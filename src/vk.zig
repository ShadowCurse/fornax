// Constants
pub const VK_MAX_PHYSICAL_DEVICE_NAME_SIZE: u32 = 256;
pub const VK_UUID_SIZE: u32 = 16;
pub const VK_LUID_SIZE: u32 = 8;
pub const VK_MAX_EXTENSION_NAME_SIZE: u32 = 256;
pub const VK_MAX_DESCRIPTION_SIZE: u32 = 256;
pub const VK_MAX_MEMORY_TYPES: u32 = 32;
pub const VK_MAX_MEMORY_HEAPS: u32 = 16;
pub const VK_LOD_CLAMP_NONE: f32 = 1000;
pub const VK_REMAINING_MIP_LEVELS: u32 = 4294967295;
pub const VK_REMAINING_ARRAY_LAYERS: u32 = 4294967295;
pub const VK_REMAINING_3D_SLICES_EXT: u32 = 4294967295;
pub const VK_WHOLE_SIZE: u64 = 18446744073709551615;
pub const VK_ATTACHMENT_UNUSED: u32 = 4294967295;
pub const VK_TRUE: u32 = 1;
pub const VK_FALSE: u32 = 0;
pub const VK_QUEUE_FAMILY_IGNORED: u32 = 4294967295;
pub const VK_QUEUE_FAMILY_EXTERNAL: u32 = 4294967294;
pub const VK_QUEUE_FAMILY_FOREIGN_EXT: u32 = 4294967293;
pub const VK_SUBPASS_EXTERNAL: u32 = 4294967295;
pub const VK_MAX_DEVICE_GROUP_SIZE: u32 = 32;
pub const VK_MAX_DRIVER_NAME_SIZE: u32 = 256;
pub const VK_MAX_DRIVER_INFO_SIZE: u32 = 256;
pub const VK_SHADER_UNUSED_KHR: u32 = 4294967295;
pub const VK_MAX_GLOBAL_PRIORITY_SIZE: u32 = 16;
pub const VK_MAX_SHADER_MODULE_IDENTIFIER_SIZE_EXT: u32 = 32;
pub const VK_MAX_PIPELINE_BINARY_KEY_SIZE_KHR: u32 = 32;
pub const VK_MAX_VIDEO_AV1_REFERENCES_PER_FRAME_KHR: u32 = 7;
pub const VK_MAX_VIDEO_VP9_REFERENCES_PER_FRAME_KHR: u32 = 3;
pub const VK_SHADER_INDEX_UNUSED_AMDX: u32 = 4294967295;
pub const VK_PARTITIONED_ACCELERATION_STRUCTURE_PARTITION_INDEX_GLOBAL_NV: u32 = 4294967295;
pub const VK_COMPRESSED_TRIANGLE_FORMAT_DGF1_BYTE_ALIGNMENT_AMDX: u32 = 128;
pub const VK_COMPRESSED_TRIANGLE_FORMAT_DGF1_BYTE_STRIDE_AMDX: u32 = 128;
pub const VK_MAX_PHYSICAL_DEVICE_DATA_GRAPH_OPERATION_SET_NAME_SIZE_ARM: u32 = 128;
pub const VK_DATA_GRAPH_MODEL_TOOLCHAIN_VERSION_LENGTH_QCOM: u32 = 3;
pub const VK_COMPUTE_OCCUPANCY_PRIORITY_LOW_NV: f32 = 0.25;
pub const VK_COMPUTE_OCCUPANCY_PRIORITY_NORMAL_NV: f32 = 0.5;
pub const VK_COMPUTE_OCCUPANCY_PRIORITY_HIGH_NV: f32 = 0.75;

// Base types
pub const VkSampleMask = u32;
pub const VkBool32 = u32;
pub const VkFlags = u32;
pub const VkFlags64 = u64;
pub const VkDeviceSize = u64;
pub const VkDeviceAddress = u64;
pub const VkRemoteAddressNV = *anyopaque;

// Handles
// Type enum: VK_OBJECT_TYPE_INSTANCE
pub const VkInstance = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_PHYSICAL_DEVICE
// Parent: VkInstance
pub const VkPhysicalDevice = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_DEVICE
// Parent: VkPhysicalDevice
pub const VkDevice = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_QUEUE
// Parent: VkDevice
pub const VkQueue = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_COMMAND_BUFFER
// Parent: VkCommandPool
pub const VkCommandBuffer = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_DEVICE_MEMORY
// Parent: VkDevice
pub const VkDeviceMemory = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_COMMAND_POOL
// Parent: VkDevice
pub const VkCommandPool = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_BUFFER
// Parent: VkDevice
pub const VkBuffer = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_BUFFER_VIEW
// Parent: VkDevice
pub const VkBufferView = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_IMAGE
// Parent: VkDevice
pub const VkImage = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_IMAGE_VIEW
// Parent: VkDevice
pub const VkImageView = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_SHADER_MODULE
// Parent: VkDevice
pub const VkShaderModule = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_PIPELINE
// Parent: VkDevice
pub const VkPipeline = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_PIPELINE_LAYOUT
// Parent: VkDevice
pub const VkPipelineLayout = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_SAMPLER
// Parent: VkDevice
pub const VkSampler = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_DESCRIPTOR_SET
// Parent: VkDescriptorPool
pub const VkDescriptorSet = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT
// Parent: VkDevice
pub const VkDescriptorSetLayout = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_DESCRIPTOR_POOL
// Parent: VkDevice
pub const VkDescriptorPool = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_FENCE
// Parent: VkDevice
pub const VkFence = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_SEMAPHORE
// Parent: VkDevice
pub const VkSemaphore = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_EVENT
// Parent: VkDevice
pub const VkEvent = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_QUERY_POOL
// Parent: VkDevice
pub const VkQueryPool = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_FRAMEBUFFER
// Parent: VkDevice
pub const VkFramebuffer = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_RENDER_PASS
// Parent: VkDevice
pub const VkRenderPass = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_PIPELINE_CACHE
// Parent: VkDevice
pub const VkPipelineCache = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_PIPELINE_BINARY_KHR
// Parent: VkDevice
pub const VkPipelineBinaryKHR = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NV
// Parent: VkDevice
pub const VkIndirectCommandsLayoutNV = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_EXT
// Parent: VkDevice
pub const VkIndirectCommandsLayoutEXT = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_INDIRECT_EXECUTION_SET_EXT
// Parent: VkDevice
pub const VkIndirectExecutionSetEXT = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE
// Parent: VkDevice
pub const VkDescriptorUpdateTemplate = enum(u64) { none = 0, _ };
pub const VkDescriptorUpdateTemplateKHR = VkDescriptorUpdateTemplate;
// Type enum: VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION
// Parent: VkDevice
pub const VkSamplerYcbcrConversion = enum(u64) { none = 0, _ };
pub const VkSamplerYcbcrConversionKHR = VkSamplerYcbcrConversion;
// Type enum: VK_OBJECT_TYPE_VALIDATION_CACHE_EXT
// Parent: VkDevice
pub const VkValidationCacheEXT = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_KHR
// Parent: VkDevice
pub const VkAccelerationStructureKHR = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV
// Parent: VkDevice
pub const VkAccelerationStructureNV = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_PERFORMANCE_CONFIGURATION_INTEL
// Parent: VkDevice
pub const VkPerformanceConfigurationINTEL = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_BUFFER_COLLECTION_FUCHSIA
// Parent: VkDevice
pub const VkBufferCollectionFUCHSIA = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_DEFERRED_OPERATION_KHR
// Parent: VkDevice
pub const VkDeferredOperationKHR = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_PRIVATE_DATA_SLOT
// Parent: VkDevice
pub const VkPrivateDataSlot = enum(u64) { none = 0, _ };
pub const VkPrivateDataSlotEXT = VkPrivateDataSlot;
// Type enum: VK_OBJECT_TYPE_CU_MODULE_NVX
// Parent: VkDevice
pub const VkCuModuleNVX = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_CU_FUNCTION_NVX
// Parent: VkDevice
pub const VkCuFunctionNVX = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_OPTICAL_FLOW_SESSION_NV
// Parent: VkDevice
pub const VkOpticalFlowSessionNV = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_MICROMAP_EXT
// Parent: VkDevice
pub const VkMicromapEXT = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_SHADER_EXT
// Parent: VkDevice
pub const VkShaderEXT = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_TENSOR_ARM
// Parent: VkDevice
pub const VkTensorARM = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_TENSOR_VIEW_ARM
// Parent: VkDevice
pub const VkTensorViewARM = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_DATA_GRAPH_PIPELINE_SESSION_ARM
// Parent: VkDevice
pub const VkDataGraphPipelineSessionARM = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_DISPLAY_KHR
// Parent: VkPhysicalDevice
pub const VkDisplayKHR = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_DISPLAY_MODE_KHR
// Parent: VkDisplayKHR
pub const VkDisplayModeKHR = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_SURFACE_KHR
// Parent: VkInstance
pub const VkSurfaceKHR = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_SWAPCHAIN_KHR
// Parent: VkDevice
pub const VkSwapchainKHR = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT
// Parent: VkInstance
pub const VkDebugReportCallbackEXT = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_DEBUG_UTILS_MESSENGER_EXT
// Parent: VkInstance
pub const VkDebugUtilsMessengerEXT = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_VIDEO_SESSION_KHR
// Parent: VkDevice
pub const VkVideoSessionKHR = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_VIDEO_SESSION_PARAMETERS_KHR
// Parent: VkVideoSessionKHR
pub const VkVideoSessionParametersKHR = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_SEMAPHORE_SCI_SYNC_POOL_NV
// Parent: VkDevice
pub const VkSemaphoreSciSyncPoolNV = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_CUDA_MODULE_NV
// Parent: VkDevice
pub const VkCudaModuleNV = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_CUDA_FUNCTION_NV
// Parent: VkDevice
pub const VkCudaFunctionNV = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_EXTERNAL_COMPUTE_QUEUE_NV
// Parent: VkDevice
pub const VkExternalComputeQueueNV = enum(u64) { none = 0, _ };

// Empty bitmasks
const VkPipelineDynamicStateCreateFlags = packed struct(u32) {
    _: 32 = 0,
};
const VkPipelineMultisampleStateCreateFlags = packed struct(u32) {
    _: 32 = 0,
};
const VkPipelineRasterizationStateCreateFlags = packed struct(u32) {
    _: 32 = 0,
};
const VkPipelineViewportStateCreateFlags = packed struct(u32) {
    _: 32 = 0,
};
const VkPipelineTessellationStateCreateFlags = packed struct(u32) {
    _: 32 = 0,
};
const VkPipelineInputAssemblyStateCreateFlags = packed struct(u32) {
    _: 32 = 0,
};
const VkPipelineVertexInputStateCreateFlags = packed struct(u32) {
    _: 32 = 0,
};
const VkBufferViewCreateFlags = packed struct(u32) {
    _: 32 = 0,
};
const VkDeviceCreateFlags = packed struct(u32) {
    _: 32 = 0,
};
const VkSemaphoreCreateFlags = packed struct(u32) {
    _: 32 = 0,
};
const VkShaderModuleCreateFlags = packed struct(u32) {
    _: 32 = 0,
};
const VkDescriptorPoolResetFlags = packed struct(u32) {
    _: 32 = 0,
};
const VkPrivateDataSlotCreateFlags = packed struct(u32) {
    _: 32 = 0,
};
const VkDescriptorUpdateTemplateCreateFlags = packed struct(u32) {
    _: 32 = 0,
};
const VkAccelerationStructureMotionInfoFlagsNV = packed struct(u32) {
    _: 32 = 0,
};
const VkAccelerationStructureMotionInstanceFlagsNV = packed struct(u32) {
    _: 32 = 0,
};
const VkDirectDriverLoadingFlagsLUNARG = packed struct(u32) {
    _: 32 = 0,
};
const VkDisplayModeCreateFlagsKHR = packed struct(u32) {
    _: 32 = 0,
};
const VkDisplaySurfaceCreateFlagsKHR = packed struct(u32) {
    _: 32 = 0,
};
const VkAndroidSurfaceCreateFlagsKHR = packed struct(u32) {
    _: 32 = 0,
};
const VkViSurfaceCreateFlagsNN = packed struct(u32) {
    _: 32 = 0,
};
const VkWaylandSurfaceCreateFlagsKHR = packed struct(u32) {
    _: 32 = 0,
};
const VkWin32SurfaceCreateFlagsKHR = packed struct(u32) {
    _: 32 = 0,
};
const VkXlibSurfaceCreateFlagsKHR = packed struct(u32) {
    _: 32 = 0,
};
const VkXcbSurfaceCreateFlagsKHR = packed struct(u32) {
    _: 32 = 0,
};
const VkDirectFBSurfaceCreateFlagsEXT = packed struct(u32) {
    _: 32 = 0,
};
const VkIOSSurfaceCreateFlagsMVK = packed struct(u32) {
    _: 32 = 0,
};
const VkMacOSSurfaceCreateFlagsMVK = packed struct(u32) {
    _: 32 = 0,
};
const VkMetalSurfaceCreateFlagsEXT = packed struct(u32) {
    _: 32 = 0,
};
const VkImagePipeSurfaceCreateFlagsFUCHSIA = packed struct(u32) {
    _: 32 = 0,
};
const VkStreamDescriptorSurfaceCreateFlagsGGP = packed struct(u32) {
    _: 32 = 0,
};
const VkHeadlessSurfaceCreateFlagsEXT = packed struct(u32) {
    _: 32 = 0,
};
const VkScreenSurfaceCreateFlagsQNX = packed struct(u32) {
    _: 32 = 0,
};
const VkCommandPoolTrimFlags = packed struct(u32) {
    _: 32 = 0,
};
const VkPipelineViewportSwizzleStateCreateFlagsNV = packed struct(u32) {
    _: 32 = 0,
};
const VkPipelineDiscardRectangleStateCreateFlagsEXT = packed struct(u32) {
    _: 32 = 0,
};
const VkPipelineCoverageToColorStateCreateFlagsNV = packed struct(u32) {
    _: 32 = 0,
};
const VkPipelineCoverageModulationStateCreateFlagsNV = packed struct(u32) {
    _: 32 = 0,
};
const VkPipelineCoverageReductionStateCreateFlagsNV = packed struct(u32) {
    _: 32 = 0,
};
const VkValidationCacheCreateFlagsEXT = packed struct(u32) {
    _: 32 = 0,
};
const VkDebugUtilsMessengerCreateFlagsEXT = packed struct(u32) {
    _: 32 = 0,
};
const VkDebugUtilsMessengerCallbackDataFlagsEXT = packed struct(u32) {
    _: 32 = 0,
};
const VkDeviceMemoryReportFlagsEXT = packed struct(u32) {
    _: 32 = 0,
};
const VkPipelineRasterizationConservativeStateCreateFlagsEXT = packed struct(u32) {
    _: 32 = 0,
};
const VkPipelineRasterizationStateStreamCreateFlagsEXT = packed struct(u32) {
    _: 32 = 0,
};
const VkPipelineRasterizationDepthClipStateCreateFlagsEXT = packed struct(u32) {
    _: 32 = 0,
};
const VkImageFormatConstraintsFlagsFUCHSIA = packed struct(u32) {
    _: 32 = 0,
};
const VkSurfaceCreateFlagsOHOS = packed struct(u32) {
    _: 32 = 0,
};
const VkPerformanceCounterDescriptionFlagsARM = packed struct(u32) {
    _: 32 = 0,
};
const VkVideoBeginCodingFlagsKHR = packed struct(u32) {
    _: 32 = 0,
};
const VkVideoEndCodingFlagsKHR = packed struct(u32) {
    _: 32 = 0,
};
const VkVideoDecodeFlagsKHR = packed struct(u32) {
    _: 32 = 0,
};
const VkVideoEncodeRateControlFlagsKHR = packed struct(u32) {
    _: 32 = 0,
};

// Bitmasks
pub const VkFramebufferCreateFlags = packed struct(u32) {
    // Extension: VK_GRAPHICS_VERSION_1_2
    // Alias: VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT_KHR
    // bit: 0
    VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT: bool = false,
    _: u31 = 0,
};
pub const VkQueryPoolCreateFlags = packed struct(u32) {
    // Extension: VK_KHR_maintenance9
    // bit: 0
    VK_QUERY_POOL_CREATE_RESET_BIT_KHR: bool = false,
    _: u31 = 0,
};
pub const VkRenderPassCreateFlags = packed struct(u32) {
    _0: u1 = 0,
    // Extension: VK_QCOM_render_pass_transform
    // bit: 1
    VK_RENDER_PASS_CREATE_TRANSFORM_BIT_QCOM: bool = false,
    // Extension: VK_VALVE_fragment_density_map_layered
    // bit: 2
    VK_RENDER_PASS_CREATE_PER_LAYER_FRAGMENT_DENSITY_BIT_VALVE: bool = false,
    _: u29 = 0,
};
pub const VkSamplerCreateFlags = packed struct(u32) {
    // Extension: VK_EXT_fragment_density_map
    // bit: 0
    VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT: bool = false,
    // Extension: VK_EXT_fragment_density_map
    // bit: 1
    VK_SAMPLER_CREATE_SUBSAMPLED_COARSE_RECONSTRUCTION_BIT_EXT: bool = false,
    // Extension: VK_EXT_non_seamless_cube_map
    // bit: 2
    VK_SAMPLER_CREATE_NON_SEAMLESS_CUBE_MAP_BIT_EXT: bool = false,
    // Extension: VK_EXT_descriptor_buffer
    // bit: 3
    VK_SAMPLER_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT: bool = false,
    // Extension: VK_QCOM_image_processing
    // bit: 4
    VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM: bool = false,
    _: u27 = 0,
};
pub const VkPipelineLayoutCreateFlags = packed struct(u32) {
    _0: u1 = 0,
    // Extension: VK_EXT_graphics_pipeline_library
    // bit: 1
    VK_PIPELINE_LAYOUT_CREATE_INDEPENDENT_SETS_BIT_EXT: bool = false,
    _: u30 = 0,
};
pub const VkPipelineCacheCreateFlags = packed struct(u32) {
    // Extension: VK_COMPUTE_VERSION_1_3
    // Alias: VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT_EXT
    // bit: 0
    VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT: bool = false,
    // Extension: VKSC_VERSION_1_0
    // bit: 1
    VK_PIPELINE_CACHE_CREATE_READ_ONLY_BIT: bool = false,
    // Extension: VKSC_VERSION_1_0
    // bit: 2
    VK_PIPELINE_CACHE_CREATE_USE_APPLICATION_STORAGE_BIT: bool = false,
    // Extension: VK_KHR_maintenance8
    // bit: 3
    VK_PIPELINE_CACHE_CREATE_INTERNALLY_SYNCHRONIZED_MERGE_BIT_KHR: bool = false,
    _: u28 = 0,
};
pub const VkPipelineDepthStencilStateCreateFlags = packed struct(u32) {
    // Extension: VK_EXT_rasterization_order_attachment_access
    // Alias: VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_ARM
    // bit: 0
    VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_EXT: bool = false,
    // Extension: VK_EXT_rasterization_order_attachment_access
    // Alias: VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_ARM
    // bit: 1
    VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_EXT: bool = false,
    _: u30 = 0,
};
pub const VkPipelineColorBlendStateCreateFlags = packed struct(u32) {
    // Extension: VK_EXT_rasterization_order_attachment_access
    // Alias: VK_PIPELINE_COLOR_BLEND_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_BIT_ARM
    // bit: 0
    VK_PIPELINE_COLOR_BLEND_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_BIT_EXT: bool = false,
    _: u31 = 0,
};
pub const VkPipelineShaderStageCreateFlags = packed struct(u32) {
    // Extension: VK_COMPUTE_VERSION_1_3
    // Alias: VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT
    // bit: 0
    VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT: bool = false,
    // Extension: VK_COMPUTE_VERSION_1_3
    // Alias: VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT
    // bit: 1
    VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT: bool = false,
    _: u30 = 0,
};
pub const VkDescriptorSetLayoutCreateFlags = packed struct(u32) {
    // Extension: VK_COMPUTE_VERSION_1_4
    // Alias: VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR
    // bit: 0
    VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT: bool = false,
    // Extension: VK_COMPUTE_VERSION_1_2
    // Alias: VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT
    // bit: 1
    VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT: bool = false,
    // Extension: VK_EXT_mutable_descriptor_type
    // Alias: VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_VALVE
    // bit: 2
    VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_EXT: bool = false,
    _2: u1 = 0,
    // Extension: VK_EXT_descriptor_buffer
    // bit: 4
    VK_DESCRIPTOR_SET_LAYOUT_CREATE_DESCRIPTOR_BUFFER_BIT_EXT: bool = false,
    // Extension: VK_EXT_descriptor_buffer
    // bit: 5
    VK_DESCRIPTOR_SET_LAYOUT_CREATE_EMBEDDED_IMMUTABLE_SAMPLERS_BIT_EXT: bool = false,
    // Extension: VK_NV_per_stage_descriptor_set
    // bit: 6
    VK_DESCRIPTOR_SET_LAYOUT_CREATE_PER_STAGE_BIT_NV: bool = false,
    // Extension: VK_NV_device_generated_commands_compute
    // bit: 7
    VK_DESCRIPTOR_SET_LAYOUT_CREATE_INDIRECT_BINDABLE_BIT_NV: bool = false,
    _: u24 = 0,
};
pub const VkInstanceCreateFlags = packed struct(u32) {
    // Extension: VK_KHR_portability_enumeration
    // bit: 0
    VK_INSTANCE_CREATE_ENUMERATE_PORTABILITY_BIT_KHR: bool = false,
    _: u31 = 0,
};
pub const VkDeviceQueueCreateFlags = packed struct(u32) {
    // Extension: VK_BASE_VERSION_1_1
    // bit: 0
    VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT: bool = false,
    _: u31 = 0,
};
pub const VkQueueFlags = packed struct(u32) {
    // Comment: Queue supports graphics operations
    // bit: 0
    VK_QUEUE_GRAPHICS_BIT: bool = false,
    // Comment: Queue supports compute operations
    // bit: 1
    VK_QUEUE_COMPUTE_BIT: bool = false,
    // Comment: Queue supports transfer operations
    // bit: 2
    VK_QUEUE_TRANSFER_BIT: bool = false,
    // Comment: Queue supports sparse resource memory management operations
    // bit: 3
    VK_QUEUE_SPARSE_BINDING_BIT: bool = false,
    // Extension: VK_BASE_VERSION_1_1
    // bit: 4
    VK_QUEUE_PROTECTED_BIT: bool = false,
    // Extension: VK_KHR_video_decode_queue
    // bit: 5
    VK_QUEUE_VIDEO_DECODE_BIT_KHR: bool = false,
    // Extension: VK_KHR_video_encode_queue
    // bit: 6
    VK_QUEUE_VIDEO_ENCODE_BIT_KHR: bool = false,
    _6: u1 = 0,
    // Extension: VK_NV_optical_flow
    // bit: 8
    VK_QUEUE_OPTICAL_FLOW_BIT_NV: bool = false,
    _8: u1 = 0,
    // Extension: VK_ARM_data_graph
    // bit: 10
    VK_QUEUE_DATA_GRAPH_BIT_ARM: bool = false,
    _: u21 = 0,
};
pub const VkMemoryPropertyFlags = packed struct(u32) {
    // Comment: If otherwise stated, then allocate memory on device
    // bit: 0
    VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT: bool = false,
    // Comment: Memory is mappable by host
    // bit: 1
    VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT: bool = false,
    // Comment: Memory will have i/o coherency. If not set, application may need to use vkFlushMappedMemoryRanges and vkInvalidateMappedMemoryRanges to flush/invalidate host cache
    // bit: 2
    VK_MEMORY_PROPERTY_HOST_COHERENT_BIT: bool = false,
    // Comment: Memory will be cached by the host
    // bit: 3
    VK_MEMORY_PROPERTY_HOST_CACHED_BIT: bool = false,
    // Comment: Memory may be allocated by the driver when it is required
    // bit: 4
    VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT: bool = false,
    // Extension: VK_BASE_VERSION_1_1
    // bit: 5
    VK_MEMORY_PROPERTY_PROTECTED_BIT: bool = false,
    // Extension: VK_AMD_device_coherent_memory
    // bit: 6
    VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD: bool = false,
    // Extension: VK_AMD_device_coherent_memory
    // bit: 7
    VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD: bool = false,
    // Extension: VK_NV_external_memory_rdma
    // bit: 8
    VK_MEMORY_PROPERTY_RDMA_CAPABLE_BIT_NV: bool = false,
    _: u23 = 0,
};
pub const VkMemoryHeapFlags = packed struct(u32) {
    // Comment: If set, heap represents device memory
    // bit: 0
    VK_MEMORY_HEAP_DEVICE_LOCAL_BIT: bool = false,
    // Extension: VK_BASE_VERSION_1_1
    // Alias: VK_MEMORY_HEAP_MULTI_INSTANCE_BIT_KHR
    // bit: 1
    VK_MEMORY_HEAP_MULTI_INSTANCE_BIT: bool = false,
    // Extension: VKSC_VERSION_1_0
    // bit: 2
    VK_MEMORY_HEAP_SEU_SAFE_BIT: bool = false,
    // Extension: VK_QCOM_tile_memory_heap
    // bit: 3
    VK_MEMORY_HEAP_TILE_MEMORY_BIT_QCOM: bool = false,
    _: u28 = 0,
};
pub const VkAccessFlags = packed struct(u32) {
    // Comment: Controls coherency of indirect command reads
    // bit: 0
    VK_ACCESS_INDIRECT_COMMAND_READ_BIT: bool = false,
    // Comment: Controls coherency of index reads
    // bit: 1
    VK_ACCESS_INDEX_READ_BIT: bool = false,
    // Comment: Controls coherency of vertex attribute reads
    // bit: 2
    VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT: bool = false,
    // Comment: Controls coherency of uniform buffer reads
    // bit: 3
    VK_ACCESS_UNIFORM_READ_BIT: bool = false,
    // Comment: Controls coherency of input attachment reads
    // bit: 4
    VK_ACCESS_INPUT_ATTACHMENT_READ_BIT: bool = false,
    // Comment: Controls coherency of shader reads
    // bit: 5
    VK_ACCESS_SHADER_READ_BIT: bool = false,
    // Comment: Controls coherency of shader writes
    // bit: 6
    VK_ACCESS_SHADER_WRITE_BIT: bool = false,
    // Comment: Controls coherency of color attachment reads
    // bit: 7
    VK_ACCESS_COLOR_ATTACHMENT_READ_BIT: bool = false,
    // Comment: Controls coherency of color attachment writes
    // bit: 8
    VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT: bool = false,
    // Comment: Controls coherency of depth/stencil attachment reads
    // bit: 9
    VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT: bool = false,
    // Comment: Controls coherency of depth/stencil attachment writes
    // bit: 10
    VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT: bool = false,
    // Comment: Controls coherency of transfer reads
    // bit: 11
    VK_ACCESS_TRANSFER_READ_BIT: bool = false,
    // Comment: Controls coherency of transfer writes
    // bit: 12
    VK_ACCESS_TRANSFER_WRITE_BIT: bool = false,
    // Comment: Controls coherency of host reads
    // bit: 13
    VK_ACCESS_HOST_READ_BIT: bool = false,
    // Comment: Controls coherency of host writes
    // bit: 14
    VK_ACCESS_HOST_WRITE_BIT: bool = false,
    // Comment: Controls coherency of memory reads
    // bit: 15
    VK_ACCESS_MEMORY_READ_BIT: bool = false,
    // Comment: Controls coherency of memory writes
    // bit: 16
    VK_ACCESS_MEMORY_WRITE_BIT: bool = false,
    // Extension: VK_EXT_device_generated_commands
    // Alias: VK_ACCESS_COMMAND_PREPROCESS_READ_BIT_NV
    // bit: 17
    VK_ACCESS_COMMAND_PREPROCESS_READ_BIT_EXT: bool = false,
    // Extension: VK_EXT_device_generated_commands
    // Alias: VK_ACCESS_COMMAND_PREPROCESS_WRITE_BIT_NV
    // bit: 18
    VK_ACCESS_COMMAND_PREPROCESS_WRITE_BIT_EXT: bool = false,
    // Extension: VK_EXT_blend_operation_advanced
    // bit: 19
    VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT: bool = false,
    // Extension: VK_EXT_conditional_rendering
    // bit: 20
    VK_ACCESS_CONDITIONAL_RENDERING_READ_BIT_EXT: bool = false,
    // Extension: VK_KHR_acceleration_structure
    // Alias: VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_NV
    // bit: 21
    VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR: bool = false,
    // Extension: VK_KHR_acceleration_structure
    // Alias: VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_NV
    // bit: 22
    VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_KHR: bool = false,
    // Extension: VK_KHR_fragment_shading_rate
    // Alias: VK_ACCESS_SHADING_RATE_IMAGE_READ_BIT_NV
    // bit: 23
    VK_ACCESS_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR: bool = false,
    // Extension: VK_EXT_fragment_density_map
    // bit: 24
    VK_ACCESS_FRAGMENT_DENSITY_MAP_READ_BIT_EXT: bool = false,
    // Extension: VK_EXT_transform_feedback
    // bit: 25
    VK_ACCESS_TRANSFORM_FEEDBACK_WRITE_BIT_EXT: bool = false,
    // Extension: VK_EXT_transform_feedback
    // bit: 26
    VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT: bool = false,
    // Extension: VK_EXT_transform_feedback
    // bit: 27
    VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT: bool = false,
    _: u4 = 0,
};
pub const VkBufferUsageFlags = packed struct(u32) {
    // Comment: Can be used as a source of transfer operations
    // bit: 0
    VK_BUFFER_USAGE_TRANSFER_SRC_BIT: bool = false,
    // Comment: Can be used as a destination of transfer operations
    // bit: 1
    VK_BUFFER_USAGE_TRANSFER_DST_BIT: bool = false,
    // Comment: Can be used as TBO
    // bit: 2
    VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT: bool = false,
    // Comment: Can be used as IBO
    // bit: 3
    VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT: bool = false,
    // Comment: Can be used as UBO
    // bit: 4
    VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT: bool = false,
    // Comment: Can be used as SSBO
    // bit: 5
    VK_BUFFER_USAGE_STORAGE_BUFFER_BIT: bool = false,
    // Comment: Can be used as source of fixed-function index fetch (index buffer)
    // bit: 6
    VK_BUFFER_USAGE_INDEX_BUFFER_BIT: bool = false,
    // Comment: Can be used as source of fixed-function vertex fetch (VBO)
    // bit: 7
    VK_BUFFER_USAGE_VERTEX_BUFFER_BIT: bool = false,
    // Comment: Can be the source of indirect parameters (e.g. indirect buffer, parameter buffer)
    // bit: 8
    VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT: bool = false,
    // Extension: VK_EXT_conditional_rendering
    // bit: 9
    VK_BUFFER_USAGE_CONDITIONAL_RENDERING_BIT_EXT: bool = false,
    // Extension: VK_KHR_ray_tracing_pipeline
    // Alias: VK_BUFFER_USAGE_RAY_TRACING_BIT_NV
    // bit: 10
    VK_BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR: bool = false,
    // Extension: VK_EXT_transform_feedback
    // bit: 11
    VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT: bool = false,
    // Extension: VK_EXT_transform_feedback
    // bit: 12
    VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT: bool = false,
    // Extension: VK_KHR_video_decode_queue
    // bit: 13
    VK_BUFFER_USAGE_VIDEO_DECODE_SRC_BIT_KHR: bool = false,
    // Extension: VK_KHR_video_decode_queue
    // bit: 14
    VK_BUFFER_USAGE_VIDEO_DECODE_DST_BIT_KHR: bool = false,
    // Extension: VK_KHR_video_encode_queue
    // bit: 15
    VK_BUFFER_USAGE_VIDEO_ENCODE_DST_BIT_KHR: bool = false,
    // Extension: VK_KHR_video_encode_queue
    // bit: 16
    VK_BUFFER_USAGE_VIDEO_ENCODE_SRC_BIT_KHR: bool = false,
    // Extension: VK_BASE_VERSION_1_2
    // Alias: VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_EXT
    // Alias: VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_KHR
    // bit: 17
    VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT: bool = false,
    _17: u1 = 0,
    // Extension: VK_KHR_acceleration_structure
    // bit: 19
    VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR: bool = false,
    // Extension: VK_KHR_acceleration_structure
    // bit: 20
    VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR: bool = false,
    // Extension: VK_EXT_descriptor_buffer
    // bit: 21
    VK_BUFFER_USAGE_SAMPLER_DESCRIPTOR_BUFFER_BIT_EXT: bool = false,
    // Extension: VK_EXT_descriptor_buffer
    // bit: 22
    VK_BUFFER_USAGE_RESOURCE_DESCRIPTOR_BUFFER_BIT_EXT: bool = false,
    // Extension: VK_EXT_opacity_micromap
    // bit: 23
    VK_BUFFER_USAGE_MICROMAP_BUILD_INPUT_READ_ONLY_BIT_EXT: bool = false,
    // Extension: VK_EXT_opacity_micromap
    // bit: 24
    VK_BUFFER_USAGE_MICROMAP_STORAGE_BIT_EXT: bool = false,
    // Extension: VK_AMDX_shader_enqueue
    // bit: 25
    VK_BUFFER_USAGE_EXECUTION_GRAPH_SCRATCH_BIT_AMDX: bool = false,
    // Extension: VK_EXT_descriptor_buffer
    // bit: 26
    VK_BUFFER_USAGE_PUSH_DESCRIPTORS_DESCRIPTOR_BUFFER_BIT_EXT: bool = false,
    // Extension: VK_QCOM_tile_memory_heap
    // bit: 27
    VK_BUFFER_USAGE_TILE_MEMORY_BIT_QCOM: bool = false,
    _: u4 = 0,
};
pub const VkBufferCreateFlags = packed struct(u32) {
    // Comment: Buffer should support sparse backing
    // bit: 0
    VK_BUFFER_CREATE_SPARSE_BINDING_BIT: bool = false,
    // Comment: Buffer should support sparse backing with partial residency
    // bit: 1
    VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT: bool = false,
    // Comment: Buffer should support constant data access to physical memory ranges mapped into multiple locations of sparse buffers
    // bit: 2
    VK_BUFFER_CREATE_SPARSE_ALIASED_BIT: bool = false,
    // Extension: VK_BASE_VERSION_1_1
    // bit: 3
    VK_BUFFER_CREATE_PROTECTED_BIT: bool = false,
    // Extension: VK_BASE_VERSION_1_2
    // Alias: VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT
    // Alias: VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR
    // bit: 4
    VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT: bool = false,
    // Extension: VK_EXT_descriptor_buffer
    // bit: 5
    VK_BUFFER_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT: bool = false,
    // Extension: VK_KHR_video_maintenance1
    // bit: 6
    VK_BUFFER_CREATE_VIDEO_PROFILE_INDEPENDENT_BIT_KHR: bool = false,
    _: u25 = 0,
};
pub const VkShaderStageFlags = packed struct(u32) {
    // bit: 0
    VK_SHADER_STAGE_VERTEX_BIT: bool = false,
    // bit: 1
    VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT: bool = false,
    // bit: 2
    VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT: bool = false,
    // bit: 3
    VK_SHADER_STAGE_GEOMETRY_BIT: bool = false,
    // bit: 4
    VK_SHADER_STAGE_FRAGMENT_BIT: bool = false,
    // bit: 5
    VK_SHADER_STAGE_COMPUTE_BIT: bool = false,
    // Extension: VK_EXT_mesh_shader
    // Alias: VK_SHADER_STAGE_TASK_BIT_NV
    // bit: 6
    VK_SHADER_STAGE_TASK_BIT_EXT: bool = false,
    // Extension: VK_EXT_mesh_shader
    // Alias: VK_SHADER_STAGE_MESH_BIT_NV
    // bit: 7
    VK_SHADER_STAGE_MESH_BIT_EXT: bool = false,
    // Extension: VK_KHR_ray_tracing_pipeline
    // Alias: VK_SHADER_STAGE_RAYGEN_BIT_NV
    // bit: 8
    VK_SHADER_STAGE_RAYGEN_BIT_KHR: bool = false,
    // Extension: VK_KHR_ray_tracing_pipeline
    // Alias: VK_SHADER_STAGE_ANY_HIT_BIT_NV
    // bit: 9
    VK_SHADER_STAGE_ANY_HIT_BIT_KHR: bool = false,
    // Extension: VK_KHR_ray_tracing_pipeline
    // Alias: VK_SHADER_STAGE_CLOSEST_HIT_BIT_NV
    // bit: 10
    VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR: bool = false,
    // Extension: VK_KHR_ray_tracing_pipeline
    // Alias: VK_SHADER_STAGE_MISS_BIT_NV
    // bit: 11
    VK_SHADER_STAGE_MISS_BIT_KHR: bool = false,
    // Extension: VK_KHR_ray_tracing_pipeline
    // Alias: VK_SHADER_STAGE_INTERSECTION_BIT_NV
    // bit: 12
    VK_SHADER_STAGE_INTERSECTION_BIT_KHR: bool = false,
    // Extension: VK_KHR_ray_tracing_pipeline
    // Alias: VK_SHADER_STAGE_CALLABLE_BIT_NV
    // bit: 13
    VK_SHADER_STAGE_CALLABLE_BIT_KHR: bool = false,
    // Extension: VK_HUAWEI_subpass_shading
    // bit: 14
    VK_SHADER_STAGE_SUBPASS_SHADING_BIT_HUAWEI: bool = false,
    _14: u4 = 0,
    // Extension: VK_HUAWEI_cluster_culling_shader
    // bit: 19
    VK_SHADER_STAGE_CLUSTER_CULLING_BIT_HUAWEI: bool = false,
    _: u12 = 0,
    pub const VK_SHADER_STAGE_ALL_GRAPHICS: @This() = @bitCast(@as(u32, 0x1f));
    pub const VK_SHADER_STAGE_ALL: @This() = @bitCast(@as(u32, 0x7fffffff));
};
pub const VkImageUsageFlags = packed struct(u32) {
    // Comment: Can be used as a source of transfer operations
    // bit: 0
    VK_IMAGE_USAGE_TRANSFER_SRC_BIT: bool = false,
    // Comment: Can be used as a destination of transfer operations
    // bit: 1
    VK_IMAGE_USAGE_TRANSFER_DST_BIT: bool = false,
    // Comment: Can be sampled from (SAMPLED_IMAGE and COMBINED_IMAGE_SAMPLER descriptor types)
    // bit: 2
    VK_IMAGE_USAGE_SAMPLED_BIT: bool = false,
    // Comment: Can be used as storage image (STORAGE_IMAGE descriptor type)
    // bit: 3
    VK_IMAGE_USAGE_STORAGE_BIT: bool = false,
    // Comment: Can be used as framebuffer color attachment
    // bit: 4
    VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT: bool = false,
    // Comment: Can be used as framebuffer depth/stencil attachment
    // bit: 5
    VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT: bool = false,
    // Comment: Image data not needed outside of rendering
    // bit: 6
    VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT: bool = false,
    // Comment: Can be used as framebuffer input attachment
    // bit: 7
    VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT: bool = false,
    // Extension: VK_KHR_fragment_shading_rate
    // Alias: VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV
    // bit: 8
    VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR: bool = false,
    // Extension: VK_EXT_fragment_density_map
    // bit: 9
    VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT: bool = false,
    // Extension: VK_KHR_video_decode_queue
    // bit: 10
    VK_IMAGE_USAGE_VIDEO_DECODE_DST_BIT_KHR: bool = false,
    // Extension: VK_KHR_video_decode_queue
    // bit: 11
    VK_IMAGE_USAGE_VIDEO_DECODE_SRC_BIT_KHR: bool = false,
    // Extension: VK_KHR_video_decode_queue
    // bit: 12
    VK_IMAGE_USAGE_VIDEO_DECODE_DPB_BIT_KHR: bool = false,
    // Extension: VK_KHR_video_encode_queue
    // bit: 13
    VK_IMAGE_USAGE_VIDEO_ENCODE_DST_BIT_KHR: bool = false,
    // Extension: VK_KHR_video_encode_queue
    // bit: 14
    VK_IMAGE_USAGE_VIDEO_ENCODE_SRC_BIT_KHR: bool = false,
    // Extension: VK_KHR_video_encode_queue
    // bit: 15
    VK_IMAGE_USAGE_VIDEO_ENCODE_DPB_BIT_KHR: bool = false,
    _15: u2 = 0,
    // Extension: VK_HUAWEI_invocation_mask
    // bit: 18
    VK_IMAGE_USAGE_INVOCATION_MASK_BIT_HUAWEI: bool = false,
    // Extension: VK_EXT_attachment_feedback_loop_layout
    // bit: 19
    VK_IMAGE_USAGE_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT: bool = false,
    // Extension: VK_QCOM_image_processing
    // bit: 20
    VK_IMAGE_USAGE_SAMPLE_WEIGHT_BIT_QCOM: bool = false,
    // Extension: VK_QCOM_image_processing
    // bit: 21
    VK_IMAGE_USAGE_SAMPLE_BLOCK_MATCH_BIT_QCOM: bool = false,
    // Extension: VK_BASE_VERSION_1_4
    // Alias: VK_IMAGE_USAGE_HOST_TRANSFER_BIT_EXT
    // bit: 22
    VK_IMAGE_USAGE_HOST_TRANSFER_BIT: bool = false,
    // Extension: VK_ARM_tensors
    // bit: 23
    VK_IMAGE_USAGE_TENSOR_ALIASING_BIT_ARM: bool = false,
    _23: u1 = 0,
    // Extension: VK_KHR_video_encode_quantization_map
    // bit: 25
    VK_IMAGE_USAGE_VIDEO_ENCODE_QUANTIZATION_DELTA_MAP_BIT_KHR: bool = false,
    // Extension: VK_KHR_video_encode_quantization_map
    // bit: 26
    VK_IMAGE_USAGE_VIDEO_ENCODE_EMPHASIS_MAP_BIT_KHR: bool = false,
    // Extension: VK_QCOM_tile_memory_heap
    // bit: 27
    VK_IMAGE_USAGE_TILE_MEMORY_BIT_QCOM: bool = false,
    _: u4 = 0,
};
pub const VkImageCreateFlags = packed struct(u32) {
    // Comment: Image should support sparse backing
    // bit: 0
    VK_IMAGE_CREATE_SPARSE_BINDING_BIT: bool = false,
    // Comment: Image should support sparse backing with partial residency
    // bit: 1
    VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT: bool = false,
    // Comment: Image should support constant data access to physical memory ranges mapped into multiple locations of sparse images
    // bit: 2
    VK_IMAGE_CREATE_SPARSE_ALIASED_BIT: bool = false,
    // Comment: Allows image views to have different format than the base image
    // bit: 3
    VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT: bool = false,
    // Comment: Allows creating image views with cube type from the created image
    // bit: 4
    VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT: bool = false,
    // Extension: VK_BASE_VERSION_1_1
    // Alias: VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT_KHR
    // bit: 5
    VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT: bool = false,
    // Extension: VK_BASE_VERSION_1_1
    // Alias: VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR
    // bit: 6
    VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT: bool = false,
    // Extension: VK_BASE_VERSION_1_1
    // Alias: VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT_KHR
    // bit: 7
    VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT: bool = false,
    // Extension: VK_BASE_VERSION_1_1
    // Alias: VK_IMAGE_CREATE_EXTENDED_USAGE_BIT_KHR
    // bit: 8
    VK_IMAGE_CREATE_EXTENDED_USAGE_BIT: bool = false,
    // Extension: VK_BASE_VERSION_1_1
    // Alias: VK_IMAGE_CREATE_DISJOINT_BIT_KHR
    // bit: 9
    VK_IMAGE_CREATE_DISJOINT_BIT: bool = false,
    // Extension: VK_BASE_VERSION_1_1
    // Alias: VK_IMAGE_CREATE_ALIAS_BIT_KHR
    // bit: 10
    VK_IMAGE_CREATE_ALIAS_BIT: bool = false,
    // Extension: VK_BASE_VERSION_1_1
    // bit: 11
    VK_IMAGE_CREATE_PROTECTED_BIT: bool = false,
    // Extension: VK_EXT_sample_locations
    // bit: 12
    VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT: bool = false,
    // Extension: VK_NV_corner_sampled_image
    // bit: 13
    VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV: bool = false,
    // Extension: VK_EXT_fragment_density_map
    // bit: 14
    VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT: bool = false,
    // Extension: VK_EXT_fragment_density_map_offset
    // Alias: VK_IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_QCOM
    // bit: 15
    VK_IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_EXT: bool = false,
    // Extension: VK_EXT_descriptor_buffer
    // bit: 16
    VK_IMAGE_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT: bool = false,
    // Extension: VK_EXT_image_2d_view_of_3d
    // bit: 17
    VK_IMAGE_CREATE_2D_VIEW_COMPATIBLE_BIT_EXT: bool = false,
    // Extension: VK_EXT_multisampled_render_to_single_sampled
    // bit: 18
    VK_IMAGE_CREATE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_BIT_EXT: bool = false,
    _18: u1 = 0,
    // Extension: VK_KHR_video_maintenance1
    // bit: 20
    VK_IMAGE_CREATE_VIDEO_PROFILE_INDEPENDENT_BIT_KHR: bool = false,
    _: u11 = 0,
};
pub const VkImageViewCreateFlags = packed struct(u32) {
    // Extension: VK_EXT_fragment_density_map
    // bit: 0
    VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT: bool = false,
    // Extension: VK_EXT_fragment_density_map2
    // bit: 1
    VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DEFERRED_BIT_EXT: bool = false,
    // Extension: VK_EXT_descriptor_buffer
    // bit: 2
    VK_IMAGE_VIEW_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT: bool = false,
    _: u29 = 0,
};
pub const VkPipelineCreateFlags = packed struct(u32) {
    // bit: 0
    VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT: bool = false,
    // bit: 1
    VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT: bool = false,
    // bit: 2
    VK_PIPELINE_CREATE_DERIVATIVE_BIT: bool = false,
    // Extension: VK_GRAPHICS_VERSION_1_1
    // Alias: VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHR
    // bit: 3
    VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT: bool = false,
    // Extension: VK_COMPUTE_VERSION_1_1
    // Alias: VK_PIPELINE_CREATE_DISPATCH_BASE
    // Alias: VK_PIPELINE_CREATE_DISPATCH_BASE_BIT_KHR
    // Alias: VK_PIPELINE_CREATE_DISPATCH_BASE_KHR
    // bit: 4
    VK_PIPELINE_CREATE_DISPATCH_BASE_BIT: bool = false,
    // Extension: VK_NV_ray_tracing
    // bit: 5
    VK_PIPELINE_CREATE_DEFER_COMPILE_BIT_NV: bool = false,
    // Extension: VK_KHR_pipeline_executable_properties
    // bit: 6
    VK_PIPELINE_CREATE_CAPTURE_STATISTICS_BIT_KHR: bool = false,
    // Extension: VK_KHR_pipeline_executable_properties
    // bit: 7
    VK_PIPELINE_CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR: bool = false,
    // Extension: VK_COMPUTE_VERSION_1_3
    // Alias: VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT_EXT
    // bit: 8
    VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT: bool = false,
    // Extension: VK_COMPUTE_VERSION_1_3
    // Alias: VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT_EXT
    // bit: 9
    VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT: bool = false,
    // Extension: VK_EXT_graphics_pipeline_library
    // bit: 10
    VK_PIPELINE_CREATE_LINK_TIME_OPTIMIZATION_BIT_EXT: bool = false,
    // Extension: VK_KHR_pipeline_library
    // bit: 11
    VK_PIPELINE_CREATE_LIBRARY_BIT_KHR: bool = false,
    // Extension: VK_KHR_ray_tracing_pipeline
    // bit: 12
    VK_PIPELINE_CREATE_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR: bool = false,
    // Extension: VK_KHR_ray_tracing_pipeline
    // bit: 13
    VK_PIPELINE_CREATE_RAY_TRACING_SKIP_AABBS_BIT_KHR: bool = false,
    // Extension: VK_KHR_ray_tracing_pipeline
    // bit: 14
    VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR: bool = false,
    // Extension: VK_KHR_ray_tracing_pipeline
    // bit: 15
    VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR: bool = false,
    // Extension: VK_KHR_ray_tracing_pipeline
    // bit: 16
    VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR: bool = false,
    // Extension: VK_KHR_ray_tracing_pipeline
    // bit: 17
    VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR: bool = false,
    // Extension: VK_NV_device_generated_commands
    // bit: 18
    VK_PIPELINE_CREATE_INDIRECT_BINDABLE_BIT_NV: bool = false,
    // Extension: VK_KHR_ray_tracing_pipeline
    // bit: 19
    VK_PIPELINE_CREATE_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR: bool = false,
    // Extension: VK_NV_ray_tracing_motion_blur
    // bit: 20
    VK_PIPELINE_CREATE_RAY_TRACING_ALLOW_MOTION_BIT_NV: bool = false,
    // Extension: VK_KHR_fragment_shading_rate
    // Alias: VK_PIPELINE_RASTERIZATION_STATE_CREATE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR
    // bit: 21
    VK_PIPELINE_CREATE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR: bool = false,
    // Extension: VK_EXT_fragment_density_map
    // Alias: VK_PIPELINE_RASTERIZATION_STATE_CREATE_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT
    // bit: 22
    VK_PIPELINE_CREATE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT: bool = false,
    // Extension: VK_EXT_graphics_pipeline_library
    // bit: 23
    VK_PIPELINE_CREATE_RETAIN_LINK_TIME_OPTIMIZATION_INFO_BIT_EXT: bool = false,
    // Extension: VK_EXT_opacity_micromap
    // bit: 24
    VK_PIPELINE_CREATE_RAY_TRACING_OPACITY_MICROMAP_BIT_EXT: bool = false,
    // Extension: VK_EXT_attachment_feedback_loop_layout
    // bit: 25
    VK_PIPELINE_CREATE_COLOR_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT: bool = false,
    // Extension: VK_EXT_attachment_feedback_loop_layout
    // bit: 26
    VK_PIPELINE_CREATE_DEPTH_STENCIL_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT: bool = false,
    // Extension: VK_COMPUTE_VERSION_1_4
    // Alias: VK_PIPELINE_CREATE_NO_PROTECTED_ACCESS_BIT_EXT
    // bit: 27
    VK_PIPELINE_CREATE_NO_PROTECTED_ACCESS_BIT: bool = false,
    // Extension: VK_NV_displacement_micromap
    // bit: 28
    VK_PIPELINE_CREATE_RAY_TRACING_DISPLACEMENT_MICROMAP_BIT_NV: bool = false,
    // Extension: VK_EXT_descriptor_buffer
    // bit: 29
    VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT: bool = false,
    // Extension: VK_COMPUTE_VERSION_1_4
    // Alias: VK_PIPELINE_CREATE_PROTECTED_ACCESS_ONLY_BIT_EXT
    // bit: 30
    VK_PIPELINE_CREATE_PROTECTED_ACCESS_ONLY_BIT: bool = false,
    _: u1 = 0,
};
pub const VkColorComponentFlags = packed struct(u32) {
    // bit: 0
    VK_COLOR_COMPONENT_R_BIT: bool = false,
    // bit: 1
    VK_COLOR_COMPONENT_G_BIT: bool = false,
    // bit: 2
    VK_COLOR_COMPONENT_B_BIT: bool = false,
    // bit: 3
    VK_COLOR_COMPONENT_A_BIT: bool = false,
    _: u28 = 0,
};
pub const VkFenceCreateFlags = packed struct(u32) {
    // bit: 0
    VK_FENCE_CREATE_SIGNALED_BIT: bool = false,
    _: u31 = 0,
};
pub const VkFormatFeatureFlags = packed struct(u32) {
    // Comment: Format can be used for sampled images (SAMPLED_IMAGE and COMBINED_IMAGE_SAMPLER descriptor types)
    // bit: 0
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT: bool = false,
    // Comment: Format can be used for storage images (STORAGE_IMAGE descriptor type)
    // bit: 1
    VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT: bool = false,
    // Comment: Format supports atomic operations in case it is used for storage images
    // bit: 2
    VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT: bool = false,
    // Comment: Format can be used for uniform texel buffers (TBOs)
    // bit: 3
    VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT: bool = false,
    // Comment: Format can be used for storage texel buffers (IBOs)
    // bit: 4
    VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT: bool = false,
    // Comment: Format supports atomic operations in case it is used for storage texel buffers
    // bit: 5
    VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT: bool = false,
    // Comment: Format can be used for vertex buffers (VBOs)
    // bit: 6
    VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT: bool = false,
    // Comment: Format can be used for color attachment images
    // bit: 7
    VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT: bool = false,
    // Comment: Format supports blending in case it is used for color attachment images
    // bit: 8
    VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT: bool = false,
    // Comment: Format can be used for depth/stencil attachment images
    // bit: 9
    VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT: bool = false,
    // Comment: Format can be used as the source image of blits with vkCmdBlitImage
    // bit: 10
    VK_FORMAT_FEATURE_BLIT_SRC_BIT: bool = false,
    // Comment: Format can be used as the destination image of blits with vkCmdBlitImage
    // bit: 11
    VK_FORMAT_FEATURE_BLIT_DST_BIT: bool = false,
    // Comment: Format can be filtered with VK_FILTER_LINEAR when being sampled
    // bit: 12
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT: bool = false,
    // Extension: VK_EXT_filter_cubic
    // Alias: VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG
    // bit: 13
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT: bool = false,
    // Extension: VK_BASE_VERSION_1_1
    // Alias: VK_FORMAT_FEATURE_TRANSFER_SRC_BIT_KHR
    // bit: 14
    VK_FORMAT_FEATURE_TRANSFER_SRC_BIT: bool = false,
    // Extension: VK_BASE_VERSION_1_1
    // Alias: VK_FORMAT_FEATURE_TRANSFER_DST_BIT_KHR
    // bit: 15
    VK_FORMAT_FEATURE_TRANSFER_DST_BIT: bool = false,
    // Extension: VK_COMPUTE_VERSION_1_2
    // Alias: VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT_EXT
    // bit: 16
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT: bool = false,
    // Extension: VK_COMPUTE_VERSION_1_1
    // Alias: VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT_KHR
    // bit: 17
    VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT: bool = false,
    // Extension: VK_COMPUTE_VERSION_1_1
    // Alias: VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR
    // bit: 18
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT: bool = false,
    // Extension: VK_COMPUTE_VERSION_1_1
    // Alias: VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR
    // bit: 19
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT: bool = false,
    // Extension: VK_COMPUTE_VERSION_1_1
    // Alias: VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR
    // bit: 20
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT: bool = false,
    // Extension: VK_COMPUTE_VERSION_1_1
    // Alias: VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR
    // bit: 21
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT: bool = false,
    // Extension: VK_COMPUTE_VERSION_1_1
    // Alias: VK_FORMAT_FEATURE_DISJOINT_BIT_KHR
    // bit: 22
    VK_FORMAT_FEATURE_DISJOINT_BIT: bool = false,
    // Extension: VK_COMPUTE_VERSION_1_1
    // Alias: VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT_KHR
    // bit: 23
    VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT: bool = false,
    // Extension: VK_EXT_fragment_density_map
    // bit: 24
    VK_FORMAT_FEATURE_FRAGMENT_DENSITY_MAP_BIT_EXT: bool = false,
    // Extension: VK_KHR_video_decode_queue
    // bit: 25
    VK_FORMAT_FEATURE_VIDEO_DECODE_OUTPUT_BIT_KHR: bool = false,
    // Extension: VK_KHR_video_decode_queue
    // bit: 26
    VK_FORMAT_FEATURE_VIDEO_DECODE_DPB_BIT_KHR: bool = false,
    // Extension: VK_KHR_video_encode_queue
    // bit: 27
    VK_FORMAT_FEATURE_VIDEO_ENCODE_INPUT_BIT_KHR: bool = false,
    // Extension: VK_KHR_video_encode_queue
    // bit: 28
    VK_FORMAT_FEATURE_VIDEO_ENCODE_DPB_BIT_KHR: bool = false,
    // Extension: VK_KHR_acceleration_structure
    // bit: 29
    VK_FORMAT_FEATURE_ACCELERATION_STRUCTURE_VERTEX_BUFFER_BIT_KHR: bool = false,
    // Extension: VK_KHR_fragment_shading_rate
    // bit: 30
    VK_FORMAT_FEATURE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR: bool = false,
    _: u1 = 0,
};
pub const VkQueryControlFlags = packed struct(u32) {
    // Comment: Require precise results to be collected by the query
    // bit: 0
    VK_QUERY_CONTROL_PRECISE_BIT: bool = false,
    _: u31 = 0,
};
pub const VkQueryResultFlags = packed struct(u32) {
    // Comment: Results of the queries are written to the destination buffer as 64-bit values
    // bit: 0
    VK_QUERY_RESULT_64_BIT: bool = false,
    // Comment: Results of the queries are waited on before proceeding with the result copy
    // bit: 1
    VK_QUERY_RESULT_WAIT_BIT: bool = false,
    // Comment: Besides the results of the query, the availability of the results is also written
    // bit: 2
    VK_QUERY_RESULT_WITH_AVAILABILITY_BIT: bool = false,
    // Comment: Copy the partial results of the query even if the final results are not available
    // bit: 3
    VK_QUERY_RESULT_PARTIAL_BIT: bool = false,
    // Extension: VK_KHR_video_queue
    // bit: 4
    VK_QUERY_RESULT_WITH_STATUS_BIT_KHR: bool = false,
    _: u27 = 0,
};
pub const VkEventCreateFlags = packed struct(u32) {
    // Extension: VK_COMPUTE_VERSION_1_3
    // Alias: VK_EVENT_CREATE_DEVICE_ONLY_BIT_KHR
    // bit: 0
    VK_EVENT_CREATE_DEVICE_ONLY_BIT: bool = false,
    _: u31 = 0,
};
pub const VkCommandPoolCreateFlags = packed struct(u32) {
    // Comment: Command buffers have a short lifetime
    // bit: 0
    VK_COMMAND_POOL_CREATE_TRANSIENT_BIT: bool = false,
    // Comment: Command buffers may release their memory individually
    // bit: 1
    VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT: bool = false,
    // Extension: VK_BASE_VERSION_1_1
    // bit: 2
    VK_COMMAND_POOL_CREATE_PROTECTED_BIT: bool = false,
    _: u29 = 0,
};
pub const VkCommandPoolResetFlags = packed struct(u32) {
    // Comment: Release resources owned by the pool
    // bit: 0
    VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT: bool = false,
    _: u31 = 0,
};
pub const VkCommandBufferResetFlags = packed struct(u32) {
    // Comment: Release resources owned by the buffer
    // bit: 0
    VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT: bool = false,
    _: u31 = 0,
};
pub const VkCommandBufferUsageFlags = packed struct(u32) {
    // bit: 0
    VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT: bool = false,
    // bit: 1
    VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT: bool = false,
    // Comment: Command buffer may be submitted/executed more than once simultaneously
    // bit: 2
    VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT: bool = false,
    _: u29 = 0,
};
pub const VkQueryPipelineStatisticFlags = packed struct(u32) {
    // Comment: Optional
    // bit: 0
    VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT: bool = false,
    // Comment: Optional
    // bit: 1
    VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT: bool = false,
    // Comment: Optional
    // bit: 2
    VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT: bool = false,
    // Comment: Optional
    // bit: 3
    VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT: bool = false,
    // Comment: Optional
    // bit: 4
    VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT: bool = false,
    // Comment: Optional
    // bit: 5
    VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT: bool = false,
    // Comment: Optional
    // bit: 6
    VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT: bool = false,
    // Comment: Optional
    // bit: 7
    VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT: bool = false,
    // Comment: Optional
    // bit: 8
    VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT: bool = false,
    // Comment: Optional
    // bit: 9
    VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT: bool = false,
    // Comment: Optional
    // bit: 10
    VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT: bool = false,
    // Extension: VK_EXT_mesh_shader
    // bit: 11
    VK_QUERY_PIPELINE_STATISTIC_TASK_SHADER_INVOCATIONS_BIT_EXT: bool = false,
    // Extension: VK_EXT_mesh_shader
    // bit: 12
    VK_QUERY_PIPELINE_STATISTIC_MESH_SHADER_INVOCATIONS_BIT_EXT: bool = false,
    // Extension: VK_HUAWEI_cluster_culling_shader
    // bit: 13
    VK_QUERY_PIPELINE_STATISTIC_CLUSTER_CULLING_SHADER_INVOCATIONS_BIT_HUAWEI: bool = false,
    _: u18 = 0,
};
pub const VkMemoryMapFlags = packed struct(u32) {
    // Extension: VK_EXT_map_memory_placed
    // bit: 0
    VK_MEMORY_MAP_PLACED_BIT_EXT: bool = false,
    _: u31 = 0,
};
pub const VkMemoryUnmapFlags = packed struct(u32) {
    // Extension: VK_EXT_map_memory_placed
    // bit: 0
    VK_MEMORY_UNMAP_RESERVE_BIT_EXT: bool = false,
    _: u31 = 0,
};
pub const VkImageAspectFlags = packed struct(u32) {
    // bit: 0
    VK_IMAGE_ASPECT_COLOR_BIT: bool = false,
    // bit: 1
    VK_IMAGE_ASPECT_DEPTH_BIT: bool = false,
    // bit: 2
    VK_IMAGE_ASPECT_STENCIL_BIT: bool = false,
    // bit: 3
    VK_IMAGE_ASPECT_METADATA_BIT: bool = false,
    // Extension: VK_BASE_VERSION_1_1
    // Alias: VK_IMAGE_ASPECT_PLANE_0_BIT_KHR
    // bit: 4
    VK_IMAGE_ASPECT_PLANE_0_BIT: bool = false,
    // Extension: VK_BASE_VERSION_1_1
    // Alias: VK_IMAGE_ASPECT_PLANE_1_BIT_KHR
    // bit: 5
    VK_IMAGE_ASPECT_PLANE_1_BIT: bool = false,
    // Extension: VK_BASE_VERSION_1_1
    // Alias: VK_IMAGE_ASPECT_PLANE_2_BIT_KHR
    // bit: 6
    VK_IMAGE_ASPECT_PLANE_2_BIT: bool = false,
    // Extension: VK_EXT_image_drm_format_modifier
    // bit: 7
    VK_IMAGE_ASPECT_MEMORY_PLANE_0_BIT_EXT: bool = false,
    // Extension: VK_EXT_image_drm_format_modifier
    // bit: 8
    VK_IMAGE_ASPECT_MEMORY_PLANE_1_BIT_EXT: bool = false,
    // Extension: VK_EXT_image_drm_format_modifier
    // bit: 9
    VK_IMAGE_ASPECT_MEMORY_PLANE_2_BIT_EXT: bool = false,
    // Extension: VK_EXT_image_drm_format_modifier
    // bit: 10
    VK_IMAGE_ASPECT_MEMORY_PLANE_3_BIT_EXT: bool = false,
    _: u21 = 0,
};
pub const VkSparseMemoryBindFlags = packed struct(u32) {
    // Comment: Operation binds resource metadata to memory
    // bit: 0
    VK_SPARSE_MEMORY_BIND_METADATA_BIT: bool = false,
    _: u31 = 0,
};
pub const VkSparseImageFormatFlags = packed struct(u32) {
    // Comment: Image uses a single mip tail region for all array layers
    // bit: 0
    VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT: bool = false,
    // Comment: Image requires mip level dimensions to be an integer multiple of the sparse image block dimensions for non-tail mip levels.
    // bit: 1
    VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT: bool = false,
    // Comment: Image uses a non-standard sparse image block dimensions
    // bit: 2
    VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT: bool = false,
    _: u29 = 0,
};
pub const VkSubpassDescriptionFlags = packed struct(u32) {
    // Extension: VK_NVX_multiview_per_view_attributes
    // bit: 0
    VK_SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX: bool = false,
    // Extension: VK_NVX_multiview_per_view_attributes
    // bit: 1
    VK_SUBPASS_DESCRIPTION_PER_VIEW_POSITION_X_ONLY_BIT_NVX: bool = false,
    // Extension: VK_EXT_custom_resolve
    // Alias: VK_SUBPASS_DESCRIPTION_FRAGMENT_REGION_BIT_QCOM
    // bit: 2
    VK_SUBPASS_DESCRIPTION_FRAGMENT_REGION_BIT_EXT: bool = false,
    // Extension: VK_EXT_custom_resolve
    // Alias: VK_SUBPASS_DESCRIPTION_SHADER_RESOLVE_BIT_QCOM
    // bit: 3
    VK_SUBPASS_DESCRIPTION_CUSTOM_RESOLVE_BIT_EXT: bool = false,
    // Extension: VK_EXT_rasterization_order_attachment_access
    // Alias: VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_COLOR_ACCESS_BIT_ARM
    // bit: 4
    VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_COLOR_ACCESS_BIT_EXT: bool = false,
    // Extension: VK_EXT_rasterization_order_attachment_access
    // Alias: VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_ARM
    // bit: 5
    VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_EXT: bool = false,
    // Extension: VK_EXT_rasterization_order_attachment_access
    // Alias: VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_ARM
    // bit: 6
    VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_EXT: bool = false,
    // Extension: VK_EXT_legacy_dithering
    // bit: 7
    VK_SUBPASS_DESCRIPTION_ENABLE_LEGACY_DITHERING_BIT_EXT: bool = false,
    // Extension: VK_QCOM_tile_shading
    // bit: 8
    VK_SUBPASS_DESCRIPTION_TILE_SHADING_APRON_BIT_QCOM: bool = false,
    _: u23 = 0,
};
pub const VkPipelineStageFlags = packed struct(u32) {
    // Comment: Before subsequent commands are processed
    // bit: 0
    VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT: bool = false,
    // Comment: Draw/DispatchIndirect command fetch
    // bit: 1
    VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT: bool = false,
    // Comment: Vertex/index fetch
    // bit: 2
    VK_PIPELINE_STAGE_VERTEX_INPUT_BIT: bool = false,
    // Comment: Vertex shading
    // bit: 3
    VK_PIPELINE_STAGE_VERTEX_SHADER_BIT: bool = false,
    // Comment: Tessellation control shading
    // bit: 4
    VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT: bool = false,
    // Comment: Tessellation evaluation shading
    // bit: 5
    VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT: bool = false,
    // Comment: Geometry shading
    // bit: 6
    VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT: bool = false,
    // Comment: Fragment shading
    // bit: 7
    VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT: bool = false,
    // Comment: Early fragment (depth and stencil) tests
    // bit: 8
    VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT: bool = false,
    // Comment: Late fragment (depth and stencil) tests
    // bit: 9
    VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT: bool = false,
    // Comment: Color attachment writes
    // bit: 10
    VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT: bool = false,
    // Comment: Compute shading
    // bit: 11
    VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT: bool = false,
    // Comment: Transfer/copy operations
    // bit: 12
    VK_PIPELINE_STAGE_TRANSFER_BIT: bool = false,
    // Comment: After previous commands have completed
    // bit: 13
    VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT: bool = false,
    // Comment: Indicates host (CPU) is a source/sink of the dependency
    // bit: 14
    VK_PIPELINE_STAGE_HOST_BIT: bool = false,
    // Comment: All stages of the graphics pipeline
    // bit: 15
    VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT: bool = false,
    // Comment: All stages supported on the queue
    // bit: 16
    VK_PIPELINE_STAGE_ALL_COMMANDS_BIT: bool = false,
    // Extension: VK_EXT_device_generated_commands
    // Alias: VK_PIPELINE_STAGE_COMMAND_PREPROCESS_BIT_NV
    // bit: 17
    VK_PIPELINE_STAGE_COMMAND_PREPROCESS_BIT_EXT: bool = false,
    // Extension: VK_EXT_conditional_rendering
    // bit: 18
    VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT: bool = false,
    // Extension: VK_EXT_mesh_shader
    // Alias: VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV
    // bit: 19
    VK_PIPELINE_STAGE_TASK_SHADER_BIT_EXT: bool = false,
    // Extension: VK_EXT_mesh_shader
    // Alias: VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV
    // bit: 20
    VK_PIPELINE_STAGE_MESH_SHADER_BIT_EXT: bool = false,
    // Extension: VK_KHR_ray_tracing_pipeline
    // Alias: VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_NV
    // bit: 21
    VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_KHR: bool = false,
    // Extension: VK_KHR_fragment_shading_rate
    // Alias: VK_PIPELINE_STAGE_SHADING_RATE_IMAGE_BIT_NV
    // bit: 22
    VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR: bool = false,
    // Extension: VK_EXT_fragment_density_map
    // bit: 23
    VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT: bool = false,
    // Extension: VK_EXT_transform_feedback
    // bit: 24
    VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT: bool = false,
    // Extension: VK_KHR_acceleration_structure
    // Alias: VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_NV
    // bit: 25
    VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR: bool = false,
    _: u6 = 0,
};
pub const VkSampleCountFlags = packed struct(u32) {
    // Comment: Sample count 1 supported
    // bit: 0
    VK_SAMPLE_COUNT_1_BIT: bool = false,
    // Comment: Sample count 2 supported
    // bit: 1
    VK_SAMPLE_COUNT_2_BIT: bool = false,
    // Comment: Sample count 4 supported
    // bit: 2
    VK_SAMPLE_COUNT_4_BIT: bool = false,
    // Comment: Sample count 8 supported
    // bit: 3
    VK_SAMPLE_COUNT_8_BIT: bool = false,
    // Comment: Sample count 16 supported
    // bit: 4
    VK_SAMPLE_COUNT_16_BIT: bool = false,
    // Comment: Sample count 32 supported
    // bit: 5
    VK_SAMPLE_COUNT_32_BIT: bool = false,
    // Comment: Sample count 64 supported
    // bit: 6
    VK_SAMPLE_COUNT_64_BIT: bool = false,
    _: u25 = 0,
};
pub const VkAttachmentDescriptionFlags = packed struct(u32) {
    // Comment: The attachment may alias physical memory of another attachment in the same render pass
    // bit: 0
    VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT: bool = false,
    // Extension: VK_KHR_maintenance10
    // bit: 1
    VK_ATTACHMENT_DESCRIPTION_RESOLVE_SKIP_TRANSFER_FUNCTION_BIT_KHR: bool = false,
    // Extension: VK_KHR_maintenance10
    // bit: 2
    VK_ATTACHMENT_DESCRIPTION_RESOLVE_ENABLE_TRANSFER_FUNCTION_BIT_KHR: bool = false,
    _: u29 = 0,
};
pub const VkStencilFaceFlags = packed struct(u32) {
    // Comment: Front face
    // bit: 0
    VK_STENCIL_FACE_FRONT_BIT: bool = false,
    // Comment: Back face
    // bit: 1
    VK_STENCIL_FACE_BACK_BIT: bool = false,
    _: u30 = 0,
    // Front and back faces
    pub const VK_STENCIL_FACE_FRONT_AND_BACK: @This() = @bitCast(@as(u32, 0x3));
};
pub const VkCullModeFlags = packed struct(u32) {
    // bit: 0
    VK_CULL_MODE_FRONT_BIT: bool = false,
    // bit: 1
    VK_CULL_MODE_BACK_BIT: bool = false,
    _: u30 = 0,
    pub const VK_CULL_MODE_NONE: @This() = @bitCast(@as(u32, 0x0));
    pub const VK_CULL_MODE_FRONT_AND_BACK: @This() = @bitCast(@as(u32, 0x3));
};
pub const VkDescriptorPoolCreateFlags = packed struct(u32) {
    // Comment: Descriptor sets may be freed individually
    // bit: 0
    VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT: bool = false,
    // Extension: VK_COMPUTE_VERSION_1_2
    // Alias: VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT
    // bit: 1
    VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT: bool = false,
    // Extension: VK_EXT_mutable_descriptor_type
    // Alias: VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_VALVE
    // bit: 2
    VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_EXT: bool = false,
    // Extension: VK_NV_descriptor_pool_overallocation
    // bit: 3
    VK_DESCRIPTOR_POOL_CREATE_ALLOW_OVERALLOCATION_SETS_BIT_NV: bool = false,
    // Extension: VK_NV_descriptor_pool_overallocation
    // bit: 4
    VK_DESCRIPTOR_POOL_CREATE_ALLOW_OVERALLOCATION_POOLS_BIT_NV: bool = false,
    _: u27 = 0,
};
pub const VkDependencyFlags = packed struct(u32) {
    // Comment: Dependency is per pixel region 
    // bit: 0
    VK_DEPENDENCY_BY_REGION_BIT: bool = false,
    // Extension: VK_GRAPHICS_VERSION_1_1
    // Alias: VK_DEPENDENCY_VIEW_LOCAL_BIT_KHR
    // bit: 1
    VK_DEPENDENCY_VIEW_LOCAL_BIT: bool = false,
    // Extension: VK_BASE_VERSION_1_1
    // Alias: VK_DEPENDENCY_DEVICE_GROUP_BIT_KHR
    // bit: 2
    VK_DEPENDENCY_DEVICE_GROUP_BIT: bool = false,
    // Extension: VK_EXT_attachment_feedback_loop_layout
    // bit: 3
    VK_DEPENDENCY_FEEDBACK_LOOP_BIT_EXT: bool = false,
    _3: u1 = 0,
    // Extension: VK_KHR_maintenance8
    // bit: 5
    VK_DEPENDENCY_QUEUE_FAMILY_OWNERSHIP_TRANSFER_USE_ALL_STAGES_BIT_KHR: bool = false,
    // Extension: VK_KHR_maintenance9
    // bit: 6
    VK_DEPENDENCY_ASYMMETRIC_EVENT_BIT_KHR: bool = false,
    _: u25 = 0,
};
pub const VkSubgroupFeatureFlags = packed struct(u32) {
    // Comment: Basic subgroup operations
    // bit: 0
    VK_SUBGROUP_FEATURE_BASIC_BIT: bool = false,
    // Comment: Vote subgroup operations
    // bit: 1
    VK_SUBGROUP_FEATURE_VOTE_BIT: bool = false,
    // Comment: Arithmetic subgroup operations
    // bit: 2
    VK_SUBGROUP_FEATURE_ARITHMETIC_BIT: bool = false,
    // Comment: Ballot subgroup operations
    // bit: 3
    VK_SUBGROUP_FEATURE_BALLOT_BIT: bool = false,
    // Comment: Shuffle subgroup operations
    // bit: 4
    VK_SUBGROUP_FEATURE_SHUFFLE_BIT: bool = false,
    // Comment: Shuffle relative subgroup operations
    // bit: 5
    VK_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT: bool = false,
    // Comment: Clustered subgroup operations
    // bit: 6
    VK_SUBGROUP_FEATURE_CLUSTERED_BIT: bool = false,
    // Comment: Quad subgroup operations
    // bit: 7
    VK_SUBGROUP_FEATURE_QUAD_BIT: bool = false,
    // Extension: VK_NV_shader_subgroup_partitioned
    // bit: 8
    VK_SUBGROUP_FEATURE_PARTITIONED_BIT_NV: bool = false,
    // Extension: VK_COMPUTE_VERSION_1_4
    // Alias: VK_SUBGROUP_FEATURE_ROTATE_BIT_KHR
    // bit: 9
    VK_SUBGROUP_FEATURE_ROTATE_BIT: bool = false,
    // Extension: VK_COMPUTE_VERSION_1_4
    // Alias: VK_SUBGROUP_FEATURE_ROTATE_CLUSTERED_BIT_KHR
    // bit: 10
    VK_SUBGROUP_FEATURE_ROTATE_CLUSTERED_BIT: bool = false,
    _: u21 = 0,
};
pub const VkIndirectCommandsLayoutUsageFlagsNV = packed struct(u32) {
    // bit: 0
    VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EXPLICIT_PREPROCESS_BIT_NV: bool = false,
    // bit: 1
    VK_INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT_NV: bool = false,
    // bit: 2
    VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_NV: bool = false,
    _: u29 = 0,
};
pub const VkIndirectStateFlagsNV = packed struct(u32) {
    // bit: 0
    VK_INDIRECT_STATE_FLAG_FRONTFACE_BIT_NV: bool = false,
    _: u31 = 0,
};
pub const VkGeometryFlagsKHR = packed struct(u32) {
    // Alias: VK_GEOMETRY_OPAQUE_BIT_NV
    // bit: 0
    VK_GEOMETRY_OPAQUE_BIT_KHR: bool = false,
    // Alias: VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_NV
    // bit: 1
    VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_KHR: bool = false,
    _: u30 = 0,
};
pub const VkGeometryInstanceFlagsKHR = packed struct(u32) {
    // Alias: VK_GEOMETRY_INSTANCE_TRIANGLE_CULL_DISABLE_BIT_NV
    // bit: 0
    VK_GEOMETRY_INSTANCE_TRIANGLE_FACING_CULL_DISABLE_BIT_KHR: bool = false,
    // bit: 1
    VK_GEOMETRY_INSTANCE_TRIANGLE_FLIP_FACING_BIT_KHR: bool = false,
    // Alias: VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_NV
    // bit: 2
    VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_KHR: bool = false,
    // Alias: VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_NV
    // bit: 3
    VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_KHR: bool = false,
    // Extension: VK_EXT_opacity_micromap
    // Alias: VK_GEOMETRY_INSTANCE_FORCE_OPACITY_MICROMAP_2_STATE_EXT
    // bit: 4
    VK_GEOMETRY_INSTANCE_FORCE_OPACITY_MICROMAP_2_STATE_BIT_EXT: bool = false,
    // Extension: VK_EXT_opacity_micromap
    // Alias: VK_GEOMETRY_INSTANCE_DISABLE_OPACITY_MICROMAPS_EXT
    // bit: 5
    VK_GEOMETRY_INSTANCE_DISABLE_OPACITY_MICROMAPS_BIT_EXT: bool = false,
    _: u26 = 0,
};
pub const VkClusterAccelerationStructureGeometryFlagsNV = packed struct(u32) {
    // bit: 0
    VK_CLUSTER_ACCELERATION_STRUCTURE_GEOMETRY_CULL_DISABLE_BIT_NV: bool = false,
    // bit: 1
    VK_CLUSTER_ACCELERATION_STRUCTURE_GEOMETRY_NO_DUPLICATE_ANYHIT_INVOCATION_BIT_NV: bool = false,
    // bit: 2
    VK_CLUSTER_ACCELERATION_STRUCTURE_GEOMETRY_OPAQUE_BIT_NV: bool = false,
    _: u29 = 0,
};
pub const VkClusterAccelerationStructureClusterFlagsNV = packed struct(u32) {
    // bit: 0
    VK_CLUSTER_ACCELERATION_STRUCTURE_CLUSTER_ALLOW_DISABLE_OPACITY_MICROMAPS_NV: bool = false,
    _: u31 = 0,
};
pub const VkClusterAccelerationStructureAddressResolutionFlagsNV = packed struct(u32) {
    // bit: 0
    VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_DST_IMPLICIT_DATA_BIT_NV: bool = false,
    // bit: 1
    VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_SCRATCH_DATA_BIT_NV: bool = false,
    // bit: 2
    VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_DST_ADDRESS_ARRAY_BIT_NV: bool = false,
    // bit: 3
    VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_DST_SIZES_ARRAY_BIT_NV: bool = false,
    // bit: 4
    VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_SRC_INFOS_ARRAY_BIT_NV: bool = false,
    // bit: 5
    VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_SRC_INFOS_COUNT_BIT_NV: bool = false,
    _: u26 = 0,
    pub const VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_NONE_NV: @This() = @bitCast(@as(u32, 0x0));
};
pub const VkBuildAccelerationStructureFlagsKHR = packed struct(u32) {
    // Alias: VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_NV
    // bit: 0
    VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_KHR: bool = false,
    // Alias: VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_NV
    // bit: 1
    VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_KHR: bool = false,
    // Alias: VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_NV
    // bit: 2
    VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_KHR: bool = false,
    // Alias: VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_NV
    // bit: 3
    VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_KHR: bool = false,
    // Alias: VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_NV
    // bit: 4
    VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_KHR: bool = false,
    // Extension: VK_NV_ray_tracing_motion_blur
    // bit: 5
    VK_BUILD_ACCELERATION_STRUCTURE_MOTION_BIT_NV: bool = false,
    // Extension: VK_EXT_opacity_micromap
    // Alias: VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_UPDATE_EXT
    // bit: 6
    VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_UPDATE_BIT_EXT: bool = false,
    // Extension: VK_EXT_opacity_micromap
    // Alias: VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DISABLE_OPACITY_MICROMAPS_EXT
    // bit: 7
    VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DISABLE_OPACITY_MICROMAPS_BIT_EXT: bool = false,
    // Extension: VK_EXT_opacity_micromap
    // Alias: VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_DATA_UPDATE_EXT
    // bit: 8
    VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_DATA_UPDATE_BIT_EXT: bool = false,
    // Extension: VK_NV_displacement_micromap
    // Alias: VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DISPLACEMENT_MICROMAP_UPDATE_NV
    // bit: 9
    VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DISPLACEMENT_MICROMAP_UPDATE_BIT_NV: bool = false,
    _9: u1 = 0,
    // Extension: VK_KHR_ray_tracing_position_fetch
    // Alias: VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DATA_ACCESS_KHR
    // bit: 11
    VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DATA_ACCESS_BIT_KHR: bool = false,
    // Extension: VK_NV_cluster_acceleration_structure
    // bit: 12
    VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_CLUSTER_OPACITY_MICROMAPS_BIT_NV: bool = false,
    _: u19 = 0,
};
pub const VkAccelerationStructureCreateFlagsKHR = packed struct(u32) {
    // bit: 0
    VK_ACCELERATION_STRUCTURE_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR: bool = false,
    // Extension: VK_NV_ray_tracing_motion_blur
    // bit: 2
    VK_ACCELERATION_STRUCTURE_CREATE_MOTION_BIT_NV: bool = false,
    // Extension: VK_EXT_descriptor_buffer
    // bit: 3
    VK_ACCELERATION_STRUCTURE_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT: bool = false,
    _: u28 = 0,
};
pub const VkPipelineCreationFeedbackFlags = packed struct(u32) {
    // Alias: VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT_EXT
    // bit: 0
    VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT: bool = false,
    // Alias: VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT_EXT
    // bit: 1
    VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT: bool = false,
    // Alias: VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT_EXT
    // bit: 2
    VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT: bool = false,
    _: u29 = 0,
};
pub const VkPerformanceCounterDescriptionFlagsKHR = packed struct(u32) {
    // bit: 0
    VK_PERFORMANCE_COUNTER_DESCRIPTION_PERFORMANCE_IMPACTING_BIT_KHR: bool = false,
    // bit: 1
    VK_PERFORMANCE_COUNTER_DESCRIPTION_CONCURRENTLY_IMPACTED_BIT_KHR: bool = false,
    _: u30 = 0,
};
pub const VkAcquireProfilingLockFlagsKHR = packed struct(u32) {
    _: u32 = 0,
};
pub const VkSemaphoreWaitFlags = packed struct(u32) {
    // Alias: VK_SEMAPHORE_WAIT_ANY_BIT_KHR
    // bit: 0
    VK_SEMAPHORE_WAIT_ANY_BIT: bool = false,
    _: u31 = 0,
};
pub const VkPipelineCompilerControlFlagsAMD = packed struct(u32) {
    _: u32 = 0,
};
pub const VkShaderCorePropertiesFlagsAMD = packed struct(u32) {
    _: u32 = 0,
};
pub const VkDeviceDiagnosticsConfigFlagsNV = packed struct(u32) {
    // bit: 0
    VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_SHADER_DEBUG_INFO_BIT_NV: bool = false,
    // bit: 1
    VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_RESOURCE_TRACKING_BIT_NV: bool = false,
    // bit: 2
    VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_AUTOMATIC_CHECKPOINTS_BIT_NV: bool = false,
    // bit: 3
    VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_SHADER_ERROR_REPORTING_BIT_NV: bool = false,
    _: u28 = 0,
};
pub const VkRefreshObjectFlagsKHR = packed struct(u32) {
    _: u32 = 0,
};
pub const VkAccessFlags2 = packed struct(u64) {
    // Alias: VK_ACCESS_2_INDIRECT_COMMAND_READ_BIT_KHR
    // bit: 0
    VK_ACCESS_2_INDIRECT_COMMAND_READ_BIT: bool = false,
    // Alias: VK_ACCESS_2_INDEX_READ_BIT_KHR
    // bit: 1
    VK_ACCESS_2_INDEX_READ_BIT: bool = false,
    // Alias: VK_ACCESS_2_VERTEX_ATTRIBUTE_READ_BIT_KHR
    // bit: 2
    VK_ACCESS_2_VERTEX_ATTRIBUTE_READ_BIT: bool = false,
    // Alias: VK_ACCESS_2_UNIFORM_READ_BIT_KHR
    // bit: 3
    VK_ACCESS_2_UNIFORM_READ_BIT: bool = false,
    // Alias: VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT_KHR
    // bit: 4
    VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT: bool = false,
    // Alias: VK_ACCESS_2_SHADER_READ_BIT_KHR
    // bit: 5
    VK_ACCESS_2_SHADER_READ_BIT: bool = false,
    // Alias: VK_ACCESS_2_SHADER_WRITE_BIT_KHR
    // bit: 6
    VK_ACCESS_2_SHADER_WRITE_BIT: bool = false,
    // Alias: VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT_KHR
    // bit: 7
    VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT: bool = false,
    // Alias: VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT_KHR
    // bit: 8
    VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT: bool = false,
    // Alias: VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT_KHR
    // bit: 9
    VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT: bool = false,
    // Alias: VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT_KHR
    // bit: 10
    VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT: bool = false,
    // Alias: VK_ACCESS_2_TRANSFER_READ_BIT_KHR
    // bit: 11
    VK_ACCESS_2_TRANSFER_READ_BIT: bool = false,
    // Alias: VK_ACCESS_2_TRANSFER_WRITE_BIT_KHR
    // bit: 12
    VK_ACCESS_2_TRANSFER_WRITE_BIT: bool = false,
    // Alias: VK_ACCESS_2_HOST_READ_BIT_KHR
    // bit: 13
    VK_ACCESS_2_HOST_READ_BIT: bool = false,
    // Alias: VK_ACCESS_2_HOST_WRITE_BIT_KHR
    // bit: 14
    VK_ACCESS_2_HOST_WRITE_BIT: bool = false,
    // Alias: VK_ACCESS_2_MEMORY_READ_BIT_KHR
    // bit: 15
    VK_ACCESS_2_MEMORY_READ_BIT: bool = false,
    // Alias: VK_ACCESS_2_MEMORY_WRITE_BIT_KHR
    // bit: 16
    VK_ACCESS_2_MEMORY_WRITE_BIT: bool = false,
    // Extension: VK_KHR_synchronization2
    // Alias: VK_ACCESS_2_COMMAND_PREPROCESS_READ_BIT_NV
    // bit: 17
    VK_ACCESS_2_COMMAND_PREPROCESS_READ_BIT_EXT: bool = false,
    // Extension: VK_KHR_synchronization2
    // Alias: VK_ACCESS_2_COMMAND_PREPROCESS_WRITE_BIT_NV
    // bit: 18
    VK_ACCESS_2_COMMAND_PREPROCESS_WRITE_BIT_EXT: bool = false,
    // Extension: VK_KHR_synchronization2
    // bit: 19
    VK_ACCESS_2_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT: bool = false,
    // Extension: VK_KHR_synchronization2
    // bit: 20
    VK_ACCESS_2_CONDITIONAL_RENDERING_READ_BIT_EXT: bool = false,
    // Extension: VK_KHR_synchronization2
    // Alias: VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_NV
    // bit: 21
    VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_KHR: bool = false,
    // Extension: VK_KHR_synchronization2
    // Alias: VK_ACCESS_2_ACCELERATION_STRUCTURE_WRITE_BIT_NV
    // bit: 22
    VK_ACCESS_2_ACCELERATION_STRUCTURE_WRITE_BIT_KHR: bool = false,
    // Extension: VK_KHR_synchronization2
    // Alias: VK_ACCESS_2_SHADING_RATE_IMAGE_READ_BIT_NV
    // bit: 23
    VK_ACCESS_2_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR: bool = false,
    // Extension: VK_KHR_synchronization2
    // bit: 24
    VK_ACCESS_2_FRAGMENT_DENSITY_MAP_READ_BIT_EXT: bool = false,
    // Extension: VK_KHR_synchronization2
    // bit: 25
    VK_ACCESS_2_TRANSFORM_FEEDBACK_WRITE_BIT_EXT: bool = false,
    // Extension: VK_KHR_synchronization2
    // bit: 26
    VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT: bool = false,
    // Extension: VK_KHR_synchronization2
    // bit: 27
    VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT: bool = false,
    _27: u4 = 0,
    // Alias: VK_ACCESS_2_SHADER_SAMPLED_READ_BIT_KHR
    // bit: 32
    VK_ACCESS_2_SHADER_SAMPLED_READ_BIT: bool = false,
    // Alias: VK_ACCESS_2_SHADER_STORAGE_READ_BIT_KHR
    // bit: 33
    VK_ACCESS_2_SHADER_STORAGE_READ_BIT: bool = false,
    // Alias: VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT_KHR
    // bit: 34
    VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT: bool = false,
    // Extension: VK_KHR_video_decode_queue
    // bit: 35
    VK_ACCESS_2_VIDEO_DECODE_READ_BIT_KHR: bool = false,
    // Extension: VK_KHR_video_decode_queue
    // bit: 36
    VK_ACCESS_2_VIDEO_DECODE_WRITE_BIT_KHR: bool = false,
    // Extension: VK_KHR_video_encode_queue
    // bit: 37
    VK_ACCESS_2_VIDEO_ENCODE_READ_BIT_KHR: bool = false,
    // Extension: VK_KHR_video_encode_queue
    // bit: 38
    VK_ACCESS_2_VIDEO_ENCODE_WRITE_BIT_KHR: bool = false,
    // Extension: VK_HUAWEI_invocation_mask
    // bit: 39
    VK_ACCESS_2_INVOCATION_MASK_READ_BIT_HUAWEI: bool = false,
    // Extension: VK_KHR_ray_tracing_maintenance1
    // bit: 40
    VK_ACCESS_2_SHADER_BINDING_TABLE_READ_BIT_KHR: bool = false,
    // Extension: VK_EXT_descriptor_buffer
    // bit: 41
    VK_ACCESS_2_DESCRIPTOR_BUFFER_READ_BIT_EXT: bool = false,
    // Extension: VK_NV_optical_flow
    // bit: 42
    VK_ACCESS_2_OPTICAL_FLOW_READ_BIT_NV: bool = false,
    // Extension: VK_NV_optical_flow
    // bit: 43
    VK_ACCESS_2_OPTICAL_FLOW_WRITE_BIT_NV: bool = false,
    // Extension: VK_EXT_opacity_micromap
    // bit: 44
    VK_ACCESS_2_MICROMAP_READ_BIT_EXT: bool = false,
    // Extension: VK_EXT_opacity_micromap
    // bit: 45
    VK_ACCESS_2_MICROMAP_WRITE_BIT_EXT: bool = false,
    _45: u1 = 0,
    // Extension: VK_ARM_data_graph
    // bit: 47
    VK_ACCESS_2_DATA_GRAPH_READ_BIT_ARM: bool = false,
    // Extension: VK_ARM_data_graph
    // bit: 48
    VK_ACCESS_2_DATA_GRAPH_WRITE_BIT_ARM: bool = false,
    _48: u2 = 0,
    // Extension: VK_QCOM_tile_shading
    // bit: 51
    VK_ACCESS_2_SHADER_TILE_ATTACHMENT_READ_BIT_QCOM: bool = false,
    // Extension: VK_QCOM_tile_shading
    // bit: 52
    VK_ACCESS_2_SHADER_TILE_ATTACHMENT_WRITE_BIT_QCOM: bool = false,
    _52: u2 = 0,
    // Extension: VK_EXT_memory_decompression
    // bit: 55
    VK_ACCESS_2_MEMORY_DECOMPRESSION_READ_BIT_EXT: bool = false,
    // Extension: VK_EXT_memory_decompression
    // bit: 56
    VK_ACCESS_2_MEMORY_DECOMPRESSION_WRITE_BIT_EXT: bool = false,
    _: u7 = 0,
    pub const VK_ACCESS_2_NONE: @This() = @bitCast(@as(u64, 0x0));
};
pub const VkPipelineStageFlags2 = packed struct(u64) {
    // Alias: VK_PIPELINE_STAGE_2_TOP_OF_PIPE_BIT_KHR
    // bit: 0
    VK_PIPELINE_STAGE_2_TOP_OF_PIPE_BIT: bool = false,
    // Alias: VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT_KHR
    // bit: 1
    VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT: bool = false,
    // Alias: VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT_KHR
    // bit: 2
    VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT: bool = false,
    // Alias: VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT_KHR
    // bit: 3
    VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT: bool = false,
    // Alias: VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT_KHR
    // bit: 4
    VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT: bool = false,
    // Alias: VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT_KHR
    // bit: 5
    VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT: bool = false,
    // Alias: VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT_KHR
    // bit: 6
    VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT: bool = false,
    // Alias: VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT_KHR
    // bit: 7
    VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT: bool = false,
    // Alias: VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT_KHR
    // bit: 8
    VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT: bool = false,
    // Alias: VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT_KHR
    // bit: 9
    VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT: bool = false,
    // Alias: VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT_KHR
    // bit: 10
    VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT: bool = false,
    // Alias: VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT_KHR
    // bit: 11
    VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT: bool = false,
    // Alias: VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT_KHR
    // Alias: VK_PIPELINE_STAGE_2_TRANSFER_BIT_KHR
    // bit: 12
    VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT: bool = false,
    // Alias: VK_PIPELINE_STAGE_2_BOTTOM_OF_PIPE_BIT_KHR
    // bit: 13
    VK_PIPELINE_STAGE_2_BOTTOM_OF_PIPE_BIT: bool = false,
    // Alias: VK_PIPELINE_STAGE_2_HOST_BIT_KHR
    // bit: 14
    VK_PIPELINE_STAGE_2_HOST_BIT: bool = false,
    // Alias: VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT_KHR
    // bit: 15
    VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT: bool = false,
    // Alias: VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT_KHR
    // bit: 16
    VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT: bool = false,
    // Extension: VK_KHR_synchronization2
    // Alias: VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_NV
    // bit: 17
    VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_EXT: bool = false,
    // Extension: VK_KHR_synchronization2
    // bit: 18
    VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT: bool = false,
    // Extension: VK_KHR_synchronization2
    // Alias: VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_NV
    // bit: 19
    VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_EXT: bool = false,
    // Extension: VK_KHR_synchronization2
    // Alias: VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_NV
    // bit: 20
    VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_EXT: bool = false,
    // Extension: VK_KHR_synchronization2
    // Alias: VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_NV
    // bit: 21
    VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR: bool = false,
    // Extension: VK_KHR_synchronization2
    // Alias: VK_PIPELINE_STAGE_2_SHADING_RATE_IMAGE_BIT_NV
    // bit: 22
    VK_PIPELINE_STAGE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR: bool = false,
    // Extension: VK_KHR_synchronization2
    // bit: 23
    VK_PIPELINE_STAGE_2_FRAGMENT_DENSITY_PROCESS_BIT_EXT: bool = false,
    // Extension: VK_KHR_synchronization2
    // bit: 24
    VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT: bool = false,
    // Extension: VK_KHR_synchronization2
    // Alias: VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_NV
    // bit: 25
    VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR: bool = false,
    // Extension: VK_KHR_video_decode_queue
    // bit: 26
    VK_PIPELINE_STAGE_2_VIDEO_DECODE_BIT_KHR: bool = false,
    // Extension: VK_KHR_video_encode_queue
    // bit: 27
    VK_PIPELINE_STAGE_2_VIDEO_ENCODE_BIT_KHR: bool = false,
    // Extension: VK_KHR_ray_tracing_maintenance1
    // bit: 28
    VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_COPY_BIT_KHR: bool = false,
    // Extension: VK_NV_optical_flow
    // bit: 29
    VK_PIPELINE_STAGE_2_OPTICAL_FLOW_BIT_NV: bool = false,
    // Extension: VK_EXT_opacity_micromap
    // bit: 30
    VK_PIPELINE_STAGE_2_MICROMAP_BUILD_BIT_EXT: bool = false,
    _30: u1 = 0,
    // Alias: VK_PIPELINE_STAGE_2_COPY_BIT_KHR
    // bit: 32
    VK_PIPELINE_STAGE_2_COPY_BIT: bool = false,
    // Alias: VK_PIPELINE_STAGE_2_RESOLVE_BIT_KHR
    // bit: 33
    VK_PIPELINE_STAGE_2_RESOLVE_BIT: bool = false,
    // Alias: VK_PIPELINE_STAGE_2_BLIT_BIT_KHR
    // bit: 34
    VK_PIPELINE_STAGE_2_BLIT_BIT: bool = false,
    // Alias: VK_PIPELINE_STAGE_2_CLEAR_BIT_KHR
    // bit: 35
    VK_PIPELINE_STAGE_2_CLEAR_BIT: bool = false,
    // Alias: VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT_KHR
    // bit: 36
    VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT: bool = false,
    // Alias: VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT_KHR
    // bit: 37
    VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT: bool = false,
    // Alias: VK_PIPELINE_STAGE_2_PRE_RASTERIZATION_SHADERS_BIT_KHR
    // bit: 38
    VK_PIPELINE_STAGE_2_PRE_RASTERIZATION_SHADERS_BIT: bool = false,
    // Extension: VK_HUAWEI_subpass_shading
    // Alias: VK_PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI
    // bit: 39
    VK_PIPELINE_STAGE_2_SUBPASS_SHADER_BIT_HUAWEI: bool = false,
    // Extension: VK_HUAWEI_invocation_mask
    // bit: 40
    VK_PIPELINE_STAGE_2_INVOCATION_MASK_BIT_HUAWEI: bool = false,
    // Extension: VK_HUAWEI_cluster_culling_shader
    // bit: 41
    VK_PIPELINE_STAGE_2_CLUSTER_CULLING_SHADER_BIT_HUAWEI: bool = false,
    // Extension: VK_ARM_data_graph
    // bit: 42
    VK_PIPELINE_STAGE_2_DATA_GRAPH_BIT_ARM: bool = false,
    _42: u1 = 0,
    // Extension: VK_NV_cooperative_vector
    // bit: 44
    VK_PIPELINE_STAGE_2_CONVERT_COOPERATIVE_VECTOR_MATRIX_BIT_NV: bool = false,
    // Extension: VK_EXT_memory_decompression
    // bit: 45
    VK_PIPELINE_STAGE_2_MEMORY_DECOMPRESSION_BIT_EXT: bool = false,
    // Extension: VK_KHR_copy_memory_indirect
    // bit: 46
    VK_PIPELINE_STAGE_2_COPY_INDIRECT_BIT_KHR: bool = false,
    _: u17 = 0,
    pub const VK_PIPELINE_STAGE_2_NONE: @This() = @bitCast(@as(u64, 0x0));
};
pub const VkFormatFeatureFlags2 = packed struct(u64) {
    // Alias: VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_BIT_KHR
    // bit: 0
    VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_BIT: bool = false,
    // Alias: VK_FORMAT_FEATURE_2_STORAGE_IMAGE_BIT_KHR
    // bit: 1
    VK_FORMAT_FEATURE_2_STORAGE_IMAGE_BIT: bool = false,
    // Alias: VK_FORMAT_FEATURE_2_STORAGE_IMAGE_ATOMIC_BIT_KHR
    // bit: 2
    VK_FORMAT_FEATURE_2_STORAGE_IMAGE_ATOMIC_BIT: bool = false,
    // Alias: VK_FORMAT_FEATURE_2_UNIFORM_TEXEL_BUFFER_BIT_KHR
    // bit: 3
    VK_FORMAT_FEATURE_2_UNIFORM_TEXEL_BUFFER_BIT: bool = false,
    // Alias: VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_BIT_KHR
    // bit: 4
    VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_BIT: bool = false,
    // Alias: VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_ATOMIC_BIT_KHR
    // bit: 5
    VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_ATOMIC_BIT: bool = false,
    // Alias: VK_FORMAT_FEATURE_2_VERTEX_BUFFER_BIT_KHR
    // bit: 6
    VK_FORMAT_FEATURE_2_VERTEX_BUFFER_BIT: bool = false,
    // Alias: VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BIT_KHR
    // bit: 7
    VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BIT: bool = false,
    // Alias: VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BLEND_BIT_KHR
    // bit: 8
    VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BLEND_BIT: bool = false,
    // Alias: VK_FORMAT_FEATURE_2_DEPTH_STENCIL_ATTACHMENT_BIT_KHR
    // bit: 9
    VK_FORMAT_FEATURE_2_DEPTH_STENCIL_ATTACHMENT_BIT: bool = false,
    // Alias: VK_FORMAT_FEATURE_2_BLIT_SRC_BIT_KHR
    // bit: 10
    VK_FORMAT_FEATURE_2_BLIT_SRC_BIT: bool = false,
    // Alias: VK_FORMAT_FEATURE_2_BLIT_DST_BIT_KHR
    // bit: 11
    VK_FORMAT_FEATURE_2_BLIT_DST_BIT: bool = false,
    // Alias: VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_LINEAR_BIT_KHR
    // bit: 12
    VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_LINEAR_BIT: bool = false,
    // Extension: VK_BASE_VERSION_1_3
    // Alias: VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT
    // bit: 13
    VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_CUBIC_BIT: bool = false,
    // Alias: VK_FORMAT_FEATURE_2_TRANSFER_SRC_BIT_KHR
    // bit: 14
    VK_FORMAT_FEATURE_2_TRANSFER_SRC_BIT: bool = false,
    // Alias: VK_FORMAT_FEATURE_2_TRANSFER_DST_BIT_KHR
    // bit: 15
    VK_FORMAT_FEATURE_2_TRANSFER_DST_BIT: bool = false,
    // Alias: VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_MINMAX_BIT_KHR
    // bit: 16
    VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_MINMAX_BIT: bool = false,
    // Alias: VK_FORMAT_FEATURE_2_MIDPOINT_CHROMA_SAMPLES_BIT_KHR
    // bit: 17
    VK_FORMAT_FEATURE_2_MIDPOINT_CHROMA_SAMPLES_BIT: bool = false,
    // Alias: VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR
    // bit: 18
    VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT: bool = false,
    // Alias: VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR
    // bit: 19
    VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT: bool = false,
    // Alias: VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR
    // bit: 20
    VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT: bool = false,
    // Alias: VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR
    // bit: 21
    VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT: bool = false,
    // Alias: VK_FORMAT_FEATURE_2_DISJOINT_BIT_KHR
    // bit: 22
    VK_FORMAT_FEATURE_2_DISJOINT_BIT: bool = false,
    // Alias: VK_FORMAT_FEATURE_2_COSITED_CHROMA_SAMPLES_BIT_KHR
    // bit: 23
    VK_FORMAT_FEATURE_2_COSITED_CHROMA_SAMPLES_BIT: bool = false,
    // Extension: VK_EXT_fragment_density_map
    // bit: 24
    VK_FORMAT_FEATURE_2_FRAGMENT_DENSITY_MAP_BIT_EXT: bool = false,
    // Extension: VK_KHR_video_decode_queue
    // bit: 25
    VK_FORMAT_FEATURE_2_VIDEO_DECODE_OUTPUT_BIT_KHR: bool = false,
    // Extension: VK_KHR_video_decode_queue
    // bit: 26
    VK_FORMAT_FEATURE_2_VIDEO_DECODE_DPB_BIT_KHR: bool = false,
    // Extension: VK_KHR_video_encode_queue
    // bit: 27
    VK_FORMAT_FEATURE_2_VIDEO_ENCODE_INPUT_BIT_KHR: bool = false,
    // Extension: VK_KHR_video_encode_queue
    // bit: 28
    VK_FORMAT_FEATURE_2_VIDEO_ENCODE_DPB_BIT_KHR: bool = false,
    // Extension: VK_KHR_acceleration_structure
    // bit: 29
    VK_FORMAT_FEATURE_2_ACCELERATION_STRUCTURE_VERTEX_BUFFER_BIT_KHR: bool = false,
    // Extension: VK_KHR_fragment_shading_rate
    // bit: 30
    VK_FORMAT_FEATURE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR: bool = false,
    // Alias: VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT_KHR
    // bit: 31
    VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT: bool = false,
    // Alias: VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT_KHR
    // bit: 32
    VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT: bool = false,
    // Alias: VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT_KHR
    // bit: 33
    VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT: bool = false,
    // Extension: VK_QCOM_image_processing
    // bit: 34
    VK_FORMAT_FEATURE_2_WEIGHT_IMAGE_BIT_QCOM: bool = false,
    // Extension: VK_QCOM_image_processing
    // bit: 35
    VK_FORMAT_FEATURE_2_WEIGHT_SAMPLED_IMAGE_BIT_QCOM: bool = false,
    // Extension: VK_QCOM_image_processing
    // bit: 36
    VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM: bool = false,
    // Extension: VK_QCOM_image_processing
    // bit: 37
    VK_FORMAT_FEATURE_2_BOX_FILTER_SAMPLED_BIT_QCOM: bool = false,
    // Extension: VK_NV_linear_color_attachment
    // bit: 38
    VK_FORMAT_FEATURE_2_LINEAR_COLOR_ATTACHMENT_BIT_NV: bool = false,
    // Extension: VK_ARM_tensors
    // bit: 39
    VK_FORMAT_FEATURE_2_TENSOR_SHADER_BIT_ARM: bool = false,
    // Extension: VK_NV_optical_flow
    // bit: 40
    VK_FORMAT_FEATURE_2_OPTICAL_FLOW_IMAGE_BIT_NV: bool = false,
    // Extension: VK_NV_optical_flow
    // bit: 41
    VK_FORMAT_FEATURE_2_OPTICAL_FLOW_VECTOR_BIT_NV: bool = false,
    // Extension: VK_NV_optical_flow
    // bit: 42
    VK_FORMAT_FEATURE_2_OPTICAL_FLOW_COST_BIT_NV: bool = false,
    // Extension: VK_ARM_tensors
    // bit: 43
    VK_FORMAT_FEATURE_2_TENSOR_IMAGE_ALIASING_BIT_ARM: bool = false,
    _43: u2 = 0,
    // Extension: VK_BASE_VERSION_1_4
    // Alias: VK_FORMAT_FEATURE_2_HOST_IMAGE_TRANSFER_BIT_EXT
    // bit: 46
    VK_FORMAT_FEATURE_2_HOST_IMAGE_TRANSFER_BIT: bool = false,
    _46: u1 = 0,
    // Extension: VK_ARM_data_graph
    // bit: 48
    VK_FORMAT_FEATURE_2_TENSOR_DATA_GRAPH_BIT_ARM: bool = false,
    // Extension: VK_KHR_video_encode_quantization_map
    // bit: 49
    VK_FORMAT_FEATURE_2_VIDEO_ENCODE_QUANTIZATION_DELTA_MAP_BIT_KHR: bool = false,
    // Extension: VK_KHR_video_encode_quantization_map
    // bit: 50
    VK_FORMAT_FEATURE_2_VIDEO_ENCODE_EMPHASIS_MAP_BIT_KHR: bool = false,
    // Extension: VK_NV_ray_tracing_linear_swept_spheres
    // bit: 51
    VK_FORMAT_FEATURE_2_ACCELERATION_STRUCTURE_RADIUS_BUFFER_BIT_NV: bool = false,
    // Extension: VK_KHR_maintenance10
    // bit: 52
    VK_FORMAT_FEATURE_2_DEPTH_COPY_ON_COMPUTE_QUEUE_BIT_KHR: bool = false,
    // Extension: VK_KHR_maintenance10
    // bit: 53
    VK_FORMAT_FEATURE_2_DEPTH_COPY_ON_TRANSFER_QUEUE_BIT_KHR: bool = false,
    // Extension: VK_KHR_maintenance10
    // bit: 54
    VK_FORMAT_FEATURE_2_STENCIL_COPY_ON_COMPUTE_QUEUE_BIT_KHR: bool = false,
    // Extension: VK_KHR_maintenance10
    // bit: 55
    VK_FORMAT_FEATURE_2_STENCIL_COPY_ON_TRANSFER_QUEUE_BIT_KHR: bool = false,
    _55: u3 = 0,
    // Extension: VK_KHR_copy_memory_indirect
    // bit: 59
    VK_FORMAT_FEATURE_2_COPY_IMAGE_INDIRECT_DST_BIT_KHR: bool = false,
    _: u4 = 0,
};
pub const VkRenderingFlags = packed struct(u32) {
    // Alias: VK_RENDERING_CONTENTS_SECONDARY_COMMAND_BUFFERS_BIT_KHR
    // bit: 0
    VK_RENDERING_CONTENTS_SECONDARY_COMMAND_BUFFERS_BIT: bool = false,
    // Alias: VK_RENDERING_SUSPENDING_BIT_KHR
    // bit: 1
    VK_RENDERING_SUSPENDING_BIT: bool = false,
    // Alias: VK_RENDERING_RESUMING_BIT_KHR
    // bit: 2
    VK_RENDERING_RESUMING_BIT: bool = false,
    // Extension: VK_EXT_legacy_dithering
    // bit: 3
    VK_RENDERING_ENABLE_LEGACY_DITHERING_BIT_EXT: bool = false,
    // Extension: VK_KHR_maintenance7
    // Alias: VK_RENDERING_CONTENTS_INLINE_BIT_EXT
    // bit: 4
    VK_RENDERING_CONTENTS_INLINE_BIT_KHR: bool = false,
    // Extension: VK_VALVE_fragment_density_map_layered
    // bit: 5
    VK_RENDERING_PER_LAYER_FRAGMENT_DENSITY_BIT_VALVE: bool = false,
    // Extension: VK_EXT_custom_resolve
    // bit: 6
    VK_RENDERING_FRAGMENT_REGION_BIT_EXT: bool = false,
    // Extension: VK_EXT_custom_resolve
    // bit: 7
    VK_RENDERING_CUSTOM_RESOLVE_BIT_EXT: bool = false,
    // Extension: VK_KHR_maintenance10
    // bit: 8
    VK_RENDERING_LOCAL_READ_CONCURRENT_ACCESS_CONTROL_BIT_KHR: bool = false,
    _: u23 = 0,
};
pub const VkMemoryDecompressionMethodFlagsEXT = packed struct(u64) {
    // bit: 0
    VK_MEMORY_DECOMPRESSION_METHOD_GDEFLATE_1_0_BIT_EXT: bool = false,
    _: u63 = 0,
};
pub const VkBuildMicromapFlagsEXT = packed struct(u32) {
    // bit: 0
    VK_BUILD_MICROMAP_PREFER_FAST_TRACE_BIT_EXT: bool = false,
    // bit: 1
    VK_BUILD_MICROMAP_PREFER_FAST_BUILD_BIT_EXT: bool = false,
    // bit: 2
    VK_BUILD_MICROMAP_ALLOW_COMPACTION_BIT_EXT: bool = false,
    _: u29 = 0,
};
pub const VkMicromapCreateFlagsEXT = packed struct(u32) {
    // bit: 0
    VK_MICROMAP_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT: bool = false,
    _: u31 = 0,
};
pub const VkIndirectCommandsLayoutUsageFlagsEXT = packed struct(u32) {
    // bit: 0
    VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EXPLICIT_PREPROCESS_BIT_EXT: bool = false,
    // bit: 1
    VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_EXT: bool = false,
    _: u30 = 0,
};
pub const VkIndirectCommandsInputModeFlagsEXT = packed struct(u32) {
    // bit: 0
    VK_INDIRECT_COMMANDS_INPUT_MODE_VULKAN_INDEX_BUFFER_EXT: bool = false,
    // bit: 1
    VK_INDIRECT_COMMANDS_INPUT_MODE_DXGI_INDEX_BUFFER_EXT: bool = false,
    _: u30 = 0,
};
pub const VkPipelineCreateFlags2 = packed struct(u64) {
    // Alias: VK_PIPELINE_CREATE_2_DISABLE_OPTIMIZATION_BIT_KHR
    // bit: 0
    VK_PIPELINE_CREATE_2_DISABLE_OPTIMIZATION_BIT: bool = false,
    // Alias: VK_PIPELINE_CREATE_2_ALLOW_DERIVATIVES_BIT_KHR
    // bit: 1
    VK_PIPELINE_CREATE_2_ALLOW_DERIVATIVES_BIT: bool = false,
    // Alias: VK_PIPELINE_CREATE_2_DERIVATIVE_BIT_KHR
    // bit: 2
    VK_PIPELINE_CREATE_2_DERIVATIVE_BIT: bool = false,
    // Alias: VK_PIPELINE_CREATE_2_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHR
    // bit: 3
    VK_PIPELINE_CREATE_2_VIEW_INDEX_FROM_DEVICE_INDEX_BIT: bool = false,
    // Alias: VK_PIPELINE_CREATE_2_DISPATCH_BASE_BIT_KHR
    // bit: 4
    VK_PIPELINE_CREATE_2_DISPATCH_BASE_BIT: bool = false,
    // Extension: VK_KHR_maintenance5
    // bit: 5
    VK_PIPELINE_CREATE_2_DEFER_COMPILE_BIT_NV: bool = false,
    // Extension: VK_KHR_maintenance5
    // bit: 6
    VK_PIPELINE_CREATE_2_CAPTURE_STATISTICS_BIT_KHR: bool = false,
    // Extension: VK_KHR_maintenance5
    // bit: 7
    VK_PIPELINE_CREATE_2_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR: bool = false,
    // Alias: VK_PIPELINE_CREATE_2_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT_KHR
    // bit: 8
    VK_PIPELINE_CREATE_2_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT: bool = false,
    // Alias: VK_PIPELINE_CREATE_2_EARLY_RETURN_ON_FAILURE_BIT_KHR
    // bit: 9
    VK_PIPELINE_CREATE_2_EARLY_RETURN_ON_FAILURE_BIT: bool = false,
    // Extension: VK_KHR_maintenance5
    // bit: 10
    VK_PIPELINE_CREATE_2_LINK_TIME_OPTIMIZATION_BIT_EXT: bool = false,
    // Extension: VK_KHR_maintenance5
    // bit: 11
    VK_PIPELINE_CREATE_2_LIBRARY_BIT_KHR: bool = false,
    // Extension: VK_KHR_maintenance5
    // Alias: VK_PIPELINE_CREATE_2_RAY_TRACING_SKIP_BUILT_IN_PRIMITIVES_BIT_KHR
    // bit: 12
    VK_PIPELINE_CREATE_2_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR: bool = false,
    // Extension: VK_KHR_maintenance5
    // bit: 13
    VK_PIPELINE_CREATE_2_RAY_TRACING_SKIP_AABBS_BIT_KHR: bool = false,
    // Extension: VK_KHR_maintenance5
    // bit: 14
    VK_PIPELINE_CREATE_2_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR: bool = false,
    // Extension: VK_KHR_maintenance5
    // bit: 15
    VK_PIPELINE_CREATE_2_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR: bool = false,
    // Extension: VK_KHR_maintenance5
    // bit: 16
    VK_PIPELINE_CREATE_2_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR: bool = false,
    // Extension: VK_KHR_maintenance5
    // bit: 17
    VK_PIPELINE_CREATE_2_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR: bool = false,
    // Extension: VK_KHR_maintenance5
    // bit: 18
    VK_PIPELINE_CREATE_2_INDIRECT_BINDABLE_BIT_NV: bool = false,
    // Extension: VK_KHR_maintenance5
    // bit: 19
    VK_PIPELINE_CREATE_2_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR: bool = false,
    // Extension: VK_KHR_maintenance5
    // bit: 20
    VK_PIPELINE_CREATE_2_RAY_TRACING_ALLOW_MOTION_BIT_NV: bool = false,
    // Extension: VK_KHR_maintenance5
    // bit: 21
    VK_PIPELINE_CREATE_2_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR: bool = false,
    // Extension: VK_KHR_maintenance5
    // bit: 22
    VK_PIPELINE_CREATE_2_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT: bool = false,
    // Extension: VK_KHR_maintenance5
    // bit: 23
    VK_PIPELINE_CREATE_2_RETAIN_LINK_TIME_OPTIMIZATION_INFO_BIT_EXT: bool = false,
    // Extension: VK_KHR_maintenance5
    // bit: 24
    VK_PIPELINE_CREATE_2_RAY_TRACING_OPACITY_MICROMAP_BIT_EXT: bool = false,
    // Extension: VK_KHR_maintenance5
    // bit: 25
    VK_PIPELINE_CREATE_2_COLOR_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT: bool = false,
    // Extension: VK_KHR_maintenance5
    // bit: 26
    VK_PIPELINE_CREATE_2_DEPTH_STENCIL_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT: bool = false,
    // Alias: VK_PIPELINE_CREATE_2_NO_PROTECTED_ACCESS_BIT_EXT
    // bit: 27
    VK_PIPELINE_CREATE_2_NO_PROTECTED_ACCESS_BIT: bool = false,
    // Extension: VK_KHR_maintenance5
    // bit: 28
    VK_PIPELINE_CREATE_2_RAY_TRACING_DISPLACEMENT_MICROMAP_BIT_NV: bool = false,
    // Extension: VK_KHR_maintenance5
    // bit: 29
    VK_PIPELINE_CREATE_2_DESCRIPTOR_BUFFER_BIT_EXT: bool = false,
    // Alias: VK_PIPELINE_CREATE_2_PROTECTED_ACCESS_ONLY_BIT_EXT
    // bit: 30
    VK_PIPELINE_CREATE_2_PROTECTED_ACCESS_ONLY_BIT: bool = false,
    // Extension: VK_KHR_pipeline_binary
    // bit: 31
    VK_PIPELINE_CREATE_2_CAPTURE_DATA_BIT_KHR: bool = false,
    // Extension: VK_AMDX_shader_enqueue
    // bit: 32
    VK_PIPELINE_CREATE_2_EXECUTION_GRAPH_BIT_AMDX: bool = false,
    // Extension: VK_NV_ray_tracing_linear_swept_spheres
    // bit: 33
    VK_PIPELINE_CREATE_2_RAY_TRACING_ALLOW_SPHERES_AND_LINEAR_SWEPT_SPHERES_BIT_NV: bool = false,
    // Extension: VK_EXT_legacy_dithering
    // bit: 34
    VK_PIPELINE_CREATE_2_ENABLE_LEGACY_DITHERING_BIT_EXT: bool = false,
    _34: u2 = 0,
    // Extension: VK_KHR_maintenance5
    // Extension: VK_ARM_pipeline_opacity_micromap
    // bit: 37
    VK_PIPELINE_CREATE_2_DISALLOW_OPACITY_MICROMAP_BIT_ARM: bool = false,
    // Extension: VK_EXT_device_generated_commands
    // bit: 38
    VK_PIPELINE_CREATE_2_INDIRECT_BINDABLE_BIT_EXT: bool = false,
    _38: u1 = 0,
    // Extension: VK_VALVE_fragment_density_map_layered
    // bit: 40
    VK_PIPELINE_CREATE_2_PER_LAYER_FRAGMENT_DENSITY_BIT_VALVE: bool = false,
    _40: u2 = 0,
    // Extension: VK_EXT_shader_64bit_indexing
    // bit: 43
    VK_PIPELINE_CREATE_2_64_BIT_INDEXING_BIT_EXT: bool = false,
    _: u20 = 0,
};
pub const VkBufferUsageFlags2 = packed struct(u64) {
    // Alias: VK_BUFFER_USAGE_2_TRANSFER_SRC_BIT_KHR
    // bit: 0
    VK_BUFFER_USAGE_2_TRANSFER_SRC_BIT: bool = false,
    // Alias: VK_BUFFER_USAGE_2_TRANSFER_DST_BIT_KHR
    // bit: 1
    VK_BUFFER_USAGE_2_TRANSFER_DST_BIT: bool = false,
    // Alias: VK_BUFFER_USAGE_2_UNIFORM_TEXEL_BUFFER_BIT_KHR
    // bit: 2
    VK_BUFFER_USAGE_2_UNIFORM_TEXEL_BUFFER_BIT: bool = false,
    // Alias: VK_BUFFER_USAGE_2_STORAGE_TEXEL_BUFFER_BIT_KHR
    // bit: 3
    VK_BUFFER_USAGE_2_STORAGE_TEXEL_BUFFER_BIT: bool = false,
    // Alias: VK_BUFFER_USAGE_2_UNIFORM_BUFFER_BIT_KHR
    // bit: 4
    VK_BUFFER_USAGE_2_UNIFORM_BUFFER_BIT: bool = false,
    // Alias: VK_BUFFER_USAGE_2_STORAGE_BUFFER_BIT_KHR
    // bit: 5
    VK_BUFFER_USAGE_2_STORAGE_BUFFER_BIT: bool = false,
    // Alias: VK_BUFFER_USAGE_2_INDEX_BUFFER_BIT_KHR
    // bit: 6
    VK_BUFFER_USAGE_2_INDEX_BUFFER_BIT: bool = false,
    // Alias: VK_BUFFER_USAGE_2_VERTEX_BUFFER_BIT_KHR
    // bit: 7
    VK_BUFFER_USAGE_2_VERTEX_BUFFER_BIT: bool = false,
    // Alias: VK_BUFFER_USAGE_2_INDIRECT_BUFFER_BIT_KHR
    // bit: 8
    VK_BUFFER_USAGE_2_INDIRECT_BUFFER_BIT: bool = false,
    // Extension: VK_KHR_maintenance5
    // bit: 9
    VK_BUFFER_USAGE_2_CONDITIONAL_RENDERING_BIT_EXT: bool = false,
    // Extension: VK_KHR_maintenance5
    // Alias: VK_BUFFER_USAGE_2_RAY_TRACING_BIT_NV
    // bit: 10
    VK_BUFFER_USAGE_2_SHADER_BINDING_TABLE_BIT_KHR: bool = false,
    // Extension: VK_KHR_maintenance5
    // bit: 11
    VK_BUFFER_USAGE_2_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT: bool = false,
    // Extension: VK_KHR_maintenance5
    // bit: 12
    VK_BUFFER_USAGE_2_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT: bool = false,
    // Extension: VK_KHR_maintenance5
    // bit: 13
    VK_BUFFER_USAGE_2_VIDEO_DECODE_SRC_BIT_KHR: bool = false,
    // Extension: VK_KHR_maintenance5
    // bit: 14
    VK_BUFFER_USAGE_2_VIDEO_DECODE_DST_BIT_KHR: bool = false,
    // Extension: VK_KHR_maintenance5
    // bit: 15
    VK_BUFFER_USAGE_2_VIDEO_ENCODE_DST_BIT_KHR: bool = false,
    // Extension: VK_KHR_maintenance5
    // bit: 16
    VK_BUFFER_USAGE_2_VIDEO_ENCODE_SRC_BIT_KHR: bool = false,
    // Extension: VK_BASE_VERSION_1_4
    // Alias: VK_BUFFER_USAGE_2_SHADER_DEVICE_ADDRESS_BIT_KHR
    // bit: 17
    VK_BUFFER_USAGE_2_SHADER_DEVICE_ADDRESS_BIT: bool = false,
    _17: u1 = 0,
    // Extension: VK_KHR_maintenance5
    // bit: 19
    VK_BUFFER_USAGE_2_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR: bool = false,
    // Extension: VK_KHR_maintenance5
    // bit: 20
    VK_BUFFER_USAGE_2_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR: bool = false,
    // Extension: VK_KHR_maintenance5
    // bit: 21
    VK_BUFFER_USAGE_2_SAMPLER_DESCRIPTOR_BUFFER_BIT_EXT: bool = false,
    // Extension: VK_KHR_maintenance5
    // bit: 22
    VK_BUFFER_USAGE_2_RESOURCE_DESCRIPTOR_BUFFER_BIT_EXT: bool = false,
    // Extension: VK_KHR_maintenance5
    // bit: 23
    VK_BUFFER_USAGE_2_MICROMAP_BUILD_INPUT_READ_ONLY_BIT_EXT: bool = false,
    // Extension: VK_KHR_maintenance5
    // bit: 24
    VK_BUFFER_USAGE_2_MICROMAP_STORAGE_BIT_EXT: bool = false,
    // Extension: VK_AMDX_shader_enqueue
    // bit: 25
    VK_BUFFER_USAGE_2_EXECUTION_GRAPH_SCRATCH_BIT_AMDX: bool = false,
    // Extension: VK_KHR_maintenance5
    // bit: 26
    VK_BUFFER_USAGE_2_PUSH_DESCRIPTORS_DESCRIPTOR_BUFFER_BIT_EXT: bool = false,
    // Extension: VK_QCOM_tile_memory_heap
    // bit: 27
    VK_BUFFER_USAGE_2_TILE_MEMORY_BIT_QCOM: bool = false,
    _27: u1 = 0,
    // Extension: VK_ARM_data_graph
    // bit: 29
    VK_BUFFER_USAGE_2_DATA_GRAPH_FOREIGN_DESCRIPTOR_BIT_ARM: bool = false,
    _29: u1 = 0,
    // Extension: VK_EXT_device_generated_commands
    // bit: 31
    VK_BUFFER_USAGE_2_PREPROCESS_BUFFER_BIT_EXT: bool = false,
    // Extension: VK_EXT_memory_decompression
    // bit: 32
    VK_BUFFER_USAGE_2_MEMORY_DECOMPRESSION_BIT_EXT: bool = false,
    // Extension: VK_AMDX_dense_geometry_format
    // bit: 33
    VK_BUFFER_USAGE_2_COMPRESSED_DATA_DGF1_BIT_AMDX: bool = false,
    _: u30 = 0,
};
pub const VkAddressCopyFlagsKHR = packed struct(u32) {
    // bit: 0
    VK_ADDRESS_COPY_DEVICE_LOCAL_BIT_KHR: bool = false,
    // bit: 1
    VK_ADDRESS_COPY_SPARSE_BIT_KHR: bool = false,
    // bit: 2
    VK_ADDRESS_COPY_PROTECTED_BIT_KHR: bool = false,
    _: u29 = 0,
};
pub const VkTensorCreateFlagsARM = packed struct(u64) {
    // bit: 0
    VK_TENSOR_CREATE_MUTABLE_FORMAT_BIT_ARM: bool = false,
    // bit: 1
    VK_TENSOR_CREATE_PROTECTED_BIT_ARM: bool = false,
    // Extension: VK_ARM_tensors
    // bit: 2
    VK_TENSOR_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_ARM: bool = false,
    _: u61 = 0,
};
pub const VkTensorUsageFlagsARM = packed struct(u64) {
    _0: u1 = 0,
    // Comment: Tensor written/read through shader descriptor
    // bit: 1
    VK_TENSOR_USAGE_SHADER_BIT_ARM: bool = false,
    // Comment: Tensor can be src of a transfer operation
    // bit: 2
    VK_TENSOR_USAGE_TRANSFER_SRC_BIT_ARM: bool = false,
    // Comment: Tensor can be dst of a transfer operation
    // bit: 3
    VK_TENSOR_USAGE_TRANSFER_DST_BIT_ARM: bool = false,
    // Comment: Tensor can be aliased with an image
    // bit: 4
    VK_TENSOR_USAGE_IMAGE_ALIASING_BIT_ARM: bool = false,
    // Extension: VK_ARM_data_graph
    // bit: 5
    VK_TENSOR_USAGE_DATA_GRAPH_BIT_ARM: bool = false,
    _: u58 = 0,
};
pub const VkTensorViewCreateFlagsARM = packed struct(u64) {
    // Extension: VK_ARM_tensors
    // bit: 0
    VK_TENSOR_VIEW_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_ARM: bool = false,
    _: u63 = 0,
};
pub const VkDataGraphPipelineSessionCreateFlagsARM = packed struct(u64) {
    // bit: 0
    VK_DATA_GRAPH_PIPELINE_SESSION_CREATE_PROTECTED_BIT_ARM: bool = false,
    _: u63 = 0,
};
pub const VkDataGraphPipelineDispatchFlagsARM = packed struct(u64) {
    _: u64 = 0,
};
pub const VkVideoEncodeRgbModelConversionFlagsVALVE = packed struct(u32) {
    // bit: 0
    VK_VIDEO_ENCODE_RGB_MODEL_CONVERSION_RGB_IDENTITY_BIT_VALVE: bool = false,
    // bit: 1
    VK_VIDEO_ENCODE_RGB_MODEL_CONVERSION_YCBCR_IDENTITY_BIT_VALVE: bool = false,
    // bit: 2
    VK_VIDEO_ENCODE_RGB_MODEL_CONVERSION_YCBCR_709_BIT_VALVE: bool = false,
    // bit: 3
    VK_VIDEO_ENCODE_RGB_MODEL_CONVERSION_YCBCR_601_BIT_VALVE: bool = false,
    // bit: 4
    VK_VIDEO_ENCODE_RGB_MODEL_CONVERSION_YCBCR_2020_BIT_VALVE: bool = false,
    _: u27 = 0,
};
pub const VkVideoEncodeRgbRangeCompressionFlagsVALVE = packed struct(u32) {
    // bit: 0
    VK_VIDEO_ENCODE_RGB_RANGE_COMPRESSION_FULL_RANGE_BIT_VALVE: bool = false,
    // bit: 1
    VK_VIDEO_ENCODE_RGB_RANGE_COMPRESSION_NARROW_RANGE_BIT_VALVE: bool = false,
    _: u30 = 0,
};
pub const VkVideoEncodeRgbChromaOffsetFlagsVALVE = packed struct(u32) {
    // bit: 0
    VK_VIDEO_ENCODE_RGB_CHROMA_OFFSET_COSITED_EVEN_BIT_VALVE: bool = false,
    // bit: 1
    VK_VIDEO_ENCODE_RGB_CHROMA_OFFSET_MIDPOINT_BIT_VALVE: bool = false,
    _: u30 = 0,
};
pub const VkCompositeAlphaFlagsKHR = packed struct(u32) {
    // bit: 0
    VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR: bool = false,
    // bit: 1
    VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR: bool = false,
    // bit: 2
    VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR: bool = false,
    // bit: 3
    VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR: bool = false,
    _: u28 = 0,
};
pub const VkDisplayPlaneAlphaFlagsKHR = packed struct(u32) {
    // bit: 0
    VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR: bool = false,
    // bit: 1
    VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR: bool = false,
    // bit: 2
    VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR: bool = false,
    // bit: 3
    VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR: bool = false,
    _: u28 = 0,
};
pub const VkSurfaceTransformFlagsKHR = packed struct(u32) {
    // bit: 0
    VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR: bool = false,
    // bit: 1
    VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR: bool = false,
    // bit: 2
    VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR: bool = false,
    // bit: 3
    VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR: bool = false,
    // bit: 4
    VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR: bool = false,
    // bit: 5
    VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR: bool = false,
    // bit: 6
    VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR: bool = false,
    // bit: 7
    VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR: bool = false,
    // bit: 8
    VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR: bool = false,
    _: u23 = 0,
};
pub const VkSwapchainCreateFlagsKHR = packed struct(u32) {
    // Extension: VK_KHR_swapchain
    // Extension: VK_KHR_device_group
    // bit: 0
    VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR: bool = false,
    // Extension: VK_KHR_swapchain
    // bit: 1
    VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR: bool = false,
    // Extension: VK_KHR_swapchain_mutable_format
    // bit: 2
    VK_SWAPCHAIN_CREATE_MUTABLE_FORMAT_BIT_KHR: bool = false,
    // Extension: VK_KHR_swapchain_maintenance1
    // Alias: VK_SWAPCHAIN_CREATE_DEFERRED_MEMORY_ALLOCATION_BIT_EXT
    // bit: 3
    VK_SWAPCHAIN_CREATE_DEFERRED_MEMORY_ALLOCATION_BIT_KHR: bool = false,
    _3: u2 = 0,
    // Extension: VK_KHR_present_id2
    // bit: 6
    VK_SWAPCHAIN_CREATE_PRESENT_ID_2_BIT_KHR: bool = false,
    // Extension: VK_KHR_present_wait2
    // bit: 7
    VK_SWAPCHAIN_CREATE_PRESENT_WAIT_2_BIT_KHR: bool = false,
    _7: u1 = 0,
    // Extension: VK_EXT_present_timing
    // bit: 9
    VK_SWAPCHAIN_CREATE_PRESENT_TIMING_BIT_EXT: bool = false,
    _: u22 = 0,
};
pub const VkPeerMemoryFeatureFlags = packed struct(u32) {
    // Alias: VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT_KHR
    // Comment: Can read with vkCmdCopy commands
    // bit: 0
    VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT: bool = false,
    // Alias: VK_PEER_MEMORY_FEATURE_COPY_DST_BIT_KHR
    // Comment: Can write with vkCmdCopy commands
    // bit: 1
    VK_PEER_MEMORY_FEATURE_COPY_DST_BIT: bool = false,
    // Alias: VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT_KHR
    // Comment: Can read with any access type/command
    // bit: 2
    VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT: bool = false,
    // Alias: VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT_KHR
    // Comment: Can write with and access type/command
    // bit: 3
    VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT: bool = false,
    _: u28 = 0,
};
pub const VkMemoryAllocateFlags = packed struct(u32) {
    // Alias: VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT_KHR
    // Comment: Force allocation on specific devices
    // bit: 0
    VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT: bool = false,
    // Extension: VK_BASE_VERSION_1_2
    // Alias: VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT_KHR
    // bit: 1
    VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT: bool = false,
    // Extension: VK_BASE_VERSION_1_2
    // Alias: VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR
    // bit: 2
    VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT: bool = false,
    // Extension: VK_EXT_zero_initialize_device_memory
    // bit: 3
    VK_MEMORY_ALLOCATE_ZERO_INITIALIZE_BIT_EXT: bool = false,
    _: u28 = 0,
};
pub const VkDeviceGroupPresentModeFlagsKHR = packed struct(u32) {
    // Comment: Present from local memory
    // bit: 0
    VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR: bool = false,
    // Comment: Present from remote memory
    // bit: 1
    VK_DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHR: bool = false,
    // Comment: Present sum of local and/or remote memory
    // bit: 2
    VK_DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHR: bool = false,
    // Comment: Each physical device presents from local memory
    // bit: 3
    VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHR: bool = false,
    _: u28 = 0,
};
pub const VkDebugReportFlagsEXT = packed struct(u32) {
    // bit: 0
    VK_DEBUG_REPORT_INFORMATION_BIT_EXT: bool = false,
    // bit: 1
    VK_DEBUG_REPORT_WARNING_BIT_EXT: bool = false,
    // bit: 2
    VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT: bool = false,
    // bit: 3
    VK_DEBUG_REPORT_ERROR_BIT_EXT: bool = false,
    // bit: 4
    VK_DEBUG_REPORT_DEBUG_BIT_EXT: bool = false,
    _: u27 = 0,
};
pub const VkExternalMemoryHandleTypeFlagsNV = packed struct(u32) {
    // bit: 0
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV: bool = false,
    // bit: 1
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_NV: bool = false,
    // bit: 2
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_BIT_NV: bool = false,
    // bit: 3
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_KMT_BIT_NV: bool = false,
    _: u28 = 0,
};
pub const VkClusterAccelerationStructureIndexFormatFlagsNV = packed struct(u32) {
    // bit: 0
    VK_CLUSTER_ACCELERATION_STRUCTURE_INDEX_FORMAT_8BIT_NV: bool = false,
    // bit: 1
    VK_CLUSTER_ACCELERATION_STRUCTURE_INDEX_FORMAT_16BIT_NV: bool = false,
    // bit: 2
    VK_CLUSTER_ACCELERATION_STRUCTURE_INDEX_FORMAT_32BIT_NV: bool = false,
    _: u29 = 0,
};
pub const VkExternalMemoryFeatureFlagsNV = packed struct(u32) {
    // bit: 0
    VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV: bool = false,
    // bit: 1
    VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_NV: bool = false,
    // bit: 2
    VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_NV: bool = false,
    _: u29 = 0,
};
pub const VkExternalMemoryHandleTypeFlags = packed struct(u32) {
    // Alias: VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT_KHR
    // bit: 0
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT: bool = false,
    // Alias: VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR
    // bit: 1
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT: bool = false,
    // Alias: VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR
    // bit: 2
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT: bool = false,
    // Alias: VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT_KHR
    // bit: 3
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT: bool = false,
    // Alias: VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT_KHR
    // bit: 4
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT: bool = false,
    // Alias: VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT_KHR
    // bit: 5
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT: bool = false,
    // Alias: VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT_KHR
    // bit: 6
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT: bool = false,
    // Extension: VK_EXT_external_memory_host
    // bit: 7
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT: bool = false,
    // Extension: VK_EXT_external_memory_host
    // bit: 8
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT: bool = false,
    // Extension: VK_EXT_external_memory_dma_buf
    // bit: 9
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT: bool = false,
    // Extension: VK_ANDROID_external_memory_android_hardware_buffer
    // bit: 10
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID: bool = false,
    // Extension: VK_FUCHSIA_external_memory
    // bit: 11
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_ZIRCON_VMO_BIT_FUCHSIA: bool = false,
    // Extension: VK_NV_external_memory_rdma
    // bit: 12
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_RDMA_ADDRESS_BIT_NV: bool = false,
    // Extension: VK_NV_external_memory_sci_buf
    // bit: 13
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_SCI_BUF_BIT_NV: bool = false,
    // Extension: VK_QNX_external_memory_screen_buffer
    // bit: 14
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_SCREEN_BUFFER_BIT_QNX: bool = false,
    // Extension: VK_OHOS_external_memory
    // bit: 15
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_OH_NATIVE_BUFFER_BIT_OHOS: bool = false,
    // Extension: VK_EXT_external_memory_metal
    // bit: 16
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLBUFFER_BIT_EXT: bool = false,
    // Extension: VK_EXT_external_memory_metal
    // bit: 17
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLTEXTURE_BIT_EXT: bool = false,
    // Extension: VK_EXT_external_memory_metal
    // bit: 18
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLHEAP_BIT_EXT: bool = false,
    _: u13 = 0,
};
pub const VkExternalMemoryFeatureFlags = packed struct(u32) {
    // Alias: VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_KHR
    // bit: 0
    VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT: bool = false,
    // Alias: VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_KHR
    // bit: 1
    VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT: bool = false,
    // Alias: VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_KHR
    // bit: 2
    VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT: bool = false,
    _: u29 = 0,
};
pub const VkExternalSemaphoreHandleTypeFlags = packed struct(u32) {
    // Alias: VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR
    // bit: 0
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT: bool = false,
    // Alias: VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR
    // bit: 1
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT: bool = false,
    // Alias: VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR
    // bit: 2
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT: bool = false,
    // Alias: VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT_KHR
    // bit: 3
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT: bool = false,
    // Alias: VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT_KHR
    // bit: 4
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT: bool = false,
    // Extension: VK_NV_external_sci_sync
    // bit: 5
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SCI_SYNC_OBJ_BIT_NV: bool = false,
    _5: u1 = 0,
    // Extension: VK_FUCHSIA_external_semaphore
    // bit: 7
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_ZIRCON_EVENT_BIT_FUCHSIA: bool = false,
    _: u24 = 0,
};
pub const VkExternalSemaphoreFeatureFlags = packed struct(u32) {
    // Alias: VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT_KHR
    // bit: 0
    VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT: bool = false,
    // Alias: VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT_KHR
    // bit: 1
    VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT: bool = false,
    _: u30 = 0,
};
pub const VkSemaphoreImportFlags = packed struct(u32) {
    // Alias: VK_SEMAPHORE_IMPORT_TEMPORARY_BIT_KHR
    // bit: 0
    VK_SEMAPHORE_IMPORT_TEMPORARY_BIT: bool = false,
    _: u31 = 0,
};
pub const VkExternalFenceHandleTypeFlags = packed struct(u32) {
    // Alias: VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR
    // bit: 0
    VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT: bool = false,
    // Alias: VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR
    // bit: 1
    VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT: bool = false,
    // Alias: VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR
    // bit: 2
    VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT: bool = false,
    // Alias: VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT_KHR
    // bit: 3
    VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT: bool = false,
    // Extension: VK_NV_external_sci_sync
    // Extension: VK_NV_external_sci_sync2
    // bit: 4
    VK_EXTERNAL_FENCE_HANDLE_TYPE_SCI_SYNC_OBJ_BIT_NV: bool = false,
    // Extension: VK_NV_external_sci_sync
    // Extension: VK_NV_external_sci_sync2
    // bit: 5
    VK_EXTERNAL_FENCE_HANDLE_TYPE_SCI_SYNC_FENCE_BIT_NV: bool = false,
    _: u26 = 0,
};
pub const VkExternalFenceFeatureFlags = packed struct(u32) {
    // Alias: VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT_KHR
    // bit: 0
    VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT: bool = false,
    // Alias: VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT_KHR
    // bit: 1
    VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT: bool = false,
    _: u30 = 0,
};
pub const VkFenceImportFlags = packed struct(u32) {
    // Alias: VK_FENCE_IMPORT_TEMPORARY_BIT_KHR
    // bit: 0
    VK_FENCE_IMPORT_TEMPORARY_BIT: bool = false,
    _: u31 = 0,
};
pub const VkSurfaceCounterFlagsEXT = packed struct(u32) {
    // bit: 0
    VK_SURFACE_COUNTER_VBLANK_BIT_EXT: bool = false,
    _: u31 = 0,
};
pub const VkDebugUtilsMessageSeverityFlagsEXT = packed struct(u32) {
    // bit: 0
    VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT: bool = false,
    // bit: 4
    VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT: bool = false,
    _4: u3 = 0,
    // bit: 8
    VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT: bool = false,
    _8: u3 = 0,
    // bit: 12
    VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT: bool = false,
    _: u19 = 0,
};
pub const VkDebugUtilsMessageTypeFlagsEXT = packed struct(u32) {
    // bit: 0
    VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT: bool = false,
    // bit: 1
    VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT: bool = false,
    // bit: 2
    VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT: bool = false,
    // Extension: VK_EXT_device_address_binding_report
    // bit: 3
    VK_DEBUG_UTILS_MESSAGE_TYPE_DEVICE_ADDRESS_BINDING_BIT_EXT: bool = false,
    _: u28 = 0,
};
pub const VkDescriptorBindingFlags = packed struct(u32) {
    // Alias: VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT
    // bit: 0
    VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT: bool = false,
    // Alias: VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT_EXT
    // bit: 1
    VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT: bool = false,
    // Alias: VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT_EXT
    // bit: 2
    VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT: bool = false,
    // Alias: VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT
    // bit: 3
    VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT: bool = false,
    _: u28 = 0,
};
pub const VkConditionalRenderingFlagsEXT = packed struct(u32) {
    // bit: 0
    VK_CONDITIONAL_RENDERING_INVERTED_BIT_EXT: bool = false,
    _: u31 = 0,
};
pub const VkResolveModeFlags = packed struct(u32) {
    // Alias: VK_RESOLVE_MODE_SAMPLE_ZERO_BIT_KHR
    // bit: 0
    VK_RESOLVE_MODE_SAMPLE_ZERO_BIT: bool = false,
    // Alias: VK_RESOLVE_MODE_AVERAGE_BIT_KHR
    // bit: 1
    VK_RESOLVE_MODE_AVERAGE_BIT: bool = false,
    // Alias: VK_RESOLVE_MODE_MIN_BIT_KHR
    // bit: 2
    VK_RESOLVE_MODE_MIN_BIT: bool = false,
    // Alias: VK_RESOLVE_MODE_MAX_BIT_KHR
    // bit: 3
    VK_RESOLVE_MODE_MAX_BIT: bool = false,
    // Extension: VK_ANDROID_external_format_resolve
    // Alias: VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID
    // bit: 4
    VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_BIT_ANDROID: bool = false,
    // Extension: VK_EXT_custom_resolve
    // bit: 5
    VK_RESOLVE_MODE_CUSTOM_BIT_EXT: bool = false,
    _: u26 = 0,
    pub const VK_RESOLVE_MODE_NONE: @This() = @bitCast(@as(u32, 0x0));
};
pub const VkSwapchainImageUsageFlagsANDROID = packed struct(u32) {
    // bit: 0
    VK_SWAPCHAIN_IMAGE_USAGE_SHARED_BIT_ANDROID: bool = false,
    _: u31 = 0,
};
pub const VkToolPurposeFlags = packed struct(u32) {
    // Alias: VK_TOOL_PURPOSE_VALIDATION_BIT_EXT
    // bit: 0
    VK_TOOL_PURPOSE_VALIDATION_BIT: bool = false,
    // Alias: VK_TOOL_PURPOSE_PROFILING_BIT_EXT
    // bit: 1
    VK_TOOL_PURPOSE_PROFILING_BIT: bool = false,
    // Alias: VK_TOOL_PURPOSE_TRACING_BIT_EXT
    // bit: 2
    VK_TOOL_PURPOSE_TRACING_BIT: bool = false,
    // Alias: VK_TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT_EXT
    // bit: 3
    VK_TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT: bool = false,
    // Alias: VK_TOOL_PURPOSE_MODIFYING_FEATURES_BIT_EXT
    // bit: 4
    VK_TOOL_PURPOSE_MODIFYING_FEATURES_BIT: bool = false,
    // Extension: VK_EXT_tooling_info
    // Extension: VK_EXT_tooling_info
    // bit: 5
    VK_TOOL_PURPOSE_DEBUG_REPORTING_BIT_EXT: bool = false,
    // Extension: VK_EXT_tooling_info
    // Extension: VK_EXT_tooling_info
    // bit: 6
    VK_TOOL_PURPOSE_DEBUG_MARKERS_BIT_EXT: bool = false,
    _: u25 = 0,
};
pub const VkSubmitFlags = packed struct(u32) {
    // Alias: VK_SUBMIT_PROTECTED_BIT_KHR
    // bit: 0
    VK_SUBMIT_PROTECTED_BIT: bool = false,
    _: u31 = 0,
};
pub const VkHostImageCopyFlags = packed struct(u32) {
    // Alias: VK_HOST_IMAGE_COPY_MEMCPY_BIT_EXT
    // Alias: VK_HOST_IMAGE_COPY_MEMCPY_EXT
    // bit: 0
    VK_HOST_IMAGE_COPY_MEMCPY_BIT: bool = false,
    _: u31 = 0,
};
pub const VkPartitionedAccelerationStructureInstanceFlagsNV = packed struct(u32) {
    // bit: 0
    VK_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCE_FLAG_TRIANGLE_FACING_CULL_DISABLE_BIT_NV: bool = false,
    // bit: 1
    VK_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCE_FLAG_TRIANGLE_FLIP_FACING_BIT_NV: bool = false,
    // bit: 2
    VK_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCE_FLAG_FORCE_OPAQUE_BIT_NV: bool = false,
    // bit: 3
    VK_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCE_FLAG_FORCE_NO_OPAQUE_BIT_NV: bool = false,
    // bit: 4
    VK_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCE_FLAG_ENABLE_EXPLICIT_BOUNDING_BOX_NV: bool = false,
    _: u27 = 0,
};
pub const VkImageConstraintsInfoFlagsFUCHSIA = packed struct(u32) {
    // bit: 0
    VK_IMAGE_CONSTRAINTS_INFO_CPU_READ_RARELY_FUCHSIA: bool = false,
    // bit: 1
    VK_IMAGE_CONSTRAINTS_INFO_CPU_READ_OFTEN_FUCHSIA: bool = false,
    // bit: 2
    VK_IMAGE_CONSTRAINTS_INFO_CPU_WRITE_RARELY_FUCHSIA: bool = false,
    // bit: 3
    VK_IMAGE_CONSTRAINTS_INFO_CPU_WRITE_OFTEN_FUCHSIA: bool = false,
    // bit: 4
    VK_IMAGE_CONSTRAINTS_INFO_PROTECTED_OPTIONAL_FUCHSIA: bool = false,
    _: u27 = 0,
};
pub const VkGraphicsPipelineLibraryFlagsEXT = packed struct(u32) {
    // bit: 0
    VK_GRAPHICS_PIPELINE_LIBRARY_VERTEX_INPUT_INTERFACE_BIT_EXT: bool = false,
    // bit: 1
    VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT: bool = false,
    // bit: 2
    VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT: bool = false,
    // bit: 3
    VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_OUTPUT_INTERFACE_BIT_EXT: bool = false,
    _: u28 = 0,
};
pub const VkImageCompressionFlagsEXT = packed struct(u32) {
    // bit: 0
    VK_IMAGE_COMPRESSION_FIXED_RATE_DEFAULT_EXT: bool = false,
    // bit: 1
    VK_IMAGE_COMPRESSION_FIXED_RATE_EXPLICIT_EXT: bool = false,
    // bit: 2
    VK_IMAGE_COMPRESSION_DISABLED_EXT: bool = false,
    _: u29 = 0,
    pub const VK_IMAGE_COMPRESSION_DEFAULT_EXT: @This() = @bitCast(@as(u32, 0x0));
};
pub const VkImageCompressionFixedRateFlagsEXT = packed struct(u32) {
    // bit: 0
    VK_IMAGE_COMPRESSION_FIXED_RATE_1BPC_BIT_EXT: bool = false,
    // bit: 1
    VK_IMAGE_COMPRESSION_FIXED_RATE_2BPC_BIT_EXT: bool = false,
    // bit: 2
    VK_IMAGE_COMPRESSION_FIXED_RATE_3BPC_BIT_EXT: bool = false,
    // bit: 3
    VK_IMAGE_COMPRESSION_FIXED_RATE_4BPC_BIT_EXT: bool = false,
    // bit: 4
    VK_IMAGE_COMPRESSION_FIXED_RATE_5BPC_BIT_EXT: bool = false,
    // bit: 5
    VK_IMAGE_COMPRESSION_FIXED_RATE_6BPC_BIT_EXT: bool = false,
    // bit: 6
    VK_IMAGE_COMPRESSION_FIXED_RATE_7BPC_BIT_EXT: bool = false,
    // bit: 7
    VK_IMAGE_COMPRESSION_FIXED_RATE_8BPC_BIT_EXT: bool = false,
    // bit: 8
    VK_IMAGE_COMPRESSION_FIXED_RATE_9BPC_BIT_EXT: bool = false,
    // bit: 9
    VK_IMAGE_COMPRESSION_FIXED_RATE_10BPC_BIT_EXT: bool = false,
    // bit: 10
    VK_IMAGE_COMPRESSION_FIXED_RATE_11BPC_BIT_EXT: bool = false,
    // bit: 11
    VK_IMAGE_COMPRESSION_FIXED_RATE_12BPC_BIT_EXT: bool = false,
    // bit: 12
    VK_IMAGE_COMPRESSION_FIXED_RATE_13BPC_BIT_EXT: bool = false,
    // bit: 13
    VK_IMAGE_COMPRESSION_FIXED_RATE_14BPC_BIT_EXT: bool = false,
    // bit: 14
    VK_IMAGE_COMPRESSION_FIXED_RATE_15BPC_BIT_EXT: bool = false,
    // bit: 15
    VK_IMAGE_COMPRESSION_FIXED_RATE_16BPC_BIT_EXT: bool = false,
    // bit: 16
    VK_IMAGE_COMPRESSION_FIXED_RATE_17BPC_BIT_EXT: bool = false,
    // bit: 17
    VK_IMAGE_COMPRESSION_FIXED_RATE_18BPC_BIT_EXT: bool = false,
    // bit: 18
    VK_IMAGE_COMPRESSION_FIXED_RATE_19BPC_BIT_EXT: bool = false,
    // bit: 19
    VK_IMAGE_COMPRESSION_FIXED_RATE_20BPC_BIT_EXT: bool = false,
    // bit: 20
    VK_IMAGE_COMPRESSION_FIXED_RATE_21BPC_BIT_EXT: bool = false,
    // bit: 21
    VK_IMAGE_COMPRESSION_FIXED_RATE_22BPC_BIT_EXT: bool = false,
    // bit: 22
    VK_IMAGE_COMPRESSION_FIXED_RATE_23BPC_BIT_EXT: bool = false,
    // bit: 23
    VK_IMAGE_COMPRESSION_FIXED_RATE_24BPC_BIT_EXT: bool = false,
    _: u8 = 0,
    pub const VK_IMAGE_COMPRESSION_FIXED_RATE_NONE_EXT: @This() = @bitCast(@as(u32, 0x0));
};
pub const VkExportMetalObjectTypeFlagsEXT = packed struct(u32) {
    // bit: 0
    VK_EXPORT_METAL_OBJECT_TYPE_METAL_DEVICE_BIT_EXT: bool = false,
    // bit: 1
    VK_EXPORT_METAL_OBJECT_TYPE_METAL_COMMAND_QUEUE_BIT_EXT: bool = false,
    // bit: 2
    VK_EXPORT_METAL_OBJECT_TYPE_METAL_BUFFER_BIT_EXT: bool = false,
    // bit: 3
    VK_EXPORT_METAL_OBJECT_TYPE_METAL_TEXTURE_BIT_EXT: bool = false,
    // bit: 4
    VK_EXPORT_METAL_OBJECT_TYPE_METAL_IOSURFACE_BIT_EXT: bool = false,
    // bit: 5
    VK_EXPORT_METAL_OBJECT_TYPE_METAL_SHARED_EVENT_BIT_EXT: bool = false,
    _: u26 = 0,
};
pub const VkRenderingAttachmentFlagsKHR = packed struct(u32) {
    // Extension: VK_KHR_maintenance10
    // bit: 0
    VK_RENDERING_ATTACHMENT_INPUT_ATTACHMENT_FEEDBACK_BIT_KHR: bool = false,
    // Extension: VK_KHR_maintenance10
    // bit: 1
    VK_RENDERING_ATTACHMENT_RESOLVE_SKIP_TRANSFER_FUNCTION_BIT_KHR: bool = false,
    // Extension: VK_KHR_maintenance10
    // bit: 2
    VK_RENDERING_ATTACHMENT_RESOLVE_ENABLE_TRANSFER_FUNCTION_BIT_KHR: bool = false,
    _: u29 = 0,
};
pub const VkResolveImageFlagsKHR = packed struct(u32) {
    // Extension: VK_KHR_maintenance10
    // bit: 0
    VK_RESOLVE_IMAGE_SKIP_TRANSFER_FUNCTION_BIT_KHR: bool = false,
    // Extension: VK_KHR_maintenance10
    // bit: 1
    VK_RESOLVE_IMAGE_ENABLE_TRANSFER_FUNCTION_BIT_KHR: bool = false,
    _: u30 = 0,
};
pub const VkDeviceAddressBindingFlagsEXT = packed struct(u32) {
    // bit: 0
    VK_DEVICE_ADDRESS_BINDING_INTERNAL_OBJECT_BIT_EXT: bool = false,
    _: u31 = 0,
};
pub const VkOpticalFlowGridSizeFlagsNV = packed struct(u32) {
    // bit: 0
    VK_OPTICAL_FLOW_GRID_SIZE_1X1_BIT_NV: bool = false,
    // bit: 1
    VK_OPTICAL_FLOW_GRID_SIZE_2X2_BIT_NV: bool = false,
    // bit: 2
    VK_OPTICAL_FLOW_GRID_SIZE_4X4_BIT_NV: bool = false,
    // bit: 3
    VK_OPTICAL_FLOW_GRID_SIZE_8X8_BIT_NV: bool = false,
    _: u28 = 0,
    pub const VK_OPTICAL_FLOW_GRID_SIZE_UNKNOWN_NV: @This() = @bitCast(@as(u32, 0x0));
};
pub const VkOpticalFlowUsageFlagsNV = packed struct(u32) {
    // bit: 0
    VK_OPTICAL_FLOW_USAGE_INPUT_BIT_NV: bool = false,
    // bit: 1
    VK_OPTICAL_FLOW_USAGE_OUTPUT_BIT_NV: bool = false,
    // bit: 2
    VK_OPTICAL_FLOW_USAGE_HINT_BIT_NV: bool = false,
    // bit: 3
    VK_OPTICAL_FLOW_USAGE_COST_BIT_NV: bool = false,
    // bit: 4
    VK_OPTICAL_FLOW_USAGE_GLOBAL_FLOW_BIT_NV: bool = false,
    _: u27 = 0,
    pub const VK_OPTICAL_FLOW_USAGE_UNKNOWN_NV: @This() = @bitCast(@as(u32, 0x0));
};
pub const VkOpticalFlowSessionCreateFlagsNV = packed struct(u32) {
    // bit: 0
    VK_OPTICAL_FLOW_SESSION_CREATE_ENABLE_HINT_BIT_NV: bool = false,
    // bit: 1
    VK_OPTICAL_FLOW_SESSION_CREATE_ENABLE_COST_BIT_NV: bool = false,
    // bit: 2
    VK_OPTICAL_FLOW_SESSION_CREATE_ENABLE_GLOBAL_FLOW_BIT_NV: bool = false,
    // bit: 3
    VK_OPTICAL_FLOW_SESSION_CREATE_ALLOW_REGIONS_BIT_NV: bool = false,
    // bit: 4
    VK_OPTICAL_FLOW_SESSION_CREATE_BOTH_DIRECTIONS_BIT_NV: bool = false,
    _: u27 = 0,
};
pub const VkOpticalFlowExecuteFlagsNV = packed struct(u32) {
    // bit: 0
    VK_OPTICAL_FLOW_EXECUTE_DISABLE_TEMPORAL_HINTS_BIT_NV: bool = false,
    _: u31 = 0,
};
pub const VkFrameBoundaryFlagsEXT = packed struct(u32) {
    // bit: 0
    VK_FRAME_BOUNDARY_FRAME_END_BIT_EXT: bool = false,
    _: u31 = 0,
};
pub const VkPresentScalingFlagsKHR = packed struct(u32) {
    // bit: 0
    VK_PRESENT_SCALING_ONE_TO_ONE_BIT_KHR: bool = false,
    // bit: 1
    VK_PRESENT_SCALING_ASPECT_RATIO_STRETCH_BIT_KHR: bool = false,
    // bit: 2
    VK_PRESENT_SCALING_STRETCH_BIT_KHR: bool = false,
    _: u29 = 0,
};
pub const VkPresentGravityFlagsKHR = packed struct(u32) {
    // bit: 0
    VK_PRESENT_GRAVITY_MIN_BIT_KHR: bool = false,
    // bit: 1
    VK_PRESENT_GRAVITY_MAX_BIT_KHR: bool = false,
    // bit: 2
    VK_PRESENT_GRAVITY_CENTERED_BIT_KHR: bool = false,
    _: u29 = 0,
};
pub const VkShaderCreateFlagsEXT = packed struct(u32) {
    // bit: 0
    VK_SHADER_CREATE_LINK_STAGE_BIT_EXT: bool = false,
    // Extension: VK_EXT_shader_object
    // bit: 1
    VK_SHADER_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT: bool = false,
    // Extension: VK_EXT_shader_object
    // bit: 2
    VK_SHADER_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT: bool = false,
    // Extension: VK_EXT_shader_object
    // bit: 3
    VK_SHADER_CREATE_NO_TASK_SHADER_BIT_EXT: bool = false,
    // Extension: VK_EXT_shader_object
    // bit: 4
    VK_SHADER_CREATE_DISPATCH_BASE_BIT_EXT: bool = false,
    // Extension: VK_EXT_shader_object
    // bit: 5
    VK_SHADER_CREATE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_EXT: bool = false,
    // Extension: VK_EXT_shader_object
    // bit: 6
    VK_SHADER_CREATE_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT: bool = false,
    // Extension: VK_EXT_device_generated_commands
    // bit: 7
    VK_SHADER_CREATE_INDIRECT_BINDABLE_BIT_EXT: bool = false,
    _7: u7 = 0,
    // Extension: VK_EXT_shader_64bit_indexing
    // bit: 15
    VK_SHADER_CREATE_64_BIT_INDEXING_BIT_EXT: bool = false,
    _: u16 = 0,
};
pub const VkTileShadingRenderPassFlagsQCOM = packed struct(u32) {
    // bit: 0
    VK_TILE_SHADING_RENDER_PASS_ENABLE_BIT_QCOM: bool = false,
    // bit: 1
    VK_TILE_SHADING_RENDER_PASS_PER_TILE_EXECUTION_BIT_QCOM: bool = false,
    _: u30 = 0,
};
pub const VkPhysicalDeviceSchedulingControlsFlagsARM = packed struct(u64) {
    // bit: 0
    VK_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_SHADER_CORE_COUNT_ARM: bool = false,
    _: u63 = 0,
};
pub const VkPresentStageFlagsEXT = packed struct(u32) {
    // bit: 0
    VK_PRESENT_STAGE_QUEUE_OPERATIONS_END_BIT_EXT: bool = false,
    // bit: 1
    VK_PRESENT_STAGE_REQUEST_DEQUEUED_BIT_EXT: bool = false,
    // bit: 2
    VK_PRESENT_STAGE_IMAGE_FIRST_PIXEL_OUT_BIT_EXT: bool = false,
    // bit: 3
    VK_PRESENT_STAGE_IMAGE_FIRST_PIXEL_VISIBLE_BIT_EXT: bool = false,
    _: u28 = 0,
};
pub const VkPastPresentationTimingFlagsEXT = packed struct(u32) {
    // bit: 0
    VK_PAST_PRESENTATION_TIMING_ALLOW_PARTIAL_RESULTS_BIT_EXT: bool = false,
    // bit: 1
    VK_PAST_PRESENTATION_TIMING_ALLOW_OUT_OF_ORDER_RESULTS_BIT_EXT: bool = false,
    _: u30 = 0,
};
pub const VkPresentTimingInfoFlagsEXT = packed struct(u32) {
    // bit: 0
    VK_PRESENT_TIMING_INFO_PRESENT_AT_RELATIVE_TIME_BIT_EXT: bool = false,
    // bit: 1
    VK_PRESENT_TIMING_INFO_PRESENT_AT_NEAREST_REFRESH_CYCLE_BIT_EXT: bool = false,
    _: u30 = 0,
};
pub const VkSwapchainImageUsageFlagsOHOS = packed struct(u32) {
    // bit: 0
    VK_SWAPCHAIN_IMAGE_USAGE_SHARED_BIT_OHOS: bool = false,
    _: u31 = 0,
};
pub const VkVideoCodecOperationFlagsKHR = packed struct(u32) {
    // Extension: VK_KHR_video_decode_h264
    // bit: 0
    VK_VIDEO_CODEC_OPERATION_DECODE_H264_BIT_KHR: bool = false,
    // Extension: VK_KHR_video_decode_h265
    // bit: 1
    VK_VIDEO_CODEC_OPERATION_DECODE_H265_BIT_KHR: bool = false,
    // Extension: VK_KHR_video_decode_av1
    // bit: 2
    VK_VIDEO_CODEC_OPERATION_DECODE_AV1_BIT_KHR: bool = false,
    // Extension: VK_KHR_video_decode_vp9
    // bit: 3
    VK_VIDEO_CODEC_OPERATION_DECODE_VP9_BIT_KHR: bool = false,
    _3: u12 = 0,
    // Extension: VK_KHR_video_encode_h264
    // bit: 16
    VK_VIDEO_CODEC_OPERATION_ENCODE_H264_BIT_KHR: bool = false,
    // Extension: VK_KHR_video_encode_h265
    // bit: 17
    VK_VIDEO_CODEC_OPERATION_ENCODE_H265_BIT_KHR: bool = false,
    // Extension: VK_KHR_video_encode_av1
    // bit: 18
    VK_VIDEO_CODEC_OPERATION_ENCODE_AV1_BIT_KHR: bool = false,
    _: u13 = 0,
    pub const VK_VIDEO_CODEC_OPERATION_NONE_KHR: @This() = @bitCast(@as(u32, 0x0));
};
pub const VkVideoCapabilityFlagsKHR = packed struct(u32) {
    // bit: 0
    VK_VIDEO_CAPABILITY_PROTECTED_CONTENT_BIT_KHR: bool = false,
    // bit: 1
    VK_VIDEO_CAPABILITY_SEPARATE_REFERENCE_IMAGES_BIT_KHR: bool = false,
    _: u30 = 0,
};
pub const VkVideoSessionCreateFlagsKHR = packed struct(u32) {
    // bit: 0
    VK_VIDEO_SESSION_CREATE_PROTECTED_CONTENT_BIT_KHR: bool = false,
    // Extension: VK_KHR_video_encode_queue
    // bit: 1
    VK_VIDEO_SESSION_CREATE_ALLOW_ENCODE_PARAMETER_OPTIMIZATIONS_BIT_KHR: bool = false,
    // Extension: VK_KHR_video_maintenance1
    // bit: 2
    VK_VIDEO_SESSION_CREATE_INLINE_QUERIES_BIT_KHR: bool = false,
    // Extension: VK_KHR_video_encode_quantization_map
    // bit: 3
    VK_VIDEO_SESSION_CREATE_ALLOW_ENCODE_QUANTIZATION_DELTA_MAP_BIT_KHR: bool = false,
    // Extension: VK_KHR_video_encode_quantization_map
    // bit: 4
    VK_VIDEO_SESSION_CREATE_ALLOW_ENCODE_EMPHASIS_MAP_BIT_KHR: bool = false,
    // Extension: VK_KHR_video_maintenance2
    // bit: 5
    VK_VIDEO_SESSION_CREATE_INLINE_SESSION_PARAMETERS_BIT_KHR: bool = false,
    _: u26 = 0,
};
pub const VkVideoSessionParametersCreateFlagsKHR = packed struct(u32) {
    // Extension: VK_KHR_video_encode_quantization_map
    // bit: 0
    VK_VIDEO_SESSION_PARAMETERS_CREATE_QUANTIZATION_MAP_COMPATIBLE_BIT_KHR: bool = false,
    _: u31 = 0,
};
pub const VkVideoCodingControlFlagsKHR = packed struct(u32) {
    // bit: 0
    VK_VIDEO_CODING_CONTROL_RESET_BIT_KHR: bool = false,
    // Extension: VK_KHR_video_encode_queue
    // bit: 1
    VK_VIDEO_CODING_CONTROL_ENCODE_RATE_CONTROL_BIT_KHR: bool = false,
    // Extension: VK_KHR_video_encode_queue
    // bit: 2
    VK_VIDEO_CODING_CONTROL_ENCODE_QUALITY_LEVEL_BIT_KHR: bool = false,
    _: u29 = 0,
};
pub const VkVideoDecodeUsageFlagsKHR = packed struct(u32) {
    // bit: 0
    VK_VIDEO_DECODE_USAGE_TRANSCODING_BIT_KHR: bool = false,
    // bit: 1
    VK_VIDEO_DECODE_USAGE_OFFLINE_BIT_KHR: bool = false,
    // bit: 2
    VK_VIDEO_DECODE_USAGE_STREAMING_BIT_KHR: bool = false,
    _: u29 = 0,
    pub const VK_VIDEO_DECODE_USAGE_DEFAULT_KHR: @This() = @bitCast(@as(u32, 0x0));
};
pub const VkVideoDecodeCapabilityFlagsKHR = packed struct(u32) {
    // bit: 0
    VK_VIDEO_DECODE_CAPABILITY_DPB_AND_OUTPUT_COINCIDE_BIT_KHR: bool = false,
    // bit: 1
    VK_VIDEO_DECODE_CAPABILITY_DPB_AND_OUTPUT_DISTINCT_BIT_KHR: bool = false,
    _: u30 = 0,
};
pub const VkVideoDecodeH264PictureLayoutFlagsKHR = packed struct(u32) {
    // bit: 0
    VK_VIDEO_DECODE_H264_PICTURE_LAYOUT_INTERLACED_INTERLEAVED_LINES_BIT_KHR: bool = false,
    // bit: 1
    VK_VIDEO_DECODE_H264_PICTURE_LAYOUT_INTERLACED_SEPARATE_PLANES_BIT_KHR: bool = false,
    _: u30 = 0,
    pub const VK_VIDEO_DECODE_H264_PICTURE_LAYOUT_PROGRESSIVE_KHR: @This() = @bitCast(@as(u32, 0x0));
};
pub const VkVideoEncodeFlagsKHR = packed struct(u32) {
    // Extension: VK_KHR_video_encode_quantization_map
    // bit: 0
    VK_VIDEO_ENCODE_WITH_QUANTIZATION_DELTA_MAP_BIT_KHR: bool = false,
    // Extension: VK_KHR_video_encode_quantization_map
    // bit: 1
    VK_VIDEO_ENCODE_WITH_EMPHASIS_MAP_BIT_KHR: bool = false,
    // Extension: VK_KHR_video_encode_intra_refresh
    // bit: 2
    VK_VIDEO_ENCODE_INTRA_REFRESH_BIT_KHR: bool = false,
    _: u29 = 0,
};
pub const VkVideoEncodeUsageFlagsKHR = packed struct(u32) {
    // bit: 0
    VK_VIDEO_ENCODE_USAGE_TRANSCODING_BIT_KHR: bool = false,
    // bit: 1
    VK_VIDEO_ENCODE_USAGE_STREAMING_BIT_KHR: bool = false,
    // bit: 2
    VK_VIDEO_ENCODE_USAGE_RECORDING_BIT_KHR: bool = false,
    // bit: 3
    VK_VIDEO_ENCODE_USAGE_CONFERENCING_BIT_KHR: bool = false,
    _: u28 = 0,
    pub const VK_VIDEO_ENCODE_USAGE_DEFAULT_KHR: @This() = @bitCast(@as(u32, 0x0));
};
pub const VkVideoEncodeContentFlagsKHR = packed struct(u32) {
    // bit: 0
    VK_VIDEO_ENCODE_CONTENT_CAMERA_BIT_KHR: bool = false,
    // bit: 1
    VK_VIDEO_ENCODE_CONTENT_DESKTOP_BIT_KHR: bool = false,
    // bit: 2
    VK_VIDEO_ENCODE_CONTENT_RENDERED_BIT_KHR: bool = false,
    _: u29 = 0,
    pub const VK_VIDEO_ENCODE_CONTENT_DEFAULT_KHR: @This() = @bitCast(@as(u32, 0x0));
};
pub const VkVideoEncodeCapabilityFlagsKHR = packed struct(u32) {
    // bit: 0
    VK_VIDEO_ENCODE_CAPABILITY_PRECEDING_EXTERNALLY_ENCODED_BYTES_BIT_KHR: bool = false,
    // bit: 1
    VK_VIDEO_ENCODE_CAPABILITY_INSUFFICIENT_BITSTREAM_BUFFER_RANGE_DETECTION_BIT_KHR: bool = false,
    // Extension: VK_KHR_video_encode_quantization_map
    // bit: 2
    VK_VIDEO_ENCODE_CAPABILITY_QUANTIZATION_DELTA_MAP_BIT_KHR: bool = false,
    // Extension: VK_KHR_video_encode_quantization_map
    // bit: 3
    VK_VIDEO_ENCODE_CAPABILITY_EMPHASIS_MAP_BIT_KHR: bool = false,
    _: u28 = 0,
};
pub const VkVideoEncodeFeedbackFlagsKHR = packed struct(u32) {
    // bit: 0
    VK_VIDEO_ENCODE_FEEDBACK_BITSTREAM_BUFFER_OFFSET_BIT_KHR: bool = false,
    // bit: 1
    VK_VIDEO_ENCODE_FEEDBACK_BITSTREAM_BYTES_WRITTEN_BIT_KHR: bool = false,
    // bit: 2
    VK_VIDEO_ENCODE_FEEDBACK_BITSTREAM_HAS_OVERRIDES_BIT_KHR: bool = false,
    _: u29 = 0,
};
pub const VkVideoEncodeRateControlModeFlagsKHR = packed struct(u32) {
    // bit: 0
    VK_VIDEO_ENCODE_RATE_CONTROL_MODE_DISABLED_BIT_KHR: bool = false,
    // bit: 1
    VK_VIDEO_ENCODE_RATE_CONTROL_MODE_CBR_BIT_KHR: bool = false,
    // bit: 2
    VK_VIDEO_ENCODE_RATE_CONTROL_MODE_VBR_BIT_KHR: bool = false,
    _: u29 = 0,
    pub const VK_VIDEO_ENCODE_RATE_CONTROL_MODE_DEFAULT_KHR: @This() = @bitCast(@as(u32, 0x0));
};
pub const VkVideoEncodeIntraRefreshModeFlagsKHR = packed struct(u32) {
    // bit: 0
    VK_VIDEO_ENCODE_INTRA_REFRESH_MODE_PER_PICTURE_PARTITION_BIT_KHR: bool = false,
    // bit: 1
    VK_VIDEO_ENCODE_INTRA_REFRESH_MODE_BLOCK_BASED_BIT_KHR: bool = false,
    // bit: 2
    VK_VIDEO_ENCODE_INTRA_REFRESH_MODE_BLOCK_ROW_BASED_BIT_KHR: bool = false,
    // bit: 3
    VK_VIDEO_ENCODE_INTRA_REFRESH_MODE_BLOCK_COLUMN_BASED_BIT_KHR: bool = false,
    _: u28 = 0,
    pub const VK_VIDEO_ENCODE_INTRA_REFRESH_MODE_NONE_KHR: @This() = @bitCast(@as(u32, 0x0));
};
pub const VkVideoChromaSubsamplingFlagsKHR = packed struct(u32) {
    // bit: 0
    VK_VIDEO_CHROMA_SUBSAMPLING_MONOCHROME_BIT_KHR: bool = false,
    // bit: 1
    VK_VIDEO_CHROMA_SUBSAMPLING_420_BIT_KHR: bool = false,
    // bit: 2
    VK_VIDEO_CHROMA_SUBSAMPLING_422_BIT_KHR: bool = false,
    // bit: 3
    VK_VIDEO_CHROMA_SUBSAMPLING_444_BIT_KHR: bool = false,
    _: u28 = 0,
    pub const VK_VIDEO_CHROMA_SUBSAMPLING_INVALID_KHR: @This() = @bitCast(@as(u32, 0x0));
};
pub const VkVideoComponentBitDepthFlagsKHR = packed struct(u32) {
    // bit: 0
    VK_VIDEO_COMPONENT_BIT_DEPTH_8_BIT_KHR: bool = false,
    // bit: 2
    VK_VIDEO_COMPONENT_BIT_DEPTH_10_BIT_KHR: bool = false,
    _2: u1 = 0,
    // bit: 4
    VK_VIDEO_COMPONENT_BIT_DEPTH_12_BIT_KHR: bool = false,
    _: u27 = 0,
    pub const VK_VIDEO_COMPONENT_BIT_DEPTH_INVALID_KHR: @This() = @bitCast(@as(u32, 0x0));
};
pub const VkVideoEncodeH264CapabilityFlagsKHR = packed struct(u32) {
    // bit: 0
    VK_VIDEO_ENCODE_H264_CAPABILITY_HRD_COMPLIANCE_BIT_KHR: bool = false,
    // bit: 1
    VK_VIDEO_ENCODE_H264_CAPABILITY_PREDICTION_WEIGHT_TABLE_GENERATED_BIT_KHR: bool = false,
    // bit: 2
    VK_VIDEO_ENCODE_H264_CAPABILITY_ROW_UNALIGNED_SLICE_BIT_KHR: bool = false,
    // bit: 3
    VK_VIDEO_ENCODE_H264_CAPABILITY_DIFFERENT_SLICE_TYPE_BIT_KHR: bool = false,
    // bit: 4
    VK_VIDEO_ENCODE_H264_CAPABILITY_B_FRAME_IN_L0_LIST_BIT_KHR: bool = false,
    // bit: 5
    VK_VIDEO_ENCODE_H264_CAPABILITY_B_FRAME_IN_L1_LIST_BIT_KHR: bool = false,
    // bit: 6
    VK_VIDEO_ENCODE_H264_CAPABILITY_PER_PICTURE_TYPE_MIN_MAX_QP_BIT_KHR: bool = false,
    // bit: 7
    VK_VIDEO_ENCODE_H264_CAPABILITY_PER_SLICE_CONSTANT_QP_BIT_KHR: bool = false,
    // bit: 8
    VK_VIDEO_ENCODE_H264_CAPABILITY_GENERATE_PREFIX_NALU_BIT_KHR: bool = false,
    // Extension: VK_KHR_video_encode_quantization_map
    // bit: 9
    VK_VIDEO_ENCODE_H264_CAPABILITY_MB_QP_DIFF_WRAPAROUND_BIT_KHR: bool = false,
    // Extension: VK_KHR_video_encode_intra_refresh
    // bit: 10
    VK_VIDEO_ENCODE_H264_CAPABILITY_B_PICTURE_INTRA_REFRESH_BIT_KHR: bool = false,
    _: u21 = 0,
};
pub const VkVideoEncodeH264StdFlagsKHR = packed struct(u32) {
    // bit: 0
    VK_VIDEO_ENCODE_H264_STD_SEPARATE_COLOR_PLANE_FLAG_SET_BIT_KHR: bool = false,
    // bit: 1
    VK_VIDEO_ENCODE_H264_STD_QPPRIME_Y_ZERO_TRANSFORM_BYPASS_FLAG_SET_BIT_KHR: bool = false,
    // bit: 2
    VK_VIDEO_ENCODE_H264_STD_SCALING_MATRIX_PRESENT_FLAG_SET_BIT_KHR: bool = false,
    // bit: 3
    VK_VIDEO_ENCODE_H264_STD_CHROMA_QP_INDEX_OFFSET_BIT_KHR: bool = false,
    // bit: 4
    VK_VIDEO_ENCODE_H264_STD_SECOND_CHROMA_QP_INDEX_OFFSET_BIT_KHR: bool = false,
    // bit: 5
    VK_VIDEO_ENCODE_H264_STD_PIC_INIT_QP_MINUS26_BIT_KHR: bool = false,
    // bit: 6
    VK_VIDEO_ENCODE_H264_STD_WEIGHTED_PRED_FLAG_SET_BIT_KHR: bool = false,
    // bit: 7
    VK_VIDEO_ENCODE_H264_STD_WEIGHTED_BIPRED_IDC_EXPLICIT_BIT_KHR: bool = false,
    // bit: 8
    VK_VIDEO_ENCODE_H264_STD_WEIGHTED_BIPRED_IDC_IMPLICIT_BIT_KHR: bool = false,
    // bit: 9
    VK_VIDEO_ENCODE_H264_STD_TRANSFORM_8X8_MODE_FLAG_SET_BIT_KHR: bool = false,
    // bit: 10
    VK_VIDEO_ENCODE_H264_STD_DIRECT_SPATIAL_MV_PRED_FLAG_UNSET_BIT_KHR: bool = false,
    // bit: 11
    VK_VIDEO_ENCODE_H264_STD_ENTROPY_CODING_MODE_FLAG_UNSET_BIT_KHR: bool = false,
    // bit: 12
    VK_VIDEO_ENCODE_H264_STD_ENTROPY_CODING_MODE_FLAG_SET_BIT_KHR: bool = false,
    // bit: 13
    VK_VIDEO_ENCODE_H264_STD_DIRECT_8X8_INFERENCE_FLAG_UNSET_BIT_KHR: bool = false,
    // bit: 14
    VK_VIDEO_ENCODE_H264_STD_CONSTRAINED_INTRA_PRED_FLAG_SET_BIT_KHR: bool = false,
    // bit: 15
    VK_VIDEO_ENCODE_H264_STD_DEBLOCKING_FILTER_DISABLED_BIT_KHR: bool = false,
    // bit: 16
    VK_VIDEO_ENCODE_H264_STD_DEBLOCKING_FILTER_ENABLED_BIT_KHR: bool = false,
    // bit: 17
    VK_VIDEO_ENCODE_H264_STD_DEBLOCKING_FILTER_PARTIAL_BIT_KHR: bool = false,
    _17: u1 = 0,
    // bit: 19
    VK_VIDEO_ENCODE_H264_STD_SLICE_QP_DELTA_BIT_KHR: bool = false,
    // bit: 20
    VK_VIDEO_ENCODE_H264_STD_DIFFERENT_SLICE_QP_DELTA_BIT_KHR: bool = false,
    _: u11 = 0,
};
pub const VkVideoEncodeH264RateControlFlagsKHR = packed struct(u32) {
    // bit: 0
    VK_VIDEO_ENCODE_H264_RATE_CONTROL_ATTEMPT_HRD_COMPLIANCE_BIT_KHR: bool = false,
    // bit: 1
    VK_VIDEO_ENCODE_H264_RATE_CONTROL_REGULAR_GOP_BIT_KHR: bool = false,
    // bit: 2
    VK_VIDEO_ENCODE_H264_RATE_CONTROL_REFERENCE_PATTERN_FLAT_BIT_KHR: bool = false,
    // bit: 3
    VK_VIDEO_ENCODE_H264_RATE_CONTROL_REFERENCE_PATTERN_DYADIC_BIT_KHR: bool = false,
    // bit: 4
    VK_VIDEO_ENCODE_H264_RATE_CONTROL_TEMPORAL_LAYER_PATTERN_DYADIC_BIT_KHR: bool = false,
    _: u27 = 0,
};
pub const VkVideoEncodeH265CapabilityFlagsKHR = packed struct(u32) {
    // bit: 0
    VK_VIDEO_ENCODE_H265_CAPABILITY_HRD_COMPLIANCE_BIT_KHR: bool = false,
    // bit: 1
    VK_VIDEO_ENCODE_H265_CAPABILITY_PREDICTION_WEIGHT_TABLE_GENERATED_BIT_KHR: bool = false,
    // bit: 2
    VK_VIDEO_ENCODE_H265_CAPABILITY_ROW_UNALIGNED_SLICE_SEGMENT_BIT_KHR: bool = false,
    // bit: 3
    VK_VIDEO_ENCODE_H265_CAPABILITY_DIFFERENT_SLICE_SEGMENT_TYPE_BIT_KHR: bool = false,
    // bit: 4
    VK_VIDEO_ENCODE_H265_CAPABILITY_B_FRAME_IN_L0_LIST_BIT_KHR: bool = false,
    // bit: 5
    VK_VIDEO_ENCODE_H265_CAPABILITY_B_FRAME_IN_L1_LIST_BIT_KHR: bool = false,
    // bit: 6
    VK_VIDEO_ENCODE_H265_CAPABILITY_PER_PICTURE_TYPE_MIN_MAX_QP_BIT_KHR: bool = false,
    // bit: 7
    VK_VIDEO_ENCODE_H265_CAPABILITY_PER_SLICE_SEGMENT_CONSTANT_QP_BIT_KHR: bool = false,
    // bit: 8
    VK_VIDEO_ENCODE_H265_CAPABILITY_MULTIPLE_TILES_PER_SLICE_SEGMENT_BIT_KHR: bool = false,
    // bit: 9
    VK_VIDEO_ENCODE_H265_CAPABILITY_MULTIPLE_SLICE_SEGMENTS_PER_TILE_BIT_KHR: bool = false,
    // Extension: VK_KHR_video_encode_quantization_map
    // bit: 10
    VK_VIDEO_ENCODE_H265_CAPABILITY_CU_QP_DIFF_WRAPAROUND_BIT_KHR: bool = false,
    // Extension: VK_KHR_video_encode_intra_refresh
    // bit: 11
    VK_VIDEO_ENCODE_H265_CAPABILITY_B_PICTURE_INTRA_REFRESH_BIT_KHR: bool = false,
    _: u20 = 0,
};
pub const VkVideoEncodeH265StdFlagsKHR = packed struct(u32) {
    // bit: 0
    VK_VIDEO_ENCODE_H265_STD_SEPARATE_COLOR_PLANE_FLAG_SET_BIT_KHR: bool = false,
    // bit: 1
    VK_VIDEO_ENCODE_H265_STD_SAMPLE_ADAPTIVE_OFFSET_ENABLED_FLAG_SET_BIT_KHR: bool = false,
    // bit: 2
    VK_VIDEO_ENCODE_H265_STD_SCALING_LIST_DATA_PRESENT_FLAG_SET_BIT_KHR: bool = false,
    // bit: 3
    VK_VIDEO_ENCODE_H265_STD_PCM_ENABLED_FLAG_SET_BIT_KHR: bool = false,
    // bit: 4
    VK_VIDEO_ENCODE_H265_STD_SPS_TEMPORAL_MVP_ENABLED_FLAG_SET_BIT_KHR: bool = false,
    // bit: 5
    VK_VIDEO_ENCODE_H265_STD_INIT_QP_MINUS26_BIT_KHR: bool = false,
    // bit: 6
    VK_VIDEO_ENCODE_H265_STD_WEIGHTED_PRED_FLAG_SET_BIT_KHR: bool = false,
    // bit: 7
    VK_VIDEO_ENCODE_H265_STD_WEIGHTED_BIPRED_FLAG_SET_BIT_KHR: bool = false,
    // bit: 8
    VK_VIDEO_ENCODE_H265_STD_LOG2_PARALLEL_MERGE_LEVEL_MINUS2_BIT_KHR: bool = false,
    // bit: 9
    VK_VIDEO_ENCODE_H265_STD_SIGN_DATA_HIDING_ENABLED_FLAG_SET_BIT_KHR: bool = false,
    // bit: 10
    VK_VIDEO_ENCODE_H265_STD_TRANSFORM_SKIP_ENABLED_FLAG_SET_BIT_KHR: bool = false,
    // bit: 11
    VK_VIDEO_ENCODE_H265_STD_TRANSFORM_SKIP_ENABLED_FLAG_UNSET_BIT_KHR: bool = false,
    // bit: 12
    VK_VIDEO_ENCODE_H265_STD_PPS_SLICE_CHROMA_QP_OFFSETS_PRESENT_FLAG_SET_BIT_KHR: bool = false,
    // bit: 13
    VK_VIDEO_ENCODE_H265_STD_TRANSQUANT_BYPASS_ENABLED_FLAG_SET_BIT_KHR: bool = false,
    // bit: 14
    VK_VIDEO_ENCODE_H265_STD_CONSTRAINED_INTRA_PRED_FLAG_SET_BIT_KHR: bool = false,
    // bit: 15
    VK_VIDEO_ENCODE_H265_STD_ENTROPY_CODING_SYNC_ENABLED_FLAG_SET_BIT_KHR: bool = false,
    // bit: 16
    VK_VIDEO_ENCODE_H265_STD_DEBLOCKING_FILTER_OVERRIDE_ENABLED_FLAG_SET_BIT_KHR: bool = false,
    // bit: 17
    VK_VIDEO_ENCODE_H265_STD_DEPENDENT_SLICE_SEGMENTS_ENABLED_FLAG_SET_BIT_KHR: bool = false,
    // bit: 18
    VK_VIDEO_ENCODE_H265_STD_DEPENDENT_SLICE_SEGMENT_FLAG_SET_BIT_KHR: bool = false,
    // bit: 19
    VK_VIDEO_ENCODE_H265_STD_SLICE_QP_DELTA_BIT_KHR: bool = false,
    // bit: 20
    VK_VIDEO_ENCODE_H265_STD_DIFFERENT_SLICE_QP_DELTA_BIT_KHR: bool = false,
    _: u11 = 0,
};
pub const VkVideoEncodeH265RateControlFlagsKHR = packed struct(u32) {
    // bit: 0
    VK_VIDEO_ENCODE_H265_RATE_CONTROL_ATTEMPT_HRD_COMPLIANCE_BIT_KHR: bool = false,
    // bit: 1
    VK_VIDEO_ENCODE_H265_RATE_CONTROL_REGULAR_GOP_BIT_KHR: bool = false,
    // bit: 2
    VK_VIDEO_ENCODE_H265_RATE_CONTROL_REFERENCE_PATTERN_FLAT_BIT_KHR: bool = false,
    // bit: 3
    VK_VIDEO_ENCODE_H265_RATE_CONTROL_REFERENCE_PATTERN_DYADIC_BIT_KHR: bool = false,
    // bit: 4
    VK_VIDEO_ENCODE_H265_RATE_CONTROL_TEMPORAL_SUB_LAYER_PATTERN_DYADIC_BIT_KHR: bool = false,
    _: u27 = 0,
};
pub const VkVideoEncodeH265CtbSizeFlagsKHR = packed struct(u32) {
    // bit: 0
    VK_VIDEO_ENCODE_H265_CTB_SIZE_16_BIT_KHR: bool = false,
    // bit: 1
    VK_VIDEO_ENCODE_H265_CTB_SIZE_32_BIT_KHR: bool = false,
    // bit: 2
    VK_VIDEO_ENCODE_H265_CTB_SIZE_64_BIT_KHR: bool = false,
    _: u29 = 0,
};
pub const VkVideoEncodeH265TransformBlockSizeFlagsKHR = packed struct(u32) {
    // bit: 0
    VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_4_BIT_KHR: bool = false,
    // bit: 1
    VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_8_BIT_KHR: bool = false,
    // bit: 2
    VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_16_BIT_KHR: bool = false,
    // bit: 3
    VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_32_BIT_KHR: bool = false,
    _: u28 = 0,
};
pub const VkVideoEncodeAV1CapabilityFlagsKHR = packed struct(u32) {
    // bit: 0
    VK_VIDEO_ENCODE_AV1_CAPABILITY_PER_RATE_CONTROL_GROUP_MIN_MAX_Q_INDEX_BIT_KHR: bool = false,
    // bit: 1
    VK_VIDEO_ENCODE_AV1_CAPABILITY_GENERATE_OBU_EXTENSION_HEADER_BIT_KHR: bool = false,
    // bit: 2
    VK_VIDEO_ENCODE_AV1_CAPABILITY_PRIMARY_REFERENCE_CDF_ONLY_BIT_KHR: bool = false,
    // bit: 3
    VK_VIDEO_ENCODE_AV1_CAPABILITY_FRAME_SIZE_OVERRIDE_BIT_KHR: bool = false,
    // bit: 4
    VK_VIDEO_ENCODE_AV1_CAPABILITY_MOTION_VECTOR_SCALING_BIT_KHR: bool = false,
    // Extension: VK_KHR_video_encode_intra_refresh
    // bit: 5
    VK_VIDEO_ENCODE_AV1_CAPABILITY_COMPOUND_PREDICTION_INTRA_REFRESH_BIT_KHR: bool = false,
    _: u26 = 0,
};
pub const VkVideoEncodeAV1StdFlagsKHR = packed struct(u32) {
    // bit: 0
    VK_VIDEO_ENCODE_AV1_STD_UNIFORM_TILE_SPACING_FLAG_SET_BIT_KHR: bool = false,
    // bit: 1
    VK_VIDEO_ENCODE_AV1_STD_SKIP_MODE_PRESENT_UNSET_BIT_KHR: bool = false,
    // bit: 2
    VK_VIDEO_ENCODE_AV1_STD_PRIMARY_REF_FRAME_BIT_KHR: bool = false,
    // bit: 3
    VK_VIDEO_ENCODE_AV1_STD_DELTA_Q_BIT_KHR: bool = false,
    _: u28 = 0,
};
pub const VkVideoEncodeAV1RateControlFlagsKHR = packed struct(u32) {
    // bit: 0
    VK_VIDEO_ENCODE_AV1_RATE_CONTROL_REGULAR_GOP_BIT_KHR: bool = false,
    // bit: 1
    VK_VIDEO_ENCODE_AV1_RATE_CONTROL_TEMPORAL_LAYER_PATTERN_DYADIC_BIT_KHR: bool = false,
    // bit: 2
    VK_VIDEO_ENCODE_AV1_RATE_CONTROL_REFERENCE_PATTERN_FLAT_BIT_KHR: bool = false,
    // bit: 3
    VK_VIDEO_ENCODE_AV1_RATE_CONTROL_REFERENCE_PATTERN_DYADIC_BIT_KHR: bool = false,
    _: u28 = 0,
};
pub const VkVideoEncodeAV1SuperblockSizeFlagsKHR = packed struct(u32) {
    // bit: 0
    VK_VIDEO_ENCODE_AV1_SUPERBLOCK_SIZE_64_BIT_KHR: bool = false,
    // bit: 1
    VK_VIDEO_ENCODE_AV1_SUPERBLOCK_SIZE_128_BIT_KHR: bool = false,
    _: u30 = 0,
};
pub const VkAccessFlags3KHR = packed struct(u64) {
    _: u64 = 0,
    pub const VK_ACCESS_3_NONE_KHR: @This() = @bitCast(@as(u64, 0x0));
};

// Enums
pub const VkImageLayout = enum(u32) {
    // Comment: Implicit layout an image is when its contents are undefined due to various reasons (e.g. right after creation)
    VK_IMAGE_LAYOUT_UNDEFINED = 0,
    // Comment: General layout when image can be used for any kind of access
    VK_IMAGE_LAYOUT_GENERAL = 1,
    // Comment: Optimal layout when image is only used for color attachment read/write
    VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL = 2,
    // Comment: Optimal layout when image is only used for depth/stencil attachment read/write
    VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL = 3,
    // Comment: Optimal layout when image is used for read only depth/stencil attachment and shader access
    VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL = 4,
    // Comment: Optimal layout when image is used for read only shader access
    VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL = 5,
    // Comment: Optimal layout when image is used only as source of transfer operations
    VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL = 6,
    // Comment: Optimal layout when image is used only as destination of transfer operations
    VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL = 7,
    // Comment: Initial layout used when the data is populated by the CPU
    VK_IMAGE_LAYOUT_PREINITIALIZED = 8,
    // Extension: VK_KHR_swapchain
    VK_IMAGE_LAYOUT_PRESENT_SRC_KHR = 1000001002,
    // Extension: VK_KHR_video_decode_queue
    VK_IMAGE_LAYOUT_VIDEO_DECODE_DST_KHR = 1000024000,
    // Extension: VK_KHR_video_decode_queue
    VK_IMAGE_LAYOUT_VIDEO_DECODE_SRC_KHR = 1000024001,
    // Extension: VK_KHR_video_decode_queue
    VK_IMAGE_LAYOUT_VIDEO_DECODE_DPB_KHR = 1000024002,
    // Extension: VK_KHR_shared_presentable_image
    VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR = 1000111000,
    // Extension: VK_GRAPHICS_VERSION_1_1
    // Alias: VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL_KHR
    VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL = 1000117000,
    // Extension: VK_GRAPHICS_VERSION_1_1
    // Alias: VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL_KHR
    VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL = 1000117001,
    // Extension: VK_KHR_fragment_shading_rate
    // Alias: VK_IMAGE_LAYOUT_SHADING_RATE_OPTIMAL_NV
    VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR = 1000164003,
    // Extension: VK_EXT_fragment_density_map
    VK_IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT = 1000218000,
    // Extension: VK_GRAPHICS_VERSION_1_4
    // Alias: VK_IMAGE_LAYOUT_RENDERING_LOCAL_READ_KHR
    VK_IMAGE_LAYOUT_RENDERING_LOCAL_READ = 1000232000,
    // Extension: VK_GRAPHICS_VERSION_1_2
    // Alias: VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL_KHR
    VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL = 1000241000,
    // Extension: VK_GRAPHICS_VERSION_1_2
    // Alias: VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL_KHR
    VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL = 1000241001,
    // Extension: VK_GRAPHICS_VERSION_1_2
    // Alias: VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL_KHR
    VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL = 1000241002,
    // Extension: VK_GRAPHICS_VERSION_1_2
    // Alias: VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL_KHR
    VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL = 1000241003,
    // Extension: VK_KHR_video_encode_queue
    VK_IMAGE_LAYOUT_VIDEO_ENCODE_DST_KHR = 1000299000,
    // Extension: VK_KHR_video_encode_queue
    VK_IMAGE_LAYOUT_VIDEO_ENCODE_SRC_KHR = 1000299001,
    // Extension: VK_KHR_video_encode_queue
    VK_IMAGE_LAYOUT_VIDEO_ENCODE_DPB_KHR = 1000299002,
    // Extension: VK_BASE_VERSION_1_3
    // Alias: VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL_KHR
    VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL = 1000314000,
    // Extension: VK_BASE_VERSION_1_3
    // Alias: VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL_KHR
    VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL = 1000314001,
    // Extension: VK_EXT_attachment_feedback_loop_layout
    VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT = 1000339000,
    // Extension: VK_ARM_tensors
    VK_IMAGE_LAYOUT_TENSOR_ALIASING_ARM = 1000460000,
    // Extension: VK_KHR_video_encode_quantization_map
    VK_IMAGE_LAYOUT_VIDEO_ENCODE_QUANTIZATION_MAP_KHR = 1000553000,
    // Extension: VK_EXT_zero_initialize_device_memory
    VK_IMAGE_LAYOUT_ZERO_INITIALIZED_EXT = 1000620000,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkAttachmentLoadOp = enum(u32) {
    VK_ATTACHMENT_LOAD_OP_LOAD = 0,
    VK_ATTACHMENT_LOAD_OP_CLEAR = 1,
    VK_ATTACHMENT_LOAD_OP_DONT_CARE = 2,
    // Extension: VK_GRAPHICS_VERSION_1_4
    // Alias: VK_ATTACHMENT_LOAD_OP_NONE_EXT
    // Alias: VK_ATTACHMENT_LOAD_OP_NONE_KHR
    VK_ATTACHMENT_LOAD_OP_NONE = 1000400000,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkAttachmentStoreOp = enum(u32) {
    VK_ATTACHMENT_STORE_OP_STORE = 0,
    VK_ATTACHMENT_STORE_OP_DONT_CARE = 1,
    // Extension: VK_GRAPHICS_VERSION_1_3
    // Alias: VK_ATTACHMENT_STORE_OP_NONE_KHR
    // Alias: VK_ATTACHMENT_STORE_OP_NONE_QCOM
    // Alias: VK_ATTACHMENT_STORE_OP_NONE_EXT
    // Alias: VK_ATTACHMENT_STORE_OP_NONE_KHR
    VK_ATTACHMENT_STORE_OP_NONE = 1000301000,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkImageType = enum(u32) {
    VK_IMAGE_TYPE_1D = 0,
    VK_IMAGE_TYPE_2D = 1,
    VK_IMAGE_TYPE_3D = 2,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkImageTiling = enum(u32) {
    VK_IMAGE_TILING_OPTIMAL = 0,
    VK_IMAGE_TILING_LINEAR = 1,
    // Extension: VK_EXT_image_drm_format_modifier
    VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT = 1000158000,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkImageViewType = enum(u32) {
    VK_IMAGE_VIEW_TYPE_1D = 0,
    VK_IMAGE_VIEW_TYPE_2D = 1,
    VK_IMAGE_VIEW_TYPE_3D = 2,
    VK_IMAGE_VIEW_TYPE_CUBE = 3,
    VK_IMAGE_VIEW_TYPE_1D_ARRAY = 4,
    VK_IMAGE_VIEW_TYPE_2D_ARRAY = 5,
    VK_IMAGE_VIEW_TYPE_CUBE_ARRAY = 6,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkCommandBufferLevel = enum(u32) {
    VK_COMMAND_BUFFER_LEVEL_PRIMARY = 0,
    VK_COMMAND_BUFFER_LEVEL_SECONDARY = 1,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkComponentSwizzle = enum(u32) {
    VK_COMPONENT_SWIZZLE_IDENTITY = 0,
    VK_COMPONENT_SWIZZLE_ZERO = 1,
    VK_COMPONENT_SWIZZLE_ONE = 2,
    VK_COMPONENT_SWIZZLE_R = 3,
    VK_COMPONENT_SWIZZLE_G = 4,
    VK_COMPONENT_SWIZZLE_B = 5,
    VK_COMPONENT_SWIZZLE_A = 6,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkDescriptorType = enum(u32) {
    VK_DESCRIPTOR_TYPE_SAMPLER = 0,
    VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER = 1,
    VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE = 2,
    VK_DESCRIPTOR_TYPE_STORAGE_IMAGE = 3,
    VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER = 4,
    VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER = 5,
    VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER = 6,
    VK_DESCRIPTOR_TYPE_STORAGE_BUFFER = 7,
    VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC = 8,
    VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC = 9,
    VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT = 10,
    // Extension: VK_COMPUTE_VERSION_1_3
    // Alias: VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT
    VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK = 1000138000,
    // Extension: VK_KHR_acceleration_structure
    VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR = 1000150000,
    // Extension: VK_NV_ray_tracing
    VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV = 1000165000,
    // Extension: VK_EXT_mutable_descriptor_type
    // Alias: VK_DESCRIPTOR_TYPE_MUTABLE_VALVE
    VK_DESCRIPTOR_TYPE_MUTABLE_EXT = 1000351000,
    // Extension: VK_QCOM_image_processing
    VK_DESCRIPTOR_TYPE_SAMPLE_WEIGHT_IMAGE_QCOM = 1000440000,
    // Extension: VK_QCOM_image_processing
    VK_DESCRIPTOR_TYPE_BLOCK_MATCH_IMAGE_QCOM = 1000440001,
    // Extension: VK_ARM_tensors
    VK_DESCRIPTOR_TYPE_TENSOR_ARM = 1000460000,
    // Extension: VK_NV_partitioned_acceleration_structure
    VK_DESCRIPTOR_TYPE_PARTITIONED_ACCELERATION_STRUCTURE_NV = 1000570000,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkQueryType = enum(u32) {
    VK_QUERY_TYPE_OCCLUSION = 0,
    // Comment: Optional
    VK_QUERY_TYPE_PIPELINE_STATISTICS = 1,
    VK_QUERY_TYPE_TIMESTAMP = 2,
    // Extension: VK_KHR_video_queue
    VK_QUERY_TYPE_RESULT_STATUS_ONLY_KHR = 1000023000,
    // Extension: VK_EXT_transform_feedback
    VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT = 1000028004,
    // Extension: VK_KHR_performance_query
    VK_QUERY_TYPE_PERFORMANCE_QUERY_KHR = 1000116000,
    // Extension: VK_KHR_acceleration_structure
    VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_KHR = 1000150000,
    // Extension: VK_KHR_acceleration_structure
    VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_SIZE_KHR = 1000150001,
    // Extension: VK_NV_ray_tracing
    VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_NV = 1000165000,
    // Extension: VK_INTEL_performance_query
    VK_QUERY_TYPE_PERFORMANCE_QUERY_INTEL = 1000210000,
    // Extension: VK_KHR_video_encode_queue
    VK_QUERY_TYPE_VIDEO_ENCODE_FEEDBACK_KHR = 1000299000,
    // Extension: VK_EXT_mesh_shader
    VK_QUERY_TYPE_MESH_PRIMITIVES_GENERATED_EXT = 1000328000,
    // Extension: VK_EXT_primitives_generated_query
    VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT = 1000382000,
    // Extension: VK_KHR_ray_tracing_maintenance1
    VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_BOTTOM_LEVEL_POINTERS_KHR = 1000386000,
    // Extension: VK_KHR_ray_tracing_maintenance1
    VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SIZE_KHR = 1000386001,
    // Extension: VK_EXT_opacity_micromap
    VK_QUERY_TYPE_MICROMAP_SERIALIZATION_SIZE_EXT = 1000396000,
    // Extension: VK_EXT_opacity_micromap
    VK_QUERY_TYPE_MICROMAP_COMPACTED_SIZE_EXT = 1000396001,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkBorderColor = enum(u32) {
    VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK = 0,
    VK_BORDER_COLOR_INT_TRANSPARENT_BLACK = 1,
    VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK = 2,
    VK_BORDER_COLOR_INT_OPAQUE_BLACK = 3,
    VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE = 4,
    VK_BORDER_COLOR_INT_OPAQUE_WHITE = 5,
    // Extension: VK_EXT_custom_border_color
    VK_BORDER_COLOR_FLOAT_CUSTOM_EXT = 1000287003,
    // Extension: VK_EXT_custom_border_color
    VK_BORDER_COLOR_INT_CUSTOM_EXT = 1000287004,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkPipelineBindPoint = enum(u32) {
    VK_PIPELINE_BIND_POINT_GRAPHICS = 0,
    VK_PIPELINE_BIND_POINT_COMPUTE = 1,
    // Extension: VK_AMDX_shader_enqueue
    VK_PIPELINE_BIND_POINT_EXECUTION_GRAPH_AMDX = 1000134000,
    // Extension: VK_KHR_ray_tracing_pipeline
    // Alias: VK_PIPELINE_BIND_POINT_RAY_TRACING_NV
    VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR = 1000165000,
    // Extension: VK_HUAWEI_subpass_shading
    VK_PIPELINE_BIND_POINT_SUBPASS_SHADING_HUAWEI = 1000369003,
    // Extension: VK_ARM_data_graph
    VK_PIPELINE_BIND_POINT_DATA_GRAPH_ARM = 1000507000,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkPipelineCacheHeaderVersion = enum(u32) {
    VK_PIPELINE_CACHE_HEADER_VERSION_ONE = 1,
    // Extension: VKSC_VERSION_1_0
    VK_PIPELINE_CACHE_HEADER_VERSION_SAFETY_CRITICAL_ONE = 1000298001,
    // Extension: VK_QCOM_data_graph_model
    VK_PIPELINE_CACHE_HEADER_VERSION_DATA_GRAPH_QCOM = 1000629000,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkPrimitiveTopology = enum(u32) {
    VK_PRIMITIVE_TOPOLOGY_POINT_LIST = 0,
    VK_PRIMITIVE_TOPOLOGY_LINE_LIST = 1,
    VK_PRIMITIVE_TOPOLOGY_LINE_STRIP = 2,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST = 3,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP = 4,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN = 5,
    VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY = 6,
    VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY = 7,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY = 8,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY = 9,
    VK_PRIMITIVE_TOPOLOGY_PATCH_LIST = 10,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkSharingMode = enum(u32) {
    VK_SHARING_MODE_EXCLUSIVE = 0,
    VK_SHARING_MODE_CONCURRENT = 1,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkIndexType = enum(u32) {
    VK_INDEX_TYPE_UINT16 = 0,
    VK_INDEX_TYPE_UINT32 = 1,
    // Extension: VK_KHR_acceleration_structure
    // Alias: VK_INDEX_TYPE_NONE_NV
    VK_INDEX_TYPE_NONE_KHR = 1000165000,
    // Extension: VK_BASE_VERSION_1_4
    // Alias: VK_INDEX_TYPE_UINT8_EXT
    // Alias: VK_INDEX_TYPE_UINT8_KHR
    VK_INDEX_TYPE_UINT8 = 1000265000,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkFilter = enum(u32) {
    VK_FILTER_NEAREST = 0,
    VK_FILTER_LINEAR = 1,
    // Extension: VK_EXT_filter_cubic
    // Alias: VK_FILTER_CUBIC_IMG
    VK_FILTER_CUBIC_EXT = 1000015000,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkSamplerMipmapMode = enum(u32) {
    // Comment: Choose nearest mip level
    VK_SAMPLER_MIPMAP_MODE_NEAREST = 0,
    // Comment: Linear filter between mip levels
    VK_SAMPLER_MIPMAP_MODE_LINEAR = 1,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkSamplerAddressMode = enum(u32) {
    VK_SAMPLER_ADDRESS_MODE_REPEAT = 0,
    VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT = 1,
    VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE = 2,
    VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER = 3,
    // Extension: VK_BASE_VERSION_1_2
    // Extension: VK_KHR_sampler_mirror_clamp_to_edge
    // Alias: VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE_KHR
    VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE = 4,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkCompareOp = enum(u32) {
    VK_COMPARE_OP_NEVER = 0,
    VK_COMPARE_OP_LESS = 1,
    VK_COMPARE_OP_EQUAL = 2,
    VK_COMPARE_OP_LESS_OR_EQUAL = 3,
    VK_COMPARE_OP_GREATER = 4,
    VK_COMPARE_OP_NOT_EQUAL = 5,
    VK_COMPARE_OP_GREATER_OR_EQUAL = 6,
    VK_COMPARE_OP_ALWAYS = 7,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkPolygonMode = enum(u32) {
    VK_POLYGON_MODE_FILL = 0,
    VK_POLYGON_MODE_LINE = 1,
    VK_POLYGON_MODE_POINT = 2,
    // Extension: VK_NV_fill_rectangle
    VK_POLYGON_MODE_FILL_RECTANGLE_NV = 1000153000,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkFrontFace = enum(u32) {
    VK_FRONT_FACE_COUNTER_CLOCKWISE = 0,
    VK_FRONT_FACE_CLOCKWISE = 1,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkBlendFactor = enum(u32) {
    VK_BLEND_FACTOR_ZERO = 0,
    VK_BLEND_FACTOR_ONE = 1,
    VK_BLEND_FACTOR_SRC_COLOR = 2,
    VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR = 3,
    VK_BLEND_FACTOR_DST_COLOR = 4,
    VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR = 5,
    VK_BLEND_FACTOR_SRC_ALPHA = 6,
    VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA = 7,
    VK_BLEND_FACTOR_DST_ALPHA = 8,
    VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA = 9,
    VK_BLEND_FACTOR_CONSTANT_COLOR = 10,
    VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR = 11,
    VK_BLEND_FACTOR_CONSTANT_ALPHA = 12,
    VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA = 13,
    VK_BLEND_FACTOR_SRC_ALPHA_SATURATE = 14,
    VK_BLEND_FACTOR_SRC1_COLOR = 15,
    VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR = 16,
    VK_BLEND_FACTOR_SRC1_ALPHA = 17,
    VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA = 18,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkBlendOp = enum(u32) {
    VK_BLEND_OP_ADD = 0,
    VK_BLEND_OP_SUBTRACT = 1,
    VK_BLEND_OP_REVERSE_SUBTRACT = 2,
    VK_BLEND_OP_MIN = 3,
    VK_BLEND_OP_MAX = 4,
    // Extension: VK_EXT_blend_operation_advanced
    VK_BLEND_OP_ZERO_EXT = 1000148000,
    // Extension: VK_EXT_blend_operation_advanced
    VK_BLEND_OP_SRC_EXT = 1000148001,
    // Extension: VK_EXT_blend_operation_advanced
    VK_BLEND_OP_DST_EXT = 1000148002,
    // Extension: VK_EXT_blend_operation_advanced
    VK_BLEND_OP_SRC_OVER_EXT = 1000148003,
    // Extension: VK_EXT_blend_operation_advanced
    VK_BLEND_OP_DST_OVER_EXT = 1000148004,
    // Extension: VK_EXT_blend_operation_advanced
    VK_BLEND_OP_SRC_IN_EXT = 1000148005,
    // Extension: VK_EXT_blend_operation_advanced
    VK_BLEND_OP_DST_IN_EXT = 1000148006,
    // Extension: VK_EXT_blend_operation_advanced
    VK_BLEND_OP_SRC_OUT_EXT = 1000148007,
    // Extension: VK_EXT_blend_operation_advanced
    VK_BLEND_OP_DST_OUT_EXT = 1000148008,
    // Extension: VK_EXT_blend_operation_advanced
    VK_BLEND_OP_SRC_ATOP_EXT = 1000148009,
    // Extension: VK_EXT_blend_operation_advanced
    VK_BLEND_OP_DST_ATOP_EXT = 1000148010,
    // Extension: VK_EXT_blend_operation_advanced
    VK_BLEND_OP_XOR_EXT = 1000148011,
    // Extension: VK_EXT_blend_operation_advanced
    VK_BLEND_OP_MULTIPLY_EXT = 1000148012,
    // Extension: VK_EXT_blend_operation_advanced
    VK_BLEND_OP_SCREEN_EXT = 1000148013,
    // Extension: VK_EXT_blend_operation_advanced
    VK_BLEND_OP_OVERLAY_EXT = 1000148014,
    // Extension: VK_EXT_blend_operation_advanced
    VK_BLEND_OP_DARKEN_EXT = 1000148015,
    // Extension: VK_EXT_blend_operation_advanced
    VK_BLEND_OP_LIGHTEN_EXT = 1000148016,
    // Extension: VK_EXT_blend_operation_advanced
    VK_BLEND_OP_COLORDODGE_EXT = 1000148017,
    // Extension: VK_EXT_blend_operation_advanced
    VK_BLEND_OP_COLORBURN_EXT = 1000148018,
    // Extension: VK_EXT_blend_operation_advanced
    VK_BLEND_OP_HARDLIGHT_EXT = 1000148019,
    // Extension: VK_EXT_blend_operation_advanced
    VK_BLEND_OP_SOFTLIGHT_EXT = 1000148020,
    // Extension: VK_EXT_blend_operation_advanced
    VK_BLEND_OP_DIFFERENCE_EXT = 1000148021,
    // Extension: VK_EXT_blend_operation_advanced
    VK_BLEND_OP_EXCLUSION_EXT = 1000148022,
    // Extension: VK_EXT_blend_operation_advanced
    VK_BLEND_OP_INVERT_EXT = 1000148023,
    // Extension: VK_EXT_blend_operation_advanced
    VK_BLEND_OP_INVERT_RGB_EXT = 1000148024,
    // Extension: VK_EXT_blend_operation_advanced
    VK_BLEND_OP_LINEARDODGE_EXT = 1000148025,
    // Extension: VK_EXT_blend_operation_advanced
    VK_BLEND_OP_LINEARBURN_EXT = 1000148026,
    // Extension: VK_EXT_blend_operation_advanced
    VK_BLEND_OP_VIVIDLIGHT_EXT = 1000148027,
    // Extension: VK_EXT_blend_operation_advanced
    VK_BLEND_OP_LINEARLIGHT_EXT = 1000148028,
    // Extension: VK_EXT_blend_operation_advanced
    VK_BLEND_OP_PINLIGHT_EXT = 1000148029,
    // Extension: VK_EXT_blend_operation_advanced
    VK_BLEND_OP_HARDMIX_EXT = 1000148030,
    // Extension: VK_EXT_blend_operation_advanced
    VK_BLEND_OP_HSL_HUE_EXT = 1000148031,
    // Extension: VK_EXT_blend_operation_advanced
    VK_BLEND_OP_HSL_SATURATION_EXT = 1000148032,
    // Extension: VK_EXT_blend_operation_advanced
    VK_BLEND_OP_HSL_COLOR_EXT = 1000148033,
    // Extension: VK_EXT_blend_operation_advanced
    VK_BLEND_OP_HSL_LUMINOSITY_EXT = 1000148034,
    // Extension: VK_EXT_blend_operation_advanced
    VK_BLEND_OP_PLUS_EXT = 1000148035,
    // Extension: VK_EXT_blend_operation_advanced
    VK_BLEND_OP_PLUS_CLAMPED_EXT = 1000148036,
    // Extension: VK_EXT_blend_operation_advanced
    VK_BLEND_OP_PLUS_CLAMPED_ALPHA_EXT = 1000148037,
    // Extension: VK_EXT_blend_operation_advanced
    VK_BLEND_OP_PLUS_DARKER_EXT = 1000148038,
    // Extension: VK_EXT_blend_operation_advanced
    VK_BLEND_OP_MINUS_EXT = 1000148039,
    // Extension: VK_EXT_blend_operation_advanced
    VK_BLEND_OP_MINUS_CLAMPED_EXT = 1000148040,
    // Extension: VK_EXT_blend_operation_advanced
    VK_BLEND_OP_CONTRAST_EXT = 1000148041,
    // Extension: VK_EXT_blend_operation_advanced
    VK_BLEND_OP_INVERT_OVG_EXT = 1000148042,
    // Extension: VK_EXT_blend_operation_advanced
    VK_BLEND_OP_RED_EXT = 1000148043,
    // Extension: VK_EXT_blend_operation_advanced
    VK_BLEND_OP_GREEN_EXT = 1000148044,
    // Extension: VK_EXT_blend_operation_advanced
    VK_BLEND_OP_BLUE_EXT = 1000148045,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkStencilOp = enum(u32) {
    VK_STENCIL_OP_KEEP = 0,
    VK_STENCIL_OP_ZERO = 1,
    VK_STENCIL_OP_REPLACE = 2,
    VK_STENCIL_OP_INCREMENT_AND_CLAMP = 3,
    VK_STENCIL_OP_DECREMENT_AND_CLAMP = 4,
    VK_STENCIL_OP_INVERT = 5,
    VK_STENCIL_OP_INCREMENT_AND_WRAP = 6,
    VK_STENCIL_OP_DECREMENT_AND_WRAP = 7,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkLogicOp = enum(u32) {
    VK_LOGIC_OP_CLEAR = 0,
    VK_LOGIC_OP_AND = 1,
    VK_LOGIC_OP_AND_REVERSE = 2,
    VK_LOGIC_OP_COPY = 3,
    VK_LOGIC_OP_AND_INVERTED = 4,
    VK_LOGIC_OP_NO_OP = 5,
    VK_LOGIC_OP_XOR = 6,
    VK_LOGIC_OP_OR = 7,
    VK_LOGIC_OP_NOR = 8,
    VK_LOGIC_OP_EQUIVALENT = 9,
    VK_LOGIC_OP_INVERT = 10,
    VK_LOGIC_OP_OR_REVERSE = 11,
    VK_LOGIC_OP_COPY_INVERTED = 12,
    VK_LOGIC_OP_OR_INVERTED = 13,
    VK_LOGIC_OP_NAND = 14,
    VK_LOGIC_OP_SET = 15,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkInternalAllocationType = enum(u32) {
    VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE = 0,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkSystemAllocationScope = enum(u32) {
    VK_SYSTEM_ALLOCATION_SCOPE_COMMAND = 0,
    VK_SYSTEM_ALLOCATION_SCOPE_OBJECT = 1,
    VK_SYSTEM_ALLOCATION_SCOPE_CACHE = 2,
    VK_SYSTEM_ALLOCATION_SCOPE_DEVICE = 3,
    VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE = 4,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkPhysicalDeviceType = enum(u32) {
    VK_PHYSICAL_DEVICE_TYPE_OTHER = 0,
    VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU = 1,
    VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU = 2,
    VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU = 3,
    VK_PHYSICAL_DEVICE_TYPE_CPU = 4,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkVertexInputRate = enum(u32) {
    VK_VERTEX_INPUT_RATE_VERTEX = 0,
    VK_VERTEX_INPUT_RATE_INSTANCE = 1,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkFormat = enum(u32) {
    VK_FORMAT_UNDEFINED = 0,
    VK_FORMAT_R4G4_UNORM_PACK8 = 1,
    VK_FORMAT_R4G4B4A4_UNORM_PACK16 = 2,
    VK_FORMAT_B4G4R4A4_UNORM_PACK16 = 3,
    VK_FORMAT_R5G6B5_UNORM_PACK16 = 4,
    VK_FORMAT_B5G6R5_UNORM_PACK16 = 5,
    VK_FORMAT_R5G5B5A1_UNORM_PACK16 = 6,
    VK_FORMAT_B5G5R5A1_UNORM_PACK16 = 7,
    VK_FORMAT_A1R5G5B5_UNORM_PACK16 = 8,
    VK_FORMAT_R8_UNORM = 9,
    VK_FORMAT_R8_SNORM = 10,
    VK_FORMAT_R8_USCALED = 11,
    VK_FORMAT_R8_SSCALED = 12,
    VK_FORMAT_R8_UINT = 13,
    VK_FORMAT_R8_SINT = 14,
    VK_FORMAT_R8_SRGB = 15,
    VK_FORMAT_R8G8_UNORM = 16,
    VK_FORMAT_R8G8_SNORM = 17,
    VK_FORMAT_R8G8_USCALED = 18,
    VK_FORMAT_R8G8_SSCALED = 19,
    VK_FORMAT_R8G8_UINT = 20,
    VK_FORMAT_R8G8_SINT = 21,
    VK_FORMAT_R8G8_SRGB = 22,
    VK_FORMAT_R8G8B8_UNORM = 23,
    VK_FORMAT_R8G8B8_SNORM = 24,
    VK_FORMAT_R8G8B8_USCALED = 25,
    VK_FORMAT_R8G8B8_SSCALED = 26,
    VK_FORMAT_R8G8B8_UINT = 27,
    VK_FORMAT_R8G8B8_SINT = 28,
    VK_FORMAT_R8G8B8_SRGB = 29,
    VK_FORMAT_B8G8R8_UNORM = 30,
    VK_FORMAT_B8G8R8_SNORM = 31,
    VK_FORMAT_B8G8R8_USCALED = 32,
    VK_FORMAT_B8G8R8_SSCALED = 33,
    VK_FORMAT_B8G8R8_UINT = 34,
    VK_FORMAT_B8G8R8_SINT = 35,
    VK_FORMAT_B8G8R8_SRGB = 36,
    VK_FORMAT_R8G8B8A8_UNORM = 37,
    VK_FORMAT_R8G8B8A8_SNORM = 38,
    VK_FORMAT_R8G8B8A8_USCALED = 39,
    VK_FORMAT_R8G8B8A8_SSCALED = 40,
    VK_FORMAT_R8G8B8A8_UINT = 41,
    VK_FORMAT_R8G8B8A8_SINT = 42,
    VK_FORMAT_R8G8B8A8_SRGB = 43,
    VK_FORMAT_B8G8R8A8_UNORM = 44,
    VK_FORMAT_B8G8R8A8_SNORM = 45,
    VK_FORMAT_B8G8R8A8_USCALED = 46,
    VK_FORMAT_B8G8R8A8_SSCALED = 47,
    VK_FORMAT_B8G8R8A8_UINT = 48,
    VK_FORMAT_B8G8R8A8_SINT = 49,
    VK_FORMAT_B8G8R8A8_SRGB = 50,
    VK_FORMAT_A8B8G8R8_UNORM_PACK32 = 51,
    VK_FORMAT_A8B8G8R8_SNORM_PACK32 = 52,
    VK_FORMAT_A8B8G8R8_USCALED_PACK32 = 53,
    VK_FORMAT_A8B8G8R8_SSCALED_PACK32 = 54,
    VK_FORMAT_A8B8G8R8_UINT_PACK32 = 55,
    VK_FORMAT_A8B8G8R8_SINT_PACK32 = 56,
    VK_FORMAT_A8B8G8R8_SRGB_PACK32 = 57,
    VK_FORMAT_A2R10G10B10_UNORM_PACK32 = 58,
    VK_FORMAT_A2R10G10B10_SNORM_PACK32 = 59,
    VK_FORMAT_A2R10G10B10_USCALED_PACK32 = 60,
    VK_FORMAT_A2R10G10B10_SSCALED_PACK32 = 61,
    VK_FORMAT_A2R10G10B10_UINT_PACK32 = 62,
    VK_FORMAT_A2R10G10B10_SINT_PACK32 = 63,
    VK_FORMAT_A2B10G10R10_UNORM_PACK32 = 64,
    VK_FORMAT_A2B10G10R10_SNORM_PACK32 = 65,
    VK_FORMAT_A2B10G10R10_USCALED_PACK32 = 66,
    VK_FORMAT_A2B10G10R10_SSCALED_PACK32 = 67,
    VK_FORMAT_A2B10G10R10_UINT_PACK32 = 68,
    VK_FORMAT_A2B10G10R10_SINT_PACK32 = 69,
    VK_FORMAT_R16_UNORM = 70,
    VK_FORMAT_R16_SNORM = 71,
    VK_FORMAT_R16_USCALED = 72,
    VK_FORMAT_R16_SSCALED = 73,
    VK_FORMAT_R16_UINT = 74,
    VK_FORMAT_R16_SINT = 75,
    VK_FORMAT_R16_SFLOAT = 76,
    VK_FORMAT_R16G16_UNORM = 77,
    VK_FORMAT_R16G16_SNORM = 78,
    VK_FORMAT_R16G16_USCALED = 79,
    VK_FORMAT_R16G16_SSCALED = 80,
    VK_FORMAT_R16G16_UINT = 81,
    VK_FORMAT_R16G16_SINT = 82,
    VK_FORMAT_R16G16_SFLOAT = 83,
    VK_FORMAT_R16G16B16_UNORM = 84,
    VK_FORMAT_R16G16B16_SNORM = 85,
    VK_FORMAT_R16G16B16_USCALED = 86,
    VK_FORMAT_R16G16B16_SSCALED = 87,
    VK_FORMAT_R16G16B16_UINT = 88,
    VK_FORMAT_R16G16B16_SINT = 89,
    VK_FORMAT_R16G16B16_SFLOAT = 90,
    VK_FORMAT_R16G16B16A16_UNORM = 91,
    VK_FORMAT_R16G16B16A16_SNORM = 92,
    VK_FORMAT_R16G16B16A16_USCALED = 93,
    VK_FORMAT_R16G16B16A16_SSCALED = 94,
    VK_FORMAT_R16G16B16A16_UINT = 95,
    VK_FORMAT_R16G16B16A16_SINT = 96,
    VK_FORMAT_R16G16B16A16_SFLOAT = 97,
    VK_FORMAT_R32_UINT = 98,
    VK_FORMAT_R32_SINT = 99,
    VK_FORMAT_R32_SFLOAT = 100,
    VK_FORMAT_R32G32_UINT = 101,
    VK_FORMAT_R32G32_SINT = 102,
    VK_FORMAT_R32G32_SFLOAT = 103,
    VK_FORMAT_R32G32B32_UINT = 104,
    VK_FORMAT_R32G32B32_SINT = 105,
    VK_FORMAT_R32G32B32_SFLOAT = 106,
    VK_FORMAT_R32G32B32A32_UINT = 107,
    VK_FORMAT_R32G32B32A32_SINT = 108,
    VK_FORMAT_R32G32B32A32_SFLOAT = 109,
    VK_FORMAT_R64_UINT = 110,
    VK_FORMAT_R64_SINT = 111,
    VK_FORMAT_R64_SFLOAT = 112,
    VK_FORMAT_R64G64_UINT = 113,
    VK_FORMAT_R64G64_SINT = 114,
    VK_FORMAT_R64G64_SFLOAT = 115,
    VK_FORMAT_R64G64B64_UINT = 116,
    VK_FORMAT_R64G64B64_SINT = 117,
    VK_FORMAT_R64G64B64_SFLOAT = 118,
    VK_FORMAT_R64G64B64A64_UINT = 119,
    VK_FORMAT_R64G64B64A64_SINT = 120,
    VK_FORMAT_R64G64B64A64_SFLOAT = 121,
    VK_FORMAT_B10G11R11_UFLOAT_PACK32 = 122,
    VK_FORMAT_E5B9G9R9_UFLOAT_PACK32 = 123,
    VK_FORMAT_D16_UNORM = 124,
    VK_FORMAT_X8_D24_UNORM_PACK32 = 125,
    VK_FORMAT_D32_SFLOAT = 126,
    VK_FORMAT_S8_UINT = 127,
    VK_FORMAT_D16_UNORM_S8_UINT = 128,
    VK_FORMAT_D24_UNORM_S8_UINT = 129,
    VK_FORMAT_D32_SFLOAT_S8_UINT = 130,
    VK_FORMAT_BC1_RGB_UNORM_BLOCK = 131,
    VK_FORMAT_BC1_RGB_SRGB_BLOCK = 132,
    VK_FORMAT_BC1_RGBA_UNORM_BLOCK = 133,
    VK_FORMAT_BC1_RGBA_SRGB_BLOCK = 134,
    VK_FORMAT_BC2_UNORM_BLOCK = 135,
    VK_FORMAT_BC2_SRGB_BLOCK = 136,
    VK_FORMAT_BC3_UNORM_BLOCK = 137,
    VK_FORMAT_BC3_SRGB_BLOCK = 138,
    VK_FORMAT_BC4_UNORM_BLOCK = 139,
    VK_FORMAT_BC4_SNORM_BLOCK = 140,
    VK_FORMAT_BC5_UNORM_BLOCK = 141,
    VK_FORMAT_BC5_SNORM_BLOCK = 142,
    VK_FORMAT_BC6H_UFLOAT_BLOCK = 143,
    VK_FORMAT_BC6H_SFLOAT_BLOCK = 144,
    VK_FORMAT_BC7_UNORM_BLOCK = 145,
    VK_FORMAT_BC7_SRGB_BLOCK = 146,
    VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK = 147,
    VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK = 148,
    VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK = 149,
    VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK = 150,
    VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK = 151,
    VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK = 152,
    VK_FORMAT_EAC_R11_UNORM_BLOCK = 153,
    VK_FORMAT_EAC_R11_SNORM_BLOCK = 154,
    VK_FORMAT_EAC_R11G11_UNORM_BLOCK = 155,
    VK_FORMAT_EAC_R11G11_SNORM_BLOCK = 156,
    VK_FORMAT_ASTC_4x4_UNORM_BLOCK = 157,
    VK_FORMAT_ASTC_4x4_SRGB_BLOCK = 158,
    VK_FORMAT_ASTC_5x4_UNORM_BLOCK = 159,
    VK_FORMAT_ASTC_5x4_SRGB_BLOCK = 160,
    VK_FORMAT_ASTC_5x5_UNORM_BLOCK = 161,
    VK_FORMAT_ASTC_5x5_SRGB_BLOCK = 162,
    VK_FORMAT_ASTC_6x5_UNORM_BLOCK = 163,
    VK_FORMAT_ASTC_6x5_SRGB_BLOCK = 164,
    VK_FORMAT_ASTC_6x6_UNORM_BLOCK = 165,
    VK_FORMAT_ASTC_6x6_SRGB_BLOCK = 166,
    VK_FORMAT_ASTC_8x5_UNORM_BLOCK = 167,
    VK_FORMAT_ASTC_8x5_SRGB_BLOCK = 168,
    VK_FORMAT_ASTC_8x6_UNORM_BLOCK = 169,
    VK_FORMAT_ASTC_8x6_SRGB_BLOCK = 170,
    VK_FORMAT_ASTC_8x8_UNORM_BLOCK = 171,
    VK_FORMAT_ASTC_8x8_SRGB_BLOCK = 172,
    VK_FORMAT_ASTC_10x5_UNORM_BLOCK = 173,
    VK_FORMAT_ASTC_10x5_SRGB_BLOCK = 174,
    VK_FORMAT_ASTC_10x6_UNORM_BLOCK = 175,
    VK_FORMAT_ASTC_10x6_SRGB_BLOCK = 176,
    VK_FORMAT_ASTC_10x8_UNORM_BLOCK = 177,
    VK_FORMAT_ASTC_10x8_SRGB_BLOCK = 178,
    VK_FORMAT_ASTC_10x10_UNORM_BLOCK = 179,
    VK_FORMAT_ASTC_10x10_SRGB_BLOCK = 180,
    VK_FORMAT_ASTC_12x10_UNORM_BLOCK = 181,
    VK_FORMAT_ASTC_12x10_SRGB_BLOCK = 182,
    VK_FORMAT_ASTC_12x12_UNORM_BLOCK = 183,
    VK_FORMAT_ASTC_12x12_SRGB_BLOCK = 184,
    // Extension: VK_IMG_format_pvrtc
    VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG = 1000054000,
    // Extension: VK_IMG_format_pvrtc
    VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG = 1000054001,
    // Extension: VK_IMG_format_pvrtc
    VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG = 1000054002,
    // Extension: VK_IMG_format_pvrtc
    VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG = 1000054003,
    // Extension: VK_IMG_format_pvrtc
    VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG = 1000054004,
    // Extension: VK_IMG_format_pvrtc
    VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG = 1000054005,
    // Extension: VK_IMG_format_pvrtc
    VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG = 1000054006,
    // Extension: VK_IMG_format_pvrtc
    VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG = 1000054007,
    // Extension: VK_BASE_VERSION_1_3
    // Alias: VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK_EXT
    VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK = 1000066000,
    // Extension: VK_BASE_VERSION_1_3
    // Alias: VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK_EXT
    VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK = 1000066001,
    // Extension: VK_BASE_VERSION_1_3
    // Alias: VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK_EXT
    VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK = 1000066002,
    // Extension: VK_BASE_VERSION_1_3
    // Alias: VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK_EXT
    VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK = 1000066003,
    // Extension: VK_BASE_VERSION_1_3
    // Alias: VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK_EXT
    VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK = 1000066004,
    // Extension: VK_BASE_VERSION_1_3
    // Alias: VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK_EXT
    VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK = 1000066005,
    // Extension: VK_BASE_VERSION_1_3
    // Alias: VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK_EXT
    VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK = 1000066006,
    // Extension: VK_BASE_VERSION_1_3
    // Alias: VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK_EXT
    VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK = 1000066007,
    // Extension: VK_BASE_VERSION_1_3
    // Alias: VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK_EXT
    VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK = 1000066008,
    // Extension: VK_BASE_VERSION_1_3
    // Alias: VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK_EXT
    VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK = 1000066009,
    // Extension: VK_BASE_VERSION_1_3
    // Alias: VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK_EXT
    VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK = 1000066010,
    // Extension: VK_BASE_VERSION_1_3
    // Alias: VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK_EXT
    VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK = 1000066011,
    // Extension: VK_BASE_VERSION_1_3
    // Alias: VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK_EXT
    VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK = 1000066012,
    // Extension: VK_BASE_VERSION_1_3
    // Alias: VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK_EXT
    VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK = 1000066013,
    // Extension: VK_BASE_VERSION_1_1
    // Alias: VK_FORMAT_G8B8G8R8_422_UNORM_KHR
    VK_FORMAT_G8B8G8R8_422_UNORM = 1000156000,
    // Extension: VK_BASE_VERSION_1_1
    // Alias: VK_FORMAT_B8G8R8G8_422_UNORM_KHR
    VK_FORMAT_B8G8R8G8_422_UNORM = 1000156001,
    // Extension: VK_BASE_VERSION_1_1
    // Alias: VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM_KHR
    VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM = 1000156002,
    // Extension: VK_BASE_VERSION_1_1
    // Alias: VK_FORMAT_G8_B8R8_2PLANE_420_UNORM_KHR
    VK_FORMAT_G8_B8R8_2PLANE_420_UNORM = 1000156003,
    // Extension: VK_BASE_VERSION_1_1
    // Alias: VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM_KHR
    VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM = 1000156004,
    // Extension: VK_BASE_VERSION_1_1
    // Alias: VK_FORMAT_G8_B8R8_2PLANE_422_UNORM_KHR
    VK_FORMAT_G8_B8R8_2PLANE_422_UNORM = 1000156005,
    // Extension: VK_BASE_VERSION_1_1
    // Alias: VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM_KHR
    VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM = 1000156006,
    // Extension: VK_BASE_VERSION_1_1
    // Alias: VK_FORMAT_R10X6_UNORM_PACK16_KHR
    VK_FORMAT_R10X6_UNORM_PACK16 = 1000156007,
    // Extension: VK_BASE_VERSION_1_1
    // Alias: VK_FORMAT_R10X6G10X6_UNORM_2PACK16_KHR
    VK_FORMAT_R10X6G10X6_UNORM_2PACK16 = 1000156008,
    // Extension: VK_BASE_VERSION_1_1
    // Alias: VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16_KHR
    VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16 = 1000156009,
    // Extension: VK_BASE_VERSION_1_1
    // Alias: VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16_KHR
    VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16 = 1000156010,
    // Extension: VK_BASE_VERSION_1_1
    // Alias: VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16_KHR
    VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16 = 1000156011,
    // Extension: VK_BASE_VERSION_1_1
    // Alias: VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16_KHR
    VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16 = 1000156012,
    // Extension: VK_BASE_VERSION_1_1
    // Alias: VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16_KHR
    VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16 = 1000156013,
    // Extension: VK_BASE_VERSION_1_1
    // Alias: VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16_KHR
    VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16 = 1000156014,
    // Extension: VK_BASE_VERSION_1_1
    // Alias: VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16_KHR
    VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16 = 1000156015,
    // Extension: VK_BASE_VERSION_1_1
    // Alias: VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16_KHR
    VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16 = 1000156016,
    // Extension: VK_BASE_VERSION_1_1
    // Alias: VK_FORMAT_R12X4_UNORM_PACK16_KHR
    VK_FORMAT_R12X4_UNORM_PACK16 = 1000156017,
    // Extension: VK_BASE_VERSION_1_1
    // Alias: VK_FORMAT_R12X4G12X4_UNORM_2PACK16_KHR
    VK_FORMAT_R12X4G12X4_UNORM_2PACK16 = 1000156018,
    // Extension: VK_BASE_VERSION_1_1
    // Alias: VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16_KHR
    VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16 = 1000156019,
    // Extension: VK_BASE_VERSION_1_1
    // Alias: VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16_KHR
    VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16 = 1000156020,
    // Extension: VK_BASE_VERSION_1_1
    // Alias: VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16_KHR
    VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16 = 1000156021,
    // Extension: VK_BASE_VERSION_1_1
    // Alias: VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16_KHR
    VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16 = 1000156022,
    // Extension: VK_BASE_VERSION_1_1
    // Alias: VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16_KHR
    VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16 = 1000156023,
    // Extension: VK_BASE_VERSION_1_1
    // Alias: VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16_KHR
    VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16 = 1000156024,
    // Extension: VK_BASE_VERSION_1_1
    // Alias: VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16_KHR
    VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16 = 1000156025,
    // Extension: VK_BASE_VERSION_1_1
    // Alias: VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16_KHR
    VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16 = 1000156026,
    // Extension: VK_BASE_VERSION_1_1
    // Alias: VK_FORMAT_G16B16G16R16_422_UNORM_KHR
    VK_FORMAT_G16B16G16R16_422_UNORM = 1000156027,
    // Extension: VK_BASE_VERSION_1_1
    // Alias: VK_FORMAT_B16G16R16G16_422_UNORM_KHR
    VK_FORMAT_B16G16R16G16_422_UNORM = 1000156028,
    // Extension: VK_BASE_VERSION_1_1
    // Alias: VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM_KHR
    VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM = 1000156029,
    // Extension: VK_BASE_VERSION_1_1
    // Alias: VK_FORMAT_G16_B16R16_2PLANE_420_UNORM_KHR
    VK_FORMAT_G16_B16R16_2PLANE_420_UNORM = 1000156030,
    // Extension: VK_BASE_VERSION_1_1
    // Alias: VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM_KHR
    VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM = 1000156031,
    // Extension: VK_BASE_VERSION_1_1
    // Alias: VK_FORMAT_G16_B16R16_2PLANE_422_UNORM_KHR
    VK_FORMAT_G16_B16R16_2PLANE_422_UNORM = 1000156032,
    // Extension: VK_BASE_VERSION_1_1
    // Alias: VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM_KHR
    VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM = 1000156033,
    // Extension: VK_BASE_VERSION_1_3
    // Alias: VK_FORMAT_G8_B8R8_2PLANE_444_UNORM_EXT
    VK_FORMAT_G8_B8R8_2PLANE_444_UNORM = 1000330000,
    // Extension: VK_BASE_VERSION_1_3
    // Alias: VK_FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16_EXT
    VK_FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16 = 1000330001,
    // Extension: VK_BASE_VERSION_1_3
    // Alias: VK_FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16_EXT
    VK_FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16 = 1000330002,
    // Extension: VK_BASE_VERSION_1_3
    // Alias: VK_FORMAT_G16_B16R16_2PLANE_444_UNORM_EXT
    VK_FORMAT_G16_B16R16_2PLANE_444_UNORM = 1000330003,
    // Extension: VK_BASE_VERSION_1_3
    // Alias: VK_FORMAT_A4R4G4B4_UNORM_PACK16_EXT
    VK_FORMAT_A4R4G4B4_UNORM_PACK16 = 1000340000,
    // Extension: VK_BASE_VERSION_1_3
    // Alias: VK_FORMAT_A4B4G4R4_UNORM_PACK16_EXT
    VK_FORMAT_A4B4G4R4_UNORM_PACK16 = 1000340001,
    // Extension: VK_ARM_tensors
    VK_FORMAT_R8_BOOL_ARM = 1000460000,
    // Extension: VK_NV_optical_flow
    // Alias: VK_FORMAT_R16G16_S10_5_NV
    VK_FORMAT_R16G16_SFIXED5_NV = 1000464000,
    // Extension: VK_BASE_VERSION_1_4
    // Alias: VK_FORMAT_A1B5G5R5_UNORM_PACK16_KHR
    VK_FORMAT_A1B5G5R5_UNORM_PACK16 = 1000470000,
    // Extension: VK_BASE_VERSION_1_4
    // Alias: VK_FORMAT_A8_UNORM_KHR
    VK_FORMAT_A8_UNORM = 1000470001,
    // Extension: VK_ARM_format_pack
    VK_FORMAT_R10X6_UINT_PACK16_ARM = 1000609000,
    // Extension: VK_ARM_format_pack
    VK_FORMAT_R10X6G10X6_UINT_2PACK16_ARM = 1000609001,
    // Extension: VK_ARM_format_pack
    VK_FORMAT_R10X6G10X6B10X6A10X6_UINT_4PACK16_ARM = 1000609002,
    // Extension: VK_ARM_format_pack
    VK_FORMAT_R12X4_UINT_PACK16_ARM = 1000609003,
    // Extension: VK_ARM_format_pack
    VK_FORMAT_R12X4G12X4_UINT_2PACK16_ARM = 1000609004,
    // Extension: VK_ARM_format_pack
    VK_FORMAT_R12X4G12X4B12X4A12X4_UINT_4PACK16_ARM = 1000609005,
    // Extension: VK_ARM_format_pack
    VK_FORMAT_R14X2_UINT_PACK16_ARM = 1000609006,
    // Extension: VK_ARM_format_pack
    VK_FORMAT_R14X2G14X2_UINT_2PACK16_ARM = 1000609007,
    // Extension: VK_ARM_format_pack
    VK_FORMAT_R14X2G14X2B14X2A14X2_UINT_4PACK16_ARM = 1000609008,
    // Extension: VK_ARM_format_pack
    VK_FORMAT_R14X2_UNORM_PACK16_ARM = 1000609009,
    // Extension: VK_ARM_format_pack
    VK_FORMAT_R14X2G14X2_UNORM_2PACK16_ARM = 1000609010,
    // Extension: VK_ARM_format_pack
    VK_FORMAT_R14X2G14X2B14X2A14X2_UNORM_4PACK16_ARM = 1000609011,
    // Extension: VK_ARM_format_pack
    VK_FORMAT_G14X2_B14X2R14X2_2PLANE_420_UNORM_3PACK16_ARM = 1000609012,
    // Extension: VK_ARM_format_pack
    VK_FORMAT_G14X2_B14X2R14X2_2PLANE_422_UNORM_3PACK16_ARM = 1000609013,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkStructureType = enum(u32) {
    VK_STRUCTURE_TYPE_APPLICATION_INFO = 0,
    VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO = 1,
    VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO = 2,
    VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO = 3,
    VK_STRUCTURE_TYPE_SUBMIT_INFO = 4,
    VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO = 5,
    VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE = 6,
    VK_STRUCTURE_TYPE_BIND_SPARSE_INFO = 7,
    VK_STRUCTURE_TYPE_FENCE_CREATE_INFO = 8,
    VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO = 9,
    VK_STRUCTURE_TYPE_EVENT_CREATE_INFO = 10,
    VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO = 11,
    VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO = 12,
    VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO = 13,
    VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO = 14,
    VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO = 15,
    VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO = 16,
    VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO = 17,
    VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO = 18,
    VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO = 19,
    VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO = 20,
    VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO = 21,
    VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO = 22,
    VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO = 23,
    VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO = 24,
    VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO = 25,
    VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO = 26,
    VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO = 27,
    VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO = 28,
    VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO = 29,
    VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO = 30,
    VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO = 31,
    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO = 32,
    VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO = 33,
    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO = 34,
    VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET = 35,
    VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET = 36,
    VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO = 37,
    VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO = 38,
    VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO = 39,
    VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO = 40,
    VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO = 41,
    VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO = 42,
    VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO = 43,
    VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER = 44,
    VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER = 45,
    VK_STRUCTURE_TYPE_MEMORY_BARRIER = 46,
    // Comment: Reserved for internal use by the loader, layers, and ICDs
    VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO = 47,
    // Comment: Reserved for internal use by the loader, layers, and ICDs
    VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO = 48,
    // Extension: VK_BASE_VERSION_1_2
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES = 49,
    // Extension: VK_BASE_VERSION_1_2
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES = 50,
    // Extension: VK_BASE_VERSION_1_2
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES = 51,
    // Extension: VK_BASE_VERSION_1_2
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES = 52,
    // Extension: VK_BASE_VERSION_1_3
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES = 53,
    // Extension: VK_BASE_VERSION_1_3
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES = 54,
    // Extension: VK_BASE_VERSION_1_4
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_FEATURES = 55,
    // Extension: VK_BASE_VERSION_1_4
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_PROPERTIES = 56,
    // Extension: VK_KHR_swapchain
    VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR = 1000001000,
    // Extension: VK_KHR_swapchain
    VK_STRUCTURE_TYPE_PRESENT_INFO_KHR = 1000001001,
    // Extension: VK_KHR_display
    VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR = 1000002000,
    // Extension: VK_KHR_display
    VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR = 1000002001,
    // Extension: VK_KHR_display_swapchain
    VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR = 1000003000,
    // Extension: VK_KHR_xlib_surface
    VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR = 1000004000,
    // Extension: VK_KHR_xcb_surface
    VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR = 1000005000,
    // Extension: VK_KHR_wayland_surface
    VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR = 1000006000,
    // Extension: VK_KHR_android_surface
    VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR = 1000008000,
    // Extension: VK_KHR_win32_surface
    VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR = 1000009000,
    // Extension: VK_EXT_debug_report
    // Alias: VK_STRUCTURE_TYPE_DEBUG_REPORT_CREATE_INFO_EXT
    VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT = 1000011000,
    // Extension: VK_AMD_rasterization_order
    VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD = 1000018000,
    // Extension: VK_EXT_debug_marker
    VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT = 1000022000,
    // Extension: VK_EXT_debug_marker
    VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT = 1000022001,
    // Extension: VK_EXT_debug_marker
    VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT = 1000022002,
    // Extension: VK_KHR_video_queue
    VK_STRUCTURE_TYPE_VIDEO_PROFILE_INFO_KHR = 1000023000,
    // Extension: VK_KHR_video_queue
    VK_STRUCTURE_TYPE_VIDEO_CAPABILITIES_KHR = 1000023001,
    // Extension: VK_KHR_video_queue
    VK_STRUCTURE_TYPE_VIDEO_PICTURE_RESOURCE_INFO_KHR = 1000023002,
    // Extension: VK_KHR_video_queue
    VK_STRUCTURE_TYPE_VIDEO_SESSION_MEMORY_REQUIREMENTS_KHR = 1000023003,
    // Extension: VK_KHR_video_queue
    VK_STRUCTURE_TYPE_BIND_VIDEO_SESSION_MEMORY_INFO_KHR = 1000023004,
    // Extension: VK_KHR_video_queue
    VK_STRUCTURE_TYPE_VIDEO_SESSION_CREATE_INFO_KHR = 1000023005,
    // Extension: VK_KHR_video_queue
    VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_CREATE_INFO_KHR = 1000023006,
    // Extension: VK_KHR_video_queue
    VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_UPDATE_INFO_KHR = 1000023007,
    // Extension: VK_KHR_video_queue
    VK_STRUCTURE_TYPE_VIDEO_BEGIN_CODING_INFO_KHR = 1000023008,
    // Extension: VK_KHR_video_queue
    VK_STRUCTURE_TYPE_VIDEO_END_CODING_INFO_KHR = 1000023009,
    // Extension: VK_KHR_video_queue
    VK_STRUCTURE_TYPE_VIDEO_CODING_CONTROL_INFO_KHR = 1000023010,
    // Extension: VK_KHR_video_queue
    VK_STRUCTURE_TYPE_VIDEO_REFERENCE_SLOT_INFO_KHR = 1000023011,
    // Extension: VK_KHR_video_queue
    VK_STRUCTURE_TYPE_QUEUE_FAMILY_VIDEO_PROPERTIES_KHR = 1000023012,
    // Extension: VK_KHR_video_queue
    VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR = 1000023013,
    // Extension: VK_KHR_video_queue
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_FORMAT_INFO_KHR = 1000023014,
    // Extension: VK_KHR_video_queue
    VK_STRUCTURE_TYPE_VIDEO_FORMAT_PROPERTIES_KHR = 1000023015,
    // Extension: VK_KHR_video_queue
    VK_STRUCTURE_TYPE_QUEUE_FAMILY_QUERY_RESULT_STATUS_PROPERTIES_KHR = 1000023016,
    // Extension: VK_KHR_video_decode_queue
    VK_STRUCTURE_TYPE_VIDEO_DECODE_INFO_KHR = 1000024000,
    // Extension: VK_KHR_video_decode_queue
    VK_STRUCTURE_TYPE_VIDEO_DECODE_CAPABILITIES_KHR = 1000024001,
    // Extension: VK_KHR_video_decode_queue
    VK_STRUCTURE_TYPE_VIDEO_DECODE_USAGE_INFO_KHR = 1000024002,
    // Extension: VK_NV_dedicated_allocation
    VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV = 1000026000,
    // Extension: VK_NV_dedicated_allocation
    VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV = 1000026001,
    // Extension: VK_NV_dedicated_allocation
    VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV = 1000026002,
    // Extension: VK_EXT_transform_feedback
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT = 1000028000,
    // Extension: VK_EXT_transform_feedback
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT = 1000028001,
    // Extension: VK_EXT_transform_feedback
    VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT = 1000028002,
    // Extension: VK_NVX_binary_import
    VK_STRUCTURE_TYPE_CU_MODULE_CREATE_INFO_NVX = 1000029000,
    // Extension: VK_NVX_binary_import
    VK_STRUCTURE_TYPE_CU_FUNCTION_CREATE_INFO_NVX = 1000029001,
    // Extension: VK_NVX_binary_import
    VK_STRUCTURE_TYPE_CU_LAUNCH_INFO_NVX = 1000029002,
    // Extension: VK_NVX_binary_import
    VK_STRUCTURE_TYPE_CU_MODULE_TEXTURING_MODE_CREATE_INFO_NVX = 1000029004,
    // Extension: VK_NVX_image_view_handle
    VK_STRUCTURE_TYPE_IMAGE_VIEW_HANDLE_INFO_NVX = 1000030000,
    // Extension: VK_NVX_image_view_handle
    VK_STRUCTURE_TYPE_IMAGE_VIEW_ADDRESS_PROPERTIES_NVX = 1000030001,
    // Extension: VK_KHR_video_encode_h264
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_CAPABILITIES_KHR = 1000038000,
    // Extension: VK_KHR_video_encode_h264
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR = 1000038001,
    // Extension: VK_KHR_video_encode_h264
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR = 1000038002,
    // Extension: VK_KHR_video_encode_h264
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PICTURE_INFO_KHR = 1000038003,
    // Extension: VK_KHR_video_encode_h264
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_DPB_SLOT_INFO_KHR = 1000038004,
    // Extension: VK_KHR_video_encode_h264
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_NALU_SLICE_INFO_KHR = 1000038005,
    // Extension: VK_KHR_video_encode_h264
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_GOP_REMAINING_FRAME_INFO_KHR = 1000038006,
    // Extension: VK_KHR_video_encode_h264
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PROFILE_INFO_KHR = 1000038007,
    // Extension: VK_KHR_video_encode_h264
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_INFO_KHR = 1000038008,
    // Extension: VK_KHR_video_encode_h264
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_LAYER_INFO_KHR = 1000038009,
    // Extension: VK_KHR_video_encode_h264
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_CREATE_INFO_KHR = 1000038010,
    // Extension: VK_KHR_video_encode_h264
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_QUALITY_LEVEL_PROPERTIES_KHR = 1000038011,
    // Extension: VK_KHR_video_encode_h264
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_GET_INFO_KHR = 1000038012,
    // Extension: VK_KHR_video_encode_h264
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_FEEDBACK_INFO_KHR = 1000038013,
    // Extension: VK_KHR_video_encode_h265
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_CAPABILITIES_KHR = 1000039000,
    // Extension: VK_KHR_video_encode_h265
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR = 1000039001,
    // Extension: VK_KHR_video_encode_h265
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR = 1000039002,
    // Extension: VK_KHR_video_encode_h265
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PICTURE_INFO_KHR = 1000039003,
    // Extension: VK_KHR_video_encode_h265
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_DPB_SLOT_INFO_KHR = 1000039004,
    // Extension: VK_KHR_video_encode_h265
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_NALU_SLICE_SEGMENT_INFO_KHR = 1000039005,
    // Extension: VK_KHR_video_encode_h265
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_GOP_REMAINING_FRAME_INFO_KHR = 1000039006,
    // Extension: VK_KHR_video_encode_h265
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PROFILE_INFO_KHR = 1000039007,
    // Extension: VK_KHR_video_encode_h265
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_INFO_KHR = 1000039009,
    // Extension: VK_KHR_video_encode_h265
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_LAYER_INFO_KHR = 1000039010,
    // Extension: VK_KHR_video_encode_h265
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_CREATE_INFO_KHR = 1000039011,
    // Extension: VK_KHR_video_encode_h265
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_QUALITY_LEVEL_PROPERTIES_KHR = 1000039012,
    // Extension: VK_KHR_video_encode_h265
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_GET_INFO_KHR = 1000039013,
    // Extension: VK_KHR_video_encode_h265
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_FEEDBACK_INFO_KHR = 1000039014,
    // Extension: VK_KHR_video_decode_h264
    VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_CAPABILITIES_KHR = 1000040000,
    // Extension: VK_KHR_video_decode_h264
    VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PICTURE_INFO_KHR = 1000040001,
    // Extension: VK_KHR_video_decode_h264
    VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PROFILE_INFO_KHR = 1000040003,
    // Extension: VK_KHR_video_decode_h264
    VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR = 1000040004,
    // Extension: VK_KHR_video_decode_h264
    VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR = 1000040005,
    // Extension: VK_KHR_video_decode_h264
    VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_DPB_SLOT_INFO_KHR = 1000040006,
    // Extension: VK_AMD_texture_gather_bias_lod
    VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD = 1000041000,
    // Extension: VK_GRAPHICS_VERSION_1_3
    // Alias: VK_STRUCTURE_TYPE_RENDERING_INFO_KHR
    VK_STRUCTURE_TYPE_RENDERING_INFO = 1000044000,
    // Extension: VK_GRAPHICS_VERSION_1_3
    // Alias: VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO_KHR
    VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO = 1000044001,
    // Extension: VK_GRAPHICS_VERSION_1_3
    // Alias: VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO_KHR
    VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO = 1000044002,
    // Extension: VK_GRAPHICS_VERSION_1_3
    // Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES_KHR
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES = 1000044003,
    // Extension: VK_GRAPHICS_VERSION_1_3
    // Alias: VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO_KHR
    VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO = 1000044004,
    // Extension: VK_KHR_fragment_shading_rate
    VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR = 1000044006,
    // Extension: VK_EXT_fragment_density_map
    VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT = 1000044007,
    // Extension: VK_AMD_mixed_attachment_samples
    // Alias: VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_NV
    VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD = 1000044008,
    // Extension: VK_NVX_multiview_per_view_attributes
    VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_NVX = 1000044009,
    // Extension: VK_GGP_stream_descriptor_surface
    VK_STRUCTURE_TYPE_STREAM_DESCRIPTOR_SURFACE_CREATE_INFO_GGP = 1000049000,
    // Extension: VK_NV_corner_sampled_image
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV = 1000050000,
    // Extension: VK_NV_private_vendor_info
    VK_STRUCTURE_TYPE_PRIVATE_VENDOR_INFO_PLACEHOLDER_OFFSET_0_NV = 1000051000,
    // Extension: VK_GRAPHICS_VERSION_1_1
    // Alias: VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO_KHR
    VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO = 1000053000,
    // Extension: VK_GRAPHICS_VERSION_1_1
    // Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES_KHR
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES = 1000053001,
    // Extension: VK_GRAPHICS_VERSION_1_1
    // Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES_KHR
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES = 1000053002,
    // Extension: VK_NV_external_memory
    VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV = 1000056000,
    // Extension: VK_NV_external_memory
    VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV = 1000056001,
    // Extension: VK_NV_external_memory_win32
    VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV = 1000057000,
    // Extension: VK_NV_external_memory_win32
    VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV = 1000057001,
    // Extension: VK_NV_win32_keyed_mutex
    VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV = 1000058000,
    // Extension: VK_BASE_VERSION_1_1
    // Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2_KHR
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2 = 1000059000,
    // Extension: VK_BASE_VERSION_1_1
    // Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2_KHR
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2 = 1000059001,
    // Extension: VK_BASE_VERSION_1_1
    // Alias: VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2_KHR
    VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2 = 1000059002,
    // Extension: VK_BASE_VERSION_1_1
    // Alias: VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2_KHR
    VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2 = 1000059003,
    // Extension: VK_BASE_VERSION_1_1
    // Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2_KHR
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2 = 1000059004,
    // Extension: VK_BASE_VERSION_1_1
    // Alias: VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2_KHR
    VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2 = 1000059005,
    // Extension: VK_BASE_VERSION_1_1
    // Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2_KHR
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2 = 1000059006,
    // Extension: VK_BASE_VERSION_1_1
    // Alias: VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2_KHR
    VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2 = 1000059007,
    // Extension: VK_BASE_VERSION_1_1
    // Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2_KHR
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2 = 1000059008,
    // Extension: VK_BASE_VERSION_1_1
    // Alias: VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO_KHR
    VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO = 1000060000,
    // Extension: VK_GRAPHICS_VERSION_1_1
    // Alias: VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO_KHR
    VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO = 1000060003,
    // Extension: VK_BASE_VERSION_1_1
    // Alias: VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO_KHR
    VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO = 1000060004,
    // Extension: VK_BASE_VERSION_1_1
    // Alias: VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO_KHR
    VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO = 1000060005,
    // Extension: VK_BASE_VERSION_1_1
    // Alias: VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO_KHR
    VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO = 1000060006,
    // Extension: VK_KHR_device_group
    // Extension: VK_KHR_swapchain
    VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR = 1000060007,
    // Extension: VK_KHR_device_group
    // Extension: VK_KHR_swapchain
    VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR = 1000060008,
    // Extension: VK_KHR_swapchain
    // Extension: VK_KHR_device_group
    VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR = 1000060009,
    // Extension: VK_KHR_device_group
    // Extension: VK_KHR_swapchain
    VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR = 1000060010,
    // Extension: VK_KHR_device_group
    // Extension: VK_KHR_swapchain
    VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR = 1000060011,
    // Extension: VK_KHR_swapchain
    // Extension: VK_KHR_device_group
    VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR = 1000060012,
    // Extension: VK_BASE_VERSION_1_1
    // Alias: VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO_KHR
    VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO = 1000060013,
    // Extension: VK_BASE_VERSION_1_1
    // Alias: VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO_KHR
    VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO = 1000060014,
    // Extension: VK_EXT_validation_flags
    VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT = 1000061000,
    // Extension: VK_NN_vi_surface
    VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN = 1000062000,
    // Extension: VK_GRAPHICS_VERSION_1_1
    // Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETER_FEATURES
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES = 1000063000,
    // Extension: VK_BASE_VERSION_1_3
    // Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES_EXT
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES = 1000066000,
    // Extension: VK_EXT_astc_decode_mode
    VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT = 1000067000,
    // Extension: VK_EXT_astc_decode_mode
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT = 1000067001,
    // Extension: VK_COMPUTE_VERSION_1_4
    // Alias: VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO_EXT
    VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO = 1000068000,
    // Extension: VK_COMPUTE_VERSION_1_4
    // Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES_EXT
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES = 1000068001,
    // Extension: VK_COMPUTE_VERSION_1_4
    // Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES_EXT
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES = 1000068002,
    // Extension: VK_BASE_VERSION_1_1
    // Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES_KHR
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES = 1000070000,
    // Extension: VK_BASE_VERSION_1_1
    // Alias: VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO_KHR
    VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO = 1000070001,
    // Extension: VK_BASE_VERSION_1_1
    // Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO_KHR
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO = 1000071000,
    // Extension: VK_BASE_VERSION_1_1
    // Alias: VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES_KHR
    VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES = 1000071001,
    // Extension: VK_BASE_VERSION_1_1
    // Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO_KHR
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO = 1000071002,
    // Extension: VK_BASE_VERSION_1_1
    // Alias: VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES_KHR
    VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES = 1000071003,
    // Extension: VK_BASE_VERSION_1_1
    // Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES_KHR
    // Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES_KHR
    // Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES_KHR
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES = 1000071004,
    // Extension: VK_BASE_VERSION_1_1
    // Alias: VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO_KHR
    VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO = 1000072000,
    // Extension: VK_BASE_VERSION_1_1
    // Alias: VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_KHR
    VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO = 1000072001,
    // Extension: VK_BASE_VERSION_1_1
    // Alias: VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_KHR
    VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO = 1000072002,
    // Extension: VK_KHR_external_memory_win32
    VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR = 1000073000,
    // Extension: VK_KHR_external_memory_win32
    VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR = 1000073001,
    // Extension: VK_KHR_external_memory_win32
    VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR = 1000073002,
    // Extension: VK_KHR_external_memory_win32
    VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR = 1000073003,
    // Extension: VK_KHR_external_memory_fd
    VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR = 1000074000,
    // Extension: VK_KHR_external_memory_fd
    VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR = 1000074001,
    // Extension: VK_KHR_external_memory_fd
    VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR = 1000074002,
    // Extension: VK_KHR_win32_keyed_mutex
    VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR = 1000075000,
    // Extension: VK_BASE_VERSION_1_1
    // Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO_KHR
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO = 1000076000,
    // Extension: VK_BASE_VERSION_1_1
    // Alias: VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES_KHR
    VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES = 1000076001,
    // Extension: VK_BASE_VERSION_1_1
    // Alias: VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO_KHR
    VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO = 1000077000,
    // Extension: VK_KHR_external_semaphore_win32
    VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR = 1000078000,
    // Extension: VK_KHR_external_semaphore_win32
    VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR = 1000078001,
    // Extension: VK_KHR_external_semaphore_win32
    VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR = 1000078002,
    // Extension: VK_KHR_external_semaphore_win32
    VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR = 1000078003,
    // Extension: VK_KHR_external_semaphore_fd
    VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR = 1000079000,
    // Extension: VK_KHR_external_semaphore_fd
    VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR = 1000079001,
    // Extension: VK_COMPUTE_VERSION_1_4
    // Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES = 1000080000,
    // Extension: VK_EXT_conditional_rendering
    VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT = 1000081000,
    // Extension: VK_EXT_conditional_rendering
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT = 1000081001,
    // Extension: VK_EXT_conditional_rendering
    VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT = 1000081002,
    // Extension: VK_COMPUTE_VERSION_1_2
    // Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES_KHR
    // Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT16_INT8_FEATURES_KHR
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES = 1000082000,
    // Extension: VK_COMPUTE_VERSION_1_1
    // Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES_KHR
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES = 1000083000,
    // Extension: VK_KHR_incremental_present
    VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR = 1000084000,
    // Extension: VK_COMPUTE_VERSION_1_1
    // Alias: VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO_KHR
    VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO = 1000085000,
    // Extension: VK_NV_clip_space_w_scaling
    VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV = 1000087000,
    // Extension: VK_EXT_display_surface_counter
    // Alias: VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES2_EXT
    VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT = 1000090000,
    // Extension: VK_EXT_display_control
    VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT = 1000091000,
    // Extension: VK_EXT_display_control
    VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT = 1000091001,
    // Extension: VK_EXT_display_control
    VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT = 1000091002,
    // Extension: VK_EXT_display_control
    VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT = 1000091003,
    // Extension: VK_GOOGLE_display_timing
    VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE = 1000092000,
    // Extension: VK_COMPUTE_VERSION_1_1
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES = 1000094000,
    // Extension: VK_NVX_multiview_per_view_attributes
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX = 1000097000,
    // Extension: VK_NV_viewport_swizzle
    VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV = 1000098000,
    // Extension: VK_EXT_discard_rectangles
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT = 1000099000,
    // Extension: VK_EXT_discard_rectangles
    VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT = 1000099001,
    // Extension: VK_EXT_conservative_rasterization
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT = 1000101000,
    // Extension: VK_EXT_conservative_rasterization
    VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT = 1000101001,
    // Extension: VK_EXT_depth_clip_enable
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT = 1000102000,
    // Extension: VK_EXT_depth_clip_enable
    VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT = 1000102001,
    // Extension: VK_EXT_hdr_metadata
    VK_STRUCTURE_TYPE_HDR_METADATA_EXT = 1000105000,
    // Extension: VK_GRAPHICS_VERSION_1_2
    // Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES_KHR
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES = 1000108000,
    // Extension: VK_GRAPHICS_VERSION_1_2
    // Alias: VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO_KHR
    VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO = 1000108001,
    // Extension: VK_GRAPHICS_VERSION_1_2
    // Alias: VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO_KHR
    VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO = 1000108002,
    // Extension: VK_GRAPHICS_VERSION_1_2
    // Alias: VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO_KHR
    VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO = 1000108003,
    // Extension: VK_GRAPHICS_VERSION_1_2
    // Alias: VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2_KHR
    VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2 = 1000109000,
    // Extension: VK_GRAPHICS_VERSION_1_2
    // Alias: VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2_KHR
    VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2 = 1000109001,
    // Extension: VK_GRAPHICS_VERSION_1_2
    // Alias: VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2_KHR
    VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2 = 1000109002,
    // Extension: VK_GRAPHICS_VERSION_1_2
    // Alias: VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2_KHR
    VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2 = 1000109003,
    // Extension: VK_GRAPHICS_VERSION_1_2
    // Alias: VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2_KHR
    VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2 = 1000109004,
    // Extension: VK_GRAPHICS_VERSION_1_2
    // Alias: VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO_KHR
    VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO = 1000109005,
    // Extension: VK_GRAPHICS_VERSION_1_2
    // Alias: VK_STRUCTURE_TYPE_SUBPASS_END_INFO_KHR
    VK_STRUCTURE_TYPE_SUBPASS_END_INFO = 1000109006,
    // Extension: VK_IMG_relaxed_line_rasterization
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RELAXED_LINE_RASTERIZATION_FEATURES_IMG = 1000110000,
    // Extension: VK_KHR_shared_presentable_image
    VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR = 1000111000,
    // Extension: VK_BASE_VERSION_1_1
    // Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO_KHR
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO = 1000112000,
    // Extension: VK_BASE_VERSION_1_1
    // Alias: VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES_KHR
    VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES = 1000112001,
    // Extension: VK_BASE_VERSION_1_1
    // Alias: VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO_KHR
    VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO = 1000113000,
    // Extension: VK_KHR_external_fence_win32
    VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR = 1000114000,
    // Extension: VK_KHR_external_fence_win32
    VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR = 1000114001,
    // Extension: VK_KHR_external_fence_win32
    VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR = 1000114002,
    // Extension: VK_KHR_external_fence_fd
    VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR = 1000115000,
    // Extension: VK_KHR_external_fence_fd
    VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR = 1000115001,
    // Extension: VK_KHR_performance_query
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR = 1000116000,
    // Extension: VK_KHR_performance_query
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR = 1000116001,
    // Extension: VK_KHR_performance_query
    VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR = 1000116002,
    // Extension: VK_KHR_performance_query
    VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR = 1000116003,
    // Extension: VK_KHR_performance_query
    VK_STRUCTURE_TYPE_ACQUIRE_PROFILING_LOCK_INFO_KHR = 1000116004,
    // Extension: VK_KHR_performance_query
    VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_KHR = 1000116005,
    // Extension: VK_KHR_performance_query
    VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_DESCRIPTION_KHR = 1000116006,
    // Extension: VK_KHR_performance_query
    VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_RESERVATION_INFO_KHR = 1000116007,
    // Extension: VK_GRAPHICS_VERSION_1_1
    // Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES_KHR
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES = 1000117000,
    // Extension: VK_GRAPHICS_VERSION_1_1
    // Alias: VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO_KHR
    VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO = 1000117001,
    // Extension: VK_BASE_VERSION_1_1
    // Alias: VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO_KHR
    VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO = 1000117002,
    // Extension: VK_GRAPHICS_VERSION_1_1
    // Alias: VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO_KHR
    VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO = 1000117003,
    // Extension: VK_KHR_get_surface_capabilities2
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR = 1000119000,
    // Extension: VK_KHR_get_surface_capabilities2
    VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR = 1000119001,
    // Extension: VK_KHR_get_surface_capabilities2
    VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR = 1000119002,
    // Extension: VK_COMPUTE_VERSION_1_1
    // Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES
    // Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES_KHR
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES = 1000120000,
    // Extension: VK_KHR_get_display_properties2
    VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR = 1000121000,
    // Extension: VK_KHR_get_display_properties2
    VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR = 1000121001,
    // Extension: VK_KHR_get_display_properties2
    VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR = 1000121002,
    // Extension: VK_KHR_get_display_properties2
    VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR = 1000121003,
    // Extension: VK_KHR_get_display_properties2
    VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR = 1000121004,
    // Extension: VK_MVK_ios_surface
    VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK = 1000122000,
    // Extension: VK_MVK_macos_surface
    VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK = 1000123000,
    // Extension: VK_BASE_VERSION_1_1
    // Alias: VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS_KHR
    VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS = 1000127000,
    // Extension: VK_BASE_VERSION_1_1
    // Alias: VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_KHR
    VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO = 1000127001,
    // Extension: VK_EXT_debug_utils
    VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT = 1000128000,
    // Extension: VK_EXT_debug_utils
    VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT = 1000128001,
    // Extension: VK_EXT_debug_utils
    VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT = 1000128002,
    // Extension: VK_EXT_debug_utils
    VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT = 1000128003,
    // Extension: VK_EXT_debug_utils
    VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT = 1000128004,
    // Extension: VK_ANDROID_external_memory_android_hardware_buffer
    VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID = 1000129000,
    // Extension: VK_ANDROID_external_memory_android_hardware_buffer
    VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID = 1000129001,
    // Extension: VK_ANDROID_external_memory_android_hardware_buffer
    VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID = 1000129002,
    // Extension: VK_ANDROID_external_memory_android_hardware_buffer
    VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID = 1000129003,
    // Extension: VK_ANDROID_external_memory_android_hardware_buffer
    VK_STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID = 1000129004,
    // Extension: VK_ANDROID_external_memory_android_hardware_buffer
    VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID = 1000129005,
    // Extension: VK_ANDROID_external_memory_android_hardware_buffer
    VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_2_ANDROID = 1000129006,
    // Extension: VK_COMPUTE_VERSION_1_2
    // Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES = 1000130000,
    // Extension: VK_COMPUTE_VERSION_1_2
    // Alias: VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT
    VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO = 1000130001,
    // Extension: VK_AMDX_shader_enqueue
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ENQUEUE_FEATURES_AMDX = 1000134000,
    // Extension: VK_AMDX_shader_enqueue
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ENQUEUE_PROPERTIES_AMDX = 1000134001,
    // Extension: VK_AMDX_shader_enqueue
    VK_STRUCTURE_TYPE_EXECUTION_GRAPH_PIPELINE_SCRATCH_SIZE_AMDX = 1000134002,
    // Extension: VK_AMDX_shader_enqueue
    VK_STRUCTURE_TYPE_EXECUTION_GRAPH_PIPELINE_CREATE_INFO_AMDX = 1000134003,
    // Extension: VK_AMDX_shader_enqueue
    VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_NODE_CREATE_INFO_AMDX = 1000134004,
    // Extension: VK_COMPUTE_VERSION_1_3
    // Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES_EXT
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES = 1000138000,
    // Extension: VK_COMPUTE_VERSION_1_3
    // Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES_EXT
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES = 1000138001,
    // Extension: VK_COMPUTE_VERSION_1_3
    // Alias: VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK_EXT
    VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK = 1000138002,
    // Extension: VK_COMPUTE_VERSION_1_3
    // Alias: VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO_EXT
    VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO = 1000138003,
    // Extension: VK_KHR_shader_bfloat16
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_BFLOAT16_FEATURES_KHR = 1000141000,
    // Extension: VK_EXT_sample_locations
    VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT = 1000143000,
    // Extension: VK_EXT_sample_locations
    VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT = 1000143001,
    // Extension: VK_EXT_sample_locations
    VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT = 1000143002,
    // Extension: VK_EXT_sample_locations
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT = 1000143003,
    // Extension: VK_EXT_sample_locations
    VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT = 1000143004,
    // Extension: VK_BASE_VERSION_1_1
    VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO = 1000145000,
    // Extension: VK_BASE_VERSION_1_1
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES = 1000145001,
    // Extension: VK_BASE_VERSION_1_1
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES = 1000145002,
    // Extension: VK_BASE_VERSION_1_1
    VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2 = 1000145003,
    // Extension: VK_BASE_VERSION_1_1
    // Alias: VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2_KHR
    VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2 = 1000146000,
    // Extension: VK_BASE_VERSION_1_1
    // Alias: VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2_KHR
    VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2 = 1000146001,
    // Extension: VK_BASE_VERSION_1_1
    // Alias: VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2_KHR
    VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2 = 1000146002,
    // Extension: VK_BASE_VERSION_1_1
    // Alias: VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2_KHR
    VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2 = 1000146003,
    // Extension: VK_BASE_VERSION_1_1
    // Alias: VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2_KHR
    VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2 = 1000146004,
    // Extension: VK_BASE_VERSION_1_2
    // Alias: VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO_KHR
    VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO = 1000147000,
    // Extension: VK_EXT_blend_operation_advanced
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT = 1000148000,
    // Extension: VK_EXT_blend_operation_advanced
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT = 1000148001,
    // Extension: VK_EXT_blend_operation_advanced
    VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT = 1000148002,
    // Extension: VK_NV_fragment_coverage_to_color
    VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV = 1000149000,
    // Extension: VK_KHR_acceleration_structure
    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR = 1000150000,
    // Extension: VK_KHR_acceleration_structure
    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR = 1000150002,
    // Extension: VK_KHR_acceleration_structure
    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_AABBS_DATA_KHR = 1000150003,
    // Extension: VK_KHR_acceleration_structure
    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR = 1000150004,
    // Extension: VK_KHR_acceleration_structure
    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR = 1000150005,
    // Extension: VK_KHR_acceleration_structure
    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR = 1000150006,
    // Extension: VK_KHR_acceleration_structure
    VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR = 1000150007,
    // Extension: VK_KHR_acceleration_structure
    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_VERSION_INFO_KHR = 1000150009,
    // Extension: VK_KHR_acceleration_structure
    VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_INFO_KHR = 1000150010,
    // Extension: VK_KHR_acceleration_structure
    VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR = 1000150011,
    // Extension: VK_KHR_acceleration_structure
    VK_STRUCTURE_TYPE_COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR = 1000150012,
    // Extension: VK_KHR_acceleration_structure
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR = 1000150013,
    // Extension: VK_KHR_acceleration_structure
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR = 1000150014,
    // Extension: VK_KHR_ray_tracing_pipeline
    VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_KHR = 1000150015,
    // Extension: VK_KHR_ray_tracing_pipeline
    VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR = 1000150016,
    // Extension: VK_KHR_acceleration_structure
    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR = 1000150017,
    // Extension: VK_KHR_ray_tracing_pipeline
    VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_INTERFACE_CREATE_INFO_KHR = 1000150018,
    // Extension: VK_KHR_acceleration_structure
    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR = 1000150020,
    // Extension: VK_NV_framebuffer_mixed_samples
    VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV = 1000152000,
    // Extension: VK_NV_shader_sm_builtins
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV = 1000154000,
    // Extension: VK_NV_shader_sm_builtins
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV = 1000154001,
    // Extension: VK_COMPUTE_VERSION_1_1
    // Alias: VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO_KHR
    VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO = 1000156000,
    // Extension: VK_COMPUTE_VERSION_1_1
    // Alias: VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO_KHR
    VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO = 1000156001,
    // Extension: VK_COMPUTE_VERSION_1_1
    // Alias: VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO_KHR
    VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO = 1000156002,
    // Extension: VK_COMPUTE_VERSION_1_1
    // Alias: VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO_KHR
    VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO = 1000156003,
    // Extension: VK_COMPUTE_VERSION_1_1
    // Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES_KHR
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES = 1000156004,
    // Extension: VK_COMPUTE_VERSION_1_1
    // Alias: VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES_KHR
    VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES = 1000156005,
    // Extension: VK_BASE_VERSION_1_1
    // Alias: VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO_KHR
    VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO = 1000157000,
    // Extension: VK_BASE_VERSION_1_1
    // Alias: VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO_KHR
    VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO = 1000157001,
    // Extension: VK_EXT_image_drm_format_modifier
    VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT = 1000158000,
    // Extension: VK_EXT_image_drm_format_modifier
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT = 1000158002,
    // Extension: VK_EXT_image_drm_format_modifier
    VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT = 1000158003,
    // Extension: VK_EXT_image_drm_format_modifier
    VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT = 1000158004,
    // Extension: VK_EXT_image_drm_format_modifier
    VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT = 1000158005,
    // Extension: VK_EXT_image_drm_format_modifier
    VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT = 1000158006,
    // Extension: VK_EXT_validation_cache
    VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT = 1000160000,
    // Extension: VK_EXT_validation_cache
    VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT = 1000160001,
    // Extension: VK_COMPUTE_VERSION_1_2
    // Alias: VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT
    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO = 1000161000,
    // Extension: VK_COMPUTE_VERSION_1_2
    // Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES = 1000161001,
    // Extension: VK_COMPUTE_VERSION_1_2
    // Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES_EXT
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES = 1000161002,
    // Extension: VK_COMPUTE_VERSION_1_2
    // Alias: VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT
    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO = 1000161003,
    // Extension: VK_COMPUTE_VERSION_1_2
    // Alias: VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT
    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT = 1000161004,
    // Extension: VK_KHR_portability_subset
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_FEATURES_KHR = 1000163000,
    // Extension: VK_KHR_portability_subset
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_PROPERTIES_KHR = 1000163001,
    // Extension: VK_NV_shading_rate_image
    VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV = 1000164000,
    // Extension: VK_NV_shading_rate_image
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV = 1000164001,
    // Extension: VK_NV_shading_rate_image
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV = 1000164002,
    // Extension: VK_NV_shading_rate_image
    VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV = 1000164005,
    // Extension: VK_NV_ray_tracing
    VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV = 1000165000,
    // Extension: VK_NV_ray_tracing
    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV = 1000165001,
    // Extension: VK_NV_ray_tracing
    VK_STRUCTURE_TYPE_GEOMETRY_NV = 1000165003,
    // Extension: VK_NV_ray_tracing
    VK_STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV = 1000165004,
    // Extension: VK_NV_ray_tracing
    VK_STRUCTURE_TYPE_GEOMETRY_AABB_NV = 1000165005,
    // Extension: VK_NV_ray_tracing
    VK_STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV = 1000165006,
    // Extension: VK_NV_ray_tracing
    VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV = 1000165007,
    // Extension: VK_NV_ray_tracing
    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV = 1000165008,
    // Extension: VK_NV_ray_tracing
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV = 1000165009,
    // Extension: VK_NV_ray_tracing
    VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV = 1000165011,
    // Extension: VK_NV_ray_tracing
    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV = 1000165012,
    // Extension: VK_NV_representative_fragment_test
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV = 1000166000,
    // Extension: VK_NV_representative_fragment_test
    VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV = 1000166001,
    // Extension: VK_COMPUTE_VERSION_1_1
    // Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES_KHR
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES = 1000168000,
    // Extension: VK_COMPUTE_VERSION_1_1
    // Alias: VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT_KHR
    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT = 1000168001,
    // Extension: VK_EXT_filter_cubic
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT = 1000170000,
    // Extension: VK_EXT_filter_cubic
    VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT = 1000170001,
    // Extension: VK_BASE_VERSION_1_4
    // Alias: VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT
    // Alias: VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_KHR
    VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO = 1000174000,
    // Extension: VK_COMPUTE_VERSION_1_2
    // Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES_KHR
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES = 1000175000,
    // Extension: VK_COMPUTE_VERSION_1_2
    // Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES_KHR
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES = 1000177000,
    // Extension: VK_EXT_external_memory_host
    VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT = 1000178000,
    // Extension: VK_EXT_external_memory_host
    VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT = 1000178001,
    // Extension: VK_EXT_external_memory_host
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT = 1000178002,
    // Extension: VK_COMPUTE_VERSION_1_2
    // Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES_KHR
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES = 1000180000,
    // Extension: VK_KHR_shader_clock
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR = 1000181000,
    // Extension: VK_AMD_pipeline_compiler_control
    VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD = 1000183000,
    // Extension: VK_KHR_calibrated_timestamps
    // Alias: VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_EXT
    VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_KHR = 1000184000,
    // Extension: VK_AMD_shader_core_properties
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD = 1000185000,
    // Extension: VK_KHR_video_decode_h265
    VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_CAPABILITIES_KHR = 1000187000,
    // Extension: VK_KHR_video_decode_h265
    VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR = 1000187001,
    // Extension: VK_KHR_video_decode_h265
    VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR = 1000187002,
    // Extension: VK_KHR_video_decode_h265
    VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PROFILE_INFO_KHR = 1000187003,
    // Extension: VK_KHR_video_decode_h265
    VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PICTURE_INFO_KHR = 1000187004,
    // Extension: VK_KHR_video_decode_h265
    VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_DPB_SLOT_INFO_KHR = 1000187005,
    // Extension: VK_AMD_memory_overallocation_behavior
    VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD = 1000189000,
    // Extension: VK_EXT_vertex_attribute_divisor
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT = 1000190000,
    // Extension: VK_GRAPHICS_VERSION_1_4
    // Alias: VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT
    // Alias: VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_KHR
    VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO = 1000190001,
    // Extension: VK_GRAPHICS_VERSION_1_4
    // Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT
    // Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_KHR
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES = 1000190002,
    // Extension: VK_GGP_frame_token
    VK_STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP = 1000191000,
    // Extension: VK_COMPUTE_VERSION_1_3
    // Alias: VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO_EXT
    VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO = 1000192000,
    // Extension: VK_BASE_VERSION_1_2
    // Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES_KHR
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES = 1000196000,
    // Extension: VK_COMPUTE_VERSION_1_2
    // Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES_KHR
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES = 1000197000,
    // Extension: VK_GRAPHICS_VERSION_1_2
    // Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES_KHR
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES = 1000199000,
    // Extension: VK_GRAPHICS_VERSION_1_2
    // Alias: VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE_KHR
    VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE = 1000199001,
    // Extension: VK_KHR_compute_shader_derivatives
    // Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_KHR = 1000201000,
    // Extension: VK_NV_mesh_shader
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV = 1000202000,
    // Extension: VK_NV_mesh_shader
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV = 1000202001,
    // Extension: VK_KHR_fragment_shader_barycentric
    // Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_NV
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR = 1000203000,
    // Extension: VK_NV_shader_image_footprint
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV = 1000204000,
    // Extension: VK_NV_scissor_exclusive
    VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV = 1000205000,
    // Extension: VK_NV_scissor_exclusive
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV = 1000205002,
    // Extension: VK_NV_device_diagnostic_checkpoints
    VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV = 1000206000,
    // Extension: VK_NV_device_diagnostic_checkpoints
    VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV = 1000206001,
    // Extension: VK_BASE_VERSION_1_2
    // Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES_KHR
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES = 1000207000,
    // Extension: VK_BASE_VERSION_1_2
    // Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES_KHR
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES = 1000207001,
    // Extension: VK_BASE_VERSION_1_2
    // Alias: VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO_KHR
    VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO = 1000207002,
    // Extension: VK_BASE_VERSION_1_2
    // Alias: VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO_KHR
    VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO = 1000207003,
    // Extension: VK_BASE_VERSION_1_2
    // Alias: VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO_KHR
    VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO = 1000207004,
    // Extension: VK_BASE_VERSION_1_2
    // Alias: VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO_KHR
    VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO = 1000207005,
    // Extension: VK_EXT_present_timing
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_TIMING_FEATURES_EXT = 1000208000,
    // Extension: VK_EXT_present_timing
    VK_STRUCTURE_TYPE_SWAPCHAIN_TIMING_PROPERTIES_EXT = 1000208001,
    // Extension: VK_EXT_present_timing
    VK_STRUCTURE_TYPE_SWAPCHAIN_TIME_DOMAIN_PROPERTIES_EXT = 1000208002,
    // Extension: VK_EXT_present_timing
    VK_STRUCTURE_TYPE_PRESENT_TIMINGS_INFO_EXT = 1000208003,
    // Extension: VK_EXT_present_timing
    VK_STRUCTURE_TYPE_PRESENT_TIMING_INFO_EXT = 1000208004,
    // Extension: VK_EXT_present_timing
    VK_STRUCTURE_TYPE_PAST_PRESENTATION_TIMING_INFO_EXT = 1000208005,
    // Extension: VK_EXT_present_timing
    VK_STRUCTURE_TYPE_PAST_PRESENTATION_TIMING_PROPERTIES_EXT = 1000208006,
    // Extension: VK_EXT_present_timing
    VK_STRUCTURE_TYPE_PAST_PRESENTATION_TIMING_EXT = 1000208007,
    // Extension: VK_EXT_present_timing
    VK_STRUCTURE_TYPE_PRESENT_TIMING_SURFACE_CAPABILITIES_EXT = 1000208008,
    // Extension: VK_EXT_present_timing
    VK_STRUCTURE_TYPE_SWAPCHAIN_CALIBRATED_TIMESTAMP_INFO_EXT = 1000208009,
    // Extension: VK_INTEL_shader_integer_functions2
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL = 1000209000,
    // Extension: VK_INTEL_performance_query
    // Alias: VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO_INTEL
    VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL = 1000210000,
    // Extension: VK_INTEL_performance_query
    VK_STRUCTURE_TYPE_INITIALIZE_PERFORMANCE_API_INFO_INTEL = 1000210001,
    // Extension: VK_INTEL_performance_query
    VK_STRUCTURE_TYPE_PERFORMANCE_MARKER_INFO_INTEL = 1000210002,
    // Extension: VK_INTEL_performance_query
    VK_STRUCTURE_TYPE_PERFORMANCE_STREAM_MARKER_INFO_INTEL = 1000210003,
    // Extension: VK_INTEL_performance_query
    VK_STRUCTURE_TYPE_PERFORMANCE_OVERRIDE_INFO_INTEL = 1000210004,
    // Extension: VK_INTEL_performance_query
    VK_STRUCTURE_TYPE_PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL = 1000210005,
    // Extension: VK_BASE_VERSION_1_2
    // Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES_KHR
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES = 1000211000,
    // Extension: VK_EXT_pci_bus_info
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT = 1000212000,
    // Extension: VK_AMD_display_native_hdr
    VK_STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD = 1000213000,
    // Extension: VK_AMD_display_native_hdr
    VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD = 1000213001,
    // Extension: VK_FUCHSIA_imagepipe_surface
    VK_STRUCTURE_TYPE_IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA = 1000214000,
    // Extension: VK_COMPUTE_VERSION_1_3
    // Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES_KHR
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES = 1000215000,
    // Extension: VK_EXT_metal_surface
    VK_STRUCTURE_TYPE_METAL_SURFACE_CREATE_INFO_EXT = 1000217000,
    // Extension: VK_EXT_fragment_density_map
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT = 1000218000,
    // Extension: VK_EXT_fragment_density_map
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT = 1000218001,
    // Extension: VK_EXT_fragment_density_map
    VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT = 1000218002,
    // Extension: VK_COMPUTE_VERSION_1_2
    // Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES_EXT
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES = 1000221000,
    // Extension: VK_COMPUTE_VERSION_1_3
    // Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES_EXT
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES = 1000225000,
    // Extension: VK_COMPUTE_VERSION_1_3
    // Alias: VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO_EXT
    // Alias: VK_STRUCTURE_TYPE_SHADER_REQUIRED_SUBGROUP_SIZE_CREATE_INFO_EXT
    VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO = 1000225001,
    // Extension: VK_COMPUTE_VERSION_1_3
    // Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES_EXT
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES = 1000225002,
    // Extension: VK_KHR_fragment_shading_rate
    VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR = 1000226000,
    // Extension: VK_KHR_fragment_shading_rate
    VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR = 1000226001,
    // Extension: VK_KHR_fragment_shading_rate
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR = 1000226002,
    // Extension: VK_KHR_fragment_shading_rate
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR = 1000226003,
    // Extension: VK_KHR_fragment_shading_rate
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR = 1000226004,
    // Extension: VK_AMD_shader_core_properties2
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD = 1000227000,
    // Extension: VK_AMD_device_coherent_memory
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD = 1000229000,
    // Extension: VK_GRAPHICS_VERSION_1_4
    // Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_LOCAL_READ_FEATURES_KHR
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_LOCAL_READ_FEATURES = 1000232000,
    // Extension: VK_GRAPHICS_VERSION_1_4
    // Alias: VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_LOCATION_INFO_KHR
    VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_LOCATION_INFO = 1000232001,
    // Extension: VK_GRAPHICS_VERSION_1_4
    // Alias: VK_STRUCTURE_TYPE_RENDERING_INPUT_ATTACHMENT_INDEX_INFO_KHR
    VK_STRUCTURE_TYPE_RENDERING_INPUT_ATTACHMENT_INDEX_INFO = 1000232002,
    // Extension: VK_EXT_shader_image_atomic_int64
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT = 1000234000,
    // Extension: VK_KHR_shader_quad_control
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_QUAD_CONTROL_FEATURES_KHR = 1000235000,
    // Extension: VK_EXT_memory_budget
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT = 1000237000,
    // Extension: VK_EXT_memory_priority
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT = 1000238000,
    // Extension: VK_EXT_memory_priority
    VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT = 1000238001,
    // Extension: VK_KHR_surface_protected_capabilities
    VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR = 1000239000,
    // Extension: VK_NV_dedicated_allocation_image_aliasing
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV = 1000240000,
    // Extension: VK_GRAPHICS_VERSION_1_2
    // Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES_KHR
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES = 1000241000,
    // Extension: VK_GRAPHICS_VERSION_1_2
    // Alias: VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT_KHR
    VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT = 1000241001,
    // Extension: VK_GRAPHICS_VERSION_1_2
    // Alias: VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT_KHR
    VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT = 1000241002,
    // Extension: VK_EXT_buffer_device_address
    // Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_ADDRESS_FEATURES_EXT
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT = 1000244000,
    // Extension: VK_BASE_VERSION_1_2
    // Alias: VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_EXT
    // Alias: VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_KHR
    VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO = 1000244001,
    // Extension: VK_EXT_buffer_device_address
    VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT = 1000244002,
    // Extension: VK_BASE_VERSION_1_3
    // Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES_EXT
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES = 1000245000,
    // Extension: VK_GRAPHICS_VERSION_1_2
    // Alias: VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO_EXT
    VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO = 1000246000,
    // Extension: VK_EXT_validation_features
    VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT = 1000247000,
    // Extension: VK_KHR_present_wait
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR = 1000248000,
    // Extension: VK_NV_cooperative_matrix
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV = 1000249000,
    // Extension: VK_NV_cooperative_matrix
    VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_NV = 1000249001,
    // Extension: VK_NV_cooperative_matrix
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV = 1000249002,
    // Extension: VK_NV_coverage_reduction_mode
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV = 1000250000,
    // Extension: VK_NV_coverage_reduction_mode
    VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV = 1000250001,
    // Extension: VK_NV_coverage_reduction_mode
    VK_STRUCTURE_TYPE_FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV = 1000250002,
    // Extension: VK_EXT_fragment_shader_interlock
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT = 1000251000,
    // Extension: VK_EXT_ycbcr_image_arrays
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT = 1000252000,
    // Extension: VK_COMPUTE_VERSION_1_2
    // Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES_KHR
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES = 1000253000,
    // Extension: VK_EXT_provoking_vertex
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT = 1000254000,
    // Extension: VK_EXT_provoking_vertex
    VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT = 1000254001,
    // Extension: VK_EXT_provoking_vertex
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT = 1000254002,
    // Extension: VK_EXT_full_screen_exclusive
    VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT = 1000255000,
    // Extension: VK_EXT_full_screen_exclusive
    VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT = 1000255001,
    // Extension: VK_EXT_full_screen_exclusive
    VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT = 1000255002,
    // Extension: VK_EXT_headless_surface
    VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT = 1000256000,
    // Extension: VK_BASE_VERSION_1_2
    // Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_KHR
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES = 1000257000,
    // Extension: VK_BASE_VERSION_1_2
    // Alias: VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO_KHR
    VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO = 1000257002,
    // Extension: VK_BASE_VERSION_1_2
    // Alias: VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO_KHR
    VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO = 1000257003,
    // Extension: VK_BASE_VERSION_1_2
    // Alias: VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO_KHR
    VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO = 1000257004,
    // Extension: VK_GRAPHICS_VERSION_1_4
    // Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT
    // Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_KHR
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES = 1000259000,
    // Extension: VK_GRAPHICS_VERSION_1_4
    // Alias: VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT
    // Alias: VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_KHR
    VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO = 1000259001,
    // Extension: VK_GRAPHICS_VERSION_1_4
    // Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT
    // Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_KHR
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES = 1000259002,
    // Extension: VK_EXT_shader_atomic_float
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT = 1000260000,
    // Extension: VK_BASE_VERSION_1_2
    // Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES_EXT
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES = 1000261000,
    // Extension: VK_BASE_VERSION_1_4
    // Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT
    // Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_KHR
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES = 1000265000,
    // Extension: VK_EXT_extended_dynamic_state
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT = 1000267000,
    // Extension: VK_KHR_pipeline_executable_properties
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR = 1000269000,
    // Extension: VK_KHR_pipeline_executable_properties
    // Alias: VK_STRUCTURE_TYPE_PIPELINE_INFO_EXT
    VK_STRUCTURE_TYPE_PIPELINE_INFO_KHR = 1000269001,
    // Extension: VK_KHR_pipeline_executable_properties
    VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_PROPERTIES_KHR = 1000269002,
    // Extension: VK_KHR_pipeline_executable_properties
    VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INFO_KHR = 1000269003,
    // Extension: VK_KHR_pipeline_executable_properties
    VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_STATISTIC_KHR = 1000269004,
    // Extension: VK_KHR_pipeline_executable_properties
    VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR = 1000269005,
    // Extension: VK_BASE_VERSION_1_4
    // Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES_EXT
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES = 1000270000,
    // Extension: VK_BASE_VERSION_1_4
    // Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_PROPERTIES_EXT
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_PROPERTIES = 1000270001,
    // Extension: VK_BASE_VERSION_1_4
    // Alias: VK_STRUCTURE_TYPE_MEMORY_TO_IMAGE_COPY_EXT
    VK_STRUCTURE_TYPE_MEMORY_TO_IMAGE_COPY = 1000270002,
    // Extension: VK_BASE_VERSION_1_4
    // Alias: VK_STRUCTURE_TYPE_IMAGE_TO_MEMORY_COPY_EXT
    VK_STRUCTURE_TYPE_IMAGE_TO_MEMORY_COPY = 1000270003,
    // Extension: VK_BASE_VERSION_1_4
    // Alias: VK_STRUCTURE_TYPE_COPY_IMAGE_TO_MEMORY_INFO_EXT
    VK_STRUCTURE_TYPE_COPY_IMAGE_TO_MEMORY_INFO = 1000270004,
    // Extension: VK_BASE_VERSION_1_4
    // Alias: VK_STRUCTURE_TYPE_COPY_MEMORY_TO_IMAGE_INFO_EXT
    VK_STRUCTURE_TYPE_COPY_MEMORY_TO_IMAGE_INFO = 1000270005,
    // Extension: VK_BASE_VERSION_1_4
    // Alias: VK_STRUCTURE_TYPE_HOST_IMAGE_LAYOUT_TRANSITION_INFO_EXT
    VK_STRUCTURE_TYPE_HOST_IMAGE_LAYOUT_TRANSITION_INFO = 1000270006,
    // Extension: VK_BASE_VERSION_1_4
    // Alias: VK_STRUCTURE_TYPE_COPY_IMAGE_TO_IMAGE_INFO_EXT
    VK_STRUCTURE_TYPE_COPY_IMAGE_TO_IMAGE_INFO = 1000270007,
    // Extension: VK_BASE_VERSION_1_4
    // Alias: VK_STRUCTURE_TYPE_SUBRESOURCE_HOST_MEMCPY_SIZE_EXT
    VK_STRUCTURE_TYPE_SUBRESOURCE_HOST_MEMCPY_SIZE = 1000270008,
    // Extension: VK_BASE_VERSION_1_4
    // Alias: VK_STRUCTURE_TYPE_HOST_IMAGE_COPY_DEVICE_PERFORMANCE_QUERY_EXT
    VK_STRUCTURE_TYPE_HOST_IMAGE_COPY_DEVICE_PERFORMANCE_QUERY = 1000270009,
    // Extension: VK_BASE_VERSION_1_4
    // Alias: VK_STRUCTURE_TYPE_MEMORY_MAP_INFO_KHR
    VK_STRUCTURE_TYPE_MEMORY_MAP_INFO = 1000271000,
    // Extension: VK_BASE_VERSION_1_4
    // Alias: VK_STRUCTURE_TYPE_MEMORY_UNMAP_INFO_KHR
    VK_STRUCTURE_TYPE_MEMORY_UNMAP_INFO = 1000271001,
    // Extension: VK_EXT_map_memory_placed
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_FEATURES_EXT = 1000272000,
    // Extension: VK_EXT_map_memory_placed
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_PROPERTIES_EXT = 1000272001,
    // Extension: VK_EXT_map_memory_placed
    VK_STRUCTURE_TYPE_MEMORY_MAP_PLACED_INFO_EXT = 1000272002,
    // Extension: VK_EXT_shader_atomic_float2
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT = 1000273000,
    // Extension: VK_KHR_surface_maintenance1
    // Alias: VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_EXT
    VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_KHR = 1000274000,
    // Extension: VK_KHR_surface_maintenance1
    // Alias: VK_STRUCTURE_TYPE_SURFACE_PRESENT_SCALING_CAPABILITIES_EXT
    VK_STRUCTURE_TYPE_SURFACE_PRESENT_SCALING_CAPABILITIES_KHR = 1000274001,
    // Extension: VK_KHR_surface_maintenance1
    // Alias: VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_COMPATIBILITY_EXT
    VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_COMPATIBILITY_KHR = 1000274002,
    // Extension: VK_KHR_swapchain_maintenance1
    // Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_EXT
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_KHR = 1000275000,
    // Extension: VK_KHR_swapchain_maintenance1
    // Alias: VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_EXT
    VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_KHR = 1000275001,
    // Extension: VK_KHR_swapchain_maintenance1
    // Alias: VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODES_CREATE_INFO_EXT
    VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODES_CREATE_INFO_KHR = 1000275002,
    // Extension: VK_KHR_swapchain_maintenance1
    // Alias: VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODE_INFO_EXT
    VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODE_INFO_KHR = 1000275003,
    // Extension: VK_KHR_swapchain_maintenance1
    // Alias: VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_SCALING_CREATE_INFO_EXT
    VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_SCALING_CREATE_INFO_KHR = 1000275004,
    // Extension: VK_KHR_swapchain_maintenance1
    // Alias: VK_STRUCTURE_TYPE_RELEASE_SWAPCHAIN_IMAGES_INFO_EXT
    VK_STRUCTURE_TYPE_RELEASE_SWAPCHAIN_IMAGES_INFO_KHR = 1000275005,
    // Extension: VK_COMPUTE_VERSION_1_3
    // Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES_EXT
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES = 1000276000,
    // Extension: VK_NV_device_generated_commands
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV = 1000277000,
    // Extension: VK_NV_device_generated_commands
    VK_STRUCTURE_TYPE_GRAPHICS_SHADER_GROUP_CREATE_INFO_NV = 1000277001,
    // Extension: VK_NV_device_generated_commands
    VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV = 1000277002,
    // Extension: VK_NV_device_generated_commands
    VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_NV = 1000277003,
    // Extension: VK_NV_device_generated_commands
    VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NV = 1000277004,
    // Extension: VK_NV_device_generated_commands
    VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_NV = 1000277005,
    // Extension: VK_NV_device_generated_commands
    VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_NV = 1000277006,
    // Extension: VK_NV_device_generated_commands
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV = 1000277007,
    // Extension: VK_NV_inherited_viewport_scissor
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV = 1000278000,
    // Extension: VK_NV_inherited_viewport_scissor
    VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_VIEWPORT_SCISSOR_INFO_NV = 1000278001,
    // Extension: VK_COMPUTE_VERSION_1_3
    // Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES_KHR
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES = 1000280000,
    // Extension: VK_COMPUTE_VERSION_1_3
    // Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES_KHR
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES = 1000280001,
    // Extension: VK_EXT_texel_buffer_alignment
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT = 1000281000,
    // Extension: VK_COMPUTE_VERSION_1_3
    // Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES_EXT
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES = 1000281001,
    // Extension: VK_QCOM_render_pass_transform
    VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM = 1000282000,
    // Extension: VK_QCOM_render_pass_transform
    VK_STRUCTURE_TYPE_RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM = 1000282001,
    // Extension: VK_EXT_depth_bias_control
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_BIAS_CONTROL_FEATURES_EXT = 1000283000,
    // Extension: VK_EXT_depth_bias_control
    VK_STRUCTURE_TYPE_DEPTH_BIAS_INFO_EXT = 1000283001,
    // Extension: VK_EXT_depth_bias_control
    VK_STRUCTURE_TYPE_DEPTH_BIAS_REPRESENTATION_INFO_EXT = 1000283002,
    // Extension: VK_EXT_device_memory_report
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT = 1000284000,
    // Extension: VK_EXT_device_memory_report
    VK_STRUCTURE_TYPE_DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT = 1000284001,
    // Extension: VK_EXT_device_memory_report
    VK_STRUCTURE_TYPE_DEVICE_MEMORY_REPORT_CALLBACK_DATA_EXT = 1000284002,
    // Extension: VK_KHR_robustness2
    // Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_KHR = 1000286000,
    // Extension: VK_KHR_robustness2
    // Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_EXT
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_KHR = 1000286001,
    // Extension: VK_EXT_custom_border_color
    VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT = 1000287000,
    // Extension: VK_EXT_custom_border_color
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT = 1000287001,
    // Extension: VK_EXT_custom_border_color
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT = 1000287002,
    // Extension: VK_KHR_pipeline_library
    VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR = 1000290000,
    // Extension: VK_NV_present_barrier
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_BARRIER_FEATURES_NV = 1000292000,
    // Extension: VK_NV_present_barrier
    VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_BARRIER_NV = 1000292001,
    // Extension: VK_NV_present_barrier
    VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_BARRIER_CREATE_INFO_NV = 1000292002,
    // Extension: VK_KHR_present_id
    VK_STRUCTURE_TYPE_PRESENT_ID_KHR = 1000294000,
    // Extension: VK_KHR_present_id
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR = 1000294001,
    // Extension: VK_BASE_VERSION_1_3
    // Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES_EXT
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES = 1000295000,
    // Extension: VK_BASE_VERSION_1_3
    // Alias: VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO_EXT
    VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO = 1000295001,
    // Extension: VK_BASE_VERSION_1_3
    // Alias: VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO_EXT
    VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO = 1000295002,
    // Extension: VK_COMPUTE_VERSION_1_3
    // Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES_EXT
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES = 1000297000,
    // Extension: VKSC_VERSION_1_0
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_SC_1_0_FEATURES = 1000298000,
    // Extension: VKSC_VERSION_1_0
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_SC_1_0_PROPERTIES = 1000298001,
    // Extension: VKSC_VERSION_1_0
    VK_STRUCTURE_TYPE_DEVICE_OBJECT_RESERVATION_CREATE_INFO = 1000298002,
    // Extension: VKSC_VERSION_1_0
    VK_STRUCTURE_TYPE_COMMAND_POOL_MEMORY_RESERVATION_CREATE_INFO = 1000298003,
    // Extension: VKSC_VERSION_1_0
    VK_STRUCTURE_TYPE_COMMAND_POOL_MEMORY_CONSUMPTION = 1000298004,
    // Extension: VKSC_VERSION_1_0
    VK_STRUCTURE_TYPE_PIPELINE_POOL_SIZE = 1000298005,
    // Extension: VKSC_VERSION_1_0
    VK_STRUCTURE_TYPE_FAULT_DATA = 1000298007,
    // Extension: VKSC_VERSION_1_0
    VK_STRUCTURE_TYPE_FAULT_CALLBACK_INFO = 1000298008,
    // Extension: VKSC_VERSION_1_0
    VK_STRUCTURE_TYPE_PIPELINE_OFFLINE_CREATE_INFO = 1000298010,
    // Extension: VK_KHR_video_encode_queue
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_INFO_KHR = 1000299000,
    // Extension: VK_KHR_video_encode_queue
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_INFO_KHR = 1000299001,
    // Extension: VK_KHR_video_encode_queue
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_LAYER_INFO_KHR = 1000299002,
    // Extension: VK_KHR_video_encode_queue
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_CAPABILITIES_KHR = 1000299003,
    // Extension: VK_KHR_video_encode_queue
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_USAGE_INFO_KHR = 1000299004,
    // Extension: VK_KHR_video_encode_queue
    VK_STRUCTURE_TYPE_QUERY_POOL_VIDEO_ENCODE_FEEDBACK_CREATE_INFO_KHR = 1000299005,
    // Extension: VK_KHR_video_encode_queue
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR = 1000299006,
    // Extension: VK_KHR_video_encode_queue
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_PROPERTIES_KHR = 1000299007,
    // Extension: VK_KHR_video_encode_queue
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR = 1000299008,
    // Extension: VK_KHR_video_encode_queue
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_GET_INFO_KHR = 1000299009,
    // Extension: VK_KHR_video_encode_queue
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_FEEDBACK_INFO_KHR = 1000299010,
    // Extension: VK_NV_device_diagnostics_config
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV = 1000300000,
    // Extension: VK_NV_device_diagnostics_config
    VK_STRUCTURE_TYPE_DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV = 1000300001,
    // Extension: VK_NV_cuda_kernel_launch
    VK_STRUCTURE_TYPE_CUDA_MODULE_CREATE_INFO_NV = 1000307000,
    // Extension: VK_NV_cuda_kernel_launch
    VK_STRUCTURE_TYPE_CUDA_FUNCTION_CREATE_INFO_NV = 1000307001,
    // Extension: VK_NV_cuda_kernel_launch
    VK_STRUCTURE_TYPE_CUDA_LAUNCH_INFO_NV = 1000307002,
    // Extension: VK_NV_cuda_kernel_launch
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUDA_KERNEL_LAUNCH_FEATURES_NV = 1000307003,
    // Extension: VK_NV_cuda_kernel_launch
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUDA_KERNEL_LAUNCH_PROPERTIES_NV = 1000307004,
    // Extension: VK_KHR_object_refresh
    VK_STRUCTURE_TYPE_REFRESH_OBJECT_LIST_KHR = 1000308000,
    // Extension: VK_QCOM_tile_shading
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_SHADING_FEATURES_QCOM = 1000309000,
    // Extension: VK_QCOM_tile_shading
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_SHADING_PROPERTIES_QCOM = 1000309001,
    // Extension: VK_QCOM_tile_shading
    VK_STRUCTURE_TYPE_RENDER_PASS_TILE_SHADING_CREATE_INFO_QCOM = 1000309002,
    // Extension: VK_QCOM_tile_shading
    VK_STRUCTURE_TYPE_PER_TILE_BEGIN_INFO_QCOM = 1000309003,
    // Extension: VK_QCOM_tile_shading
    VK_STRUCTURE_TYPE_PER_TILE_END_INFO_QCOM = 1000309004,
    // Extension: VK_QCOM_tile_shading
    VK_STRUCTURE_TYPE_DISPATCH_TILE_INFO_QCOM = 1000309005,
    // Extension: VK_NV_low_latency
    VK_STRUCTURE_TYPE_QUERY_LOW_LATENCY_SUPPORT_NV = 1000310000,
    // Extension: VK_EXT_metal_objects
    VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT = 1000311000,
    // Extension: VK_EXT_metal_objects
    VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECTS_INFO_EXT = 1000311001,
    // Extension: VK_EXT_metal_objects
    VK_STRUCTURE_TYPE_EXPORT_METAL_DEVICE_INFO_EXT = 1000311002,
    // Extension: VK_EXT_metal_objects
    VK_STRUCTURE_TYPE_EXPORT_METAL_COMMAND_QUEUE_INFO_EXT = 1000311003,
    // Extension: VK_EXT_metal_objects
    VK_STRUCTURE_TYPE_EXPORT_METAL_BUFFER_INFO_EXT = 1000311004,
    // Extension: VK_EXT_metal_objects
    VK_STRUCTURE_TYPE_IMPORT_METAL_BUFFER_INFO_EXT = 1000311005,
    // Extension: VK_EXT_metal_objects
    VK_STRUCTURE_TYPE_EXPORT_METAL_TEXTURE_INFO_EXT = 1000311006,
    // Extension: VK_EXT_metal_objects
    VK_STRUCTURE_TYPE_IMPORT_METAL_TEXTURE_INFO_EXT = 1000311007,
    // Extension: VK_EXT_metal_objects
    VK_STRUCTURE_TYPE_EXPORT_METAL_IO_SURFACE_INFO_EXT = 1000311008,
    // Extension: VK_EXT_metal_objects
    VK_STRUCTURE_TYPE_IMPORT_METAL_IO_SURFACE_INFO_EXT = 1000311009,
    // Extension: VK_EXT_metal_objects
    VK_STRUCTURE_TYPE_EXPORT_METAL_SHARED_EVENT_INFO_EXT = 1000311010,
    // Extension: VK_EXT_metal_objects
    VK_STRUCTURE_TYPE_IMPORT_METAL_SHARED_EVENT_INFO_EXT = 1000311011,
    // Extension: VK_BASE_VERSION_1_3
    // Alias: VK_STRUCTURE_TYPE_MEMORY_BARRIER_2_KHR
    VK_STRUCTURE_TYPE_MEMORY_BARRIER_2 = 1000314000,
    // Extension: VK_BASE_VERSION_1_3
    // Alias: VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2_KHR
    VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2 = 1000314001,
    // Extension: VK_BASE_VERSION_1_3
    // Alias: VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2_KHR
    VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2 = 1000314002,
    // Extension: VK_BASE_VERSION_1_3
    // Alias: VK_STRUCTURE_TYPE_DEPENDENCY_INFO_KHR
    VK_STRUCTURE_TYPE_DEPENDENCY_INFO = 1000314003,
    // Extension: VK_BASE_VERSION_1_3
    // Alias: VK_STRUCTURE_TYPE_SUBMIT_INFO_2_KHR
    VK_STRUCTURE_TYPE_SUBMIT_INFO_2 = 1000314004,
    // Extension: VK_BASE_VERSION_1_3
    // Alias: VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO_KHR
    VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO = 1000314005,
    // Extension: VK_BASE_VERSION_1_3
    // Alias: VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO_KHR
    VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO = 1000314006,
    // Extension: VK_BASE_VERSION_1_3
    // Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES_KHR
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES = 1000314007,
    // Extension: VK_NV_device_diagnostic_checkpoints
    VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV = 1000314008,
    // Extension: VK_NV_device_diagnostic_checkpoints
    VK_STRUCTURE_TYPE_CHECKPOINT_DATA_2_NV = 1000314009,
    // Extension: VK_EXT_descriptor_buffer
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_PROPERTIES_EXT = 1000316000,
    // Extension: VK_EXT_descriptor_buffer
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_DENSITY_MAP_PROPERTIES_EXT = 1000316001,
    // Extension: VK_EXT_descriptor_buffer
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_FEATURES_EXT = 1000316002,
    // Extension: VK_EXT_descriptor_buffer
    VK_STRUCTURE_TYPE_DESCRIPTOR_ADDRESS_INFO_EXT = 1000316003,
    // Extension: VK_EXT_descriptor_buffer
    VK_STRUCTURE_TYPE_DESCRIPTOR_GET_INFO_EXT = 1000316004,
    // Extension: VK_EXT_descriptor_buffer
    VK_STRUCTURE_TYPE_BUFFER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT = 1000316005,
    // Extension: VK_EXT_descriptor_buffer
    VK_STRUCTURE_TYPE_IMAGE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT = 1000316006,
    // Extension: VK_EXT_descriptor_buffer
    VK_STRUCTURE_TYPE_IMAGE_VIEW_CAPTURE_DESCRIPTOR_DATA_INFO_EXT = 1000316007,
    // Extension: VK_EXT_descriptor_buffer
    VK_STRUCTURE_TYPE_SAMPLER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT = 1000316008,
    // Extension: VK_EXT_descriptor_buffer
    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT = 1000316009,
    // Extension: VK_EXT_descriptor_buffer
    VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT = 1000316010,
    // Extension: VK_EXT_descriptor_buffer
    VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_INFO_EXT = 1000316011,
    // Extension: VK_EXT_descriptor_buffer
    VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_PUSH_DESCRIPTOR_BUFFER_HANDLE_EXT = 1000316012,
    // Extension: VK_EXT_graphics_pipeline_library
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT = 1000320000,
    // Extension: VK_EXT_graphics_pipeline_library
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_PROPERTIES_EXT = 1000320001,
    // Extension: VK_EXT_graphics_pipeline_library
    VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_LIBRARY_CREATE_INFO_EXT = 1000320002,
    // Extension: VK_AMD_shader_early_and_late_fragment_tests
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_FEATURES_AMD = 1000321000,
    // Extension: VK_KHR_fragment_shader_barycentric
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_PROPERTIES_KHR = 1000322000,
    // Extension: VK_KHR_shader_subgroup_uniform_control_flow
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR = 1000323000,
    // Extension: VK_COMPUTE_VERSION_1_3
    // Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES_KHR
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES = 1000325000,
    // Extension: VK_NV_fragment_shading_rate_enums
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV = 1000326000,
    // Extension: VK_NV_fragment_shading_rate_enums
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV = 1000326001,
    // Extension: VK_NV_fragment_shading_rate_enums
    VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV = 1000326002,
    // Extension: VK_NV_ray_tracing_motion_blur
    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_MOTION_TRIANGLES_DATA_NV = 1000327000,
    // Extension: VK_NV_ray_tracing_motion_blur
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV = 1000327001,
    // Extension: VK_NV_ray_tracing_motion_blur
    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MOTION_INFO_NV = 1000327002,
    // Extension: VK_EXT_mesh_shader
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT = 1000328000,
    // Extension: VK_EXT_mesh_shader
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_EXT = 1000328001,
    // Extension: VK_EXT_ycbcr_2plane_444_formats
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT = 1000330000,
    // Extension: VK_EXT_fragment_density_map2
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT = 1000332000,
    // Extension: VK_EXT_fragment_density_map2
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT = 1000332001,
    // Extension: VK_QCOM_rotated_copy_commands
    VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM = 1000333000,
    // Extension: VK_COMPUTE_VERSION_1_3
    // Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES_EXT
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES = 1000335000,
    // Extension: VK_KHR_workgroup_memory_explicit_layout
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR = 1000336000,
    // Extension: VK_BASE_VERSION_1_3
    // Alias: VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2_KHR
    VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2 = 1000337000,
    // Extension: VK_BASE_VERSION_1_3
    // Alias: VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2_KHR
    VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2 = 1000337001,
    // Extension: VK_BASE_VERSION_1_3
    // Alias: VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2_KHR
    VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2 = 1000337002,
    // Extension: VK_BASE_VERSION_1_3
    // Alias: VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2_KHR
    VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2 = 1000337003,
    // Extension: VK_GRAPHICS_VERSION_1_3
    // Alias: VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2_KHR
    VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2 = 1000337004,
    // Extension: VK_GRAPHICS_VERSION_1_3
    // Alias: VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2_KHR
    VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2 = 1000337005,
    // Extension: VK_BASE_VERSION_1_3
    // Alias: VK_STRUCTURE_TYPE_BUFFER_COPY_2_KHR
    VK_STRUCTURE_TYPE_BUFFER_COPY_2 = 1000337006,
    // Extension: VK_BASE_VERSION_1_3
    // Alias: VK_STRUCTURE_TYPE_IMAGE_COPY_2_KHR
    VK_STRUCTURE_TYPE_IMAGE_COPY_2 = 1000337007,
    // Extension: VK_GRAPHICS_VERSION_1_3
    // Alias: VK_STRUCTURE_TYPE_IMAGE_BLIT_2_KHR
    VK_STRUCTURE_TYPE_IMAGE_BLIT_2 = 1000337008,
    // Extension: VK_BASE_VERSION_1_3
    // Alias: VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2_KHR
    VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2 = 1000337009,
    // Extension: VK_GRAPHICS_VERSION_1_3
    // Alias: VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2_KHR
    VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2 = 1000337010,
    // Extension: VK_EXT_image_compression_control
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT = 1000338000,
    // Extension: VK_EXT_image_compression_control
    VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT = 1000338001,
    // Extension: VK_BASE_VERSION_1_4
    // Alias: VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2_EXT
    // Alias: VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2_KHR
    VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2 = 1000338002,
    // Extension: VK_BASE_VERSION_1_4
    // Alias: VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2_EXT
    // Alias: VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2_KHR
    VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2 = 1000338003,
    // Extension: VK_EXT_image_compression_control
    VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT = 1000338004,
    // Extension: VK_EXT_attachment_feedback_loop_layout
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT = 1000339000,
    // Extension: VK_EXT_4444_formats
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT = 1000340000,
    // Extension: VK_EXT_device_fault
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FAULT_FEATURES_EXT = 1000341000,
    // Extension: VK_EXT_device_fault
    VK_STRUCTURE_TYPE_DEVICE_FAULT_COUNTS_EXT = 1000341001,
    // Extension: VK_EXT_device_fault
    VK_STRUCTURE_TYPE_DEVICE_FAULT_INFO_EXT = 1000341002,
    // Extension: VK_EXT_rasterization_order_attachment_access
    // Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_ARM
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT = 1000342000,
    // Extension: VK_EXT_rgba10x6_formats
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT = 1000344000,
    // Extension: VK_EXT_directfb_surface
    VK_STRUCTURE_TYPE_DIRECTFB_SURFACE_CREATE_INFO_EXT = 1000346000,
    // Extension: VK_KHR_ray_tracing_pipeline
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR = 1000347000,
    // Extension: VK_KHR_ray_tracing_pipeline
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR = 1000347001,
    // Extension: VK_KHR_ray_query
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR = 1000348013,
    // Extension: VK_EXT_mutable_descriptor_type
    // Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_VALVE
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT = 1000351000,
    // Extension: VK_EXT_mutable_descriptor_type
    // Alias: VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_VALVE
    VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT = 1000351002,
    // Extension: VK_EXT_vertex_input_dynamic_state
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT = 1000352000,
    // Extension: VK_EXT_shader_object
    // Extension: VK_EXT_vertex_input_dynamic_state
    VK_STRUCTURE_TYPE_VERTEX_INPUT_BINDING_DESCRIPTION_2_EXT = 1000352001,
    // Extension: VK_EXT_shader_object
    // Extension: VK_EXT_vertex_input_dynamic_state
    VK_STRUCTURE_TYPE_VERTEX_INPUT_ATTRIBUTE_DESCRIPTION_2_EXT = 1000352002,
    // Extension: VK_EXT_physical_device_drm
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRM_PROPERTIES_EXT = 1000353000,
    // Extension: VK_EXT_device_address_binding_report
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ADDRESS_BINDING_REPORT_FEATURES_EXT = 1000354000,
    // Extension: VK_EXT_device_address_binding_report
    VK_STRUCTURE_TYPE_DEVICE_ADDRESS_BINDING_CALLBACK_DATA_EXT = 1000354001,
    // Extension: VK_EXT_depth_clip_control
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT = 1000355000,
    // Extension: VK_EXT_depth_clip_control
    VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLIP_CONTROL_CREATE_INFO_EXT = 1000355001,
    // Extension: VK_EXT_primitive_topology_list_restart
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT = 1000356000,
    // Extension: VK_BASE_VERSION_1_3
    // Alias: VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3_KHR
    VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3 = 1000360000,
    // Extension: VK_KHR_present_mode_fifo_latest_ready
    // Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_MODE_FIFO_LATEST_READY_FEATURES_EXT
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_MODE_FIFO_LATEST_READY_FEATURES_KHR = 1000361000,
    // Extension: VK_FUCHSIA_external_memory
    VK_STRUCTURE_TYPE_IMPORT_MEMORY_ZIRCON_HANDLE_INFO_FUCHSIA = 1000364000,
    // Extension: VK_FUCHSIA_external_memory
    VK_STRUCTURE_TYPE_MEMORY_ZIRCON_HANDLE_PROPERTIES_FUCHSIA = 1000364001,
    // Extension: VK_FUCHSIA_external_memory
    VK_STRUCTURE_TYPE_MEMORY_GET_ZIRCON_HANDLE_INFO_FUCHSIA = 1000364002,
    // Extension: VK_FUCHSIA_external_semaphore
    VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_ZIRCON_HANDLE_INFO_FUCHSIA = 1000365000,
    // Extension: VK_FUCHSIA_external_semaphore
    VK_STRUCTURE_TYPE_SEMAPHORE_GET_ZIRCON_HANDLE_INFO_FUCHSIA = 1000365001,
    // Extension: VK_FUCHSIA_buffer_collection
    VK_STRUCTURE_TYPE_BUFFER_COLLECTION_CREATE_INFO_FUCHSIA = 1000366000,
    // Extension: VK_FUCHSIA_buffer_collection
    VK_STRUCTURE_TYPE_IMPORT_MEMORY_BUFFER_COLLECTION_FUCHSIA = 1000366001,
    // Extension: VK_FUCHSIA_buffer_collection
    VK_STRUCTURE_TYPE_BUFFER_COLLECTION_IMAGE_CREATE_INFO_FUCHSIA = 1000366002,
    // Extension: VK_FUCHSIA_buffer_collection
    VK_STRUCTURE_TYPE_BUFFER_COLLECTION_PROPERTIES_FUCHSIA = 1000366003,
    // Extension: VK_FUCHSIA_buffer_collection
    VK_STRUCTURE_TYPE_BUFFER_CONSTRAINTS_INFO_FUCHSIA = 1000366004,
    // Extension: VK_FUCHSIA_buffer_collection
    VK_STRUCTURE_TYPE_BUFFER_COLLECTION_BUFFER_CREATE_INFO_FUCHSIA = 1000366005,
    // Extension: VK_FUCHSIA_buffer_collection
    VK_STRUCTURE_TYPE_IMAGE_CONSTRAINTS_INFO_FUCHSIA = 1000366006,
    // Extension: VK_FUCHSIA_buffer_collection
    VK_STRUCTURE_TYPE_IMAGE_FORMAT_CONSTRAINTS_INFO_FUCHSIA = 1000366007,
    // Extension: VK_FUCHSIA_buffer_collection
    VK_STRUCTURE_TYPE_SYSMEM_COLOR_SPACE_FUCHSIA = 1000366008,
    // Extension: VK_FUCHSIA_buffer_collection
    VK_STRUCTURE_TYPE_BUFFER_COLLECTION_CONSTRAINTS_INFO_FUCHSIA = 1000366009,
    // Extension: VK_HUAWEI_subpass_shading
    VK_STRUCTURE_TYPE_SUBPASS_SHADING_PIPELINE_CREATE_INFO_HUAWEI = 1000369000,
    // Extension: VK_HUAWEI_subpass_shading
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI = 1000369001,
    // Extension: VK_HUAWEI_subpass_shading
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_PROPERTIES_HUAWEI = 1000369002,
    // Extension: VK_HUAWEI_invocation_mask
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI = 1000370000,
    // Extension: VK_NV_external_memory_rdma
    VK_STRUCTURE_TYPE_MEMORY_GET_REMOTE_ADDRESS_INFO_NV = 1000371000,
    // Extension: VK_NV_external_memory_rdma
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_RDMA_FEATURES_NV = 1000371001,
    // Extension: VK_EXT_pipeline_properties
    VK_STRUCTURE_TYPE_PIPELINE_PROPERTIES_IDENTIFIER_EXT = 1000372000,
    // Extension: VK_EXT_pipeline_properties
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROPERTIES_FEATURES_EXT = 1000372001,
    // Extension: VK_NV_external_sci_sync2
    // Extension: VK_NV_external_sci_sync
    VK_STRUCTURE_TYPE_IMPORT_FENCE_SCI_SYNC_INFO_NV = 1000373000,
    // Extension: VK_NV_external_sci_sync2
    // Extension: VK_NV_external_sci_sync
    VK_STRUCTURE_TYPE_EXPORT_FENCE_SCI_SYNC_INFO_NV = 1000373001,
    // Extension: VK_NV_external_sci_sync2
    // Extension: VK_NV_external_sci_sync
    VK_STRUCTURE_TYPE_FENCE_GET_SCI_SYNC_INFO_NV = 1000373002,
    // Extension: VK_NV_external_sci_sync2
    // Extension: VK_NV_external_sci_sync
    VK_STRUCTURE_TYPE_SCI_SYNC_ATTRIBUTES_INFO_NV = 1000373003,
    // Extension: VK_NV_external_sci_sync
    VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_SCI_SYNC_INFO_NV = 1000373004,
    // Extension: VK_NV_external_sci_sync
    VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_SCI_SYNC_INFO_NV = 1000373005,
    // Extension: VK_NV_external_sci_sync
    VK_STRUCTURE_TYPE_SEMAPHORE_GET_SCI_SYNC_INFO_NV = 1000373006,
    // Extension: VK_NV_external_sci_sync
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SCI_SYNC_FEATURES_NV = 1000373007,
    // Extension: VK_NV_external_memory_sci_buf
    VK_STRUCTURE_TYPE_IMPORT_MEMORY_SCI_BUF_INFO_NV = 1000374000,
    // Extension: VK_NV_external_memory_sci_buf
    VK_STRUCTURE_TYPE_EXPORT_MEMORY_SCI_BUF_INFO_NV = 1000374001,
    // Extension: VK_NV_external_memory_sci_buf
    VK_STRUCTURE_TYPE_MEMORY_GET_SCI_BUF_INFO_NV = 1000374002,
    // Extension: VK_NV_external_memory_sci_buf
    VK_STRUCTURE_TYPE_MEMORY_SCI_BUF_PROPERTIES_NV = 1000374003,
    // Extension: VK_NV_external_memory_sci_buf
    // Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SCI_BUF_FEATURES_NV
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_SCI_BUF_FEATURES_NV = 1000374004,
    // Extension: VK_EXT_frame_boundary
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAME_BOUNDARY_FEATURES_EXT = 1000375000,
    // Extension: VK_EXT_frame_boundary
    VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT = 1000375001,
    // Extension: VK_EXT_multisampled_render_to_single_sampled
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT = 1000376000,
    // Extension: VK_EXT_multisampled_render_to_single_sampled
    VK_STRUCTURE_TYPE_SUBPASS_RESOLVE_PERFORMANCE_QUERY_EXT = 1000376001,
    // Extension: VK_EXT_multisampled_render_to_single_sampled
    VK_STRUCTURE_TYPE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_INFO_EXT = 1000376002,
    // Extension: VK_EXT_extended_dynamic_state2
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT = 1000377000,
    // Extension: VK_QNX_screen_surface
    VK_STRUCTURE_TYPE_SCREEN_SURFACE_CREATE_INFO_QNX = 1000378000,
    // Extension: VK_EXT_color_write_enable
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT = 1000381000,
    // Extension: VK_EXT_color_write_enable
    VK_STRUCTURE_TYPE_PIPELINE_COLOR_WRITE_CREATE_INFO_EXT = 1000381001,
    // Extension: VK_EXT_primitives_generated_query
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT = 1000382000,
    // Extension: VK_KHR_ray_tracing_maintenance1
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR = 1000386000,
    // Extension: VK_KHR_shader_untyped_pointers
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_UNTYPED_POINTERS_FEATURES_KHR = 1000387000,
    // Extension: VK_BASE_VERSION_1_4
    // Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_KHR
    // Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_EXT
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES = 1000388000,
    // Extension: VK_BASE_VERSION_1_4
    // Alias: VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_KHR
    // Alias: VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_EXT
    VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES = 1000388001,
    // Extension: VK_VALVE_video_encode_rgb_conversion
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_RGB_CONVERSION_FEATURES_VALVE = 1000390000,
    // Extension: VK_VALVE_video_encode_rgb_conversion
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_RGB_CONVERSION_CAPABILITIES_VALVE = 1000390001,
    // Extension: VK_VALVE_video_encode_rgb_conversion
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_PROFILE_RGB_CONVERSION_INFO_VALVE = 1000390002,
    // Extension: VK_VALVE_video_encode_rgb_conversion
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_RGB_CONVERSION_CREATE_INFO_VALVE = 1000390003,
    // Extension: VK_EXT_image_view_min_lod
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT = 1000391000,
    // Extension: VK_EXT_image_view_min_lod
    VK_STRUCTURE_TYPE_IMAGE_VIEW_MIN_LOD_CREATE_INFO_EXT = 1000391001,
    // Extension: VK_EXT_multi_draw
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT = 1000392000,
    // Extension: VK_EXT_multi_draw
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT = 1000392001,
    // Extension: VK_EXT_image_2d_view_of_3d
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT = 1000393000,
    // Extension: VK_EXT_shader_tile_image
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_FEATURES_EXT = 1000395000,
    // Extension: VK_EXT_shader_tile_image
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_PROPERTIES_EXT = 1000395001,
    // Extension: VK_EXT_opacity_micromap
    VK_STRUCTURE_TYPE_MICROMAP_BUILD_INFO_EXT = 1000396000,
    // Extension: VK_EXT_opacity_micromap
    VK_STRUCTURE_TYPE_MICROMAP_VERSION_INFO_EXT = 1000396001,
    // Extension: VK_EXT_opacity_micromap
    VK_STRUCTURE_TYPE_COPY_MICROMAP_INFO_EXT = 1000396002,
    // Extension: VK_EXT_opacity_micromap
    VK_STRUCTURE_TYPE_COPY_MICROMAP_TO_MEMORY_INFO_EXT = 1000396003,
    // Extension: VK_EXT_opacity_micromap
    VK_STRUCTURE_TYPE_COPY_MEMORY_TO_MICROMAP_INFO_EXT = 1000396004,
    // Extension: VK_EXT_opacity_micromap
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_FEATURES_EXT = 1000396005,
    // Extension: VK_EXT_opacity_micromap
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_PROPERTIES_EXT = 1000396006,
    // Extension: VK_EXT_opacity_micromap
    VK_STRUCTURE_TYPE_MICROMAP_CREATE_INFO_EXT = 1000396007,
    // Extension: VK_EXT_opacity_micromap
    VK_STRUCTURE_TYPE_MICROMAP_BUILD_SIZES_INFO_EXT = 1000396008,
    // Extension: VK_EXT_opacity_micromap
    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_OPACITY_MICROMAP_EXT = 1000396009,
    // Extension: VK_NV_displacement_micromap
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISPLACEMENT_MICROMAP_FEATURES_NV = 1000397000,
    // Extension: VK_NV_displacement_micromap
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISPLACEMENT_MICROMAP_PROPERTIES_NV = 1000397001,
    // Extension: VK_NV_displacement_micromap
    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_DISPLACEMENT_MICROMAP_NV = 1000397002,
    // Extension: VK_HUAWEI_cluster_culling_shader
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_FEATURES_HUAWEI = 1000404000,
    // Extension: VK_HUAWEI_cluster_culling_shader
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_PROPERTIES_HUAWEI = 1000404001,
    // Extension: VK_HUAWEI_cluster_culling_shader
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_VRS_FEATURES_HUAWEI = 1000404002,
    // Extension: VK_EXT_border_color_swizzle
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT = 1000411000,
    // Extension: VK_EXT_border_color_swizzle
    VK_STRUCTURE_TYPE_SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT = 1000411001,
    // Extension: VK_EXT_pageable_device_local_memory
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT = 1000412000,
    // Extension: VK_BASE_VERSION_1_3
    // Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES_KHR
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES = 1000413000,
    // Extension: VK_BASE_VERSION_1_3
    // Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES_KHR
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES = 1000413001,
    // Extension: VK_BASE_VERSION_1_3
    // Alias: VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS_KHR
    VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS = 1000413002,
    // Extension: VK_BASE_VERSION_1_3
    // Alias: VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS_KHR
    VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS = 1000413003,
    // Extension: VK_ARM_shader_core_properties
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_ARM = 1000415000,
    // Extension: VK_COMPUTE_VERSION_1_4
    // Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_ROTATE_FEATURES_KHR
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_ROTATE_FEATURES = 1000416000,
    // Extension: VK_ARM_scheduling_controls
    VK_STRUCTURE_TYPE_DEVICE_QUEUE_SHADER_CORE_CONTROL_CREATE_INFO_ARM = 1000417000,
    // Extension: VK_ARM_scheduling_controls
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_FEATURES_ARM = 1000417001,
    // Extension: VK_ARM_scheduling_controls
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_PROPERTIES_ARM = 1000417002,
    // Extension: VK_EXT_image_sliced_view_of_3d
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_SLICED_VIEW_OF_3D_FEATURES_EXT = 1000418000,
    // Extension: VK_EXT_image_sliced_view_of_3d
    VK_STRUCTURE_TYPE_IMAGE_VIEW_SLICED_CREATE_INFO_EXT = 1000418001,
    // Extension: VK_VALVE_descriptor_set_host_mapping
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE = 1000420000,
    // Extension: VK_VALVE_descriptor_set_host_mapping
    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_BINDING_REFERENCE_VALVE = 1000420001,
    // Extension: VK_VALVE_descriptor_set_host_mapping
    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_HOST_MAPPING_INFO_VALVE = 1000420002,
    // Extension: VK_KHR_depth_clamp_zero_one
    // Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_EXT
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_KHR = 1000421000,
    // Extension: VK_EXT_non_seamless_cube_map
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT = 1000422000,
    // Extension: VK_ARM_render_pass_striped
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_FEATURES_ARM = 1000424000,
    // Extension: VK_ARM_render_pass_striped
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_PROPERTIES_ARM = 1000424001,
    // Extension: VK_ARM_render_pass_striped
    VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_BEGIN_INFO_ARM = 1000424002,
    // Extension: VK_ARM_render_pass_striped
    VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_INFO_ARM = 1000424003,
    // Extension: VK_ARM_render_pass_striped
    VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_SUBMIT_INFO_ARM = 1000424004,
    // Extension: VK_EXT_fragment_density_map_offset
    // Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_QCOM
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_EXT = 1000425000,
    // Extension: VK_EXT_fragment_density_map_offset
    // Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_QCOM
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_EXT = 1000425001,
    // Extension: VK_EXT_fragment_density_map_offset
    // Alias: VK_STRUCTURE_TYPE_SUBPASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_QCOM
    VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_EXT = 1000425002,
    // Extension: VK_NV_copy_memory_indirect
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_FEATURES_NV = 1000426000,
    // Extension: VK_KHR_copy_memory_indirect
    // Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_PROPERTIES_NV
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_PROPERTIES_KHR = 1000426001,
    // Extension: VK_EXT_memory_decompression
    // Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_FEATURES_NV
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_FEATURES_EXT = 1000427000,
    // Extension: VK_EXT_memory_decompression
    // Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_PROPERTIES_NV
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_PROPERTIES_EXT = 1000427001,
    // Extension: VK_NV_device_generated_commands_compute
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_COMPUTE_FEATURES_NV = 1000428000,
    // Extension: VK_NV_device_generated_commands_compute
    VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_INDIRECT_BUFFER_INFO_NV = 1000428001,
    // Extension: VK_NV_device_generated_commands_compute
    VK_STRUCTURE_TYPE_PIPELINE_INDIRECT_DEVICE_ADDRESS_INFO_NV = 1000428002,
    // Extension: VK_NV_ray_tracing_linear_swept_spheres
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_LINEAR_SWEPT_SPHERES_FEATURES_NV = 1000429008,
    // Extension: VK_NV_ray_tracing_linear_swept_spheres
    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_LINEAR_SWEPT_SPHERES_DATA_NV = 1000429009,
    // Extension: VK_NV_ray_tracing_linear_swept_spheres
    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_SPHERES_DATA_NV = 1000429010,
    // Extension: VK_NV_linear_color_attachment
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINEAR_COLOR_ATTACHMENT_FEATURES_NV = 1000430000,
    // Extension: VK_KHR_shader_maximal_reconvergence
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MAXIMAL_RECONVERGENCE_FEATURES_KHR = 1000434000,
    // Extension: VK_EXT_application_parameters
    VK_STRUCTURE_TYPE_APPLICATION_PARAMETERS_EXT = 1000435000,
    // Extension: VK_EXT_image_compression_control_swapchain
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT = 1000437000,
    // Extension: VK_QCOM_image_processing
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_FEATURES_QCOM = 1000440000,
    // Extension: VK_QCOM_image_processing
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_PROPERTIES_QCOM = 1000440001,
    // Extension: VK_QCOM_image_processing
    VK_STRUCTURE_TYPE_IMAGE_VIEW_SAMPLE_WEIGHT_CREATE_INFO_QCOM = 1000440002,
    // Extension: VK_EXT_nested_command_buffer
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_FEATURES_EXT = 1000451000,
    // Extension: VK_EXT_nested_command_buffer
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_PROPERTIES_EXT = 1000451001,
    // Extension: VK_OHOS_external_memory
    VK_STRUCTURE_TYPE_NATIVE_BUFFER_USAGE_OHOS = 1000452000,
    // Extension: VK_OHOS_external_memory
    VK_STRUCTURE_TYPE_NATIVE_BUFFER_PROPERTIES_OHOS = 1000452001,
    // Extension: VK_OHOS_external_memory
    VK_STRUCTURE_TYPE_NATIVE_BUFFER_FORMAT_PROPERTIES_OHOS = 1000452002,
    // Extension: VK_OHOS_external_memory
    VK_STRUCTURE_TYPE_IMPORT_NATIVE_BUFFER_INFO_OHOS = 1000452003,
    // Extension: VK_OHOS_external_memory
    VK_STRUCTURE_TYPE_MEMORY_GET_NATIVE_BUFFER_INFO_OHOS = 1000452004,
    // Extension: VK_OHOS_external_memory
    VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_OHOS = 1000452005,
    // Extension: VK_EXT_external_memory_acquire_unmodified
    VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT = 1000453000,
    // Extension: VK_OHOS_native_buffer
    VK_STRUCTURE_TYPE_NATIVE_BUFFER_OHOS = 1000453001,
    // Extension: VK_OHOS_native_buffer
    VK_STRUCTURE_TYPE_SWAPCHAIN_IMAGE_CREATE_INFO_OHOS = 1000453002,
    // Extension: VK_OHOS_native_buffer
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENTATION_PROPERTIES_OHOS = 1000453003,
    // Extension: VK_EXT_extended_dynamic_state3
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_FEATURES_EXT = 1000455000,
    // Extension: VK_EXT_extended_dynamic_state3
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_PROPERTIES_EXT = 1000455001,
    // Extension: VK_EXT_subpass_merge_feedback
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT = 1000458000,
    // Extension: VK_EXT_subpass_merge_feedback
    VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_CONTROL_EXT = 1000458001,
    // Extension: VK_EXT_subpass_merge_feedback
    VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_FEEDBACK_CREATE_INFO_EXT = 1000458002,
    // Extension: VK_EXT_subpass_merge_feedback
    VK_STRUCTURE_TYPE_RENDER_PASS_SUBPASS_FEEDBACK_CREATE_INFO_EXT = 1000458003,
    // Extension: VK_LUNARG_direct_driver_loading
    VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_INFO_LUNARG = 1000459000,
    // Extension: VK_LUNARG_direct_driver_loading
    VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_LIST_LUNARG = 1000459001,
    // Extension: VK_ARM_tensors
    VK_STRUCTURE_TYPE_TENSOR_CREATE_INFO_ARM = 1000460000,
    // Extension: VK_ARM_tensors
    VK_STRUCTURE_TYPE_TENSOR_VIEW_CREATE_INFO_ARM = 1000460001,
    // Extension: VK_ARM_tensors
    VK_STRUCTURE_TYPE_BIND_TENSOR_MEMORY_INFO_ARM = 1000460002,
    // Extension: VK_ARM_tensors
    VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_TENSOR_ARM = 1000460003,
    // Extension: VK_ARM_tensors
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TENSOR_PROPERTIES_ARM = 1000460004,
    // Extension: VK_ARM_tensors
    VK_STRUCTURE_TYPE_TENSOR_FORMAT_PROPERTIES_ARM = 1000460005,
    // Extension: VK_ARM_tensors
    VK_STRUCTURE_TYPE_TENSOR_DESCRIPTION_ARM = 1000460006,
    // Extension: VK_ARM_tensors
    VK_STRUCTURE_TYPE_TENSOR_MEMORY_REQUIREMENTS_INFO_ARM = 1000460007,
    // Extension: VK_ARM_tensors
    VK_STRUCTURE_TYPE_TENSOR_MEMORY_BARRIER_ARM = 1000460008,
    // Extension: VK_ARM_tensors
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TENSOR_FEATURES_ARM = 1000460009,
    // Extension: VK_ARM_tensors
    VK_STRUCTURE_TYPE_DEVICE_TENSOR_MEMORY_REQUIREMENTS_ARM = 1000460010,
    // Extension: VK_ARM_tensors
    VK_STRUCTURE_TYPE_COPY_TENSOR_INFO_ARM = 1000460011,
    // Extension: VK_ARM_tensors
    VK_STRUCTURE_TYPE_TENSOR_COPY_ARM = 1000460012,
    // Extension: VK_ARM_tensors
    VK_STRUCTURE_TYPE_TENSOR_DEPENDENCY_INFO_ARM = 1000460013,
    // Extension: VK_ARM_tensors
    VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_TENSOR_ARM = 1000460014,
    // Extension: VK_ARM_tensors
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_TENSOR_INFO_ARM = 1000460015,
    // Extension: VK_ARM_tensors
    VK_STRUCTURE_TYPE_EXTERNAL_TENSOR_PROPERTIES_ARM = 1000460016,
    // Extension: VK_ARM_tensors
    VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_TENSOR_CREATE_INFO_ARM = 1000460017,
    // Extension: VK_ARM_tensors
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_TENSOR_FEATURES_ARM = 1000460018,
    // Extension: VK_ARM_tensors
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_TENSOR_PROPERTIES_ARM = 1000460019,
    // Extension: VK_ARM_tensors
    VK_STRUCTURE_TYPE_DESCRIPTOR_GET_TENSOR_INFO_ARM = 1000460020,
    // Extension: VK_ARM_tensors
    VK_STRUCTURE_TYPE_TENSOR_CAPTURE_DESCRIPTOR_DATA_INFO_ARM = 1000460021,
    // Extension: VK_ARM_tensors
    VK_STRUCTURE_TYPE_TENSOR_VIEW_CAPTURE_DESCRIPTOR_DATA_INFO_ARM = 1000460022,
    // Extension: VK_ARM_tensors
    VK_STRUCTURE_TYPE_FRAME_BOUNDARY_TENSORS_ARM = 1000460023,
    // Extension: VK_EXT_shader_module_identifier
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT = 1000462000,
    // Extension: VK_EXT_shader_module_identifier
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_PROPERTIES_EXT = 1000462001,
    // Extension: VK_EXT_shader_module_identifier
    VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_MODULE_IDENTIFIER_CREATE_INFO_EXT = 1000462002,
    // Extension: VK_EXT_shader_module_identifier
    VK_STRUCTURE_TYPE_SHADER_MODULE_IDENTIFIER_EXT = 1000462003,
    // Extension: VK_NV_optical_flow
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_FEATURES_NV = 1000464000,
    // Extension: VK_NV_optical_flow
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_PROPERTIES_NV = 1000464001,
    // Extension: VK_NV_optical_flow
    VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV = 1000464002,
    // Extension: VK_NV_optical_flow
    VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_PROPERTIES_NV = 1000464003,
    // Extension: VK_NV_optical_flow
    VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_INFO_NV = 1000464004,
    // Extension: VK_NV_optical_flow
    VK_STRUCTURE_TYPE_OPTICAL_FLOW_EXECUTE_INFO_NV = 1000464005,
    // Extension: VK_NV_optical_flow
    VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_PRIVATE_DATA_INFO_NV = 1000464010,
    // Extension: VK_EXT_legacy_dithering
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT = 1000465000,
    // Extension: VK_COMPUTE_VERSION_1_4
    // Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES_EXT
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES = 1000466000,
    // Extension: VK_ANDROID_external_format_resolve
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FORMAT_RESOLVE_FEATURES_ANDROID = 1000468000,
    // Extension: VK_ANDROID_external_format_resolve
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FORMAT_RESOLVE_PROPERTIES_ANDROID = 1000468001,
    // Extension: VK_ANDROID_external_format_resolve
    VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_RESOLVE_PROPERTIES_ANDROID = 1000468002,
    // Extension: VK_BASE_VERSION_1_4
    // Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES_KHR
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES = 1000470000,
    // Extension: VK_BASE_VERSION_1_4
    // Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_PROPERTIES_KHR
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_PROPERTIES = 1000470001,
    // Extension: VK_GRAPHICS_VERSION_1_4
    // Alias: VK_STRUCTURE_TYPE_RENDERING_AREA_INFO_KHR
    VK_STRUCTURE_TYPE_RENDERING_AREA_INFO = 1000470003,
    // Extension: VK_BASE_VERSION_1_4
    // Alias: VK_STRUCTURE_TYPE_DEVICE_IMAGE_SUBRESOURCE_INFO_KHR
    VK_STRUCTURE_TYPE_DEVICE_IMAGE_SUBRESOURCE_INFO = 1000470004,
    // Extension: VK_COMPUTE_VERSION_1_4
    // Alias: VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO_KHR
    VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO = 1000470005,
    // Extension: VK_BASE_VERSION_1_4
    // Alias: VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO_KHR
    VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO = 1000470006,
    // Extension: VK_AMD_anti_lag
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ANTI_LAG_FEATURES_AMD = 1000476000,
    // Extension: VK_AMD_anti_lag
    VK_STRUCTURE_TYPE_ANTI_LAG_DATA_AMD = 1000476001,
    // Extension: VK_AMD_anti_lag
    VK_STRUCTURE_TYPE_ANTI_LAG_PRESENTATION_INFO_AMD = 1000476002,
    // Extension: VK_AMDX_dense_geometry_format
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DENSE_GEOMETRY_FORMAT_FEATURES_AMDX = 1000478000,
    // Extension: VK_AMDX_dense_geometry_format
    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DENSE_GEOMETRY_FORMAT_TRIANGLES_DATA_AMDX = 1000478001,
    // Extension: VK_KHR_present_id2
    VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_ID_2_KHR = 1000479000,
    // Extension: VK_KHR_present_id2
    VK_STRUCTURE_TYPE_PRESENT_ID_2_KHR = 1000479001,
    // Extension: VK_KHR_present_id2
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_2_FEATURES_KHR = 1000479002,
    // Extension: VK_KHR_present_wait2
    VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_WAIT_2_KHR = 1000480000,
    // Extension: VK_KHR_present_wait2
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_2_FEATURES_KHR = 1000480001,
    // Extension: VK_KHR_present_wait2
    VK_STRUCTURE_TYPE_PRESENT_WAIT_2_INFO_KHR = 1000480002,
    // Extension: VK_KHR_ray_tracing_position_fetch
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_POSITION_FETCH_FEATURES_KHR = 1000481000,
    // Extension: VK_EXT_shader_object
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_FEATURES_EXT = 1000482000,
    // Extension: VK_EXT_shader_object
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_PROPERTIES_EXT = 1000482001,
    // Extension: VK_EXT_shader_object
    VK_STRUCTURE_TYPE_SHADER_CREATE_INFO_EXT = 1000482002,
    // Extension: VK_KHR_pipeline_binary
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_FEATURES_KHR = 1000483000,
    // Extension: VK_KHR_pipeline_binary
    VK_STRUCTURE_TYPE_PIPELINE_BINARY_CREATE_INFO_KHR = 1000483001,
    // Extension: VK_KHR_pipeline_binary
    VK_STRUCTURE_TYPE_PIPELINE_BINARY_INFO_KHR = 1000483002,
    // Extension: VK_KHR_pipeline_binary
    VK_STRUCTURE_TYPE_PIPELINE_BINARY_KEY_KHR = 1000483003,
    // Extension: VK_KHR_pipeline_binary
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_PROPERTIES_KHR = 1000483004,
    // Extension: VK_KHR_pipeline_binary
    VK_STRUCTURE_TYPE_RELEASE_CAPTURED_PIPELINE_DATA_INFO_KHR = 1000483005,
    // Extension: VK_KHR_pipeline_binary
    VK_STRUCTURE_TYPE_PIPELINE_BINARY_DATA_INFO_KHR = 1000483006,
    // Extension: VK_KHR_pipeline_binary
    VK_STRUCTURE_TYPE_PIPELINE_CREATE_INFO_KHR = 1000483007,
    // Extension: VK_KHR_pipeline_binary
    VK_STRUCTURE_TYPE_DEVICE_PIPELINE_BINARY_INTERNAL_CACHE_CONTROL_KHR = 1000483008,
    // Extension: VK_KHR_pipeline_binary
    VK_STRUCTURE_TYPE_PIPELINE_BINARY_HANDLES_INFO_KHR = 1000483009,
    // Extension: VK_QCOM_tile_properties
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_PROPERTIES_FEATURES_QCOM = 1000484000,
    // Extension: VK_QCOM_tile_properties
    VK_STRUCTURE_TYPE_TILE_PROPERTIES_QCOM = 1000484001,
    // Extension: VK_SEC_amigo_profiling
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_AMIGO_PROFILING_FEATURES_SEC = 1000485000,
    // Extension: VK_SEC_amigo_profiling
    VK_STRUCTURE_TYPE_AMIGO_PROFILING_SUBMIT_INFO_SEC = 1000485001,
    // Extension: VK_QCOM_multiview_per_view_viewports
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_VIEWPORTS_FEATURES_QCOM = 1000488000,
    // Extension: VK_NV_external_sci_sync2
    VK_STRUCTURE_TYPE_SEMAPHORE_SCI_SYNC_POOL_CREATE_INFO_NV = 1000489000,
    // Extension: VK_NV_external_sci_sync2
    VK_STRUCTURE_TYPE_SEMAPHORE_SCI_SYNC_CREATE_INFO_NV = 1000489001,
    // Extension: VK_NV_external_sci_sync2
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SCI_SYNC_2_FEATURES_NV = 1000489002,
    // Extension: VK_NV_external_sci_sync2
    VK_STRUCTURE_TYPE_DEVICE_SEMAPHORE_SCI_SYNC_POOL_RESERVATION_CREATE_INFO_NV = 1000489003,
    // Extension: VK_NV_ray_tracing_invocation_reorder
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_FEATURES_NV = 1000490000,
    // Extension: VK_NV_ray_tracing_invocation_reorder
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_PROPERTIES_NV = 1000490001,
    // Extension: VK_NV_cooperative_vector
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_VECTOR_FEATURES_NV = 1000491000,
    // Extension: VK_NV_cooperative_vector
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_VECTOR_PROPERTIES_NV = 1000491001,
    // Extension: VK_NV_cooperative_vector
    VK_STRUCTURE_TYPE_COOPERATIVE_VECTOR_PROPERTIES_NV = 1000491002,
    // Extension: VK_NV_cooperative_vector
    VK_STRUCTURE_TYPE_CONVERT_COOPERATIVE_VECTOR_MATRIX_INFO_NV = 1000491004,
    // Extension: VK_NV_extended_sparse_address_space
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_FEATURES_NV = 1000492000,
    // Extension: VK_NV_extended_sparse_address_space
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_PROPERTIES_NV = 1000492001,
    // Extension: VK_EXT_legacy_vertex_attributes
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_FEATURES_EXT = 1000495000,
    // Extension: VK_EXT_legacy_vertex_attributes
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_PROPERTIES_EXT = 1000495001,
    // Extension: VK_EXT_layer_settings
    VK_STRUCTURE_TYPE_LAYER_SETTINGS_CREATE_INFO_EXT = 1000496000,
    // Extension: VK_ARM_shader_core_builtins
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_FEATURES_ARM = 1000497000,
    // Extension: VK_ARM_shader_core_builtins
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_PROPERTIES_ARM = 1000497001,
    // Extension: VK_EXT_pipeline_library_group_handles
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_LIBRARY_GROUP_HANDLES_FEATURES_EXT = 1000498000,
    // Extension: VK_EXT_dynamic_rendering_unused_attachments
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_FEATURES_EXT = 1000499000,
    // Extension: VK_NV_low_latency2
    VK_STRUCTURE_TYPE_LATENCY_SLEEP_MODE_INFO_NV = 1000505000,
    // Extension: VK_NV_low_latency2
    VK_STRUCTURE_TYPE_LATENCY_SLEEP_INFO_NV = 1000505001,
    // Extension: VK_NV_low_latency2
    VK_STRUCTURE_TYPE_SET_LATENCY_MARKER_INFO_NV = 1000505002,
    // Extension: VK_NV_low_latency2
    VK_STRUCTURE_TYPE_GET_LATENCY_MARKER_INFO_NV = 1000505003,
    // Extension: VK_NV_low_latency2
    VK_STRUCTURE_TYPE_LATENCY_TIMINGS_FRAME_REPORT_NV = 1000505004,
    // Extension: VK_NV_low_latency2
    VK_STRUCTURE_TYPE_LATENCY_SUBMISSION_PRESENT_ID_NV = 1000505005,
    // Extension: VK_NV_low_latency2
    VK_STRUCTURE_TYPE_OUT_OF_BAND_QUEUE_TYPE_INFO_NV = 1000505006,
    // Extension: VK_NV_low_latency2
    VK_STRUCTURE_TYPE_SWAPCHAIN_LATENCY_CREATE_INFO_NV = 1000505007,
    // Extension: VK_NV_low_latency2
    VK_STRUCTURE_TYPE_LATENCY_SURFACE_CAPABILITIES_NV = 1000505008,
    // Extension: VK_KHR_cooperative_matrix
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_KHR = 1000506000,
    // Extension: VK_KHR_cooperative_matrix
    VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_KHR = 1000506001,
    // Extension: VK_KHR_cooperative_matrix
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_KHR = 1000506002,
    // Extension: VK_ARM_data_graph
    VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_CREATE_INFO_ARM = 1000507000,
    // Extension: VK_ARM_data_graph
    VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_CREATE_INFO_ARM = 1000507001,
    // Extension: VK_ARM_data_graph
    VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_RESOURCE_INFO_ARM = 1000507002,
    // Extension: VK_ARM_data_graph
    VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_CONSTANT_ARM = 1000507003,
    // Extension: VK_ARM_data_graph
    VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_MEMORY_REQUIREMENTS_INFO_ARM = 1000507004,
    // Extension: VK_ARM_data_graph
    VK_STRUCTURE_TYPE_BIND_DATA_GRAPH_PIPELINE_SESSION_MEMORY_INFO_ARM = 1000507005,
    // Extension: VK_ARM_data_graph
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DATA_GRAPH_FEATURES_ARM = 1000507006,
    // Extension: VK_ARM_data_graph
    VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SHADER_MODULE_CREATE_INFO_ARM = 1000507007,
    // Extension: VK_ARM_data_graph
    VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_PROPERTY_QUERY_RESULT_ARM = 1000507008,
    // Extension: VK_ARM_data_graph
    VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_INFO_ARM = 1000507009,
    // Extension: VK_ARM_data_graph
    VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_COMPILER_CONTROL_CREATE_INFO_ARM = 1000507010,
    // Extension: VK_ARM_data_graph
    VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_REQUIREMENTS_INFO_ARM = 1000507011,
    // Extension: VK_ARM_data_graph
    VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_REQUIREMENT_ARM = 1000507012,
    // Extension: VK_ARM_data_graph
    VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_IDENTIFIER_CREATE_INFO_ARM = 1000507013,
    // Extension: VK_ARM_data_graph
    VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_DISPATCH_INFO_ARM = 1000507014,
    // Extension: VK_ARM_data_graph
    VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_CONSTANT_TENSOR_SEMI_STRUCTURED_SPARSITY_INFO_ARM = 1000507015,
    // Extension: VK_ARM_data_graph
    VK_STRUCTURE_TYPE_DATA_GRAPH_PROCESSING_ENGINE_CREATE_INFO_ARM = 1000507016,
    // Extension: VK_ARM_data_graph
    VK_STRUCTURE_TYPE_QUEUE_FAMILY_DATA_GRAPH_PROCESSING_ENGINE_PROPERTIES_ARM = 1000507017,
    // Extension: VK_ARM_data_graph
    VK_STRUCTURE_TYPE_QUEUE_FAMILY_DATA_GRAPH_PROPERTIES_ARM = 1000507018,
    // Extension: VK_ARM_data_graph
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_QUEUE_FAMILY_DATA_GRAPH_PROCESSING_ENGINE_INFO_ARM = 1000507019,
    // Extension: VK_QCOM_multiview_per_view_render_areas
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_RENDER_AREAS_FEATURES_QCOM = 1000510000,
    // Extension: VK_QCOM_multiview_per_view_render_areas
    VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_RENDER_AREAS_RENDER_PASS_BEGIN_INFO_QCOM = 1000510001,
    // Extension: VK_KHR_compute_shader_derivatives
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_PROPERTIES_KHR = 1000511000,
    // Extension: VK_KHR_video_decode_av1
    VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_CAPABILITIES_KHR = 1000512000,
    // Extension: VK_KHR_video_decode_av1
    VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_PICTURE_INFO_KHR = 1000512001,
    // Extension: VK_KHR_video_decode_av1
    VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_PROFILE_INFO_KHR = 1000512003,
    // Extension: VK_KHR_video_decode_av1
    VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_SESSION_PARAMETERS_CREATE_INFO_KHR = 1000512004,
    // Extension: VK_KHR_video_decode_av1
    VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_DPB_SLOT_INFO_KHR = 1000512005,
    // Extension: VK_KHR_video_encode_av1
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_CAPABILITIES_KHR = 1000513000,
    // Extension: VK_KHR_video_encode_av1
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_SESSION_PARAMETERS_CREATE_INFO_KHR = 1000513001,
    // Extension: VK_KHR_video_encode_av1
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_PICTURE_INFO_KHR = 1000513002,
    // Extension: VK_KHR_video_encode_av1
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_DPB_SLOT_INFO_KHR = 1000513003,
    // Extension: VK_KHR_video_encode_av1
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_AV1_FEATURES_KHR = 1000513004,
    // Extension: VK_KHR_video_encode_av1
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_PROFILE_INFO_KHR = 1000513005,
    // Extension: VK_KHR_video_encode_av1
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_RATE_CONTROL_INFO_KHR = 1000513006,
    // Extension: VK_KHR_video_encode_av1
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_RATE_CONTROL_LAYER_INFO_KHR = 1000513007,
    // Extension: VK_KHR_video_encode_av1
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_QUALITY_LEVEL_PROPERTIES_KHR = 1000513008,
    // Extension: VK_KHR_video_encode_av1
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_SESSION_CREATE_INFO_KHR = 1000513009,
    // Extension: VK_KHR_video_encode_av1
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_GOP_REMAINING_FRAME_INFO_KHR = 1000513010,
    // Extension: VK_KHR_video_decode_vp9
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_DECODE_VP9_FEATURES_KHR = 1000514000,
    // Extension: VK_KHR_video_decode_vp9
    VK_STRUCTURE_TYPE_VIDEO_DECODE_VP9_CAPABILITIES_KHR = 1000514001,
    // Extension: VK_KHR_video_decode_vp9
    VK_STRUCTURE_TYPE_VIDEO_DECODE_VP9_PICTURE_INFO_KHR = 1000514002,
    // Extension: VK_KHR_video_decode_vp9
    VK_STRUCTURE_TYPE_VIDEO_DECODE_VP9_PROFILE_INFO_KHR = 1000514003,
    // Extension: VK_KHR_video_maintenance1
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_1_FEATURES_KHR = 1000515000,
    // Extension: VK_KHR_video_maintenance1
    VK_STRUCTURE_TYPE_VIDEO_INLINE_QUERY_INFO_KHR = 1000515001,
    // Extension: VK_NV_per_stage_descriptor_set
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PER_STAGE_DESCRIPTOR_SET_FEATURES_NV = 1000516000,
    // Extension: VK_QCOM_image_processing2
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_FEATURES_QCOM = 1000518000,
    // Extension: VK_QCOM_image_processing2
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_PROPERTIES_QCOM = 1000518001,
    // Extension: VK_QCOM_image_processing2
    VK_STRUCTURE_TYPE_SAMPLER_BLOCK_MATCH_WINDOW_CREATE_INFO_QCOM = 1000518002,
    // Extension: VK_QCOM_filter_cubic_weights
    VK_STRUCTURE_TYPE_SAMPLER_CUBIC_WEIGHTS_CREATE_INFO_QCOM = 1000519000,
    // Extension: VK_QCOM_filter_cubic_weights
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_WEIGHTS_FEATURES_QCOM = 1000519001,
    // Extension: VK_QCOM_filter_cubic_weights
    VK_STRUCTURE_TYPE_BLIT_IMAGE_CUBIC_WEIGHTS_INFO_QCOM = 1000519002,
    // Extension: VK_QCOM_ycbcr_degamma
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_DEGAMMA_FEATURES_QCOM = 1000520000,
    // Extension: VK_QCOM_ycbcr_degamma
    VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_YCBCR_DEGAMMA_CREATE_INFO_QCOM = 1000520001,
    // Extension: VK_QCOM_filter_cubic_clamp
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_CLAMP_FEATURES_QCOM = 1000521000,
    // Extension: VK_EXT_attachment_feedback_loop_dynamic_state
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_FEATURES_EXT = 1000524000,
    // Extension: VK_GRAPHICS_VERSION_1_4
    // Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_KHR
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES = 1000525000,
    // Extension: VK_KHR_unified_image_layouts
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFIED_IMAGE_LAYOUTS_FEATURES_KHR = 1000527000,
    // Extension: VK_KHR_unified_image_layouts
    VK_STRUCTURE_TYPE_ATTACHMENT_FEEDBACK_LOOP_INFO_EXT = 1000527001,
    // Extension: VK_COMPUTE_VERSION_1_4
    // Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT_CONTROLS_2_FEATURES_KHR
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT_CONTROLS_2_FEATURES = 1000528000,
    // Extension: VK_QNX_external_memory_screen_buffer
    VK_STRUCTURE_TYPE_SCREEN_BUFFER_PROPERTIES_QNX = 1000529000,
    // Extension: VK_QNX_external_memory_screen_buffer
    VK_STRUCTURE_TYPE_SCREEN_BUFFER_FORMAT_PROPERTIES_QNX = 1000529001,
    // Extension: VK_QNX_external_memory_screen_buffer
    VK_STRUCTURE_TYPE_IMPORT_SCREEN_BUFFER_INFO_QNX = 1000529002,
    // Extension: VK_QNX_external_memory_screen_buffer
    VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_QNX = 1000529003,
    // Extension: VK_QNX_external_memory_screen_buffer
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_SCREEN_BUFFER_FEATURES_QNX = 1000529004,
    // Extension: VK_MSFT_layered_driver
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_DRIVER_PROPERTIES_MSFT = 1000530000,
    // Extension: VK_COMPUTE_VERSION_1_4
    // Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EXPECT_ASSUME_FEATURES_KHR
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EXPECT_ASSUME_FEATURES = 1000544000,
    // Extension: VK_BASE_VERSION_1_4
    // Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_FEATURES_KHR
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_FEATURES = 1000545000,
    // Extension: VK_BASE_VERSION_1_4
    // Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_PROPERTIES_KHR
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_PROPERTIES = 1000545001,
    // Extension: VK_BASE_VERSION_1_4
    // Alias: VK_STRUCTURE_TYPE_BIND_MEMORY_STATUS_KHR
    VK_STRUCTURE_TYPE_BIND_MEMORY_STATUS = 1000545002,
    // Extension: VK_COMPUTE_VERSION_1_4
    // Alias: VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_SETS_INFO_KHR
    VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_SETS_INFO = 1000545003,
    // Extension: VK_COMPUTE_VERSION_1_4
    // Alias: VK_STRUCTURE_TYPE_PUSH_CONSTANTS_INFO_KHR
    VK_STRUCTURE_TYPE_PUSH_CONSTANTS_INFO = 1000545004,
    // Extension: VK_COMPUTE_VERSION_1_4
    // Alias: VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_INFO_KHR
    VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_INFO = 1000545005,
    // Extension: VK_COMPUTE_VERSION_1_4
    // Alias: VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_WITH_TEMPLATE_INFO_KHR
    VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_WITH_TEMPLATE_INFO = 1000545006,
    // Extension: VK_KHR_maintenance6
    VK_STRUCTURE_TYPE_SET_DESCRIPTOR_BUFFER_OFFSETS_INFO_EXT = 1000545007,
    // Extension: VK_KHR_maintenance6
    VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_BUFFER_EMBEDDED_SAMPLERS_INFO_EXT = 1000545008,
    // Extension: VK_NV_descriptor_pool_overallocation
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_POOL_OVERALLOCATION_FEATURES_NV = 1000546000,
    // Extension: VK_QCOM_tile_memory_heap
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_MEMORY_HEAP_FEATURES_QCOM = 1000547000,
    // Extension: VK_QCOM_tile_memory_heap
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_MEMORY_HEAP_PROPERTIES_QCOM = 1000547001,
    // Extension: VK_QCOM_tile_memory_heap
    VK_STRUCTURE_TYPE_TILE_MEMORY_REQUIREMENTS_QCOM = 1000547002,
    // Extension: VK_QCOM_tile_memory_heap
    VK_STRUCTURE_TYPE_TILE_MEMORY_BIND_INFO_QCOM = 1000547003,
    // Extension: VK_QCOM_tile_memory_heap
    VK_STRUCTURE_TYPE_TILE_MEMORY_SIZE_INFO_QCOM = 1000547004,
    // Extension: VK_KHR_copy_memory_indirect
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_FEATURES_KHR = 1000549000,
    // Extension: VK_KHR_copy_memory_indirect
    VK_STRUCTURE_TYPE_COPY_MEMORY_INDIRECT_INFO_KHR = 1000549002,
    // Extension: VK_KHR_copy_memory_indirect
    VK_STRUCTURE_TYPE_COPY_MEMORY_TO_IMAGE_INDIRECT_INFO_KHR = 1000549003,
    // Extension: VK_EXT_memory_decompression
    VK_STRUCTURE_TYPE_DECOMPRESS_MEMORY_INFO_EXT = 1000550002,
    // Extension: VK_NV_display_stereo
    VK_STRUCTURE_TYPE_DISPLAY_SURFACE_STEREO_CREATE_INFO_NV = 1000551000,
    // Extension: VK_NV_display_stereo
    VK_STRUCTURE_TYPE_DISPLAY_MODE_STEREO_PROPERTIES_NV = 1000551001,
    // Extension: VK_KHR_video_encode_intra_refresh
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_INTRA_REFRESH_CAPABILITIES_KHR = 1000552000,
    // Extension: VK_KHR_video_encode_intra_refresh
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_INTRA_REFRESH_CREATE_INFO_KHR = 1000552001,
    // Extension: VK_KHR_video_encode_intra_refresh
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_INTRA_REFRESH_INFO_KHR = 1000552002,
    // Extension: VK_KHR_video_encode_intra_refresh
    VK_STRUCTURE_TYPE_VIDEO_REFERENCE_INTRA_REFRESH_INFO_KHR = 1000552003,
    // Extension: VK_KHR_video_encode_intra_refresh
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_INTRA_REFRESH_FEATURES_KHR = 1000552004,
    // Extension: VK_KHR_video_encode_quantization_map
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_CAPABILITIES_KHR = 1000553000,
    // Extension: VK_KHR_video_encode_quantization_map
    VK_STRUCTURE_TYPE_VIDEO_FORMAT_QUANTIZATION_MAP_PROPERTIES_KHR = 1000553001,
    // Extension: VK_KHR_video_encode_quantization_map
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_INFO_KHR = 1000553002,
    // Extension: VK_KHR_video_encode_quantization_map
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_QUANTIZATION_MAP_CAPABILITIES_KHR = 1000553003,
    // Extension: VK_KHR_video_encode_quantization_map
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_QUANTIZATION_MAP_CAPABILITIES_KHR = 1000553004,
    // Extension: VK_KHR_video_encode_quantization_map
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_SESSION_PARAMETERS_CREATE_INFO_KHR = 1000553005,
    // Extension: VK_KHR_video_encode_quantization_map
    VK_STRUCTURE_TYPE_VIDEO_FORMAT_H265_QUANTIZATION_MAP_PROPERTIES_KHR = 1000553006,
    // Extension: VK_KHR_video_encode_quantization_map
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_QUANTIZATION_MAP_CAPABILITIES_KHR = 1000553007,
    // Extension: VK_KHR_video_encode_quantization_map
    VK_STRUCTURE_TYPE_VIDEO_FORMAT_AV1_QUANTIZATION_MAP_PROPERTIES_KHR = 1000553008,
    // Extension: VK_KHR_video_encode_quantization_map
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUANTIZATION_MAP_FEATURES_KHR = 1000553009,
    // Extension: VK_NV_raw_access_chains
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAW_ACCESS_CHAINS_FEATURES_NV = 1000555000,
    // Extension: VK_NV_external_compute_queue
    VK_STRUCTURE_TYPE_EXTERNAL_COMPUTE_QUEUE_DEVICE_CREATE_INFO_NV = 1000556000,
    // Extension: VK_NV_external_compute_queue
    VK_STRUCTURE_TYPE_EXTERNAL_COMPUTE_QUEUE_CREATE_INFO_NV = 1000556001,
    // Extension: VK_NV_external_compute_queue
    VK_STRUCTURE_TYPE_EXTERNAL_COMPUTE_QUEUE_DATA_PARAMS_NV = 1000556002,
    // Extension: VK_NV_external_compute_queue
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_COMPUTE_QUEUE_PROPERTIES_NV = 1000556003,
    // Extension: VK_KHR_shader_relaxed_extended_instruction
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_RELAXED_EXTENDED_INSTRUCTION_FEATURES_KHR = 1000558000,
    // Extension: VK_NV_command_buffer_inheritance
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMMAND_BUFFER_INHERITANCE_FEATURES_NV = 1000559000,
    // Extension: VK_KHR_maintenance7
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_7_FEATURES_KHR = 1000562000,
    // Extension: VK_KHR_maintenance7
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_7_PROPERTIES_KHR = 1000562001,
    // Extension: VK_KHR_maintenance7
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_PROPERTIES_LIST_KHR = 1000562002,
    // Extension: VK_KHR_maintenance7
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_PROPERTIES_KHR = 1000562003,
    // Extension: VK_KHR_maintenance7
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_VULKAN_PROPERTIES_KHR = 1000562004,
    // Extension: VK_NV_shader_atomic_float16_vector
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT16_VECTOR_FEATURES_NV = 1000563000,
    // Extension: VK_EXT_shader_replicated_composites
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_REPLICATED_COMPOSITES_FEATURES_EXT = 1000564000,
    // Extension: VK_EXT_shader_float8
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT8_FEATURES_EXT = 1000567000,
    // Extension: VK_NV_ray_tracing_validation
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_VALIDATION_FEATURES_NV = 1000568000,
    // Extension: VK_NV_cluster_acceleration_structure
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_ACCELERATION_STRUCTURE_FEATURES_NV = 1000569000,
    // Extension: VK_NV_cluster_acceleration_structure
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_ACCELERATION_STRUCTURE_PROPERTIES_NV = 1000569001,
    // Extension: VK_NV_cluster_acceleration_structure
    VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_CLUSTERS_BOTTOM_LEVEL_INPUT_NV = 1000569002,
    // Extension: VK_NV_cluster_acceleration_structure
    VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_TRIANGLE_CLUSTER_INPUT_NV = 1000569003,
    // Extension: VK_NV_cluster_acceleration_structure
    VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_MOVE_OBJECTS_INPUT_NV = 1000569004,
    // Extension: VK_NV_cluster_acceleration_structure
    VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_INPUT_INFO_NV = 1000569005,
    // Extension: VK_NV_cluster_acceleration_structure
    VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_COMMANDS_INFO_NV = 1000569006,
    // Extension: VK_NV_cluster_acceleration_structure
    VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CLUSTER_ACCELERATION_STRUCTURE_CREATE_INFO_NV = 1000569007,
    // Extension: VK_NV_partitioned_acceleration_structure
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PARTITIONED_ACCELERATION_STRUCTURE_FEATURES_NV = 1000570000,
    // Extension: VK_NV_partitioned_acceleration_structure
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PARTITIONED_ACCELERATION_STRUCTURE_PROPERTIES_NV = 1000570001,
    // Extension: VK_NV_partitioned_acceleration_structure
    VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_PARTITIONED_ACCELERATION_STRUCTURE_NV = 1000570002,
    // Extension: VK_NV_partitioned_acceleration_structure
    VK_STRUCTURE_TYPE_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCES_INPUT_NV = 1000570003,
    // Extension: VK_NV_partitioned_acceleration_structure
    VK_STRUCTURE_TYPE_BUILD_PARTITIONED_ACCELERATION_STRUCTURE_INFO_NV = 1000570004,
    // Extension: VK_NV_partitioned_acceleration_structure
    VK_STRUCTURE_TYPE_PARTITIONED_ACCELERATION_STRUCTURE_FLAGS_NV = 1000570005,
    // Extension: VK_EXT_device_generated_commands
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_EXT = 1000572000,
    // Extension: VK_EXT_device_generated_commands
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_EXT = 1000572001,
    // Extension: VK_EXT_device_generated_commands
    VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_EXT = 1000572002,
    // Extension: VK_EXT_device_generated_commands
    VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_CREATE_INFO_EXT = 1000572003,
    // Extension: VK_EXT_device_generated_commands
    VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_EXT = 1000572004,
    // Extension: VK_EXT_device_generated_commands
    VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_EXT = 1000572006,
    // Extension: VK_EXT_device_generated_commands
    VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_EXT = 1000572007,
    // Extension: VK_EXT_device_generated_commands
    VK_STRUCTURE_TYPE_WRITE_INDIRECT_EXECUTION_SET_PIPELINE_EXT = 1000572008,
    // Extension: VK_EXT_device_generated_commands
    VK_STRUCTURE_TYPE_WRITE_INDIRECT_EXECUTION_SET_SHADER_EXT = 1000572009,
    // Extension: VK_EXT_device_generated_commands
    VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_PIPELINE_INFO_EXT = 1000572010,
    // Extension: VK_EXT_device_generated_commands
    VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_SHADER_INFO_EXT = 1000572011,
    // Extension: VK_EXT_device_generated_commands
    VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_SHADER_LAYOUT_INFO_EXT = 1000572012,
    // Extension: VK_EXT_device_generated_commands
    VK_STRUCTURE_TYPE_GENERATED_COMMANDS_PIPELINE_INFO_EXT = 1000572013,
    // Extension: VK_EXT_device_generated_commands
    VK_STRUCTURE_TYPE_GENERATED_COMMANDS_SHADER_INFO_EXT = 1000572014,
    // Extension: VK_KHR_maintenance8
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_8_FEATURES_KHR = 1000574000,
    // Extension: VK_KHR_maintenance8
    VK_STRUCTURE_TYPE_MEMORY_BARRIER_ACCESS_FLAGS_3_KHR = 1000574002,
    // Extension: VK_MESA_image_alignment_control
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_FEATURES_MESA = 1000575000,
    // Extension: VK_MESA_image_alignment_control
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_PROPERTIES_MESA = 1000575001,
    // Extension: VK_MESA_image_alignment_control
    VK_STRUCTURE_TYPE_IMAGE_ALIGNMENT_CONTROL_CREATE_INFO_MESA = 1000575002,
    // Extension: VK_KHR_shader_fma
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FMA_FEATURES_KHR = 1000579000,
    // Extension: VK_EXT_ray_tracing_invocation_reorder
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_FEATURES_EXT = 1000581000,
    // Extension: VK_EXT_ray_tracing_invocation_reorder
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_PROPERTIES_EXT = 1000581001,
    // Extension: VK_EXT_depth_clamp_control
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_CONTROL_FEATURES_EXT = 1000582000,
    // Extension: VK_EXT_depth_clamp_control
    VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLAMP_CONTROL_CREATE_INFO_EXT = 1000582001,
    // Extension: VK_KHR_maintenance9
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_9_FEATURES_KHR = 1000584000,
    // Extension: VK_KHR_maintenance9
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_9_PROPERTIES_KHR = 1000584001,
    // Extension: VK_KHR_maintenance9
    VK_STRUCTURE_TYPE_QUEUE_FAMILY_OWNERSHIP_TRANSFER_PROPERTIES_KHR = 1000584002,
    // Extension: VK_KHR_video_maintenance2
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_2_FEATURES_KHR = 1000586000,
    // Extension: VK_KHR_video_maintenance2
    VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_INLINE_SESSION_PARAMETERS_INFO_KHR = 1000586001,
    // Extension: VK_KHR_video_maintenance2
    VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_INLINE_SESSION_PARAMETERS_INFO_KHR = 1000586002,
    // Extension: VK_KHR_video_maintenance2
    VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_INLINE_SESSION_PARAMETERS_INFO_KHR = 1000586003,
    // Extension: VK_HUAWEI_hdr_vivid
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HDR_VIVID_FEATURES_HUAWEI = 1000590000,
    // Extension: VK_HUAWEI_hdr_vivid
    VK_STRUCTURE_TYPE_HDR_VIVID_DYNAMIC_METADATA_HUAWEI = 1000590001,
    // Extension: VK_NV_cooperative_matrix2
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_2_FEATURES_NV = 1000593000,
    // Extension: VK_NV_cooperative_matrix2
    VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_FLEXIBLE_DIMENSIONS_PROPERTIES_NV = 1000593001,
    // Extension: VK_NV_cooperative_matrix2
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_2_PROPERTIES_NV = 1000593002,
    // Extension: VK_ARM_pipeline_opacity_micromap
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_OPACITY_MICROMAP_FEATURES_ARM = 1000596000,
    // Extension: VK_EXT_external_memory_metal
    VK_STRUCTURE_TYPE_IMPORT_MEMORY_METAL_HANDLE_INFO_EXT = 1000602000,
    // Extension: VK_EXT_external_memory_metal
    VK_STRUCTURE_TYPE_MEMORY_METAL_HANDLE_PROPERTIES_EXT = 1000602001,
    // Extension: VK_EXT_external_memory_metal
    VK_STRUCTURE_TYPE_MEMORY_GET_METAL_HANDLE_INFO_EXT = 1000602002,
    // Extension: VK_ARM_performance_counters_by_region
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_COUNTERS_BY_REGION_FEATURES_ARM = 1000605000,
    // Extension: VK_ARM_performance_counters_by_region
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_COUNTERS_BY_REGION_PROPERTIES_ARM = 1000605001,
    // Extension: VK_ARM_performance_counters_by_region
    VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_ARM = 1000605002,
    // Extension: VK_ARM_performance_counters_by_region
    VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_DESCRIPTION_ARM = 1000605003,
    // Extension: VK_ARM_performance_counters_by_region
    VK_STRUCTURE_TYPE_RENDER_PASS_PERFORMANCE_COUNTERS_BY_REGION_BEGIN_INFO_ARM = 1000605004,
    // Extension: VK_EXT_vertex_attribute_robustness
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_ROBUSTNESS_FEATURES_EXT = 1000608000,
    // Extension: VK_ARM_format_pack
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FORMAT_PACK_FEATURES_ARM = 1000609000,
    // Extension: VK_VALVE_fragment_density_map_layered
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_LAYERED_FEATURES_VALVE = 1000611000,
    // Extension: VK_VALVE_fragment_density_map_layered
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_LAYERED_PROPERTIES_VALVE = 1000611001,
    // Extension: VK_VALVE_fragment_density_map_layered
    VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_DENSITY_MAP_LAYERED_CREATE_INFO_VALVE = 1000611002,
    // Extension: VK_NV_present_metering
    VK_STRUCTURE_TYPE_SET_PRESENT_CONFIG_NV = 1000613000,
    // Extension: VK_NV_present_metering
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_METERING_FEATURES_NV = 1000613001,
    // Extension: VK_KHR_maintenance10
    // Alias: VK_STRUCTURE_TYPE_RENDERING_END_INFO_EXT
    VK_STRUCTURE_TYPE_RENDERING_END_INFO_KHR = 1000619003,
    // Extension: VK_EXT_zero_initialize_device_memory
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_DEVICE_MEMORY_FEATURES_EXT = 1000620000,
    // Extension: VK_EXT_shader_64bit_indexing
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_64_BIT_INDEXING_FEATURES_EXT = 1000627000,
    // Extension: VK_EXT_custom_resolve
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_RESOLVE_FEATURES_EXT = 1000628000,
    // Extension: VK_EXT_custom_resolve
    VK_STRUCTURE_TYPE_BEGIN_CUSTOM_RESOLVE_INFO_EXT = 1000628001,
    // Extension: VK_EXT_custom_resolve
    VK_STRUCTURE_TYPE_CUSTOM_RESOLVE_CREATE_INFO_EXT = 1000628002,
    // Extension: VK_QCOM_data_graph_model
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DATA_GRAPH_MODEL_FEATURES_QCOM = 1000629000,
    // Extension: VK_QCOM_data_graph_model
    VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_BUILTIN_MODEL_CREATE_INFO_QCOM = 1000629001,
    // Extension: VK_KHR_maintenance10
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_10_FEATURES_KHR = 1000630000,
    // Extension: VK_KHR_maintenance10
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_10_PROPERTIES_KHR = 1000630001,
    // Extension: VK_KHR_maintenance10
    VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_FLAGS_INFO_KHR = 1000630002,
    // Extension: VK_KHR_maintenance10
    VK_STRUCTURE_TYPE_RESOLVE_IMAGE_MODE_INFO_KHR = 1000630004,
    // Extension: VK_SEC_pipeline_cache_incremental_mode
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CACHE_INCREMENTAL_MODE_FEATURES_SEC = 1000637000,
    // Extension: VK_EXT_shader_uniform_buffer_unsized_array
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_UNIFORM_BUFFER_UNSIZED_ARRAY_FEATURES_EXT = 1000642000,
    // Extension: VK_NV_compute_occupancy_priority
    VK_STRUCTURE_TYPE_COMPUTE_OCCUPANCY_PRIORITY_PARAMETERS_NV = 1000645000,
    // Extension: VK_NV_compute_occupancy_priority
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_OCCUPANCY_PRIORITY_FEATURES_NV = 1000645001,
    // Extension: VK_OHOS_surface
    VK_STRUCTURE_TYPE_SURFACE_CREATE_INFO_OHOS = 1000685000,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkSubpassContents = enum(u32) {
    VK_SUBPASS_CONTENTS_INLINE = 0,
    VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS = 1,
    // Extension: VK_KHR_maintenance7
    // Alias: VK_SUBPASS_CONTENTS_INLINE_AND_SECONDARY_COMMAND_BUFFERS_EXT
    VK_SUBPASS_CONTENTS_INLINE_AND_SECONDARY_COMMAND_BUFFERS_KHR = 1000451000,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkResult = enum(u32) {
    // Extension: VK_KHR_pipeline_binary
    VK_ERROR_NOT_ENOUGH_SPACE_KHR = -1000483000,
    // Extension: VK_EXT_image_compression_control
    VK_ERROR_COMPRESSION_EXHAUSTED_EXT = -1000338000,
    // Extension: VK_KHR_video_encode_queue
    VK_ERROR_INVALID_VIDEO_STD_PARAMETERS_KHR = -1000299000,
    // Extension: VKSC_VERSION_1_0
    VK_ERROR_NO_PIPELINE_MATCH = -1000298001,
    // Extension: VKSC_VERSION_1_0
    VK_ERROR_INVALID_PIPELINE_CACHE_DATA = -1000298000,
    // Extension: VK_BASE_VERSION_1_2
    // Alias: VK_ERROR_INVALID_DEVICE_ADDRESS_EXT
    // Alias: VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS_KHR
    VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS = -1000257000,
    // Extension: VK_EXT_full_screen_exclusive
    VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT = -1000255000,
    // Extension: VK_EXT_present_timing
    VK_ERROR_PRESENT_TIMING_QUEUE_FULL_EXT = -1000208000,
    // Extension: VK_BASE_VERSION_1_4
    // Alias: VK_ERROR_NOT_PERMITTED_EXT
    // Alias: VK_ERROR_NOT_PERMITTED_KHR
    VK_ERROR_NOT_PERMITTED = -1000174001,
    // Extension: VK_COMPUTE_VERSION_1_2
    // Alias: VK_ERROR_FRAGMENTATION_EXT
    VK_ERROR_FRAGMENTATION = -1000161000,
    // Extension: VK_EXT_image_drm_format_modifier
    VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT = -1000158000,
    // Extension: VK_BASE_VERSION_1_1
    // Alias: VK_ERROR_INVALID_EXTERNAL_HANDLE_KHR
    VK_ERROR_INVALID_EXTERNAL_HANDLE = -1000072003,
    // Extension: VK_BASE_VERSION_1_1
    // Alias: VK_ERROR_OUT_OF_POOL_MEMORY_KHR
    VK_ERROR_OUT_OF_POOL_MEMORY = -1000069000,
    // Extension: VK_KHR_video_queue
    VK_ERROR_VIDEO_STD_VERSION_NOT_SUPPORTED_KHR = -1000023005,
    // Extension: VK_KHR_video_queue
    VK_ERROR_VIDEO_PROFILE_CODEC_NOT_SUPPORTED_KHR = -1000023004,
    // Extension: VK_KHR_video_queue
    VK_ERROR_VIDEO_PROFILE_FORMAT_NOT_SUPPORTED_KHR = -1000023003,
    // Extension: VK_KHR_video_queue
    VK_ERROR_VIDEO_PROFILE_OPERATION_NOT_SUPPORTED_KHR = -1000023002,
    // Extension: VK_KHR_video_queue
    VK_ERROR_VIDEO_PICTURE_LAYOUT_NOT_SUPPORTED_KHR = -1000023001,
    // Extension: VK_KHR_video_queue
    VK_ERROR_IMAGE_USAGE_NOT_SUPPORTED_KHR = -1000023000,
    // Extension: VK_NV_glsl_shader
    VK_ERROR_INVALID_SHADER_NV = -1000012000,
    // Extension: VK_BASE_VERSION_1_0
    // Alias: VK_ERROR_VALIDATION_FAILED_EXT
    VK_ERROR_VALIDATION_FAILED = -1000011001,
    // Extension: VK_KHR_display_swapchain
    VK_ERROR_INCOMPATIBLE_DISPLAY_KHR = -1000003001,
    // Extension: VK_KHR_swapchain
    VK_ERROR_OUT_OF_DATE_KHR = -1000001004,
    // Extension: VK_KHR_surface
    VK_ERROR_NATIVE_WINDOW_IN_USE_KHR = -1000000001,
    // Extension: VK_KHR_surface
    VK_ERROR_SURFACE_LOST_KHR = -1000000000,
    // Comment: An unknown error has occurred, due to an implementation or application bug
    VK_ERROR_UNKNOWN = -13,
    // Comment: A requested pool allocation has failed due to fragmentation of the pool's memory
    VK_ERROR_FRAGMENTED_POOL = -12,
    // Comment: Requested format is not supported on this device
    VK_ERROR_FORMAT_NOT_SUPPORTED = -11,
    // Comment: Too many objects of the type have already been created
    VK_ERROR_TOO_MANY_OBJECTS = -10,
    // Comment: Unable to find a Vulkan driver
    VK_ERROR_INCOMPATIBLE_DRIVER = -9,
    // Comment: Requested feature is not available on this device
    VK_ERROR_FEATURE_NOT_PRESENT = -8,
    // Comment: Extension specified does not exist
    VK_ERROR_EXTENSION_NOT_PRESENT = -7,
    // Comment: Layer specified does not exist
    VK_ERROR_LAYER_NOT_PRESENT = -6,
    // Comment: Mapping of a memory object has failed
    VK_ERROR_MEMORY_MAP_FAILED = -5,
    // Comment: The logical device has been lost. See &lt;&lt;devsandqueues-lost-device&gt;&gt;
    VK_ERROR_DEVICE_LOST = -4,
    // Comment: Initialization of an object has failed
    VK_ERROR_INITIALIZATION_FAILED = -3,
    // Comment: A device memory allocation has failed
    VK_ERROR_OUT_OF_DEVICE_MEMORY = -2,
    // Comment: A host memory allocation has failed
    VK_ERROR_OUT_OF_HOST_MEMORY = -1,
    // Comment: Command completed successfully
    VK_SUCCESS = 0,
    // Comment: A fence or query has not yet completed
    VK_NOT_READY = 1,
    // Comment: A wait operation has not completed in the specified time
    VK_TIMEOUT = 2,
    // Comment: An event is signaled
    VK_EVENT_SET = 3,
    // Comment: An event is unsignaled
    VK_EVENT_RESET = 4,
    // Comment: A return array was too small for the result
    VK_INCOMPLETE = 5,
    // Extension: VK_KHR_swapchain
    VK_SUBOPTIMAL_KHR = 1000001003,
    // Extension: VK_KHR_deferred_host_operations
    VK_THREAD_IDLE_KHR = 1000268000,
    // Extension: VK_KHR_deferred_host_operations
    VK_THREAD_DONE_KHR = 1000268001,
    // Extension: VK_KHR_deferred_host_operations
    VK_OPERATION_DEFERRED_KHR = 1000268002,
    // Extension: VK_KHR_deferred_host_operations
    VK_OPERATION_NOT_DEFERRED_KHR = 1000268003,
    // Extension: VK_COMPUTE_VERSION_1_3
    // Alias: VK_PIPELINE_COMPILE_REQUIRED_EXT
    // Alias: VK_ERROR_PIPELINE_COMPILE_REQUIRED_EXT
    VK_PIPELINE_COMPILE_REQUIRED = 1000297000,
    // Extension: VK_EXT_shader_object
    // Alias: VK_ERROR_INCOMPATIBLE_SHADER_BINARY_EXT
    VK_INCOMPATIBLE_SHADER_BINARY_EXT = 1000482000,
    // Extension: VK_KHR_pipeline_binary
    VK_PIPELINE_BINARY_MISSING_KHR = 1000483000,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkDynamicState = enum(u32) {
    VK_DYNAMIC_STATE_VIEWPORT = 0,
    VK_DYNAMIC_STATE_SCISSOR = 1,
    VK_DYNAMIC_STATE_LINE_WIDTH = 2,
    VK_DYNAMIC_STATE_DEPTH_BIAS = 3,
    VK_DYNAMIC_STATE_BLEND_CONSTANTS = 4,
    VK_DYNAMIC_STATE_DEPTH_BOUNDS = 5,
    VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK = 6,
    VK_DYNAMIC_STATE_STENCIL_WRITE_MASK = 7,
    VK_DYNAMIC_STATE_STENCIL_REFERENCE = 8,
    // Extension: VK_NV_clip_space_w_scaling
    VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV = 1000087000,
    // Extension: VK_EXT_discard_rectangles
    VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT = 1000099000,
    // Extension: VK_EXT_discard_rectangles
    VK_DYNAMIC_STATE_DISCARD_RECTANGLE_ENABLE_EXT = 1000099001,
    // Extension: VK_EXT_discard_rectangles
    VK_DYNAMIC_STATE_DISCARD_RECTANGLE_MODE_EXT = 1000099002,
    // Extension: VK_EXT_sample_locations
    VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT = 1000143000,
    // Extension: VK_NV_shading_rate_image
    VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV = 1000164004,
    // Extension: VK_NV_shading_rate_image
    VK_DYNAMIC_STATE_VIEWPORT_COARSE_SAMPLE_ORDER_NV = 1000164006,
    // Extension: VK_NV_scissor_exclusive
    VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_ENABLE_NV = 1000205000,
    // Extension: VK_NV_scissor_exclusive
    VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_NV = 1000205001,
    // Extension: VK_KHR_fragment_shading_rate
    VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR = 1000226000,
    // Extension: VK_GRAPHICS_VERSION_1_4
    // Alias: VK_DYNAMIC_STATE_LINE_STIPPLE_EXT
    // Alias: VK_DYNAMIC_STATE_LINE_STIPPLE_KHR
    VK_DYNAMIC_STATE_LINE_STIPPLE = 1000259000,
    // Extension: VK_GRAPHICS_VERSION_1_3
    // Alias: VK_DYNAMIC_STATE_CULL_MODE_EXT
    VK_DYNAMIC_STATE_CULL_MODE = 1000267000,
    // Extension: VK_GRAPHICS_VERSION_1_3
    // Alias: VK_DYNAMIC_STATE_FRONT_FACE_EXT
    VK_DYNAMIC_STATE_FRONT_FACE = 1000267001,
    // Extension: VK_GRAPHICS_VERSION_1_3
    // Alias: VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY_EXT
    VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY = 1000267002,
    // Extension: VK_GRAPHICS_VERSION_1_3
    // Alias: VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT_EXT
    VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT = 1000267003,
    // Extension: VK_GRAPHICS_VERSION_1_3
    // Alias: VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT_EXT
    VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT = 1000267004,
    // Extension: VK_GRAPHICS_VERSION_1_3
    // Alias: VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE_EXT
    VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE = 1000267005,
    // Extension: VK_GRAPHICS_VERSION_1_3
    // Alias: VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE_EXT
    VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE = 1000267006,
    // Extension: VK_GRAPHICS_VERSION_1_3
    // Alias: VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE_EXT
    VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE = 1000267007,
    // Extension: VK_GRAPHICS_VERSION_1_3
    // Alias: VK_DYNAMIC_STATE_DEPTH_COMPARE_OP_EXT
    VK_DYNAMIC_STATE_DEPTH_COMPARE_OP = 1000267008,
    // Extension: VK_GRAPHICS_VERSION_1_3
    // Alias: VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE_EXT
    VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE = 1000267009,
    // Extension: VK_GRAPHICS_VERSION_1_3
    // Alias: VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE_EXT
    VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE = 1000267010,
    // Extension: VK_GRAPHICS_VERSION_1_3
    // Alias: VK_DYNAMIC_STATE_STENCIL_OP_EXT
    VK_DYNAMIC_STATE_STENCIL_OP = 1000267011,
    // Extension: VK_KHR_ray_tracing_pipeline
    VK_DYNAMIC_STATE_RAY_TRACING_PIPELINE_STACK_SIZE_KHR = 1000347000,
    // Extension: VK_EXT_vertex_input_dynamic_state
    VK_DYNAMIC_STATE_VERTEX_INPUT_EXT = 1000352000,
    // Extension: VK_EXT_extended_dynamic_state2
    VK_DYNAMIC_STATE_PATCH_CONTROL_POINTS_EXT = 1000377000,
    // Extension: VK_GRAPHICS_VERSION_1_3
    // Alias: VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE_EXT
    VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE = 1000377001,
    // Extension: VK_GRAPHICS_VERSION_1_3
    // Alias: VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE_EXT
    VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE = 1000377002,
    // Extension: VK_EXT_extended_dynamic_state2
    VK_DYNAMIC_STATE_LOGIC_OP_EXT = 1000377003,
    // Extension: VK_GRAPHICS_VERSION_1_3
    // Alias: VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE_EXT
    VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE = 1000377004,
    // Extension: VK_EXT_color_write_enable
    VK_DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT = 1000381000,
    // Extension: VK_EXT_extended_dynamic_state3
    VK_DYNAMIC_STATE_TESSELLATION_DOMAIN_ORIGIN_EXT = 1000455002,
    // Extension: VK_EXT_extended_dynamic_state3
    VK_DYNAMIC_STATE_DEPTH_CLAMP_ENABLE_EXT = 1000455003,
    // Extension: VK_EXT_extended_dynamic_state3
    VK_DYNAMIC_STATE_POLYGON_MODE_EXT = 1000455004,
    // Extension: VK_EXT_extended_dynamic_state3
    VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT = 1000455005,
    // Extension: VK_EXT_extended_dynamic_state3
    VK_DYNAMIC_STATE_SAMPLE_MASK_EXT = 1000455006,
    // Extension: VK_EXT_extended_dynamic_state3
    VK_DYNAMIC_STATE_ALPHA_TO_COVERAGE_ENABLE_EXT = 1000455007,
    // Extension: VK_EXT_extended_dynamic_state3
    VK_DYNAMIC_STATE_ALPHA_TO_ONE_ENABLE_EXT = 1000455008,
    // Extension: VK_EXT_extended_dynamic_state3
    VK_DYNAMIC_STATE_LOGIC_OP_ENABLE_EXT = 1000455009,
    // Extension: VK_EXT_extended_dynamic_state3
    VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT = 1000455010,
    // Extension: VK_EXT_extended_dynamic_state3
    VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT = 1000455011,
    // Extension: VK_EXT_extended_dynamic_state3
    VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT = 1000455012,
    // Extension: VK_EXT_extended_dynamic_state3
    VK_DYNAMIC_STATE_RASTERIZATION_STREAM_EXT = 1000455013,
    // Extension: VK_EXT_extended_dynamic_state3
    VK_DYNAMIC_STATE_CONSERVATIVE_RASTERIZATION_MODE_EXT = 1000455014,
    // Extension: VK_EXT_extended_dynamic_state3
    VK_DYNAMIC_STATE_EXTRA_PRIMITIVE_OVERESTIMATION_SIZE_EXT = 1000455015,
    // Extension: VK_EXT_extended_dynamic_state3
    VK_DYNAMIC_STATE_DEPTH_CLIP_ENABLE_EXT = 1000455016,
    // Extension: VK_EXT_extended_dynamic_state3
    VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT = 1000455017,
    // Extension: VK_EXT_extended_dynamic_state3
    VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT = 1000455018,
    // Extension: VK_EXT_extended_dynamic_state3
    VK_DYNAMIC_STATE_PROVOKING_VERTEX_MODE_EXT = 1000455019,
    // Extension: VK_EXT_extended_dynamic_state3
    VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT = 1000455020,
    // Extension: VK_EXT_extended_dynamic_state3
    VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT = 1000455021,
    // Extension: VK_EXT_extended_dynamic_state3
    VK_DYNAMIC_STATE_DEPTH_CLIP_NEGATIVE_ONE_TO_ONE_EXT = 1000455022,
    // Extension: VK_EXT_extended_dynamic_state3
    VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_ENABLE_NV = 1000455023,
    // Extension: VK_EXT_extended_dynamic_state3
    VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV = 1000455024,
    // Extension: VK_EXT_extended_dynamic_state3
    VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV = 1000455025,
    // Extension: VK_EXT_extended_dynamic_state3
    VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_LOCATION_NV = 1000455026,
    // Extension: VK_EXT_extended_dynamic_state3
    VK_DYNAMIC_STATE_COVERAGE_MODULATION_MODE_NV = 1000455027,
    // Extension: VK_EXT_extended_dynamic_state3
    VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_ENABLE_NV = 1000455028,
    // Extension: VK_EXT_extended_dynamic_state3
    VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_NV = 1000455029,
    // Extension: VK_EXT_extended_dynamic_state3
    VK_DYNAMIC_STATE_SHADING_RATE_IMAGE_ENABLE_NV = 1000455030,
    // Extension: VK_EXT_extended_dynamic_state3
    VK_DYNAMIC_STATE_REPRESENTATIVE_FRAGMENT_TEST_ENABLE_NV = 1000455031,
    // Extension: VK_EXT_extended_dynamic_state3
    VK_DYNAMIC_STATE_COVERAGE_REDUCTION_MODE_NV = 1000455032,
    // Extension: VK_EXT_attachment_feedback_loop_dynamic_state
    VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT = 1000524000,
    // Extension: VK_EXT_depth_clamp_control
    VK_DYNAMIC_STATE_DEPTH_CLAMP_RANGE_EXT = 1000582000,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkDescriptorUpdateTemplateType = enum(u32) {
    // Alias: VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET_KHR
    // Comment: Create descriptor update template for descriptor set updates
    VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET = 0,
    // Extension: VK_COMPUTE_VERSION_1_4
    // Alias: VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR
    // Alias: VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR
    VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS = 1,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkObjectType = enum(u32) {
    VK_OBJECT_TYPE_UNKNOWN = 0,
    VK_OBJECT_TYPE_INSTANCE = 1,
    VK_OBJECT_TYPE_PHYSICAL_DEVICE = 2,
    VK_OBJECT_TYPE_DEVICE = 3,
    VK_OBJECT_TYPE_QUEUE = 4,
    VK_OBJECT_TYPE_SEMAPHORE = 5,
    VK_OBJECT_TYPE_COMMAND_BUFFER = 6,
    VK_OBJECT_TYPE_FENCE = 7,
    VK_OBJECT_TYPE_DEVICE_MEMORY = 8,
    VK_OBJECT_TYPE_BUFFER = 9,
    VK_OBJECT_TYPE_IMAGE = 10,
    VK_OBJECT_TYPE_EVENT = 11,
    VK_OBJECT_TYPE_QUERY_POOL = 12,
    VK_OBJECT_TYPE_BUFFER_VIEW = 13,
    VK_OBJECT_TYPE_IMAGE_VIEW = 14,
    VK_OBJECT_TYPE_SHADER_MODULE = 15,
    VK_OBJECT_TYPE_PIPELINE_CACHE = 16,
    VK_OBJECT_TYPE_PIPELINE_LAYOUT = 17,
    VK_OBJECT_TYPE_RENDER_PASS = 18,
    VK_OBJECT_TYPE_PIPELINE = 19,
    VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT = 20,
    VK_OBJECT_TYPE_SAMPLER = 21,
    VK_OBJECT_TYPE_DESCRIPTOR_POOL = 22,
    VK_OBJECT_TYPE_DESCRIPTOR_SET = 23,
    VK_OBJECT_TYPE_FRAMEBUFFER = 24,
    VK_OBJECT_TYPE_COMMAND_POOL = 25,
    // Extension: VK_KHR_surface
    VK_OBJECT_TYPE_SURFACE_KHR = 1000000000,
    // Extension: VK_KHR_swapchain
    VK_OBJECT_TYPE_SWAPCHAIN_KHR = 1000001000,
    // Extension: VK_KHR_display
    VK_OBJECT_TYPE_DISPLAY_KHR = 1000002000,
    // Extension: VK_KHR_display
    VK_OBJECT_TYPE_DISPLAY_MODE_KHR = 1000002001,
    // Extension: VK_EXT_debug_report
    VK_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT = 1000011000,
    // Extension: VK_KHR_video_queue
    VK_OBJECT_TYPE_VIDEO_SESSION_KHR = 1000023000,
    // Extension: VK_KHR_video_queue
    VK_OBJECT_TYPE_VIDEO_SESSION_PARAMETERS_KHR = 1000023001,
    // Extension: VK_NVX_binary_import
    VK_OBJECT_TYPE_CU_MODULE_NVX = 1000029000,
    // Extension: VK_NVX_binary_import
    VK_OBJECT_TYPE_CU_FUNCTION_NVX = 1000029001,
    // Extension: VK_COMPUTE_VERSION_1_1
    // Alias: VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR
    VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE = 1000085000,
    // Extension: VK_EXT_debug_utils
    VK_OBJECT_TYPE_DEBUG_UTILS_MESSENGER_EXT = 1000128000,
    // Extension: VK_KHR_acceleration_structure
    VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_KHR = 1000150000,
    // Extension: VK_COMPUTE_VERSION_1_1
    // Alias: VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR
    VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION = 1000156000,
    // Extension: VK_EXT_validation_cache
    VK_OBJECT_TYPE_VALIDATION_CACHE_EXT = 1000160000,
    // Extension: VK_NV_ray_tracing
    VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV = 1000165000,
    // Extension: VK_INTEL_performance_query
    VK_OBJECT_TYPE_PERFORMANCE_CONFIGURATION_INTEL = 1000210000,
    // Extension: VK_KHR_deferred_host_operations
    VK_OBJECT_TYPE_DEFERRED_OPERATION_KHR = 1000268000,
    // Extension: VK_NV_device_generated_commands
    VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NV = 1000277000,
    // Extension: VK_BASE_VERSION_1_3
    // Alias: VK_OBJECT_TYPE_PRIVATE_DATA_SLOT_EXT
    VK_OBJECT_TYPE_PRIVATE_DATA_SLOT = 1000295000,
    // Extension: VK_NV_cuda_kernel_launch
    VK_OBJECT_TYPE_CUDA_MODULE_NV = 1000307000,
    // Extension: VK_NV_cuda_kernel_launch
    VK_OBJECT_TYPE_CUDA_FUNCTION_NV = 1000307001,
    // Extension: VK_FUCHSIA_buffer_collection
    VK_OBJECT_TYPE_BUFFER_COLLECTION_FUCHSIA = 1000366000,
    // Extension: VK_EXT_opacity_micromap
    VK_OBJECT_TYPE_MICROMAP_EXT = 1000396000,
    // Extension: VK_ARM_tensors
    VK_OBJECT_TYPE_TENSOR_ARM = 1000460000,
    // Extension: VK_ARM_tensors
    VK_OBJECT_TYPE_TENSOR_VIEW_ARM = 1000460001,
    // Extension: VK_NV_optical_flow
    VK_OBJECT_TYPE_OPTICAL_FLOW_SESSION_NV = 1000464000,
    // Extension: VK_EXT_shader_object
    VK_OBJECT_TYPE_SHADER_EXT = 1000482000,
    // Extension: VK_KHR_pipeline_binary
    VK_OBJECT_TYPE_PIPELINE_BINARY_KHR = 1000483000,
    // Extension: VK_NV_external_sci_sync2
    VK_OBJECT_TYPE_SEMAPHORE_SCI_SYNC_POOL_NV = 1000489000,
    // Extension: VK_ARM_data_graph
    VK_OBJECT_TYPE_DATA_GRAPH_PIPELINE_SESSION_ARM = 1000507000,
    // Extension: VK_NV_external_compute_queue
    VK_OBJECT_TYPE_EXTERNAL_COMPUTE_QUEUE_NV = 1000556000,
    // Extension: VK_EXT_device_generated_commands
    VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_EXT = 1000572000,
    // Extension: VK_EXT_device_generated_commands
    VK_OBJECT_TYPE_INDIRECT_EXECUTION_SET_EXT = 1000572001,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkRayTracingInvocationReorderModeEXT = enum(u32) {
    // Alias: VK_RAY_TRACING_INVOCATION_REORDER_MODE_NONE_NV
    VK_RAY_TRACING_INVOCATION_REORDER_MODE_NONE_EXT = 0,
    // Alias: VK_RAY_TRACING_INVOCATION_REORDER_MODE_REORDER_NV
    VK_RAY_TRACING_INVOCATION_REORDER_MODE_REORDER_EXT = 1,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkRayTracingLssIndexingModeNV = enum(u32) {
    VK_RAY_TRACING_LSS_INDEXING_MODE_LIST_NV = 0,
    VK_RAY_TRACING_LSS_INDEXING_MODE_SUCCESSIVE_NV = 1,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkRayTracingLssPrimitiveEndCapsModeNV = enum(u32) {
    VK_RAY_TRACING_LSS_PRIMITIVE_END_CAPS_MODE_NONE_NV = 0,
    VK_RAY_TRACING_LSS_PRIMITIVE_END_CAPS_MODE_CHAINED_NV = 1,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkDirectDriverLoadingModeLUNARG = enum(u32) {
    VK_DIRECT_DRIVER_LOADING_MODE_EXCLUSIVE_LUNARG = 0,
    VK_DIRECT_DRIVER_LOADING_MODE_INCLUSIVE_LUNARG = 1,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkAntiLagModeAMD = enum(u32) {
    VK_ANTI_LAG_MODE_DRIVER_CONTROL_AMD = 0,
    VK_ANTI_LAG_MODE_ON_AMD = 1,
    VK_ANTI_LAG_MODE_OFF_AMD = 2,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkAntiLagStageAMD = enum(u32) {
    VK_ANTI_LAG_STAGE_INPUT_AMD = 0,
    VK_ANTI_LAG_STAGE_PRESENT_AMD = 1,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkSemaphoreType = enum(u32) {
    // Alias: VK_SEMAPHORE_TYPE_BINARY_KHR
    VK_SEMAPHORE_TYPE_BINARY = 0,
    // Alias: VK_SEMAPHORE_TYPE_TIMELINE_KHR
    VK_SEMAPHORE_TYPE_TIMELINE = 1,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkPresentModeKHR = enum(u32) {
    VK_PRESENT_MODE_IMMEDIATE_KHR = 0,
    VK_PRESENT_MODE_MAILBOX_KHR = 1,
    VK_PRESENT_MODE_FIFO_KHR = 2,
    VK_PRESENT_MODE_FIFO_RELAXED_KHR = 3,
    // Extension: VK_KHR_shared_presentable_image
    VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR = 1000111000,
    // Extension: VK_KHR_shared_presentable_image
    VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR = 1000111001,
    // Extension: VK_KHR_present_mode_fifo_latest_ready
    // Alias: VK_PRESENT_MODE_FIFO_LATEST_READY_EXT
    VK_PRESENT_MODE_FIFO_LATEST_READY_KHR = 1000361000,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkColorSpaceKHR = enum(u32) {
    VK_COLOR_SPACE_SRGB_NONLINEAR_KHR = 0,
    // Extension: VK_EXT_swapchain_colorspace
    VK_COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT = 1000104001,
    // Extension: VK_EXT_swapchain_colorspace
    VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT = 1000104002,
    // Extension: VK_EXT_swapchain_colorspace
    // Alias: VK_COLOR_SPACE_DCI_P3_LINEAR_EXT
    VK_COLOR_SPACE_DISPLAY_P3_LINEAR_EXT = 1000104003,
    // Extension: VK_EXT_swapchain_colorspace
    VK_COLOR_SPACE_DCI_P3_NONLINEAR_EXT = 1000104004,
    // Extension: VK_EXT_swapchain_colorspace
    VK_COLOR_SPACE_BT709_LINEAR_EXT = 1000104005,
    // Extension: VK_EXT_swapchain_colorspace
    VK_COLOR_SPACE_BT709_NONLINEAR_EXT = 1000104006,
    // Extension: VK_EXT_swapchain_colorspace
    VK_COLOR_SPACE_BT2020_LINEAR_EXT = 1000104007,
    // Extension: VK_EXT_swapchain_colorspace
    VK_COLOR_SPACE_HDR10_ST2084_EXT = 1000104008,
    // Extension: VK_EXT_swapchain_colorspace
    VK_COLOR_SPACE_DOLBYVISION_EXT = 1000104009,
    // Extension: VK_EXT_swapchain_colorspace
    VK_COLOR_SPACE_HDR10_HLG_EXT = 1000104010,
    // Extension: VK_EXT_swapchain_colorspace
    VK_COLOR_SPACE_ADOBERGB_LINEAR_EXT = 1000104011,
    // Extension: VK_EXT_swapchain_colorspace
    VK_COLOR_SPACE_ADOBERGB_NONLINEAR_EXT = 1000104012,
    // Extension: VK_EXT_swapchain_colorspace
    VK_COLOR_SPACE_PASS_THROUGH_EXT = 1000104013,
    // Extension: VK_EXT_swapchain_colorspace
    VK_COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT = 1000104014,
    // Extension: VK_AMD_display_native_hdr
    VK_COLOR_SPACE_DISPLAY_NATIVE_AMD = 1000213000,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkDisplaySurfaceStereoTypeNV = enum(u32) {
    VK_DISPLAY_SURFACE_STEREO_TYPE_NONE_NV = 0,
    VK_DISPLAY_SURFACE_STEREO_TYPE_ONBOARD_DIN_NV = 1,
    VK_DISPLAY_SURFACE_STEREO_TYPE_HDMI_3D_NV = 2,
    VK_DISPLAY_SURFACE_STEREO_TYPE_INBAND_DISPLAYPORT_NV = 3,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkTimeDomainKHR = enum(u32) {
    // Alias: VK_TIME_DOMAIN_DEVICE_EXT
    VK_TIME_DOMAIN_DEVICE_KHR = 0,
    // Alias: VK_TIME_DOMAIN_CLOCK_MONOTONIC_EXT
    VK_TIME_DOMAIN_CLOCK_MONOTONIC_KHR = 1,
    // Alias: VK_TIME_DOMAIN_CLOCK_MONOTONIC_RAW_EXT
    VK_TIME_DOMAIN_CLOCK_MONOTONIC_RAW_KHR = 2,
    // Alias: VK_TIME_DOMAIN_QUERY_PERFORMANCE_COUNTER_EXT
    VK_TIME_DOMAIN_QUERY_PERFORMANCE_COUNTER_KHR = 3,
    // Extension: VK_EXT_present_timing
    VK_TIME_DOMAIN_PRESENT_STAGE_LOCAL_EXT = 1000208000,
    // Extension: VK_EXT_present_timing
    VK_TIME_DOMAIN_SWAPCHAIN_LOCAL_EXT = 1000208001,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkDebugReportObjectTypeEXT = enum(u32) {
    VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT = 0,
    VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT = 1,
    VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT = 2,
    VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT = 3,
    VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT = 4,
    VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT = 5,
    VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT = 6,
    VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT = 7,
    VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT = 8,
    VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT = 9,
    VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT = 10,
    VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT = 11,
    VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT = 12,
    VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT = 13,
    VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT = 14,
    VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT = 15,
    VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT = 16,
    VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT = 17,
    VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT = 18,
    VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT = 19,
    VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT = 20,
    VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT = 21,
    VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT = 22,
    VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT = 23,
    VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT = 24,
    VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT = 25,
    VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT = 26,
    VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT = 27,
    VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT = 28,
    VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_KHR_EXT = 29,
    VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_MODE_KHR_EXT = 30,
    VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT = 33,
    // Extension: VK_NVX_binary_import
    VK_DEBUG_REPORT_OBJECT_TYPE_CU_MODULE_NVX_EXT = 1000029000,
    // Extension: VK_NVX_binary_import
    VK_DEBUG_REPORT_OBJECT_TYPE_CU_FUNCTION_NVX_EXT = 1000029001,
    // Extension: VK_EXT_debug_report
    // Alias: VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR_EXT
    VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_EXT = 1000085000,
    // Extension: VK_KHR_acceleration_structure
    VK_DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_KHR_EXT = 1000150000,
    // Extension: VK_EXT_debug_report
    // Extension: VK_KHR_sampler_ycbcr_conversion
    // Alias: VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR_EXT
    VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT = 1000156000,
    // Extension: VK_NV_ray_tracing
    VK_DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV_EXT = 1000165000,
    // Extension: VK_NV_cuda_kernel_launch
    VK_DEBUG_REPORT_OBJECT_TYPE_CUDA_MODULE_NV_EXT = 1000307000,
    // Extension: VK_NV_cuda_kernel_launch
    VK_DEBUG_REPORT_OBJECT_TYPE_CUDA_FUNCTION_NV_EXT = 1000307001,
    // Extension: VK_FUCHSIA_buffer_collection
    VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_COLLECTION_FUCHSIA_EXT = 1000366000,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkDeviceMemoryReportEventTypeEXT = enum(u32) {
    VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATE_EXT = 0,
    VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_FREE_EXT = 1,
    VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_IMPORT_EXT = 2,
    VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_UNIMPORT_EXT = 3,
    VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATION_FAILED_EXT = 4,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkRasterizationOrderAMD = enum(u32) {
    VK_RASTERIZATION_ORDER_STRICT_AMD = 0,
    VK_RASTERIZATION_ORDER_RELAXED_AMD = 1,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkClusterAccelerationStructureTypeNV = enum(u32) {
    VK_CLUSTER_ACCELERATION_STRUCTURE_TYPE_CLUSTERS_BOTTOM_LEVEL_NV = 0,
    VK_CLUSTER_ACCELERATION_STRUCTURE_TYPE_TRIANGLE_CLUSTER_NV = 1,
    VK_CLUSTER_ACCELERATION_STRUCTURE_TYPE_TRIANGLE_CLUSTER_TEMPLATE_NV = 2,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkClusterAccelerationStructureOpTypeNV = enum(u32) {
    VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_MOVE_OBJECTS_NV = 0,
    VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_BUILD_CLUSTERS_BOTTOM_LEVEL_NV = 1,
    VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_BUILD_TRIANGLE_CLUSTER_NV = 2,
    VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_BUILD_TRIANGLE_CLUSTER_TEMPLATE_NV = 3,
    VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_INSTANTIATE_TRIANGLE_CLUSTER_NV = 4,
    VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_GET_CLUSTER_TEMPLATE_INDICES_NV = 5,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkClusterAccelerationStructureOpModeNV = enum(u32) {
    VK_CLUSTER_ACCELERATION_STRUCTURE_OP_MODE_IMPLICIT_DESTINATIONS_NV = 0,
    VK_CLUSTER_ACCELERATION_STRUCTURE_OP_MODE_EXPLICIT_DESTINATIONS_NV = 1,
    VK_CLUSTER_ACCELERATION_STRUCTURE_OP_MODE_COMPUTE_SIZES_NV = 2,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkValidationCheckEXT = enum(u32) {
    VK_VALIDATION_CHECK_ALL_EXT = 0,
    VK_VALIDATION_CHECK_SHADERS_EXT = 1,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkValidationFeatureEnableEXT = enum(u32) {
    VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_EXT = 0,
    VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_RESERVE_BINDING_SLOT_EXT = 1,
    VK_VALIDATION_FEATURE_ENABLE_BEST_PRACTICES_EXT = 2,
    VK_VALIDATION_FEATURE_ENABLE_DEBUG_PRINTF_EXT = 3,
    VK_VALIDATION_FEATURE_ENABLE_SYNCHRONIZATION_VALIDATION_EXT = 4,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkValidationFeatureDisableEXT = enum(u32) {
    VK_VALIDATION_FEATURE_DISABLE_ALL_EXT = 0,
    VK_VALIDATION_FEATURE_DISABLE_SHADERS_EXT = 1,
    VK_VALIDATION_FEATURE_DISABLE_THREAD_SAFETY_EXT = 2,
    VK_VALIDATION_FEATURE_DISABLE_API_PARAMETERS_EXT = 3,
    VK_VALIDATION_FEATURE_DISABLE_OBJECT_LIFETIMES_EXT = 4,
    VK_VALIDATION_FEATURE_DISABLE_CORE_CHECKS_EXT = 5,
    VK_VALIDATION_FEATURE_DISABLE_UNIQUE_HANDLES_EXT = 6,
    VK_VALIDATION_FEATURE_DISABLE_SHADER_VALIDATION_CACHE_EXT = 7,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkLayerSettingTypeEXT = enum(u32) {
    VK_LAYER_SETTING_TYPE_BOOL32_EXT = 0,
    VK_LAYER_SETTING_TYPE_INT32_EXT = 1,
    VK_LAYER_SETTING_TYPE_INT64_EXT = 2,
    VK_LAYER_SETTING_TYPE_UINT32_EXT = 3,
    VK_LAYER_SETTING_TYPE_UINT64_EXT = 4,
    VK_LAYER_SETTING_TYPE_FLOAT32_EXT = 5,
    VK_LAYER_SETTING_TYPE_FLOAT64_EXT = 6,
    VK_LAYER_SETTING_TYPE_STRING_EXT = 7,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkIndirectCommandsTokenTypeNV = enum(u32) {
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_SHADER_GROUP_NV = 0,
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_STATE_FLAGS_NV = 1,
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_NV = 2,
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_NV = 3,
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NV = 4,
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_NV = 5,
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_NV = 6,
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_TASKS_NV = 7,
    // Extension: VK_EXT_mesh_shader
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_NV = 1000328000,
    // Extension: VK_NV_device_generated_commands_compute
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_PIPELINE_NV = 1000428003,
    // Extension: VK_NV_device_generated_commands_compute
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_NV = 1000428004,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkDisplayPowerStateEXT = enum(u32) {
    VK_DISPLAY_POWER_STATE_OFF_EXT = 0,
    VK_DISPLAY_POWER_STATE_SUSPEND_EXT = 1,
    VK_DISPLAY_POWER_STATE_ON_EXT = 2,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkDeviceEventTypeEXT = enum(u32) {
    VK_DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG_EXT = 0,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkDisplayEventTypeEXT = enum(u32) {
    VK_DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT_EXT = 0,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkViewportCoordinateSwizzleNV = enum(u32) {
    VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_X_NV = 0,
    VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_X_NV = 1,
    VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Y_NV = 2,
    VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Y_NV = 3,
    VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Z_NV = 4,
    VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Z_NV = 5,
    VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_W_NV = 6,
    VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_W_NV = 7,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkDiscardRectangleModeEXT = enum(u32) {
    VK_DISCARD_RECTANGLE_MODE_INCLUSIVE_EXT = 0,
    VK_DISCARD_RECTANGLE_MODE_EXCLUSIVE_EXT = 1,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkPointClippingBehavior = enum(u32) {
    // Alias: VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES_KHR
    VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES = 0,
    // Alias: VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY_KHR
    VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY = 1,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkSamplerReductionMode = enum(u32) {
    // Alias: VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_EXT
    VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE = 0,
    // Alias: VK_SAMPLER_REDUCTION_MODE_MIN_EXT
    VK_SAMPLER_REDUCTION_MODE_MIN = 1,
    // Alias: VK_SAMPLER_REDUCTION_MODE_MAX_EXT
    VK_SAMPLER_REDUCTION_MODE_MAX = 2,
    // Extension: VK_QCOM_filter_cubic_clamp
    VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_RANGECLAMP_QCOM = 1000521000,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkTessellationDomainOrigin = enum(u32) {
    // Alias: VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT_KHR
    VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT = 0,
    // Alias: VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT_KHR
    VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT = 1,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkSamplerYcbcrModelConversion = enum(u32) {
    // Alias: VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY_KHR
    VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY = 0,
    // Alias: VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY_KHR
    // Comment: just range expansion
    VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY = 1,
    // Alias: VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709_KHR
    // Comment: aka HD YUV
    VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709 = 2,
    // Alias: VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601_KHR
    // Comment: aka SD YUV
    VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601 = 3,
    // Alias: VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020_KHR
    // Comment: aka UHD YUV
    VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020 = 4,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkSamplerYcbcrRange = enum(u32) {
    // Alias: VK_SAMPLER_YCBCR_RANGE_ITU_FULL_KHR
    // Comment: Luma 0..1 maps to 0..255, chroma -0.5..0.5 to 1..255 (clamped)
    VK_SAMPLER_YCBCR_RANGE_ITU_FULL = 0,
    // Alias: VK_SAMPLER_YCBCR_RANGE_ITU_NARROW_KHR
    // Comment: Luma 0..1 maps to 16..235, chroma -0.5..0.5 to 16..240
    VK_SAMPLER_YCBCR_RANGE_ITU_NARROW = 1,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkChromaLocation = enum(u32) {
    // Alias: VK_CHROMA_LOCATION_COSITED_EVEN_KHR
    VK_CHROMA_LOCATION_COSITED_EVEN = 0,
    // Alias: VK_CHROMA_LOCATION_MIDPOINT_KHR
    VK_CHROMA_LOCATION_MIDPOINT = 1,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkBlendOverlapEXT = enum(u32) {
    VK_BLEND_OVERLAP_UNCORRELATED_EXT = 0,
    VK_BLEND_OVERLAP_DISJOINT_EXT = 1,
    VK_BLEND_OVERLAP_CONJOINT_EXT = 2,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkCoverageModulationModeNV = enum(u32) {
    VK_COVERAGE_MODULATION_MODE_NONE_NV = 0,
    VK_COVERAGE_MODULATION_MODE_RGB_NV = 1,
    VK_COVERAGE_MODULATION_MODE_ALPHA_NV = 2,
    VK_COVERAGE_MODULATION_MODE_RGBA_NV = 3,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkCoverageReductionModeNV = enum(u32) {
    VK_COVERAGE_REDUCTION_MODE_MERGE_NV = 0,
    VK_COVERAGE_REDUCTION_MODE_TRUNCATE_NV = 1,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkValidationCacheHeaderVersionEXT = enum(u32) {
    VK_VALIDATION_CACHE_HEADER_VERSION_ONE_EXT = 1,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkShaderInfoTypeAMD = enum(u32) {
    VK_SHADER_INFO_TYPE_STATISTICS_AMD = 0,
    VK_SHADER_INFO_TYPE_BINARY_AMD = 1,
    VK_SHADER_INFO_TYPE_DISASSEMBLY_AMD = 2,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkQueueGlobalPriority = enum(u32) {
    // Alias: VK_QUEUE_GLOBAL_PRIORITY_LOW_EXT
    // Alias: VK_QUEUE_GLOBAL_PRIORITY_LOW_KHR
    VK_QUEUE_GLOBAL_PRIORITY_LOW = 128,
    // Alias: VK_QUEUE_GLOBAL_PRIORITY_MEDIUM_EXT
    // Alias: VK_QUEUE_GLOBAL_PRIORITY_MEDIUM_KHR
    VK_QUEUE_GLOBAL_PRIORITY_MEDIUM = 256,
    // Alias: VK_QUEUE_GLOBAL_PRIORITY_HIGH_EXT
    // Alias: VK_QUEUE_GLOBAL_PRIORITY_HIGH_KHR
    VK_QUEUE_GLOBAL_PRIORITY_HIGH = 512,
    // Alias: VK_QUEUE_GLOBAL_PRIORITY_REALTIME_EXT
    // Alias: VK_QUEUE_GLOBAL_PRIORITY_REALTIME_KHR
    VK_QUEUE_GLOBAL_PRIORITY_REALTIME = 1024,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkConservativeRasterizationModeEXT = enum(u32) {
    VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT = 0,
    VK_CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT = 1,
    VK_CONSERVATIVE_RASTERIZATION_MODE_UNDERESTIMATE_EXT = 2,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkVendorId = enum(u32) {
    // Comment: Khronos vendor ID
    VK_VENDOR_ID_KHRONOS = 65536,
    // Comment: Vivante vendor ID
    VK_VENDOR_ID_VIV = 65537,
    // Comment: VeriSilicon vendor ID
    VK_VENDOR_ID_VSI = 65538,
    // Comment: Kazan Software Renderer
    VK_VENDOR_ID_KAZAN = 65539,
    // Comment: Codeplay Software Ltd. vendor ID
    VK_VENDOR_ID_CODEPLAY = 65540,
    // Comment: Mesa vendor ID
    VK_VENDOR_ID_MESA = 65541,
    // Comment: PoCL vendor ID
    VK_VENDOR_ID_POCL = 65542,
    // Comment: Mobileye vendor ID
    VK_VENDOR_ID_MOBILEYE = 65543,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkDriverId = enum(u32) {
    // Alias: VK_DRIVER_ID_AMD_PROPRIETARY_KHR
    // Comment: Advanced Micro Devices, Inc.
    VK_DRIVER_ID_AMD_PROPRIETARY = 1,
    // Alias: VK_DRIVER_ID_AMD_OPEN_SOURCE_KHR
    // Comment: Advanced Micro Devices, Inc.
    VK_DRIVER_ID_AMD_OPEN_SOURCE = 2,
    // Alias: VK_DRIVER_ID_MESA_RADV_KHR
    // Comment: Mesa open source project
    VK_DRIVER_ID_MESA_RADV = 3,
    // Alias: VK_DRIVER_ID_NVIDIA_PROPRIETARY_KHR
    // Comment: NVIDIA Corporation
    VK_DRIVER_ID_NVIDIA_PROPRIETARY = 4,
    // Alias: VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS_KHR
    // Comment: Intel Corporation
    VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS = 5,
    // Alias: VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA_KHR
    // Comment: Intel Corporation
    VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA = 6,
    // Alias: VK_DRIVER_ID_IMAGINATION_PROPRIETARY_KHR
    // Comment: Imagination Technologies
    VK_DRIVER_ID_IMAGINATION_PROPRIETARY = 7,
    // Alias: VK_DRIVER_ID_QUALCOMM_PROPRIETARY_KHR
    // Comment: Qualcomm Technologies, Inc.
    VK_DRIVER_ID_QUALCOMM_PROPRIETARY = 8,
    // Alias: VK_DRIVER_ID_ARM_PROPRIETARY_KHR
    // Comment: Arm Limited
    VK_DRIVER_ID_ARM_PROPRIETARY = 9,
    // Alias: VK_DRIVER_ID_GOOGLE_SWIFTSHADER_KHR
    // Comment: Google LLC
    VK_DRIVER_ID_GOOGLE_SWIFTSHADER = 10,
    // Alias: VK_DRIVER_ID_GGP_PROPRIETARY_KHR
    // Comment: Google LLC
    VK_DRIVER_ID_GGP_PROPRIETARY = 11,
    // Alias: VK_DRIVER_ID_BROADCOM_PROPRIETARY_KHR
    // Comment: Broadcom Inc.
    VK_DRIVER_ID_BROADCOM_PROPRIETARY = 12,
    // Comment: Mesa
    VK_DRIVER_ID_MESA_LLVMPIPE = 13,
    // Comment: MoltenVK
    VK_DRIVER_ID_MOLTENVK = 14,
    // Comment: Core Avionics &amp; Industrial Inc.
    VK_DRIVER_ID_COREAVI_PROPRIETARY = 15,
    // Comment: Juice Technologies, Inc.
    VK_DRIVER_ID_JUICE_PROPRIETARY = 16,
    // Comment: Verisilicon, Inc.
    VK_DRIVER_ID_VERISILICON_PROPRIETARY = 17,
    // Comment: Mesa open source project
    VK_DRIVER_ID_MESA_TURNIP = 18,
    // Comment: Mesa open source project
    VK_DRIVER_ID_MESA_V3DV = 19,
    // Comment: Mesa open source project
    VK_DRIVER_ID_MESA_PANVK = 20,
    // Comment: Samsung Electronics Co., Ltd.
    VK_DRIVER_ID_SAMSUNG_PROPRIETARY = 21,
    // Comment: Mesa open source project
    VK_DRIVER_ID_MESA_VENUS = 22,
    // Comment: Mesa open source project
    VK_DRIVER_ID_MESA_DOZEN = 23,
    // Comment: Mesa open source project
    VK_DRIVER_ID_MESA_NVK = 24,
    // Comment: Imagination Technologies
    VK_DRIVER_ID_IMAGINATION_OPEN_SOURCE_MESA = 25,
    // Comment: Mesa open source project
    VK_DRIVER_ID_MESA_HONEYKRISP = 26,
    // Comment: Vulkan SC Emulation on Vulkan
    VK_DRIVER_ID_VULKAN_SC_EMULATION_ON_VULKAN = 27,
    // Comment: Mesa open source project
    VK_DRIVER_ID_MESA_KOSMICKRISP = 28,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkShadingRatePaletteEntryNV = enum(u32) {
    VK_SHADING_RATE_PALETTE_ENTRY_NO_INVOCATIONS_NV = 0,
    VK_SHADING_RATE_PALETTE_ENTRY_16_INVOCATIONS_PER_PIXEL_NV = 1,
    VK_SHADING_RATE_PALETTE_ENTRY_8_INVOCATIONS_PER_PIXEL_NV = 2,
    VK_SHADING_RATE_PALETTE_ENTRY_4_INVOCATIONS_PER_PIXEL_NV = 3,
    VK_SHADING_RATE_PALETTE_ENTRY_2_INVOCATIONS_PER_PIXEL_NV = 4,
    VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_PIXEL_NV = 5,
    VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X1_PIXELS_NV = 6,
    VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_1X2_PIXELS_NV = 7,
    VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X2_PIXELS_NV = 8,
    VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X2_PIXELS_NV = 9,
    VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X4_PIXELS_NV = 10,
    VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X4_PIXELS_NV = 11,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkCoarseSampleOrderTypeNV = enum(u32) {
    VK_COARSE_SAMPLE_ORDER_TYPE_DEFAULT_NV = 0,
    VK_COARSE_SAMPLE_ORDER_TYPE_CUSTOM_NV = 1,
    VK_COARSE_SAMPLE_ORDER_TYPE_PIXEL_MAJOR_NV = 2,
    VK_COARSE_SAMPLE_ORDER_TYPE_SAMPLE_MAJOR_NV = 3,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkCopyAccelerationStructureModeKHR = enum(u32) {
    // Alias: VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_NV
    VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_KHR = 0,
    // Alias: VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_NV
    VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_KHR = 1,
    // Extension: VK_KHR_acceleration_structure
    VK_COPY_ACCELERATION_STRUCTURE_MODE_SERIALIZE_KHR = 2,
    // Extension: VK_KHR_acceleration_structure
    VK_COPY_ACCELERATION_STRUCTURE_MODE_DESERIALIZE_KHR = 3,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkBuildAccelerationStructureModeKHR = enum(u32) {
    VK_BUILD_ACCELERATION_STRUCTURE_MODE_BUILD_KHR = 0,
    VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR = 1,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkAccelerationStructureTypeKHR = enum(u32) {
    // Alias: VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_NV
    VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR = 0,
    // Alias: VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_NV
    VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR = 1,
    VK_ACCELERATION_STRUCTURE_TYPE_GENERIC_KHR = 2,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkGeometryTypeKHR = enum(u32) {
    // Alias: VK_GEOMETRY_TYPE_TRIANGLES_NV
    VK_GEOMETRY_TYPE_TRIANGLES_KHR = 0,
    // Alias: VK_GEOMETRY_TYPE_AABBS_NV
    VK_GEOMETRY_TYPE_AABBS_KHR = 1,
    VK_GEOMETRY_TYPE_INSTANCES_KHR = 2,
    // Extension: VK_NV_ray_tracing_linear_swept_spheres
    VK_GEOMETRY_TYPE_SPHERES_NV = 1000429004,
    // Extension: VK_NV_ray_tracing_linear_swept_spheres
    VK_GEOMETRY_TYPE_LINEAR_SWEPT_SPHERES_NV = 1000429005,
    // Extension: VK_AMDX_dense_geometry_format
    VK_GEOMETRY_TYPE_DENSE_GEOMETRY_FORMAT_TRIANGLES_AMDX = 1000478000,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkAccelerationStructureMemoryRequirementsTypeNV = enum(u32) {
    VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_OBJECT_NV = 0,
    VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_BUILD_SCRATCH_NV = 1,
    VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_UPDATE_SCRATCH_NV = 2,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkAccelerationStructureBuildTypeKHR = enum(u32) {
    VK_ACCELERATION_STRUCTURE_BUILD_TYPE_HOST_KHR = 0,
    VK_ACCELERATION_STRUCTURE_BUILD_TYPE_DEVICE_KHR = 1,
    VK_ACCELERATION_STRUCTURE_BUILD_TYPE_HOST_OR_DEVICE_KHR = 2,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkRayTracingShaderGroupTypeKHR = enum(u32) {
    // Alias: VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_NV
    VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR = 0,
    // Alias: VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_NV
    VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_KHR = 1,
    // Alias: VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_NV
    VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_KHR = 2,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkAccelerationStructureCompatibilityKHR = enum(u32) {
    VK_ACCELERATION_STRUCTURE_COMPATIBILITY_COMPATIBLE_KHR = 0,
    VK_ACCELERATION_STRUCTURE_COMPATIBILITY_INCOMPATIBLE_KHR = 1,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkShaderGroupShaderKHR = enum(u32) {
    VK_SHADER_GROUP_SHADER_GENERAL_KHR = 0,
    VK_SHADER_GROUP_SHADER_CLOSEST_HIT_KHR = 1,
    VK_SHADER_GROUP_SHADER_ANY_HIT_KHR = 2,
    VK_SHADER_GROUP_SHADER_INTERSECTION_KHR = 3,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkMemoryOverallocationBehaviorAMD = enum(u32) {
    VK_MEMORY_OVERALLOCATION_BEHAVIOR_DEFAULT_AMD = 0,
    VK_MEMORY_OVERALLOCATION_BEHAVIOR_ALLOWED_AMD = 1,
    VK_MEMORY_OVERALLOCATION_BEHAVIOR_DISALLOWED_AMD = 2,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkFullScreenExclusiveEXT = enum(u32) {
    VK_FULL_SCREEN_EXCLUSIVE_DEFAULT_EXT = 0,
    VK_FULL_SCREEN_EXCLUSIVE_ALLOWED_EXT = 1,
    VK_FULL_SCREEN_EXCLUSIVE_DISALLOWED_EXT = 2,
    VK_FULL_SCREEN_EXCLUSIVE_APPLICATION_CONTROLLED_EXT = 3,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkPerformanceCounterScopeKHR = enum(u32) {
    VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_BUFFER_KHR = 0,
    VK_PERFORMANCE_COUNTER_SCOPE_RENDER_PASS_KHR = 1,
    VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_KHR = 2,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkPerformanceCounterUnitKHR = enum(u32) {
    VK_PERFORMANCE_COUNTER_UNIT_GENERIC_KHR = 0,
    VK_PERFORMANCE_COUNTER_UNIT_PERCENTAGE_KHR = 1,
    VK_PERFORMANCE_COUNTER_UNIT_NANOSECONDS_KHR = 2,
    VK_PERFORMANCE_COUNTER_UNIT_BYTES_KHR = 3,
    VK_PERFORMANCE_COUNTER_UNIT_BYTES_PER_SECOND_KHR = 4,
    VK_PERFORMANCE_COUNTER_UNIT_KELVIN_KHR = 5,
    VK_PERFORMANCE_COUNTER_UNIT_WATTS_KHR = 6,
    VK_PERFORMANCE_COUNTER_UNIT_VOLTS_KHR = 7,
    VK_PERFORMANCE_COUNTER_UNIT_AMPS_KHR = 8,
    VK_PERFORMANCE_COUNTER_UNIT_HERTZ_KHR = 9,
    VK_PERFORMANCE_COUNTER_UNIT_CYCLES_KHR = 10,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkPerformanceCounterStorageKHR = enum(u32) {
    VK_PERFORMANCE_COUNTER_STORAGE_INT32_KHR = 0,
    VK_PERFORMANCE_COUNTER_STORAGE_INT64_KHR = 1,
    VK_PERFORMANCE_COUNTER_STORAGE_UINT32_KHR = 2,
    VK_PERFORMANCE_COUNTER_STORAGE_UINT64_KHR = 3,
    VK_PERFORMANCE_COUNTER_STORAGE_FLOAT32_KHR = 4,
    VK_PERFORMANCE_COUNTER_STORAGE_FLOAT64_KHR = 5,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkPerformanceConfigurationTypeINTEL = enum(u32) {
    VK_PERFORMANCE_CONFIGURATION_TYPE_COMMAND_QUEUE_METRICS_DISCOVERY_ACTIVATED_INTEL = 0,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkQueryPoolSamplingModeINTEL = enum(u32) {
    VK_QUERY_POOL_SAMPLING_MODE_MANUAL_INTEL = 0,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkPerformanceOverrideTypeINTEL = enum(u32) {
    VK_PERFORMANCE_OVERRIDE_TYPE_NULL_HARDWARE_INTEL = 0,
    VK_PERFORMANCE_OVERRIDE_TYPE_FLUSH_GPU_CACHES_INTEL = 1,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkPerformanceParameterTypeINTEL = enum(u32) {
    VK_PERFORMANCE_PARAMETER_TYPE_HW_COUNTERS_SUPPORTED_INTEL = 0,
    VK_PERFORMANCE_PARAMETER_TYPE_STREAM_MARKER_VALID_BITS_INTEL = 1,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkPerformanceValueTypeINTEL = enum(u32) {
    VK_PERFORMANCE_VALUE_TYPE_UINT32_INTEL = 0,
    VK_PERFORMANCE_VALUE_TYPE_UINT64_INTEL = 1,
    VK_PERFORMANCE_VALUE_TYPE_FLOAT_INTEL = 2,
    VK_PERFORMANCE_VALUE_TYPE_BOOL_INTEL = 3,
    VK_PERFORMANCE_VALUE_TYPE_STRING_INTEL = 4,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkShaderFloatControlsIndependence = enum(u32) {
    // Alias: VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY_KHR
    VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY = 0,
    // Alias: VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL_KHR
    VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL = 1,
    // Alias: VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE_KHR
    VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE = 2,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkPipelineExecutableStatisticFormatKHR = enum(u32) {
    VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_BOOL32_KHR = 0,
    VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_INT64_KHR = 1,
    VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_UINT64_KHR = 2,
    VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_FLOAT64_KHR = 3,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkLineRasterizationMode = enum(u32) {
    // Alias: VK_LINE_RASTERIZATION_MODE_DEFAULT_EXT
    // Alias: VK_LINE_RASTERIZATION_MODE_DEFAULT_KHR
    VK_LINE_RASTERIZATION_MODE_DEFAULT = 0,
    // Alias: VK_LINE_RASTERIZATION_MODE_RECTANGULAR_EXT
    // Alias: VK_LINE_RASTERIZATION_MODE_RECTANGULAR_KHR
    VK_LINE_RASTERIZATION_MODE_RECTANGULAR = 1,
    // Alias: VK_LINE_RASTERIZATION_MODE_BRESENHAM_EXT
    // Alias: VK_LINE_RASTERIZATION_MODE_BRESENHAM_KHR
    VK_LINE_RASTERIZATION_MODE_BRESENHAM = 2,
    // Alias: VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_EXT
    // Alias: VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_KHR
    VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH = 3,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkFaultLevel = enum(u32) {
    VK_FAULT_LEVEL_UNASSIGNED = 0,
    VK_FAULT_LEVEL_CRITICAL = 1,
    VK_FAULT_LEVEL_RECOVERABLE = 2,
    VK_FAULT_LEVEL_WARNING = 3,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkFaultType = enum(u32) {
    VK_FAULT_TYPE_INVALID = 0,
    VK_FAULT_TYPE_UNASSIGNED = 1,
    VK_FAULT_TYPE_IMPLEMENTATION = 2,
    VK_FAULT_TYPE_SYSTEM = 3,
    VK_FAULT_TYPE_PHYSICAL_DEVICE = 4,
    VK_FAULT_TYPE_COMMAND_BUFFER_FULL = 5,
    VK_FAULT_TYPE_INVALID_API_USAGE = 6,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkFaultQueryBehavior = enum(u32) {
    VK_FAULT_QUERY_BEHAVIOR_GET_AND_CLEAR_ALL_FAULTS = 0,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkPipelineMatchControl = enum(u32) {
    VK_PIPELINE_MATCH_CONTROL_APPLICATION_UUID_EXACT_MATCH = 0,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkFragmentShadingRateCombinerOpKHR = enum(u32) {
    VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR = 0,
    VK_FRAGMENT_SHADING_RATE_COMBINER_OP_REPLACE_KHR = 1,
    VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MIN_KHR = 2,
    VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MAX_KHR = 3,
    VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MUL_KHR = 4,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkFragmentShadingRateNV = enum(u32) {
    VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_PIXEL_NV = 0,
    VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_1X2_PIXELS_NV = 1,
    VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X1_PIXELS_NV = 4,
    VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X2_PIXELS_NV = 5,
    VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X4_PIXELS_NV = 6,
    VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_4X2_PIXELS_NV = 9,
    VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_4X4_PIXELS_NV = 10,
    VK_FRAGMENT_SHADING_RATE_2_INVOCATIONS_PER_PIXEL_NV = 11,
    VK_FRAGMENT_SHADING_RATE_4_INVOCATIONS_PER_PIXEL_NV = 12,
    VK_FRAGMENT_SHADING_RATE_8_INVOCATIONS_PER_PIXEL_NV = 13,
    VK_FRAGMENT_SHADING_RATE_16_INVOCATIONS_PER_PIXEL_NV = 14,
    VK_FRAGMENT_SHADING_RATE_NO_INVOCATIONS_NV = 15,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkFragmentShadingRateTypeNV = enum(u32) {
    VK_FRAGMENT_SHADING_RATE_TYPE_FRAGMENT_SIZE_NV = 0,
    VK_FRAGMENT_SHADING_RATE_TYPE_ENUMS_NV = 1,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkSubpassMergeStatusEXT = enum(u32) {
    VK_SUBPASS_MERGE_STATUS_MERGED_EXT = 0,
    VK_SUBPASS_MERGE_STATUS_DISALLOWED_EXT = 1,
    VK_SUBPASS_MERGE_STATUS_NOT_MERGED_SIDE_EFFECTS_EXT = 2,
    VK_SUBPASS_MERGE_STATUS_NOT_MERGED_SAMPLES_MISMATCH_EXT = 3,
    VK_SUBPASS_MERGE_STATUS_NOT_MERGED_VIEWS_MISMATCH_EXT = 4,
    VK_SUBPASS_MERGE_STATUS_NOT_MERGED_ALIASING_EXT = 5,
    VK_SUBPASS_MERGE_STATUS_NOT_MERGED_DEPENDENCIES_EXT = 6,
    VK_SUBPASS_MERGE_STATUS_NOT_MERGED_INCOMPATIBLE_INPUT_ATTACHMENT_EXT = 7,
    VK_SUBPASS_MERGE_STATUS_NOT_MERGED_TOO_MANY_ATTACHMENTS_EXT = 8,
    VK_SUBPASS_MERGE_STATUS_NOT_MERGED_INSUFFICIENT_STORAGE_EXT = 9,
    VK_SUBPASS_MERGE_STATUS_NOT_MERGED_DEPTH_STENCIL_COUNT_EXT = 10,
    VK_SUBPASS_MERGE_STATUS_NOT_MERGED_RESOLVE_ATTACHMENT_REUSE_EXT = 11,
    VK_SUBPASS_MERGE_STATUS_NOT_MERGED_SINGLE_SUBPASS_EXT = 12,
    VK_SUBPASS_MERGE_STATUS_NOT_MERGED_UNSPECIFIED_EXT = 13,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkSciSyncClientTypeNV = enum(u32) {
    VK_SCI_SYNC_CLIENT_TYPE_SIGNALER_NV = 0,
    VK_SCI_SYNC_CLIENT_TYPE_WAITER_NV = 1,
    VK_SCI_SYNC_CLIENT_TYPE_SIGNALER_WAITER_NV = 2,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkSciSyncPrimitiveTypeNV = enum(u32) {
    VK_SCI_SYNC_PRIMITIVE_TYPE_FENCE_NV = 0,
    VK_SCI_SYNC_PRIMITIVE_TYPE_SEMAPHORE_NV = 1,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkProvokingVertexModeEXT = enum(u32) {
    VK_PROVOKING_VERTEX_MODE_FIRST_VERTEX_EXT = 0,
    VK_PROVOKING_VERTEX_MODE_LAST_VERTEX_EXT = 1,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkPipelineCacheValidationVersion = enum(u32) {
    VK_PIPELINE_CACHE_VALIDATION_VERSION_SAFETY_CRITICAL_ONE = 1,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkAccelerationStructureMotionInstanceTypeNV = enum(u32) {
    VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_STATIC_NV = 0,
    VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_MATRIX_MOTION_NV = 1,
    VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_SRT_MOTION_NV = 2,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkDeviceAddressBindingTypeEXT = enum(u32) {
    VK_DEVICE_ADDRESS_BINDING_TYPE_BIND_EXT = 0,
    VK_DEVICE_ADDRESS_BINDING_TYPE_UNBIND_EXT = 1,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkQueryResultStatusKHR = enum(u32) {
    // Extension: VK_KHR_video_encode_queue
    VK_QUERY_RESULT_STATUS_INSUFFICIENT_BITSTREAM_BUFFER_RANGE_KHR = -1000299000,
    VK_QUERY_RESULT_STATUS_ERROR_KHR = -1,
    VK_QUERY_RESULT_STATUS_NOT_READY_KHR = 0,
    VK_QUERY_RESULT_STATUS_COMPLETE_KHR = 1,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkVideoEncodeTuningModeKHR = enum(u32) {
    VK_VIDEO_ENCODE_TUNING_MODE_DEFAULT_KHR = 0,
    VK_VIDEO_ENCODE_TUNING_MODE_HIGH_QUALITY_KHR = 1,
    VK_VIDEO_ENCODE_TUNING_MODE_LOW_LATENCY_KHR = 2,
    VK_VIDEO_ENCODE_TUNING_MODE_ULTRA_LOW_LATENCY_KHR = 3,
    VK_VIDEO_ENCODE_TUNING_MODE_LOSSLESS_KHR = 4,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkPartitionedAccelerationStructureOpTypeNV = enum(u32) {
    VK_PARTITIONED_ACCELERATION_STRUCTURE_OP_TYPE_WRITE_INSTANCE_NV = 0,
    VK_PARTITIONED_ACCELERATION_STRUCTURE_OP_TYPE_UPDATE_INSTANCE_NV = 1,
    VK_PARTITIONED_ACCELERATION_STRUCTURE_OP_TYPE_WRITE_PARTITION_TRANSLATION_NV = 2,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkVideoEncodeAV1PredictionModeKHR = enum(u32) {
    VK_VIDEO_ENCODE_AV1_PREDICTION_MODE_INTRA_ONLY_KHR = 0,
    VK_VIDEO_ENCODE_AV1_PREDICTION_MODE_SINGLE_REFERENCE_KHR = 1,
    VK_VIDEO_ENCODE_AV1_PREDICTION_MODE_UNIDIRECTIONAL_COMPOUND_KHR = 2,
    VK_VIDEO_ENCODE_AV1_PREDICTION_MODE_BIDIRECTIONAL_COMPOUND_KHR = 3,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkVideoEncodeAV1RateControlGroupKHR = enum(u32) {
    VK_VIDEO_ENCODE_AV1_RATE_CONTROL_GROUP_INTRA_KHR = 0,
    VK_VIDEO_ENCODE_AV1_RATE_CONTROL_GROUP_PREDICTIVE_KHR = 1,
    VK_VIDEO_ENCODE_AV1_RATE_CONTROL_GROUP_BIPREDICTIVE_KHR = 2,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkPipelineRobustnessBufferBehavior = enum(u32) {
    // Alias: VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DEVICE_DEFAULT_EXT
    VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DEVICE_DEFAULT = 0,
    // Alias: VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DISABLED_EXT
    VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DISABLED = 1,
    // Alias: VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT
    VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS = 2,
    // Alias: VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT
    VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2 = 3,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkPipelineRobustnessImageBehavior = enum(u32) {
    // Alias: VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DEVICE_DEFAULT_EXT
    VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DEVICE_DEFAULT = 0,
    // Alias: VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DISABLED_EXT
    VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DISABLED = 1,
    // Alias: VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS_EXT
    VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS = 2,
    // Alias: VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS_2_EXT
    VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS_2 = 3,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkOpticalFlowPerformanceLevelNV = enum(u32) {
    VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_UNKNOWN_NV = 0,
    VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_SLOW_NV = 1,
    VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_MEDIUM_NV = 2,
    VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_FAST_NV = 3,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkOpticalFlowSessionBindingPointNV = enum(u32) {
    VK_OPTICAL_FLOW_SESSION_BINDING_POINT_UNKNOWN_NV = 0,
    VK_OPTICAL_FLOW_SESSION_BINDING_POINT_INPUT_NV = 1,
    VK_OPTICAL_FLOW_SESSION_BINDING_POINT_REFERENCE_NV = 2,
    VK_OPTICAL_FLOW_SESSION_BINDING_POINT_HINT_NV = 3,
    VK_OPTICAL_FLOW_SESSION_BINDING_POINT_FLOW_VECTOR_NV = 4,
    VK_OPTICAL_FLOW_SESSION_BINDING_POINT_BACKWARD_FLOW_VECTOR_NV = 5,
    VK_OPTICAL_FLOW_SESSION_BINDING_POINT_COST_NV = 6,
    VK_OPTICAL_FLOW_SESSION_BINDING_POINT_BACKWARD_COST_NV = 7,
    VK_OPTICAL_FLOW_SESSION_BINDING_POINT_GLOBAL_FLOW_NV = 8,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkMicromapTypeEXT = enum(u32) {
    VK_MICROMAP_TYPE_OPACITY_MICROMAP_EXT = 0,
    // Extension: VK_NV_displacement_micromap
    VK_MICROMAP_TYPE_DISPLACEMENT_MICROMAP_NV = 1000397000,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkCopyMicromapModeEXT = enum(u32) {
    VK_COPY_MICROMAP_MODE_CLONE_EXT = 0,
    VK_COPY_MICROMAP_MODE_SERIALIZE_EXT = 1,
    VK_COPY_MICROMAP_MODE_DESERIALIZE_EXT = 2,
    VK_COPY_MICROMAP_MODE_COMPACT_EXT = 3,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkBuildMicromapModeEXT = enum(u32) {
    VK_BUILD_MICROMAP_MODE_BUILD_EXT = 0,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkOpacityMicromapFormatEXT = enum(u32) {
    VK_OPACITY_MICROMAP_FORMAT_2_STATE_EXT = 1,
    VK_OPACITY_MICROMAP_FORMAT_4_STATE_EXT = 2,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkOpacityMicromapSpecialIndexEXT = enum(u32) {
    // Extension: VK_NV_cluster_acceleration_structure
    VK_OPACITY_MICROMAP_SPECIAL_INDEX_CLUSTER_GEOMETRY_DISABLE_OPACITY_MICROMAP_NV = -5,
    VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_UNKNOWN_OPAQUE_EXT = -4,
    VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_UNKNOWN_TRANSPARENT_EXT = -3,
    VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_OPAQUE_EXT = -2,
    VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_TRANSPARENT_EXT = -1,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkDepthBiasRepresentationEXT = enum(u32) {
    VK_DEPTH_BIAS_REPRESENTATION_LEAST_REPRESENTABLE_VALUE_FORMAT_EXT = 0,
    VK_DEPTH_BIAS_REPRESENTATION_LEAST_REPRESENTABLE_VALUE_FORCE_UNORM_EXT = 1,
    VK_DEPTH_BIAS_REPRESENTATION_FLOAT_EXT = 2,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkDeviceFaultAddressTypeEXT = enum(u32) {
    // Comment: Currently unused
    VK_DEVICE_FAULT_ADDRESS_TYPE_NONE_EXT = 0,
    VK_DEVICE_FAULT_ADDRESS_TYPE_READ_INVALID_EXT = 1,
    VK_DEVICE_FAULT_ADDRESS_TYPE_WRITE_INVALID_EXT = 2,
    VK_DEVICE_FAULT_ADDRESS_TYPE_EXECUTE_INVALID_EXT = 3,
    VK_DEVICE_FAULT_ADDRESS_TYPE_INSTRUCTION_POINTER_UNKNOWN_EXT = 4,
    VK_DEVICE_FAULT_ADDRESS_TYPE_INSTRUCTION_POINTER_INVALID_EXT = 5,
    VK_DEVICE_FAULT_ADDRESS_TYPE_INSTRUCTION_POINTER_FAULT_EXT = 6,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkDeviceFaultVendorBinaryHeaderVersionEXT = enum(u32) {
    VK_DEVICE_FAULT_VENDOR_BINARY_HEADER_VERSION_ONE_EXT = 1,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkIndirectExecutionSetInfoTypeEXT = enum(u32) {
    VK_INDIRECT_EXECUTION_SET_INFO_TYPE_PIPELINES_EXT = 0,
    VK_INDIRECT_EXECUTION_SET_INFO_TYPE_SHADER_OBJECTS_EXT = 1,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkIndirectCommandsTokenTypeEXT = enum(u32) {
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_EXECUTION_SET_EXT = 0,
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_EXT = 1,
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_SEQUENCE_INDEX_EXT = 2,
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_EXT = 3,
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_EXT = 4,
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_EXT = 5,
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_EXT = 6,
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_COUNT_EXT = 7,
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_COUNT_EXT = 8,
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_EXT = 9,
    // Extension: VK_NV_mesh_shader
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_NV_EXT = 1000202002,
    // Extension: VK_NV_mesh_shader
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_COUNT_NV_EXT = 1000202003,
    // Extension: VK_EXT_mesh_shader
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_EXT = 1000328000,
    // Extension: VK_EXT_mesh_shader
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_COUNT_EXT = 1000328001,
    // Extension: VK_KHR_ray_tracing_maintenance1
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_TRACE_RAYS2_EXT = 1000386004,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkDisplacementMicromapFormatNV = enum(u32) {
    VK_DISPLACEMENT_MICROMAP_FORMAT_64_TRIANGLES_64_BYTES_NV = 1,
    VK_DISPLACEMENT_MICROMAP_FORMAT_256_TRIANGLES_128_BYTES_NV = 2,
    VK_DISPLACEMENT_MICROMAP_FORMAT_1024_TRIANGLES_128_BYTES_NV = 3,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkShaderCodeTypeEXT = enum(u32) {
    VK_SHADER_CODE_TYPE_BINARY_EXT = 0,
    VK_SHADER_CODE_TYPE_SPIRV_EXT = 1,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkScopeKHR = enum(u32) {
    // Alias: VK_SCOPE_DEVICE_NV
    VK_SCOPE_DEVICE_KHR = 1,
    // Alias: VK_SCOPE_WORKGROUP_NV
    VK_SCOPE_WORKGROUP_KHR = 2,
    // Alias: VK_SCOPE_SUBGROUP_NV
    VK_SCOPE_SUBGROUP_KHR = 3,
    // Alias: VK_SCOPE_QUEUE_FAMILY_NV
    VK_SCOPE_QUEUE_FAMILY_KHR = 5,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkComponentTypeKHR = enum(u32) {
    // Alias: VK_COMPONENT_TYPE_FLOAT16_NV
    VK_COMPONENT_TYPE_FLOAT16_KHR = 0,
    // Alias: VK_COMPONENT_TYPE_FLOAT32_NV
    VK_COMPONENT_TYPE_FLOAT32_KHR = 1,
    // Alias: VK_COMPONENT_TYPE_FLOAT64_NV
    VK_COMPONENT_TYPE_FLOAT64_KHR = 2,
    // Alias: VK_COMPONENT_TYPE_SINT8_NV
    VK_COMPONENT_TYPE_SINT8_KHR = 3,
    // Alias: VK_COMPONENT_TYPE_SINT16_NV
    VK_COMPONENT_TYPE_SINT16_KHR = 4,
    // Alias: VK_COMPONENT_TYPE_SINT32_NV
    VK_COMPONENT_TYPE_SINT32_KHR = 5,
    // Alias: VK_COMPONENT_TYPE_SINT64_NV
    VK_COMPONENT_TYPE_SINT64_KHR = 6,
    // Alias: VK_COMPONENT_TYPE_UINT8_NV
    VK_COMPONENT_TYPE_UINT8_KHR = 7,
    // Alias: VK_COMPONENT_TYPE_UINT16_NV
    VK_COMPONENT_TYPE_UINT16_KHR = 8,
    // Alias: VK_COMPONENT_TYPE_UINT32_NV
    VK_COMPONENT_TYPE_UINT32_KHR = 9,
    // Alias: VK_COMPONENT_TYPE_UINT64_NV
    VK_COMPONENT_TYPE_UINT64_KHR = 10,
    // Extension: VK_KHR_shader_bfloat16
    VK_COMPONENT_TYPE_BFLOAT16_KHR = 1000141000,
    // Extension: VK_NV_cooperative_vector
    VK_COMPONENT_TYPE_SINT8_PACKED_NV = 1000491000,
    // Extension: VK_NV_cooperative_vector
    VK_COMPONENT_TYPE_UINT8_PACKED_NV = 1000491001,
    // Extension: VK_EXT_shader_float8
    // Alias: VK_COMPONENT_TYPE_FLOAT_E4M3_NV
    VK_COMPONENT_TYPE_FLOAT8_E4M3_EXT = 1000491002,
    // Extension: VK_EXT_shader_float8
    // Alias: VK_COMPONENT_TYPE_FLOAT_E5M2_NV
    VK_COMPONENT_TYPE_FLOAT8_E5M2_EXT = 1000491003,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkCubicFilterWeightsQCOM = enum(u32) {
    VK_CUBIC_FILTER_WEIGHTS_CATMULL_ROM_QCOM = 0,
    VK_CUBIC_FILTER_WEIGHTS_ZERO_TANGENT_CARDINAL_QCOM = 1,
    VK_CUBIC_FILTER_WEIGHTS_B_SPLINE_QCOM = 2,
    VK_CUBIC_FILTER_WEIGHTS_MITCHELL_NETRAVALI_QCOM = 3,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkBlockMatchWindowCompareModeQCOM = enum(u32) {
    VK_BLOCK_MATCH_WINDOW_COMPARE_MODE_MIN_QCOM = 0,
    VK_BLOCK_MATCH_WINDOW_COMPARE_MODE_MAX_QCOM = 1,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkPhysicalDeviceLayeredApiKHR = enum(u32) {
    VK_PHYSICAL_DEVICE_LAYERED_API_VULKAN_KHR = 0,
    VK_PHYSICAL_DEVICE_LAYERED_API_D3D12_KHR = 1,
    VK_PHYSICAL_DEVICE_LAYERED_API_METAL_KHR = 2,
    VK_PHYSICAL_DEVICE_LAYERED_API_OPENGL_KHR = 3,
    VK_PHYSICAL_DEVICE_LAYERED_API_OPENGLES_KHR = 4,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkLayeredDriverUnderlyingApiMSFT = enum(u32) {
    VK_LAYERED_DRIVER_UNDERLYING_API_NONE_MSFT = 0,
    VK_LAYERED_DRIVER_UNDERLYING_API_D3D12_MSFT = 1,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkLatencyMarkerNV = enum(u32) {
    VK_LATENCY_MARKER_SIMULATION_START_NV = 0,
    VK_LATENCY_MARKER_SIMULATION_END_NV = 1,
    VK_LATENCY_MARKER_RENDERSUBMIT_START_NV = 2,
    VK_LATENCY_MARKER_RENDERSUBMIT_END_NV = 3,
    VK_LATENCY_MARKER_PRESENT_START_NV = 4,
    VK_LATENCY_MARKER_PRESENT_END_NV = 5,
    VK_LATENCY_MARKER_INPUT_SAMPLE_NV = 6,
    VK_LATENCY_MARKER_TRIGGER_FLASH_NV = 7,
    VK_LATENCY_MARKER_OUT_OF_BAND_RENDERSUBMIT_START_NV = 8,
    VK_LATENCY_MARKER_OUT_OF_BAND_RENDERSUBMIT_END_NV = 9,
    VK_LATENCY_MARKER_OUT_OF_BAND_PRESENT_START_NV = 10,
    VK_LATENCY_MARKER_OUT_OF_BAND_PRESENT_END_NV = 11,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkOutOfBandQueueTypeNV = enum(u32) {
    VK_OUT_OF_BAND_QUEUE_TYPE_RENDER_NV = 0,
    VK_OUT_OF_BAND_QUEUE_TYPE_PRESENT_NV = 1,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkCompressedTriangleFormatAMDX = enum(u32) {
    VK_COMPRESSED_TRIANGLE_FORMAT_DGF1_AMDX = 0,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkDepthClampModeEXT = enum(u32) {
    VK_DEPTH_CLAMP_MODE_VIEWPORT_RANGE_EXT = 0,
    VK_DEPTH_CLAMP_MODE_USER_DEFINED_RANGE_EXT = 1,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkCooperativeVectorMatrixLayoutNV = enum(u32) {
    VK_COOPERATIVE_VECTOR_MATRIX_LAYOUT_ROW_MAJOR_NV = 0,
    VK_COOPERATIVE_VECTOR_MATRIX_LAYOUT_COLUMN_MAJOR_NV = 1,
    VK_COOPERATIVE_VECTOR_MATRIX_LAYOUT_INFERENCING_OPTIMAL_NV = 2,
    VK_COOPERATIVE_VECTOR_MATRIX_LAYOUT_TRAINING_OPTIMAL_NV = 3,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkTensorTilingARM = enum(u32) {
    VK_TENSOR_TILING_OPTIMAL_ARM = 0,
    VK_TENSOR_TILING_LINEAR_ARM = 1,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkDefaultVertexAttributeValueKHR = enum(u32) {
    VK_DEFAULT_VERTEX_ATTRIBUTE_VALUE_ZERO_ZERO_ZERO_ZERO_KHR = 0,
    VK_DEFAULT_VERTEX_ATTRIBUTE_VALUE_ZERO_ZERO_ZERO_ONE_KHR = 1,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkDataGraphPipelineSessionBindPointARM = enum(u32) {
    VK_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_TRANSIENT_ARM = 0,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkDataGraphPipelineSessionBindPointTypeARM = enum(u32) {
    VK_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_TYPE_MEMORY_ARM = 0,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkDataGraphPipelinePropertyARM = enum(u32) {
    VK_DATA_GRAPH_PIPELINE_PROPERTY_CREATION_LOG_ARM = 0,
    VK_DATA_GRAPH_PIPELINE_PROPERTY_IDENTIFIER_ARM = 1,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkPhysicalDeviceDataGraphProcessingEngineTypeARM = enum(u32) {
    VK_PHYSICAL_DEVICE_DATA_GRAPH_PROCESSING_ENGINE_TYPE_DEFAULT_ARM = 0,
    // Extension: VK_QCOM_data_graph_model
    VK_PHYSICAL_DEVICE_DATA_GRAPH_PROCESSING_ENGINE_TYPE_NEURAL_QCOM = 1000629000,
    // Extension: VK_QCOM_data_graph_model
    VK_PHYSICAL_DEVICE_DATA_GRAPH_PROCESSING_ENGINE_TYPE_COMPUTE_QCOM = 1000629001,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkPhysicalDeviceDataGraphOperationTypeARM = enum(u32) {
    VK_PHYSICAL_DEVICE_DATA_GRAPH_OPERATION_TYPE_SPIRV_EXTENDED_INSTRUCTION_SET_ARM = 0,
    // Extension: VK_QCOM_data_graph_model
    VK_PHYSICAL_DEVICE_DATA_GRAPH_OPERATION_TYPE_NEURAL_MODEL_QCOM = 1000629000,
    // Extension: VK_QCOM_data_graph_model
    VK_PHYSICAL_DEVICE_DATA_GRAPH_OPERATION_TYPE_BUILTIN_MODEL_QCOM = 1000629001,
    pub const zero = @import("std").mem.zeroes(@This());
};
pub const VkDataGraphModelCacheTypeQCOM = enum(u32) {
    VK_DATA_GRAPH_MODEL_CACHE_TYPE_GENERIC_BINARY_QCOM = 0,
    pub const zero = @import("std").mem.zeroes(@This());
};

// Structs
// Extension: VK_BASE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkBaseOutStructure = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType,
    // Extern sync: false
    // Optional: true
    pNext: ?*VkBaseOutStructure = null,
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkBaseInStructure = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType,
    // Extern sync: false
    // Optional: true
    pNext: ?*const VkBaseInStructure = null,
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkOffset2D = extern struct {
    // Extern sync: false
    // Optional: false
    x: i32 = 0,
    // Extern sync: false
    // Optional: false
    y: i32 = 0,
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkOffset3D = extern struct {
    // Extern sync: false
    // Optional: false
    x: i32 = 0,
    // Extern sync: false
    // Optional: false
    y: i32 = 0,
    // Extern sync: false
    // Optional: false
    z: i32 = 0,
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkExtent2D = extern struct {
    // Extern sync: false
    // Optional: false
    width: u32 = 0,
    // Extern sync: false
    // Optional: false
    height: u32 = 0,
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkExtent3D = extern struct {
    // Extern sync: false
    // Optional: false
    width: u32 = 0,
    // Extern sync: false
    // Optional: false
    height: u32 = 0,
    // Extern sync: false
    // Optional: false
    depth: u32 = 0,
};
// Extension: VK_GRAPHICS_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkViewport = extern struct {
    // Extern sync: false
    // Optional: false
    x: f32 = 0,
    // Extern sync: false
    // Optional: false
    y: f32 = 0,
    // Extern sync: false
    // Optional: false
    width: f32 = 0,
    // Extern sync: false
    // Optional: false
    height: f32 = 0,
    // Extern sync: false
    // Optional: false
    minDepth: f32 = 0,
    // Extern sync: false
    // Optional: false
    maxDepth: f32 = 0,
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkRect2D = extern struct {
    // Extern sync: false
    // Optional: false
    offset: VkOffset2D = .{},
    // Extern sync: false
    // Optional: false
    extent: VkExtent2D = .{},
};
// Extension: VK_GRAPHICS_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkClearRect = extern struct {
    // Extern sync: false
    // Optional: false
    rect: VkRect2D = .{},
    // Extern sync: false
    // Optional: false
    baseArrayLayer: u32 = 0,
    // Extern sync: false
    // Optional: false
    layerCount: u32 = 0,
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkComponentMapping = extern struct {
    // Extern sync: false
    // Optional: false
    r: VkComponentSwizzle,
    // Extern sync: false
    // Optional: false
    g: VkComponentSwizzle,
    // Extern sync: false
    // Optional: false
    b: VkComponentSwizzle,
    // Extern sync: false
    // Optional: false
    a: VkComponentSwizzle,
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceProperties = extern struct {
    // Extern sync: false
    // Optional: false
    apiVersion: u32 = 0,
    // Extern sync: false
    // Optional: false
    driverVersion: u32 = 0,
    // Extern sync: false
    // Optional: false
    vendorID: u32 = 0,
    // Extern sync: false
    // Optional: false
    deviceID: u32 = 0,
    // Extern sync: false
    // Optional: false
    deviceType: VkPhysicalDeviceType,
    // Length member: null-terminated
    // Extern sync: false
    // Optional: false
    deviceName: [VK_MAX_PHYSICAL_DEVICE_NAME_SIZE]u8 = @import("std").mem.zeroes([VK_MAX_PHYSICAL_DEVICE_NAME_SIZE]u8),
    // Extern sync: false
    // Optional: false
    pipelineCacheUUID: [VK_UUID_SIZE]u8 = @import("std").mem.zeroes([VK_UUID_SIZE]u8),
    // Extern sync: false
    // Optional: false
    limits: VkPhysicalDeviceLimits = .{},
    // Extern sync: false
    // Optional: false
    sparseProperties: VkPhysicalDeviceSparseProperties = .{},
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkExtensionProperties = extern struct {
    // Length member: null-terminated
    // Extern sync: false
    // Optional: false
    extensionName: [VK_MAX_EXTENSION_NAME_SIZE]u8 = @import("std").mem.zeroes([VK_MAX_EXTENSION_NAME_SIZE]u8),
    // Extern sync: false
    // Optional: false
    // Comment: version of the extension specification implemented
    specVersion: u32 = 0,
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkLayerProperties = extern struct {
    // Length member: null-terminated
    // Extern sync: false
    // Optional: false
    layerName: [VK_MAX_EXTENSION_NAME_SIZE]u8 = @import("std").mem.zeroes([VK_MAX_EXTENSION_NAME_SIZE]u8),
    // Extern sync: false
    // Optional: false
    // Comment: version of the layer specification implemented
    specVersion: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: build or release version of the layer's library
    implementationVersion: u32 = 0,
    // Length member: null-terminated
    // Extern sync: false
    // Optional: false
    description: [VK_MAX_DESCRIPTION_SIZE]u8 = @import("std").mem.zeroes([VK_MAX_DESCRIPTION_SIZE]u8),
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkApplicationInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_APPLICATION_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Length member: null-terminated
    // Extern sync: false
    // Optional: true
    pApplicationName: ?[*:0]const u8 = null,
    // Extern sync: false
    // Optional: false
    applicationVersion: u32 = 0,
    // Length member: null-terminated
    // Extern sync: false
    // Optional: true
    pEngineName: ?[*:0]const u8 = null,
    // Extern sync: false
    // Optional: false
    engineVersion: u32 = 0,
    // Extern sync: false
    // Optional: false
    apiVersion: u32 = 0,
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkAllocationCallbacks = extern struct {
    // Extern sync: false
    // Optional: true
    pUserData: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    pfnAllocation: ?*const vkAllocationFunction = null,
    // Extern sync: false
    // Optional: false
    pfnReallocation: ?*const vkReallocationFunction = null,
    // Extern sync: false
    // Optional: false
    pfnFree: ?*const vkFreeFunction = null,
    // Extern sync: false
    // Optional: true
    pfnInternalAllocation: ?*const vkInternalAllocationNotification = null,
    // Extern sync: false
    // Optional: true
    pfnInternalFree: ?*const vkInternalFreeNotification = null,
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDeviceQueueCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkDeviceQueueCreateFlags = .{},
    // Extern sync: false
    // Optional: false
    queueFamilyIndex: u32 = 0,
    // Extern sync: false
    // Optional: false
    queueCount: u32 = 0,
    // Length member: queueCount
    // Extern sync: false
    // Optional: false
    pQueuePriorities: ?[*]const f32 = null,
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDeviceCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkDeviceCreateFlags = .{},
    // Extern sync: false
    // Optional: true
    queueCreateInfoCount: u32 = 0,
    // Length member: queueCreateInfoCount
    // Extern sync: false
    // Optional: false
    pQueueCreateInfos: ?[*]const VkDeviceQueueCreateInfo = null,
    // Deprecated: ignored
    // Extern sync: false
    // Optional: true
    enabledLayerCount: u32 = 0,
    // Length member: enabledLayerCount,null-terminated
    // Deprecated: ignored
    // Extern sync: false
    // Optional: false
    // Comment: Ordered list of layer names to be enabled
    ppEnabledLayerNames: ?[*]const [*:0]const u8 = null,
    // Extern sync: false
    // Optional: true
    enabledExtensionCount: u32 = 0,
    // Length member: enabledExtensionCount,null-terminated
    // Extern sync: false
    // Optional: false
    ppEnabledExtensionNames: ?[*]const [*:0]const u8 = null,
    // Extern sync: false
    // Optional: true
    pEnabledFeatures: ?*const VkPhysicalDeviceFeatures = null,
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkInstanceCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkInstanceCreateFlags = .{},
    // Extern sync: false
    // Optional: true
    pApplicationInfo: ?*const VkApplicationInfo = null,
    // Extern sync: false
    // Optional: true
    enabledLayerCount: u32 = 0,
    // Length member: enabledLayerCount,null-terminated
    // Extern sync: false
    // Optional: false
    // Comment: Ordered list of layer names to be enabled
    ppEnabledLayerNames: ?[*]const [*:0]const u8 = null,
    // Extern sync: false
    // Optional: true
    enabledExtensionCount: u32 = 0,
    // Length member: enabledExtensionCount,null-terminated
    // Extern sync: false
    // Optional: false
    // Comment: Extension names to be enabled
    ppEnabledExtensionNames: ?[*]const [*:0]const u8 = null,
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkQueueFamilyProperties = extern struct {
    // Extern sync: false
    // Optional: true
    // Comment: Queue flags
    queueFlags: VkQueueFlags = .{},
    // Extern sync: false
    // Optional: false
    queueCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    timestampValidBits: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Minimum alignment requirement for image transfers
    minImageTransferGranularity: VkExtent3D = .{},
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceMemoryProperties = extern struct {
    // Extern sync: false
    // Optional: false
    memoryTypeCount: u32 = 0,
    // Length member: memoryTypeCount
    // Extern sync: false
    // Optional: false
    memoryTypes: [VK_MAX_MEMORY_TYPES]VkMemoryType = @import("std").mem.zeroes([VK_MAX_MEMORY_TYPES]VkMemoryType),
    // Extern sync: false
    // Optional: false
    memoryHeapCount: u32 = 0,
    // Length member: memoryHeapCount
    // Extern sync: false
    // Optional: false
    memoryHeaps: [VK_MAX_MEMORY_HEAPS]VkMemoryHeap = @import("std").mem.zeroes([VK_MAX_MEMORY_HEAPS]VkMemoryHeap),
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkMemoryAllocateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: Size of memory allocation
    allocationSize: u64 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Index of the of the memory type to allocate from
    memoryTypeIndex: u32 = 0,
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkMemoryRequirements = extern struct {
    // Extern sync: false
    // Optional: false
    // Comment: Specified in bytes
    size: u64 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Specified in bytes
    alignment: u64 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Bitmask of the allowed memory type indices into memoryTypes[] for this object
    memoryTypeBits: u32 = 0,
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkSparseImageFormatProperties = extern struct {
    // Extern sync: false
    // Optional: true
    aspectMask: VkImageAspectFlags = .{},
    // Extern sync: false
    // Optional: false
    imageGranularity: VkExtent3D = .{},
    // Extern sync: false
    // Optional: true
    flags: VkSparseImageFormatFlags = .{},
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkSparseImageMemoryRequirements = extern struct {
    // Extern sync: false
    // Optional: false
    formatProperties: VkSparseImageFormatProperties = .{},
    // Extern sync: false
    // Optional: false
    imageMipTailFirstLod: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Specified in bytes, must be a multiple of sparse block size in bytes / alignment
    imageMipTailSize: u64 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Specified in bytes, must be a multiple of sparse block size in bytes / alignment
    imageMipTailOffset: u64 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Specified in bytes, must be a multiple of sparse block size in bytes / alignment
    imageMipTailStride: u64 = 0,
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkMemoryType = extern struct {
    // Extern sync: false
    // Optional: true
    // Comment: Memory properties of this memory type
    propertyFlags: VkMemoryPropertyFlags = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Index of the memory heap allocations of this memory type are taken from
    heapIndex: u32 = 0,
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkMemoryHeap = extern struct {
    // Extern sync: false
    // Optional: false
    // Comment: Available memory in the heap
    size: u64 = 0,
    // Extern sync: false
    // Optional: true
    // Comment: Flags for the heap
    flags: VkMemoryHeapFlags = .{},
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkMappedMemoryRange = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: Mapped memory object
    memory: VkDeviceMemory = .none,
    // Extern sync: false
    // Optional: false
    // Comment: Offset within the memory object where the range starts
    offset: u64 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Size of the range within the memory object
    size: u64 = 0,
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkFormatProperties = extern struct {
    // Extern sync: false
    // Optional: true
    // Comment: Format features in case of linear tiling
    linearTilingFeatures: VkFormatFeatureFlags = .{},
    // Extern sync: false
    // Optional: true
    // Comment: Format features in case of optimal tiling
    optimalTilingFeatures: VkFormatFeatureFlags = .{},
    // Extern sync: false
    // Optional: true
    // Comment: Format features supported by buffers
    bufferFeatures: VkFormatFeatureFlags = .{},
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkImageFormatProperties = extern struct {
    // Extern sync: false
    // Optional: false
    // Comment: max image dimensions for this resource type
    maxExtent: VkExtent3D = .{},
    // Extern sync: false
    // Optional: false
    // Comment: max number of mipmap levels for this resource type
    maxMipLevels: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: max array size for this resource type
    maxArrayLayers: u32 = 0,
    // Extern sync: false
    // Optional: true
    // Comment: supported sample counts for this resource type
    sampleCounts: VkSampleCountFlags = .{},
    // Extern sync: false
    // Optional: false
    // Comment: max size (in bytes) of this resource type
    maxResourceSize: u64 = 0,
};
// Extension: VK_COMPUTE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDescriptorBufferInfo = extern struct {
    // Extern sync: false
    // Optional: true
    // Comment: Buffer used for this descriptor slot.
    buffer: VkBuffer = .none,
    // Extern sync: false
    // Optional: false
    // Comment: Base offset from buffer start in bytes to update in the descriptor set.
    offset: u64 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Size in bytes of the buffer resource for this descriptor update.
    range: u64 = 0,
};
// Extension: VK_COMPUTE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDescriptorImageInfo = extern struct {
    // Extern sync: false
    // Optional: false
    // Comment: Sampler to write to the descriptor in case it is a SAMPLER or COMBINED_IMAGE_SAMPLER descriptor. Ignored otherwise.
    sampler: VkSampler = .none,
    // Extern sync: false
    // Optional: false
    // Comment: Image view to write to the descriptor in case it is a SAMPLED_IMAGE, STORAGE_IMAGE, COMBINED_IMAGE_SAMPLER, or INPUT_ATTACHMENT descriptor. Ignored otherwise.
    imageView: VkImageView = .none,
    // Extern sync: false
    // Optional: false
    // Comment: Layout the image is expected to be in when accessed using this descriptor (only used if imageView is not VK_NULL_HANDLE).
    imageLayout: VkImageLayout,
};
// Extension: VK_COMPUTE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkWriteDescriptorSet = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: Destination descriptor set
    dstSet: VkDescriptorSet = .none,
    // Extern sync: false
    // Optional: false
    // Comment: Binding within the destination descriptor set to write
    dstBinding: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Array element within the destination binding to write
    dstArrayElement: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Number of descriptors to write (determines the size of the array pointed by pDescriptors)
    descriptorCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Descriptor type to write (determines which members of the array pointed by pDescriptors are going to be used)
    descriptorType: VkDescriptorType,
    // Length member: descriptorCount
    // Extern sync: false
    // Optional: false
    // Comment: Sampler, image view, and layout for SAMPLER, COMBINED_IMAGE_SAMPLER, {SAMPLED,STORAGE}_IMAGE, and INPUT_ATTACHMENT descriptor types.
    pImageInfo: ?[*]const VkDescriptorImageInfo = null,
    // Length member: descriptorCount
    // Extern sync: false
    // Optional: false
    // Comment: Raw buffer, size, and offset for {UNIFORM,STORAGE}_BUFFER[_DYNAMIC] descriptor types.
    pBufferInfo: ?[*]const VkDescriptorBufferInfo = null,
    // Length member: descriptorCount
    // Extern sync: false
    // Optional: false
    // Comment: Buffer view to write to the descriptor for {UNIFORM,STORAGE}_TEXEL_BUFFER descriptor types.
    pTexelBufferView: ?[*]const VkBufferView = null,
};
// Extension: VK_COMPUTE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkCopyDescriptorSet = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: Source descriptor set
    srcSet: VkDescriptorSet = .none,
    // Extern sync: false
    // Optional: false
    // Comment: Binding within the source descriptor set to copy from
    srcBinding: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Array element within the source binding to copy from
    srcArrayElement: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Destination descriptor set
    dstSet: VkDescriptorSet = .none,
    // Extern sync: false
    // Optional: false
    // Comment: Binding within the destination descriptor set to copy to
    dstBinding: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Array element within the destination binding to copy to
    dstArrayElement: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Number of descriptors to write (determines the size of the array pointed by pDescriptors)
    descriptorCount: u32 = 0,
};
// Extension: VK_BASE_VERSION_1_4
// Extends: VkBufferViewCreateInfo,VkBufferCreateInfo,VkPhysicalDeviceExternalBufferInfo,VkDescriptorBufferBindingInfoEXT
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkBufferUsageFlags2CreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    usage: VkBufferUsageFlags2 = .{},
};
// Extension: VK_KHR_maintenance5
pub const VkBufferUsageFlags2CreateInfoKHR = VkBufferUsageFlags2CreateInfo;
// Extension: VK_BASE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkBufferCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    // Comment: Buffer creation flags
    flags: VkBufferCreateFlags = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Specified in bytes
    size: u64 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Buffer usage flags
    usage: VkBufferUsageFlags = .{},
    // Extern sync: false
    // Optional: false
    sharingMode: VkSharingMode,
    // Extern sync: false
    // Optional: true
    queueFamilyIndexCount: u32 = 0,
    // Length member: queueFamilyIndexCount
    // Extern sync: false
    // Optional: false
    pQueueFamilyIndices: ?[*]const u32 = null,
};
// Extension: VK_COMPUTE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkBufferViewCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkBufferViewCreateFlags = .{},
    // Extern sync: false
    // Optional: false
    buffer: VkBuffer = .none,
    // Extern sync: false
    // Optional: false
    // Comment: Optionally specifies format of elements
    format: VkFormat,
    // Extern sync: false
    // Optional: false
    // Comment: Specified in bytes
    offset: u64 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: View size specified in bytes
    range: u64 = 0,
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImageSubresource = extern struct {
    // Extern sync: false
    // Optional: false
    aspectMask: VkImageAspectFlags = .{},
    // Extern sync: false
    // Optional: false
    mipLevel: u32 = 0,
    // Extern sync: false
    // Optional: false
    arrayLayer: u32 = 0,
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImageSubresourceLayers = extern struct {
    // Extern sync: false
    // Optional: false
    aspectMask: VkImageAspectFlags = .{},
    // Extern sync: false
    // Optional: false
    mipLevel: u32 = 0,
    // Extern sync: false
    // Optional: false
    baseArrayLayer: u32 = 0,
    // Extern sync: false
    // Optional: false
    layerCount: u32 = 0,
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImageSubresourceRange = extern struct {
    // Extern sync: false
    // Optional: false
    aspectMask: VkImageAspectFlags = .{},
    // Extern sync: false
    // Optional: false
    baseMipLevel: u32 = 0,
    // Extern sync: false
    // Optional: false
    levelCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    baseArrayLayer: u32 = 0,
    // Extern sync: false
    // Optional: false
    layerCount: u32 = 0,
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkMemoryBarrier = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_MEMORY_BARRIER,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    // Comment: Memory accesses from the source of the dependency to synchronize
    srcAccessMask: VkAccessFlags = .{},
    // Extern sync: false
    // Optional: true
    // Comment: Memory accesses from the destination of the dependency to synchronize
    dstAccessMask: VkAccessFlags = .{},
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkBufferMemoryBarrier = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: Memory accesses from the source of the dependency to synchronize
    srcAccessMask: VkAccessFlags = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Memory accesses from the destination of the dependency to synchronize
    dstAccessMask: VkAccessFlags = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Queue family to transition ownership from
    srcQueueFamilyIndex: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Queue family to transition ownership to
    dstQueueFamilyIndex: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Buffer to sync
    buffer: VkBuffer = .none,
    // Extern sync: false
    // Optional: false
    // Comment: Offset within the buffer to sync
    offset: u64 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Amount of bytes to sync
    size: u64 = 0,
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImageMemoryBarrier = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: Memory accesses from the source of the dependency to synchronize
    srcAccessMask: VkAccessFlags = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Memory accesses from the destination of the dependency to synchronize
    dstAccessMask: VkAccessFlags = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Current layout of the image
    oldLayout: VkImageLayout,
    // Extern sync: false
    // Optional: false
    // Comment: New layout to transition the image to
    newLayout: VkImageLayout,
    // Extern sync: false
    // Optional: false
    // Comment: Queue family to transition ownership from
    srcQueueFamilyIndex: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Queue family to transition ownership to
    dstQueueFamilyIndex: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Image to sync
    image: VkImage = .none,
    // Extern sync: false
    // Optional: false
    // Comment: Subresource range to sync
    subresourceRange: VkImageSubresourceRange = .{},
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImageCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    // Comment: Image creation flags
    flags: VkImageCreateFlags = .{},
    // Extern sync: false
    // Optional: false
    imageType: VkImageType,
    // Extern sync: false
    // Optional: false
    format: VkFormat,
    // Extern sync: false
    // Optional: false
    extent: VkExtent3D = .{},
    // Extern sync: false
    // Optional: false
    mipLevels: u32 = 0,
    // Extern sync: false
    // Optional: false
    arrayLayers: u32 = 0,
    // Extern sync: false
    // Optional: false
    samples: VkSampleCountFlags = .{},
    // Extern sync: false
    // Optional: false
    tiling: VkImageTiling,
    // Extern sync: false
    // Optional: false
    // Comment: Image usage flags
    usage: VkImageUsageFlags = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Cross-queue-family sharing mode
    sharingMode: VkSharingMode,
    // Extern sync: false
    // Optional: true
    // Comment: Number of queue families to share across
    queueFamilyIndexCount: u32 = 0,
    // Length member: queueFamilyIndexCount
    // Extern sync: false
    // Optional: false
    // Comment: Array of queue family indices to share across
    pQueueFamilyIndices: ?[*]const u32 = null,
    // Extern sync: false
    // Optional: false
    // Comment: Initial image layout for all subresources
    initialLayout: VkImageLayout,
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSubresourceLayout = extern struct {
    // Extern sync: false
    // Optional: false
    // Comment: Specified in bytes
    offset: u64 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Specified in bytes
    size: u64 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Specified in bytes
    rowPitch: u64 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Specified in bytes
    arrayPitch: u64 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Specified in bytes
    depthPitch: u64 = 0,
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImageViewCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkImageViewCreateFlags = .{},
    // Extern sync: false
    // Optional: false
    image: VkImage = .none,
    // Extern sync: false
    // Optional: false
    viewType: VkImageViewType,
    // Extern sync: false
    // Optional: false
    format: VkFormat,
    // Extern sync: false
    // Optional: false
    components: VkComponentMapping = .{},
    // Extern sync: false
    // Optional: false
    subresourceRange: VkImageSubresourceRange = .{},
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkBufferCopy = extern struct {
    // Extern sync: false
    // Optional: false
    // Comment: Specified in bytes
    srcOffset: u64 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Specified in bytes
    dstOffset: u64 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Specified in bytes
    size: u64 = 0,
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSparseMemoryBind = extern struct {
    // Extern sync: false
    // Optional: false
    // Comment: Specified in bytes
    resourceOffset: u64 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Specified in bytes
    size: u64 = 0,
    // Extern sync: false
    // Optional: true
    memory: VkDeviceMemory = .none,
    // Extern sync: false
    // Optional: false
    // Comment: Specified in bytes
    memoryOffset: u64 = 0,
    // Extern sync: false
    // Optional: true
    flags: VkSparseMemoryBindFlags = .{},
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSparseImageMemoryBind = extern struct {
    // Extern sync: false
    // Optional: false
    subresource: VkImageSubresource = .{},
    // Extern sync: false
    // Optional: false
    offset: VkOffset3D = .{},
    // Extern sync: false
    // Optional: false
    extent: VkExtent3D = .{},
    // Extern sync: false
    // Optional: true
    memory: VkDeviceMemory = .none,
    // Extern sync: false
    // Optional: false
    // Comment: Specified in bytes
    memoryOffset: u64 = 0,
    // Extern sync: false
    // Optional: true
    flags: VkSparseMemoryBindFlags = .{},
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSparseBufferMemoryBindInfo = extern struct {
    // Extern sync: false
    // Optional: false
    buffer: VkBuffer = .none,
    // Extern sync: false
    // Optional: false
    bindCount: u32 = 0,
    // Length member: bindCount
    // Extern sync: false
    // Optional: false
    pBinds: ?[*]const VkSparseMemoryBind = null,
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSparseImageOpaqueMemoryBindInfo = extern struct {
    // Extern sync: false
    // Optional: false
    image: VkImage = .none,
    // Extern sync: false
    // Optional: false
    bindCount: u32 = 0,
    // Length member: bindCount
    // Extern sync: false
    // Optional: false
    pBinds: ?[*]const VkSparseMemoryBind = null,
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSparseImageMemoryBindInfo = extern struct {
    // Extern sync: false
    // Optional: false
    image: VkImage = .none,
    // Extern sync: false
    // Optional: false
    bindCount: u32 = 0,
    // Length member: bindCount
    // Extern sync: false
    // Optional: false
    pBinds: ?[*]const VkSparseImageMemoryBind = null,
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkBindSparseInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_BIND_SPARSE_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    waitSemaphoreCount: u32 = 0,
    // Length member: waitSemaphoreCount
    // Extern sync: false
    // Optional: false
    pWaitSemaphores: ?[*]const VkSemaphore = null,
    // Extern sync: false
    // Optional: true
    bufferBindCount: u32 = 0,
    // Length member: bufferBindCount
    // Extern sync: false
    // Optional: false
    pBufferBinds: ?[*]const VkSparseBufferMemoryBindInfo = null,
    // Extern sync: false
    // Optional: true
    imageOpaqueBindCount: u32 = 0,
    // Length member: imageOpaqueBindCount
    // Extern sync: false
    // Optional: false
    pImageOpaqueBinds: ?[*]const VkSparseImageOpaqueMemoryBindInfo = null,
    // Extern sync: false
    // Optional: true
    imageBindCount: u32 = 0,
    // Length member: imageBindCount
    // Extern sync: false
    // Optional: false
    pImageBinds: ?[*]const VkSparseImageMemoryBindInfo = null,
    // Extern sync: false
    // Optional: true
    signalSemaphoreCount: u32 = 0,
    // Length member: signalSemaphoreCount
    // Extern sync: false
    // Optional: false
    pSignalSemaphores: ?[*]const VkSemaphore = null,
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImageCopy = extern struct {
    // Extern sync: false
    // Optional: false
    srcSubresource: VkImageSubresourceLayers = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Specified in pixels for both compressed and uncompressed images
    srcOffset: VkOffset3D = .{},
    // Extern sync: false
    // Optional: false
    dstSubresource: VkImageSubresourceLayers = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Specified in pixels for both compressed and uncompressed images
    dstOffset: VkOffset3D = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Specified in pixels for both compressed and uncompressed images
    extent: VkExtent3D = .{},
};
// Extension: VK_GRAPHICS_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImageBlit = extern struct {
    // Extern sync: false
    // Optional: false
    srcSubresource: VkImageSubresourceLayers = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Specified in pixels for both compressed and uncompressed images
    srcOffsets: [2]VkOffset3D = @import("std").mem.zeroes([2]VkOffset3D),
    // Extern sync: false
    // Optional: false
    dstSubresource: VkImageSubresourceLayers = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Specified in pixels for both compressed and uncompressed images
    dstOffsets: [2]VkOffset3D = @import("std").mem.zeroes([2]VkOffset3D),
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkBufferImageCopy = extern struct {
    // Extern sync: false
    // Optional: false
    // Comment: Specified in bytes
    bufferOffset: u64 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Specified in texels
    bufferRowLength: u32 = 0,
    // Extern sync: false
    // Optional: false
    bufferImageHeight: u32 = 0,
    // Extern sync: false
    // Optional: false
    imageSubresource: VkImageSubresourceLayers = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Specified in pixels for both compressed and uncompressed images
    imageOffset: VkOffset3D = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Specified in pixels for both compressed and uncompressed images
    imageExtent: VkExtent3D = .{},
};
// Extension: VK_KHR_copy_memory_indirect
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkStridedDeviceAddressRangeKHR = extern struct {
    // Extern sync: false
    // Optional: true
    address: u64 = 0,
    // Extern sync: false
    // Optional: false
    size: u64 = 0,
    // Extern sync: false
    // Optional: false
    stride: u64 = 0,
};
// Extension: VK_KHR_copy_memory_indirect
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkCopyMemoryIndirectCommandKHR = extern struct {
    // Extern sync: false
    // Optional: false
    srcAddress: u64 = 0,
    // Extern sync: false
    // Optional: false
    dstAddress: u64 = 0,
    // Extern sync: false
    // Optional: false
    size: u64 = 0,
};
// Extension: VK_NV_copy_memory_indirect
pub const VkCopyMemoryIndirectCommandNV = VkCopyMemoryIndirectCommandKHR;
// Extension: VK_KHR_copy_memory_indirect
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkCopyMemoryIndirectInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_COPY_MEMORY_INDIRECT_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    srcCopyFlags: VkAddressCopyFlagsKHR = .{},
    // Extern sync: false
    // Optional: false
    dstCopyFlags: VkAddressCopyFlagsKHR = .{},
    // Extern sync: false
    // Optional: false
    copyCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    copyAddressRange: VkStridedDeviceAddressRangeKHR = .{},
};
// Extension: VK_KHR_copy_memory_indirect
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkCopyMemoryToImageIndirectCommandKHR = extern struct {
    // Extern sync: false
    // Optional: false
    srcAddress: u64 = 0,
    // Extern sync: false
    // Optional: false
    bufferRowLength: u32 = 0,
    // Extern sync: false
    // Optional: false
    bufferImageHeight: u32 = 0,
    // Extern sync: false
    // Optional: false
    imageSubresource: VkImageSubresourceLayers = .{},
    // Extern sync: false
    // Optional: false
    imageOffset: VkOffset3D = .{},
    // Extern sync: false
    // Optional: false
    imageExtent: VkExtent3D = .{},
};
// Extension: VK_NV_copy_memory_indirect
pub const VkCopyMemoryToImageIndirectCommandNV = VkCopyMemoryToImageIndirectCommandKHR;
// Extension: VK_KHR_copy_memory_indirect
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkCopyMemoryToImageIndirectInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_COPY_MEMORY_TO_IMAGE_INDIRECT_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    srcCopyFlags: VkAddressCopyFlagsKHR = .{},
    // Extern sync: false
    // Optional: false
    copyCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    copyAddressRange: VkStridedDeviceAddressRangeKHR = .{},
    // Extern sync: false
    // Optional: false
    dstImage: VkImage = .none,
    // Extern sync: false
    // Optional: false
    dstImageLayout: VkImageLayout,
    // Length member: copyCount
    // Extern sync: false
    // Optional: false
    pImageSubresources: ?[*]const VkImageSubresourceLayers = null,
};
// Extension: VK_GRAPHICS_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImageResolve = extern struct {
    // Extern sync: false
    // Optional: false
    srcSubresource: VkImageSubresourceLayers = .{},
    // Extern sync: false
    // Optional: false
    srcOffset: VkOffset3D = .{},
    // Extern sync: false
    // Optional: false
    dstSubresource: VkImageSubresourceLayers = .{},
    // Extern sync: false
    // Optional: false
    dstOffset: VkOffset3D = .{},
    // Extern sync: false
    // Optional: false
    extent: VkExtent3D = .{},
};
// Extension: VK_COMPUTE_VERSION_1_0
// Extends: VkPipelineShaderStageCreateInfo,VkDataGraphPipelineCreateInfoARM
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkShaderModuleCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO,
    // Extern sync: false
    // Optional: true
    // Comment: noautovalidity because this structure can be either an explicit parameter, or passed in a pNext chain
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkShaderModuleCreateFlags = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Specified in bytes
    codeSize: u64 = 0,
    // Length member: codeSize / 4
    // Extern sync: false
    // Optional: false
    // Comment: Binary code of size codeSize
    pCode: ?[*]const u32 = null,
};
// Extension: VK_COMPUTE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDescriptorSetLayoutBinding = extern struct {
    // Extern sync: false
    // Optional: false
    // Comment: Binding number for this entry
    binding: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Type of the descriptors in this binding
    descriptorType: VkDescriptorType,
    // Extern sync: false
    // Optional: true
    // Comment: Number of descriptors in this binding
    descriptorCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Shader stages this binding is visible to
    stageFlags: VkShaderStageFlags = .{},
    // Length member: descriptorCount
    // Extern sync: false
    // Optional: true
    // Comment: Immutable samplers (used if descriptor type is SAMPLER or COMBINED_IMAGE_SAMPLER, is either NULL or contains count number of elements)
    pImmutableSamplers: ?[*]const VkSampler = null,
};
// Extension: VK_COMPUTE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDescriptorSetLayoutCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkDescriptorSetLayoutCreateFlags = .{},
    // Extern sync: false
    // Optional: true
    // Comment: Number of bindings in the descriptor set layout
    bindingCount: u32 = 0,
    // Length member: bindingCount
    // Extern sync: false
    // Optional: false
    // Comment: Array of descriptor set layout bindings
    pBindings: ?[*]const VkDescriptorSetLayoutBinding = null,
};
// Extension: VK_COMPUTE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDescriptorPoolSize = extern struct {
    // Extern sync: false
    // Optional: false
    type: VkDescriptorType,
    // Extern sync: false
    // Optional: false
    descriptorCount: u32 = 0,
};
// Extension: VK_COMPUTE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDescriptorPoolCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkDescriptorPoolCreateFlags = .{},
    // Extern sync: false
    // Optional: false
    maxSets: u32 = 0,
    // Extern sync: false
    // Optional: true
    poolSizeCount: u32 = 0,
    // Length member: poolSizeCount
    // Extern sync: false
    // Optional: false
    pPoolSizes: ?[*]const VkDescriptorPoolSize = null,
};
// Extension: VK_COMPUTE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDescriptorSetAllocateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: true
    // Optional: false
    descriptorPool: VkDescriptorPool = .none,
    // Extern sync: false
    // Optional: false
    descriptorSetCount: u32 = 0,
    // Length member: descriptorSetCount
    // Extern sync: false
    // Optional: false
    pSetLayouts: ?[*]const VkDescriptorSetLayout = null,
};
// Extension: VK_COMPUTE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSpecializationMapEntry = extern struct {
    // Extern sync: false
    // Optional: false
    // Comment: The SpecConstant ID specified in the BIL
    constantID: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Offset of the value in the data block
    offset: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Size in bytes of the SpecConstant
    size: u64 = 0,
};
// Extension: VK_COMPUTE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSpecializationInfo = extern struct {
    // Extern sync: false
    // Optional: true
    // Comment: Number of entries in the map
    mapEntryCount: u32 = 0,
    // Length member: mapEntryCount
    // Extern sync: false
    // Optional: false
    // Comment: Array of map entries
    pMapEntries: ?[*]const VkSpecializationMapEntry = null,
    // Extern sync: false
    // Optional: true
    // Comment: Size in bytes of pData
    dataSize: u64 = 0,
    // Length member: dataSize
    // Extern sync: false
    // Optional: false
    // Comment: Pointer to SpecConstant data
    pData: ?[*]const anyopaque = null,
};
// Extension: VK_COMPUTE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineShaderStageCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkPipelineShaderStageCreateFlags = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Shader stage
    stage: VkShaderStageFlags = .{},
    // Extern sync: false
    // Optional: true
    // Comment: Module containing entry point
    module: VkShaderModule = .none,
    // Length member: null-terminated
    // Extern sync: false
    // Optional: false
    // Comment: Null-terminated entry point name
    pName: ?[*:0]const u8 = null,
};
// Extension: VK_COMPUTE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkComputePipelineCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    // Comment: Pipeline creation flags
    flags: VkPipelineCreateFlags = .{},
    // Extern sync: false
    // Optional: false
    stage: VkPipelineShaderStageCreateInfo = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Interface layout of the pipeline
    layout: VkPipelineLayout = .none,
    // Extern sync: false
    // Optional: true
    // Comment: If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is nonzero, it specifies the handle of the base pipeline this is a derivative of
    basePipelineHandle: VkPipeline = .none,
    // Extern sync: false
    // Optional: false
    // Comment: If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is not -1, it specifies an index into pCreateInfos of the base pipeline this is a derivative of
    basePipelineIndex: i32 = 0,
};
// Extension: VK_NV_device_generated_commands_compute
// Extends: VkComputePipelineCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkComputePipelineIndirectBufferInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_INDIRECT_BUFFER_INFO_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    deviceAddress: u64 = 0,
    // Extern sync: false
    // Optional: false
    size: u64 = 0,
    // Extern sync: false
    // Optional: true
    pipelineDeviceAddressCaptureReplay: u64 = 0,
};
// Extension: VK_COMPUTE_VERSION_1_4
// Extends: VkComputePipelineCreateInfo,VkGraphicsPipelineCreateInfo,VkRayTracingPipelineCreateInfoNV,VkRayTracingPipelineCreateInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineCreateFlags2CreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkPipelineCreateFlags2 = .{},
};
// Extension: VK_KHR_maintenance5
pub const VkPipelineCreateFlags2CreateInfoKHR = VkPipelineCreateFlags2CreateInfo;
// Extension: VK_GRAPHICS_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVertexInputBindingDescription = extern struct {
    // Extern sync: false
    // Optional: false
    // Comment: Vertex buffer binding id
    binding: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Distance between vertices in bytes (0 = no advancement)
    stride: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: The rate at which the vertex data is consumed
    inputRate: VkVertexInputRate,
};
// Extension: VK_GRAPHICS_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVertexInputAttributeDescription = extern struct {
    // Extern sync: false
    // Optional: false
    // Comment: location of the shader vertex attrib
    location: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Vertex buffer binding id
    binding: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: format of source data
    format: VkFormat,
    // Extern sync: false
    // Optional: false
    // Comment: Offset of first element in bytes from base of vertex
    offset: u32 = 0,
};
// Extension: VK_GRAPHICS_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineVertexInputStateCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkPipelineVertexInputStateCreateFlags = .{},
    // Extern sync: false
    // Optional: true
    // Comment: number of bindings
    vertexBindingDescriptionCount: u32 = 0,
    // Length member: vertexBindingDescriptionCount
    // Extern sync: false
    // Optional: false
    pVertexBindingDescriptions: ?[*]const VkVertexInputBindingDescription = null,
    // Extern sync: false
    // Optional: true
    // Comment: number of attributes
    vertexAttributeDescriptionCount: u32 = 0,
    // Length member: vertexAttributeDescriptionCount
    // Extern sync: false
    // Optional: false
    pVertexAttributeDescriptions: ?[*]const VkVertexInputAttributeDescription = null,
};
// Extension: VK_GRAPHICS_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineInputAssemblyStateCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkPipelineInputAssemblyStateCreateFlags = .{},
    // Extern sync: false
    // Optional: false
    topology: VkPrimitiveTopology,
    // Extern sync: false
    // Optional: false
    primitiveRestartEnable: u32 = 0,
};
// Extension: VK_GRAPHICS_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineTessellationStateCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkPipelineTessellationStateCreateFlags = .{},
    // Extern sync: false
    // Optional: false
    patchControlPoints: u32 = 0,
};
// Extension: VK_GRAPHICS_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineViewportStateCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkPipelineViewportStateCreateFlags = .{},
    // Extern sync: false
    // Optional: true
    viewportCount: u32 = 0,
    // Length member: viewportCount
    // Extern sync: false
    // Optional: true
    pViewports: ?[*]const VkViewport = null,
    // Extern sync: false
    // Optional: true
    scissorCount: u32 = 0,
    // Length member: scissorCount
    // Extern sync: false
    // Optional: true
    pScissors: ?[*]const VkRect2D = null,
};
// Extension: VK_GRAPHICS_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineRasterizationStateCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkPipelineRasterizationStateCreateFlags = .{},
    // Extern sync: false
    // Optional: false
    depthClampEnable: u32 = 0,
    // Extern sync: false
    // Optional: false
    rasterizerDiscardEnable: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: optional (GL45)
    polygonMode: VkPolygonMode,
    // Extern sync: false
    // Optional: true
    cullMode: VkCullModeFlags = .{},
    // Extern sync: false
    // Optional: false
    frontFace: VkFrontFace,
    // Extern sync: false
    // Optional: false
    depthBiasEnable: u32 = 0,
    // Extern sync: false
    // Optional: false
    depthBiasConstantFactor: f32 = 0,
    // Extern sync: false
    // Optional: false
    depthBiasClamp: f32 = 0,
    // Extern sync: false
    // Optional: false
    depthBiasSlopeFactor: f32 = 0,
    // Extern sync: false
    // Optional: false
    lineWidth: f32 = 0,
};
// Extension: VK_GRAPHICS_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineMultisampleStateCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkPipelineMultisampleStateCreateFlags = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Number of samples used for rasterization
    rasterizationSamples: VkSampleCountFlags = .{},
    // Extern sync: false
    // Optional: false
    // Comment: optional (GL45)
    sampleShadingEnable: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: optional (GL45)
    minSampleShading: f32 = 0,
    // Length member: (rasterizationSamples + 31) / 32
    // Extern sync: false
    // Optional: true
    // Comment: Array of sampleMask words
    pSampleMask: ?[*]const u32 = null,
    // Extern sync: false
    // Optional: false
    alphaToCoverageEnable: u32 = 0,
    // Extern sync: false
    // Optional: false
    alphaToOneEnable: u32 = 0,
};
// Extension: VK_GRAPHICS_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineColorBlendAttachmentState = extern struct {
    // Extern sync: false
    // Optional: false
    blendEnable: u32 = 0,
    // Extern sync: false
    // Optional: false
    srcColorBlendFactor: VkBlendFactor,
    // Extern sync: false
    // Optional: false
    dstColorBlendFactor: VkBlendFactor,
    // Extern sync: false
    // Optional: false
    colorBlendOp: VkBlendOp,
    // Extern sync: false
    // Optional: false
    srcAlphaBlendFactor: VkBlendFactor,
    // Extern sync: false
    // Optional: false
    dstAlphaBlendFactor: VkBlendFactor,
    // Extern sync: false
    // Optional: false
    alphaBlendOp: VkBlendOp,
    // Extern sync: false
    // Optional: true
    colorWriteMask: VkColorComponentFlags = .{},
};
// Extension: VK_GRAPHICS_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineColorBlendStateCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkPipelineColorBlendStateCreateFlags = .{},
    // Extern sync: false
    // Optional: false
    logicOpEnable: u32 = 0,
    // Extern sync: false
    // Optional: false
    logicOp: VkLogicOp,
    // Extern sync: false
    // Optional: true
    // Comment: # of pAttachments
    attachmentCount: u32 = 0,
    // Length member: attachmentCount
    // Extern sync: false
    // Optional: true
    pAttachments: ?[*]const VkPipelineColorBlendAttachmentState = null,
    // Extern sync: false
    // Optional: false
    blendConstants: [4]f32 = @import("std").mem.zeroes([4]f32),
};
// Extension: VK_GRAPHICS_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineDynamicStateCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkPipelineDynamicStateCreateFlags = .{},
    // Extern sync: false
    // Optional: true
    dynamicStateCount: u32 = 0,
    // Length member: dynamicStateCount
    // Extern sync: false
    // Optional: false
    pDynamicStates: ?[*]const VkDynamicState = null,
};
// Extension: VK_GRAPHICS_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkStencilOpState = extern struct {
    // Extern sync: false
    // Optional: false
    failOp: VkStencilOp,
    // Extern sync: false
    // Optional: false
    passOp: VkStencilOp,
    // Extern sync: false
    // Optional: false
    depthFailOp: VkStencilOp,
    // Extern sync: false
    // Optional: false
    compareOp: VkCompareOp,
    // Extern sync: false
    // Optional: false
    compareMask: u32 = 0,
    // Extern sync: false
    // Optional: false
    writeMask: u32 = 0,
    // Extern sync: false
    // Optional: false
    reference: u32 = 0,
};
// Extension: VK_GRAPHICS_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineDepthStencilStateCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkPipelineDepthStencilStateCreateFlags = .{},
    // Extern sync: false
    // Optional: false
    depthTestEnable: u32 = 0,
    // Extern sync: false
    // Optional: false
    depthWriteEnable: u32 = 0,
    // Extern sync: false
    // Optional: false
    depthCompareOp: VkCompareOp,
    // Extern sync: false
    // Optional: false
    // Comment: optional (depth_bounds_test)
    depthBoundsTestEnable: u32 = 0,
    // Extern sync: false
    // Optional: false
    stencilTestEnable: u32 = 0,
    // Extern sync: false
    // Optional: false
    front: VkStencilOpState = .{},
    // Extern sync: false
    // Optional: false
    back: VkStencilOpState = .{},
    // Extern sync: false
    // Optional: false
    minDepthBounds: f32 = 0,
    // Extern sync: false
    // Optional: false
    maxDepthBounds: f32 = 0,
};
// Extension: VK_GRAPHICS_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkGraphicsPipelineCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    // Comment: Pipeline creation flags
    flags: VkPipelineCreateFlags = .{},
    // Extern sync: false
    // Optional: true
    stageCount: u32 = 0,
    // Length member: stageCount
    // Extern sync: false
    // Optional: true
    // Comment: One entry for each active shader stage
    pStages: ?[*]const VkPipelineShaderStageCreateInfo = null,
};
// Extension: VK_COMPUTE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineCacheCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkPipelineCacheCreateFlags = .{},
    // Extern sync: false
    // Optional: true
    // Comment: Size of initial data to populate cache, in bytes
    initialDataSize: u64 = 0,
};
// Extension: VK_COMPUTE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineCacheHeaderVersionOne = extern struct {
};
// Extension: VKSC_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineCacheStageValidationIndexEntry = extern struct {
};
// Extension: VKSC_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineCacheSafetyCriticalIndexEntry = extern struct {
};
// Extension: VKSC_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineCacheHeaderVersionSafetyCriticalOne = extern struct {
};
// Extension: VK_QCOM_data_graph_model
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineCacheHeaderVersionDataGraphQCOM = extern struct {
};
// Extension: VK_COMPUTE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPushConstantRange = extern struct {
    // Extern sync: false
    // Optional: false
    // Comment: Which stages use the range
    stageFlags: VkShaderStageFlags = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Start of the range, in bytes
    offset: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Size of the range, in bytes
    size: u32 = 0,
};
// Extension: VK_KHR_pipeline_binary
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineBinaryCreateInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_BINARY_CREATE_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    pKeysAndDataInfo: ?*const VkPipelineBinaryKeysAndDataKHR = null,
    // Extern sync: false
    // Optional: true
    pipeline: VkPipeline = .none,
    // Extern sync: false
    // Optional: true
    pPipelineCreateInfo: ?*const VkPipelineCreateInfoKHR = null,
};
// Extension: VK_KHR_pipeline_binary
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineBinaryHandlesInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_BINARY_HANDLES_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    pipelineBinaryCount: u32 = 0,
    // Length member: pipelineBinaryCount
    // Extern sync: false
    // Optional: true
    pPipelineBinaries: ?[*]VkPipelineBinaryKHR = null,
};
// Extension: VK_KHR_pipeline_binary
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineBinaryDataKHR = extern struct {
    // Extern sync: false
    // Optional: false
    dataSize: u64 = 0,
    // Length member: dataSize
    // Extern sync: false
    // Optional: false
    pData: ?[*]anyopaque = null,
};
// Extension: VK_KHR_pipeline_binary
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineBinaryKeysAndDataKHR = extern struct {
    // Extern sync: false
    // Optional: false
    binaryCount: u32 = 0,
    // Length member: binaryCount
    // Extern sync: false
    // Optional: false
    pPipelineBinaryKeys: ?[*]const VkPipelineBinaryKeyKHR = null,
    // Length member: binaryCount
    // Extern sync: false
    // Optional: false
    pPipelineBinaryData: ?[*]const VkPipelineBinaryDataKHR = null,
};
// Extension: VK_KHR_pipeline_binary
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineBinaryKeyKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_BINARY_KEY_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    keySize: u32 = 0,
    // Extern sync: false
    // Optional: false
    key: [VK_MAX_PIPELINE_BINARY_KEY_SIZE_KHR]u8 = @import("std").mem.zeroes([VK_MAX_PIPELINE_BINARY_KEY_SIZE_KHR]u8),
};
// Extension: VK_KHR_pipeline_binary
// Extends: VkGraphicsPipelineCreateInfo,VkComputePipelineCreateInfo,VkRayTracingPipelineCreateInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineBinaryInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_BINARY_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    binaryCount: u32 = 0,
    // Length member: binaryCount
    // Extern sync: false
    // Optional: false
    pPipelineBinaries: ?[*]const VkPipelineBinaryKHR = null,
};
// Extension: VK_KHR_pipeline_binary
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkReleaseCapturedPipelineDataInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_RELEASE_CAPTURED_PIPELINE_DATA_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: true
    // Optional: false
    pipeline: VkPipeline = .none,
};
// Extension: VK_KHR_pipeline_binary
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineBinaryDataInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_BINARY_DATA_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    pipelineBinary: VkPipelineBinaryKHR = .none,
};
// Extension: VK_KHR_pipeline_binary
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineCreateInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_CREATE_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
};
// Extension: VK_COMPUTE_VERSION_1_0
// Extends: VkBindDescriptorSetsInfo,VkPushConstantsInfo,VkPushDescriptorSetInfo,VkPushDescriptorSetWithTemplateInfo,VkSetDescriptorBufferOffsetsInfoEXT,VkBindDescriptorBufferEmbeddedSamplersInfoEXT,VkIndirectCommandsLayoutCreateInfoEXT
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineLayoutCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkPipelineLayoutCreateFlags = .{},
    // Extern sync: false
    // Optional: true
    // Comment: Number of descriptor sets interfaced by the pipeline
    setLayoutCount: u32 = 0,
    // Length member: setLayoutCount
    // Extern sync: false
    // Optional: false
    // Comment: Array of setCount number of descriptor set layout objects defining the layout of the
    pSetLayouts: ?[*]const VkDescriptorSetLayout = null,
    // Extern sync: false
    // Optional: true
    // Comment: Number of push-constant ranges used by the pipeline
    pushConstantRangeCount: u32 = 0,
    // Length member: pushConstantRangeCount
    // Extern sync: false
    // Optional: false
    // Comment: Array of pushConstantRangeCount number of ranges used by various shader stages
    pPushConstantRanges: ?[*]const VkPushConstantRange = null,
};
// Extension: VK_COMPUTE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSamplerCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkSamplerCreateFlags = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Filter mode for magnification
    magFilter: VkFilter,
    // Extern sync: false
    // Optional: false
    // Comment: Filter mode for minifiation
    minFilter: VkFilter,
    // Extern sync: false
    // Optional: false
    // Comment: Mipmap selection mode
    mipmapMode: VkSamplerMipmapMode,
    // Extern sync: false
    // Optional: false
    addressModeU: VkSamplerAddressMode,
    // Extern sync: false
    // Optional: false
    addressModeV: VkSamplerAddressMode,
    // Extern sync: false
    // Optional: false
    addressModeW: VkSamplerAddressMode,
    // Extern sync: false
    // Optional: false
    mipLodBias: f32 = 0,
    // Extern sync: false
    // Optional: false
    anisotropyEnable: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxAnisotropy: f32 = 0,
    // Extern sync: false
    // Optional: false
    compareEnable: u32 = 0,
    // Extern sync: false
    // Optional: false
    compareOp: VkCompareOp,
    // Extern sync: false
    // Optional: false
    minLod: f32 = 0,
    // Extern sync: false
    // Optional: false
    maxLod: f32 = 0,
    // Extern sync: false
    // Optional: false
    borderColor: VkBorderColor,
    // Extern sync: false
    // Optional: false
    unnormalizedCoordinates: u32 = 0,
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkCommandPoolCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    // Comment: Command pool creation flags
    flags: VkCommandPoolCreateFlags = .{},
    // Extern sync: false
    // Optional: false
    queueFamilyIndex: u32 = 0,
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkCommandBufferAllocateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: true
    // Optional: false
    commandPool: VkCommandPool = .none,
    // Extern sync: false
    // Optional: false
    level: VkCommandBufferLevel,
    // Extern sync: false
    // Optional: false
    commandBufferCount: u32 = 0,
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkCommandBufferInheritanceInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    // Comment: Render pass for secondary command buffers
    renderPass: VkRenderPass = .none,
    // Extern sync: false
    // Optional: false
    subpass: u32 = 0,
    // Extern sync: false
    // Optional: true
    // Comment: Framebuffer for secondary command buffers
    framebuffer: VkFramebuffer = .none,
    // Extern sync: false
    // Optional: false
    // Comment: Whether this secondary command buffer may be executed during an occlusion query
    occlusionQueryEnable: u32 = 0,
    // Extern sync: false
    // Optional: true
    // Comment: Query flags used by this secondary command buffer, if executed during an occlusion query
    queryFlags: VkQueryControlFlags = .{},
    // Extern sync: false
    // Optional: true
    // Comment: Pipeline statistics that may be counted for this secondary command buffer
    pipelineStatistics: VkQueryPipelineStatisticFlags = .{},
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkCommandBufferBeginInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    // Comment: Command buffer usage flags
    flags: VkCommandBufferUsageFlags = .{},
    // Extern sync: false
    // Optional: true
    // Comment: Pointer to inheritance info for secondary command buffers
    pInheritanceInfo: ?*const VkCommandBufferInheritanceInfo = null,
};
// Extension: VK_GRAPHICS_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkRenderPassBeginInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    renderPass: VkRenderPass = .none,
    // Extern sync: false
    // Optional: false
    framebuffer: VkFramebuffer = .none,
    // Extern sync: false
    // Optional: false
    renderArea: VkRect2D = .{},
    // Extern sync: false
    // Optional: true
    clearValueCount: u32 = 0,
    // Length member: clearValueCount
    // Extern sync: false
    // Optional: false
    pClearValues: ?[*]const VkClearValue = null,
};
// Extension: VK_GRAPHICS_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkClearDepthStencilValue = extern struct {
    // Extern sync: false
    // Optional: false
    depth: f32 = 0,
    // Extern sync: false
    // Optional: false
    stencil: u32 = 0,
};
// Extension: VK_GRAPHICS_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkClearAttachment = extern struct {
    // Extern sync: false
    // Optional: false
    aspectMask: VkImageAspectFlags = .{},
    // Extern sync: false
    // Optional: false
    colorAttachment: u32 = 0,
    // Extern sync: false
    // Optional: false
    clearValue: VkClearValue,
};
// Extension: VK_GRAPHICS_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkAttachmentDescription = extern struct {
    // Extern sync: false
    // Optional: true
    flags: VkAttachmentDescriptionFlags = .{},
    // Extern sync: false
    // Optional: false
    format: VkFormat,
    // Extern sync: false
    // Optional: false
    samples: VkSampleCountFlags = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Load operation for color or depth data
    loadOp: VkAttachmentLoadOp,
    // Extern sync: false
    // Optional: false
    // Comment: Store operation for color or depth data
    storeOp: VkAttachmentStoreOp,
    // Extern sync: false
    // Optional: false
    // Comment: Load operation for stencil data
    stencilLoadOp: VkAttachmentLoadOp,
    // Extern sync: false
    // Optional: false
    // Comment: Store operation for stencil data
    stencilStoreOp: VkAttachmentStoreOp,
    // Extern sync: false
    // Optional: false
    initialLayout: VkImageLayout,
    // Extern sync: false
    // Optional: false
    finalLayout: VkImageLayout,
};
// Extension: VK_GRAPHICS_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkAttachmentReference = extern struct {
    // Extern sync: false
    // Optional: false
    attachment: u32 = 0,
    // Extern sync: false
    // Optional: false
    layout: VkImageLayout,
};
// Extension: VK_GRAPHICS_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSubpassDescription = extern struct {
    // Extern sync: false
    // Optional: true
    flags: VkSubpassDescriptionFlags = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Must be VK_PIPELINE_BIND_POINT_GRAPHICS for now
    pipelineBindPoint: VkPipelineBindPoint,
    // Extern sync: false
    // Optional: true
    inputAttachmentCount: u32 = 0,
    // Length member: inputAttachmentCount
    // Extern sync: false
    // Optional: false
    pInputAttachments: ?[*]const VkAttachmentReference = null,
    // Extern sync: false
    // Optional: true
    colorAttachmentCount: u32 = 0,
    // Length member: colorAttachmentCount
    // Extern sync: false
    // Optional: false
    pColorAttachments: ?[*]const VkAttachmentReference = null,
    // Length member: colorAttachmentCount
    // Extern sync: false
    // Optional: true
    pResolveAttachments: ?[*]const VkAttachmentReference = null,
    // Extern sync: false
    // Optional: true
    pDepthStencilAttachment: ?*const VkAttachmentReference = null,
    // Extern sync: false
    // Optional: true
    preserveAttachmentCount: u32 = 0,
    // Length member: preserveAttachmentCount
    // Extern sync: false
    // Optional: false
    pPreserveAttachments: ?[*]const u32 = null,
};
// Extension: VK_GRAPHICS_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSubpassDependency = extern struct {
    // Extern sync: false
    // Optional: false
    srcSubpass: u32 = 0,
    // Extern sync: false
    // Optional: false
    dstSubpass: u32 = 0,
    // Extern sync: false
    // Optional: true
    srcStageMask: VkPipelineStageFlags = .{},
    // Extern sync: false
    // Optional: true
    dstStageMask: VkPipelineStageFlags = .{},
    // Extern sync: false
    // Optional: true
    // Comment: Memory accesses from the source of the dependency to synchronize
    srcAccessMask: VkAccessFlags = .{},
    // Extern sync: false
    // Optional: true
    // Comment: Memory accesses from the destination of the dependency to synchronize
    dstAccessMask: VkAccessFlags = .{},
    // Extern sync: false
    // Optional: true
    dependencyFlags: VkDependencyFlags = .{},
};
// Extension: VK_GRAPHICS_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkRenderPassCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkRenderPassCreateFlags = .{},
    // Extern sync: false
    // Optional: true
    attachmentCount: u32 = 0,
    // Length member: attachmentCount
    // Extern sync: false
    // Optional: false
    pAttachments: ?[*]const VkAttachmentDescription = null,
    // Extern sync: false
    // Optional: false
    subpassCount: u32 = 0,
    // Length member: subpassCount
    // Extern sync: false
    // Optional: false
    pSubpasses: ?[*]const VkSubpassDescription = null,
    // Extern sync: false
    // Optional: true
    dependencyCount: u32 = 0,
    // Length member: dependencyCount
    // Extern sync: false
    // Optional: false
    pDependencies: ?[*]const VkSubpassDependency = null,
};
// Extension: VK_COMPUTE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkEventCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_EVENT_CREATE_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    // Comment: Event creation flags
    flags: VkEventCreateFlags = .{},
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkFenceCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_FENCE_CREATE_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    // Comment: Fence creation flags
    flags: VkFenceCreateFlags = .{},
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceFeatures = extern struct {
    // Extern sync: false
    // Optional: false
    // Comment: out of bounds buffer accesses are well defined
    robustBufferAccess: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: full 32-bit range of indices for indexed draw calls
    fullDrawIndexUint32: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: image views which are arrays of cube maps
    imageCubeArray: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: blending operations are controlled per-attachment
    independentBlend: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: geometry stage
    geometryShader: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: tessellation control and evaluation stage
    tessellationShader: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: per-sample shading and interpolation
    sampleRateShading: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: blend operations which take two sources
    dualSrcBlend: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: logic operations
    logicOp: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: multi draw indirect
    multiDrawIndirect: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: indirect drawing can use non-zero firstInstance
    drawIndirectFirstInstance: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: depth clamping
    depthClamp: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: depth bias clamping
    depthBiasClamp: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: point and wireframe fill modes
    fillModeNonSolid: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: depth bounds test
    depthBounds: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: lines with width greater than 1
    wideLines: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: points with size greater than 1
    largePoints: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: the fragment alpha component can be forced to maximum representable alpha value
    alphaToOne: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: viewport arrays
    multiViewport: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: anisotropic sampler filtering
    samplerAnisotropy: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: ETC texture compression formats
    textureCompressionETC2: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: ASTC LDR texture compression formats
    textureCompressionASTC_LDR: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: BC1-7 texture compressed formats
    textureCompressionBC: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: precise occlusion queries returning actual sample counts
    occlusionQueryPrecise: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: pipeline statistics query
    pipelineStatisticsQuery: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: stores and atomic ops on storage buffers and images are supported in vertex, tessellation, and geometry stages
    vertexPipelineStoresAndAtomics: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: stores and atomic ops on storage buffers and images are supported in the fragment stage
    fragmentStoresAndAtomics: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: tessellation and geometry stages can export point size
    shaderTessellationAndGeometryPointSize: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: image gather with runtime values and independent offsets
    shaderImageGatherExtended: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: the extended set of formats can be used for storage images
    shaderStorageImageExtendedFormats: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: multisample images can be used for storage images
    shaderStorageImageMultisample: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: read from storage image does not require format qualifier
    shaderStorageImageReadWithoutFormat: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: write to storage image does not require format qualifier
    shaderStorageImageWriteWithoutFormat: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: arrays of uniform buffers can be accessed with dynamically uniform indices
    shaderUniformBufferArrayDynamicIndexing: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: arrays of sampled images can be accessed with dynamically uniform indices
    shaderSampledImageArrayDynamicIndexing: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: arrays of storage buffers can be accessed with dynamically uniform indices
    shaderStorageBufferArrayDynamicIndexing: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: arrays of storage images can be accessed with dynamically uniform indices
    shaderStorageImageArrayDynamicIndexing: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: clip distance in shaders
    shaderClipDistance: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: cull distance in shaders
    shaderCullDistance: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: 64-bit floats (doubles) in shaders
    shaderFloat64: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: 64-bit integers in shaders
    shaderInt64: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: 16-bit integers in shaders
    shaderInt16: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: shader can use texture operations that return resource residency information (requires sparseNonResident support)
    shaderResourceResidency: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: shader can use texture operations that specify minimum resource LOD
    shaderResourceMinLod: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Sparse resources support: Resource memory can be managed at opaque page level rather than object level
    sparseBinding: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Sparse resources support: GPU can access partially resident buffers 
    sparseResidencyBuffer: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Sparse resources support: GPU can access partially resident 2D (non-MSAA non-depth/stencil) images 
    sparseResidencyImage2D: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Sparse resources support: GPU can access partially resident 3D images 
    sparseResidencyImage3D: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Sparse resources support: GPU can access partially resident MSAA 2D images with 2 samples
    sparseResidency2Samples: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Sparse resources support: GPU can access partially resident MSAA 2D images with 4 samples
    sparseResidency4Samples: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Sparse resources support: GPU can access partially resident MSAA 2D images with 8 samples
    sparseResidency8Samples: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Sparse resources support: GPU can access partially resident MSAA 2D images with 16 samples
    sparseResidency16Samples: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Sparse resources support: GPU can correctly access data aliased into multiple locations (opt-in)
    sparseResidencyAliased: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: multisample rate must be the same for all pipelines in a subpass
    variableMultisampleRate: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Queries may be inherited from primary to secondary command buffers
    inheritedQueries: u32 = 0,
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceSparseProperties = extern struct {
    // Extern sync: false
    // Optional: false
    // Comment: Sparse resources support: GPU will access all 2D (single sample) sparse resources using the standard sparse image block shapes (based on pixel format)
    residencyStandard2DBlockShape: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Sparse resources support: GPU will access all 2D (multisample) sparse resources using the standard sparse image block shapes (based on pixel format)
    residencyStandard2DMultisampleBlockShape: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Sparse resources support: GPU will access all 3D sparse resources using the standard sparse image block shapes (based on pixel format)
    residencyStandard3DBlockShape: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Sparse resources support: Images with mip level dimensions that are NOT a multiple of the sparse image block dimensions will be placed in the mip tail
    residencyAlignedMipSize: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Sparse resources support: GPU can consistently access non-resident regions of a resource, all reads return as if data is 0, writes are discarded
    residencyNonResidentStrict: u32 = 0,
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceLimits = extern struct {
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSemaphoreCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    // Comment: Semaphore creation flags
    flags: VkSemaphoreCreateFlags = .{},
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkQueryPoolCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkQueryPoolCreateFlags = .{},
    // Extern sync: false
    // Optional: false
    queryType: VkQueryType,
    // Extern sync: false
    // Optional: false
    queryCount: u32 = 0,
    // Extern sync: false
    // Optional: true
    // Comment: Optional
    pipelineStatistics: VkQueryPipelineStatisticFlags = .{},
};
// Extension: VK_GRAPHICS_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkFramebufferCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkFramebufferCreateFlags = .{},
    // Extern sync: false
    // Optional: false
    renderPass: VkRenderPass = .none,
    // Extern sync: false
    // Optional: true
    attachmentCount: u32 = 0,
    // Length member: attachmentCount
    // Extern sync: false
    // Optional: false
    pAttachments: ?[*]const VkImageView = null,
    // Extern sync: false
    // Optional: false
    width: u32 = 0,
    // Extern sync: false
    // Optional: false
    height: u32 = 0,
    // Extern sync: false
    // Optional: false
    layers: u32 = 0,
};
// Extension: VK_GRAPHICS_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDrawIndirectCommand = extern struct {
    // Extern sync: false
    // Optional: false
    vertexCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    instanceCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    firstVertex: u32 = 0,
    // Extern sync: false
    // Optional: false
    firstInstance: u32 = 0,
};
// Extension: VK_GRAPHICS_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDrawIndexedIndirectCommand = extern struct {
    // Extern sync: false
    // Optional: false
    indexCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    instanceCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    firstIndex: u32 = 0,
    // Extern sync: false
    // Optional: false
    vertexOffset: i32 = 0,
    // Extern sync: false
    // Optional: false
    firstInstance: u32 = 0,
};
// Extension: VK_COMPUTE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDispatchIndirectCommand = extern struct {
    // Extern sync: false
    // Optional: false
    x: u32 = 0,
    // Extern sync: false
    // Optional: false
    y: u32 = 0,
    // Extern sync: false
    // Optional: false
    z: u32 = 0,
};
// Extension: VK_EXT_multi_draw
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkMultiDrawInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    firstVertex: u32 = 0,
    // Extern sync: false
    // Optional: false
    vertexCount: u32 = 0,
};
// Extension: VK_EXT_multi_draw
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkMultiDrawIndexedInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    firstIndex: u32 = 0,
    // Extern sync: false
    // Optional: false
    indexCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    vertexOffset: i32 = 0,
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSubmitInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_SUBMIT_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    waitSemaphoreCount: u32 = 0,
    // Length member: waitSemaphoreCount
    // Extern sync: false
    // Optional: false
    pWaitSemaphores: ?[*]const VkSemaphore = null,
    // Length member: waitSemaphoreCount
    // Extern sync: false
    // Optional: false
    pWaitDstStageMask: ?[*]const VkPipelineStageFlags = null,
    // Extern sync: false
    // Optional: true
    commandBufferCount: u32 = 0,
    // Length member: commandBufferCount
    // Extern sync: false
    // Optional: false
    pCommandBuffers: ?[*]const VkCommandBuffer = null,
    // Extern sync: false
    // Optional: true
    signalSemaphoreCount: u32 = 0,
    // Length member: signalSemaphoreCount
    // Extern sync: false
    // Optional: false
    pSignalSemaphores: ?[*]const VkSemaphore = null,
};
// Extension: VK_KHR_display
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkDisplayPropertiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    // Comment: Handle of the display object
    display: VkDisplayKHR = .none,
    // Length member: null-terminated
    // Extern sync: false
    // Optional: false
    // Comment: Name of the display
    displayName: ?[*:0]const u8 = null,
    // Extern sync: false
    // Optional: false
    // Comment: In millimeters?
    physicalDimensions: VkExtent2D = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Max resolution for CRT?
    physicalResolution: VkExtent2D = .{},
    // Extern sync: false
    // Optional: true
    // Comment: one or more bits from VkSurfaceTransformFlagsKHR
    supportedTransforms: VkSurfaceTransformFlagsKHR = .{},
    // Extern sync: false
    // Optional: false
    // Comment: VK_TRUE if the overlay plane's z-order can be changed on this display.
    planeReorderPossible: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: VK_TRUE if this is a "smart" display that supports self-refresh/internal buffering.
    persistentContent: u32 = 0,
};
// Extension: VK_KHR_display
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkDisplayPlanePropertiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    // Comment: Display the plane is currently associated with.  Will be VK_NULL_HANDLE if the plane is not in use.
    currentDisplay: VkDisplayKHR = .none,
    // Extern sync: false
    // Optional: false
    // Comment: Current z-order of the plane.
    currentStackIndex: u32 = 0,
};
// Extension: VK_KHR_display
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDisplayModeParametersKHR = extern struct {
    // Extern sync: false
    // Optional: false
    // Comment: Visible scanout region.
    visibleRegion: VkExtent2D = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Number of times per second the display is updated.
    refreshRate: u32 = 0,
};
// Extension: VK_KHR_display
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkDisplayModePropertiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    // Comment: Handle of this display mode.
    displayMode: VkDisplayModeKHR = .none,
    // Extern sync: false
    // Optional: false
    // Comment: The parameters this mode uses.
    parameters: VkDisplayModeParametersKHR = .{},
};
// Extension: VK_KHR_display
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDisplayModeCreateInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkDisplayModeCreateFlagsKHR = .{},
    // Extern sync: false
    // Optional: false
    // Comment: The parameters this mode uses.
    parameters: VkDisplayModeParametersKHR = .{},
};
// Extension: VK_KHR_display
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkDisplayPlaneCapabilitiesKHR = extern struct {
    // Extern sync: false
    // Optional: true
    // Comment: Types of alpha blending supported, if any.
    supportedAlpha: VkDisplayPlaneAlphaFlagsKHR = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Does the plane have any position and extent restrictions?
    minSrcPosition: VkOffset2D = .{},
    // Extern sync: false
    // Optional: false
    maxSrcPosition: VkOffset2D = .{},
    // Extern sync: false
    // Optional: false
    minSrcExtent: VkExtent2D = .{},
    // Extern sync: false
    // Optional: false
    maxSrcExtent: VkExtent2D = .{},
    // Extern sync: false
    // Optional: false
    minDstPosition: VkOffset2D = .{},
    // Extern sync: false
    // Optional: false
    maxDstPosition: VkOffset2D = .{},
    // Extern sync: false
    // Optional: false
    minDstExtent: VkExtent2D = .{},
    // Extern sync: false
    // Optional: false
    maxDstExtent: VkExtent2D = .{},
};
// Extension: VK_KHR_display
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDisplaySurfaceCreateInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkDisplaySurfaceCreateFlagsKHR = .{},
    // Extern sync: false
    // Optional: false
    // Comment: The mode to use when displaying this surface
    displayMode: VkDisplayModeKHR = .none,
    // Extern sync: false
    // Optional: false
    // Comment: The plane on which this surface appears.  Must be between 0 and the value returned by vkGetPhysicalDeviceDisplayPlanePropertiesKHR() in pPropertyCount.
    planeIndex: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: The z-order of the plane.
    planeStackIndex: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Transform to apply to the images as part of the scanout operation
    transform: VkSurfaceTransformFlagsKHR = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Global alpha value.  Must be between 0 and 1, inclusive.  Ignored if alphaMode is not VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR
    globalAlpha: f32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: The type of alpha blending to use. Must be one of the bits from VkDisplayPlaneCapabilitiesKHR::supportedAlpha for this display plane
    alphaMode: VkDisplayPlaneAlphaFlagsKHR = .{},
    // Extern sync: false
    // Optional: false
    // Comment: size of the images to use with this surface
    imageExtent: VkExtent2D = .{},
};
// Extension: VK_NV_display_stereo
// Extends: VkDisplaySurfaceCreateInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDisplaySurfaceStereoCreateInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_DISPLAY_SURFACE_STEREO_CREATE_INFO_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: The 3D stereo type to use when presenting this surface.
    stereoType: VkDisplaySurfaceStereoTypeNV,
};
// Extension: VK_KHR_display_swapchain
// Extends: VkPresentInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDisplayPresentInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: Rectangle within the presentable image to read pixel data from when presenting to the display.
    srcRect: VkRect2D = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Rectangle within the current display mode's visible region to display srcRectangle in.
    dstRect: VkRect2D = .{},
    // Extern sync: false
    // Optional: false
    // Comment: For smart displays, use buffered mode.  If the display properties member "persistentMode" is VK_FALSE, this member must always be VK_FALSE.
    persistent: u32 = 0,
};
// Extension: VK_KHR_surface
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkSurfaceCapabilitiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    // Comment: Supported minimum number of images for the surface
    minImageCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Supported maximum number of images for the surface, 0 for unlimited
    maxImageCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Current image width and height for the surface, (0, 0) if undefined
    currentExtent: VkExtent2D = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Supported minimum image width and height for the surface
    minImageExtent: VkExtent2D = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Supported maximum image width and height for the surface
    maxImageExtent: VkExtent2D = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Supported maximum number of image layers for the surface
    maxImageArrayLayers: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: 1 or more bits representing the transforms supported
    supportedTransforms: VkSurfaceTransformFlagsKHR = .{},
    // Extern sync: false
    // Optional: false
    // Comment: The surface's current transform relative to the device's natural orientation
    currentTransform: VkSurfaceTransformFlagsKHR = .{},
    // Extern sync: false
    // Optional: false
    // Comment: 1 or more bits representing the alpha compositing modes supported
    supportedCompositeAlpha: VkCompositeAlphaFlagsKHR = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Supported image usage flags for the surface
    supportedUsageFlags: VkImageUsageFlags = .{},
};
// Extension: VK_KHR_android_surface
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkAndroidSurfaceCreateInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkAndroidSurfaceCreateFlagsKHR = .{},
    // Extern sync: false
    // Optional: false
    window: ?*ANativeWindow = null,
};
// Extension: VK_NN_vi_surface
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkViSurfaceCreateInfoNN = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkViSurfaceCreateFlagsNN = .{},
    // Extern sync: false
    // Optional: false
    window: ?*anyopaque = null,
};
// Extension: VK_KHR_wayland_surface
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkWaylandSurfaceCreateInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkWaylandSurfaceCreateFlagsKHR = .{},
    // Extern sync: false
    // Optional: false
    display: ?*wl_display = null,
    // Extern sync: false
    // Optional: false
    surface: ?*wl_surface = null,
};
// Extension: VK_KHR_win32_surface
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkWin32SurfaceCreateInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkWin32SurfaceCreateFlagsKHR = .{},
    // Extern sync: false
    // Optional: false
    // Extern sync: false
    // Optional: false
};
// Extension: VK_KHR_xlib_surface
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkXlibSurfaceCreateInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkXlibSurfaceCreateFlagsKHR = .{},
    // Extern sync: false
    // Optional: false
    dpy: ?*Display = null,
    // Extern sync: false
    // Optional: false
};
// Extension: VK_KHR_xcb_surface
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkXcbSurfaceCreateInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkXcbSurfaceCreateFlagsKHR = .{},
    // Extern sync: false
    // Optional: false
    connection: ?*xcb_connection_t = null,
    // Extern sync: false
    // Optional: false
};
// Extension: VK_EXT_directfb_surface
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDirectFBSurfaceCreateInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_DIRECTFB_SURFACE_CREATE_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkDirectFBSurfaceCreateFlagsEXT = .{},
    // Extern sync: false
    // Optional: false
    dfb: ?*IDirectFB = null,
    // Extern sync: false
    // Optional: false
    surface: ?*IDirectFBSurface = null,
};
// Extension: VK_FUCHSIA_imagepipe_surface
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImagePipeSurfaceCreateInfoFUCHSIA = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkImagePipeSurfaceCreateFlagsFUCHSIA = .{},
    // Extern sync: false
    // Optional: false
};
// Extension: VK_GGP_stream_descriptor_surface
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkStreamDescriptorSurfaceCreateInfoGGP = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_STREAM_DESCRIPTOR_SURFACE_CREATE_INFO_GGP,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkStreamDescriptorSurfaceCreateFlagsGGP = .{},
    // Extern sync: false
    // Optional: false
};
// Extension: VK_QNX_screen_surface
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkScreenSurfaceCreateInfoQNX = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_SCREEN_SURFACE_CREATE_INFO_QNX,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkScreenSurfaceCreateFlagsQNX = .{},
    // Extern sync: false
    // Optional: false
    context: ?*_screen_context = null,
    // Extern sync: false
    // Optional: false
    window: ?*_screen_window = null,
};
// Extension: VK_KHR_surface
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkSurfaceFormatKHR = extern struct {
    // Extern sync: false
    // Optional: false
    // Comment: Supported pair of rendering format
    format: VkFormat,
    // Extern sync: false
    // Optional: false
    // Comment: and color space for the surface
    colorSpace: VkColorSpaceKHR,
};
// Extension: VK_KHR_swapchain
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSwapchainCreateInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkSwapchainCreateFlagsKHR = .{},
    // Extern sync: true
    // Optional: false
    // Comment: The swapchain's target surface
    surface: VkSurfaceKHR = .none,
    // Extern sync: false
    // Optional: false
    // Comment: Minimum number of presentation images the application needs
    minImageCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Format of the presentation images
    imageFormat: VkFormat,
    // Extern sync: false
    // Optional: false
    // Comment: Colorspace of the presentation images
    imageColorSpace: VkColorSpaceKHR,
    // Extern sync: false
    // Optional: false
    // Comment: Dimensions of the presentation images
    imageExtent: VkExtent2D = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Determines the number of views for multiview/stereo presentation
    imageArrayLayers: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Bits indicating how the presentation images will be used
    imageUsage: VkImageUsageFlags = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Sharing mode used for the presentation images
    imageSharingMode: VkSharingMode,
    // Extern sync: false
    // Optional: true
    // Comment: Number of queue families having access to the images in case of concurrent sharing mode
    queueFamilyIndexCount: u32 = 0,
    // Length member: queueFamilyIndexCount
    // Extern sync: false
    // Optional: false
    // Comment: Array of queue family indices having access to the images in case of concurrent sharing mode
    pQueueFamilyIndices: ?[*]const u32 = null,
    // Extern sync: false
    // Optional: false
    // Comment: The transform, relative to the device's natural orientation, applied to the image content prior to presentation
    preTransform: VkSurfaceTransformFlagsKHR = .{},
    // Extern sync: false
    // Optional: false
    // Comment: The alpha blending mode used when compositing this surface with other surfaces in the window system
    compositeAlpha: VkCompositeAlphaFlagsKHR = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Which presentation mode to use for presents on this swap chain
    presentMode: VkPresentModeKHR,
    // Extern sync: false
    // Optional: false
    // Comment: Specifies whether presentable images may be affected by window clip regions
    clipped: u32 = 0,
    // Extern sync: true
    // Optional: true
    // Comment: Existing swap chain to replace, if any
    oldSwapchain: VkSwapchainKHR = .none,
};
// Extension: VK_KHR_swapchain
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPresentInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PRESENT_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    // Comment: Number of semaphores to wait for before presenting
    waitSemaphoreCount: u32 = 0,
    // Length member: waitSemaphoreCount
    // Extern sync: true
    // Optional: false
    // Comment: Semaphores to wait for before presenting
    pWaitSemaphores: ?[*]const VkSemaphore = null,
    // Extern sync: false
    // Optional: false
    // Comment: Number of swapchains to present in this call
    swapchainCount: u32 = 0,
    // Length member: swapchainCount
    // Extern sync: true
    // Optional: false
    // Comment: Swapchains to present an image from
    pSwapchains: ?[*]const VkSwapchainKHR = null,
    // Length member: swapchainCount
    // Extern sync: false
    // Optional: false
    // Comment: Indices of which presentable images to present
    pImageIndices: ?[*]const u32 = null,
    // Length member: swapchainCount
    // Extern sync: false
    // Optional: true
    // Comment: Optional (i.e. if non-NULL) VkResult for each swapchain
    pResults: ?[*]VkResult = null,
};
// Extension: VK_EXT_debug_report
// Extends: VkInstanceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDebugReportCallbackCreateInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    // Comment: Indicates which events call this callback
    flags: VkDebugReportFlagsEXT = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Function pointer of a callback function
    pfnCallback: ?*const vkDebugReportCallbackEXT = null,
    // Extern sync: false
    // Optional: true
    // Comment: Data provided to callback function
    pUserData: ?*anyopaque = null,
};
// Extension: VK_EXT_validation_flags
// Extends: VkInstanceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkValidationFlagsEXT = extern struct {
    // Extern sync: false
    // Optional: false
    // Comment: Must be VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: Number of validation checks to disable
    disabledValidationCheckCount: u32 = 0,
    // Length member: disabledValidationCheckCount
    // Extern sync: false
    // Optional: false
    // Comment: Validation checks to disable
    pDisabledValidationChecks: ?[*]const VkValidationCheckEXT = null,
};
// Extension: VK_EXT_validation_features
// Extends: VkInstanceCreateInfo,VkShaderModuleCreateInfo,VkShaderCreateInfoEXT
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkValidationFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    // Comment: Must be VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    // Comment: Number of validation features to enable
    enabledValidationFeatureCount: u32 = 0,
    // Length member: enabledValidationFeatureCount
    // Extern sync: false
    // Optional: false
    // Comment: Validation features to enable
    pEnabledValidationFeatures: ?[*]const VkValidationFeatureEnableEXT = null,
    // Extern sync: false
    // Optional: true
    // Comment: Number of validation features to disable
    disabledValidationFeatureCount: u32 = 0,
    // Length member: disabledValidationFeatureCount
    // Extern sync: false
    // Optional: false
    // Comment: Validation features to disable
    pDisabledValidationFeatures: ?[*]const VkValidationFeatureDisableEXT = null,
};
// Extension: VK_EXT_layer_settings
// Extends: VkInstanceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: true
pub const VkLayerSettingsCreateInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    // Comment: Must be VK_STRUCTURE_TYPE_LAYER_SETTINGS_CREATE_INFO_EXT
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_LAYER_SETTINGS_CREATE_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    // Comment: Number of settings to configure
    settingCount: u32 = 0,
    // Length member: settingCount
    // Extern sync: false
    // Optional: false
    // Comment: Validation features to enable
    pSettings: ?[*]const VkLayerSettingEXT = null,
};
// Extension: VK_EXT_layer_settings
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkLayerSettingEXT = extern struct {
    // Length member: null-terminated
    // Extern sync: false
    // Optional: false
    pLayerName: ?[*:0]const u8 = null,
    // Length member: null-terminated
    // Extern sync: false
    // Optional: false
    pSettingName: ?[*:0]const u8 = null,
    // Extern sync: false
    // Optional: false
    // Comment: The type of the object
    type: VkLayerSettingTypeEXT,
    // Extern sync: false
    // Optional: true
    // Comment: Number of values of the setting
    valueCount: u32 = 0,
    // Length member: valueCount
    // Extern sync: false
    // Optional: false
    // Comment: Values to pass for a setting
    pValues: ?[*]const anyopaque = null,
};
// Extension: VK_EXT_application_parameters
// Extends: VkApplicationInfo,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: true
pub const VkApplicationParametersEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_APPLICATION_PARAMETERS_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    vendorID: u32 = 0,
    // Extern sync: false
    // Optional: true
    deviceID: u32 = 0,
    // Extern sync: false
    // Optional: false
    key: u32 = 0,
    // Extern sync: false
    // Optional: false
    value: u64 = 0,
};
// Extension: VK_AMD_rasterization_order
// Extends: VkPipelineRasterizationStateCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineRasterizationStateRasterizationOrderAMD = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: Rasterization order to use for the pipeline
    rasterizationOrder: VkRasterizationOrderAMD,
};
// Extension: VK_EXT_debug_marker
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDebugMarkerObjectNameInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: The type of the object
    objectType: VkDebugReportObjectTypeEXT,
    // Extern sync: true
    // Optional: false
    // Object type: objectType (Which object handle is this)
    // Comment: The handle of the object, cast to uint64_t
    object: u64 = 0,
    // Length member: null-terminated
    // Extern sync: false
    // Optional: false
    // Comment: Name to apply to the object
    pObjectName: ?[*:0]const u8 = null,
};
// Extension: VK_EXT_debug_marker
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDebugMarkerObjectTagInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: The type of the object
    objectType: VkDebugReportObjectTypeEXT,
    // Extern sync: true
    // Optional: false
    // Object type: objectType (Which object handle is this)
    // Comment: The handle of the object, cast to uint64_t
    object: u64 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: The name of the tag to set on the object
    tagName: u64 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: The length in bytes of the tag data
    tagSize: u64 = 0,
    // Length member: tagSize
    // Extern sync: false
    // Optional: false
    // Comment: Tag data to attach to the object
    pTag: ?[*]const anyopaque = null,
};
// Extension: VK_EXT_debug_marker
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDebugMarkerMarkerInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Length member: null-terminated
    // Extern sync: false
    // Optional: false
    // Comment: Name of the debug marker
    pMarkerName: ?[*:0]const u8 = null,
    // Extern sync: false
    // Optional: false
    // Comment: Optional color for debug marker
    color: [4]f32 = @import("std").mem.zeroes([4]f32),
};
// Extension: VK_NV_dedicated_allocation
// Extends: VkImageCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDedicatedAllocationImageCreateInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: Whether this image uses a dedicated allocation
    dedicatedAllocation: u32 = 0,
};
// Extension: VK_NV_dedicated_allocation
// Extends: VkBufferCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDedicatedAllocationBufferCreateInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: Whether this buffer uses a dedicated allocation
    dedicatedAllocation: u32 = 0,
};
// Extension: VK_NV_dedicated_allocation
// Extends: VkMemoryAllocateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDedicatedAllocationMemoryAllocateInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    // Comment: Image that this allocation will be bound to
    image: VkImage = .none,
    // Extern sync: false
    // Optional: true
    // Comment: Buffer that this allocation will be bound to
    buffer: VkBuffer = .none,
};
// Extension: VK_NV_external_memory_capabilities
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkExternalImageFormatPropertiesNV = extern struct {
    // Extern sync: false
    // Optional: false
    imageFormatProperties: VkImageFormatProperties = .{},
    // Extern sync: false
    // Optional: true
    externalMemoryFeatures: VkExternalMemoryFeatureFlagsNV = .{},
    // Extern sync: false
    // Optional: true
    exportFromImportedHandleTypes: VkExternalMemoryHandleTypeFlagsNV = .{},
    // Extern sync: false
    // Optional: true
    compatibleHandleTypes: VkExternalMemoryHandleTypeFlagsNV = .{},
};
// Extension: VK_NV_external_memory
// Extends: VkImageCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkExternalMemoryImageCreateInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    handleTypes: VkExternalMemoryHandleTypeFlagsNV = .{},
};
// Extension: VK_NV_external_memory
// Extends: VkMemoryAllocateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkExportMemoryAllocateInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    handleTypes: VkExternalMemoryHandleTypeFlagsNV = .{},
};
// Extension: VK_NV_external_memory_win32
// Extends: VkMemoryAllocateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImportMemoryWin32HandleInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    handleType: VkExternalMemoryHandleTypeFlagsNV = .{},
    // Extern sync: false
    // Optional: true
};
// Extension: VK_NV_external_memory_win32
// Extends: VkMemoryAllocateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkExportMemoryWin32HandleInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    pAttributes: ?*const SECURITY_ATTRIBUTES = null,
    // Extern sync: false
    // Optional: true
};
// Extension: VK_NV_external_memory_sci_buf
// Extends: VkMemoryAllocateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkExportMemorySciBufInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_EXPORT_MEMORY_SCI_BUF_INFO_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
};
// Extension: VK_NV_external_memory_sci_buf
// Extends: VkMemoryAllocateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImportMemorySciBufInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_IMPORT_MEMORY_SCI_BUF_INFO_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    handleType: VkExternalMemoryHandleTypeFlags = .{},
    // Extern sync: false
    // Optional: false
};
// Extension: VK_NV_external_memory_sci_buf
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkMemoryGetSciBufInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_MEMORY_GET_SCI_BUF_INFO_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    memory: VkDeviceMemory = .none,
    // Extern sync: false
    // Optional: false
    handleType: VkExternalMemoryHandleTypeFlags = .{},
};
// Extension: VK_NV_external_memory_sci_buf
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkMemorySciBufPropertiesNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_MEMORY_SCI_BUF_PROPERTIES_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    memoryTypeBits: u32 = 0,
};
// Extension: VK_NV_external_memory_sci_buf
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceExternalMemorySciBufFeaturesNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_SCI_BUF_FEATURES_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    sciBufImport: u32 = 0,
    // Extern sync: false
    // Optional: false
    sciBufExport: u32 = 0,
};
// Extension: VK_NV_external_memory_sci_buf
pub const VkPhysicalDeviceExternalSciBufFeaturesNV = VkPhysicalDeviceExternalMemorySciBufFeaturesNV;
// Extension: VK_NV_win32_keyed_mutex
// Extends: VkSubmitInfo,VkSubmitInfo2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkWin32KeyedMutexAcquireReleaseInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    acquireCount: u32 = 0,
    // Length member: acquireCount
    // Extern sync: false
    // Optional: false
    pAcquireSyncs: ?[*]const VkDeviceMemory = null,
    // Length member: acquireCount
    // Extern sync: false
    // Optional: false
    pAcquireKeys: ?[*]const u64 = null,
    // Length member: acquireCount
    // Extern sync: false
    // Optional: false
    pAcquireTimeoutMilliseconds: ?[*]const u32 = null,
    // Extern sync: false
    // Optional: true
    releaseCount: u32 = 0,
    // Length member: releaseCount
    // Extern sync: false
    // Optional: false
    pReleaseSyncs: ?[*]const VkDeviceMemory = null,
    // Length member: releaseCount
    // Extern sync: false
    // Optional: false
    pReleaseKeys: ?[*]const u64 = null,
};
// Extension: VK_NV_device_generated_commands
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Feature link: deviceGeneratedCommandsNV
    deviceGeneratedCommands: u32 = 0,
};
// Extension: VK_NV_device_generated_commands_compute
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_COMPUTE_FEATURES_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    deviceGeneratedCompute: u32 = 0,
    // Extern sync: false
    // Optional: false
    deviceGeneratedComputePipelines: u32 = 0,
    // Extern sync: false
    // Optional: false
    deviceGeneratedComputeCaptureReplay: u32 = 0,
};
// Extension: VK_BASE_VERSION_1_3
// Extends: VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: true
pub const VkDevicePrivateDataCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    privateDataSlotRequestCount: u32 = 0,
};
// Extension: VK_EXT_private_data
pub const VkDevicePrivateDataCreateInfoEXT = VkDevicePrivateDataCreateInfo;
// Extension: VK_BASE_VERSION_1_3
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPrivateDataSlotCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    flags: VkPrivateDataSlotCreateFlags = .{},
};
// Extension: VK_EXT_private_data
pub const VkPrivateDataSlotCreateInfoEXT = VkPrivateDataSlotCreateInfo;
// Extension: VK_BASE_VERSION_1_3
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDevicePrivateDataFeatures = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    privateData: u32 = 0,
};
// Extension: VK_EXT_private_data
pub const VkPhysicalDevicePrivateDataFeaturesEXT = VkPhysicalDevicePrivateDataFeatures;
// Extension: VK_NV_device_generated_commands
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    maxGraphicsShaderGroupCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxIndirectSequenceCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxIndirectCommandsTokenCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxIndirectCommandsStreamCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxIndirectCommandsTokenOffset: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxIndirectCommandsStreamStride: u32 = 0,
    // Extern sync: false
    // Optional: false
    minSequencesCountBufferOffsetAlignment: u32 = 0,
    // Extern sync: false
    // Optional: false
    minSequencesIndexBufferOffsetAlignment: u32 = 0,
    // Extern sync: false
    // Optional: false
    minIndirectCommandsBufferOffsetAlignment: u32 = 0,
};
// Extension: VK_NV_cluster_acceleration_structure
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceClusterAccelerationStructureFeaturesNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_ACCELERATION_STRUCTURE_FEATURES_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    clusterAccelerationStructure: u32 = 0,
};
// Extension: VK_NV_cluster_acceleration_structure
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceClusterAccelerationStructurePropertiesNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_ACCELERATION_STRUCTURE_PROPERTIES_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    maxVerticesPerCluster: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxTrianglesPerCluster: u32 = 0,
    // Extern sync: false
    // Optional: false
    clusterScratchByteAlignment: u32 = 0,
    // Extern sync: false
    // Optional: false
    clusterByteAlignment: u32 = 0,
    // Extern sync: false
    // Optional: false
    clusterTemplateByteAlignment: u32 = 0,
    // Extern sync: false
    // Optional: false
    clusterBottomLevelByteAlignment: u32 = 0,
    // Extern sync: false
    // Optional: false
    clusterTemplateBoundsByteAlignment: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxClusterGeometryIndex: u32 = 0,
};
// Extension: VK_NV_cluster_acceleration_structure
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkStridedDeviceAddressNV = extern struct {
    // Extern sync: false
    // Optional: false
    startAddress: u64 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Specified in bytes
    strideInBytes: u64 = 0,
};
// Extension: VK_NV_cluster_acceleration_structure
// Extends: VkRayTracingPipelineCreateInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkRayTracingPipelineClusterAccelerationStructureCreateInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CLUSTER_ACCELERATION_STRUCTURE_CREATE_INFO_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    allowClusterAccelerationStructure: u32 = 0,
};
// Extension: VK_NV_cluster_acceleration_structure
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV = extern struct {
};
// Extension: VK_NV_cluster_acceleration_structure
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkClusterAccelerationStructureMoveObjectsInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    srcAccelerationStructure: u64 = 0,
};
// Extension: VK_NV_cluster_acceleration_structure
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkClusterAccelerationStructureBuildClustersBottomLevelInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    clusterReferencesCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    clusterReferencesStride: u32 = 0,
    // Extern sync: false
    // Optional: false
    clusterReferences: u64 = 0,
};
// Extension: VK_NV_cluster_acceleration_structure
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkClusterAccelerationStructureGetTemplateIndicesInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    clusterTemplateAddress: u64 = 0,
};
// Extension: VK_NV_cluster_acceleration_structure
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkClusterAccelerationStructureBuildTriangleClusterInfoNV = extern struct {
};
// Extension: VK_NV_cluster_acceleration_structure
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkClusterAccelerationStructureBuildTriangleClusterTemplateInfoNV = extern struct {
};
// Extension: VK_NV_cluster_acceleration_structure
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkClusterAccelerationStructureInstantiateClusterInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    clusterIdOffset: u32 = 0,
    // Bitfield start
    bitfield0: packed struct(u32) {
    // Extern sync: false
    // Optional: false
        geometryIndexOffset: u24 = 0,
    // Extern sync: false
    // Optional: false
        reserved: u8 = 0,
    // Bitfield end
    },
    // Extern sync: false
    // Optional: false
    clusterTemplateAddress: u64 = 0,
    // Extern sync: false
    // Optional: false
    vertexBuffer: VkStridedDeviceAddressNV = .{},
};
// Extension: VK_NV_cluster_acceleration_structure
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkClusterAccelerationStructureClustersBottomLevelInputNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_CLUSTERS_BOTTOM_LEVEL_INPUT_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    maxTotalClusterCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxClusterCountPerAccelerationStructure: u32 = 0,
};
// Extension: VK_NV_cluster_acceleration_structure
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkClusterAccelerationStructureTriangleClusterInputNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_TRIANGLE_CLUSTER_INPUT_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    vertexFormat: VkFormat,
    // Extern sync: false
    // Optional: false
    maxGeometryIndexValue: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxClusterUniqueGeometryCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxClusterTriangleCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxClusterVertexCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxTotalTriangleCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxTotalVertexCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    minPositionTruncateBitCount: u32 = 0,
};
// Extension: VK_NV_cluster_acceleration_structure
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkClusterAccelerationStructureMoveObjectsInputNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_MOVE_OBJECTS_INPUT_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    type: VkClusterAccelerationStructureTypeNV,
    // Extern sync: false
    // Optional: false
    noMoveOverlap: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxMovedBytes: u64 = 0,
};
// Extension: VK_NV_cluster_acceleration_structure
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkClusterAccelerationStructureInputInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_INPUT_INFO_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    maxAccelerationStructureCount: u32 = 0,
    // Extern sync: false
    // Optional: true
    flags: VkBuildAccelerationStructureFlagsKHR = .{},
    // Extern sync: false
    // Optional: false
    opType: VkClusterAccelerationStructureOpTypeNV,
    // Extern sync: false
    // Optional: false
    opMode: VkClusterAccelerationStructureOpModeNV,
    // Extern sync: false
    // Optional: false
    // Selector member: opType (What union field is valid)
    opInput: VkClusterAccelerationStructureOpInputNV,
};
// Extension: VK_NV_cluster_acceleration_structure
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkClusterAccelerationStructureCommandsInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_COMMANDS_INFO_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    input: VkClusterAccelerationStructureInputInfoNV = .{},
    // Extern sync: false
    // Optional: true
    dstImplicitData: u64 = 0,
    // Extern sync: false
    // Optional: false
    scratchData: u64 = 0,
    // Extern sync: false
    // Optional: false
    dstAddressesArray: VkStridedDeviceAddressRegionKHR = .{},
    // Extern sync: false
    // Optional: false
    dstSizesArray: VkStridedDeviceAddressRegionKHR = .{},
    // Extern sync: false
    // Optional: false
    srcInfosArray: VkStridedDeviceAddressRegionKHR = .{},
    // Extern sync: false
    // Optional: true
    srcInfosCount: u64 = 0,
    // Extern sync: false
    // Optional: true
    addressResolutionFlags: VkClusterAccelerationStructureAddressResolutionFlagsNV = .{},
};
// Extension: VK_EXT_multi_draw
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceMultiDrawPropertiesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    maxMultiDrawCount: u32 = 0,
};
// Extension: VK_NV_device_generated_commands
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkGraphicsShaderGroupCreateInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_GRAPHICS_SHADER_GROUP_CREATE_INFO_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    stageCount: u32 = 0,
    // Length member: stageCount
    // Extern sync: false
    // Optional: false
    pStages: ?[*]const VkPipelineShaderStageCreateInfo = null,
    // Extern sync: false
    // Optional: true
    pVertexInputState: ?*const VkPipelineVertexInputStateCreateInfo = null,
    // Extern sync: false
    // Optional: true
    pTessellationState: ?*const VkPipelineTessellationStateCreateInfo = null,
};
// Extension: VK_NV_device_generated_commands
// Extends: VkGraphicsPipelineCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkGraphicsPipelineShaderGroupsCreateInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    groupCount: u32 = 0,
    // Length member: groupCount
    // Extern sync: false
    // Optional: false
    pGroups: ?[*]const VkGraphicsShaderGroupCreateInfoNV = null,
    // Extern sync: false
    // Optional: true
    pipelineCount: u32 = 0,
    // Length member: pipelineCount
    // Extern sync: false
    // Optional: false
    pPipelines: ?[*]const VkPipeline = null,
};
// Extension: VK_NV_device_generated_commands
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkBindShaderGroupIndirectCommandNV = extern struct {
    // Extern sync: false
    // Optional: false
    groupIndex: u32 = 0,
};
// Extension: VK_NV_device_generated_commands
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkBindIndexBufferIndirectCommandNV = extern struct {
    // Extern sync: false
    // Optional: false
    bufferAddress: u64 = 0,
    // Extern sync: false
    // Optional: false
    size: u32 = 0,
    // Extern sync: false
    // Optional: false
    indexType: VkIndexType,
};
// Extension: VK_NV_device_generated_commands
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkBindVertexBufferIndirectCommandNV = extern struct {
    // Extern sync: false
    // Optional: false
    bufferAddress: u64 = 0,
    // Extern sync: false
    // Optional: false
    size: u32 = 0,
    // Extern sync: false
    // Optional: false
    stride: u32 = 0,
};
// Extension: VK_NV_device_generated_commands
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSetStateFlagsIndirectCommandNV = extern struct {
    // Extern sync: false
    // Optional: false
    data: u32 = 0,
};
// Extension: VK_NV_device_generated_commands
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkIndirectCommandsStreamNV = extern struct {
    // Extern sync: false
    // Optional: false
    buffer: VkBuffer = .none,
    // Extern sync: false
    // Optional: false
    offset: u64 = 0,
};
// Extension: VK_NV_device_generated_commands
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkIndirectCommandsLayoutTokenNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    tokenType: VkIndirectCommandsTokenTypeNV,
    // Extern sync: false
    // Optional: false
    stream: u32 = 0,
    // Extern sync: false
    // Optional: false
    offset: u32 = 0,
    // Extern sync: false
    // Optional: false
    vertexBindingUnit: u32 = 0,
    // Extern sync: false
    // Optional: false
    vertexDynamicStride: u32 = 0,
    // Extern sync: false
    // Optional: true
    pushconstantPipelineLayout: VkPipelineLayout = .none,
    // Extern sync: false
    // Optional: true
    pushconstantShaderStageFlags: VkShaderStageFlags = .{},
    // Extern sync: false
    // Optional: false
    pushconstantOffset: u32 = 0,
    // Extern sync: false
    // Optional: false
    pushconstantSize: u32 = 0,
    // Extern sync: false
    // Optional: true
    indirectStateFlags: VkIndirectStateFlagsNV = .{},
    // Extern sync: false
    // Optional: true
    indexTypeCount: u32 = 0,
    // Length member: indexTypeCount
    // Extern sync: false
    // Optional: false
    pIndexTypes: ?[*]const VkIndexType = null,
    // Length member: indexTypeCount
    // Extern sync: false
    // Optional: false
    pIndexTypeValues: ?[*]const u32 = null,
};
// Extension: VK_NV_device_generated_commands
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkIndirectCommandsLayoutCreateInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkIndirectCommandsLayoutUsageFlagsNV = .{},
    // Extern sync: false
    // Optional: false
    pipelineBindPoint: VkPipelineBindPoint,
    // Extern sync: false
    // Optional: false
    tokenCount: u32 = 0,
    // Length member: tokenCount
    // Extern sync: false
    // Optional: false
    pTokens: ?[*]const VkIndirectCommandsLayoutTokenNV = null,
    // Extern sync: false
    // Optional: false
    streamCount: u32 = 0,
    // Length member: streamCount
    // Extern sync: false
    // Optional: false
    pStreamStrides: ?[*]const u32 = null,
};
// Extension: VK_NV_device_generated_commands
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkGeneratedCommandsInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    pipelineBindPoint: VkPipelineBindPoint,
    // Extern sync: false
    // Optional: true
    pipeline: VkPipeline = .none,
    // Extern sync: false
    // Optional: false
    indirectCommandsLayout: VkIndirectCommandsLayoutNV = .none,
    // Extern sync: false
    // Optional: false
    streamCount: u32 = 0,
    // Length member: streamCount
    // Extern sync: false
    // Optional: false
    pStreams: ?[*]const VkIndirectCommandsStreamNV = null,
    // Extern sync: false
    // Optional: false
    sequencesCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    preprocessBuffer: VkBuffer = .none,
    // Extern sync: false
    // Optional: false
    preprocessOffset: u64 = 0,
    // Extern sync: false
    // Optional: false
    preprocessSize: u64 = 0,
    // Extern sync: false
    // Optional: true
    sequencesCountBuffer: VkBuffer = .none,
    // Extern sync: false
    // Optional: false
    sequencesCountOffset: u64 = 0,
    // Extern sync: false
    // Optional: true
    sequencesIndexBuffer: VkBuffer = .none,
    // Extern sync: false
    // Optional: false
    sequencesIndexOffset: u64 = 0,
};
// Extension: VK_NV_device_generated_commands
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkGeneratedCommandsMemoryRequirementsInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    pipelineBindPoint: VkPipelineBindPoint,
    // Extern sync: false
    // Optional: true
    pipeline: VkPipeline = .none,
    // Extern sync: false
    // Optional: false
    indirectCommandsLayout: VkIndirectCommandsLayoutNV = .none,
    // Extern sync: false
    // Optional: false
    maxSequencesCount: u32 = 0,
};
// Extension: VK_NV_device_generated_commands_compute
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineIndirectDeviceAddressInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_INDIRECT_DEVICE_ADDRESS_INFO_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    pipelineBindPoint: VkPipelineBindPoint,
    // Extern sync: false
    // Optional: false
    pipeline: VkPipeline = .none,
};
// Extension: VK_NV_device_generated_commands_compute
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkBindPipelineIndirectCommandNV = extern struct {
    // Extern sync: false
    // Optional: false
    pipelineAddress: u64 = 0,
};
// Extension: VK_BASE_VERSION_1_1
// Extends: VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceFeatures2 = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    features: VkPhysicalDeviceFeatures = .{},
};
// Extension: VK_KHR_get_physical_device_properties2
pub const VkPhysicalDeviceFeatures2KHR = VkPhysicalDeviceFeatures2;
// Extension: VK_BASE_VERSION_1_1
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceProperties2 = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    properties: VkPhysicalDeviceProperties = .{},
};
// Extension: VK_KHR_get_physical_device_properties2
pub const VkPhysicalDeviceProperties2KHR = VkPhysicalDeviceProperties2;
// Extension: VK_BASE_VERSION_1_1
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkFormatProperties2 = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    formatProperties: VkFormatProperties = .{},
};
// Extension: VK_KHR_get_physical_device_properties2
pub const VkFormatProperties2KHR = VkFormatProperties2;
// Extension: VK_BASE_VERSION_1_1
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkImageFormatProperties2 = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    imageFormatProperties: VkImageFormatProperties = .{},
};
// Extension: VK_KHR_get_physical_device_properties2
pub const VkImageFormatProperties2KHR = VkImageFormatProperties2;
// Extension: VK_BASE_VERSION_1_1
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceImageFormatInfo2 = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    format: VkFormat,
    // Extern sync: false
    // Optional: false
    type: VkImageType,
    // Extern sync: false
    // Optional: false
    tiling: VkImageTiling,
    // Extern sync: false
    // Optional: false
    usage: VkImageUsageFlags = .{},
    // Extern sync: false
    // Optional: true
    flags: VkImageCreateFlags = .{},
};
// Extension: VK_KHR_get_physical_device_properties2
pub const VkPhysicalDeviceImageFormatInfo2KHR = VkPhysicalDeviceImageFormatInfo2;
// Extension: VK_BASE_VERSION_1_1
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkQueueFamilyProperties2 = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    queueFamilyProperties: VkQueueFamilyProperties = .{},
};
// Extension: VK_KHR_get_physical_device_properties2
pub const VkQueueFamilyProperties2KHR = VkQueueFamilyProperties2;
// Extension: VK_BASE_VERSION_1_1
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceMemoryProperties2 = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    memoryProperties: VkPhysicalDeviceMemoryProperties = .{},
};
// Extension: VK_KHR_get_physical_device_properties2
pub const VkPhysicalDeviceMemoryProperties2KHR = VkPhysicalDeviceMemoryProperties2;
// Extension: VK_BASE_VERSION_1_1
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkSparseImageFormatProperties2 = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    properties: VkSparseImageFormatProperties = .{},
};
// Extension: VK_KHR_get_physical_device_properties2
pub const VkSparseImageFormatProperties2KHR = VkSparseImageFormatProperties2;
// Extension: VK_BASE_VERSION_1_1
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceSparseImageFormatInfo2 = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    format: VkFormat,
    // Extern sync: false
    // Optional: false
    type: VkImageType,
    // Extern sync: false
    // Optional: false
    samples: VkSampleCountFlags = .{},
    // Extern sync: false
    // Optional: false
    usage: VkImageUsageFlags = .{},
    // Extern sync: false
    // Optional: false
    tiling: VkImageTiling,
};
// Extension: VK_KHR_get_physical_device_properties2
pub const VkPhysicalDeviceSparseImageFormatInfo2KHR = VkPhysicalDeviceSparseImageFormatInfo2;
// Extension: VK_COMPUTE_VERSION_1_4
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDevicePushDescriptorProperties = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    maxPushDescriptors: u32 = 0,
};
// Extension: VK_KHR_push_descriptor
pub const VkPhysicalDevicePushDescriptorPropertiesKHR = VkPhysicalDevicePushDescriptorProperties;
// Extension: VK_BASE_VERSION_1_2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkConformanceVersion = extern struct {
    // Extern sync: false
    // Optional: false
    major: u8 = 0,
    // Extern sync: false
    // Optional: false
    minor: u8 = 0,
    // Extern sync: false
    // Optional: false
    subminor: u8 = 0,
    // Extern sync: false
    // Optional: false
    patch: u8 = 0,
};
// Extension: VK_KHR_driver_properties
pub const VkConformanceVersionKHR = VkConformanceVersion;
// Extension: VK_BASE_VERSION_1_2
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceDriverProperties = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    driverID: VkDriverId,
    // Length member: null-terminated
    // Extern sync: false
    // Optional: false
    driverName: [VK_MAX_DRIVER_NAME_SIZE]u8 = @import("std").mem.zeroes([VK_MAX_DRIVER_NAME_SIZE]u8),
    // Length member: null-terminated
    // Extern sync: false
    // Optional: false
    driverInfo: [VK_MAX_DRIVER_INFO_SIZE]u8 = @import("std").mem.zeroes([VK_MAX_DRIVER_INFO_SIZE]u8),
    // Extern sync: false
    // Optional: false
    conformanceVersion: VkConformanceVersion = .{},
};
// Extension: VK_KHR_driver_properties
pub const VkPhysicalDeviceDriverPropertiesKHR = VkPhysicalDeviceDriverProperties;
// Extension: VK_KHR_incremental_present
// Extends: VkPresentInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPresentRegionsKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: Copy of VkPresentInfoKHR::swapchainCount
    swapchainCount: u32 = 0,
    // Length member: swapchainCount
    // Extern sync: false
    // Optional: true
    // Comment: The regions that have changed
    pRegions: ?[*]const VkPresentRegionKHR = null,
};
// Extension: VK_KHR_incremental_present
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPresentRegionKHR = extern struct {
    // Extern sync: false
    // Optional: true
    // Comment: Number of rectangles in pRectangles
    rectangleCount: u32 = 0,
    // Length member: rectangleCount
    // Extern sync: false
    // Optional: true
    // Comment: Array of rectangles that have changed in a swapchain's image(s)
    pRectangles: ?[*]const VkRectLayerKHR = null,
};
// Extension: VK_KHR_incremental_present
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkRectLayerKHR = extern struct {
    // Extern sync: false
    // Optional: false
    // Comment: upper-left corner of a rectangle that has not changed, in pixels of a presentation images
    offset: VkOffset2D = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Dimensions of a rectangle that has not changed, in pixels of a presentation images
    extent: VkExtent2D = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Layer of a swapchain's image(s), for stereoscopic-3D images
    layer: u32 = 0,
};
// Extension: VK_COMPUTE_VERSION_1_1
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceVariablePointersFeatures = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    variablePointersStorageBuffer: u32 = 0,
    // Extern sync: false
    // Optional: false
    variablePointers: u32 = 0,
};
// Extension: VK_KHR_variable_pointers
pub const VkPhysicalDeviceVariablePointersFeaturesKHR = VkPhysicalDeviceVariablePointersFeatures;
// Extension: VK_KHR_variable_pointers
pub const VkPhysicalDeviceVariablePointerFeaturesKHR = VkPhysicalDeviceVariablePointersFeatures;
// Extension: VK_COMPUTE_VERSION_1_1
pub const VkPhysicalDeviceVariablePointerFeatures = VkPhysicalDeviceVariablePointersFeatures;
// Extension: VK_BASE_VERSION_1_1
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkExternalMemoryProperties = extern struct {
    // Extern sync: false
    // Optional: false
    externalMemoryFeatures: VkExternalMemoryFeatureFlags = .{},
    // Extern sync: false
    // Optional: true
    exportFromImportedHandleTypes: VkExternalMemoryHandleTypeFlags = .{},
    // Extern sync: false
    // Optional: false
    compatibleHandleTypes: VkExternalMemoryHandleTypeFlags = .{},
};
// Extension: VK_KHR_external_memory_capabilities
pub const VkExternalMemoryPropertiesKHR = VkExternalMemoryProperties;
// Extension: VK_BASE_VERSION_1_1
// Extends: VkPhysicalDeviceImageFormatInfo2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceExternalImageFormatInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    handleType: VkExternalMemoryHandleTypeFlags = .{},
};
// Extension: VK_KHR_external_memory_capabilities
pub const VkPhysicalDeviceExternalImageFormatInfoKHR = VkPhysicalDeviceExternalImageFormatInfo;
// Extension: VK_BASE_VERSION_1_1
// Extends: VkImageFormatProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkExternalImageFormatProperties = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    externalMemoryProperties: VkExternalMemoryProperties = .{},
};
// Extension: VK_KHR_external_memory_capabilities
pub const VkExternalImageFormatPropertiesKHR = VkExternalImageFormatProperties;
// Extension: VK_BASE_VERSION_1_1
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceExternalBufferInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkBufferCreateFlags = .{},
    // Extern sync: false
    // Optional: true
    usage: VkBufferUsageFlags = .{},
    // Extern sync: false
    // Optional: false
    handleType: VkExternalMemoryHandleTypeFlags = .{},
};
// Extension: VK_KHR_external_memory_capabilities
pub const VkPhysicalDeviceExternalBufferInfoKHR = VkPhysicalDeviceExternalBufferInfo;
// Extension: VK_BASE_VERSION_1_1
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkExternalBufferProperties = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    externalMemoryProperties: VkExternalMemoryProperties = .{},
};
// Extension: VK_KHR_external_memory_capabilities
pub const VkExternalBufferPropertiesKHR = VkExternalBufferProperties;
// Extension: VK_BASE_VERSION_1_1
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceIDProperties = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    deviceUUID: [VK_UUID_SIZE]u8 = @import("std").mem.zeroes([VK_UUID_SIZE]u8),
    // Extern sync: false
    // Optional: false
    driverUUID: [VK_UUID_SIZE]u8 = @import("std").mem.zeroes([VK_UUID_SIZE]u8),
    // Extern sync: false
    // Optional: false
    deviceLUID: [VK_LUID_SIZE]u8 = @import("std").mem.zeroes([VK_LUID_SIZE]u8),
    // Extern sync: false
    // Optional: false
    deviceNodeMask: u32 = 0,
    // Extern sync: false
    // Optional: false
    deviceLUIDValid: u32 = 0,
};
// Extension: VK_KHR_external_memory_capabilities
// Extension: VK_KHR_external_semaphore_capabilities
// Extension: VK_KHR_external_fence_capabilities
pub const VkPhysicalDeviceIDPropertiesKHR = VkPhysicalDeviceIDProperties;
// Extension: VK_BASE_VERSION_1_1
// Extends: VkImageCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkExternalMemoryImageCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    handleTypes: VkExternalMemoryHandleTypeFlags = .{},
};
// Extension: VK_KHR_external_memory
pub const VkExternalMemoryImageCreateInfoKHR = VkExternalMemoryImageCreateInfo;
// Extension: VK_BASE_VERSION_1_1
// Extends: VkBufferCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkExternalMemoryBufferCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    handleTypes: VkExternalMemoryHandleTypeFlags = .{},
};
// Extension: VK_KHR_external_memory
pub const VkExternalMemoryBufferCreateInfoKHR = VkExternalMemoryBufferCreateInfo;
// Extension: VK_BASE_VERSION_1_1
// Extends: VkMemoryAllocateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkExportMemoryAllocateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    handleTypes: VkExternalMemoryHandleTypeFlags = .{},
};
// Extension: VK_KHR_external_memory
pub const VkExportMemoryAllocateInfoKHR = VkExportMemoryAllocateInfo;
// Extension: VK_KHR_external_memory_win32
// Extends: VkMemoryAllocateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImportMemoryWin32HandleInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    handleType: VkExternalMemoryHandleTypeFlags = .{},
    // Extern sync: false
    // Optional: true
    // Extern sync: false
    // Optional: true
};
// Extension: VK_KHR_external_memory_win32
// Extends: VkMemoryAllocateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkExportMemoryWin32HandleInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    pAttributes: ?*const SECURITY_ATTRIBUTES = null,
    // Extern sync: false
    // Optional: false
    // Extern sync: false
    // Optional: false
};
// Extension: VK_FUCHSIA_external_memory
// Extends: VkMemoryAllocateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImportMemoryZirconHandleInfoFUCHSIA = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_IMPORT_MEMORY_ZIRCON_HANDLE_INFO_FUCHSIA,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    handleType: VkExternalMemoryHandleTypeFlags = .{},
    // Extern sync: false
    // Optional: true
};
// Extension: VK_FUCHSIA_external_memory
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkMemoryZirconHandlePropertiesFUCHSIA = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_MEMORY_ZIRCON_HANDLE_PROPERTIES_FUCHSIA,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    memoryTypeBits: u32 = 0,
};
// Extension: VK_FUCHSIA_external_memory
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkMemoryGetZirconHandleInfoFUCHSIA = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_MEMORY_GET_ZIRCON_HANDLE_INFO_FUCHSIA,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    memory: VkDeviceMemory = .none,
    // Extern sync: false
    // Optional: false
    handleType: VkExternalMemoryHandleTypeFlags = .{},
};
// Extension: VK_KHR_external_memory_win32
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkMemoryWin32HandlePropertiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    memoryTypeBits: u32 = 0,
};
// Extension: VK_KHR_external_memory_win32
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkMemoryGetWin32HandleInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    memory: VkDeviceMemory = .none,
    // Extern sync: false
    // Optional: false
    handleType: VkExternalMemoryHandleTypeFlags = .{},
};
// Extension: VK_KHR_external_memory_fd
// Extends: VkMemoryAllocateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImportMemoryFdInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    handleType: VkExternalMemoryHandleTypeFlags = .{},
    // Extern sync: false
    // Optional: false
};
// Extension: VK_KHR_external_memory_fd
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkMemoryFdPropertiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    memoryTypeBits: u32 = 0,
};
// Extension: VK_KHR_external_memory_fd
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkMemoryGetFdInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    memory: VkDeviceMemory = .none,
    // Extern sync: false
    // Optional: false
    handleType: VkExternalMemoryHandleTypeFlags = .{},
};
// Extension: VK_KHR_win32_keyed_mutex
// Extends: VkSubmitInfo,VkSubmitInfo2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkWin32KeyedMutexAcquireReleaseInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    acquireCount: u32 = 0,
    // Length member: acquireCount
    // Extern sync: false
    // Optional: false
    pAcquireSyncs: ?[*]const VkDeviceMemory = null,
    // Length member: acquireCount
    // Extern sync: false
    // Optional: false
    pAcquireKeys: ?[*]const u64 = null,
    // Length member: acquireCount
    // Extern sync: false
    // Optional: false
    pAcquireTimeouts: ?[*]const u32 = null,
    // Extern sync: false
    // Optional: true
    releaseCount: u32 = 0,
    // Length member: releaseCount
    // Extern sync: false
    // Optional: false
    pReleaseSyncs: ?[*]const VkDeviceMemory = null,
    // Length member: releaseCount
    // Extern sync: false
    // Optional: false
    pReleaseKeys: ?[*]const u64 = null,
};
// Extension: VK_EXT_external_memory_metal
// Extends: VkMemoryAllocateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImportMemoryMetalHandleInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_IMPORT_MEMORY_METAL_HANDLE_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    handleType: VkExternalMemoryHandleTypeFlags = .{},
    // Extern sync: false
    // Optional: true
    handle: ?*anyopaque = null,
};
// Extension: VK_EXT_external_memory_metal
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkMemoryMetalHandlePropertiesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_MEMORY_METAL_HANDLE_PROPERTIES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    memoryTypeBits: u32 = 0,
};
// Extension: VK_EXT_external_memory_metal
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkMemoryGetMetalHandleInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_MEMORY_GET_METAL_HANDLE_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    memory: VkDeviceMemory = .none,
    // Extern sync: false
    // Optional: false
    handleType: VkExternalMemoryHandleTypeFlags = .{},
};
// Extension: VK_BASE_VERSION_1_1
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceExternalSemaphoreInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    handleType: VkExternalSemaphoreHandleTypeFlags = .{},
};
// Extension: VK_KHR_external_semaphore_capabilities
pub const VkPhysicalDeviceExternalSemaphoreInfoKHR = VkPhysicalDeviceExternalSemaphoreInfo;
// Extension: VK_BASE_VERSION_1_1
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkExternalSemaphoreProperties = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    exportFromImportedHandleTypes: VkExternalSemaphoreHandleTypeFlags = .{},
    // Extern sync: false
    // Optional: false
    compatibleHandleTypes: VkExternalSemaphoreHandleTypeFlags = .{},
    // Extern sync: false
    // Optional: true
    externalSemaphoreFeatures: VkExternalSemaphoreFeatureFlags = .{},
};
// Extension: VK_KHR_external_semaphore_capabilities
pub const VkExternalSemaphorePropertiesKHR = VkExternalSemaphoreProperties;
// Extension: VK_BASE_VERSION_1_1
// Extends: VkSemaphoreCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkExportSemaphoreCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    handleTypes: VkExternalSemaphoreHandleTypeFlags = .{},
};
// Extension: VK_KHR_external_semaphore
pub const VkExportSemaphoreCreateInfoKHR = VkExportSemaphoreCreateInfo;
// Extension: VK_KHR_external_semaphore_win32
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImportSemaphoreWin32HandleInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: true
    // Optional: false
    semaphore: VkSemaphore = .none,
    // Extern sync: false
    // Optional: true
    flags: VkSemaphoreImportFlags = .{},
    // Extern sync: false
    // Optional: false
    handleType: VkExternalSemaphoreHandleTypeFlags = .{},
    // Extern sync: false
    // Optional: true
    // Extern sync: false
    // Optional: true
};
// Extension: VK_KHR_external_semaphore_win32
// Extends: VkSemaphoreCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkExportSemaphoreWin32HandleInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    pAttributes: ?*const SECURITY_ATTRIBUTES = null,
    // Extern sync: false
    // Optional: false
    // Extern sync: false
    // Optional: false
};
// Extension: VK_KHR_external_semaphore_win32
// Extends: VkSubmitInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkD3D12FenceSubmitInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    waitSemaphoreValuesCount: u32 = 0,
    // Length member: waitSemaphoreValuesCount
    // Extern sync: false
    // Optional: true
    pWaitSemaphoreValues: ?[*]const u64 = null,
    // Extern sync: false
    // Optional: true
    signalSemaphoreValuesCount: u32 = 0,
    // Length member: signalSemaphoreValuesCount
    // Extern sync: false
    // Optional: true
    pSignalSemaphoreValues: ?[*]const u64 = null,
};
// Extension: VK_KHR_external_semaphore_win32
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSemaphoreGetWin32HandleInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    semaphore: VkSemaphore = .none,
    // Extern sync: false
    // Optional: false
    handleType: VkExternalSemaphoreHandleTypeFlags = .{},
};
// Extension: VK_KHR_external_semaphore_fd
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImportSemaphoreFdInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: true
    // Optional: false
    semaphore: VkSemaphore = .none,
    // Extern sync: false
    // Optional: true
    flags: VkSemaphoreImportFlags = .{},
    // Extern sync: false
    // Optional: false
    handleType: VkExternalSemaphoreHandleTypeFlags = .{},
    // Extern sync: false
    // Optional: false
};
// Extension: VK_KHR_external_semaphore_fd
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSemaphoreGetFdInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    semaphore: VkSemaphore = .none,
    // Extern sync: false
    // Optional: false
    handleType: VkExternalSemaphoreHandleTypeFlags = .{},
};
// Extension: VK_FUCHSIA_external_semaphore
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImportSemaphoreZirconHandleInfoFUCHSIA = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_ZIRCON_HANDLE_INFO_FUCHSIA,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: true
    // Optional: false
    semaphore: VkSemaphore = .none,
    // Extern sync: false
    // Optional: true
    flags: VkSemaphoreImportFlags = .{},
    // Extern sync: false
    // Optional: false
    handleType: VkExternalSemaphoreHandleTypeFlags = .{},
    // Extern sync: false
    // Optional: false
};
// Extension: VK_FUCHSIA_external_semaphore
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSemaphoreGetZirconHandleInfoFUCHSIA = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_SEMAPHORE_GET_ZIRCON_HANDLE_INFO_FUCHSIA,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    semaphore: VkSemaphore = .none,
    // Extern sync: false
    // Optional: false
    handleType: VkExternalSemaphoreHandleTypeFlags = .{},
};
// Extension: VK_BASE_VERSION_1_1
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceExternalFenceInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    handleType: VkExternalFenceHandleTypeFlags = .{},
};
// Extension: VK_KHR_external_fence_capabilities
pub const VkPhysicalDeviceExternalFenceInfoKHR = VkPhysicalDeviceExternalFenceInfo;
// Extension: VK_BASE_VERSION_1_1
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkExternalFenceProperties = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    exportFromImportedHandleTypes: VkExternalFenceHandleTypeFlags = .{},
    // Extern sync: false
    // Optional: false
    compatibleHandleTypes: VkExternalFenceHandleTypeFlags = .{},
    // Extern sync: false
    // Optional: true
    externalFenceFeatures: VkExternalFenceFeatureFlags = .{},
};
// Extension: VK_KHR_external_fence_capabilities
pub const VkExternalFencePropertiesKHR = VkExternalFenceProperties;
// Extension: VK_BASE_VERSION_1_1
// Extends: VkFenceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkExportFenceCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    handleTypes: VkExternalFenceHandleTypeFlags = .{},
};
// Extension: VK_KHR_external_fence
pub const VkExportFenceCreateInfoKHR = VkExportFenceCreateInfo;
// Extension: VK_KHR_external_fence_win32
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImportFenceWin32HandleInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: true
    // Optional: false
    fence: VkFence = .none,
    // Extern sync: false
    // Optional: true
    flags: VkFenceImportFlags = .{},
    // Extern sync: false
    // Optional: false
    handleType: VkExternalFenceHandleTypeFlags = .{},
    // Extern sync: false
    // Optional: true
    // Extern sync: false
    // Optional: true
};
// Extension: VK_KHR_external_fence_win32
// Extends: VkFenceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkExportFenceWin32HandleInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    pAttributes: ?*const SECURITY_ATTRIBUTES = null,
    // Extern sync: false
    // Optional: false
    // Extern sync: false
    // Optional: false
};
// Extension: VK_KHR_external_fence_win32
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkFenceGetWin32HandleInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    fence: VkFence = .none,
    // Extern sync: false
    // Optional: false
    handleType: VkExternalFenceHandleTypeFlags = .{},
};
// Extension: VK_KHR_external_fence_fd
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImportFenceFdInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: true
    // Optional: false
    fence: VkFence = .none,
    // Extern sync: false
    // Optional: true
    flags: VkFenceImportFlags = .{},
    // Extern sync: false
    // Optional: false
    handleType: VkExternalFenceHandleTypeFlags = .{},
    // Extern sync: false
    // Optional: false
};
// Extension: VK_KHR_external_fence_fd
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkFenceGetFdInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    fence: VkFence = .none,
    // Extern sync: false
    // Optional: false
    handleType: VkExternalFenceHandleTypeFlags = .{},
};
// Extension: VK_NV_external_sci_sync
// Extension: VK_NV_external_sci_sync2
// Extends: VkFenceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkExportFenceSciSyncInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_EXPORT_FENCE_SCI_SYNC_INFO_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
};
// Extension: VK_NV_external_sci_sync
// Extension: VK_NV_external_sci_sync2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImportFenceSciSyncInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_IMPORT_FENCE_SCI_SYNC_INFO_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: true
    // Optional: false
    fence: VkFence = .none,
    // Extern sync: false
    // Optional: false
    handleType: VkExternalFenceHandleTypeFlags = .{},
    // Extern sync: false
    // Optional: false
    handle: ?*anyopaque = null,
};
// Extension: VK_NV_external_sci_sync
// Extension: VK_NV_external_sci_sync2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkFenceGetSciSyncInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_FENCE_GET_SCI_SYNC_INFO_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    fence: VkFence = .none,
    // Extern sync: false
    // Optional: false
    handleType: VkExternalFenceHandleTypeFlags = .{},
};
// Extension: VK_NV_external_sci_sync
// Extends: VkSemaphoreCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkExportSemaphoreSciSyncInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_SCI_SYNC_INFO_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
};
// Extension: VK_NV_external_sci_sync
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImportSemaphoreSciSyncInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_SCI_SYNC_INFO_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: true
    // Optional: false
    semaphore: VkSemaphore = .none,
    // Extern sync: false
    // Optional: false
    handleType: VkExternalSemaphoreHandleTypeFlags = .{},
    // Extern sync: false
    // Optional: false
    handle: ?*anyopaque = null,
};
// Extension: VK_NV_external_sci_sync
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSemaphoreGetSciSyncInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_SEMAPHORE_GET_SCI_SYNC_INFO_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    semaphore: VkSemaphore = .none,
    // Extern sync: false
    // Optional: false
    handleType: VkExternalSemaphoreHandleTypeFlags = .{},
};
// Extension: VK_NV_external_sci_sync
// Extension: VK_NV_external_sci_sync2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSciSyncAttributesInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_SCI_SYNC_ATTRIBUTES_INFO_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    clientType: VkSciSyncClientTypeNV,
    // Extern sync: false
    // Optional: false
    primitiveType: VkSciSyncPrimitiveTypeNV,
};
// Extension: VK_NV_external_sci_sync
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceExternalSciSyncFeaturesNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SCI_SYNC_FEATURES_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    sciSyncFence: u32 = 0,
    // Extern sync: false
    // Optional: false
    sciSyncSemaphore: u32 = 0,
    // Extern sync: false
    // Optional: false
    sciSyncImport: u32 = 0,
    // Extern sync: false
    // Optional: false
    sciSyncExport: u32 = 0,
};
// Extension: VK_NV_external_sci_sync2
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceExternalSciSync2FeaturesNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SCI_SYNC_2_FEATURES_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Feature link: sciSyncFence2
    sciSyncFence: u32 = 0,
    // Extern sync: false
    // Optional: false
    sciSyncSemaphore2: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Feature link: sciSyncImport2
    sciSyncImport: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Feature link: sciSyncExport2
    sciSyncExport: u32 = 0,
};
// Extension: VK_NV_external_sci_sync2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSemaphoreSciSyncPoolCreateInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_SEMAPHORE_SCI_SYNC_POOL_CREATE_INFO_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
};
// Extension: VK_NV_external_sci_sync2
// Extends: VkSemaphoreCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSemaphoreSciSyncCreateInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_SEMAPHORE_SCI_SYNC_CREATE_INFO_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    semaphorePool: VkSemaphoreSciSyncPoolNV = .none,
    // Extern sync: false
    // Optional: false
    pFence: ?*const NvSciSyncFence = null,
};
// Extension: VK_NV_external_sci_sync2
// Extends: VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: true
pub const VkDeviceSemaphoreSciSyncPoolReservationCreateInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_DEVICE_SEMAPHORE_SCI_SYNC_POOL_RESERVATION_CREATE_INFO_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    semaphoreSciSyncPoolRequestCount: u32 = 0,
};
// Extension: VK_GRAPHICS_VERSION_1_1
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceMultiviewFeatures = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: Multiple views in a render pass
    multiview: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Multiple views in a render pass w/ geometry shader
    multiviewGeometryShader: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Multiple views in a render pass w/ tessellation shader
    multiviewTessellationShader: u32 = 0,
};
// Extension: VK_KHR_multiview
pub const VkPhysicalDeviceMultiviewFeaturesKHR = VkPhysicalDeviceMultiviewFeatures;
// Extension: VK_GRAPHICS_VERSION_1_1
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceMultiviewProperties = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: max number of views in a subpass
    maxMultiviewViewCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: max instance index for a draw in a multiview subpass
    maxMultiviewInstanceIndex: u32 = 0,
};
// Extension: VK_KHR_multiview
pub const VkPhysicalDeviceMultiviewPropertiesKHR = VkPhysicalDeviceMultiviewProperties;
// Extension: VK_GRAPHICS_VERSION_1_1
// Extends: VkRenderPassCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkRenderPassMultiviewCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    subpassCount: u32 = 0,
    // Length member: subpassCount
    // Extern sync: false
    // Optional: false
    pViewMasks: ?[*]const u32 = null,
    // Extern sync: false
    // Optional: true
    dependencyCount: u32 = 0,
    // Length member: dependencyCount
    // Extern sync: false
    // Optional: false
    pViewOffsets: ?[*]const i32 = null,
    // Extern sync: false
    // Optional: true
    correlationMaskCount: u32 = 0,
    // Length member: correlationMaskCount
    // Extern sync: false
    // Optional: false
    pCorrelationMasks: ?[*]const u32 = null,
};
// Extension: VK_KHR_multiview
pub const VkRenderPassMultiviewCreateInfoKHR = VkRenderPassMultiviewCreateInfo;
// Extension: VK_EXT_display_surface_counter
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkSurfaceCapabilities2EXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: Supported minimum number of images for the surface
    minImageCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Supported maximum number of images for the surface, 0 for unlimited
    maxImageCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Current image width and height for the surface, (0, 0) if undefined
    currentExtent: VkExtent2D = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Supported minimum image width and height for the surface
    minImageExtent: VkExtent2D = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Supported maximum image width and height for the surface
    maxImageExtent: VkExtent2D = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Supported maximum number of image layers for the surface
    maxImageArrayLayers: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: 1 or more bits representing the transforms supported
    supportedTransforms: VkSurfaceTransformFlagsKHR = .{},
    // Extern sync: false
    // Optional: false
    // Comment: The surface's current transform relative to the device's natural orientation
    currentTransform: VkSurfaceTransformFlagsKHR = .{},
    // Extern sync: false
    // Optional: false
    // Comment: 1 or more bits representing the alpha compositing modes supported
    supportedCompositeAlpha: VkCompositeAlphaFlagsKHR = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Supported image usage flags for the surface
    supportedUsageFlags: VkImageUsageFlags = .{},
    // Extern sync: false
    // Optional: true
    supportedSurfaceCounters: VkSurfaceCounterFlagsEXT = .{},
};
// Extension: VK_EXT_display_control
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDisplayPowerInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    powerState: VkDisplayPowerStateEXT,
};
// Extension: VK_EXT_display_control
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDeviceEventInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    deviceEvent: VkDeviceEventTypeEXT,
};
// Extension: VK_EXT_display_control
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDisplayEventInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    displayEvent: VkDisplayEventTypeEXT,
};
// Extension: VK_EXT_display_control
// Extends: VkSwapchainCreateInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSwapchainCounterCreateInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    surfaceCounters: VkSurfaceCounterFlagsEXT = .{},
};
// Extension: VK_BASE_VERSION_1_1
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceGroupProperties = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    physicalDeviceCount: u32 = 0,
    // Length member: physicalDeviceCount
    // Extern sync: false
    // Optional: false
    physicalDevices: [VK_MAX_DEVICE_GROUP_SIZE]VkPhysicalDevice = @import("std").mem.zeroes([VK_MAX_DEVICE_GROUP_SIZE]VkPhysicalDevice),
    // Extern sync: false
    // Optional: false
    subsetAllocation: u32 = 0,
};
// Extension: VK_KHR_device_group_creation
pub const VkPhysicalDeviceGroupPropertiesKHR = VkPhysicalDeviceGroupProperties;
// Extension: VK_BASE_VERSION_1_1
// Extends: VkMemoryAllocateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkMemoryAllocateFlagsInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkMemoryAllocateFlags = .{},
    // Extern sync: false
    // Optional: false
    deviceMask: u32 = 0,
};
// Extension: VK_KHR_device_group
pub const VkMemoryAllocateFlagsInfoKHR = VkMemoryAllocateFlagsInfo;
// Extension: VK_BASE_VERSION_1_1
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkBindBufferMemoryInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: true
    // Optional: false
    buffer: VkBuffer = .none,
    // Extern sync: false
    // Optional: false
    memory: VkDeviceMemory = .none,
    // Extern sync: false
    // Optional: false
    memoryOffset: u64 = 0,
};
// Extension: VK_KHR_bind_memory2
pub const VkBindBufferMemoryInfoKHR = VkBindBufferMemoryInfo;
// Extension: VK_BASE_VERSION_1_1
// Extends: VkBindBufferMemoryInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkBindBufferMemoryDeviceGroupInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    deviceIndexCount: u32 = 0,
    // Length member: deviceIndexCount
    // Extern sync: false
    // Optional: false
    pDeviceIndices: ?[*]const u32 = null,
};
// Extension: VK_KHR_device_group
pub const VkBindBufferMemoryDeviceGroupInfoKHR = VkBindBufferMemoryDeviceGroupInfo;
// Extension: VK_BASE_VERSION_1_1
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkBindImageMemoryInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: true
    // Optional: false
    image: VkImage = .none,
    // Extern sync: false
    // Optional: false
    memory: VkDeviceMemory = .none,
    // Extern sync: false
    // Optional: false
    memoryOffset: u64 = 0,
};
// Extension: VK_KHR_bind_memory2
pub const VkBindImageMemoryInfoKHR = VkBindImageMemoryInfo;
// Extension: VK_BASE_VERSION_1_1
// Extends: VkBindImageMemoryInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkBindImageMemoryDeviceGroupInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    deviceIndexCount: u32 = 0,
    // Length member: deviceIndexCount
    // Extern sync: false
    // Optional: false
    pDeviceIndices: ?[*]const u32 = null,
    // Extern sync: false
    // Optional: true
    splitInstanceBindRegionCount: u32 = 0,
    // Length member: splitInstanceBindRegionCount
    // Extern sync: false
    // Optional: false
    pSplitInstanceBindRegions: ?[*]const VkRect2D = null,
};
// Extension: VK_KHR_device_group
pub const VkBindImageMemoryDeviceGroupInfoKHR = VkBindImageMemoryDeviceGroupInfo;
// Extension: VK_GRAPHICS_VERSION_1_1
// Extends: VkRenderPassBeginInfo,VkRenderingInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDeviceGroupRenderPassBeginInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    deviceMask: u32 = 0,
    // Extern sync: false
    // Optional: true
    deviceRenderAreaCount: u32 = 0,
    // Length member: deviceRenderAreaCount
    // Extern sync: false
    // Optional: false
    pDeviceRenderAreas: ?[*]const VkRect2D = null,
};
// Extension: VK_KHR_device_group
pub const VkDeviceGroupRenderPassBeginInfoKHR = VkDeviceGroupRenderPassBeginInfo;
// Extension: VK_BASE_VERSION_1_1
// Extends: VkCommandBufferBeginInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDeviceGroupCommandBufferBeginInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    deviceMask: u32 = 0,
};
// Extension: VK_KHR_device_group
pub const VkDeviceGroupCommandBufferBeginInfoKHR = VkDeviceGroupCommandBufferBeginInfo;
// Extension: VK_BASE_VERSION_1_1
// Extends: VkSubmitInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDeviceGroupSubmitInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    waitSemaphoreCount: u32 = 0,
    // Length member: waitSemaphoreCount
    // Extern sync: false
    // Optional: false
    pWaitSemaphoreDeviceIndices: ?[*]const u32 = null,
    // Extern sync: false
    // Optional: true
    commandBufferCount: u32 = 0,
    // Length member: commandBufferCount
    // Extern sync: false
    // Optional: false
    pCommandBufferDeviceMasks: ?[*]const u32 = null,
    // Extern sync: false
    // Optional: true
    signalSemaphoreCount: u32 = 0,
    // Length member: signalSemaphoreCount
    // Extern sync: false
    // Optional: false
    pSignalSemaphoreDeviceIndices: ?[*]const u32 = null,
};
// Extension: VK_KHR_device_group
pub const VkDeviceGroupSubmitInfoKHR = VkDeviceGroupSubmitInfo;
// Extension: VK_BASE_VERSION_1_1
// Extends: VkBindSparseInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDeviceGroupBindSparseInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    resourceDeviceIndex: u32 = 0,
    // Extern sync: false
    // Optional: false
    memoryDeviceIndex: u32 = 0,
};
// Extension: VK_KHR_device_group
pub const VkDeviceGroupBindSparseInfoKHR = VkDeviceGroupBindSparseInfo;
// Extension: VK_KHR_swapchain
// Extension: VK_KHR_device_group
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkDeviceGroupPresentCapabilitiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    presentMask: [VK_MAX_DEVICE_GROUP_SIZE]u32 = @import("std").mem.zeroes([VK_MAX_DEVICE_GROUP_SIZE]u32),
    // Extern sync: false
    // Optional: false
    modes: VkDeviceGroupPresentModeFlagsKHR = .{},
};
// Extension: VK_KHR_swapchain
// Extension: VK_KHR_device_group
// Extends: VkImageCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImageSwapchainCreateInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    swapchain: VkSwapchainKHR = .none,
};
// Extension: VK_KHR_swapchain
// Extension: VK_KHR_device_group
// Extends: VkBindImageMemoryInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkBindImageMemorySwapchainInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: true
    // Optional: false
    swapchain: VkSwapchainKHR = .none,
    // Extern sync: false
    // Optional: false
    imageIndex: u32 = 0,
};
// Extension: VK_KHR_swapchain
// Extension: VK_KHR_device_group
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkAcquireNextImageInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: true
    // Optional: false
    swapchain: VkSwapchainKHR = .none,
    // Extern sync: false
    // Optional: false
    timeout: u64 = 0,
    // Extern sync: true
    // Optional: true
    semaphore: VkSemaphore = .none,
    // Extern sync: true
    // Optional: true
    fence: VkFence = .none,
    // Extern sync: false
    // Optional: false
    deviceMask: u32 = 0,
};
// Extension: VK_KHR_swapchain
// Extension: VK_KHR_device_group
// Extends: VkPresentInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDeviceGroupPresentInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    swapchainCount: u32 = 0,
    // Length member: swapchainCount
    // Extern sync: false
    // Optional: false
    pDeviceMasks: ?[*]const u32 = null,
    // Extern sync: false
    // Optional: false
    mode: VkDeviceGroupPresentModeFlagsKHR = .{},
};
// Extension: VK_BASE_VERSION_1_1
// Extends: VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDeviceGroupDeviceCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    physicalDeviceCount: u32 = 0,
    // Length member: physicalDeviceCount
    // Extern sync: false
    // Optional: false
    pPhysicalDevices: ?[*]const VkPhysicalDevice = null,
};
// Extension: VK_KHR_device_group_creation
pub const VkDeviceGroupDeviceCreateInfoKHR = VkDeviceGroupDeviceCreateInfo;
// Extension: VK_KHR_swapchain
// Extension: VK_KHR_device_group
// Extends: VkSwapchainCreateInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDeviceGroupSwapchainCreateInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    modes: VkDeviceGroupPresentModeFlagsKHR = .{},
};
// Extension: VK_COMPUTE_VERSION_1_1
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDescriptorUpdateTemplateEntry = extern struct {
    // Extern sync: false
    // Optional: false
    // Comment: Binding within the destination descriptor set to write
    dstBinding: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Array element within the destination binding to write
    dstArrayElement: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Number of descriptors to write
    descriptorCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Descriptor type to write
    descriptorType: VkDescriptorType,
    // Extern sync: false
    // Optional: false
    // Comment: Offset into pData where the descriptors to update are stored
    offset: u64 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Stride between two descriptors in pData when writing more than one descriptor
    stride: u64 = 0,
};
// Extension: VK_KHR_descriptor_update_template
pub const VkDescriptorUpdateTemplateEntryKHR = VkDescriptorUpdateTemplateEntry;
// Extension: VK_COMPUTE_VERSION_1_1
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDescriptorUpdateTemplateCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkDescriptorUpdateTemplateCreateFlags = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Number of descriptor update entries to use for the update template
    descriptorUpdateEntryCount: u32 = 0,
    // Length member: descriptorUpdateEntryCount
    // Extern sync: false
    // Optional: false
    // Comment: Descriptor update entries for the template
    pDescriptorUpdateEntries: ?[*]const VkDescriptorUpdateTemplateEntry = null,
    // Extern sync: false
    // Optional: false
    templateType: VkDescriptorUpdateTemplateType,
    // Extern sync: false
    // Optional: false
    descriptorSetLayout: VkDescriptorSetLayout = .none,
    // Extern sync: false
    // Optional: false
    pipelineBindPoint: VkPipelineBindPoint,
    // Extern sync: false
    // Optional: false
    // Comment: If used for push descriptors, this is the only allowed layout
    pipelineLayout: VkPipelineLayout = .none,
    // Extern sync: false
    // Optional: false
    set: u32 = 0,
};
// Extension: VK_KHR_descriptor_update_template
pub const VkDescriptorUpdateTemplateCreateInfoKHR = VkDescriptorUpdateTemplateCreateInfo;
// Extension: VK_EXT_hdr_metadata
// Comment: Chromaticity coordinate
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkXYColorEXT = extern struct {
    // Extern sync: false
    // Optional: false
    x: f32 = 0,
    // Extern sync: false
    // Optional: false
    y: f32 = 0,
};
// Extension: VK_KHR_present_id
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDevicePresentIdFeaturesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: Present ID in VkPresentInfoKHR
    presentId: u32 = 0,
};
// Extension: VK_KHR_present_id
// Extends: VkPresentInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPresentIdKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PRESENT_ID_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: Copy of VkPresentInfoKHR::swapchainCount
    swapchainCount: u32 = 0,
    // Length member: swapchainCount
    // Extern sync: false
    // Optional: true
    // Comment: Present ID values for each swapchain
    pPresentIds: ?[*]const u64 = null,
};
// Extension: VK_KHR_present_id2
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDevicePresentId2FeaturesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_2_FEATURES_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: Present ID2 in VkPresentInfoKHR
    presentId2: u32 = 0,
};
// Extension: VK_KHR_present_id2
// Extends: VkPresentInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPresentId2KHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PRESENT_ID_2_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: Copy of VkPresentInfoKHR::swapchainCount
    swapchainCount: u32 = 0,
    // Length member: swapchainCount
    // Extern sync: false
    // Optional: true
    // Comment: Present ID values for each swapchain
    pPresentIds: ?[*]const u64 = null,
};
// Extension: VK_KHR_present_wait2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPresentWait2InfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PRESENT_WAIT_2_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    presentId: u64 = 0,
    // Extern sync: false
    // Optional: false
    timeout: u64 = 0,
};
// Extension: VK_KHR_present_wait
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDevicePresentWaitFeaturesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: vkWaitForPresentKHR is supported
    presentWait: u32 = 0,
};
// Extension: VK_KHR_present_wait2
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDevicePresentWait2FeaturesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_2_FEATURES_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: vkWaitForPresent2KHR is supported
    presentWait2: u32 = 0,
};
// Extension: VK_EXT_present_timing
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDevicePresentTimingFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_TIMING_FEATURES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: vkGetPastPresentationTimingEXT is supported
    presentTiming: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Absolute time can be used to specify present time
    presentAtAbsoluteTime: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Relative time can be used to specify present duration
    presentAtRelativeTime: u32 = 0,
};
// Extension: VK_EXT_present_timing
// Extends: VkSurfaceCapabilities2KHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPresentTimingSurfaceCapabilitiesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PRESENT_TIMING_SURFACE_CAPABILITIES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: presentation timings of the surface can be queried using vkGetPastPresentationTimingEXT
    presentTimingSupported: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: surface can be presented using absolute times
    presentAtAbsoluteTimeSupported: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: surface can be presented using relative times
    presentAtRelativeTimeSupported: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: present stages that can be queried
    presentStageQueries: VkPresentStageFlagsEXT = .{},
};
// Extension: VK_EXT_present_timing
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSwapchainTimingPropertiesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_SWAPCHAIN_TIMING_PROPERTIES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: Number of nanoseconds from the start of one refresh cycle to the next
    refreshDuration: u64 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Interval in nanoseconds between refresh cycles durations
    refreshInterval: u64 = 0,
};
// Extension: VK_EXT_present_timing
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSwapchainTimeDomainPropertiesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_SWAPCHAIN_TIME_DOMAIN_PROPERTIES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    timeDomainCount: u32 = 0,
    // Length member: timeDomainCount
    // Extern sync: false
    // Optional: true
    // Comment: Available time domains to use with the swapchain
    pTimeDomains: ?[*]VkTimeDomainKHR = null,
    // Length member: timeDomainCount
    // Extern sync: false
    // Optional: true
    // Comment: Unique identifier for a time domain
    pTimeDomainIds: ?[*]u64 = null,
};
// Extension: VK_EXT_present_timing
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPresentStageTimeEXT = extern struct {
    // Extern sync: false
    // Optional: false
    stage: VkPresentStageFlagsEXT = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Time in nanoseconds of the associated stage
    time: u64 = 0,
};
// Extension: VK_EXT_present_timing
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPastPresentationTimingInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PAST_PRESENTATION_TIMING_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkPastPresentationTimingFlagsEXT = .{},
    // Extern sync: true
    // Optional: false
    swapchain: VkSwapchainKHR = .none,
};
// Extension: VK_EXT_present_timing
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPastPresentationTimingPropertiesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PAST_PRESENTATION_TIMING_PROPERTIES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    timingPropertiesCounter: u64 = 0,
    // Extern sync: false
    // Optional: false
    timeDomainsCounter: u64 = 0,
    // Extern sync: false
    // Optional: false
    presentationTimingCount: u32 = 0,
    // Length member: presentationTimingCount
    // Extern sync: false
    // Optional: false
    pPresentationTimings: ?[*]VkPastPresentationTimingEXT = null,
};
// Extension: VK_EXT_present_timing
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPastPresentationTimingEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PAST_PRESENTATION_TIMING_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: Application-provided identifier, previously given to vkQueuePresentKHR
    presentId: u64 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Application-provided present time
    targetTime: u64 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Number of present stages results available in pPresentStages
    presentStageCount: u32 = 0,
    // Length member: presentStageCount
    // Extern sync: false
    // Optional: false
    // Comment: Reported timings for each present stage
    pPresentStages: ?[*]VkPresentStageTimeEXT = null,
    // Extern sync: false
    // Optional: false
    // Comment: Time domain of the present stages
    timeDomain: VkTimeDomainKHR,
    // Extern sync: false
    // Optional: false
    // Comment: Time domain id of the present stages
    timeDomainId: u64 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: VK_TRUE if all the present stages have been reported
    reportComplete: u32 = 0,
};
// Extension: VK_EXT_present_timing
// Extends: VkPresentInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPresentTimingsInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PRESENT_TIMINGS_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: Copy of VkPresentInfoKHR::swapchainCount
    swapchainCount: u32 = 0,
    // Length member: swapchainCount
    // Extern sync: false
    // Optional: true
    // Comment: Present timing details for each swapchain
    pTimingInfos: ?[*]const VkPresentTimingInfoEXT = null,
};
// Extension: VK_EXT_present_timing
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPresentTimingInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PRESENT_TIMING_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkPresentTimingInfoFlagsEXT = .{},
    // Extern sync: false
    // Optional: false
    targetTime: u64 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Time domain to interpret the target present time and collect present stages timings with
    timeDomainId: u64 = 0,
    // Extern sync: false
    // Optional: true
    // Comment: Present stages to collect timing information for
    presentStageQueries: VkPresentStageFlagsEXT = .{},
    // Extern sync: false
    // Optional: true
    // Comment: Target stage-local time domain's stage
    targetTimeDomainPresentStage: VkPresentStageFlagsEXT = .{},
};
// Extension: VK_EXT_present_timing
// Extends: VkCalibratedTimestampInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSwapchainCalibratedTimestampInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_SWAPCHAIN_CALIBRATED_TIMESTAMP_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: true
    // Optional: false
    swapchain: VkSwapchainKHR = .none,
    // Extern sync: false
    // Optional: false
    presentStage: VkPresentStageFlagsEXT = .{},
    // Extern sync: false
    // Optional: false
    timeDomainId: u64 = 0,
};
// Extension: VK_EXT_hdr_metadata
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkHdrMetadataEXT = extern struct {
};
// Extension: VK_HUAWEI_hdr_vivid
// Extends: VkHdrMetadataEXT
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkHdrVividDynamicMetadataHUAWEI = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_HDR_VIVID_DYNAMIC_METADATA_HUAWEI,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: Specified in bytes
    dynamicMetadataSize: u64 = 0,
    // Length member: dynamicMetadataSize
    // Extern sync: false
    // Optional: false
    // Comment: Binary code of size dynamicMetadataSize
    pDynamicMetadata: ?[*]const anyopaque = null,
};
// Extension: VK_AMD_display_native_hdr
// Extends: VkSurfaceCapabilities2KHR
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkDisplayNativeHdrSurfaceCapabilitiesAMD = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    localDimmingSupport: u32 = 0,
};
// Extension: VK_AMD_display_native_hdr
// Extends: VkSwapchainCreateInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSwapchainDisplayNativeHdrCreateInfoAMD = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    localDimmingEnable: u32 = 0,
};
// Extension: VK_GOOGLE_display_timing
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkRefreshCycleDurationGOOGLE = extern struct {
    // Extern sync: false
    // Optional: false
    // Comment: Number of nanoseconds from the start of one refresh cycle to the next
    refreshDuration: u64 = 0,
};
// Extension: VK_GOOGLE_display_timing
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPastPresentationTimingGOOGLE = extern struct {
    // Extern sync: false
    // Optional: false
    // Comment: Application-provided identifier, previously given to vkQueuePresentKHR
    presentID: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Earliest time an image should have been presented, previously given to vkQueuePresentKHR
    desiredPresentTime: u64 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Time the image was actually displayed
    actualPresentTime: u64 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Earliest time the image could have been displayed
    earliestPresentTime: u64 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: How early vkQueuePresentKHR was processed vs. how soon it needed to be and make earliestPresentTime
    presentMargin: u64 = 0,
};
// Extension: VK_GOOGLE_display_timing
// Extends: VkPresentInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPresentTimesInfoGOOGLE = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: Copy of VkPresentInfoKHR::swapchainCount
    swapchainCount: u32 = 0,
    // Length member: swapchainCount
    // Extern sync: false
    // Optional: true
    // Comment: The earliest times to present images
    pTimes: ?[*]const VkPresentTimeGOOGLE = null,
};
// Extension: VK_GOOGLE_display_timing
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPresentTimeGOOGLE = extern struct {
    // Extern sync: false
    // Optional: false
    // Comment: Application-provided identifier
    presentID: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Earliest time an image should be presented
    desiredPresentTime: u64 = 0,
};
// Extension: VK_MVK_ios_surface
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkIOSSurfaceCreateInfoMVK = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkIOSSurfaceCreateFlagsMVK = .{},
    // Extern sync: false
    // Optional: false
    pView: ?*const anyopaque = null,
};
// Extension: VK_MVK_macos_surface
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkMacOSSurfaceCreateInfoMVK = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkMacOSSurfaceCreateFlagsMVK = .{},
    // Extern sync: false
    // Optional: false
    pView: ?*const anyopaque = null,
};
// Extension: VK_EXT_metal_surface
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkMetalSurfaceCreateInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_METAL_SURFACE_CREATE_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkMetalSurfaceCreateFlagsEXT = .{},
    // Extern sync: false
    // Optional: false
    pLayer: ?*const CAMetalLayer = null,
};
// Extension: VK_NV_clip_space_w_scaling
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkViewportWScalingNV = extern struct {
    // Extern sync: false
    // Optional: false
    xcoeff: f32 = 0,
    // Extern sync: false
    // Optional: false
    ycoeff: f32 = 0,
};
// Extension: VK_NV_clip_space_w_scaling
// Extends: VkPipelineViewportStateCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineViewportWScalingStateCreateInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    viewportWScalingEnable: u32 = 0,
    // Extern sync: false
    // Optional: false
    viewportCount: u32 = 0,
    // Length member: viewportCount
    // Extern sync: false
    // Optional: true
    pViewportWScalings: ?[*]const VkViewportWScalingNV = null,
};
// Extension: VK_NV_viewport_swizzle
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkViewportSwizzleNV = extern struct {
    // Extern sync: false
    // Optional: false
    x: VkViewportCoordinateSwizzleNV,
    // Extern sync: false
    // Optional: false
    y: VkViewportCoordinateSwizzleNV,
    // Extern sync: false
    // Optional: false
    z: VkViewportCoordinateSwizzleNV,
    // Extern sync: false
    // Optional: false
    w: VkViewportCoordinateSwizzleNV,
};
// Extension: VK_NV_viewport_swizzle
// Extends: VkPipelineViewportStateCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineViewportSwizzleStateCreateInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkPipelineViewportSwizzleStateCreateFlagsNV = .{},
    // Extern sync: false
    // Optional: false
    viewportCount: u32 = 0,
    // Length member: viewportCount
    // Extern sync: false
    // Optional: false
    pViewportSwizzles: ?[*]const VkViewportSwizzleNV = null,
};
// Extension: VK_EXT_discard_rectangles
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceDiscardRectanglePropertiesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: max number of active discard rectangles
    maxDiscardRectangles: u32 = 0,
};
// Extension: VK_EXT_discard_rectangles
// Extends: VkGraphicsPipelineCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineDiscardRectangleStateCreateInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkPipelineDiscardRectangleStateCreateFlagsEXT = .{},
    // Extern sync: false
    // Optional: false
    discardRectangleMode: VkDiscardRectangleModeEXT,
    // Extern sync: false
    // Optional: true
    discardRectangleCount: u32 = 0,
    // Length member: discardRectangleCount
    // Extern sync: false
    // Optional: false
    pDiscardRectangles: ?[*]const VkRect2D = null,
};
// Extension: VK_NVX_multiview_per_view_attributes
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    perViewPositionAllComponents: u32 = 0,
};
// Extension: VK_GRAPHICS_VERSION_1_1
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkInputAttachmentAspectReference = extern struct {
    // Extern sync: false
    // Optional: false
    subpass: u32 = 0,
    // Extern sync: false
    // Optional: false
    inputAttachmentIndex: u32 = 0,
    // Extern sync: false
    // Optional: false
    aspectMask: VkImageAspectFlags = .{},
};
// Extension: VK_KHR_maintenance2
pub const VkInputAttachmentAspectReferenceKHR = VkInputAttachmentAspectReference;
// Extension: VK_GRAPHICS_VERSION_1_1
// Extends: VkRenderPassCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkRenderPassInputAttachmentAspectCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    aspectReferenceCount: u32 = 0,
    // Length member: aspectReferenceCount
    // Extern sync: false
    // Optional: false
    pAspectReferences: ?[*]const VkInputAttachmentAspectReference = null,
};
// Extension: VK_KHR_maintenance2
pub const VkRenderPassInputAttachmentAspectCreateInfoKHR = VkRenderPassInputAttachmentAspectCreateInfo;
// Extension: VK_KHR_get_surface_capabilities2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceSurfaceInfo2KHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    surface: VkSurfaceKHR = .none,
};
// Extension: VK_KHR_get_surface_capabilities2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkSurfaceCapabilities2KHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    surfaceCapabilities: VkSurfaceCapabilitiesKHR = .{},
};
// Extension: VK_KHR_get_surface_capabilities2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkSurfaceFormat2KHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    surfaceFormat: VkSurfaceFormatKHR = .{},
};
// Extension: VK_KHR_get_display_properties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkDisplayProperties2KHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    displayProperties: VkDisplayPropertiesKHR = .{},
};
// Extension: VK_KHR_get_display_properties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkDisplayPlaneProperties2KHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    displayPlaneProperties: VkDisplayPlanePropertiesKHR = .{},
};
// Extension: VK_KHR_get_display_properties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkDisplayModeProperties2KHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    displayModeProperties: VkDisplayModePropertiesKHR = .{},
};
// Extension: VK_NV_display_stereo
// Extends: VkDisplayModeProperties2KHR
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkDisplayModeStereoPropertiesNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_DISPLAY_MODE_STEREO_PROPERTIES_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: Whether this mode supports HDMI 3D stereo rendering.
    hdmi3DSupported: u32 = 0,
};
// Extension: VK_KHR_get_display_properties2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDisplayPlaneInfo2KHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: true
    // Optional: false
    mode: VkDisplayModeKHR = .none,
    // Extern sync: false
    // Optional: false
    planeIndex: u32 = 0,
};
// Extension: VK_KHR_get_display_properties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkDisplayPlaneCapabilities2KHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    capabilities: VkDisplayPlaneCapabilitiesKHR = .{},
};
// Extension: VK_KHR_shared_presentable_image
// Extends: VkSurfaceCapabilities2KHR
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkSharedPresentSurfaceCapabilitiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: true
    // Comment: Supported image usage flags if swapchain created using a shared present mode
    sharedPresentSupportedUsageFlags: VkImageUsageFlags = .{},
};
// Extension: VK_COMPUTE_VERSION_1_1
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDevice16BitStorageFeatures = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: 16-bit integer/floating-point variables supported in BufferBlock
    storageBuffer16BitAccess: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: 16-bit integer/floating-point variables supported in BufferBlock and Block
    uniformAndStorageBuffer16BitAccess: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: 16-bit integer/floating-point variables supported in PushConstant
    storagePushConstant16: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: 16-bit integer/floating-point variables supported in shader inputs and outputs
    storageInputOutput16: u32 = 0,
};
// Extension: VK_KHR_16bit_storage
pub const VkPhysicalDevice16BitStorageFeaturesKHR = VkPhysicalDevice16BitStorageFeatures;
// Extension: VK_COMPUTE_VERSION_1_1
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceSubgroupProperties = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: The size of a subgroup for this queue.
    subgroupSize: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Bitfield of what shader stages support subgroup operations
    supportedStages: VkShaderStageFlags = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Bitfield of what subgroup operations are supported.
    supportedOperations: VkSubgroupFeatureFlags = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Flag to specify whether quad operations are available in all stages.
    quadOperationsInAllStages: u32 = 0,
};
// Extension: VK_COMPUTE_VERSION_1_2
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: Flag to specify whether subgroup operations with extended types are supported
    shaderSubgroupExtendedTypes: u32 = 0,
};
// Extension: VK_KHR_shader_subgroup_extended_types
pub const VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR = VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures;
// Extension: VK_BASE_VERSION_1_1
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkBufferMemoryRequirementsInfo2 = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    buffer: VkBuffer = .none,
};
// Extension: VK_KHR_get_memory_requirements2
pub const VkBufferMemoryRequirementsInfo2KHR = VkBufferMemoryRequirementsInfo2;
// Extension: VK_BASE_VERSION_1_3
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDeviceBufferMemoryRequirements = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    pCreateInfo: ?*const VkBufferCreateInfo = null,
};
// Extension: VK_KHR_maintenance4
pub const VkDeviceBufferMemoryRequirementsKHR = VkDeviceBufferMemoryRequirements;
// Extension: VK_BASE_VERSION_1_1
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImageMemoryRequirementsInfo2 = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    image: VkImage = .none,
};
// Extension: VK_KHR_get_memory_requirements2
pub const VkImageMemoryRequirementsInfo2KHR = VkImageMemoryRequirementsInfo2;
// Extension: VK_BASE_VERSION_1_1
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImageSparseMemoryRequirementsInfo2 = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    image: VkImage = .none,
};
// Extension: VK_KHR_get_memory_requirements2
pub const VkImageSparseMemoryRequirementsInfo2KHR = VkImageSparseMemoryRequirementsInfo2;
// Extension: VK_BASE_VERSION_1_3
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDeviceImageMemoryRequirements = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    pCreateInfo: ?*const VkImageCreateInfo = null,
    // Extern sync: false
    // Optional: true
    planeAspect: VkImageAspectFlags = .{},
};
// Extension: VK_KHR_maintenance4
pub const VkDeviceImageMemoryRequirementsKHR = VkDeviceImageMemoryRequirements;
// Extension: VK_BASE_VERSION_1_1
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkMemoryRequirements2 = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    memoryRequirements: VkMemoryRequirements = .{},
};
// Extension: VK_KHR_get_memory_requirements2
// Extension: VK_NV_ray_tracing
pub const VkMemoryRequirements2KHR = VkMemoryRequirements2;
// Extension: VK_BASE_VERSION_1_1
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkSparseImageMemoryRequirements2 = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    memoryRequirements: VkSparseImageMemoryRequirements = .{},
};
// Extension: VK_KHR_get_memory_requirements2
pub const VkSparseImageMemoryRequirements2KHR = VkSparseImageMemoryRequirements2;
// Extension: VK_GRAPHICS_VERSION_1_1
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDevicePointClippingProperties = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    pointClippingBehavior: VkPointClippingBehavior,
};
// Extension: VK_KHR_maintenance2
pub const VkPhysicalDevicePointClippingPropertiesKHR = VkPhysicalDevicePointClippingProperties;
// Extension: VK_BASE_VERSION_1_1
// Extends: VkMemoryRequirements2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkMemoryDedicatedRequirements = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    prefersDedicatedAllocation: u32 = 0,
    // Extern sync: false
    // Optional: false
    requiresDedicatedAllocation: u32 = 0,
};
// Extension: VK_KHR_dedicated_allocation
pub const VkMemoryDedicatedRequirementsKHR = VkMemoryDedicatedRequirements;
// Extension: VK_BASE_VERSION_1_1
// Extends: VkMemoryAllocateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkMemoryDedicatedAllocateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    // Comment: Image that this allocation will be bound to
    image: VkImage = .none,
    // Extern sync: false
    // Optional: true
    // Comment: Buffer that this allocation will be bound to
    buffer: VkBuffer = .none,
};
// Extension: VK_KHR_dedicated_allocation
pub const VkMemoryDedicatedAllocateInfoKHR = VkMemoryDedicatedAllocateInfo;
// Extension: VK_BASE_VERSION_1_1
// Extends: VkImageViewCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImageViewUsageCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    usage: VkImageUsageFlags = .{},
};
// Extension: VK_EXT_image_sliced_view_of_3d
// Extends: VkImageViewCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImageViewSlicedCreateInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_IMAGE_VIEW_SLICED_CREATE_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    sliceOffset: u32 = 0,
    // Extern sync: false
    // Optional: false
    sliceCount: u32 = 0,
};
// Extension: VK_KHR_maintenance2
pub const VkImageViewUsageCreateInfoKHR = VkImageViewUsageCreateInfo;
// Extension: VK_GRAPHICS_VERSION_1_1
// Extends: VkPipelineTessellationStateCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineTessellationDomainOriginStateCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    domainOrigin: VkTessellationDomainOrigin,
};
// Extension: VK_KHR_maintenance2
pub const VkPipelineTessellationDomainOriginStateCreateInfoKHR = VkPipelineTessellationDomainOriginStateCreateInfo;
// Extension: VK_COMPUTE_VERSION_1_1
// Extends: VkSamplerCreateInfo,VkImageViewCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSamplerYcbcrConversionInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    conversion: VkSamplerYcbcrConversion = .none,
};
// Extension: VK_KHR_sampler_ycbcr_conversion
pub const VkSamplerYcbcrConversionInfoKHR = VkSamplerYcbcrConversionInfo;
// Extension: VK_COMPUTE_VERSION_1_1
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSamplerYcbcrConversionCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    format: VkFormat,
    // Extern sync: false
    // Optional: false
    ycbcrModel: VkSamplerYcbcrModelConversion,
    // Extern sync: false
    // Optional: false
    ycbcrRange: VkSamplerYcbcrRange,
    // Extern sync: false
    // Optional: false
    components: VkComponentMapping = .{},
    // Extern sync: false
    // Optional: false
    xChromaOffset: VkChromaLocation,
    // Extern sync: false
    // Optional: false
    yChromaOffset: VkChromaLocation,
    // Extern sync: false
    // Optional: false
    chromaFilter: VkFilter,
    // Extern sync: false
    // Optional: false
    forceExplicitReconstruction: u32 = 0,
};
// Extension: VK_KHR_sampler_ycbcr_conversion
pub const VkSamplerYcbcrConversionCreateInfoKHR = VkSamplerYcbcrConversionCreateInfo;
// Extension: VK_BASE_VERSION_1_1
// Extends: VkBindImageMemoryInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkBindImagePlaneMemoryInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    planeAspect: VkImageAspectFlags = .{},
};
// Extension: VK_KHR_sampler_ycbcr_conversion
pub const VkBindImagePlaneMemoryInfoKHR = VkBindImagePlaneMemoryInfo;
// Extension: VK_BASE_VERSION_1_1
// Extends: VkImageMemoryRequirementsInfo2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImagePlaneMemoryRequirementsInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    planeAspect: VkImageAspectFlags = .{},
};
// Extension: VK_KHR_sampler_ycbcr_conversion
pub const VkImagePlaneMemoryRequirementsInfoKHR = VkImagePlaneMemoryRequirementsInfo;
// Extension: VK_COMPUTE_VERSION_1_1
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceSamplerYcbcrConversionFeatures = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: Sampler color conversion supported
    samplerYcbcrConversion: u32 = 0,
};
// Extension: VK_KHR_sampler_ycbcr_conversion
pub const VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR = VkPhysicalDeviceSamplerYcbcrConversionFeatures;
// Extension: VK_COMPUTE_VERSION_1_1
// Extends: VkImageFormatProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkSamplerYcbcrConversionImageFormatProperties = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    combinedImageSamplerDescriptorCount: u32 = 0,
};
// Extension: VK_KHR_sampler_ycbcr_conversion
pub const VkSamplerYcbcrConversionImageFormatPropertiesKHR = VkSamplerYcbcrConversionImageFormatProperties;
// Extension: VK_AMD_texture_gather_bias_lod
// Extends: VkImageFormatProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkTextureLODGatherFormatPropertiesAMD = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    supportsTextureGatherLODBiasAMD: u32 = 0,
};
// Extension: VK_EXT_conditional_rendering
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkConditionalRenderingBeginInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    buffer: VkBuffer = .none,
    // Extern sync: false
    // Optional: false
    offset: u64 = 0,
    // Extern sync: false
    // Optional: true
    flags: VkConditionalRenderingFlagsEXT = .{},
};
// Extension: VK_BASE_VERSION_1_1
// Extends: VkSubmitInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkProtectedSubmitInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: Submit protected command buffers
    protectedSubmit: u32 = 0,
};
// Extension: VK_BASE_VERSION_1_1
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceProtectedMemoryFeatures = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    protectedMemory: u32 = 0,
};
// Extension: VK_BASE_VERSION_1_1
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceProtectedMemoryProperties = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    protectedNoFault: u32 = 0,
};
// Extension: VK_BASE_VERSION_1_1
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDeviceQueueInfo2 = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkDeviceQueueCreateFlags = .{},
    // Extern sync: false
    // Optional: false
    queueFamilyIndex: u32 = 0,
    // Extern sync: false
    // Optional: false
    queueIndex: u32 = 0,
};
// Extension: VK_NV_fragment_coverage_to_color
// Extends: VkPipelineMultisampleStateCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineCoverageToColorStateCreateInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkPipelineCoverageToColorStateCreateFlagsNV = .{},
    // Extern sync: false
    // Optional: false
    coverageToColorEnable: u32 = 0,
    // Extern sync: false
    // Optional: true
    coverageToColorLocation: u32 = 0,
};
// Extension: VK_COMPUTE_VERSION_1_2
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceSamplerFilterMinmaxProperties = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    filterMinmaxSingleComponentFormats: u32 = 0,
    // Extern sync: false
    // Optional: false
    filterMinmaxImageComponentMapping: u32 = 0,
};
// Extension: VK_EXT_sampler_filter_minmax
pub const VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT = VkPhysicalDeviceSamplerFilterMinmaxProperties;
// Extension: VK_EXT_sample_locations
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSampleLocationEXT = extern struct {
    // Extern sync: false
    // Optional: false
    x: f32 = 0,
    // Extern sync: false
    // Optional: false
    y: f32 = 0,
};
// Extension: VK_EXT_sample_locations
// Extends: VkImageMemoryBarrier,VkImageMemoryBarrier2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSampleLocationsInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    sampleLocationsPerPixel: VkSampleCountFlags = .{},
    // Extern sync: false
    // Optional: false
    sampleLocationGridSize: VkExtent2D = .{},
    // Extern sync: false
    // Optional: true
    sampleLocationsCount: u32 = 0,
    // Length member: sampleLocationsCount
    // Extern sync: false
    // Optional: false
    pSampleLocations: ?[*]const VkSampleLocationEXT = null,
};
// Extension: VK_EXT_sample_locations
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkAttachmentSampleLocationsEXT = extern struct {
    // Extern sync: false
    // Optional: false
    attachmentIndex: u32 = 0,
    // Extern sync: false
    // Optional: false
    sampleLocationsInfo: VkSampleLocationsInfoEXT = .{},
};
// Extension: VK_EXT_sample_locations
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSubpassSampleLocationsEXT = extern struct {
    // Extern sync: false
    // Optional: false
    subpassIndex: u32 = 0,
    // Extern sync: false
    // Optional: false
    sampleLocationsInfo: VkSampleLocationsInfoEXT = .{},
};
// Extension: VK_EXT_sample_locations
// Extends: VkRenderPassBeginInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkRenderPassSampleLocationsBeginInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    attachmentInitialSampleLocationsCount: u32 = 0,
    // Length member: attachmentInitialSampleLocationsCount
    // Extern sync: false
    // Optional: false
    pAttachmentInitialSampleLocations: ?[*]const VkAttachmentSampleLocationsEXT = null,
    // Extern sync: false
    // Optional: true
    postSubpassSampleLocationsCount: u32 = 0,
    // Length member: postSubpassSampleLocationsCount
    // Extern sync: false
    // Optional: false
    pPostSubpassSampleLocations: ?[*]const VkSubpassSampleLocationsEXT = null,
};
// Extension: VK_EXT_sample_locations
// Extends: VkPipelineMultisampleStateCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineSampleLocationsStateCreateInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    sampleLocationsEnable: u32 = 0,
    // Extern sync: false
    // Optional: false
    sampleLocationsInfo: VkSampleLocationsInfoEXT = .{},
};
// Extension: VK_EXT_sample_locations
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceSampleLocationsPropertiesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    sampleLocationSampleCounts: VkSampleCountFlags = .{},
    // Extern sync: false
    // Optional: false
    maxSampleLocationGridSize: VkExtent2D = .{},
    // Extern sync: false
    // Optional: false
    sampleLocationCoordinateRange: [2]f32 = @import("std").mem.zeroes([2]f32),
    // Extern sync: false
    // Optional: false
    sampleLocationSubPixelBits: u32 = 0,
    // Extern sync: false
    // Optional: false
    variableSampleLocations: u32 = 0,
};
// Extension: VK_EXT_sample_locations
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkMultisamplePropertiesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    maxSampleLocationGridSize: VkExtent2D = .{},
};
// Extension: VK_COMPUTE_VERSION_1_2
// Extends: VkSamplerCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSamplerReductionModeCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    reductionMode: VkSamplerReductionMode,
};
// Extension: VK_EXT_sampler_filter_minmax
pub const VkSamplerReductionModeCreateInfoEXT = VkSamplerReductionModeCreateInfo;
// Extension: VK_EXT_blend_operation_advanced
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    advancedBlendCoherentOperations: u32 = 0,
};
// Extension: VK_EXT_multi_draw
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceMultiDrawFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    multiDraw: u32 = 0,
};
// Extension: VK_EXT_blend_operation_advanced
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    advancedBlendMaxColorAttachments: u32 = 0,
    // Extern sync: false
    // Optional: false
    advancedBlendIndependentBlend: u32 = 0,
    // Extern sync: false
    // Optional: false
    advancedBlendNonPremultipliedSrcColor: u32 = 0,
    // Extern sync: false
    // Optional: false
    advancedBlendNonPremultipliedDstColor: u32 = 0,
    // Extern sync: false
    // Optional: false
    advancedBlendCorrelatedOverlap: u32 = 0,
    // Extern sync: false
    // Optional: false
    advancedBlendAllOperations: u32 = 0,
};
// Extension: VK_EXT_blend_operation_advanced
// Extends: VkPipelineColorBlendStateCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineColorBlendAdvancedStateCreateInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    srcPremultiplied: u32 = 0,
    // Extern sync: false
    // Optional: false
    dstPremultiplied: u32 = 0,
    // Extern sync: false
    // Optional: false
    blendOverlap: VkBlendOverlapEXT,
};
// Extension: VK_COMPUTE_VERSION_1_3
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceInlineUniformBlockFeatures = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    inlineUniformBlock: u32 = 0,
    // Extern sync: false
    // Optional: false
    descriptorBindingInlineUniformBlockUpdateAfterBind: u32 = 0,
};
// Extension: VK_EXT_inline_uniform_block
pub const VkPhysicalDeviceInlineUniformBlockFeaturesEXT = VkPhysicalDeviceInlineUniformBlockFeatures;
// Extension: VK_COMPUTE_VERSION_1_3
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceInlineUniformBlockProperties = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    maxInlineUniformBlockSize: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxPerStageDescriptorInlineUniformBlocks: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxDescriptorSetInlineUniformBlocks: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxDescriptorSetUpdateAfterBindInlineUniformBlocks: u32 = 0,
};
// Extension: VK_EXT_inline_uniform_block
pub const VkPhysicalDeviceInlineUniformBlockPropertiesEXT = VkPhysicalDeviceInlineUniformBlockProperties;
// Extension: VK_COMPUTE_VERSION_1_3
// Extends: VkWriteDescriptorSet
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkWriteDescriptorSetInlineUniformBlock = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    dataSize: u32 = 0,
    // Length member: dataSize
    // Extern sync: false
    // Optional: false
    pData: ?[*]const anyopaque = null,
};
// Extension: VK_EXT_inline_uniform_block
pub const VkWriteDescriptorSetInlineUniformBlockEXT = VkWriteDescriptorSetInlineUniformBlock;
// Extension: VK_COMPUTE_VERSION_1_3
// Extends: VkDescriptorPoolCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDescriptorPoolInlineUniformBlockCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    maxInlineUniformBlockBindings: u32 = 0,
};
// Extension: VK_EXT_inline_uniform_block
pub const VkDescriptorPoolInlineUniformBlockCreateInfoEXT = VkDescriptorPoolInlineUniformBlockCreateInfo;
// Extension: VK_NV_framebuffer_mixed_samples
// Extends: VkPipelineMultisampleStateCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineCoverageModulationStateCreateInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkPipelineCoverageModulationStateCreateFlagsNV = .{},
    // Extern sync: false
    // Optional: false
    coverageModulationMode: VkCoverageModulationModeNV,
    // Extern sync: false
    // Optional: false
    coverageModulationTableEnable: u32 = 0,
    // Extern sync: false
    // Optional: true
    coverageModulationTableCount: u32 = 0,
    // Length member: coverageModulationTableCount
    // Extern sync: false
    // Optional: true
    pCoverageModulationTable: ?[*]const f32 = null,
};
// Extension: VK_BASE_VERSION_1_2
// Extends: VkImageCreateInfo,VkSwapchainCreateInfoKHR,VkPhysicalDeviceImageFormatInfo2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImageFormatListCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    viewFormatCount: u32 = 0,
    // Length member: viewFormatCount
    // Extern sync: false
    // Optional: false
    pViewFormats: ?[*]const VkFormat = null,
};
// Extension: VK_KHR_image_format_list
pub const VkImageFormatListCreateInfoKHR = VkImageFormatListCreateInfo;
// Extension: VK_EXT_validation_cache
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkValidationCacheCreateInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkValidationCacheCreateFlagsEXT = .{},
    // Extern sync: false
    // Optional: true
    initialDataSize: u64 = 0,
    // Length member: initialDataSize
    // Extern sync: false
    // Optional: false
    pInitialData: ?[*]const anyopaque = null,
};
// Extension: VK_EXT_validation_cache
// Extends: VkShaderModuleCreateInfo,VkPipelineShaderStageCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkShaderModuleValidationCacheCreateInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    validationCache: VkValidationCacheEXT = .none,
};
// Extension: VK_COMPUTE_VERSION_1_1
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceMaintenance3Properties = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    maxPerSetDescriptors: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxMemoryAllocationSize: u64 = 0,
};
// Extension: VK_KHR_maintenance3
pub const VkPhysicalDeviceMaintenance3PropertiesKHR = VkPhysicalDeviceMaintenance3Properties;
// Extension: VK_BASE_VERSION_1_3
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceMaintenance4Features = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    maintenance4: u32 = 0,
};
// Extension: VK_KHR_maintenance4
pub const VkPhysicalDeviceMaintenance4FeaturesKHR = VkPhysicalDeviceMaintenance4Features;
// Extension: VK_BASE_VERSION_1_3
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceMaintenance4Properties = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    maxBufferSize: u64 = 0,
};
// Extension: VK_KHR_maintenance4
pub const VkPhysicalDeviceMaintenance4PropertiesKHR = VkPhysicalDeviceMaintenance4Properties;
// Extension: VK_BASE_VERSION_1_4
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceMaintenance5Features = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    maintenance5: u32 = 0,
};
// Extension: VK_KHR_maintenance5
pub const VkPhysicalDeviceMaintenance5FeaturesKHR = VkPhysicalDeviceMaintenance5Features;
// Extension: VK_BASE_VERSION_1_4
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceMaintenance5Properties = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_PROPERTIES,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    earlyFragmentMultisampleCoverageAfterSampleCounting: u32 = 0,
    // Extern sync: false
    // Optional: false
    earlyFragmentSampleMaskTestBeforeSampleCounting: u32 = 0,
    // Extern sync: false
    // Optional: false
    depthStencilSwizzleOneSupport: u32 = 0,
    // Extern sync: false
    // Optional: false
    polygonModePointSize: u32 = 0,
    // Extern sync: false
    // Optional: false
    nonStrictSinglePixelWideLinesUseParallelogram: u32 = 0,
    // Extern sync: false
    // Optional: false
    nonStrictWideLinesUseParallelogram: u32 = 0,
};
// Extension: VK_KHR_maintenance5
pub const VkPhysicalDeviceMaintenance5PropertiesKHR = VkPhysicalDeviceMaintenance5Properties;
// Extension: VK_BASE_VERSION_1_4
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceMaintenance6Features = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_FEATURES,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    maintenance6: u32 = 0,
};
// Extension: VK_KHR_maintenance6
pub const VkPhysicalDeviceMaintenance6FeaturesKHR = VkPhysicalDeviceMaintenance6Features;
// Extension: VK_BASE_VERSION_1_4
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceMaintenance6Properties = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_PROPERTIES,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    blockTexelViewCompatibleMultipleLayers: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxCombinedImageSamplerDescriptorCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    fragmentShadingRateClampCombinerInputs: u32 = 0,
};
// Extension: VK_KHR_maintenance6
pub const VkPhysicalDeviceMaintenance6PropertiesKHR = VkPhysicalDeviceMaintenance6Properties;
// Extension: VK_KHR_maintenance7
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceMaintenance7FeaturesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_7_FEATURES_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    maintenance7: u32 = 0,
};
// Extension: VK_KHR_maintenance7
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceMaintenance7PropertiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_7_PROPERTIES_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    robustFragmentShadingRateAttachmentAccess: u32 = 0,
    // Extern sync: false
    // Optional: false
    separateDepthStencilAttachmentAccess: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxDescriptorSetTotalUniformBuffersDynamic: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxDescriptorSetTotalStorageBuffersDynamic: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxDescriptorSetTotalBuffersDynamic: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxDescriptorSetUpdateAfterBindTotalUniformBuffersDynamic: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxDescriptorSetUpdateAfterBindTotalStorageBuffersDynamic: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxDescriptorSetUpdateAfterBindTotalBuffersDynamic: u32 = 0,
};
// Extension: VK_KHR_maintenance7
// Extends: VkPhysicalDeviceProperties2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceLayeredApiPropertiesListKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_PROPERTIES_LIST_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: true
    layeredApiCount: u32 = 0,
    // Length member: layeredApiCount
    // Extern sync: false
    // Optional: true
    // Comment: Output list of layered implementations underneath the physical device
    pLayeredApis: ?[*]VkPhysicalDeviceLayeredApiPropertiesKHR = null,
};
// Extension: VK_KHR_maintenance7
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceLayeredApiPropertiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_PROPERTIES_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    vendorID: u32 = 0,
    // Extern sync: false
    // Optional: false
    deviceID: u32 = 0,
    // Extern sync: false
    // Optional: false
    layeredAPI: VkPhysicalDeviceLayeredApiKHR,
    // Extern sync: false
    // Optional: false
    deviceName: [VK_MAX_PHYSICAL_DEVICE_NAME_SIZE]u8 = @import("std").mem.zeroes([VK_MAX_PHYSICAL_DEVICE_NAME_SIZE]u8),
};
// Extension: VK_KHR_maintenance7
// Extends: VkPhysicalDeviceLayeredApiPropertiesKHR
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceLayeredApiVulkanPropertiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_VULKAN_PROPERTIES_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    properties: VkPhysicalDeviceProperties2 = .{},
};
// Extension: VK_KHR_maintenance8
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceMaintenance8FeaturesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_8_FEATURES_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    maintenance8: u32 = 0,
};
// Extension: VK_KHR_maintenance9
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceMaintenance9FeaturesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_9_FEATURES_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    maintenance9: u32 = 0,
};
// Extension: VK_KHR_maintenance9
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceMaintenance9PropertiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_9_PROPERTIES_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    image2DViewOf3DSparse: u32 = 0,
    // Extern sync: false
    // Optional: false
    defaultVertexAttributeValue: VkDefaultVertexAttributeValueKHR,
};
// Extension: VK_KHR_maintenance10
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceMaintenance10PropertiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_10_PROPERTIES_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    rgba4OpaqueBlackSwizzled: u32 = 0,
    // Extern sync: false
    // Optional: false
    resolveSrgbFormatAppliesTransferFunction: u32 = 0,
    // Extern sync: false
    // Optional: false
    resolveSrgbFormatSupportsTransferFunctionControl: u32 = 0,
};
// Extension: VK_KHR_maintenance10
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceMaintenance10FeaturesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_10_FEATURES_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    maintenance10: u32 = 0,
};
// Extension: VK_KHR_maintenance9
// Extends: VkQueueFamilyProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkQueueFamilyOwnershipTransferPropertiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_QUEUE_FAMILY_OWNERSHIP_TRANSFER_PROPERTIES_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    optimalImageTransferToQueueFamilies: u32 = 0,
};
// Extension: VK_GRAPHICS_VERSION_1_4
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkRenderingAreaInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_RENDERING_AREA_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    viewMask: u32 = 0,
    // Extern sync: false
    // Optional: true
    colorAttachmentCount: u32 = 0,
    // Length member: colorAttachmentCount
    // Extern sync: false
    // Optional: false
    pColorAttachmentFormats: ?[*]const VkFormat = null,
    // Extern sync: false
    // Optional: false
    depthAttachmentFormat: VkFormat,
    // Extern sync: false
    // Optional: false
    stencilAttachmentFormat: VkFormat,
};
// Extension: VK_KHR_maintenance5
pub const VkRenderingAreaInfoKHR = VkRenderingAreaInfo;
// Extension: VK_COMPUTE_VERSION_1_1
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkDescriptorSetLayoutSupport = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    supported: u32 = 0,
};
// Extension: VK_KHR_maintenance3
pub const VkDescriptorSetLayoutSupportKHR = VkDescriptorSetLayoutSupport;
// Extension: VK_GRAPHICS_VERSION_1_1
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceShaderDrawParametersFeatures = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    shaderDrawParameters: u32 = 0,
};
// Extension: VK_GRAPHICS_VERSION_1_1
pub const VkPhysicalDeviceShaderDrawParameterFeatures = VkPhysicalDeviceShaderDrawParametersFeatures;
// Extension: VK_COMPUTE_VERSION_1_2
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceShaderFloat16Int8Features = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: 16-bit floats (halfs) in shaders
    shaderFloat16: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: 8-bit integers in shaders
    shaderInt8: u32 = 0,
};
// Extension: VK_KHR_shader_float16_int8
pub const VkPhysicalDeviceShaderFloat16Int8FeaturesKHR = VkPhysicalDeviceShaderFloat16Int8Features;
// Extension: VK_KHR_shader_float16_int8
pub const VkPhysicalDeviceFloat16Int8FeaturesKHR = VkPhysicalDeviceShaderFloat16Int8Features;
// Extension: VK_COMPUTE_VERSION_1_2
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceFloatControlsProperties = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    denormBehaviorIndependence: VkShaderFloatControlsIndependence,
    // Extern sync: false
    // Optional: false
    roundingModeIndependence: VkShaderFloatControlsIndependence,
    // Extern sync: false
    // Optional: false
    // Comment: An implementation can preserve signed zero, nan, inf
    shaderSignedZeroInfNanPreserveFloat16: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: An implementation can preserve signed zero, nan, inf
    shaderSignedZeroInfNanPreserveFloat32: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: An implementation can preserve signed zero, nan, inf
    shaderSignedZeroInfNanPreserveFloat64: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: An implementation can preserve  denormals
    shaderDenormPreserveFloat16: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: An implementation can preserve  denormals
    shaderDenormPreserveFloat32: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: An implementation can preserve  denormals
    shaderDenormPreserveFloat64: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: An implementation can flush to zero  denormals
    shaderDenormFlushToZeroFloat16: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: An implementation can flush to zero  denormals
    shaderDenormFlushToZeroFloat32: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: An implementation can flush to zero  denormals
    shaderDenormFlushToZeroFloat64: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: An implementation can support RTE
    shaderRoundingModeRTEFloat16: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: An implementation can support RTE
    shaderRoundingModeRTEFloat32: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: An implementation can support RTE
    shaderRoundingModeRTEFloat64: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: An implementation can support RTZ
    shaderRoundingModeRTZFloat16: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: An implementation can support RTZ
    shaderRoundingModeRTZFloat32: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: An implementation can support RTZ
    shaderRoundingModeRTZFloat64: u32 = 0,
};
// Extension: VK_KHR_shader_float_controls
pub const VkPhysicalDeviceFloatControlsPropertiesKHR = VkPhysicalDeviceFloatControlsProperties;
// Extension: VK_BASE_VERSION_1_2
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceHostQueryResetFeatures = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    hostQueryReset: u32 = 0,
};
// Extension: VK_EXT_host_query_reset
pub const VkPhysicalDeviceHostQueryResetFeaturesEXT = VkPhysicalDeviceHostQueryResetFeatures;
// Extension: VK_AMD_shader_info
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkShaderResourceUsageAMD = extern struct {
    // Extern sync: false
    // Optional: false
    numUsedVgprs: u32 = 0,
    // Extern sync: false
    // Optional: false
    numUsedSgprs: u32 = 0,
    // Extern sync: false
    // Optional: false
    ldsSizePerLocalWorkGroup: u32 = 0,
    // Extern sync: false
    // Optional: false
    ldsUsageSizeInBytes: u64 = 0,
    // Extern sync: false
    // Optional: false
    scratchMemUsageInBytes: u64 = 0,
};
// Extension: VK_AMD_shader_info
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkShaderStatisticsInfoAMD = extern struct {
    // Extern sync: false
    // Optional: false
    shaderStageMask: VkShaderStageFlags = .{},
    // Extern sync: false
    // Optional: false
    resourceUsage: VkShaderResourceUsageAMD = .{},
    // Extern sync: false
    // Optional: false
    numPhysicalVgprs: u32 = 0,
    // Extern sync: false
    // Optional: false
    numPhysicalSgprs: u32 = 0,
    // Extern sync: false
    // Optional: false
    numAvailableVgprs: u32 = 0,
    // Extern sync: false
    // Optional: false
    numAvailableSgprs: u32 = 0,
    // Extern sync: false
    // Optional: false
    computeWorkGroupSize: [3]u32 = @import("std").mem.zeroes([3]u32),
};
// Extension: VK_BASE_VERSION_1_4
// Extends: VkDeviceQueueCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDeviceQueueGlobalPriorityCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    globalPriority: VkQueueGlobalPriority,
};
// Extension: VK_KHR_global_priority
pub const VkDeviceQueueGlobalPriorityCreateInfoKHR = VkDeviceQueueGlobalPriorityCreateInfo;
// Extension: VK_EXT_global_priority
pub const VkDeviceQueueGlobalPriorityCreateInfoEXT = VkDeviceQueueGlobalPriorityCreateInfo;
// Extension: VK_BASE_VERSION_1_4
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceGlobalPriorityQueryFeatures = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    globalPriorityQuery: u32 = 0,
};
// Extension: VK_KHR_global_priority
pub const VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR = VkPhysicalDeviceGlobalPriorityQueryFeatures;
// Extension: VK_EXT_global_priority_query
pub const VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT = VkPhysicalDeviceGlobalPriorityQueryFeatures;
// Extension: VK_BASE_VERSION_1_4
// Extends: VkQueueFamilyProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkQueueFamilyGlobalPriorityProperties = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    priorityCount: u32 = 0,
    // Length member: priorityCount
    // Extern sync: false
    // Optional: false
    priorities: [VK_MAX_GLOBAL_PRIORITY_SIZE]VkQueueGlobalPriority = @import("std").mem.zeroes([VK_MAX_GLOBAL_PRIORITY_SIZE]VkQueueGlobalPriority),
};
// Extension: VK_KHR_global_priority
pub const VkQueueFamilyGlobalPriorityPropertiesKHR = VkQueueFamilyGlobalPriorityProperties;
// Extension: VK_EXT_global_priority_query
pub const VkQueueFamilyGlobalPriorityPropertiesEXT = VkQueueFamilyGlobalPriorityProperties;
// Extension: VK_EXT_debug_utils
// Extends: VkPipelineShaderStageCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDebugUtilsObjectNameInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    objectType: VkObjectType,
    // Extern sync: false
    // Optional: false
    // Object type: objectType (Which object handle is this)
    objectHandle: u64 = 0,
    // Length member: null-terminated
    // Extern sync: false
    // Optional: true
    pObjectName: ?[*:0]const u8 = null,
};
// Extension: VK_EXT_debug_utils
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDebugUtilsObjectTagInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    objectType: VkObjectType,
    // Extern sync: true
    // Optional: false
    // Object type: objectType (Which object handle is this)
    objectHandle: u64 = 0,
    // Extern sync: false
    // Optional: false
    tagName: u64 = 0,
    // Extern sync: false
    // Optional: false
    tagSize: u64 = 0,
    // Length member: tagSize
    // Extern sync: false
    // Optional: false
    pTag: ?[*]const anyopaque = null,
};
// Extension: VK_EXT_debug_utils
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDebugUtilsLabelEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Length member: null-terminated
    // Extern sync: false
    // Optional: false
    pLabelName: ?[*:0]const u8 = null,
    // Extern sync: false
    // Optional: false
    color: [4]f32 = @import("std").mem.zeroes([4]f32),
};
// Extension: VK_EXT_debug_utils
// Extends: VkInstanceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: true
pub const VkDebugUtilsMessengerCreateInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkDebugUtilsMessengerCreateFlagsEXT = .{},
    // Extern sync: false
    // Optional: false
    messageSeverity: VkDebugUtilsMessageSeverityFlagsEXT = .{},
    // Extern sync: false
    // Optional: false
    messageType: VkDebugUtilsMessageTypeFlagsEXT = .{},
    // Extern sync: false
    // Optional: false
    pfnUserCallback: ?*const vkDebugUtilsMessengerCallbackEXT = null,
    // Extern sync: false
    // Optional: true
    pUserData: ?*anyopaque = null,
};
// Extension: VK_EXT_debug_utils
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDebugUtilsMessengerCallbackDataEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkDebugUtilsMessengerCallbackDataFlagsEXT = .{},
    // Length member: null-terminated
    // Extern sync: false
    // Optional: true
    pMessageIdName: ?[*:0]const u8 = null,
    // Extern sync: false
    // Optional: false
    messageIdNumber: i32 = 0,
    // Length member: null-terminated
    // Extern sync: false
    // Optional: true
    pMessage: ?[*:0]const u8 = null,
    // Extern sync: false
    // Optional: true
    queueLabelCount: u32 = 0,
    // Length member: queueLabelCount
    // Extern sync: false
    // Optional: false
    pQueueLabels: ?[*]const VkDebugUtilsLabelEXT = null,
    // Extern sync: false
    // Optional: true
    cmdBufLabelCount: u32 = 0,
    // Length member: cmdBufLabelCount
    // Extern sync: false
    // Optional: false
    pCmdBufLabels: ?[*]const VkDebugUtilsLabelEXT = null,
    // Extern sync: false
    // Optional: true
    objectCount: u32 = 0,
    // Length member: objectCount
    // Extern sync: false
    // Optional: false
    pObjects: ?[*]const VkDebugUtilsObjectNameInfoEXT = null,
};
// Extension: VK_EXT_device_memory_report
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceDeviceMemoryReportFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    deviceMemoryReport: u32 = 0,
};
// Extension: VK_EXT_device_memory_report
// Extends: VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: true
pub const VkDeviceDeviceMemoryReportCreateInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    flags: VkDeviceMemoryReportFlagsEXT = .{},
    // Extern sync: false
    // Optional: false
    pfnUserCallback: ?*const vkDeviceMemoryReportCallbackEXT = null,
    // Extern sync: false
    // Optional: true
    pUserData: ?*anyopaque = null,
};
// Extension: VK_EXT_device_memory_report
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkDeviceMemoryReportCallbackDataEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_DEVICE_MEMORY_REPORT_CALLBACK_DATA_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    flags: VkDeviceMemoryReportFlagsEXT = .{},
    // Extern sync: false
    // Optional: false
    type: VkDeviceMemoryReportEventTypeEXT,
    // Extern sync: false
    // Optional: false
    memoryObjectId: u64 = 0,
    // Extern sync: false
    // Optional: false
    size: u64 = 0,
    // Extern sync: false
    // Optional: false
    objectType: VkObjectType,
    // Extern sync: false
    // Optional: false
    // Object type: objectType (Which object handle is this)
    objectHandle: u64 = 0,
    // Extern sync: false
    // Optional: false
    heapIndex: u32 = 0,
};
// Extension: VK_EXT_external_memory_host
// Extends: VkMemoryAllocateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImportMemoryHostPointerInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    handleType: VkExternalMemoryHandleTypeFlags = .{},
    // Extern sync: false
    // Optional: false
    pHostPointer: ?*anyopaque = null,
};
// Extension: VK_EXT_external_memory_host
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkMemoryHostPointerPropertiesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    memoryTypeBits: u32 = 0,
};
// Extension: VK_EXT_external_memory_host
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceExternalMemoryHostPropertiesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    minImportedHostPointerAlignment: u64 = 0,
};
// Extension: VK_EXT_conservative_rasterization
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceConservativeRasterizationPropertiesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: The size in pixels the primitive is enlarged at each edge during conservative rasterization
    primitiveOverestimationSize: f32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: The maximum additional overestimation the client can specify in the pipeline state
    maxExtraPrimitiveOverestimationSize: f32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: The granularity of extra overestimation sizes the implementations supports between 0 and maxExtraOverestimationSize
    extraPrimitiveOverestimationSizeGranularity: f32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: true if the implementation supports conservative rasterization underestimation mode
    primitiveUnderestimation: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: true if conservative rasterization also applies to points and lines
    conservativePointAndLineRasterization: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: true if degenerate triangles (those with zero area after snap) are rasterized
    degenerateTrianglesRasterized: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: true if degenerate lines (those with zero length after snap) are rasterized
    degenerateLinesRasterized: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: true if the implementation supports the FullyCoveredEXT SPIR-V builtin fragment shader input variable
    fullyCoveredFragmentShaderInputVariable: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: true if the implementation supports both conservative rasterization and post depth coverage sample coverage mask
    conservativeRasterizationPostDepthCoverage: u32 = 0,
};
// Extension: VK_KHR_calibrated_timestamps
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkCalibratedTimestampInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    timeDomain: VkTimeDomainKHR,
};
// Extension: VK_EXT_calibrated_timestamps
pub const VkCalibratedTimestampInfoEXT = VkCalibratedTimestampInfoKHR;
// Extension: VK_AMD_shader_core_properties
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceShaderCorePropertiesAMD = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: number of shader engines
    shaderEngineCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: number of shader arrays
    shaderArraysPerEngineCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: number of physical CUs per shader array
    computeUnitsPerShaderArray: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: number of SIMDs per compute unit
    simdPerComputeUnit: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: number of wavefront slots in each SIMD
    wavefrontsPerSimd: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: maximum number of threads per wavefront
    wavefrontSize: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: number of physical SGPRs per SIMD
    sgprsPerSimd: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: minimum number of SGPRs that can be allocated by a wave
    minSgprAllocation: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: number of available SGPRs
    maxSgprAllocation: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: SGPRs are allocated in groups of this size
    sgprAllocationGranularity: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: number of physical VGPRs per SIMD
    vgprsPerSimd: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: minimum number of VGPRs that can be allocated by a wave
    minVgprAllocation: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: number of available VGPRs
    maxVgprAllocation: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: VGPRs are allocated in groups of this size
    vgprAllocationGranularity: u32 = 0,
};
// Extension: VK_AMD_shader_core_properties2
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceShaderCoreProperties2AMD = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD,
    // Extern sync: false
    // Optional: true
    // Comment: Pointer to next structure
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: features supported by the shader core
    shaderCoreFeatures: VkShaderCorePropertiesFlagsAMD = .{},
    // Extern sync: false
    // Optional: false
    // Comment: number of active compute units across all shader engines/arrays
    activeComputeUnitCount: u32 = 0,
};
// Extension: VK_EXT_conservative_rasterization
// Extends: VkPipelineRasterizationStateCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineRasterizationConservativeStateCreateInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    // Comment: Reserved
    flags: VkPipelineRasterizationConservativeStateCreateFlagsEXT = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Conservative rasterization mode
    conservativeRasterizationMode: VkConservativeRasterizationModeEXT,
    // Extern sync: false
    // Optional: false
    // Comment: Extra overestimation to add to the primitive
    extraPrimitiveOverestimationSize: f32 = 0,
};
// Extension: VK_COMPUTE_VERSION_1_2
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceDescriptorIndexingFeatures = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    shaderInputAttachmentArrayDynamicIndexing: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderUniformTexelBufferArrayDynamicIndexing: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderStorageTexelBufferArrayDynamicIndexing: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderUniformBufferArrayNonUniformIndexing: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderSampledImageArrayNonUniformIndexing: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderStorageBufferArrayNonUniformIndexing: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderStorageImageArrayNonUniformIndexing: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderInputAttachmentArrayNonUniformIndexing: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderUniformTexelBufferArrayNonUniformIndexing: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderStorageTexelBufferArrayNonUniformIndexing: u32 = 0,
    // Extern sync: false
    // Optional: false
    descriptorBindingUniformBufferUpdateAfterBind: u32 = 0,
    // Extern sync: false
    // Optional: false
    descriptorBindingSampledImageUpdateAfterBind: u32 = 0,
    // Extern sync: false
    // Optional: false
    descriptorBindingStorageImageUpdateAfterBind: u32 = 0,
    // Extern sync: false
    // Optional: false
    descriptorBindingStorageBufferUpdateAfterBind: u32 = 0,
    // Extern sync: false
    // Optional: false
    descriptorBindingUniformTexelBufferUpdateAfterBind: u32 = 0,
    // Extern sync: false
    // Optional: false
    descriptorBindingStorageTexelBufferUpdateAfterBind: u32 = 0,
    // Extern sync: false
    // Optional: false
    descriptorBindingUpdateUnusedWhilePending: u32 = 0,
    // Extern sync: false
    // Optional: false
    descriptorBindingPartiallyBound: u32 = 0,
    // Extern sync: false
    // Optional: false
    descriptorBindingVariableDescriptorCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    runtimeDescriptorArray: u32 = 0,
};
// Extension: VK_EXT_descriptor_indexing
pub const VkPhysicalDeviceDescriptorIndexingFeaturesEXT = VkPhysicalDeviceDescriptorIndexingFeatures;
// Extension: VK_COMPUTE_VERSION_1_2
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceDescriptorIndexingProperties = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    maxUpdateAfterBindDescriptorsInAllPools: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderUniformBufferArrayNonUniformIndexingNative: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderSampledImageArrayNonUniformIndexingNative: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderStorageBufferArrayNonUniformIndexingNative: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderStorageImageArrayNonUniformIndexingNative: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderInputAttachmentArrayNonUniformIndexingNative: u32 = 0,
    // Extern sync: false
    // Optional: false
    robustBufferAccessUpdateAfterBind: u32 = 0,
    // Extern sync: false
    // Optional: false
    quadDivergentImplicitLod: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxPerStageDescriptorUpdateAfterBindSamplers: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxPerStageDescriptorUpdateAfterBindUniformBuffers: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxPerStageDescriptorUpdateAfterBindStorageBuffers: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxPerStageDescriptorUpdateAfterBindSampledImages: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxPerStageDescriptorUpdateAfterBindStorageImages: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxPerStageDescriptorUpdateAfterBindInputAttachments: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxPerStageUpdateAfterBindResources: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxDescriptorSetUpdateAfterBindSamplers: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxDescriptorSetUpdateAfterBindUniformBuffers: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxDescriptorSetUpdateAfterBindUniformBuffersDynamic: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxDescriptorSetUpdateAfterBindStorageBuffers: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxDescriptorSetUpdateAfterBindStorageBuffersDynamic: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxDescriptorSetUpdateAfterBindSampledImages: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxDescriptorSetUpdateAfterBindStorageImages: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxDescriptorSetUpdateAfterBindInputAttachments: u32 = 0,
};
// Extension: VK_EXT_descriptor_indexing
pub const VkPhysicalDeviceDescriptorIndexingPropertiesEXT = VkPhysicalDeviceDescriptorIndexingProperties;
// Extension: VK_COMPUTE_VERSION_1_2
// Extends: VkDescriptorSetLayoutCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDescriptorSetLayoutBindingFlagsCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    bindingCount: u32 = 0,
    // Length member: bindingCount
    // Extern sync: false
    // Optional: false
    pBindingFlags: ?[*]const VkDescriptorBindingFlags = null,
};
// Extension: VK_EXT_descriptor_indexing
pub const VkDescriptorSetLayoutBindingFlagsCreateInfoEXT = VkDescriptorSetLayoutBindingFlagsCreateInfo;
// Extension: VK_COMPUTE_VERSION_1_2
// Extends: VkDescriptorSetAllocateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDescriptorSetVariableDescriptorCountAllocateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    descriptorSetCount: u32 = 0,
    // Length member: descriptorSetCount
    // Extern sync: false
    // Optional: false
    pDescriptorCounts: ?[*]const u32 = null,
};
// Extension: VK_EXT_descriptor_indexing
pub const VkDescriptorSetVariableDescriptorCountAllocateInfoEXT = VkDescriptorSetVariableDescriptorCountAllocateInfo;
// Extension: VK_COMPUTE_VERSION_1_2
// Extends: VkDescriptorSetLayoutSupport
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkDescriptorSetVariableDescriptorCountLayoutSupport = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    maxVariableDescriptorCount: u32 = 0,
};
// Extension: VK_EXT_descriptor_indexing
pub const VkDescriptorSetVariableDescriptorCountLayoutSupportEXT = VkDescriptorSetVariableDescriptorCountLayoutSupport;
// Extension: VK_GRAPHICS_VERSION_1_2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkAttachmentDescription2 = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkAttachmentDescriptionFlags = .{},
    // Extern sync: false
    // Optional: false
    format: VkFormat,
    // Extern sync: false
    // Optional: false
    samples: VkSampleCountFlags = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Load operation for color or depth data
    loadOp: VkAttachmentLoadOp,
    // Extern sync: false
    // Optional: false
    // Comment: Store operation for color or depth data
    storeOp: VkAttachmentStoreOp,
    // Extern sync: false
    // Optional: false
    // Comment: Load operation for stencil data
    stencilLoadOp: VkAttachmentLoadOp,
    // Extern sync: false
    // Optional: false
    // Comment: Store operation for stencil data
    stencilStoreOp: VkAttachmentStoreOp,
    // Extern sync: false
    // Optional: false
    initialLayout: VkImageLayout,
    // Extern sync: false
    // Optional: false
    finalLayout: VkImageLayout,
};
// Extension: VK_KHR_create_renderpass2
pub const VkAttachmentDescription2KHR = VkAttachmentDescription2;
// Extension: VK_GRAPHICS_VERSION_1_2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkAttachmentReference2 = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    attachment: u32 = 0,
    // Extern sync: false
    // Optional: false
    layout: VkImageLayout,
    // Extern sync: false
    // Optional: false
    aspectMask: VkImageAspectFlags = .{},
};
// Extension: VK_KHR_create_renderpass2
pub const VkAttachmentReference2KHR = VkAttachmentReference2;
// Extension: VK_GRAPHICS_VERSION_1_2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSubpassDescription2 = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkSubpassDescriptionFlags = .{},
    // Extern sync: false
    // Optional: false
    pipelineBindPoint: VkPipelineBindPoint,
    // Extern sync: false
    // Optional: false
    viewMask: u32 = 0,
    // Extern sync: false
    // Optional: true
    inputAttachmentCount: u32 = 0,
    // Length member: inputAttachmentCount
    // Extern sync: false
    // Optional: false
    pInputAttachments: ?[*]const VkAttachmentReference2 = null,
    // Extern sync: false
    // Optional: true
    colorAttachmentCount: u32 = 0,
    // Length member: colorAttachmentCount
    // Extern sync: false
    // Optional: false
    pColorAttachments: ?[*]const VkAttachmentReference2 = null,
    // Length member: colorAttachmentCount
    // Extern sync: false
    // Optional: true
    pResolveAttachments: ?[*]const VkAttachmentReference2 = null,
    // Extern sync: false
    // Optional: true
    pDepthStencilAttachment: ?*const VkAttachmentReference2 = null,
    // Extern sync: false
    // Optional: true
    preserveAttachmentCount: u32 = 0,
    // Length member: preserveAttachmentCount
    // Extern sync: false
    // Optional: false
    pPreserveAttachments: ?[*]const u32 = null,
};
// Extension: VK_KHR_create_renderpass2
pub const VkSubpassDescription2KHR = VkSubpassDescription2;
// Extension: VK_GRAPHICS_VERSION_1_2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSubpassDependency2 = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    srcSubpass: u32 = 0,
    // Extern sync: false
    // Optional: false
    dstSubpass: u32 = 0,
    // Extern sync: false
    // Optional: true
    srcStageMask: VkPipelineStageFlags = .{},
    // Extern sync: false
    // Optional: true
    dstStageMask: VkPipelineStageFlags = .{},
    // Extern sync: false
    // Optional: true
    srcAccessMask: VkAccessFlags = .{},
    // Extern sync: false
    // Optional: true
    dstAccessMask: VkAccessFlags = .{},
    // Extern sync: false
    // Optional: true
    dependencyFlags: VkDependencyFlags = .{},
    // Extern sync: false
    // Optional: false
    viewOffset: i32 = 0,
};
// Extension: VK_KHR_create_renderpass2
pub const VkSubpassDependency2KHR = VkSubpassDependency2;
// Extension: VK_GRAPHICS_VERSION_1_2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkRenderPassCreateInfo2 = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkRenderPassCreateFlags = .{},
    // Extern sync: false
    // Optional: true
    attachmentCount: u32 = 0,
    // Length member: attachmentCount
    // Extern sync: false
    // Optional: false
    pAttachments: ?[*]const VkAttachmentDescription2 = null,
    // Extern sync: false
    // Optional: false
    subpassCount: u32 = 0,
    // Length member: subpassCount
    // Extern sync: false
    // Optional: false
    pSubpasses: ?[*]const VkSubpassDescription2 = null,
    // Extern sync: false
    // Optional: true
    dependencyCount: u32 = 0,
    // Length member: dependencyCount
    // Extern sync: false
    // Optional: false
    pDependencies: ?[*]const VkSubpassDependency2 = null,
    // Extern sync: false
    // Optional: true
    correlatedViewMaskCount: u32 = 0,
    // Length member: correlatedViewMaskCount
    // Extern sync: false
    // Optional: false
    pCorrelatedViewMasks: ?[*]const u32 = null,
};
// Extension: VK_KHR_create_renderpass2
pub const VkRenderPassCreateInfo2KHR = VkRenderPassCreateInfo2;
// Extension: VK_GRAPHICS_VERSION_1_2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSubpassBeginInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    contents: VkSubpassContents,
};
// Extension: VK_KHR_create_renderpass2
pub const VkSubpassBeginInfoKHR = VkSubpassBeginInfo;
// Extension: VK_GRAPHICS_VERSION_1_2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSubpassEndInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_SUBPASS_END_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
};
// Extension: VK_KHR_create_renderpass2
pub const VkSubpassEndInfoKHR = VkSubpassEndInfo;
// Extension: VK_BASE_VERSION_1_2
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceTimelineSemaphoreFeatures = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    timelineSemaphore: u32 = 0,
};
// Extension: VK_KHR_timeline_semaphore
pub const VkPhysicalDeviceTimelineSemaphoreFeaturesKHR = VkPhysicalDeviceTimelineSemaphoreFeatures;
// Extension: VK_BASE_VERSION_1_2
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceTimelineSemaphoreProperties = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    maxTimelineSemaphoreValueDifference: u64 = 0,
};
// Extension: VK_KHR_timeline_semaphore
pub const VkPhysicalDeviceTimelineSemaphorePropertiesKHR = VkPhysicalDeviceTimelineSemaphoreProperties;
// Extension: VK_BASE_VERSION_1_2
// Extends: VkSemaphoreCreateInfo,VkPhysicalDeviceExternalSemaphoreInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSemaphoreTypeCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    semaphoreType: VkSemaphoreType,
    // Extern sync: false
    // Optional: false
    initialValue: u64 = 0,
};
// Extension: VK_KHR_timeline_semaphore
pub const VkSemaphoreTypeCreateInfoKHR = VkSemaphoreTypeCreateInfo;
// Extension: VK_BASE_VERSION_1_2
// Extends: VkSubmitInfo,VkBindSparseInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkTimelineSemaphoreSubmitInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    waitSemaphoreValueCount: u32 = 0,
    // Length member: waitSemaphoreValueCount
    // Extern sync: false
    // Optional: true
    pWaitSemaphoreValues: ?[*]const u64 = null,
    // Extern sync: false
    // Optional: true
    signalSemaphoreValueCount: u32 = 0,
    // Length member: signalSemaphoreValueCount
    // Extern sync: false
    // Optional: true
    pSignalSemaphoreValues: ?[*]const u64 = null,
};
// Extension: VK_KHR_timeline_semaphore
pub const VkTimelineSemaphoreSubmitInfoKHR = VkTimelineSemaphoreSubmitInfo;
// Extension: VK_BASE_VERSION_1_2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSemaphoreWaitInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkSemaphoreWaitFlags = .{},
    // Extern sync: false
    // Optional: false
    semaphoreCount: u32 = 0,
    // Length member: semaphoreCount
    // Extern sync: false
    // Optional: false
    pSemaphores: ?[*]const VkSemaphore = null,
    // Length member: semaphoreCount
    // Extern sync: false
    // Optional: false
    pValues: ?[*]const u64 = null,
};
// Extension: VK_KHR_timeline_semaphore
pub const VkSemaphoreWaitInfoKHR = VkSemaphoreWaitInfo;
// Extension: VK_BASE_VERSION_1_2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSemaphoreSignalInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    semaphore: VkSemaphore = .none,
    // Extern sync: false
    // Optional: false
    value: u64 = 0,
};
// Extension: VK_KHR_timeline_semaphore
pub const VkSemaphoreSignalInfoKHR = VkSemaphoreSignalInfo;
// Extension: VK_GRAPHICS_VERSION_1_4
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVertexInputBindingDivisorDescription = extern struct {
    // Extern sync: false
    // Optional: false
    binding: u32 = 0,
    // Extern sync: false
    // Optional: false
    divisor: u32 = 0,
};
// Extension: VK_KHR_vertex_attribute_divisor
pub const VkVertexInputBindingDivisorDescriptionKHR = VkVertexInputBindingDivisorDescription;
// Extension: VK_EXT_vertex_attribute_divisor
pub const VkVertexInputBindingDivisorDescriptionEXT = VkVertexInputBindingDivisorDescription;
// Extension: VK_GRAPHICS_VERSION_1_4
// Extends: VkPipelineVertexInputStateCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineVertexInputDivisorStateCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    vertexBindingDivisorCount: u32 = 0,
    // Length member: vertexBindingDivisorCount
    // Extern sync: false
    // Optional: false
    pVertexBindingDivisors: ?[*]const VkVertexInputBindingDivisorDescription = null,
};
// Extension: VK_KHR_vertex_attribute_divisor
pub const VkPipelineVertexInputDivisorStateCreateInfoKHR = VkPipelineVertexInputDivisorStateCreateInfo;
// Extension: VK_EXT_vertex_attribute_divisor
pub const VkPipelineVertexInputDivisorStateCreateInfoEXT = VkPipelineVertexInputDivisorStateCreateInfo;
// Extension: VK_EXT_vertex_attribute_divisor
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: max value of vertex attribute divisor
    maxVertexAttribDivisor: u32 = 0,
};
// Extension: VK_GRAPHICS_VERSION_1_4
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceVertexAttributeDivisorProperties = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: max value of vertex attribute divisor
    maxVertexAttribDivisor: u32 = 0,
    // Extern sync: false
    // Optional: false
    supportsNonZeroFirstInstance: u32 = 0,
};
// Extension: VK_KHR_vertex_attribute_divisor
pub const VkPhysicalDeviceVertexAttributeDivisorPropertiesKHR = VkPhysicalDeviceVertexAttributeDivisorProperties;
// Extension: VK_EXT_pci_bus_info
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDevicePCIBusInfoPropertiesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    pciDomain: u32 = 0,
    // Extern sync: false
    // Optional: false
    pciBus: u32 = 0,
    // Extern sync: false
    // Optional: false
    pciDevice: u32 = 0,
    // Extern sync: false
    // Optional: false
    pciFunction: u32 = 0,
};
// Extension: VK_ANDROID_external_memory_android_hardware_buffer
// Extends: VkMemoryAllocateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImportAndroidHardwareBufferInfoANDROID = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    buffer: ?*AHardwareBuffer = null,
};
// Extension: VK_ANDROID_external_memory_android_hardware_buffer
// Extends: VkImageFormatProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkAndroidHardwareBufferUsageANDROID = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    androidHardwareBufferUsage: u64 = 0,
};
// Extension: VK_ANDROID_external_memory_android_hardware_buffer
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkAndroidHardwareBufferPropertiesANDROID = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    allocationSize: u64 = 0,
    // Extern sync: false
    // Optional: false
    memoryTypeBits: u32 = 0,
};
// Extension: VK_ANDROID_external_memory_android_hardware_buffer
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkMemoryGetAndroidHardwareBufferInfoANDROID = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    memory: VkDeviceMemory = .none,
};
// Extension: VK_ANDROID_external_memory_android_hardware_buffer
// Extends: VkAndroidHardwareBufferPropertiesANDROID
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkAndroidHardwareBufferFormatPropertiesANDROID = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    format: VkFormat,
    // Extern sync: false
    // Optional: false
    externalFormat: u64 = 0,
    // Extern sync: false
    // Optional: false
    formatFeatures: VkFormatFeatureFlags = .{},
    // Extern sync: false
    // Optional: false
    samplerYcbcrConversionComponents: VkComponentMapping = .{},
    // Extern sync: false
    // Optional: false
    suggestedYcbcrModel: VkSamplerYcbcrModelConversion,
    // Extern sync: false
    // Optional: false
    suggestedYcbcrRange: VkSamplerYcbcrRange,
    // Extern sync: false
    // Optional: false
    suggestedXChromaOffset: VkChromaLocation,
    // Extern sync: false
    // Optional: false
    suggestedYChromaOffset: VkChromaLocation,
};
// Extension: VK_EXT_conditional_rendering
// Extends: VkCommandBufferInheritanceInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkCommandBufferInheritanceConditionalRenderingInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: Whether this secondary command buffer may be executed during an active conditional rendering
    conditionalRenderingEnable: u32 = 0,
};
// Extension: VK_ANDROID_external_memory_android_hardware_buffer
// Extends: VkImageCreateInfo,VkSamplerYcbcrConversionCreateInfo,VkAttachmentDescription2,VkGraphicsPipelineCreateInfo,VkCommandBufferInheritanceInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkExternalFormatANDROID = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    externalFormat: u64 = 0,
};
// Extension: VK_COMPUTE_VERSION_1_2
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDevice8BitStorageFeatures = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: 8-bit integer variables supported in StorageBuffer
    storageBuffer8BitAccess: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: 8-bit integer variables supported in StorageBuffer and Uniform
    uniformAndStorageBuffer8BitAccess: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: 8-bit integer variables supported in PushConstant
    storagePushConstant8: u32 = 0,
};
// Extension: VK_KHR_8bit_storage
pub const VkPhysicalDevice8BitStorageFeaturesKHR = VkPhysicalDevice8BitStorageFeatures;
// Extension: VK_EXT_conditional_rendering
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceConditionalRenderingFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    conditionalRendering: u32 = 0,
    // Extern sync: false
    // Optional: false
    inheritedConditionalRendering: u32 = 0,
};
// Extension: VK_BASE_VERSION_1_2
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceVulkanMemoryModelFeatures = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    vulkanMemoryModel: u32 = 0,
    // Extern sync: false
    // Optional: false
    vulkanMemoryModelDeviceScope: u32 = 0,
    // Extern sync: false
    // Optional: false
    vulkanMemoryModelAvailabilityVisibilityChains: u32 = 0,
};
// Extension: VK_KHR_vulkan_memory_model
pub const VkPhysicalDeviceVulkanMemoryModelFeaturesKHR = VkPhysicalDeviceVulkanMemoryModelFeatures;
// Extension: VK_COMPUTE_VERSION_1_2
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceShaderAtomicInt64Features = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    shaderBufferInt64Atomics: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderSharedInt64Atomics: u32 = 0,
};
// Extension: VK_KHR_shader_atomic_int64
pub const VkPhysicalDeviceShaderAtomicInt64FeaturesKHR = VkPhysicalDeviceShaderAtomicInt64Features;
// Extension: VK_EXT_shader_atomic_float
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceShaderAtomicFloatFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    shaderBufferFloat32Atomics: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderBufferFloat32AtomicAdd: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderBufferFloat64Atomics: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderBufferFloat64AtomicAdd: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderSharedFloat32Atomics: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderSharedFloat32AtomicAdd: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderSharedFloat64Atomics: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderSharedFloat64AtomicAdd: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderImageFloat32Atomics: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderImageFloat32AtomicAdd: u32 = 0,
    // Extern sync: false
    // Optional: false
    sparseImageFloat32Atomics: u32 = 0,
    // Extern sync: false
    // Optional: false
    sparseImageFloat32AtomicAdd: u32 = 0,
};
// Extension: VK_EXT_shader_atomic_float2
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    shaderBufferFloat16Atomics: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderBufferFloat16AtomicAdd: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderBufferFloat16AtomicMinMax: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderBufferFloat32AtomicMinMax: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderBufferFloat64AtomicMinMax: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderSharedFloat16Atomics: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderSharedFloat16AtomicAdd: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderSharedFloat16AtomicMinMax: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderSharedFloat32AtomicMinMax: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderSharedFloat64AtomicMinMax: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderImageFloat32AtomicMinMax: u32 = 0,
    // Extern sync: false
    // Optional: false
    sparseImageFloat32AtomicMinMax: u32 = 0,
};
// Extension: VK_GRAPHICS_VERSION_1_4
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceVertexAttributeDivisorFeatures = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    vertexAttributeInstanceRateDivisor: u32 = 0,
    // Extern sync: false
    // Optional: false
    vertexAttributeInstanceRateZeroDivisor: u32 = 0,
};
// Extension: VK_KHR_vertex_attribute_divisor
pub const VkPhysicalDeviceVertexAttributeDivisorFeaturesKHR = VkPhysicalDeviceVertexAttributeDivisorFeatures;
// Extension: VK_EXT_vertex_attribute_divisor
pub const VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT = VkPhysicalDeviceVertexAttributeDivisorFeatures;
// Extension: VK_NV_device_diagnostic_checkpoints
// Extends: VkQueueFamilyProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkQueueFamilyCheckpointPropertiesNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    checkpointExecutionStageMask: VkPipelineStageFlags = .{},
};
// Extension: VK_NV_device_diagnostic_checkpoints
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkCheckpointDataNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    stage: VkPipelineStageFlags = .{},
    // Extern sync: false
    // Optional: false
    pCheckpointMarker: ?*anyopaque = null,
};
// Extension: VK_GRAPHICS_VERSION_1_2
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceDepthStencilResolveProperties = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: supported depth resolve modes
    supportedDepthResolveModes: VkResolveModeFlags = .{},
    // Extern sync: false
    // Optional: false
    // Comment: supported stencil resolve modes
    supportedStencilResolveModes: VkResolveModeFlags = .{},
    // Extern sync: false
    // Optional: false
    // Comment: depth and stencil resolve modes can be set independently if one of them is none
    independentResolveNone: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: depth and stencil resolve modes can be set independently
    independentResolve: u32 = 0,
};
// Extension: VK_KHR_depth_stencil_resolve
pub const VkPhysicalDeviceDepthStencilResolvePropertiesKHR = VkPhysicalDeviceDepthStencilResolveProperties;
// Extension: VK_GRAPHICS_VERSION_1_2
// Extends: VkSubpassDescription2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSubpassDescriptionDepthStencilResolve = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: depth resolve mode
    depthResolveMode: VkResolveModeFlags = .{},
    // Extern sync: false
    // Optional: false
    // Comment: stencil resolve mode
    stencilResolveMode: VkResolveModeFlags = .{},
    // Extern sync: false
    // Optional: true
    // Comment: depth/stencil resolve attachment
    pDepthStencilResolveAttachment: ?*const VkAttachmentReference2 = null,
};
// Extension: VK_KHR_depth_stencil_resolve
pub const VkSubpassDescriptionDepthStencilResolveKHR = VkSubpassDescriptionDepthStencilResolve;
// Extension: VK_EXT_astc_decode_mode
// Extends: VkImageViewCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImageViewASTCDecodeModeEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    decodeMode: VkFormat,
};
// Extension: VK_EXT_astc_decode_mode
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceASTCDecodeFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    decodeModeSharedExponent: u32 = 0,
};
// Extension: VK_EXT_transform_feedback
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceTransformFeedbackFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    transformFeedback: u32 = 0,
    // Extern sync: false
    // Optional: false
    geometryStreams: u32 = 0,
};
// Extension: VK_EXT_transform_feedback
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceTransformFeedbackPropertiesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    maxTransformFeedbackStreams: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxTransformFeedbackBuffers: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxTransformFeedbackBufferSize: u64 = 0,
    // Extern sync: false
    // Optional: false
    maxTransformFeedbackStreamDataSize: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxTransformFeedbackBufferDataSize: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxTransformFeedbackBufferDataStride: u32 = 0,
    // Extern sync: false
    // Optional: false
    transformFeedbackQueries: u32 = 0,
    // Extern sync: false
    // Optional: false
    transformFeedbackStreamsLinesTriangles: u32 = 0,
    // Extern sync: false
    // Optional: false
    transformFeedbackRasterizationStreamSelect: u32 = 0,
    // Extern sync: false
    // Optional: false
    transformFeedbackDraw: u32 = 0,
};
// Extension: VK_EXT_transform_feedback
// Extends: VkPipelineRasterizationStateCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineRasterizationStateStreamCreateInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkPipelineRasterizationStateStreamCreateFlagsEXT = .{},
    // Extern sync: false
    // Optional: false
    rasterizationStream: u32 = 0,
};
// Extension: VK_NV_representative_fragment_test
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    representativeFragmentTest: u32 = 0,
};
// Extension: VK_NV_representative_fragment_test
// Extends: VkGraphicsPipelineCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineRepresentativeFragmentTestStateCreateInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    representativeFragmentTestEnable: u32 = 0,
};
// Extension: VK_NV_scissor_exclusive
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceExclusiveScissorFeaturesNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    exclusiveScissor: u32 = 0,
};
// Extension: VK_NV_scissor_exclusive
// Extends: VkPipelineViewportStateCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineViewportExclusiveScissorStateCreateInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    exclusiveScissorCount: u32 = 0,
    // Length member: exclusiveScissorCount
    // Extern sync: false
    // Optional: false
    pExclusiveScissors: ?[*]const VkRect2D = null,
};
// Extension: VK_NV_corner_sampled_image
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceCornerSampledImageFeaturesNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    cornerSampledImage: u32 = 0,
};
// Extension: VK_KHR_compute_shader_derivatives
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    computeDerivativeGroupQuads: u32 = 0,
    // Extern sync: false
    // Optional: false
    computeDerivativeGroupLinear: u32 = 0,
};
// Extension: VK_NV_compute_shader_derivatives
pub const VkPhysicalDeviceComputeShaderDerivativesFeaturesNV = VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR;
// Extension: VK_KHR_compute_shader_derivatives
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceComputeShaderDerivativesPropertiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_PROPERTIES_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    meshAndTaskShaderDerivatives: u32 = 0,
};
// Extension: VK_NV_fragment_shader_barycentric
pub const VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV = VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR;
// Extension: VK_NV_shader_image_footprint
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceShaderImageFootprintFeaturesNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    imageFootprint: u32 = 0,
};
// Extension: VK_NV_dedicated_allocation_image_aliasing
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    dedicatedAllocationImageAliasing: u32 = 0,
};
// Extension: VK_KHR_copy_memory_indirect
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceCopyMemoryIndirectFeaturesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_FEATURES_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    indirectMemoryCopy: u32 = 0,
    // Extern sync: false
    // Optional: false
    indirectMemoryToImageCopy: u32 = 0,
};
// Extension: VK_NV_copy_memory_indirect
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceCopyMemoryIndirectFeaturesNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_FEATURES_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    indirectCopy: u32 = 0,
};
// Extension: VK_KHR_copy_memory_indirect
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceCopyMemoryIndirectPropertiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_PROPERTIES_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: Bitmask of VkQueueFlagBits indicating the family of queues that support indirect copy
    supportedQueues: VkQueueFlags = .{},
};
// Extension: VK_NV_copy_memory_indirect
pub const VkPhysicalDeviceCopyMemoryIndirectPropertiesNV = VkPhysicalDeviceCopyMemoryIndirectPropertiesKHR;
// Extension: VK_EXT_memory_decompression
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceMemoryDecompressionFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_FEATURES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    memoryDecompression: u32 = 0,
};
// Extension: VK_NV_memory_decompression
pub const VkPhysicalDeviceMemoryDecompressionFeaturesNV = VkPhysicalDeviceMemoryDecompressionFeaturesEXT;
// Extension: VK_EXT_memory_decompression
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceMemoryDecompressionPropertiesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_PROPERTIES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    decompressionMethods: VkMemoryDecompressionMethodFlagsEXT = .{},
    // Extern sync: false
    // Optional: false
    maxDecompressionIndirectCount: u64 = 0,
};
// Extension: VK_NV_memory_decompression
pub const VkPhysicalDeviceMemoryDecompressionPropertiesNV = VkPhysicalDeviceMemoryDecompressionPropertiesEXT;
// Extension: VK_NV_shading_rate_image
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkShadingRatePaletteNV = extern struct {
    // Extern sync: false
    // Optional: false
    shadingRatePaletteEntryCount: u32 = 0,
    // Length member: shadingRatePaletteEntryCount
    // Extern sync: false
    // Optional: false
    pShadingRatePaletteEntries: ?[*]const VkShadingRatePaletteEntryNV = null,
};
// Extension: VK_NV_shading_rate_image
// Extends: VkPipelineViewportStateCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineViewportShadingRateImageStateCreateInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    shadingRateImageEnable: u32 = 0,
    // Extern sync: false
    // Optional: true
    viewportCount: u32 = 0,
    // Length member: viewportCount
    // Extern sync: false
    // Optional: false
    pShadingRatePalettes: ?[*]const VkShadingRatePaletteNV = null,
};
// Extension: VK_NV_shading_rate_image
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceShadingRateImageFeaturesNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    shadingRateImage: u32 = 0,
    // Extern sync: false
    // Optional: false
    shadingRateCoarseSampleOrder: u32 = 0,
};
// Extension: VK_NV_shading_rate_image
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceShadingRateImagePropertiesNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    shadingRateTexelSize: VkExtent2D = .{},
    // Extern sync: false
    // Optional: false
    shadingRatePaletteSize: u32 = 0,
    // Extern sync: false
    // Optional: false
    shadingRateMaxCoarseSamples: u32 = 0,
};
// Extension: VK_HUAWEI_invocation_mask
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceInvocationMaskFeaturesHUAWEI = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    invocationMask: u32 = 0,
};
// Extension: VK_NV_shading_rate_image
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkCoarseSampleLocationNV = extern struct {
    // Extern sync: false
    // Optional: false
    pixelX: u32 = 0,
    // Extern sync: false
    // Optional: false
    pixelY: u32 = 0,
    // Extern sync: false
    // Optional: false
    sample: u32 = 0,
};
// Extension: VK_NV_shading_rate_image
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkCoarseSampleOrderCustomNV = extern struct {
    // Extern sync: false
    // Optional: false
    shadingRate: VkShadingRatePaletteEntryNV,
    // Extern sync: false
    // Optional: false
    sampleCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    sampleLocationCount: u32 = 0,
    // Length member: sampleLocationCount
    // Extern sync: false
    // Optional: false
    pSampleLocations: ?[*]const VkCoarseSampleLocationNV = null,
};
// Extension: VK_NV_shading_rate_image
// Extends: VkPipelineViewportStateCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineViewportCoarseSampleOrderStateCreateInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    sampleOrderType: VkCoarseSampleOrderTypeNV,
    // Extern sync: false
    // Optional: true
    customSampleOrderCount: u32 = 0,
    // Length member: customSampleOrderCount
    // Extern sync: false
    // Optional: false
    pCustomSampleOrders: ?[*]const VkCoarseSampleOrderCustomNV = null,
};
// Extension: VK_NV_mesh_shader
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceMeshShaderFeaturesNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Feature link: taskShaderNV
    taskShader: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Feature link: meshShaderNV
    meshShader: u32 = 0,
};
// Extension: VK_NV_mesh_shader
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceMeshShaderPropertiesNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    maxDrawMeshTasksCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxTaskWorkGroupInvocations: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxTaskWorkGroupSize: [3]u32 = @import("std").mem.zeroes([3]u32),
    // Extern sync: false
    // Optional: false
    maxTaskTotalMemorySize: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxTaskOutputCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxMeshWorkGroupInvocations: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxMeshWorkGroupSize: [3]u32 = @import("std").mem.zeroes([3]u32),
    // Extern sync: false
    // Optional: false
    maxMeshTotalMemorySize: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxMeshOutputVertices: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxMeshOutputPrimitives: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxMeshMultiviewViewCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    meshOutputPerVertexGranularity: u32 = 0,
    // Extern sync: false
    // Optional: false
    meshOutputPerPrimitiveGranularity: u32 = 0,
};
// Extension: VK_NV_mesh_shader
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDrawMeshTasksIndirectCommandNV = extern struct {
    // Extern sync: false
    // Optional: false
    taskCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    firstTask: u32 = 0,
};
// Extension: VK_EXT_mesh_shader
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceMeshShaderFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    taskShader: u32 = 0,
    // Extern sync: false
    // Optional: false
    meshShader: u32 = 0,
    // Extern sync: false
    // Optional: false
    multiviewMeshShader: u32 = 0,
    // Extern sync: false
    // Optional: false
    primitiveFragmentShadingRateMeshShader: u32 = 0,
    // Extern sync: false
    // Optional: false
    meshShaderQueries: u32 = 0,
};
// Extension: VK_EXT_mesh_shader
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceMeshShaderPropertiesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    maxTaskWorkGroupTotalCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxTaskWorkGroupCount: [3]u32 = @import("std").mem.zeroes([3]u32),
    // Extern sync: false
    // Optional: false
    maxTaskWorkGroupInvocations: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxTaskWorkGroupSize: [3]u32 = @import("std").mem.zeroes([3]u32),
    // Extern sync: false
    // Optional: false
    maxTaskPayloadSize: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxTaskSharedMemorySize: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxTaskPayloadAndSharedMemorySize: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxMeshWorkGroupTotalCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxMeshWorkGroupCount: [3]u32 = @import("std").mem.zeroes([3]u32),
    // Extern sync: false
    // Optional: false
    maxMeshWorkGroupInvocations: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxMeshWorkGroupSize: [3]u32 = @import("std").mem.zeroes([3]u32),
    // Extern sync: false
    // Optional: false
    maxMeshSharedMemorySize: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxMeshPayloadAndSharedMemorySize: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxMeshOutputMemorySize: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxMeshPayloadAndOutputMemorySize: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxMeshOutputComponents: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxMeshOutputVertices: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxMeshOutputPrimitives: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxMeshOutputLayers: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxMeshMultiviewViewCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    meshOutputPerVertexGranularity: u32 = 0,
    // Extern sync: false
    // Optional: false
    meshOutputPerPrimitiveGranularity: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxPreferredTaskWorkGroupInvocations: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxPreferredMeshWorkGroupInvocations: u32 = 0,
    // Extern sync: false
    // Optional: false
    prefersLocalInvocationVertexOutput: u32 = 0,
    // Extern sync: false
    // Optional: false
    prefersLocalInvocationPrimitiveOutput: u32 = 0,
    // Extern sync: false
    // Optional: false
    prefersCompactVertexOutput: u32 = 0,
    // Extern sync: false
    // Optional: false
    prefersCompactPrimitiveOutput: u32 = 0,
};
// Extension: VK_EXT_mesh_shader
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDrawMeshTasksIndirectCommandEXT = extern struct {
    // Extern sync: false
    // Optional: false
    groupCountX: u32 = 0,
    // Extern sync: false
    // Optional: false
    groupCountY: u32 = 0,
    // Extern sync: false
    // Optional: false
    groupCountZ: u32 = 0,
};
// Extension: VK_NV_ray_tracing
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkRayTracingShaderGroupCreateInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    type: VkRayTracingShaderGroupTypeKHR,
    // Extern sync: false
    // Optional: false
    generalShader: u32 = 0,
    // Extern sync: false
    // Optional: false
    closestHitShader: u32 = 0,
    // Extern sync: false
    // Optional: false
    anyHitShader: u32 = 0,
    // Extern sync: false
    // Optional: false
    intersectionShader: u32 = 0,
};
// Extension: VK_KHR_ray_tracing_pipeline
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkRayTracingShaderGroupCreateInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    type: VkRayTracingShaderGroupTypeKHR,
    // Extern sync: false
    // Optional: false
    generalShader: u32 = 0,
    // Extern sync: false
    // Optional: false
    closestHitShader: u32 = 0,
    // Extern sync: false
    // Optional: false
    anyHitShader: u32 = 0,
    // Extern sync: false
    // Optional: false
    intersectionShader: u32 = 0,
    // Extern sync: false
    // Optional: true
    pShaderGroupCaptureReplayHandle: ?*const anyopaque = null,
};
// Extension: VK_NV_ray_tracing
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkRayTracingPipelineCreateInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    // Comment: Pipeline creation flags
    flags: VkPipelineCreateFlags = .{},
    // Extern sync: false
    // Optional: false
    stageCount: u32 = 0,
    // Length member: stageCount
    // Extern sync: false
    // Optional: false
    // Comment: One entry for each active shader stage
    pStages: ?[*]const VkPipelineShaderStageCreateInfo = null,
    // Extern sync: false
    // Optional: false
    groupCount: u32 = 0,
    // Length member: groupCount
    // Extern sync: false
    // Optional: false
    pGroups: ?[*]const VkRayTracingShaderGroupCreateInfoNV = null,
    // Extern sync: false
    // Optional: false
    maxRecursionDepth: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Interface layout of the pipeline
    layout: VkPipelineLayout = .none,
    // Extern sync: false
    // Optional: true
    // Comment: If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is nonzero, it specifies the handle of the base pipeline this is a derivative of
    basePipelineHandle: VkPipeline = .none,
    // Extern sync: false
    // Optional: false
    // Comment: If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is not -1, it specifies an index into pCreateInfos of the base pipeline this is a derivative of
    basePipelineIndex: i32 = 0,
};
// Extension: VK_KHR_ray_tracing_pipeline
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkRayTracingPipelineCreateInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    // Comment: Pipeline creation flags
    flags: VkPipelineCreateFlags = .{},
    // Extern sync: false
    // Optional: true
    stageCount: u32 = 0,
    // Length member: stageCount
    // Extern sync: false
    // Optional: false
    // Comment: One entry for each active shader stage
    pStages: ?[*]const VkPipelineShaderStageCreateInfo = null,
    // Extern sync: false
    // Optional: true
    groupCount: u32 = 0,
    // Length member: groupCount
    // Extern sync: false
    // Optional: false
    pGroups: ?[*]const VkRayTracingShaderGroupCreateInfoKHR = null,
    // Extern sync: false
    // Optional: false
    maxPipelineRayRecursionDepth: u32 = 0,
    // Extern sync: false
    // Optional: true
    pLibraryInfo: ?*const VkPipelineLibraryCreateInfoKHR = null,
    // Extern sync: false
    // Optional: true
    pLibraryInterface: ?*const VkRayTracingPipelineInterfaceCreateInfoKHR = null,
    // Extern sync: false
    // Optional: true
    pDynamicState: ?*const VkPipelineDynamicStateCreateInfo = null,
    // Extern sync: false
    // Optional: false
    // Comment: Interface layout of the pipeline
    layout: VkPipelineLayout = .none,
    // Extern sync: false
    // Optional: true
    // Comment: If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is nonzero, it specifies the handle of the base pipeline this is a derivative of
    basePipelineHandle: VkPipeline = .none,
    // Extern sync: false
    // Optional: false
    // Comment: If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is not -1, it specifies an index into pCreateInfos of the base pipeline this is a derivative of
    basePipelineIndex: i32 = 0,
};
// Extension: VK_NV_ray_tracing
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkGeometryTrianglesNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    vertexData: VkBuffer = .none,
    // Extern sync: false
    // Optional: false
    vertexOffset: u64 = 0,
    // Extern sync: false
    // Optional: false
    vertexCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    vertexStride: u64 = 0,
    // Extern sync: false
    // Optional: false
    vertexFormat: VkFormat,
    // Extern sync: false
    // Optional: true
    indexData: VkBuffer = .none,
    // Extern sync: false
    // Optional: false
    indexOffset: u64 = 0,
    // Extern sync: false
    // Optional: false
    indexCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    indexType: VkIndexType,
    // Extern sync: false
    // Optional: true
    // Comment: Optional reference to array of floats representing a 3x4 row major affine transformation matrix.
    transformData: VkBuffer = .none,
    // Extern sync: false
    // Optional: false
    transformOffset: u64 = 0,
};
// Extension: VK_NV_ray_tracing
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkGeometryAABBNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_GEOMETRY_AABB_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    aabbData: VkBuffer = .none,
    // Extern sync: false
    // Optional: false
    numAABBs: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Stride in bytes between AABBs
    stride: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Offset in bytes of the first AABB in aabbData
    offset: u64 = 0,
};
// Extension: VK_NV_ray_tracing
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkGeometryDataNV = extern struct {
    // Extern sync: false
    // Optional: false
    triangles: VkGeometryTrianglesNV = .{},
    // Extern sync: false
    // Optional: false
    aabbs: VkGeometryAABBNV = .{},
};
// Extension: VK_NV_ray_tracing
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkGeometryNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_GEOMETRY_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    geometryType: VkGeometryTypeKHR,
    // Extern sync: false
    // Optional: false
    geometry: VkGeometryDataNV = .{},
    // Extern sync: false
    // Optional: true
    flags: VkGeometryFlagsKHR = .{},
};
// Extension: VK_NV_ray_tracing
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkAccelerationStructureInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    type: VkAccelerationStructureTypeKHR,
    // Extern sync: false
    // Optional: true
    // Extern sync: false
    // Optional: true
    instanceCount: u32 = 0,
    // Extern sync: false
    // Optional: true
    geometryCount: u32 = 0,
    // Length member: geometryCount
    // Extern sync: false
    // Optional: false
    pGeometries: ?[*]const VkGeometryNV = null,
};
// Extension: VK_NV_ray_tracing
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkAccelerationStructureCreateInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    compactedSize: u64 = 0,
    // Extern sync: false
    // Optional: false
    info: VkAccelerationStructureInfoNV = .{},
};
// Extension: VK_NV_ray_tracing
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkBindAccelerationStructureMemoryInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    accelerationStructure: VkAccelerationStructureNV = .none,
    // Extern sync: false
    // Optional: false
    memory: VkDeviceMemory = .none,
    // Extern sync: false
    // Optional: false
    memoryOffset: u64 = 0,
    // Extern sync: false
    // Optional: true
    deviceIndexCount: u32 = 0,
    // Length member: deviceIndexCount
    // Extern sync: false
    // Optional: false
    pDeviceIndices: ?[*]const u32 = null,
};
// Extension: VK_KHR_acceleration_structure
// Extends: VkWriteDescriptorSet
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkWriteDescriptorSetAccelerationStructureKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    accelerationStructureCount: u32 = 0,
    // Length member: accelerationStructureCount
    // Extern sync: false
    // Optional: false
    pAccelerationStructures: ?[*]const VkAccelerationStructureKHR = null,
};
// Extension: VK_NV_ray_tracing
// Extends: VkWriteDescriptorSet
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkWriteDescriptorSetAccelerationStructureNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    accelerationStructureCount: u32 = 0,
    // Length member: accelerationStructureCount
    // Extern sync: false
    // Optional: false
    pAccelerationStructures: ?[*]const VkAccelerationStructureNV = null,
};
// Extension: VK_NV_ray_tracing
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkAccelerationStructureMemoryRequirementsInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    type: VkAccelerationStructureMemoryRequirementsTypeNV,
    // Extern sync: false
    // Optional: false
    accelerationStructure: VkAccelerationStructureNV = .none,
};
// Extension: VK_KHR_acceleration_structure
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceAccelerationStructureFeaturesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    accelerationStructure: u32 = 0,
    // Extern sync: false
    // Optional: false
    accelerationStructureCaptureReplay: u32 = 0,
    // Extern sync: false
    // Optional: false
    accelerationStructureIndirectBuild: u32 = 0,
    // Extern sync: false
    // Optional: false
    accelerationStructureHostCommands: u32 = 0,
    // Extern sync: false
    // Optional: false
    descriptorBindingAccelerationStructureUpdateAfterBind: u32 = 0,
};
// Extension: VK_KHR_ray_tracing_pipeline
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceRayTracingPipelineFeaturesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    rayTracingPipeline: u32 = 0,
    // Extern sync: false
    // Optional: false
    rayTracingPipelineShaderGroupHandleCaptureReplay: u32 = 0,
    // Extern sync: false
    // Optional: false
    rayTracingPipelineShaderGroupHandleCaptureReplayMixed: u32 = 0,
    // Extern sync: false
    // Optional: false
    rayTracingPipelineTraceRaysIndirect: u32 = 0,
    // Extern sync: false
    // Optional: false
    rayTraversalPrimitiveCulling: u32 = 0,
};
// Extension: VK_KHR_ray_query
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceRayQueryFeaturesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    rayQuery: u32 = 0,
};
// Extension: VK_KHR_acceleration_structure
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceAccelerationStructurePropertiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    maxGeometryCount: u64 = 0,
    // Extern sync: false
    // Optional: false
    maxInstanceCount: u64 = 0,
    // Extern sync: false
    // Optional: false
    maxPrimitiveCount: u64 = 0,
    // Extern sync: false
    // Optional: false
    maxPerStageDescriptorAccelerationStructures: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxPerStageDescriptorUpdateAfterBindAccelerationStructures: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxDescriptorSetAccelerationStructures: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxDescriptorSetUpdateAfterBindAccelerationStructures: u32 = 0,
    // Extern sync: false
    // Optional: false
    minAccelerationStructureScratchOffsetAlignment: u32 = 0,
};
// Extension: VK_KHR_ray_tracing_pipeline
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceRayTracingPipelinePropertiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    shaderGroupHandleSize: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxRayRecursionDepth: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxShaderGroupStride: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderGroupBaseAlignment: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderGroupHandleCaptureReplaySize: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxRayDispatchInvocationCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderGroupHandleAlignment: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxRayHitAttributeSize: u32 = 0,
};
// Extension: VK_NV_ray_tracing
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceRayTracingPropertiesNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    shaderGroupHandleSize: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxRecursionDepth: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxShaderGroupStride: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderGroupBaseAlignment: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxGeometryCount: u64 = 0,
    // Extern sync: false
    // Optional: false
    maxInstanceCount: u64 = 0,
    // Extern sync: false
    // Optional: false
    maxTriangleCount: u64 = 0,
    // Extern sync: false
    // Optional: false
    maxDescriptorSetAccelerationStructures: u32 = 0,
};
// Extension: VK_KHR_ray_tracing_pipeline
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkStridedDeviceAddressRegionKHR = extern struct {
    // Extern sync: false
    // Optional: true
    deviceAddress: u64 = 0,
    // Extern sync: false
    // Optional: false
    stride: u64 = 0,
    // Extern sync: false
    // Optional: false
    size: u64 = 0,
};
// Extension: VK_KHR_ray_tracing_pipeline
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkTraceRaysIndirectCommandKHR = extern struct {
    // Extern sync: false
    // Optional: false
    width: u32 = 0,
    // Extern sync: false
    // Optional: false
    height: u32 = 0,
    // Extern sync: false
    // Optional: false
    depth: u32 = 0,
};
// Extension: VK_KHR_ray_tracing_maintenance1
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkTraceRaysIndirectCommand2KHR = extern struct {
    // Extern sync: false
    // Optional: false
    raygenShaderRecordAddress: u64 = 0,
    // Extern sync: false
    // Optional: false
    raygenShaderRecordSize: u64 = 0,
    // Extern sync: false
    // Optional: false
    missShaderBindingTableAddress: u64 = 0,
    // Extern sync: false
    // Optional: false
    missShaderBindingTableSize: u64 = 0,
    // Extern sync: false
    // Optional: false
    missShaderBindingTableStride: u64 = 0,
    // Extern sync: false
    // Optional: false
    hitShaderBindingTableAddress: u64 = 0,
    // Extern sync: false
    // Optional: false
    hitShaderBindingTableSize: u64 = 0,
    // Extern sync: false
    // Optional: false
    hitShaderBindingTableStride: u64 = 0,
    // Extern sync: false
    // Optional: false
    callableShaderBindingTableAddress: u64 = 0,
    // Extern sync: false
    // Optional: false
    callableShaderBindingTableSize: u64 = 0,
    // Extern sync: false
    // Optional: false
    callableShaderBindingTableStride: u64 = 0,
    // Extern sync: false
    // Optional: false
    width: u32 = 0,
    // Extern sync: false
    // Optional: false
    height: u32 = 0,
    // Extern sync: false
    // Optional: false
    depth: u32 = 0,
};
// Extension: VK_KHR_ray_tracing_maintenance1
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    rayTracingMaintenance1: u32 = 0,
    // Extern sync: false
    // Optional: false
    rayTracingPipelineTraceRaysIndirect2: u32 = 0,
};
// Extension: VK_EXT_image_drm_format_modifier
// Extends: VkFormatProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkDrmFormatModifierPropertiesListEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: true
    drmFormatModifierCount: u32 = 0,
    // Length member: drmFormatModifierCount
    // Extern sync: false
    // Optional: true
    pDrmFormatModifierProperties: ?[*]VkDrmFormatModifierPropertiesEXT = null,
};
// Extension: VK_EXT_image_drm_format_modifier
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkDrmFormatModifierPropertiesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    drmFormatModifier: u64 = 0,
    // Extern sync: false
    // Optional: false
    drmFormatModifierPlaneCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    drmFormatModifierTilingFeatures: VkFormatFeatureFlags = .{},
};
// Extension: VK_EXT_image_drm_format_modifier
// Extends: VkPhysicalDeviceImageFormatInfo2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceImageDrmFormatModifierInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    drmFormatModifier: u64 = 0,
    // Extern sync: false
    // Optional: false
    sharingMode: VkSharingMode,
    // Extern sync: false
    // Optional: true
    queueFamilyIndexCount: u32 = 0,
    // Length member: queueFamilyIndexCount
    // Extern sync: false
    // Optional: false
    pQueueFamilyIndices: ?[*]const u32 = null,
};
// Extension: VK_EXT_image_drm_format_modifier
// Extends: VkImageCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImageDrmFormatModifierListCreateInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    drmFormatModifierCount: u32 = 0,
    // Length member: drmFormatModifierCount
    // Extern sync: false
    // Optional: false
    pDrmFormatModifiers: ?[*]const u64 = null,
};
// Extension: VK_EXT_image_drm_format_modifier
// Extends: VkImageCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImageDrmFormatModifierExplicitCreateInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    drmFormatModifier: u64 = 0,
    // Extern sync: false
    // Optional: false
    drmFormatModifierPlaneCount: u32 = 0,
    // Length member: drmFormatModifierPlaneCount
    // Extern sync: false
    // Optional: false
    pPlaneLayouts: ?[*]const VkSubresourceLayout = null,
};
// Extension: VK_EXT_image_drm_format_modifier
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkImageDrmFormatModifierPropertiesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    drmFormatModifier: u64 = 0,
};
// Extension: VK_GRAPHICS_VERSION_1_2
// Extends: VkImageCreateInfo,VkPhysicalDeviceImageFormatInfo2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImageStencilUsageCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    stencilUsage: VkImageUsageFlags = .{},
};
// Extension: VK_EXT_separate_stencil_usage
pub const VkImageStencilUsageCreateInfoEXT = VkImageStencilUsageCreateInfo;
// Extension: VK_AMD_memory_overallocation_behavior
// Extends: VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDeviceMemoryOverallocationCreateInfoAMD = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    overallocationBehavior: VkMemoryOverallocationBehaviorAMD,
};
// Extension: VK_EXT_fragment_density_map
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceFragmentDensityMapFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    fragmentDensityMap: u32 = 0,
    // Extern sync: false
    // Optional: false
    fragmentDensityMapDynamic: u32 = 0,
    // Extern sync: false
    // Optional: false
    fragmentDensityMapNonSubsampledImages: u32 = 0,
};
// Extension: VK_EXT_fragment_density_map2
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceFragmentDensityMap2FeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    fragmentDensityMapDeferred: u32 = 0,
};
// Extension: VK_EXT_fragment_density_map_offset
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceFragmentDensityMapOffsetFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    fragmentDensityMapOffset: u32 = 0,
};
// Extension: VK_QCOM_fragment_density_map_offset
pub const VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM = VkPhysicalDeviceFragmentDensityMapOffsetFeaturesEXT;
// Extension: VK_EXT_fragment_density_map
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceFragmentDensityMapPropertiesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    minFragmentDensityTexelSize: VkExtent2D = .{},
    // Extern sync: false
    // Optional: false
    maxFragmentDensityTexelSize: VkExtent2D = .{},
    // Extern sync: false
    // Optional: false
    fragmentDensityInvocations: u32 = 0,
};
// Extension: VK_EXT_fragment_density_map2
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceFragmentDensityMap2PropertiesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    subsampledLoads: u32 = 0,
    // Extern sync: false
    // Optional: false
    subsampledCoarseReconstructionEarlyAccess: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxSubsampledArrayLayers: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxDescriptorSetSubsampledSamplers: u32 = 0,
};
// Extension: VK_EXT_fragment_density_map_offset
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceFragmentDensityMapOffsetPropertiesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    fragmentDensityOffsetGranularity: VkExtent2D = .{},
};
// Extension: VK_QCOM_fragment_density_map_offset
pub const VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM = VkPhysicalDeviceFragmentDensityMapOffsetPropertiesEXT;
// Extension: VK_EXT_fragment_density_map
// Extends: VkRenderPassCreateInfo,VkRenderPassCreateInfo2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkRenderPassFragmentDensityMapCreateInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    fragmentDensityMapAttachment: VkAttachmentReference = .{},
};
// Extension: VK_EXT_fragment_density_map_offset
// Extends: VkSubpassEndInfo,VkRenderingEndInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkRenderPassFragmentDensityMapOffsetEndInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    fragmentDensityOffsetCount: u32 = 0,
    // Length member: fragmentDensityOffsetCount
    // Extern sync: false
    // Optional: false
    pFragmentDensityOffsets: ?[*]const VkOffset2D = null,
};
// Extension: VK_QCOM_fragment_density_map_offset
pub const VkSubpassFragmentDensityMapOffsetEndInfoQCOM = VkRenderPassFragmentDensityMapOffsetEndInfoEXT;
// Extension: VK_COMPUTE_VERSION_1_2
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceScalarBlockLayoutFeatures = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    scalarBlockLayout: u32 = 0,
};
// Extension: VK_EXT_scalar_block_layout
pub const VkPhysicalDeviceScalarBlockLayoutFeaturesEXT = VkPhysicalDeviceScalarBlockLayoutFeatures;
// Extension: VK_KHR_surface_protected_capabilities
// Extends: VkSurfaceCapabilities2KHR
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkSurfaceProtectedCapabilitiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: Represents if surface can be protected
    supportsProtected: u32 = 0,
};
// Extension: VK_COMPUTE_VERSION_1_2
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceUniformBufferStandardLayoutFeatures = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    uniformBufferStandardLayout: u32 = 0,
};
// Extension: VK_KHR_uniform_buffer_standard_layout
pub const VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR = VkPhysicalDeviceUniformBufferStandardLayoutFeatures;
// Extension: VK_EXT_depth_clip_enable
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceDepthClipEnableFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    depthClipEnable: u32 = 0,
};
// Extension: VK_EXT_depth_clip_enable
// Extends: VkPipelineRasterizationStateCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineRasterizationDepthClipStateCreateInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    // Comment: Reserved
    flags: VkPipelineRasterizationDepthClipStateCreateFlagsEXT = .{},
    // Extern sync: false
    // Optional: false
    depthClipEnable: u32 = 0,
};
// Extension: VK_EXT_memory_budget
// Extends: VkPhysicalDeviceMemoryProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceMemoryBudgetPropertiesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    heapBudget: [VK_MAX_MEMORY_HEAPS]u64 = @import("std").mem.zeroes([VK_MAX_MEMORY_HEAPS]u64),
    // Extern sync: false
    // Optional: false
    heapUsage: [VK_MAX_MEMORY_HEAPS]u64 = @import("std").mem.zeroes([VK_MAX_MEMORY_HEAPS]u64),
};
// Extension: VK_EXT_memory_priority
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceMemoryPriorityFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    memoryPriority: u32 = 0,
};
// Extension: VK_EXT_memory_priority
// Extends: VkMemoryAllocateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkMemoryPriorityAllocateInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    priority: f32 = 0,
};
// Extension: VK_EXT_pageable_device_local_memory
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    pageableDeviceLocalMemory: u32 = 0,
};
// Extension: VK_BASE_VERSION_1_2
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceBufferDeviceAddressFeatures = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    bufferDeviceAddress: u32 = 0,
    // Extern sync: false
    // Optional: false
    bufferDeviceAddressCaptureReplay: u32 = 0,
    // Extern sync: false
    // Optional: false
    bufferDeviceAddressMultiDevice: u32 = 0,
};
// Extension: VK_KHR_buffer_device_address
pub const VkPhysicalDeviceBufferDeviceAddressFeaturesKHR = VkPhysicalDeviceBufferDeviceAddressFeatures;
// Extension: VK_EXT_buffer_device_address
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceBufferDeviceAddressFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Feature link: bufferDeviceAddressEXT
    bufferDeviceAddress: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Feature link: bufferDeviceAddressCaptureReplayEXT
    bufferDeviceAddressCaptureReplay: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Feature link: bufferDeviceAddressMultiDeviceEXT
    bufferDeviceAddressMultiDevice: u32 = 0,
};
// Extension: VK_EXT_buffer_device_address
pub const VkPhysicalDeviceBufferAddressFeaturesEXT = VkPhysicalDeviceBufferDeviceAddressFeaturesEXT;
// Extension: VK_BASE_VERSION_1_2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkBufferDeviceAddressInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    buffer: VkBuffer = .none,
};
// Extension: VK_KHR_buffer_device_address
pub const VkBufferDeviceAddressInfoKHR = VkBufferDeviceAddressInfo;
// Extension: VK_EXT_buffer_device_address
pub const VkBufferDeviceAddressInfoEXT = VkBufferDeviceAddressInfo;
// Extension: VK_BASE_VERSION_1_2
// Extends: VkBufferCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkBufferOpaqueCaptureAddressCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    opaqueCaptureAddress: u64 = 0,
};
// Extension: VK_KHR_buffer_device_address
pub const VkBufferOpaqueCaptureAddressCreateInfoKHR = VkBufferOpaqueCaptureAddressCreateInfo;
// Extension: VK_EXT_buffer_device_address
// Extends: VkBufferCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkBufferDeviceAddressCreateInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    deviceAddress: u64 = 0,
};
// Extension: VK_EXT_filter_cubic
// Extends: VkPhysicalDeviceImageFormatInfo2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceImageViewImageFormatInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    imageViewType: VkImageViewType,
};
// Extension: VK_EXT_filter_cubic
// Extends: VkImageFormatProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkFilterCubicImageViewImageFormatPropertiesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: The combinations of format, image type (and image view type if provided) can be filtered with VK_FILTER_CUBIC_EXT
    filterCubic: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: The combination of format, image type (and image view type if provided) can be filtered with VK_FILTER_CUBIC_EXT and ReductionMode of Min or Max
    filterCubicMinmax: u32 = 0,
};
// Extension: VK_GRAPHICS_VERSION_1_2
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceImagelessFramebufferFeatures = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    imagelessFramebuffer: u32 = 0,
};
// Extension: VK_KHR_imageless_framebuffer
pub const VkPhysicalDeviceImagelessFramebufferFeaturesKHR = VkPhysicalDeviceImagelessFramebufferFeatures;
// Extension: VK_GRAPHICS_VERSION_1_2
// Extends: VkFramebufferCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkFramebufferAttachmentsCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    attachmentImageInfoCount: u32 = 0,
    // Length member: attachmentImageInfoCount
    // Extern sync: false
    // Optional: false
    pAttachmentImageInfos: ?[*]const VkFramebufferAttachmentImageInfo = null,
};
// Extension: VK_KHR_imageless_framebuffer
pub const VkFramebufferAttachmentsCreateInfoKHR = VkFramebufferAttachmentsCreateInfo;
// Extension: VK_GRAPHICS_VERSION_1_2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkFramebufferAttachmentImageInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    // Comment: Image creation flags
    flags: VkImageCreateFlags = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Image usage flags
    usage: VkImageUsageFlags = .{},
    // Extern sync: false
    // Optional: false
    width: u32 = 0,
    // Extern sync: false
    // Optional: false
    height: u32 = 0,
    // Extern sync: false
    // Optional: false
    layerCount: u32 = 0,
    // Extern sync: false
    // Optional: true
    viewFormatCount: u32 = 0,
    // Length member: viewFormatCount
    // Extern sync: false
    // Optional: false
    pViewFormats: ?[*]const VkFormat = null,
};
// Extension: VK_KHR_imageless_framebuffer
pub const VkFramebufferAttachmentImageInfoKHR = VkFramebufferAttachmentImageInfo;
// Extension: VK_GRAPHICS_VERSION_1_2
// Extends: VkRenderPassBeginInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkRenderPassAttachmentBeginInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    attachmentCount: u32 = 0,
    // Length member: attachmentCount
    // Extern sync: false
    // Optional: false
    pAttachments: ?[*]const VkImageView = null,
};
// Extension: VK_KHR_imageless_framebuffer
pub const VkRenderPassAttachmentBeginInfoKHR = VkRenderPassAttachmentBeginInfo;
// Extension: VK_BASE_VERSION_1_3
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceTextureCompressionASTCHDRFeatures = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    textureCompressionASTC_HDR: u32 = 0,
};
// Extension: VK_EXT_texture_compression_astc_hdr
pub const VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT = VkPhysicalDeviceTextureCompressionASTCHDRFeatures;
// Extension: VK_NV_cooperative_matrix
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceCooperativeMatrixFeaturesNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Feature link: cooperativeMatrixNV
    cooperativeMatrix: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Feature link: cooperativeMatrixRobustBufferAccessNV
    cooperativeMatrixRobustBufferAccess: u32 = 0,
};
// Extension: VK_NV_cooperative_matrix
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceCooperativeMatrixPropertiesNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    cooperativeMatrixSupportedStages: VkShaderStageFlags = .{},
};
// Extension: VK_NV_cooperative_matrix
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkCooperativeMatrixPropertiesNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    MSize: u32 = 0,
    // Extern sync: false
    // Optional: false
    NSize: u32 = 0,
    // Extern sync: false
    // Optional: false
    KSize: u32 = 0,
    // Extern sync: false
    // Optional: false
    AType: VkComponentTypeKHR,
    // Extern sync: false
    // Optional: false
    BType: VkComponentTypeKHR,
    // Extern sync: false
    // Optional: false
    CType: VkComponentTypeKHR,
    // Extern sync: false
    // Optional: false
    DType: VkComponentTypeKHR,
    // Extern sync: false
    // Optional: false
    scope: VkScopeKHR,
};
// Extension: VK_EXT_ycbcr_image_arrays
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceYcbcrImageArraysFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    ycbcrImageArrays: u32 = 0,
};
// Extension: VK_NVX_image_view_handle
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImageViewHandleInfoNVX = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_IMAGE_VIEW_HANDLE_INFO_NVX,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    imageView: VkImageView = .none,
    // Extern sync: false
    // Optional: false
    descriptorType: VkDescriptorType,
    // Extern sync: false
    // Optional: true
    sampler: VkSampler = .none,
};
// Extension: VK_NVX_image_view_handle
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkImageViewAddressPropertiesNVX = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_IMAGE_VIEW_ADDRESS_PROPERTIES_NVX,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    deviceAddress: u64 = 0,
    // Extern sync: false
    // Optional: false
    size: u64 = 0,
};
// Extension: VK_GGP_frame_token
// Extends: VkPresentInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPresentFrameTokenGGP = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
};
// Extension: VK_COMPUTE_VERSION_1_3
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPipelineCreationFeedback = extern struct {
    // Extern sync: false
    // Optional: false
    flags: VkPipelineCreationFeedbackFlags = .{},
    // Extern sync: false
    // Optional: false
    duration: u64 = 0,
};
// Extension: VK_EXT_pipeline_creation_feedback
pub const VkPipelineCreationFeedbackEXT = VkPipelineCreationFeedback;
// Extension: VK_COMPUTE_VERSION_1_3
// Extends: VkGraphicsPipelineCreateInfo,VkComputePipelineCreateInfo,VkRayTracingPipelineCreateInfoNV,VkRayTracingPipelineCreateInfoKHR,VkExecutionGraphPipelineCreateInfoAMDX,VkDataGraphPipelineCreateInfoARM
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineCreationFeedbackCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: Output pipeline creation feedback.
    pPipelineCreationFeedback: ?*VkPipelineCreationFeedback = null,
    // Extern sync: false
    // Optional: true
    pipelineStageCreationFeedbackCount: u32 = 0,
    // Length member: pipelineStageCreationFeedbackCount
    // Extern sync: false
    // Optional: false
    // Comment: One entry for each shader stage specified in the parent Vk*PipelineCreateInfo struct
    pPipelineStageCreationFeedbacks: ?[*]VkPipelineCreationFeedback = null,
};
// Extension: VK_EXT_pipeline_creation_feedback
pub const VkPipelineCreationFeedbackCreateInfoEXT = VkPipelineCreationFeedbackCreateInfo;
// Extension: VK_EXT_full_screen_exclusive
// Extends: VkPhysicalDeviceSurfaceInfo2KHR,VkSwapchainCreateInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSurfaceFullScreenExclusiveInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    fullScreenExclusive: VkFullScreenExclusiveEXT,
};
// Extension: VK_EXT_full_screen_exclusive
// Extends: VkPhysicalDeviceSurfaceInfo2KHR,VkSwapchainCreateInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSurfaceFullScreenExclusiveWin32InfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
};
// Extension: VK_EXT_full_screen_exclusive
// Extends: VkSurfaceCapabilities2KHR
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkSurfaceCapabilitiesFullScreenExclusiveEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    fullScreenExclusiveSupported: u32 = 0,
};
// Extension: VK_NV_present_barrier
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDevicePresentBarrierFeaturesNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_BARRIER_FEATURES_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    presentBarrier: u32 = 0,
};
// Extension: VK_NV_present_barrier
// Extends: VkSurfaceCapabilities2KHR
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkSurfaceCapabilitiesPresentBarrierNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_BARRIER_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    presentBarrierSupported: u32 = 0,
};
// Extension: VK_NV_present_barrier
// Extends: VkSwapchainCreateInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSwapchainPresentBarrierCreateInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_BARRIER_CREATE_INFO_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    presentBarrierEnable: u32 = 0,
};
// Extension: VK_KHR_performance_query
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDevicePerformanceQueryFeaturesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: performance counters supported in query pools
    performanceCounterQueryPools: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: performance counters from multiple query pools can be accessed in the same primary command buffer
    performanceCounterMultipleQueryPools: u32 = 0,
};
// Extension: VK_KHR_performance_query
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDevicePerformanceQueryPropertiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: Flag to specify whether performance queries are allowed to be used in vkCmdCopyQueryPoolResults
    allowCommandBufferQueryCopies: u32 = 0,
};
// Extension: VK_KHR_performance_query
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPerformanceCounterKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    unit: VkPerformanceCounterUnitKHR,
    // Extern sync: false
    // Optional: false
    scope: VkPerformanceCounterScopeKHR,
    // Extern sync: false
    // Optional: false
    storage: VkPerformanceCounterStorageKHR,
    // Extern sync: false
    // Optional: false
    uuid: [VK_UUID_SIZE]u8 = @import("std").mem.zeroes([VK_UUID_SIZE]u8),
};
// Extension: VK_KHR_performance_query
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPerformanceCounterDescriptionKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_DESCRIPTION_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkPerformanceCounterDescriptionFlagsKHR = .{},
    // Length member: null-terminated
    // Extern sync: false
    // Optional: false
    name: [VK_MAX_DESCRIPTION_SIZE]u8 = @import("std").mem.zeroes([VK_MAX_DESCRIPTION_SIZE]u8),
    // Length member: null-terminated
    // Extern sync: false
    // Optional: false
    category: [VK_MAX_DESCRIPTION_SIZE]u8 = @import("std").mem.zeroes([VK_MAX_DESCRIPTION_SIZE]u8),
    // Length member: null-terminated
    // Extern sync: false
    // Optional: false
    description: [VK_MAX_DESCRIPTION_SIZE]u8 = @import("std").mem.zeroes([VK_MAX_DESCRIPTION_SIZE]u8),
};
// Extension: VK_KHR_performance_query
// Extends: VkQueryPoolCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkQueryPoolPerformanceCreateInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    queueFamilyIndex: u32 = 0,
    // Extern sync: false
    // Optional: false
    counterIndexCount: u32 = 0,
    // Length member: counterIndexCount
    // Extern sync: false
    // Optional: false
    pCounterIndices: ?[*]const u32 = null,
};
// Extension: VK_KHR_performance_query
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkAcquireProfilingLockInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_ACQUIRE_PROFILING_LOCK_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    // Comment: Acquire profiling lock flags
    flags: VkAcquireProfilingLockFlagsKHR = .{},
    // Extern sync: false
    // Optional: false
    timeout: u64 = 0,
};
// Extension: VK_KHR_performance_query
// Extends: VkSubmitInfo,VkSubmitInfo2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPerformanceQuerySubmitInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: Index for which counter pass to submit
    counterPassIndex: u32 = 0,
};
// Extension: VK_KHR_performance_query
// Extends: VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: true
pub const VkPerformanceQueryReservationInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_RESERVATION_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: Maximum number of VK_QUERY_TYPE_PERFORMANCE_QUERY_KHR queries in a query pool
    maxPerformanceQueriesPerPool: u32 = 0,
};
// Extension: VK_EXT_headless_surface
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkHeadlessSurfaceCreateInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkHeadlessSurfaceCreateFlagsEXT = .{},
};
// Extension: VK_NV_coverage_reduction_mode
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceCoverageReductionModeFeaturesNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    coverageReductionMode: u32 = 0,
};
// Extension: VK_NV_coverage_reduction_mode
// Extends: VkPipelineMultisampleStateCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineCoverageReductionStateCreateInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkPipelineCoverageReductionStateCreateFlagsNV = .{},
    // Extern sync: false
    // Optional: false
    coverageReductionMode: VkCoverageReductionModeNV,
};
// Extension: VK_NV_coverage_reduction_mode
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkFramebufferMixedSamplesCombinationNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    coverageReductionMode: VkCoverageReductionModeNV,
    // Extern sync: false
    // Optional: false
    rasterizationSamples: VkSampleCountFlags = .{},
    // Extern sync: false
    // Optional: false
    depthStencilSamples: VkSampleCountFlags = .{},
    // Extern sync: false
    // Optional: false
    colorSamples: VkSampleCountFlags = .{},
};
// Extension: VK_INTEL_shader_integer_functions2
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    shaderIntegerFunctions2: u32 = 0,
};
// Extension: VK_INTEL_performance_query
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPerformanceValueINTEL = extern struct {
    // Extern sync: false
    // Optional: false
    type: VkPerformanceValueTypeINTEL,
    // Extern sync: false
    // Optional: false
    // Selector member: type (What union field is valid)
    data: VkPerformanceValueDataINTEL,
};
// Extension: VK_INTEL_performance_query
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkInitializePerformanceApiInfoINTEL = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_INITIALIZE_PERFORMANCE_API_INFO_INTEL,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    pUserData: ?*anyopaque = null,
};
// Extension: VK_INTEL_performance_query
// Extends: VkQueryPoolCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkQueryPoolPerformanceQueryCreateInfoINTEL = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    performanceCountersSampling: VkQueryPoolSamplingModeINTEL,
};
// Extension: VK_INTEL_performance_query
pub const VkQueryPoolCreateInfoINTEL = VkQueryPoolPerformanceQueryCreateInfoINTEL;
// Extension: VK_INTEL_performance_query
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPerformanceMarkerInfoINTEL = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PERFORMANCE_MARKER_INFO_INTEL,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    marker: u64 = 0,
};
// Extension: VK_INTEL_performance_query
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPerformanceStreamMarkerInfoINTEL = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PERFORMANCE_STREAM_MARKER_INFO_INTEL,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    marker: u32 = 0,
};
// Extension: VK_INTEL_performance_query
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPerformanceOverrideInfoINTEL = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PERFORMANCE_OVERRIDE_INFO_INTEL,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    type: VkPerformanceOverrideTypeINTEL,
    // Extern sync: false
    // Optional: false
    enable: u32 = 0,
    // Extern sync: false
    // Optional: false
    parameter: u64 = 0,
};
// Extension: VK_INTEL_performance_query
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPerformanceConfigurationAcquireInfoINTEL = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    type: VkPerformanceConfigurationTypeINTEL,
};
// Extension: VK_KHR_shader_clock
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceShaderClockFeaturesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    shaderSubgroupClock: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderDeviceClock: u32 = 0,
};
// Extension: VK_BASE_VERSION_1_4
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceIndexTypeUint8Features = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    indexTypeUint8: u32 = 0,
};
// Extension: VK_KHR_index_type_uint8
pub const VkPhysicalDeviceIndexTypeUint8FeaturesKHR = VkPhysicalDeviceIndexTypeUint8Features;
// Extension: VK_EXT_index_type_uint8
pub const VkPhysicalDeviceIndexTypeUint8FeaturesEXT = VkPhysicalDeviceIndexTypeUint8Features;
// Extension: VK_NV_shader_sm_builtins
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceShaderSMBuiltinsPropertiesNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    shaderSMCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderWarpsPerSM: u32 = 0,
};
// Extension: VK_NV_shader_sm_builtins
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceShaderSMBuiltinsFeaturesNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    shaderSMBuiltins: u32 = 0,
};
// Extension: VK_EXT_fragment_shader_interlock
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT,
    // Extern sync: false
    // Optional: true
    // Comment: Pointer to next structure
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    fragmentShaderSampleInterlock: u32 = 0,
    // Extern sync: false
    // Optional: false
    fragmentShaderPixelInterlock: u32 = 0,
    // Extern sync: false
    // Optional: false
    fragmentShaderShadingRateInterlock: u32 = 0,
};
// Extension: VK_GRAPHICS_VERSION_1_2
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    separateDepthStencilLayouts: u32 = 0,
};
// Extension: VK_KHR_separate_depth_stencil_layouts
pub const VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR = VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures;
// Extension: VK_GRAPHICS_VERSION_1_2
// Extends: VkAttachmentReference2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkAttachmentReferenceStencilLayout = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    stencilLayout: VkImageLayout,
};
// Extension: VK_EXT_primitive_topology_list_restart
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    primitiveTopologyListRestart: u32 = 0,
    // Extern sync: false
    // Optional: false
    primitiveTopologyPatchListRestart: u32 = 0,
};
// Extension: VK_KHR_separate_depth_stencil_layouts
pub const VkAttachmentReferenceStencilLayoutKHR = VkAttachmentReferenceStencilLayout;
// Extension: VK_GRAPHICS_VERSION_1_2
// Extends: VkAttachmentDescription2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkAttachmentDescriptionStencilLayout = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    stencilInitialLayout: VkImageLayout,
    // Extern sync: false
    // Optional: false
    stencilFinalLayout: VkImageLayout,
};
// Extension: VK_KHR_separate_depth_stencil_layouts
pub const VkAttachmentDescriptionStencilLayoutKHR = VkAttachmentDescriptionStencilLayout;
// Extension: VK_KHR_pipeline_executable_properties
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    pipelineExecutableInfo: u32 = 0,
};
// Extension: VK_KHR_pipeline_executable_properties
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    pipeline: VkPipeline = .none,
};
// Extension: VK_EXT_pipeline_properties
pub const VkPipelineInfoEXT = VkPipelineInfoKHR;
// Extension: VK_KHR_pipeline_executable_properties
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPipelineExecutablePropertiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_PROPERTIES_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    stages: VkShaderStageFlags = .{},
    // Length member: null-terminated
    // Extern sync: false
    // Optional: false
    name: [VK_MAX_DESCRIPTION_SIZE]u8 = @import("std").mem.zeroes([VK_MAX_DESCRIPTION_SIZE]u8),
    // Length member: null-terminated
    // Extern sync: false
    // Optional: false
    description: [VK_MAX_DESCRIPTION_SIZE]u8 = @import("std").mem.zeroes([VK_MAX_DESCRIPTION_SIZE]u8),
    // Extern sync: false
    // Optional: false
    subgroupSize: u32 = 0,
};
// Extension: VK_KHR_pipeline_executable_properties
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineExecutableInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    pipeline: VkPipeline = .none,
    // Extern sync: false
    // Optional: false
    executableIndex: u32 = 0,
};
// Extension: VK_KHR_pipeline_executable_properties
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPipelineExecutableStatisticKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_STATISTIC_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Length member: null-terminated
    // Extern sync: false
    // Optional: false
    name: [VK_MAX_DESCRIPTION_SIZE]u8 = @import("std").mem.zeroes([VK_MAX_DESCRIPTION_SIZE]u8),
    // Length member: null-terminated
    // Extern sync: false
    // Optional: false
    description: [VK_MAX_DESCRIPTION_SIZE]u8 = @import("std").mem.zeroes([VK_MAX_DESCRIPTION_SIZE]u8),
    // Extern sync: false
    // Optional: false
    format: VkPipelineExecutableStatisticFormatKHR,
    // Extern sync: false
    // Optional: false
    // Selector member: format (What union field is valid)
    value: VkPipelineExecutableStatisticValueKHR,
};
// Extension: VK_KHR_pipeline_executable_properties
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPipelineExecutableInternalRepresentationKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Length member: null-terminated
    // Extern sync: false
    // Optional: false
    name: [VK_MAX_DESCRIPTION_SIZE]u8 = @import("std").mem.zeroes([VK_MAX_DESCRIPTION_SIZE]u8),
    // Length member: null-terminated
    // Extern sync: false
    // Optional: false
    description: [VK_MAX_DESCRIPTION_SIZE]u8 = @import("std").mem.zeroes([VK_MAX_DESCRIPTION_SIZE]u8),
    // Extern sync: false
    // Optional: false
    isText: u32 = 0,
    // Extern sync: false
    // Optional: false
    dataSize: u64 = 0,
    // Length member: dataSize
    // Extern sync: false
    // Optional: true
    pData: ?[*]anyopaque = null,
};
// Extension: VK_COMPUTE_VERSION_1_3
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    shaderDemoteToHelperInvocation: u32 = 0,
};
// Extension: VK_EXT_shader_demote_to_helper_invocation
pub const VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT = VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures;
// Extension: VK_EXT_texel_buffer_alignment
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    texelBufferAlignment: u32 = 0,
};
// Extension: VK_COMPUTE_VERSION_1_3
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceTexelBufferAlignmentProperties = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    storageTexelBufferOffsetAlignmentBytes: u64 = 0,
    // Extern sync: false
    // Optional: false
    storageTexelBufferOffsetSingleTexelAlignment: u32 = 0,
    // Extern sync: false
    // Optional: false
    uniformTexelBufferOffsetAlignmentBytes: u64 = 0,
    // Extern sync: false
    // Optional: false
    uniformTexelBufferOffsetSingleTexelAlignment: u32 = 0,
};
// Extension: VK_EXT_texel_buffer_alignment
pub const VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT = VkPhysicalDeviceTexelBufferAlignmentProperties;
// Extension: VK_COMPUTE_VERSION_1_3
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceSubgroupSizeControlFeatures = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    subgroupSizeControl: u32 = 0,
    // Extern sync: false
    // Optional: false
    computeFullSubgroups: u32 = 0,
};
// Extension: VK_EXT_subgroup_size_control
pub const VkPhysicalDeviceSubgroupSizeControlFeaturesEXT = VkPhysicalDeviceSubgroupSizeControlFeatures;
// Extension: VK_COMPUTE_VERSION_1_3
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceSubgroupSizeControlProperties = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: The minimum subgroup size supported by this device
    minSubgroupSize: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: The maximum subgroup size supported by this device
    maxSubgroupSize: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: The maximum number of subgroups supported in a workgroup
    maxComputeWorkgroupSubgroups: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: The shader stages that support specifying a subgroup size
    requiredSubgroupSizeStages: VkShaderStageFlags = .{},
};
// Extension: VK_EXT_subgroup_size_control
pub const VkPhysicalDeviceSubgroupSizeControlPropertiesEXT = VkPhysicalDeviceSubgroupSizeControlProperties;
// Extension: VK_COMPUTE_VERSION_1_3
// Extends: VkPipelineShaderStageCreateInfo,VkShaderCreateInfoEXT
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineShaderStageRequiredSubgroupSizeCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    requiredSubgroupSize: u32 = 0,
};
// Extension: VK_EXT_subgroup_size_control
pub const VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT = VkPipelineShaderStageRequiredSubgroupSizeCreateInfo;
// Extension: VK_EXT_shader_object
pub const VkShaderRequiredSubgroupSizeCreateInfoEXT = VkPipelineShaderStageRequiredSubgroupSizeCreateInfo;
// Extension: VK_HUAWEI_subpass_shading
// Extends: VkComputePipelineCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSubpassShadingPipelineCreateInfoHUAWEI = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_SUBPASS_SHADING_PIPELINE_CREATE_INFO_HUAWEI,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    renderPass: VkRenderPass = .none,
    // Extern sync: false
    // Optional: false
    subpass: u32 = 0,
};
// Extension: VK_HUAWEI_subpass_shading
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceSubpassShadingPropertiesHUAWEI = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_PROPERTIES_HUAWEI,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    maxSubpassShadingWorkgroupSizeAspectRatio: u32 = 0,
};
// Extension: VK_HUAWEI_cluster_culling_shader
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_PROPERTIES_HUAWEI,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    maxWorkGroupCount: [3]u32 = @import("std").mem.zeroes([3]u32),
    // Extern sync: false
    // Optional: false
    maxWorkGroupSize: [3]u32 = @import("std").mem.zeroes([3]u32),
    // Extern sync: false
    // Optional: false
    maxOutputClusterCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    indirectBufferOffsetAlignment: u64 = 0,
};
// Extension: VK_BASE_VERSION_1_2
// Extends: VkMemoryAllocateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkMemoryOpaqueCaptureAddressAllocateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    opaqueCaptureAddress: u64 = 0,
};
// Extension: VK_KHR_buffer_device_address
pub const VkMemoryOpaqueCaptureAddressAllocateInfoKHR = VkMemoryOpaqueCaptureAddressAllocateInfo;
// Extension: VK_BASE_VERSION_1_2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDeviceMemoryOpaqueCaptureAddressInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    memory: VkDeviceMemory = .none,
};
// Extension: VK_KHR_buffer_device_address
pub const VkDeviceMemoryOpaqueCaptureAddressInfoKHR = VkDeviceMemoryOpaqueCaptureAddressInfo;
// Extension: VK_GRAPHICS_VERSION_1_4
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceLineRasterizationFeatures = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    rectangularLines: u32 = 0,
    // Extern sync: false
    // Optional: false
    bresenhamLines: u32 = 0,
    // Extern sync: false
    // Optional: false
    smoothLines: u32 = 0,
    // Extern sync: false
    // Optional: false
    stippledRectangularLines: u32 = 0,
    // Extern sync: false
    // Optional: false
    stippledBresenhamLines: u32 = 0,
    // Extern sync: false
    // Optional: false
    stippledSmoothLines: u32 = 0,
};
// Extension: VK_KHR_line_rasterization
pub const VkPhysicalDeviceLineRasterizationFeaturesKHR = VkPhysicalDeviceLineRasterizationFeatures;
// Extension: VK_EXT_line_rasterization
pub const VkPhysicalDeviceLineRasterizationFeaturesEXT = VkPhysicalDeviceLineRasterizationFeatures;
// Extension: VK_GRAPHICS_VERSION_1_4
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceLineRasterizationProperties = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    lineSubPixelPrecisionBits: u32 = 0,
};
// Extension: VK_KHR_line_rasterization
pub const VkPhysicalDeviceLineRasterizationPropertiesKHR = VkPhysicalDeviceLineRasterizationProperties;
// Extension: VK_EXT_line_rasterization
pub const VkPhysicalDeviceLineRasterizationPropertiesEXT = VkPhysicalDeviceLineRasterizationProperties;
// Extension: VK_GRAPHICS_VERSION_1_4
// Extends: VkPipelineRasterizationStateCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineRasterizationLineStateCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    lineRasterizationMode: VkLineRasterizationMode,
    // Extern sync: false
    // Optional: false
    stippledLineEnable: u32 = 0,
    // Extern sync: false
    // Optional: false
    lineStippleFactor: u32 = 0,
    // Extern sync: false
    // Optional: false
};
// Extension: VK_KHR_line_rasterization
pub const VkPipelineRasterizationLineStateCreateInfoKHR = VkPipelineRasterizationLineStateCreateInfo;
// Extension: VK_EXT_line_rasterization
pub const VkPipelineRasterizationLineStateCreateInfoEXT = VkPipelineRasterizationLineStateCreateInfo;
// Extension: VK_COMPUTE_VERSION_1_3
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDevicePipelineCreationCacheControlFeatures = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    pipelineCreationCacheControl: u32 = 0,
};
// Extension: VK_EXT_pipeline_creation_cache_control
pub const VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT = VkPhysicalDevicePipelineCreationCacheControlFeatures;
// Extension: VK_BASE_VERSION_1_2
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceVulkan11Features = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: 16-bit integer/floating-point variables supported in BufferBlock
    storageBuffer16BitAccess: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: 16-bit integer/floating-point variables supported in BufferBlock and Block
    uniformAndStorageBuffer16BitAccess: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: 16-bit integer/floating-point variables supported in PushConstant
    storagePushConstant16: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: 16-bit integer/floating-point variables supported in shader inputs and outputs
    storageInputOutput16: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Multiple views in a render pass
    multiview: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Multiple views in a render pass w/ geometry shader
    multiviewGeometryShader: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Multiple views in a render pass w/ tessellation shader
    multiviewTessellationShader: u32 = 0,
    // Extern sync: false
    // Optional: false
    variablePointersStorageBuffer: u32 = 0,
    // Extern sync: false
    // Optional: false
    variablePointers: u32 = 0,
    // Extern sync: false
    // Optional: false
    protectedMemory: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Sampler color conversion supported
    samplerYcbcrConversion: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderDrawParameters: u32 = 0,
};
// Extension: VK_BASE_VERSION_1_2
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceVulkan11Properties = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    deviceUUID: [VK_UUID_SIZE]u8 = @import("std").mem.zeroes([VK_UUID_SIZE]u8),
    // Extern sync: false
    // Optional: false
    driverUUID: [VK_UUID_SIZE]u8 = @import("std").mem.zeroes([VK_UUID_SIZE]u8),
    // Extern sync: false
    // Optional: false
    deviceLUID: [VK_LUID_SIZE]u8 = @import("std").mem.zeroes([VK_LUID_SIZE]u8),
    // Extern sync: false
    // Optional: false
    deviceNodeMask: u32 = 0,
    // Extern sync: false
    // Optional: false
    deviceLUIDValid: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: The size of a subgroup for this queue.
    subgroupSize: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Bitfield of what shader stages support subgroup operations
    subgroupSupportedStages: VkShaderStageFlags = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Bitfield of what subgroup operations are supported.
    subgroupSupportedOperations: VkSubgroupFeatureFlags = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Flag to specify whether quad operations are available in all stages.
    subgroupQuadOperationsInAllStages: u32 = 0,
    // Extern sync: false
    // Optional: false
    pointClippingBehavior: VkPointClippingBehavior,
    // Extern sync: false
    // Optional: false
    // Comment: max number of views in a subpass
    maxMultiviewViewCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: max instance index for a draw in a multiview subpass
    maxMultiviewInstanceIndex: u32 = 0,
    // Extern sync: false
    // Optional: false
    protectedNoFault: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxPerSetDescriptors: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxMemoryAllocationSize: u64 = 0,
};
// Extension: VK_BASE_VERSION_1_2
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceVulkan12Features = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    samplerMirrorClampToEdge: u32 = 0,
    // Extern sync: false
    // Optional: false
    drawIndirectCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: 8-bit integer variables supported in StorageBuffer
    storageBuffer8BitAccess: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: 8-bit integer variables supported in StorageBuffer and Uniform
    uniformAndStorageBuffer8BitAccess: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: 8-bit integer variables supported in PushConstant
    storagePushConstant8: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderBufferInt64Atomics: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderSharedInt64Atomics: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: 16-bit floats (halfs) in shaders
    shaderFloat16: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: 8-bit integers in shaders
    shaderInt8: u32 = 0,
    // Extern sync: false
    // Optional: false
    descriptorIndexing: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderInputAttachmentArrayDynamicIndexing: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderUniformTexelBufferArrayDynamicIndexing: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderStorageTexelBufferArrayDynamicIndexing: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderUniformBufferArrayNonUniformIndexing: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderSampledImageArrayNonUniformIndexing: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderStorageBufferArrayNonUniformIndexing: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderStorageImageArrayNonUniformIndexing: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderInputAttachmentArrayNonUniformIndexing: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderUniformTexelBufferArrayNonUniformIndexing: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderStorageTexelBufferArrayNonUniformIndexing: u32 = 0,
    // Extern sync: false
    // Optional: false
    descriptorBindingUniformBufferUpdateAfterBind: u32 = 0,
    // Extern sync: false
    // Optional: false
    descriptorBindingSampledImageUpdateAfterBind: u32 = 0,
    // Extern sync: false
    // Optional: false
    descriptorBindingStorageImageUpdateAfterBind: u32 = 0,
    // Extern sync: false
    // Optional: false
    descriptorBindingStorageBufferUpdateAfterBind: u32 = 0,
    // Extern sync: false
    // Optional: false
    descriptorBindingUniformTexelBufferUpdateAfterBind: u32 = 0,
    // Extern sync: false
    // Optional: false
    descriptorBindingStorageTexelBufferUpdateAfterBind: u32 = 0,
    // Extern sync: false
    // Optional: false
    descriptorBindingUpdateUnusedWhilePending: u32 = 0,
    // Extern sync: false
    // Optional: false
    descriptorBindingPartiallyBound: u32 = 0,
    // Extern sync: false
    // Optional: false
    descriptorBindingVariableDescriptorCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    runtimeDescriptorArray: u32 = 0,
    // Extern sync: false
    // Optional: false
    samplerFilterMinmax: u32 = 0,
    // Extern sync: false
    // Optional: false
    scalarBlockLayout: u32 = 0,
    // Extern sync: false
    // Optional: false
    imagelessFramebuffer: u32 = 0,
    // Extern sync: false
    // Optional: false
    uniformBufferStandardLayout: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderSubgroupExtendedTypes: u32 = 0,
    // Extern sync: false
    // Optional: false
    separateDepthStencilLayouts: u32 = 0,
    // Extern sync: false
    // Optional: false
    hostQueryReset: u32 = 0,
    // Extern sync: false
    // Optional: false
    timelineSemaphore: u32 = 0,
    // Extern sync: false
    // Optional: false
    bufferDeviceAddress: u32 = 0,
    // Extern sync: false
    // Optional: false
    bufferDeviceAddressCaptureReplay: u32 = 0,
    // Extern sync: false
    // Optional: false
    bufferDeviceAddressMultiDevice: u32 = 0,
    // Extern sync: false
    // Optional: false
    vulkanMemoryModel: u32 = 0,
    // Extern sync: false
    // Optional: false
    vulkanMemoryModelDeviceScope: u32 = 0,
    // Extern sync: false
    // Optional: false
    vulkanMemoryModelAvailabilityVisibilityChains: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderOutputViewportIndex: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderOutputLayer: u32 = 0,
    // Extern sync: false
    // Optional: false
    subgroupBroadcastDynamicId: u32 = 0,
};
// Extension: VK_BASE_VERSION_1_2
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceVulkan12Properties = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    driverID: VkDriverId,
    // Length member: null-terminated
    // Extern sync: false
    // Optional: false
    driverName: [VK_MAX_DRIVER_NAME_SIZE]u8 = @import("std").mem.zeroes([VK_MAX_DRIVER_NAME_SIZE]u8),
    // Length member: null-terminated
    // Extern sync: false
    // Optional: false
    driverInfo: [VK_MAX_DRIVER_INFO_SIZE]u8 = @import("std").mem.zeroes([VK_MAX_DRIVER_INFO_SIZE]u8),
    // Extern sync: false
    // Optional: false
    conformanceVersion: VkConformanceVersion = .{},
    // Extern sync: false
    // Optional: false
    denormBehaviorIndependence: VkShaderFloatControlsIndependence,
    // Extern sync: false
    // Optional: false
    roundingModeIndependence: VkShaderFloatControlsIndependence,
    // Extern sync: false
    // Optional: false
    // Comment: An implementation can preserve signed zero, nan, inf
    shaderSignedZeroInfNanPreserveFloat16: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: An implementation can preserve signed zero, nan, inf
    shaderSignedZeroInfNanPreserveFloat32: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: An implementation can preserve signed zero, nan, inf
    shaderSignedZeroInfNanPreserveFloat64: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: An implementation can preserve  denormals
    shaderDenormPreserveFloat16: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: An implementation can preserve  denormals
    shaderDenormPreserveFloat32: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: An implementation can preserve  denormals
    shaderDenormPreserveFloat64: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: An implementation can flush to zero  denormals
    shaderDenormFlushToZeroFloat16: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: An implementation can flush to zero  denormals
    shaderDenormFlushToZeroFloat32: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: An implementation can flush to zero  denormals
    shaderDenormFlushToZeroFloat64: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: An implementation can support RTE
    shaderRoundingModeRTEFloat16: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: An implementation can support RTE
    shaderRoundingModeRTEFloat32: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: An implementation can support RTE
    shaderRoundingModeRTEFloat64: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: An implementation can support RTZ
    shaderRoundingModeRTZFloat16: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: An implementation can support RTZ
    shaderRoundingModeRTZFloat32: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: An implementation can support RTZ
    shaderRoundingModeRTZFloat64: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxUpdateAfterBindDescriptorsInAllPools: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderUniformBufferArrayNonUniformIndexingNative: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderSampledImageArrayNonUniformIndexingNative: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderStorageBufferArrayNonUniformIndexingNative: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderStorageImageArrayNonUniformIndexingNative: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderInputAttachmentArrayNonUniformIndexingNative: u32 = 0,
    // Extern sync: false
    // Optional: false
    robustBufferAccessUpdateAfterBind: u32 = 0,
    // Extern sync: false
    // Optional: false
    quadDivergentImplicitLod: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxPerStageDescriptorUpdateAfterBindSamplers: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxPerStageDescriptorUpdateAfterBindUniformBuffers: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxPerStageDescriptorUpdateAfterBindStorageBuffers: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxPerStageDescriptorUpdateAfterBindSampledImages: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxPerStageDescriptorUpdateAfterBindStorageImages: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxPerStageDescriptorUpdateAfterBindInputAttachments: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxPerStageUpdateAfterBindResources: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxDescriptorSetUpdateAfterBindSamplers: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxDescriptorSetUpdateAfterBindUniformBuffers: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxDescriptorSetUpdateAfterBindUniformBuffersDynamic: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxDescriptorSetUpdateAfterBindStorageBuffers: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxDescriptorSetUpdateAfterBindStorageBuffersDynamic: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxDescriptorSetUpdateAfterBindSampledImages: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxDescriptorSetUpdateAfterBindStorageImages: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxDescriptorSetUpdateAfterBindInputAttachments: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: supported depth resolve modes
    supportedDepthResolveModes: VkResolveModeFlags = .{},
    // Extern sync: false
    // Optional: false
    // Comment: supported stencil resolve modes
    supportedStencilResolveModes: VkResolveModeFlags = .{},
    // Extern sync: false
    // Optional: false
    // Comment: depth and stencil resolve modes can be set independently if one of them is none
    independentResolveNone: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: depth and stencil resolve modes can be set independently
    independentResolve: u32 = 0,
    // Extern sync: false
    // Optional: false
    filterMinmaxSingleComponentFormats: u32 = 0,
    // Extern sync: false
    // Optional: false
    filterMinmaxImageComponentMapping: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxTimelineSemaphoreValueDifference: u64 = 0,
    // Extern sync: false
    // Optional: true
    framebufferIntegerColorSampleCounts: VkSampleCountFlags = .{},
};
// Extension: VK_BASE_VERSION_1_3
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceVulkan13Features = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    robustImageAccess: u32 = 0,
    // Extern sync: false
    // Optional: false
    inlineUniformBlock: u32 = 0,
    // Extern sync: false
    // Optional: false
    descriptorBindingInlineUniformBlockUpdateAfterBind: u32 = 0,
    // Extern sync: false
    // Optional: false
    pipelineCreationCacheControl: u32 = 0,
    // Extern sync: false
    // Optional: false
    privateData: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderDemoteToHelperInvocation: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderTerminateInvocation: u32 = 0,
    // Extern sync: false
    // Optional: false
    subgroupSizeControl: u32 = 0,
    // Extern sync: false
    // Optional: false
    computeFullSubgroups: u32 = 0,
    // Extern sync: false
    // Optional: false
    synchronization2: u32 = 0,
    // Extern sync: false
    // Optional: false
    textureCompressionASTC_HDR: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderZeroInitializeWorkgroupMemory: u32 = 0,
    // Extern sync: false
    // Optional: false
    dynamicRendering: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderIntegerDotProduct: u32 = 0,
    // Extern sync: false
    // Optional: false
    maintenance4: u32 = 0,
};
// Extension: VK_BASE_VERSION_1_3
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceVulkan13Properties = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: The minimum subgroup size supported by this device
    minSubgroupSize: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: The maximum subgroup size supported by this device
    maxSubgroupSize: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: The maximum number of subgroups supported in a workgroup
    maxComputeWorkgroupSubgroups: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: The shader stages that support specifying a subgroup size
    requiredSubgroupSizeStages: VkShaderStageFlags = .{},
    // Extern sync: false
    // Optional: false
    maxInlineUniformBlockSize: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxPerStageDescriptorInlineUniformBlocks: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxDescriptorSetInlineUniformBlocks: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxDescriptorSetUpdateAfterBindInlineUniformBlocks: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxInlineUniformTotalSize: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProduct8BitUnsignedAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProduct8BitSignedAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProduct8BitMixedSignednessAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProduct4x8BitPackedUnsignedAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProduct4x8BitPackedSignedAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProduct4x8BitPackedMixedSignednessAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProduct16BitUnsignedAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProduct16BitSignedAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProduct16BitMixedSignednessAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProduct32BitUnsignedAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProduct32BitSignedAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProduct32BitMixedSignednessAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProduct64BitUnsignedAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProduct64BitSignedAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProduct64BitMixedSignednessAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProductAccumulatingSaturating8BitUnsignedAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProductAccumulatingSaturating8BitSignedAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProductAccumulatingSaturating16BitUnsignedAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProductAccumulatingSaturating16BitSignedAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProductAccumulatingSaturating32BitUnsignedAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProductAccumulatingSaturating32BitSignedAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProductAccumulatingSaturating64BitUnsignedAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProductAccumulatingSaturating64BitSignedAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    storageTexelBufferOffsetAlignmentBytes: u64 = 0,
    // Extern sync: false
    // Optional: false
    storageTexelBufferOffsetSingleTexelAlignment: u32 = 0,
    // Extern sync: false
    // Optional: false
    uniformTexelBufferOffsetAlignmentBytes: u64 = 0,
    // Extern sync: false
    // Optional: false
    uniformTexelBufferOffsetSingleTexelAlignment: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxBufferSize: u64 = 0,
};
// Extension: VK_BASE_VERSION_1_4
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceVulkan14Features = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_FEATURES,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    globalPriorityQuery: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderSubgroupRotate: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderSubgroupRotateClustered: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderFloatControls2: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderExpectAssume: u32 = 0,
    // Extern sync: false
    // Optional: false
    rectangularLines: u32 = 0,
    // Extern sync: false
    // Optional: false
    bresenhamLines: u32 = 0,
    // Extern sync: false
    // Optional: false
    smoothLines: u32 = 0,
    // Extern sync: false
    // Optional: false
    stippledRectangularLines: u32 = 0,
    // Extern sync: false
    // Optional: false
    stippledBresenhamLines: u32 = 0,
    // Extern sync: false
    // Optional: false
    stippledSmoothLines: u32 = 0,
    // Extern sync: false
    // Optional: false
    vertexAttributeInstanceRateDivisor: u32 = 0,
    // Extern sync: false
    // Optional: false
    vertexAttributeInstanceRateZeroDivisor: u32 = 0,
    // Extern sync: false
    // Optional: false
    indexTypeUint8: u32 = 0,
    // Extern sync: false
    // Optional: false
    dynamicRenderingLocalRead: u32 = 0,
    // Extern sync: false
    // Optional: false
    maintenance5: u32 = 0,
    // Extern sync: false
    // Optional: false
    maintenance6: u32 = 0,
    // Extern sync: false
    // Optional: false
    pipelineProtectedAccess: u32 = 0,
    // Extern sync: false
    // Optional: false
    pipelineRobustness: u32 = 0,
    // Extern sync: false
    // Optional: false
    hostImageCopy: u32 = 0,
    // Extern sync: false
    // Optional: false
    pushDescriptor: u32 = 0,
};
// Extension: VK_BASE_VERSION_1_4
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceVulkan14Properties = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_PROPERTIES,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    lineSubPixelPrecisionBits: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: max value of vertex attribute divisor
    maxVertexAttribDivisor: u32 = 0,
    // Extern sync: false
    // Optional: false
    supportsNonZeroFirstInstance: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxPushDescriptors: u32 = 0,
    // Extern sync: false
    // Optional: false
    dynamicRenderingLocalReadDepthStencilAttachments: u32 = 0,
    // Extern sync: false
    // Optional: false
    dynamicRenderingLocalReadMultisampledAttachments: u32 = 0,
    // Extern sync: false
    // Optional: false
    earlyFragmentMultisampleCoverageAfterSampleCounting: u32 = 0,
    // Extern sync: false
    // Optional: false
    earlyFragmentSampleMaskTestBeforeSampleCounting: u32 = 0,
    // Extern sync: false
    // Optional: false
    depthStencilSwizzleOneSupport: u32 = 0,
    // Extern sync: false
    // Optional: false
    polygonModePointSize: u32 = 0,
    // Extern sync: false
    // Optional: false
    nonStrictSinglePixelWideLinesUseParallelogram: u32 = 0,
    // Extern sync: false
    // Optional: false
    nonStrictWideLinesUseParallelogram: u32 = 0,
    // Extern sync: false
    // Optional: false
    blockTexelViewCompatibleMultipleLayers: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxCombinedImageSamplerDescriptorCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    fragmentShadingRateClampCombinerInputs: u32 = 0,
    // Extern sync: false
    // Optional: false
    defaultRobustnessStorageBuffers: VkPipelineRobustnessBufferBehavior,
    // Extern sync: false
    // Optional: false
    defaultRobustnessUniformBuffers: VkPipelineRobustnessBufferBehavior,
    // Extern sync: false
    // Optional: false
    defaultRobustnessVertexInputs: VkPipelineRobustnessBufferBehavior,
    // Extern sync: false
    // Optional: false
    defaultRobustnessImages: VkPipelineRobustnessImageBehavior,
    // Extern sync: false
    // Optional: true
    copySrcLayoutCount: u32 = 0,
    // Length member: copySrcLayoutCount
    // Extern sync: false
    // Optional: true
    pCopySrcLayouts: ?[*]VkImageLayout = null,
    // Extern sync: false
    // Optional: true
    copyDstLayoutCount: u32 = 0,
    // Length member: copyDstLayoutCount
    // Extern sync: false
    // Optional: true
    pCopyDstLayouts: ?[*]VkImageLayout = null,
    // Extern sync: false
    // Optional: true
    optimalTilingLayoutUUID: [VK_UUID_SIZE]u8 = @import("std").mem.zeroes([VK_UUID_SIZE]u8),
    // Extern sync: false
    // Optional: false
    identicalMemoryTypeRequirements: u32 = 0,
};
// Extension: VK_AMD_pipeline_compiler_control
// Extends: VkGraphicsPipelineCreateInfo,VkComputePipelineCreateInfo,VkExecutionGraphPipelineCreateInfoAMDX
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineCompilerControlCreateInfoAMD = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    compilerControlFlags: VkPipelineCompilerControlFlagsAMD = .{},
};
// Extension: VK_AMD_device_coherent_memory
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceCoherentMemoryFeaturesAMD = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    deviceCoherentMemory: u32 = 0,
};
// Extension: VKSC_VERSION_1_0
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkFaultData = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_FAULT_DATA,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    faultLevel: VkFaultLevel,
    // Extern sync: false
    // Optional: false
    faultType: VkFaultType,
};
// Extension: VKSC_VERSION_1_0
// Extends: VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkFaultCallbackInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_FAULT_CALLBACK_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    faultCount: u32 = 0,
    // Length member: faultCount
    // Extern sync: false
    // Optional: true
    pFaults: ?[*]VkFaultData = null,
    // Extern sync: false
    // Optional: false
    pfnFaultCallback: ?*const vkFaultCallbackFunction = null,
};
// Extension: VK_BASE_VERSION_1_3
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceToolProperties = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Length member: null-terminated
    // Extern sync: false
    // Optional: false
    name: [VK_MAX_EXTENSION_NAME_SIZE]u8 = @import("std").mem.zeroes([VK_MAX_EXTENSION_NAME_SIZE]u8),
    // Length member: null-terminated
    // Extern sync: false
    // Optional: false
    version: [VK_MAX_EXTENSION_NAME_SIZE]u8 = @import("std").mem.zeroes([VK_MAX_EXTENSION_NAME_SIZE]u8),
    // Extern sync: false
    // Optional: false
    purposes: VkToolPurposeFlags = .{},
    // Length member: null-terminated
    // Extern sync: false
    // Optional: false
    description: [VK_MAX_DESCRIPTION_SIZE]u8 = @import("std").mem.zeroes([VK_MAX_DESCRIPTION_SIZE]u8),
    // Length member: null-terminated
    // Extern sync: false
    // Optional: false
    layer: [VK_MAX_EXTENSION_NAME_SIZE]u8 = @import("std").mem.zeroes([VK_MAX_EXTENSION_NAME_SIZE]u8),
};
// Extension: VK_EXT_tooling_info
pub const VkPhysicalDeviceToolPropertiesEXT = VkPhysicalDeviceToolProperties;
// Extension: VK_EXT_custom_border_color
// Extends: VkSamplerCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSamplerCustomBorderColorCreateInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    customBorderColor: VkClearColorValue,
    // Extern sync: false
    // Optional: false
    format: VkFormat,
};
// Extension: VK_EXT_custom_border_color
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceCustomBorderColorPropertiesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    maxCustomBorderColorSamplers: u32 = 0,
};
// Extension: VK_EXT_custom_border_color
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceCustomBorderColorFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    customBorderColors: u32 = 0,
    // Extern sync: false
    // Optional: false
    customBorderColorWithoutFormat: u32 = 0,
};
// Extension: VK_EXT_border_color_swizzle
// Extends: VkSamplerCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSamplerBorderColorComponentMappingCreateInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    components: VkComponentMapping = .{},
    // Extern sync: false
    // Optional: false
    srgb: u32 = 0,
};
// Extension: VK_EXT_border_color_swizzle
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceBorderColorSwizzleFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    borderColorSwizzle: u32 = 0,
    // Extern sync: false
    // Optional: false
    borderColorSwizzleFromImage: u32 = 0,
};
// Extension: VK_KHR_acceleration_structure
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkAccelerationStructureGeometryTrianglesDataKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    vertexFormat: VkFormat,
    // Extern sync: false
    // Optional: false
    vertexData: VkDeviceOrHostAddressConstKHR,
    // Extern sync: false
    // Optional: false
    vertexStride: u64 = 0,
    // Extern sync: false
    // Optional: false
    maxVertex: u32 = 0,
    // Extern sync: false
    // Optional: false
    indexType: VkIndexType,
    // Extern sync: false
    // Optional: false
    indexData: VkDeviceOrHostAddressConstKHR,
    // Extern sync: false
    // Optional: false
    transformData: VkDeviceOrHostAddressConstKHR,
};
// Extension: VK_KHR_acceleration_structure
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkAccelerationStructureGeometryAabbsDataKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_AABBS_DATA_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    data: VkDeviceOrHostAddressConstKHR,
    // Extern sync: false
    // Optional: false
    stride: u64 = 0,
};
// Extension: VK_KHR_acceleration_structure
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkAccelerationStructureGeometryInstancesDataKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    arrayOfPointers: u32 = 0,
    // Extern sync: false
    // Optional: false
    data: VkDeviceOrHostAddressConstKHR,
};
// Extension: VK_NV_ray_tracing_linear_swept_spheres
// Extends: VkAccelerationStructureGeometryKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkAccelerationStructureGeometryLinearSweptSpheresDataNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_LINEAR_SWEPT_SPHERES_DATA_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    vertexFormat: VkFormat,
    // Extern sync: false
    // Optional: false
    vertexData: VkDeviceOrHostAddressConstKHR,
    // Extern sync: false
    // Optional: false
    vertexStride: u64 = 0,
    // Extern sync: false
    // Optional: false
    radiusFormat: VkFormat,
    // Extern sync: false
    // Optional: false
    radiusData: VkDeviceOrHostAddressConstKHR,
    // Extern sync: false
    // Optional: false
    radiusStride: u64 = 0,
    // Extern sync: false
    // Optional: false
    indexType: VkIndexType,
    // Extern sync: false
    // Optional: false
    indexData: VkDeviceOrHostAddressConstKHR,
    // Extern sync: false
    // Optional: false
    indexStride: u64 = 0,
    // Extern sync: false
    // Optional: false
    indexingMode: VkRayTracingLssIndexingModeNV,
    // Extern sync: false
    // Optional: false
    endCapsMode: VkRayTracingLssPrimitiveEndCapsModeNV,
};
// Extension: VK_NV_ray_tracing_linear_swept_spheres
// Extends: VkAccelerationStructureGeometryKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkAccelerationStructureGeometrySpheresDataNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_SPHERES_DATA_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    vertexFormat: VkFormat,
    // Extern sync: false
    // Optional: false
    vertexData: VkDeviceOrHostAddressConstKHR,
    // Extern sync: false
    // Optional: false
    vertexStride: u64 = 0,
    // Extern sync: false
    // Optional: false
    radiusFormat: VkFormat,
    // Extern sync: false
    // Optional: false
    radiusData: VkDeviceOrHostAddressConstKHR,
    // Extern sync: false
    // Optional: false
    radiusStride: u64 = 0,
    // Extern sync: false
    // Optional: false
    indexType: VkIndexType,
    // Extern sync: false
    // Optional: false
    indexData: VkDeviceOrHostAddressConstKHR,
    // Extern sync: false
    // Optional: false
    indexStride: u64 = 0,
};
// Extension: VK_KHR_acceleration_structure
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkAccelerationStructureGeometryKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    geometryType: VkGeometryTypeKHR,
    // Extern sync: false
    // Optional: false
    // Selector member: geometryType (What union field is valid)
    geometry: VkAccelerationStructureGeometryDataKHR,
    // Extern sync: false
    // Optional: true
    flags: VkGeometryFlagsKHR = .{},
};
// Extension: VK_KHR_acceleration_structure
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkAccelerationStructureBuildGeometryInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    type: VkAccelerationStructureTypeKHR,
    // Extern sync: false
    // Optional: true
    flags: VkBuildAccelerationStructureFlagsKHR = .{},
    // Extern sync: false
    // Optional: false
    mode: VkBuildAccelerationStructureModeKHR,
    // Extern sync: false
    // Optional: true
    srcAccelerationStructure: VkAccelerationStructureKHR = .none,
    // Extern sync: false
    // Optional: true
    dstAccelerationStructure: VkAccelerationStructureKHR = .none,
    // Extern sync: false
    // Optional: true
    geometryCount: u32 = 0,
    // Length member: geometryCount
    // Extern sync: false
    // Optional: true
    pGeometries: ?[*]const VkAccelerationStructureGeometryKHR = null,
    // Length member: geometryCount,1
    // Extern sync: false
    // Optional: false
    ppGeometries: ?[*]const *const VkAccelerationStructureGeometryKHR = null,
    // Extern sync: false
    // Optional: false
    scratchData: VkDeviceOrHostAddressKHR,
};
// Extension: VK_KHR_acceleration_structure
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkAccelerationStructureBuildRangeInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    primitiveCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    primitiveOffset: u32 = 0,
    // Extern sync: false
    // Optional: false
    firstVertex: u32 = 0,
    // Extern sync: false
    // Optional: false
    transformOffset: u32 = 0,
};
// Extension: VK_KHR_acceleration_structure
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkAccelerationStructureCreateInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    createFlags: VkAccelerationStructureCreateFlagsKHR = .{},
    // Extern sync: false
    // Optional: false
    buffer: VkBuffer = .none,
    // Extern sync: false
    // Optional: false
    // Comment: Specified in bytes
    offset: u64 = 0,
    // Extern sync: false
    // Optional: false
    size: u64 = 0,
    // Extern sync: false
    // Optional: false
    type: VkAccelerationStructureTypeKHR,
    // Extern sync: false
    // Optional: true
    deviceAddress: u64 = 0,
};
// Extension: VK_KHR_acceleration_structure
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkAabbPositionsKHR = extern struct {
    // Extern sync: false
    // Optional: false
    minX: f32 = 0,
    // Extern sync: false
    // Optional: false
    minY: f32 = 0,
    // Extern sync: false
    // Optional: false
    minZ: f32 = 0,
    // Extern sync: false
    // Optional: false
    maxX: f32 = 0,
    // Extern sync: false
    // Optional: false
    maxY: f32 = 0,
    // Extern sync: false
    // Optional: false
    maxZ: f32 = 0,
};
// Extension: VK_NV_ray_tracing
pub const VkAabbPositionsNV = VkAabbPositionsKHR;
// Extension: VK_KHR_acceleration_structure
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkTransformMatrixKHR = extern struct {
    // Extern sync: false
    // Optional: false
    matrix: [3][4]f32 = @import("std").mem.zeroes([3][4]f32),
};
// Extension: VK_NV_ray_tracing
pub const VkTransformMatrixNV = VkTransformMatrixKHR;
// Extension: VK_KHR_acceleration_structure
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkAccelerationStructureInstanceKHR = extern struct {
};
// Extension: VK_NV_ray_tracing
pub const VkAccelerationStructureInstanceNV = VkAccelerationStructureInstanceKHR;
// Extension: VK_KHR_acceleration_structure
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkAccelerationStructureDeviceAddressInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    accelerationStructure: VkAccelerationStructureKHR = .none,
};
// Extension: VK_KHR_acceleration_structure
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkAccelerationStructureVersionInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_VERSION_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Length member: 2*VK_UUID_SIZE
    // Extern sync: false
    // Optional: false
    pVersionData: ?[*]const u8 = null,
};
// Extension: VK_KHR_acceleration_structure
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkCopyAccelerationStructureInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    src: VkAccelerationStructureKHR = .none,
    // Extern sync: false
    // Optional: false
    dst: VkAccelerationStructureKHR = .none,
    // Extern sync: false
    // Optional: false
    mode: VkCopyAccelerationStructureModeKHR,
};
// Extension: VK_KHR_acceleration_structure
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkCopyAccelerationStructureToMemoryInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    src: VkAccelerationStructureKHR = .none,
    // Extern sync: false
    // Optional: false
    dst: VkDeviceOrHostAddressKHR,
    // Extern sync: false
    // Optional: false
    mode: VkCopyAccelerationStructureModeKHR,
};
// Extension: VK_KHR_acceleration_structure
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkCopyMemoryToAccelerationStructureInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    src: VkDeviceOrHostAddressConstKHR,
    // Extern sync: false
    // Optional: false
    dst: VkAccelerationStructureKHR = .none,
    // Extern sync: false
    // Optional: false
    mode: VkCopyAccelerationStructureModeKHR,
};
// Extension: VK_KHR_ray_tracing_pipeline
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkRayTracingPipelineInterfaceCreateInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_INTERFACE_CREATE_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    maxPipelineRayPayloadSize: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxPipelineRayHitAttributeSize: u32 = 0,
};
// Extension: VK_KHR_pipeline_library
// Extends: VkGraphicsPipelineCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineLibraryCreateInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    libraryCount: u32 = 0,
    // Length member: libraryCount
    // Extern sync: false
    // Optional: false
    pLibraries: ?[*]const VkPipeline = null,
};
// Extension: VK_KHR_object_refresh
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkRefreshObjectKHR = extern struct {
    // Extern sync: false
    // Optional: false
    objectType: VkObjectType,
    // Extern sync: true
    // Optional: false
    // Object type: objectType (Which object handle is this)
    objectHandle: u64 = 0,
    // Extern sync: false
    // Optional: true
    flags: VkRefreshObjectFlagsKHR = .{},
};
// Extension: VK_KHR_object_refresh
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkRefreshObjectListKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_REFRESH_OBJECT_LIST_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    objectCount: u32 = 0,
    // Length member: objectCount
    // Extern sync: false
    // Optional: false
    pObjects: ?[*]const VkRefreshObjectKHR = null,
};
// Extension: VK_EXT_extended_dynamic_state
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceExtendedDynamicStateFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    extendedDynamicState: u32 = 0,
};
// Extension: VK_EXT_extended_dynamic_state2
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceExtendedDynamicState2FeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    extendedDynamicState2: u32 = 0,
    // Extern sync: false
    // Optional: false
    extendedDynamicState2LogicOp: u32 = 0,
    // Extern sync: false
    // Optional: false
    extendedDynamicState2PatchControlPoints: u32 = 0,
};
// Extension: VK_EXT_extended_dynamic_state3
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceExtendedDynamicState3FeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_FEATURES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    extendedDynamicState3TessellationDomainOrigin: u32 = 0,
    // Extern sync: false
    // Optional: false
    extendedDynamicState3DepthClampEnable: u32 = 0,
    // Extern sync: false
    // Optional: false
    extendedDynamicState3PolygonMode: u32 = 0,
    // Extern sync: false
    // Optional: false
    extendedDynamicState3RasterizationSamples: u32 = 0,
    // Extern sync: false
    // Optional: false
    extendedDynamicState3SampleMask: u32 = 0,
    // Extern sync: false
    // Optional: false
    extendedDynamicState3AlphaToCoverageEnable: u32 = 0,
    // Extern sync: false
    // Optional: false
    extendedDynamicState3AlphaToOneEnable: u32 = 0,
    // Extern sync: false
    // Optional: false
    extendedDynamicState3LogicOpEnable: u32 = 0,
    // Extern sync: false
    // Optional: false
    extendedDynamicState3ColorBlendEnable: u32 = 0,
    // Extern sync: false
    // Optional: false
    extendedDynamicState3ColorBlendEquation: u32 = 0,
    // Extern sync: false
    // Optional: false
    extendedDynamicState3ColorWriteMask: u32 = 0,
    // Extern sync: false
    // Optional: false
    extendedDynamicState3RasterizationStream: u32 = 0,
    // Extern sync: false
    // Optional: false
    extendedDynamicState3ConservativeRasterizationMode: u32 = 0,
    // Extern sync: false
    // Optional: false
    extendedDynamicState3ExtraPrimitiveOverestimationSize: u32 = 0,
    // Extern sync: false
    // Optional: false
    extendedDynamicState3DepthClipEnable: u32 = 0,
    // Extern sync: false
    // Optional: false
    extendedDynamicState3SampleLocationsEnable: u32 = 0,
    // Extern sync: false
    // Optional: false
    extendedDynamicState3ColorBlendAdvanced: u32 = 0,
    // Extern sync: false
    // Optional: false
    extendedDynamicState3ProvokingVertexMode: u32 = 0,
    // Extern sync: false
    // Optional: false
    extendedDynamicState3LineRasterizationMode: u32 = 0,
    // Extern sync: false
    // Optional: false
    extendedDynamicState3LineStippleEnable: u32 = 0,
    // Extern sync: false
    // Optional: false
    extendedDynamicState3DepthClipNegativeOneToOne: u32 = 0,
    // Extern sync: false
    // Optional: false
    extendedDynamicState3ViewportWScalingEnable: u32 = 0,
    // Extern sync: false
    // Optional: false
    extendedDynamicState3ViewportSwizzle: u32 = 0,
    // Extern sync: false
    // Optional: false
    extendedDynamicState3CoverageToColorEnable: u32 = 0,
    // Extern sync: false
    // Optional: false
    extendedDynamicState3CoverageToColorLocation: u32 = 0,
    // Extern sync: false
    // Optional: false
    extendedDynamicState3CoverageModulationMode: u32 = 0,
    // Extern sync: false
    // Optional: false
    extendedDynamicState3CoverageModulationTableEnable: u32 = 0,
    // Extern sync: false
    // Optional: false
    extendedDynamicState3CoverageModulationTable: u32 = 0,
    // Extern sync: false
    // Optional: false
    extendedDynamicState3CoverageReductionMode: u32 = 0,
    // Extern sync: false
    // Optional: false
    extendedDynamicState3RepresentativeFragmentTestEnable: u32 = 0,
    // Extern sync: false
    // Optional: false
    extendedDynamicState3ShadingRateImageEnable: u32 = 0,
};
// Extension: VK_EXT_extended_dynamic_state3
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceExtendedDynamicState3PropertiesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_PROPERTIES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    dynamicPrimitiveTopologyUnrestricted: u32 = 0,
};
// Extension: VK_EXT_extended_dynamic_state3
// Extension: VK_EXT_shader_object
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkColorBlendEquationEXT = extern struct {
    // Extern sync: false
    // Optional: false
    srcColorBlendFactor: VkBlendFactor,
    // Extern sync: false
    // Optional: false
    dstColorBlendFactor: VkBlendFactor,
    // Extern sync: false
    // Optional: false
    colorBlendOp: VkBlendOp,
    // Extern sync: false
    // Optional: false
    srcAlphaBlendFactor: VkBlendFactor,
    // Extern sync: false
    // Optional: false
    dstAlphaBlendFactor: VkBlendFactor,
    // Extern sync: false
    // Optional: false
    alphaBlendOp: VkBlendOp,
};
// Extension: VK_EXT_extended_dynamic_state3
// Extension: VK_EXT_shader_object
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkColorBlendAdvancedEXT = extern struct {
    // Extern sync: false
    // Optional: false
    advancedBlendOp: VkBlendOp,
    // Extern sync: false
    // Optional: false
    srcPremultiplied: u32 = 0,
    // Extern sync: false
    // Optional: false
    dstPremultiplied: u32 = 0,
    // Extern sync: false
    // Optional: false
    blendOverlap: VkBlendOverlapEXT,
    // Extern sync: false
    // Optional: false
    clampResults: u32 = 0,
};
// Extension: VK_QCOM_render_pass_transform
// Extends: VkRenderPassBeginInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkRenderPassTransformBeginInfoQCOM = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM,
    // Extern sync: false
    // Optional: true
    // Comment: Pointer to next structure
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    transform: VkSurfaceTransformFlagsKHR = .{},
};
// Extension: VK_QCOM_rotated_copy_commands
// Extends: VkBufferImageCopy2,VkImageBlit2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkCopyCommandTransformInfoQCOM = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    transform: VkSurfaceTransformFlagsKHR = .{},
};
// Extension: VK_QCOM_render_pass_transform
// Extends: VkCommandBufferInheritanceInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkCommandBufferInheritanceRenderPassTransformInfoQCOM = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM,
    // Extern sync: false
    // Optional: true
    // Comment: Pointer to next structure
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    transform: VkSurfaceTransformFlagsKHR = .{},
    // Extern sync: false
    // Optional: false
    renderArea: VkRect2D = .{},
};
// Extension: VK_NV_partitioned_acceleration_structure
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDevicePartitionedAccelerationStructureFeaturesNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PARTITIONED_ACCELERATION_STRUCTURE_FEATURES_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    partitionedAccelerationStructure: u32 = 0,
};
// Extension: VK_NV_partitioned_acceleration_structure
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDevicePartitionedAccelerationStructurePropertiesNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PARTITIONED_ACCELERATION_STRUCTURE_PROPERTIES_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    maxPartitionCount: u32 = 0,
};
// Extension: VK_NV_partitioned_acceleration_structure
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkBuildPartitionedAccelerationStructureIndirectCommandNV = extern struct {
    // Extern sync: false
    // Optional: false
    opType: VkPartitionedAccelerationStructureOpTypeNV,
    // Extern sync: false
    // Optional: false
    argCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    argData: VkStridedDeviceAddressNV = .{},
};
// Extension: VK_NV_partitioned_acceleration_structure
// Extends: VkPartitionedAccelerationStructureInstancesInputNV
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPartitionedAccelerationStructureFlagsNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PARTITIONED_ACCELERATION_STRUCTURE_FLAGS_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    enablePartitionTranslation: u32 = 0,
};
// Extension: VK_NV_partitioned_acceleration_structure
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPartitionedAccelerationStructureWriteInstanceDataNV = extern struct {
    // Extern sync: false
    // Optional: false
    transform: VkTransformMatrixKHR = .{},
    // Extern sync: false
    // Optional: false
    explicitAABB: [6]f32 = @import("std").mem.zeroes([6]f32),
    // Extern sync: false
    // Optional: false
    instanceID: u32 = 0,
    // Extern sync: false
    // Optional: false
    instanceMask: u32 = 0,
    // Extern sync: false
    // Optional: false
    instanceContributionToHitGroupIndex: u32 = 0,
    // Extern sync: false
    // Optional: true
    instanceFlags: VkPartitionedAccelerationStructureInstanceFlagsNV = .{},
    // Extern sync: false
    // Optional: false
    instanceIndex: u32 = 0,
    // Extern sync: false
    // Optional: false
    partitionIndex: u32 = 0,
    // Extern sync: false
    // Optional: false
    accelerationStructure: u64 = 0,
};
// Extension: VK_NV_partitioned_acceleration_structure
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPartitionedAccelerationStructureUpdateInstanceDataNV = extern struct {
    // Extern sync: false
    // Optional: false
    instanceIndex: u32 = 0,
    // Extern sync: false
    // Optional: false
    instanceContributionToHitGroupIndex: u32 = 0,
    // Extern sync: false
    // Optional: false
    accelerationStructure: u64 = 0,
};
// Extension: VK_NV_partitioned_acceleration_structure
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPartitionedAccelerationStructureWritePartitionTranslationDataNV = extern struct {
    // Extern sync: false
    // Optional: false
    partitionIndex: u32 = 0,
    // Extern sync: false
    // Optional: false
    partitionTranslation: [3]f32 = @import("std").mem.zeroes([3]f32),
};
// Extension: VK_NV_partitioned_acceleration_structure
// Extends: VkWriteDescriptorSet
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkWriteDescriptorSetPartitionedAccelerationStructureNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_PARTITIONED_ACCELERATION_STRUCTURE_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    accelerationStructureCount: u32 = 0,
    // Length member: accelerationStructureCount
    // Extern sync: false
    // Optional: false
    pAccelerationStructures: ?[*]const u64 = null,
};
// Extension: VK_NV_partitioned_acceleration_structure
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPartitionedAccelerationStructureInstancesInputNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCES_INPUT_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkBuildAccelerationStructureFlagsKHR = .{},
    // Extern sync: false
    // Optional: false
    instanceCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxInstancePerPartitionCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    partitionCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxInstanceInGlobalPartitionCount: u32 = 0,
};
// Extension: VK_NV_partitioned_acceleration_structure
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkBuildPartitionedAccelerationStructureInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_BUILD_PARTITIONED_ACCELERATION_STRUCTURE_INFO_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    input: VkPartitionedAccelerationStructureInstancesInputNV = .{},
    // Extern sync: false
    // Optional: true
    srcAccelerationStructureData: u64 = 0,
    // Extern sync: false
    // Optional: false
    dstAccelerationStructureData: u64 = 0,
    // Extern sync: false
    // Optional: false
    scratchData: u64 = 0,
    // Extern sync: false
    // Optional: false
    srcInfos: u64 = 0,
    // Extern sync: false
    // Optional: false
    srcInfosCount: u64 = 0,
};
// Extension: VK_NV_device_diagnostics_config
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceDiagnosticsConfigFeaturesNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    diagnosticsConfig: u32 = 0,
};
// Extension: VK_NV_device_diagnostics_config
// Extends: VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDeviceDiagnosticsConfigCreateInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkDeviceDiagnosticsConfigFlagsNV = .{},
};
// Extension: VKSC_VERSION_1_0
// Extends: VkGraphicsPipelineCreateInfo,VkComputePipelineCreateInfo,VkRayTracingPipelineCreateInfoKHR,VkRayTracingPipelineCreateInfoNV
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineOfflineCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_OFFLINE_CREATE_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    pipelineIdentifier: [VK_UUID_SIZE]u8 = @import("std").mem.zeroes([VK_UUID_SIZE]u8),
    // Extern sync: false
    // Optional: false
    matchControl: VkPipelineMatchControl,
    // Extern sync: false
    // Optional: false
    poolEntrySize: u64 = 0,
};
// Extension: VK_COMPUTE_VERSION_1_3
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    shaderZeroInitializeWorkgroupMemory: u32 = 0,
};
// Extension: VK_KHR_zero_initialize_workgroup_memory
pub const VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR = VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures;
// Extension: VK_KHR_shader_subgroup_uniform_control_flow
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    shaderSubgroupUniformControlFlow: u32 = 0,
};
// Extension: VK_KHR_robustness2
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceRobustness2FeaturesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    robustBufferAccess2: u32 = 0,
    // Extern sync: false
    // Optional: false
    robustImageAccess2: u32 = 0,
    // Extern sync: false
    // Optional: false
    nullDescriptor: u32 = 0,
};
// Extension: VK_EXT_robustness2
pub const VkPhysicalDeviceRobustness2FeaturesEXT = VkPhysicalDeviceRobustness2FeaturesKHR;
// Extension: VK_KHR_robustness2
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceRobustness2PropertiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    robustStorageBufferAccessSizeAlignment: u64 = 0,
    // Extern sync: false
    // Optional: false
    robustUniformBufferAccessSizeAlignment: u64 = 0,
};
// Extension: VK_EXT_robustness2
pub const VkPhysicalDeviceRobustness2PropertiesEXT = VkPhysicalDeviceRobustness2PropertiesKHR;
// Extension: VK_COMPUTE_VERSION_1_3
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceImageRobustnessFeatures = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    robustImageAccess: u32 = 0,
};
// Extension: VK_EXT_image_robustness
pub const VkPhysicalDeviceImageRobustnessFeaturesEXT = VkPhysicalDeviceImageRobustnessFeatures;
// Extension: VK_KHR_workgroup_memory_explicit_layout
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    workgroupMemoryExplicitLayout: u32 = 0,
    // Extern sync: false
    // Optional: false
    workgroupMemoryExplicitLayoutScalarBlockLayout: u32 = 0,
    // Extern sync: false
    // Optional: false
    workgroupMemoryExplicitLayout8BitAccess: u32 = 0,
    // Extern sync: false
    // Optional: false
    workgroupMemoryExplicitLayout16BitAccess: u32 = 0,
};
// Extension: VK_KHR_portability_subset
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDevicePortabilitySubsetFeaturesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_FEATURES_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    constantAlphaColorBlendFactors: u32 = 0,
    // Extern sync: false
    // Optional: false
    events: u32 = 0,
    // Extern sync: false
    // Optional: false
    imageViewFormatReinterpretation: u32 = 0,
    // Extern sync: false
    // Optional: false
    imageViewFormatSwizzle: u32 = 0,
    // Extern sync: false
    // Optional: false
    imageView2DOn3DImage: u32 = 0,
    // Extern sync: false
    // Optional: false
    multisampleArrayImage: u32 = 0,
    // Extern sync: false
    // Optional: false
    mutableComparisonSamplers: u32 = 0,
    // Extern sync: false
    // Optional: false
    pointPolygons: u32 = 0,
    // Extern sync: false
    // Optional: false
    samplerMipLodBias: u32 = 0,
    // Extern sync: false
    // Optional: false
    separateStencilMaskRef: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderSampleRateInterpolationFunctions: u32 = 0,
    // Extern sync: false
    // Optional: false
    tessellationIsolines: u32 = 0,
    // Extern sync: false
    // Optional: false
    tessellationPointMode: u32 = 0,
    // Extern sync: false
    // Optional: false
    triangleFans: u32 = 0,
    // Extern sync: false
    // Optional: false
    vertexAttributeAccessBeyondStride: u32 = 0,
};
// Extension: VK_KHR_portability_subset
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDevicePortabilitySubsetPropertiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_PROPERTIES_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    minVertexInputBindingStrideAlignment: u32 = 0,
};
// Extension: VK_EXT_4444_formats
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDevice4444FormatsFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    formatA4R4G4B4: u32 = 0,
    // Extern sync: false
    // Optional: false
    formatA4B4G4R4: u32 = 0,
};
// Extension: VK_HUAWEI_subpass_shading
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceSubpassShadingFeaturesHUAWEI = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    subpassShading: u32 = 0,
};
// Extension: VK_HUAWEI_cluster_culling_shader
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_FEATURES_HUAWEI,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    clustercullingShader: u32 = 0,
    // Extern sync: false
    // Optional: false
    multiviewClusterCullingShader: u32 = 0,
};
// Extension: VK_HUAWEI_cluster_culling_shader
// Extends: VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_VRS_FEATURES_HUAWEI,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    clusterShadingRate: u32 = 0,
};
// Extension: VK_BASE_VERSION_1_3
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkBufferCopy2 = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_BUFFER_COPY_2,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: Specified in bytes
    srcOffset: u64 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Specified in bytes
    dstOffset: u64 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Specified in bytes
    size: u64 = 0,
};
// Extension: VK_KHR_copy_commands2
pub const VkBufferCopy2KHR = VkBufferCopy2;
// Extension: VK_BASE_VERSION_1_3
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImageCopy2 = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_IMAGE_COPY_2,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    srcSubresource: VkImageSubresourceLayers = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Specified in pixels for both compressed and uncompressed images
    srcOffset: VkOffset3D = .{},
    // Extern sync: false
    // Optional: false
    dstSubresource: VkImageSubresourceLayers = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Specified in pixels for both compressed and uncompressed images
    dstOffset: VkOffset3D = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Specified in pixels for both compressed and uncompressed images
    extent: VkExtent3D = .{},
};
// Extension: VK_KHR_copy_commands2
pub const VkImageCopy2KHR = VkImageCopy2;
// Extension: VK_GRAPHICS_VERSION_1_3
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImageBlit2 = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_IMAGE_BLIT_2,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    srcSubresource: VkImageSubresourceLayers = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Specified in pixels for both compressed and uncompressed images
    srcOffsets: [2]VkOffset3D = @import("std").mem.zeroes([2]VkOffset3D),
    // Extern sync: false
    // Optional: false
    dstSubresource: VkImageSubresourceLayers = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Specified in pixels for both compressed and uncompressed images
    dstOffsets: [2]VkOffset3D = @import("std").mem.zeroes([2]VkOffset3D),
};
// Extension: VK_KHR_copy_commands2
pub const VkImageBlit2KHR = VkImageBlit2;
// Extension: VK_BASE_VERSION_1_3
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkBufferImageCopy2 = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: Specified in bytes
    bufferOffset: u64 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Specified in texels
    bufferRowLength: u32 = 0,
    // Extern sync: false
    // Optional: false
    bufferImageHeight: u32 = 0,
    // Extern sync: false
    // Optional: false
    imageSubresource: VkImageSubresourceLayers = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Specified in pixels for both compressed and uncompressed images
    imageOffset: VkOffset3D = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Specified in pixels for both compressed and uncompressed images
    imageExtent: VkExtent3D = .{},
};
// Extension: VK_KHR_copy_commands2
pub const VkBufferImageCopy2KHR = VkBufferImageCopy2;
// Extension: VK_GRAPHICS_VERSION_1_3
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImageResolve2 = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    srcSubresource: VkImageSubresourceLayers = .{},
    // Extern sync: false
    // Optional: false
    srcOffset: VkOffset3D = .{},
    // Extern sync: false
    // Optional: false
    dstSubresource: VkImageSubresourceLayers = .{},
    // Extern sync: false
    // Optional: false
    dstOffset: VkOffset3D = .{},
    // Extern sync: false
    // Optional: false
    extent: VkExtent3D = .{},
};
// Extension: VK_KHR_copy_commands2
pub const VkImageResolve2KHR = VkImageResolve2;
// Extension: VK_BASE_VERSION_1_3
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkCopyBufferInfo2 = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    srcBuffer: VkBuffer = .none,
    // Extern sync: false
    // Optional: false
    dstBuffer: VkBuffer = .none,
    // Extern sync: false
    // Optional: false
    regionCount: u32 = 0,
    // Length member: regionCount
    // Extern sync: false
    // Optional: false
    pRegions: ?[*]const VkBufferCopy2 = null,
};
// Extension: VK_KHR_copy_commands2
pub const VkCopyBufferInfo2KHR = VkCopyBufferInfo2;
// Extension: VK_BASE_VERSION_1_3
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkCopyImageInfo2 = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    srcImage: VkImage = .none,
    // Extern sync: false
    // Optional: false
    srcImageLayout: VkImageLayout,
    // Extern sync: false
    // Optional: false
    dstImage: VkImage = .none,
    // Extern sync: false
    // Optional: false
    dstImageLayout: VkImageLayout,
    // Extern sync: false
    // Optional: false
    regionCount: u32 = 0,
    // Length member: regionCount
    // Extern sync: false
    // Optional: false
    pRegions: ?[*]const VkImageCopy2 = null,
};
// Extension: VK_KHR_copy_commands2
pub const VkCopyImageInfo2KHR = VkCopyImageInfo2;
// Extension: VK_GRAPHICS_VERSION_1_3
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkBlitImageInfo2 = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    srcImage: VkImage = .none,
    // Extern sync: false
    // Optional: false
    srcImageLayout: VkImageLayout,
    // Extern sync: false
    // Optional: false
    dstImage: VkImage = .none,
    // Extern sync: false
    // Optional: false
    dstImageLayout: VkImageLayout,
    // Extern sync: false
    // Optional: false
    regionCount: u32 = 0,
    // Length member: regionCount
    // Extern sync: false
    // Optional: false
    pRegions: ?[*]const VkImageBlit2 = null,
    // Extern sync: false
    // Optional: false
    filter: VkFilter,
};
// Extension: VK_KHR_copy_commands2
pub const VkBlitImageInfo2KHR = VkBlitImageInfo2;
// Extension: VK_BASE_VERSION_1_3
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkCopyBufferToImageInfo2 = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    srcBuffer: VkBuffer = .none,
    // Extern sync: false
    // Optional: false
    dstImage: VkImage = .none,
    // Extern sync: false
    // Optional: false
    dstImageLayout: VkImageLayout,
    // Extern sync: false
    // Optional: false
    regionCount: u32 = 0,
    // Length member: regionCount
    // Extern sync: false
    // Optional: false
    pRegions: ?[*]const VkBufferImageCopy2 = null,
};
// Extension: VK_KHR_copy_commands2
pub const VkCopyBufferToImageInfo2KHR = VkCopyBufferToImageInfo2;
// Extension: VK_BASE_VERSION_1_3
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkCopyImageToBufferInfo2 = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    srcImage: VkImage = .none,
    // Extern sync: false
    // Optional: false
    srcImageLayout: VkImageLayout,
    // Extern sync: false
    // Optional: false
    dstBuffer: VkBuffer = .none,
    // Extern sync: false
    // Optional: false
    regionCount: u32 = 0,
    // Length member: regionCount
    // Extern sync: false
    // Optional: false
    pRegions: ?[*]const VkBufferImageCopy2 = null,
};
// Extension: VK_KHR_copy_commands2
pub const VkCopyImageToBufferInfo2KHR = VkCopyImageToBufferInfo2;
// Extension: VK_GRAPHICS_VERSION_1_3
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkResolveImageInfo2 = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    srcImage: VkImage = .none,
    // Extern sync: false
    // Optional: false
    srcImageLayout: VkImageLayout,
    // Extern sync: false
    // Optional: false
    dstImage: VkImage = .none,
    // Extern sync: false
    // Optional: false
    dstImageLayout: VkImageLayout,
    // Extern sync: false
    // Optional: false
    regionCount: u32 = 0,
    // Length member: regionCount
    // Extern sync: false
    // Optional: false
    pRegions: ?[*]const VkImageResolve2 = null,
};
// Extension: VK_KHR_copy_commands2
pub const VkResolveImageInfo2KHR = VkResolveImageInfo2;
// Extension: VK_EXT_shader_image_atomic_int64
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    shaderImageInt64Atomics: u32 = 0,
    // Extern sync: false
    // Optional: false
    sparseImageInt64Atomics: u32 = 0,
};
// Extension: VK_KHR_fragment_shading_rate
// Extends: VkSubpassDescription2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkFragmentShadingRateAttachmentInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    pFragmentShadingRateAttachment: ?*const VkAttachmentReference2 = null,
    // Extern sync: false
    // Optional: false
    shadingRateAttachmentTexelSize: VkExtent2D = .{},
};
// Extension: VK_KHR_fragment_shading_rate
// Extends: VkGraphicsPipelineCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineFragmentShadingRateStateCreateInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    fragmentSize: VkExtent2D = .{},
    // Extern sync: false
    // Optional: false
    combinerOps: [2]VkFragmentShadingRateCombinerOpKHR = @import("std").mem.zeroes([2]VkFragmentShadingRateCombinerOpKHR),
};
// Extension: VK_KHR_fragment_shading_rate
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceFragmentShadingRateFeaturesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    pipelineFragmentShadingRate: u32 = 0,
    // Extern sync: false
    // Optional: false
    primitiveFragmentShadingRate: u32 = 0,
    // Extern sync: false
    // Optional: false
    attachmentFragmentShadingRate: u32 = 0,
};
// Extension: VK_KHR_fragment_shading_rate
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceFragmentShadingRatePropertiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    minFragmentShadingRateAttachmentTexelSize: VkExtent2D = .{},
    // Extern sync: false
    // Optional: false
    maxFragmentShadingRateAttachmentTexelSize: VkExtent2D = .{},
    // Extern sync: false
    // Optional: false
    maxFragmentShadingRateAttachmentTexelSizeAspectRatio: u32 = 0,
    // Extern sync: false
    // Optional: false
    primitiveFragmentShadingRateWithMultipleViewports: u32 = 0,
    // Extern sync: false
    // Optional: false
    layeredShadingRateAttachments: u32 = 0,
    // Extern sync: false
    // Optional: false
    fragmentShadingRateNonTrivialCombinerOps: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxFragmentSize: VkExtent2D = .{},
    // Extern sync: false
    // Optional: false
    maxFragmentSizeAspectRatio: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxFragmentShadingRateCoverageSamples: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxFragmentShadingRateRasterizationSamples: VkSampleCountFlags = .{},
    // Extern sync: false
    // Optional: false
    fragmentShadingRateWithShaderDepthStencilWrites: u32 = 0,
    // Extern sync: false
    // Optional: false
    fragmentShadingRateWithSampleMask: u32 = 0,
    // Extern sync: false
    // Optional: false
    fragmentShadingRateWithShaderSampleMask: u32 = 0,
    // Extern sync: false
    // Optional: false
    fragmentShadingRateWithConservativeRasterization: u32 = 0,
    // Extern sync: false
    // Optional: false
    fragmentShadingRateWithFragmentShaderInterlock: u32 = 0,
    // Extern sync: false
    // Optional: false
    fragmentShadingRateWithCustomSampleLocations: u32 = 0,
    // Extern sync: false
    // Optional: false
    fragmentShadingRateStrictMultiplyCombiner: u32 = 0,
};
// Extension: VK_KHR_fragment_shading_rate
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceFragmentShadingRateKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    sampleCounts: VkSampleCountFlags = .{},
    // Extern sync: false
    // Optional: false
    fragmentSize: VkExtent2D = .{},
};
// Extension: VK_COMPUTE_VERSION_1_3
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceShaderTerminateInvocationFeatures = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    shaderTerminateInvocation: u32 = 0,
};
// Extension: VK_KHR_shader_terminate_invocation
pub const VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR = VkPhysicalDeviceShaderTerminateInvocationFeatures;
// Extension: VK_NV_fragment_shading_rate_enums
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    fragmentShadingRateEnums: u32 = 0,
    // Extern sync: false
    // Optional: false
    supersampleFragmentShadingRates: u32 = 0,
    // Extern sync: false
    // Optional: false
    noInvocationFragmentShadingRates: u32 = 0,
};
// Extension: VK_NV_fragment_shading_rate_enums
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    maxFragmentShadingRateInvocationCount: VkSampleCountFlags = .{},
};
// Extension: VK_NV_fragment_shading_rate_enums
// Extends: VkGraphicsPipelineCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineFragmentShadingRateEnumStateCreateInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    shadingRateType: VkFragmentShadingRateTypeNV,
    // Extern sync: false
    // Optional: false
    shadingRate: VkFragmentShadingRateNV,
    // Extern sync: false
    // Optional: false
    combinerOps: [2]VkFragmentShadingRateCombinerOpKHR = @import("std").mem.zeroes([2]VkFragmentShadingRateCombinerOpKHR),
};
// Extension: VK_KHR_acceleration_structure
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkAccelerationStructureBuildSizesInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    accelerationStructureSize: u64 = 0,
    // Extern sync: false
    // Optional: false
    updateScratchSize: u64 = 0,
    // Extern sync: false
    // Optional: false
    buildScratchSize: u64 = 0,
};
// Extension: VK_EXT_image_2d_view_of_3d
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceImage2DViewOf3DFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    image2DViewOf3D: u32 = 0,
    // Extern sync: false
    // Optional: false
    sampler2DViewOf3D: u32 = 0,
};
// Extension: VK_EXT_image_sliced_view_of_3d
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_SLICED_VIEW_OF_3D_FEATURES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    imageSlicedViewOf3D: u32 = 0,
};
// Extension: VK_EXT_attachment_feedback_loop_dynamic_state
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_FEATURES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    attachmentFeedbackLoopDynamicState: u32 = 0,
};
// Extension: VK_EXT_legacy_vertex_attributes
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_FEATURES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    legacyVertexAttributes: u32 = 0,
};
// Extension: VK_EXT_legacy_vertex_attributes
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_PROPERTIES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    nativeUnalignedPerformance: u32 = 0,
};
// Extension: VK_EXT_mutable_descriptor_type
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    mutableDescriptorType: u32 = 0,
};
// Extension: VK_VALVE_mutable_descriptor_type
pub const VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE = VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT;
// Extension: VK_EXT_mutable_descriptor_type
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkMutableDescriptorTypeListEXT = extern struct {
    // Extern sync: false
    // Optional: true
    descriptorTypeCount: u32 = 0,
    // Length member: descriptorTypeCount
    // Extern sync: false
    // Optional: false
    pDescriptorTypes: ?[*]const VkDescriptorType = null,
};
// Extension: VK_VALVE_mutable_descriptor_type
pub const VkMutableDescriptorTypeListVALVE = VkMutableDescriptorTypeListEXT;
// Extension: VK_EXT_mutable_descriptor_type
// Extends: VkDescriptorSetLayoutCreateInfo,VkDescriptorPoolCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkMutableDescriptorTypeCreateInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    mutableDescriptorTypeListCount: u32 = 0,
    // Length member: mutableDescriptorTypeListCount
    // Extern sync: false
    // Optional: false
    pMutableDescriptorTypeLists: ?[*]const VkMutableDescriptorTypeListEXT = null,
};
// Extension: VK_VALVE_mutable_descriptor_type
pub const VkMutableDescriptorTypeCreateInfoVALVE = VkMutableDescriptorTypeCreateInfoEXT;
// Extension: VK_EXT_depth_clip_control
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceDepthClipControlFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    depthClipControl: u32 = 0,
};
// Extension: VK_EXT_zero_initialize_device_memory
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_DEVICE_MEMORY_FEATURES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    zeroInitializeDeviceMemory: u32 = 0,
};
// Extension: VK_EXT_custom_resolve
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkBeginCustomResolveInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_BEGIN_CUSTOM_RESOLVE_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
};
// Extension: VK_EXT_custom_resolve
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceCustomResolveFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_RESOLVE_FEATURES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    customResolve: u32 = 0,
};
// Extension: VK_EXT_custom_resolve
// Extends: VkGraphicsPipelineCreateInfo,VkCommandBufferInheritanceInfo,VkShaderCreateInfoEXT
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkCustomResolveCreateInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_CUSTOM_RESOLVE_CREATE_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    customResolve: u32 = 0,
    // Extern sync: false
    // Optional: true
    colorAttachmentCount: u32 = 0,
    // Length member: colorAttachmentCount
    // Extern sync: false
    // Optional: false
    pColorAttachmentFormats: ?[*]const VkFormat = null,
    // Extern sync: false
    // Optional: false
    depthAttachmentFormat: VkFormat,
    // Extern sync: false
    // Optional: false
    stencilAttachmentFormat: VkFormat,
};
// Extension: VK_EXT_device_generated_commands
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    deviceGeneratedCommands: u32 = 0,
    // Extern sync: false
    // Optional: false
    dynamicGeneratedPipelineLayout: u32 = 0,
};
// Extension: VK_EXT_device_generated_commands
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    maxIndirectPipelineCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxIndirectShaderObjectCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxIndirectSequenceCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxIndirectCommandsTokenCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxIndirectCommandsTokenOffset: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxIndirectCommandsIndirectStride: u32 = 0,
    // Extern sync: false
    // Optional: false
    supportedIndirectCommandsInputModes: VkIndirectCommandsInputModeFlagsEXT = .{},
    // Extern sync: false
    // Optional: false
    supportedIndirectCommandsShaderStages: VkShaderStageFlags = .{},
    // Extern sync: false
    // Optional: false
    supportedIndirectCommandsShaderStagesPipelineBinding: VkShaderStageFlags = .{},
    // Extern sync: false
    // Optional: false
    supportedIndirectCommandsShaderStagesShaderBinding: VkShaderStageFlags = .{},
    // Extern sync: false
    // Optional: false
    deviceGeneratedCommandsTransformFeedback: u32 = 0,
    // Extern sync: false
    // Optional: false
    deviceGeneratedCommandsMultiDrawIndirectCount: u32 = 0,
};
// Extension: VK_EXT_device_generated_commands
// Extends: VkGeneratedCommandsInfoEXT,VkGeneratedCommandsMemoryRequirementsInfoEXT
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkGeneratedCommandsPipelineInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_GENERATED_COMMANDS_PIPELINE_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    pipeline: VkPipeline = .none,
};
// Extension: VK_EXT_device_generated_commands
// Extends: VkGeneratedCommandsInfoEXT,VkGeneratedCommandsMemoryRequirementsInfoEXT
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkGeneratedCommandsShaderInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_GENERATED_COMMANDS_SHADER_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    shaderCount: u32 = 0,
    // Length member: shaderCount
    // Extern sync: false
    // Optional: false
    pShaders: ?[*]const VkShaderEXT = null,
};
// Extension: VK_EXT_device_generated_commands
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkGeneratedCommandsMemoryRequirementsInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    indirectExecutionSet: VkIndirectExecutionSetEXT = .none,
    // Extern sync: false
    // Optional: false
    indirectCommandsLayout: VkIndirectCommandsLayoutEXT = .none,
    // Extern sync: false
    // Optional: false
    maxSequenceCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxDrawCount: u32 = 0,
};
// Extension: VK_EXT_device_generated_commands
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkIndirectExecutionSetPipelineInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_PIPELINE_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    initialPipeline: VkPipeline = .none,
    // Extern sync: false
    // Optional: false
    maxPipelineCount: u32 = 0,
};
// Extension: VK_EXT_device_generated_commands
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkIndirectExecutionSetShaderLayoutInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_SHADER_LAYOUT_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    setLayoutCount: u32 = 0,
    // Length member: setLayoutCount
    // Extern sync: false
    // Optional: false
    pSetLayouts: ?[*]const VkDescriptorSetLayout = null,
};
// Extension: VK_EXT_device_generated_commands
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkIndirectExecutionSetShaderInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_SHADER_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    shaderCount: u32 = 0,
    // Length member: shaderCount
    // Extern sync: false
    // Optional: false
    pInitialShaders: ?[*]const VkShaderEXT = null,
    // Length member: shaderCount
    // Extern sync: false
    // Optional: true
    pSetLayoutInfos: ?[*]const VkIndirectExecutionSetShaderLayoutInfoEXT = null,
    // Extern sync: false
    // Optional: false
    maxShaderCount: u32 = 0,
    // Extern sync: false
    // Optional: true
    pushConstantRangeCount: u32 = 0,
    // Length member: pushConstantRangeCount
    // Extern sync: false
    // Optional: false
    pPushConstantRanges: ?[*]const VkPushConstantRange = null,
};
// Extension: VK_EXT_device_generated_commands
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkIndirectExecutionSetCreateInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_CREATE_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    type: VkIndirectExecutionSetInfoTypeEXT,
    // Extern sync: false
    // Optional: false
    // Selector member: type (What union field is valid)
    info: VkIndirectExecutionSetInfoEXT,
};
// Extension: VK_EXT_device_generated_commands
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkGeneratedCommandsInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    shaderStages: VkShaderStageFlags = .{},
    // Extern sync: false
    // Optional: true
    indirectExecutionSet: VkIndirectExecutionSetEXT = .none,
    // Extern sync: false
    // Optional: false
    indirectCommandsLayout: VkIndirectCommandsLayoutEXT = .none,
    // Extern sync: false
    // Optional: false
    indirectAddress: u64 = 0,
    // Extern sync: false
    // Optional: false
    indirectAddressSize: u64 = 0,
    // Extern sync: false
    // Optional: true
    preprocessAddress: u64 = 0,
    // Extern sync: false
    // Optional: false
    preprocessSize: u64 = 0,
    // Extern sync: false
    // Optional: false
    maxSequenceCount: u32 = 0,
    // Extern sync: false
    // Optional: true
    sequenceCountAddress: u64 = 0,
    // Extern sync: false
    // Optional: false
    maxDrawCount: u32 = 0,
};
// Extension: VK_EXT_device_generated_commands
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkWriteIndirectExecutionSetPipelineEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_WRITE_INDIRECT_EXECUTION_SET_PIPELINE_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    index: u32 = 0,
    // Extern sync: false
    // Optional: false
    pipeline: VkPipeline = .none,
};
// Extension: VK_EXT_device_generated_commands
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkWriteIndirectExecutionSetShaderEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_WRITE_INDIRECT_EXECUTION_SET_SHADER_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    index: u32 = 0,
    // Extern sync: false
    // Optional: false
    shader: VkShaderEXT = .none,
};
// Extension: VK_EXT_device_generated_commands
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkIndirectCommandsLayoutCreateInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkIndirectCommandsLayoutUsageFlagsEXT = .{},
    // Extern sync: false
    // Optional: false
    shaderStages: VkShaderStageFlags = .{},
    // Extern sync: false
    // Optional: false
    indirectStride: u32 = 0,
    // Extern sync: false
    // Optional: true
    pipelineLayout: VkPipelineLayout = .none,
    // Extern sync: false
    // Optional: false
    tokenCount: u32 = 0,
    // Length member: tokenCount
    // Extern sync: false
    // Optional: false
    pTokens: ?[*]const VkIndirectCommandsLayoutTokenEXT = null,
};
// Extension: VK_EXT_device_generated_commands
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkIndirectCommandsLayoutTokenEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    type: VkIndirectCommandsTokenTypeEXT,
    // Extern sync: false
    // Optional: false
    // Selector member: type (What union field is valid)
    data: VkIndirectCommandsTokenDataEXT,
    // Extern sync: false
    // Optional: false
    offset: u32 = 0,
};
// Extension: VK_EXT_device_generated_commands
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDrawIndirectCountIndirectCommandEXT = extern struct {
    // Extern sync: false
    // Optional: false
    bufferAddress: u64 = 0,
    // Extern sync: false
    // Optional: false
    stride: u32 = 0,
    // Extern sync: false
    // Optional: false
    commandCount: u32 = 0,
};
// Extension: VK_EXT_device_generated_commands
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkIndirectCommandsVertexBufferTokenEXT = extern struct {
    // Extern sync: false
    // Optional: false
    vertexBindingUnit: u32 = 0,
};
// Extension: VK_EXT_device_generated_commands
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkBindVertexBufferIndirectCommandEXT = extern struct {
    // Extern sync: false
    // Optional: false
    bufferAddress: u64 = 0,
    // Extern sync: false
    // Optional: false
    size: u32 = 0,
    // Extern sync: false
    // Optional: false
    stride: u32 = 0,
};
// Extension: VK_EXT_device_generated_commands
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkIndirectCommandsIndexBufferTokenEXT = extern struct {
    // Extern sync: false
    // Optional: false
    mode: VkIndirectCommandsInputModeFlagsEXT = .{},
};
// Extension: VK_EXT_device_generated_commands
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkBindIndexBufferIndirectCommandEXT = extern struct {
    // Extern sync: false
    // Optional: false
    bufferAddress: u64 = 0,
    // Extern sync: false
    // Optional: false
    size: u32 = 0,
    // Extern sync: false
    // Optional: false
    indexType: VkIndexType,
};
// Extension: VK_EXT_device_generated_commands
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkIndirectCommandsPushConstantTokenEXT = extern struct {
    // Extern sync: false
    // Optional: false
    updateRange: VkPushConstantRange = .{},
};
// Extension: VK_EXT_device_generated_commands
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkIndirectCommandsExecutionSetTokenEXT = extern struct {
    // Extern sync: false
    // Optional: false
    type: VkIndirectExecutionSetInfoTypeEXT,
    // Extern sync: false
    // Optional: false
    shaderStages: VkShaderStageFlags = .{},
};
// Extension: VK_EXT_depth_clip_control
// Extends: VkPipelineViewportStateCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineViewportDepthClipControlCreateInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLIP_CONTROL_CREATE_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    negativeOneToOne: u32 = 0,
};
// Extension: VK_EXT_depth_clamp_control
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceDepthClampControlFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_CONTROL_FEATURES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    depthClampControl: u32 = 0,
};
// Extension: VK_EXT_depth_clamp_control
// Extends: VkPipelineViewportStateCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineViewportDepthClampControlCreateInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLAMP_CONTROL_CREATE_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    depthClampMode: VkDepthClampModeEXT,
    // Extern sync: false
    // Optional: true
    pDepthClampRange: ?*const VkDepthClampRangeEXT = null,
};
// Extension: VK_EXT_vertex_input_dynamic_state
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    vertexInputDynamicState: u32 = 0,
};
// Extension: VK_NV_external_memory_rdma
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceExternalMemoryRDMAFeaturesNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_RDMA_FEATURES_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    externalMemoryRDMA: u32 = 0,
};
// Extension: VK_KHR_shader_relaxed_extended_instruction
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_RELAXED_EXTENDED_INSTRUCTION_FEATURES_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    shaderRelaxedExtendedInstruction: u32 = 0,
};
// Extension: VK_EXT_vertex_input_dynamic_state
// Extension: VK_EXT_shader_object
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVertexInputBindingDescription2EXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VERTEX_INPUT_BINDING_DESCRIPTION_2_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    binding: u32 = 0,
    // Extern sync: false
    // Optional: false
    stride: u32 = 0,
    // Extern sync: false
    // Optional: false
    inputRate: VkVertexInputRate,
    // Extern sync: false
    // Optional: false
    divisor: u32 = 0,
};
// Extension: VK_EXT_vertex_input_dynamic_state
// Extension: VK_EXT_shader_object
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVertexInputAttributeDescription2EXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VERTEX_INPUT_ATTRIBUTE_DESCRIPTION_2_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: location of the shader vertex attrib
    location: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Vertex buffer binding id
    binding: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: format of source data
    format: VkFormat,
    // Extern sync: false
    // Optional: false
    // Comment: Offset of first element in bytes from base of vertex
    offset: u32 = 0,
};
// Extension: VK_EXT_color_write_enable
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceColorWriteEnableFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    colorWriteEnable: u32 = 0,
};
// Extension: VK_EXT_color_write_enable
// Extends: VkPipelineColorBlendStateCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineColorWriteCreateInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_COLOR_WRITE_CREATE_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    // Comment: # of pAttachments
    attachmentCount: u32 = 0,
    // Length member: attachmentCount
    // Extern sync: false
    // Optional: false
    pColorWriteEnables: ?[*]const u32 = null,
};
// Extension: VK_BASE_VERSION_1_3
// Extends: VkSubpassDependency2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkMemoryBarrier2 = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_MEMORY_BARRIER_2,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    srcStageMask: VkPipelineStageFlags2 = .{},
    // Extern sync: false
    // Optional: true
    srcAccessMask: VkAccessFlags2 = .{},
    // Extern sync: false
    // Optional: true
    dstStageMask: VkPipelineStageFlags2 = .{},
    // Extern sync: false
    // Optional: true
    dstAccessMask: VkAccessFlags2 = .{},
};
// Extension: VK_KHR_synchronization2
pub const VkMemoryBarrier2KHR = VkMemoryBarrier2;
// Extension: VK_BASE_VERSION_1_3
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImageMemoryBarrier2 = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    srcStageMask: VkPipelineStageFlags2 = .{},
    // Extern sync: false
    // Optional: true
    srcAccessMask: VkAccessFlags2 = .{},
    // Extern sync: false
    // Optional: true
    dstStageMask: VkPipelineStageFlags2 = .{},
    // Extern sync: false
    // Optional: true
    dstAccessMask: VkAccessFlags2 = .{},
    // Extern sync: false
    // Optional: false
    oldLayout: VkImageLayout,
    // Extern sync: false
    // Optional: false
    newLayout: VkImageLayout,
    // Extern sync: false
    // Optional: false
    srcQueueFamilyIndex: u32 = 0,
    // Extern sync: false
    // Optional: false
    dstQueueFamilyIndex: u32 = 0,
    // Extern sync: false
    // Optional: false
    image: VkImage = .none,
    // Extern sync: false
    // Optional: false
    subresourceRange: VkImageSubresourceRange = .{},
};
// Extension: VK_KHR_synchronization2
pub const VkImageMemoryBarrier2KHR = VkImageMemoryBarrier2;
// Extension: VK_BASE_VERSION_1_3
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkBufferMemoryBarrier2 = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    srcStageMask: VkPipelineStageFlags2 = .{},
    // Extern sync: false
    // Optional: true
    srcAccessMask: VkAccessFlags2 = .{},
    // Extern sync: false
    // Optional: true
    dstStageMask: VkPipelineStageFlags2 = .{},
    // Extern sync: false
    // Optional: true
    dstAccessMask: VkAccessFlags2 = .{},
    // Extern sync: false
    // Optional: false
    srcQueueFamilyIndex: u32 = 0,
    // Extern sync: false
    // Optional: false
    dstQueueFamilyIndex: u32 = 0,
    // Extern sync: false
    // Optional: false
    buffer: VkBuffer = .none,
    // Extern sync: false
    // Optional: false
    offset: u64 = 0,
    // Extern sync: false
    // Optional: false
    size: u64 = 0,
};
// Extension: VK_KHR_synchronization2
pub const VkBufferMemoryBarrier2KHR = VkBufferMemoryBarrier2;
// Extension: VK_KHR_maintenance8
// Extends: VkSubpassDependency2,VkBufferMemoryBarrier2,VkImageMemoryBarrier2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkMemoryBarrierAccessFlags3KHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_MEMORY_BARRIER_ACCESS_FLAGS_3_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    srcAccessMask3: VkAccessFlags3KHR = .{},
    // Extern sync: false
    // Optional: true
    dstAccessMask3: VkAccessFlags3KHR = .{},
};
// Extension: VK_BASE_VERSION_1_3
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDependencyInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_DEPENDENCY_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    dependencyFlags: VkDependencyFlags = .{},
    // Extern sync: false
    // Optional: true
    memoryBarrierCount: u32 = 0,
    // Length member: memoryBarrierCount
    // Extern sync: false
    // Optional: false
    pMemoryBarriers: ?[*]const VkMemoryBarrier2 = null,
    // Extern sync: false
    // Optional: true
    bufferMemoryBarrierCount: u32 = 0,
    // Length member: bufferMemoryBarrierCount
    // Extern sync: false
    // Optional: false
    pBufferMemoryBarriers: ?[*]const VkBufferMemoryBarrier2 = null,
    // Extern sync: false
    // Optional: true
    imageMemoryBarrierCount: u32 = 0,
    // Length member: imageMemoryBarrierCount
    // Extern sync: false
    // Optional: false
    pImageMemoryBarriers: ?[*]const VkImageMemoryBarrier2 = null,
};
// Extension: VK_KHR_synchronization2
pub const VkDependencyInfoKHR = VkDependencyInfo;
// Extension: VK_BASE_VERSION_1_3
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSemaphoreSubmitInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    semaphore: VkSemaphore = .none,
    // Extern sync: false
    // Optional: false
    value: u64 = 0,
    // Extern sync: false
    // Optional: true
    stageMask: VkPipelineStageFlags2 = .{},
    // Extern sync: false
    // Optional: false
    deviceIndex: u32 = 0,
};
// Extension: VK_KHR_synchronization2
pub const VkSemaphoreSubmitInfoKHR = VkSemaphoreSubmitInfo;
// Extension: VK_BASE_VERSION_1_3
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkCommandBufferSubmitInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    commandBuffer: VkCommandBuffer = .none,
    // Extern sync: false
    // Optional: false
    deviceMask: u32 = 0,
};
// Extension: VK_KHR_synchronization2
pub const VkCommandBufferSubmitInfoKHR = VkCommandBufferSubmitInfo;
// Extension: VK_BASE_VERSION_1_3
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSubmitInfo2 = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_SUBMIT_INFO_2,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkSubmitFlags = .{},
    // Extern sync: false
    // Optional: true
    waitSemaphoreInfoCount: u32 = 0,
    // Length member: waitSemaphoreInfoCount
    // Extern sync: false
    // Optional: false
    pWaitSemaphoreInfos: ?[*]const VkSemaphoreSubmitInfo = null,
    // Extern sync: false
    // Optional: true
    commandBufferInfoCount: u32 = 0,
    // Length member: commandBufferInfoCount
    // Extern sync: false
    // Optional: false
    pCommandBufferInfos: ?[*]const VkCommandBufferSubmitInfo = null,
    // Extern sync: false
    // Optional: true
    signalSemaphoreInfoCount: u32 = 0,
    // Length member: signalSemaphoreInfoCount
    // Extern sync: false
    // Optional: false
    pSignalSemaphoreInfos: ?[*]const VkSemaphoreSubmitInfo = null,
};
// Extension: VK_KHR_synchronization2
pub const VkSubmitInfo2KHR = VkSubmitInfo2;
// Extension: VK_NV_device_diagnostic_checkpoints
// Extends: VkQueueFamilyProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkQueueFamilyCheckpointProperties2NV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    checkpointExecutionStageMask: VkPipelineStageFlags2 = .{},
};
// Extension: VK_NV_device_diagnostic_checkpoints
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkCheckpointData2NV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_CHECKPOINT_DATA_2_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    stage: VkPipelineStageFlags2 = .{},
    // Extern sync: false
    // Optional: false
    pCheckpointMarker: ?*anyopaque = null,
};
// Extension: VK_BASE_VERSION_1_3
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceSynchronization2Features = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    synchronization2: u32 = 0,
};
// Extension: VK_KHR_synchronization2
pub const VkPhysicalDeviceSynchronization2FeaturesKHR = VkPhysicalDeviceSynchronization2Features;
// Extension: VK_KHR_unified_image_layouts
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceUnifiedImageLayoutsFeaturesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFIED_IMAGE_LAYOUTS_FEATURES_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    unifiedImageLayouts: u32 = 0,
    // Extern sync: false
    // Optional: false
    unifiedImageLayoutsVideo: u32 = 0,
};
// Extension: VK_BASE_VERSION_1_4
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceHostImageCopyFeatures = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    hostImageCopy: u32 = 0,
};
// Extension: VK_EXT_host_image_copy
pub const VkPhysicalDeviceHostImageCopyFeaturesEXT = VkPhysicalDeviceHostImageCopyFeatures;
// Extension: VK_BASE_VERSION_1_4
// Extends: VkPhysicalDeviceProperties2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceHostImageCopyProperties = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_PROPERTIES,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: true
    copySrcLayoutCount: u32 = 0,
    // Length member: copySrcLayoutCount
    // Extern sync: false
    // Optional: true
    pCopySrcLayouts: ?[*]VkImageLayout = null,
    // Extern sync: false
    // Optional: true
    copyDstLayoutCount: u32 = 0,
    // Length member: copyDstLayoutCount
    // Extern sync: false
    // Optional: true
    pCopyDstLayouts: ?[*]VkImageLayout = null,
    // Extern sync: false
    // Optional: true
    optimalTilingLayoutUUID: [VK_UUID_SIZE]u8 = @import("std").mem.zeroes([VK_UUID_SIZE]u8),
    // Extern sync: false
    // Optional: false
    identicalMemoryTypeRequirements: u32 = 0,
};
// Extension: VK_EXT_host_image_copy
pub const VkPhysicalDeviceHostImageCopyPropertiesEXT = VkPhysicalDeviceHostImageCopyProperties;
// Extension: VK_BASE_VERSION_1_4
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkMemoryToImageCopy = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_MEMORY_TO_IMAGE_COPY,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    pHostPointer: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: Specified in texels
    memoryRowLength: u32 = 0,
    // Extern sync: false
    // Optional: false
    memoryImageHeight: u32 = 0,
    // Extern sync: false
    // Optional: false
    imageSubresource: VkImageSubresourceLayers = .{},
    // Extern sync: false
    // Optional: false
    imageOffset: VkOffset3D = .{},
    // Extern sync: false
    // Optional: false
    imageExtent: VkExtent3D = .{},
};
// Extension: VK_EXT_host_image_copy
pub const VkMemoryToImageCopyEXT = VkMemoryToImageCopy;
// Extension: VK_BASE_VERSION_1_4
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImageToMemoryCopy = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_IMAGE_TO_MEMORY_COPY,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    pHostPointer: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: Specified in texels
    memoryRowLength: u32 = 0,
    // Extern sync: false
    // Optional: false
    memoryImageHeight: u32 = 0,
    // Extern sync: false
    // Optional: false
    imageSubresource: VkImageSubresourceLayers = .{},
    // Extern sync: false
    // Optional: false
    imageOffset: VkOffset3D = .{},
    // Extern sync: false
    // Optional: false
    imageExtent: VkExtent3D = .{},
};
// Extension: VK_EXT_host_image_copy
pub const VkImageToMemoryCopyEXT = VkImageToMemoryCopy;
// Extension: VK_BASE_VERSION_1_4
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkCopyMemoryToImageInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_COPY_MEMORY_TO_IMAGE_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkHostImageCopyFlags = .{},
    // Extern sync: false
    // Optional: false
    dstImage: VkImage = .none,
    // Extern sync: false
    // Optional: false
    dstImageLayout: VkImageLayout,
    // Extern sync: false
    // Optional: false
    regionCount: u32 = 0,
    // Length member: regionCount
    // Extern sync: false
    // Optional: false
    pRegions: ?[*]const VkMemoryToImageCopy = null,
};
// Extension: VK_EXT_host_image_copy
pub const VkCopyMemoryToImageInfoEXT = VkCopyMemoryToImageInfo;
// Extension: VK_BASE_VERSION_1_4
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkCopyImageToMemoryInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_COPY_IMAGE_TO_MEMORY_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkHostImageCopyFlags = .{},
    // Extern sync: false
    // Optional: false
    srcImage: VkImage = .none,
    // Extern sync: false
    // Optional: false
    srcImageLayout: VkImageLayout,
    // Extern sync: false
    // Optional: false
    regionCount: u32 = 0,
    // Length member: regionCount
    // Extern sync: false
    // Optional: false
    pRegions: ?[*]const VkImageToMemoryCopy = null,
};
// Extension: VK_EXT_host_image_copy
pub const VkCopyImageToMemoryInfoEXT = VkCopyImageToMemoryInfo;
// Extension: VK_BASE_VERSION_1_4
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkCopyImageToImageInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_COPY_IMAGE_TO_IMAGE_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkHostImageCopyFlags = .{},
    // Extern sync: false
    // Optional: false
    srcImage: VkImage = .none,
    // Extern sync: false
    // Optional: false
    srcImageLayout: VkImageLayout,
    // Extern sync: false
    // Optional: false
    dstImage: VkImage = .none,
    // Extern sync: false
    // Optional: false
    dstImageLayout: VkImageLayout,
    // Extern sync: false
    // Optional: false
    regionCount: u32 = 0,
    // Length member: regionCount
    // Extern sync: false
    // Optional: false
    pRegions: ?[*]const VkImageCopy2 = null,
};
// Extension: VK_EXT_host_image_copy
pub const VkCopyImageToImageInfoEXT = VkCopyImageToImageInfo;
// Extension: VK_BASE_VERSION_1_4
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkHostImageLayoutTransitionInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_HOST_IMAGE_LAYOUT_TRANSITION_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    image: VkImage = .none,
    // Extern sync: false
    // Optional: false
    oldLayout: VkImageLayout,
    // Extern sync: false
    // Optional: false
    newLayout: VkImageLayout,
    // Extern sync: false
    // Optional: false
    subresourceRange: VkImageSubresourceRange = .{},
};
// Extension: VK_EXT_host_image_copy
pub const VkHostImageLayoutTransitionInfoEXT = VkHostImageLayoutTransitionInfo;
// Extension: VK_BASE_VERSION_1_4
// Extends: VkSubresourceLayout2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkSubresourceHostMemcpySize = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_SUBRESOURCE_HOST_MEMCPY_SIZE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: Specified in bytes
    size: u64 = 0,
};
// Extension: VK_EXT_host_image_copy
pub const VkSubresourceHostMemcpySizeEXT = VkSubresourceHostMemcpySize;
// Extension: VK_BASE_VERSION_1_4
// Extends: VkImageFormatProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkHostImageCopyDevicePerformanceQuery = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_HOST_IMAGE_COPY_DEVICE_PERFORMANCE_QUERY,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: Specifies if device access is optimal
    optimalDeviceAccess: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Specifies if memory layout is identical
    identicalMemoryLayout: u32 = 0,
};
// Extension: VK_EXT_host_image_copy
pub const VkHostImageCopyDevicePerformanceQueryEXT = VkHostImageCopyDevicePerformanceQuery;
// Extension: VKSC_VERSION_1_0
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceVulkanSC10Properties = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_SC_1_0_PROPERTIES,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    deviceNoDynamicHostAllocations: u32 = 0,
    // Extern sync: false
    // Optional: false
    deviceDestroyFreesMemory: u32 = 0,
    // Extern sync: false
    // Optional: false
    commandPoolMultipleCommandBuffersRecording: u32 = 0,
    // Extern sync: false
    // Optional: false
    commandPoolResetCommandBuffer: u32 = 0,
    // Extern sync: false
    // Optional: false
    commandBufferSimultaneousUse: u32 = 0,
    // Extern sync: false
    // Optional: false
    secondaryCommandBufferNullOrImagelessFramebuffer: u32 = 0,
    // Extern sync: false
    // Optional: false
    recycleDescriptorSetMemory: u32 = 0,
    // Extern sync: false
    // Optional: false
    recyclePipelineMemory: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxRenderPassSubpasses: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxRenderPassDependencies: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxSubpassInputAttachments: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxSubpassPreserveAttachments: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxFramebufferAttachments: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxDescriptorSetLayoutBindings: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxQueryFaultCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxCallbackFaultCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxCommandPoolCommandBuffers: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxCommandBufferSize: u64 = 0,
};
// Extension: VKSC_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelinePoolSize = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_POOL_SIZE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    poolEntrySize: u64 = 0,
    // Extern sync: false
    // Optional: false
    poolEntryCount: u32 = 0,
};
// Extension: VKSC_VERSION_1_0
// Extends: VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: true
pub const VkDeviceObjectReservationCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_DEVICE_OBJECT_RESERVATION_CREATE_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    pipelineCacheCreateInfoCount: u32 = 0,
    // Length member: pipelineCacheCreateInfoCount
    // Extern sync: false
    // Optional: false
    pPipelineCacheCreateInfos: ?[*]const VkPipelineCacheCreateInfo = null,
    // Extern sync: false
    // Optional: true
    pipelinePoolSizeCount: u32 = 0,
    // Length member: pipelinePoolSizeCount
    // Extern sync: false
    // Optional: false
    pPipelinePoolSizes: ?[*]const VkPipelinePoolSize = null,
    // Extern sync: false
    // Optional: true
    semaphoreRequestCount: u32 = 0,
    // Extern sync: false
    // Optional: true
    commandBufferRequestCount: u32 = 0,
    // Extern sync: false
    // Optional: true
    fenceRequestCount: u32 = 0,
    // Extern sync: false
    // Optional: true
    deviceMemoryRequestCount: u32 = 0,
    // Extern sync: false
    // Optional: true
    bufferRequestCount: u32 = 0,
    // Extern sync: false
    // Optional: true
    imageRequestCount: u32 = 0,
    // Extern sync: false
    // Optional: true
    eventRequestCount: u32 = 0,
    // Extern sync: false
    // Optional: true
    queryPoolRequestCount: u32 = 0,
    // Extern sync: false
    // Optional: true
    bufferViewRequestCount: u32 = 0,
    // Extern sync: false
    // Optional: true
    imageViewRequestCount: u32 = 0,
    // Extern sync: false
    // Optional: true
    layeredImageViewRequestCount: u32 = 0,
    // Extern sync: false
    // Optional: true
    pipelineCacheRequestCount: u32 = 0,
    // Extern sync: false
    // Optional: true
    pipelineLayoutRequestCount: u32 = 0,
    // Extern sync: false
    // Optional: true
    renderPassRequestCount: u32 = 0,
    // Extern sync: false
    // Optional: true
    graphicsPipelineRequestCount: u32 = 0,
    // Extern sync: false
    // Optional: true
    computePipelineRequestCount: u32 = 0,
    // Extern sync: false
    // Optional: true
    descriptorSetLayoutRequestCount: u32 = 0,
    // Extern sync: false
    // Optional: true
    samplerRequestCount: u32 = 0,
    // Extern sync: false
    // Optional: true
    descriptorPoolRequestCount: u32 = 0,
    // Extern sync: false
    // Optional: true
    descriptorSetRequestCount: u32 = 0,
    // Extern sync: false
    // Optional: true
    framebufferRequestCount: u32 = 0,
    // Extern sync: false
    // Optional: true
    commandPoolRequestCount: u32 = 0,
    // Extern sync: false
    // Optional: true
    samplerYcbcrConversionRequestCount: u32 = 0,
    // Extern sync: false
    // Optional: true
    surfaceRequestCount: u32 = 0,
    // Extern sync: false
    // Optional: true
    swapchainRequestCount: u32 = 0,
    // Extern sync: false
    // Optional: true
    displayModeRequestCount: u32 = 0,
    // Extern sync: false
    // Optional: true
    subpassDescriptionRequestCount: u32 = 0,
    // Extern sync: false
    // Optional: true
    attachmentDescriptionRequestCount: u32 = 0,
    // Extern sync: false
    // Optional: true
    descriptorSetLayoutBindingRequestCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    descriptorSetLayoutBindingLimit: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxImageViewMipLevels: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxImageViewArrayLayers: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxLayeredImageViewMipLevels: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxOcclusionQueriesPerPool: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxPipelineStatisticsQueriesPerPool: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxTimestampQueriesPerPool: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxImmutableSamplersPerDescriptorSetLayout: u32 = 0,
};
// Extension: VKSC_VERSION_1_0
// Extends: VkCommandPoolCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkCommandPoolMemoryReservationCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_COMMAND_POOL_MEMORY_RESERVATION_CREATE_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    commandPoolReservedSize: u64 = 0,
    // Extern sync: false
    // Optional: false
    commandPoolMaxCommandBuffers: u32 = 0,
};
// Extension: VKSC_VERSION_1_0
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkCommandPoolMemoryConsumption = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_COMMAND_POOL_MEMORY_CONSUMPTION,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    commandPoolAllocated: u64 = 0,
    // Extern sync: false
    // Optional: false
    commandPoolReservedSize: u64 = 0,
    // Extern sync: false
    // Optional: false
    commandBufferAllocated: u64 = 0,
};
// Extension: VKSC_VERSION_1_0
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceVulkanSC10Features = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_SC_1_0_FEATURES,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    shaderAtomicInstructions: u32 = 0,
};
// Extension: VK_EXT_primitives_generated_query
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    primitivesGeneratedQuery: u32 = 0,
    // Extern sync: false
    // Optional: false
    primitivesGeneratedQueryWithRasterizerDiscard: u32 = 0,
    // Extern sync: false
    // Optional: false
    primitivesGeneratedQueryWithNonZeroStreams: u32 = 0,
};
// Extension: VK_EXT_legacy_dithering
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceLegacyDitheringFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    legacyDithering: u32 = 0,
};
// Extension: VK_EXT_multisampled_render_to_single_sampled
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    multisampledRenderToSingleSampled: u32 = 0,
};
// Extension: VK_KHR_present_id2
// Extends: VkSurfaceCapabilities2KHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSurfaceCapabilitiesPresentId2KHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_ID_2_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    presentId2Supported: u32 = 0,
};
// Extension: VK_KHR_present_wait2
// Extends: VkSurfaceCapabilities2KHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSurfaceCapabilitiesPresentWait2KHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_WAIT_2_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    presentWait2Supported: u32 = 0,
};
// Extension: VK_EXT_multisampled_render_to_single_sampled
// Extends: VkFormatProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkSubpassResolvePerformanceQueryEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_SUBPASS_RESOLVE_PERFORMANCE_QUERY_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    optimal: u32 = 0,
};
// Extension: VK_EXT_multisampled_render_to_single_sampled
// Extends: VkSubpassDescription2,VkRenderingInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkMultisampledRenderToSingleSampledInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    multisampledRenderToSingleSampledEnable: u32 = 0,
    // Extern sync: false
    // Optional: false
    rasterizationSamples: VkSampleCountFlags = .{},
};
// Extension: VK_COMPUTE_VERSION_1_4
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDevicePipelineProtectedAccessFeatures = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    pipelineProtectedAccess: u32 = 0,
};
// Extension: VK_EXT_pipeline_protected_access
pub const VkPhysicalDevicePipelineProtectedAccessFeaturesEXT = VkPhysicalDevicePipelineProtectedAccessFeatures;
// Extension: VK_KHR_video_queue
// Extends: VkQueueFamilyProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkQueueFamilyVideoPropertiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_QUEUE_FAMILY_VIDEO_PROPERTIES_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    videoCodecOperations: VkVideoCodecOperationFlagsKHR = .{},
};
// Extension: VK_KHR_video_queue
// Extends: VkQueueFamilyProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkQueueFamilyQueryResultStatusPropertiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_QUEUE_FAMILY_QUERY_RESULT_STATUS_PROPERTIES_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    queryResultStatusSupport: u32 = 0,
};
// Extension: VK_KHR_video_queue
// Extends: VkPhysicalDeviceImageFormatInfo2,VkPhysicalDeviceVideoFormatInfoKHR,VkImageCreateInfo,VkBufferCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoProfileListInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    profileCount: u32 = 0,
    // Length member: profileCount
    // Extern sync: false
    // Optional: false
    pProfiles: ?[*]const VkVideoProfileInfoKHR = null,
};
// Extension: VK_KHR_video_queue
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceVideoFormatInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_FORMAT_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    imageUsage: VkImageUsageFlags = .{},
};
// Extension: VK_KHR_video_queue
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkVideoFormatPropertiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_FORMAT_PROPERTIES_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    format: VkFormat,
    // Extern sync: false
    // Optional: false
    componentMapping: VkComponentMapping = .{},
    // Extern sync: false
    // Optional: false
    imageCreateFlags: VkImageCreateFlags = .{},
    // Extern sync: false
    // Optional: false
    imageType: VkImageType,
    // Extern sync: false
    // Optional: false
    imageTiling: VkImageTiling,
    // Extern sync: false
    // Optional: false
    imageUsageFlags: VkImageUsageFlags = .{},
};
// Extension: VK_KHR_video_encode_quantization_map
// Extends: VkVideoCapabilitiesKHR
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeQuantizationMapCapabilitiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_CAPABILITIES_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    maxQuantizationMapExtent: VkExtent2D = .{},
};
// Extension: VK_KHR_video_encode_quantization_map
// Extends: VkVideoCapabilitiesKHR
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeH264QuantizationMapCapabilitiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_QUANTIZATION_MAP_CAPABILITIES_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    minQpDelta: i32 = 0,
    // Extern sync: false
    // Optional: false
    maxQpDelta: i32 = 0,
};
// Extension: VK_KHR_video_encode_quantization_map
// Extends: VkVideoCapabilitiesKHR
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeH265QuantizationMapCapabilitiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_QUANTIZATION_MAP_CAPABILITIES_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    minQpDelta: i32 = 0,
    // Extern sync: false
    // Optional: false
    maxQpDelta: i32 = 0,
};
// Extension: VK_KHR_video_encode_quantization_map
// Extends: VkVideoCapabilitiesKHR
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeAV1QuantizationMapCapabilitiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_QUANTIZATION_MAP_CAPABILITIES_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    minQIndexDelta: i32 = 0,
    // Extern sync: false
    // Optional: false
    maxQIndexDelta: i32 = 0,
};
// Extension: VK_KHR_video_encode_quantization_map
// Extends: VkVideoFormatPropertiesKHR
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkVideoFormatQuantizationMapPropertiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_FORMAT_QUANTIZATION_MAP_PROPERTIES_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    quantizationMapTexelSize: VkExtent2D = .{},
};
// Extension: VK_KHR_video_encode_quantization_map
// Extends: VkVideoFormatPropertiesKHR
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkVideoFormatH265QuantizationMapPropertiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_FORMAT_H265_QUANTIZATION_MAP_PROPERTIES_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    compatibleCtbSizes: VkVideoEncodeH265CtbSizeFlagsKHR = .{},
};
// Extension: VK_KHR_video_encode_quantization_map
// Extends: VkVideoFormatPropertiesKHR
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkVideoFormatAV1QuantizationMapPropertiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_FORMAT_AV1_QUANTIZATION_MAP_PROPERTIES_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    compatibleSuperblockSizes: VkVideoEncodeAV1SuperblockSizeFlagsKHR = .{},
};
// Extension: VK_KHR_video_queue
// Extends: VkQueryPoolCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoProfileInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_PROFILE_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    videoCodecOperation: VkVideoCodecOperationFlagsKHR = .{},
    // Extern sync: false
    // Optional: false
    chromaSubsampling: VkVideoChromaSubsamplingFlagsKHR = .{},
    // Extern sync: false
    // Optional: false
    lumaBitDepth: VkVideoComponentBitDepthFlagsKHR = .{},
    // Extern sync: false
    // Optional: true
    chromaBitDepth: VkVideoComponentBitDepthFlagsKHR = .{},
};
// Extension: VK_KHR_video_queue
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkVideoCapabilitiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_CAPABILITIES_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    flags: VkVideoCapabilityFlagsKHR = .{},
    // Extern sync: false
    // Optional: false
    minBitstreamBufferOffsetAlignment: u64 = 0,
    // Extern sync: false
    // Optional: false
    minBitstreamBufferSizeAlignment: u64 = 0,
    // Extern sync: false
    // Optional: false
    pictureAccessGranularity: VkExtent2D = .{},
    // Extern sync: false
    // Optional: false
    minCodedExtent: VkExtent2D = .{},
    // Extern sync: false
    // Optional: false
    maxCodedExtent: VkExtent2D = .{},
    // Extern sync: false
    // Optional: false
    maxDpbSlots: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxActiveReferencePictures: u32 = 0,
    // Extern sync: false
    // Optional: false
    stdHeaderVersion: VkExtensionProperties = .{},
};
// Extension: VK_KHR_video_queue
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkVideoSessionMemoryRequirementsKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_SESSION_MEMORY_REQUIREMENTS_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    memoryBindIndex: u32 = 0,
    // Extern sync: false
    // Optional: false
    memoryRequirements: VkMemoryRequirements = .{},
};
// Extension: VK_KHR_video_queue
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkBindVideoSessionMemoryInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_BIND_VIDEO_SESSION_MEMORY_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    memoryBindIndex: u32 = 0,
    // Extern sync: false
    // Optional: false
    memory: VkDeviceMemory = .none,
    // Extern sync: false
    // Optional: false
    memoryOffset: u64 = 0,
    // Extern sync: false
    // Optional: false
    memorySize: u64 = 0,
};
// Extension: VK_KHR_video_queue
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoPictureResourceInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_PICTURE_RESOURCE_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: The offset to be used for the picture resource, currently only used in field mode
    codedOffset: VkOffset2D = .{},
    // Extern sync: false
    // Optional: false
    // Comment: The extent to be used for the picture resource
    codedExtent: VkExtent2D = .{},
    // Extern sync: false
    // Optional: false
    // Comment: The first array layer to be accessed for the Decode or Encode Operations
    baseArrayLayer: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: The ImageView binding of the resource
    imageViewBinding: VkImageView = .none,
};
// Extension: VK_KHR_video_queue
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoReferenceSlotInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_REFERENCE_SLOT_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: The reference slot index
    slotIndex: i32 = 0,
    // Extern sync: false
    // Optional: true
    // Comment: The reference picture resource
    pPictureResource: ?*const VkVideoPictureResourceInfoKHR = null,
};
// Extension: VK_KHR_video_decode_queue
// Extends: VkVideoCapabilitiesKHR
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkVideoDecodeCapabilitiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_DECODE_CAPABILITIES_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    flags: VkVideoDecodeCapabilityFlagsKHR = .{},
};
// Extension: VK_KHR_video_decode_queue
// Extends: VkVideoProfileInfoKHR,VkQueryPoolCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoDecodeUsageInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_DECODE_USAGE_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    videoUsageHints: VkVideoDecodeUsageFlagsKHR = .{},
};
// Extension: VK_KHR_video_decode_queue
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoDecodeInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_DECODE_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkVideoDecodeFlagsKHR = .{},
    // Extern sync: false
    // Optional: false
    srcBuffer: VkBuffer = .none,
    // Extern sync: false
    // Optional: false
    srcBufferOffset: u64 = 0,
    // Extern sync: false
    // Optional: false
    srcBufferRange: u64 = 0,
    // Extern sync: false
    // Optional: false
    dstPictureResource: VkVideoPictureResourceInfoKHR = .{},
    // Extern sync: false
    // Optional: true
    pSetupReferenceSlot: ?*const VkVideoReferenceSlotInfoKHR = null,
    // Extern sync: false
    // Optional: true
    referenceSlotCount: u32 = 0,
    // Length member: referenceSlotCount
    // Extern sync: false
    // Optional: false
    pReferenceSlots: ?[*]const VkVideoReferenceSlotInfoKHR = null,
};
// Extension: VK_KHR_video_maintenance1
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceVideoMaintenance1FeaturesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_1_FEATURES_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    videoMaintenance1: u32 = 0,
};
// Extension: VK_KHR_video_maintenance2
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceVideoMaintenance2FeaturesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_2_FEATURES_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    videoMaintenance2: u32 = 0,
};
// Extension: VK_KHR_video_maintenance1
// Extends: VkVideoDecodeInfoKHR,VkVideoEncodeInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoInlineQueryInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_INLINE_QUERY_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    queryPool: VkQueryPool = .none,
    // Extern sync: false
    // Optional: false
    firstQuery: u32 = 0,
    // Extern sync: false
    // Optional: false
    queryCount: u32 = 0,
};
// Extension: VK_KHR_video_decode_h264
// Extends: VkVideoProfileInfoKHR,VkQueryPoolCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoDecodeH264ProfileInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PROFILE_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Extern sync: false
    // Optional: true
    pictureLayout: VkVideoDecodeH264PictureLayoutFlagsKHR = .{},
};
// Extension: VK_KHR_video_decode_h264
// Extends: VkVideoCapabilitiesKHR
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkVideoDecodeH264CapabilitiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_CAPABILITIES_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Extern sync: false
    // Optional: false
    fieldOffsetGranularity: VkOffset2D = .{},
};
// Extension: VK_KHR_video_decode_h264
// Extends: VkVideoSessionParametersUpdateInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoDecodeH264SessionParametersAddInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    stdSPSCount: u32 = 0,
    // Length member: stdSPSCount
    // Extern sync: false
    // Optional: false
    pStdSPSs: ?[*]const StdVideoH264SequenceParameterSet = null,
    // Extern sync: false
    // Optional: true
    stdPPSCount: u32 = 0,
    // Length member: stdPPSCount
    // Extern sync: false
    // Optional: false
    // Comment: List of Picture Parameters associated with the spsStd, above
    pStdPPSs: ?[*]const StdVideoH264PictureParameterSet = null,
};
// Extension: VK_KHR_video_decode_h264
// Extends: VkVideoSessionParametersCreateInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoDecodeH264SessionParametersCreateInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    maxStdSPSCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxStdPPSCount: u32 = 0,
    // Extern sync: false
    // Optional: true
    pParametersAddInfo: ?*const VkVideoDecodeH264SessionParametersAddInfoKHR = null,
};
// Extension: VK_KHR_video_maintenance2
// Extends: VkVideoDecodeInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoDecodeH264InlineSessionParametersInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_INLINE_SESSION_PARAMETERS_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    pStdSPS: ?*const StdVideoH264SequenceParameterSet = null,
    // Extern sync: false
    // Optional: true
    pStdPPS: ?*const StdVideoH264PictureParameterSet = null,
};
// Extension: VK_KHR_video_decode_h264
// Extends: VkVideoDecodeInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoDecodeH264PictureInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PICTURE_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    pStdPictureInfo: ?*const StdVideoDecodeH264PictureInfo = null,
    // Extern sync: false
    // Optional: false
    sliceCount: u32 = 0,
    // Length member: sliceCount
    // Extern sync: false
    // Optional: false
    pSliceOffsets: ?[*]const u32 = null,
};
// Extension: VK_KHR_video_decode_h264
// Extends: VkVideoReferenceSlotInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoDecodeH264DpbSlotInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_DPB_SLOT_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    pStdReferenceInfo: ?*const StdVideoDecodeH264ReferenceInfo = null,
};
// Extension: VK_KHR_video_decode_h265
// Extends: VkVideoProfileInfoKHR,VkQueryPoolCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoDecodeH265ProfileInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PROFILE_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
};
// Extension: VK_KHR_video_decode_h265
// Extends: VkVideoCapabilitiesKHR
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkVideoDecodeH265CapabilitiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_CAPABILITIES_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
};
// Extension: VK_KHR_video_decode_h265
// Extends: VkVideoSessionParametersUpdateInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoDecodeH265SessionParametersAddInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    stdVPSCount: u32 = 0,
    // Length member: stdVPSCount
    // Extern sync: false
    // Optional: false
    pStdVPSs: ?[*]const StdVideoH265VideoParameterSet = null,
    // Extern sync: false
    // Optional: true
    stdSPSCount: u32 = 0,
    // Length member: stdSPSCount
    // Extern sync: false
    // Optional: false
    pStdSPSs: ?[*]const StdVideoH265SequenceParameterSet = null,
    // Extern sync: false
    // Optional: true
    stdPPSCount: u32 = 0,
    // Length member: stdPPSCount
    // Extern sync: false
    // Optional: false
    // Comment: List of Picture Parameters associated with the spsStd, above
    pStdPPSs: ?[*]const StdVideoH265PictureParameterSet = null,
};
// Extension: VK_KHR_video_decode_h265
// Extends: VkVideoSessionParametersCreateInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoDecodeH265SessionParametersCreateInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    maxStdVPSCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxStdSPSCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxStdPPSCount: u32 = 0,
    // Extern sync: false
    // Optional: true
    pParametersAddInfo: ?*const VkVideoDecodeH265SessionParametersAddInfoKHR = null,
};
// Extension: VK_KHR_video_maintenance2
// Extends: VkVideoDecodeInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoDecodeH265InlineSessionParametersInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_INLINE_SESSION_PARAMETERS_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    pStdVPS: ?*const StdVideoH265VideoParameterSet = null,
    // Extern sync: false
    // Optional: true
    pStdSPS: ?*const StdVideoH265SequenceParameterSet = null,
    // Extern sync: false
    // Optional: true
    pStdPPS: ?*const StdVideoH265PictureParameterSet = null,
};
// Extension: VK_KHR_video_decode_h265
// Extends: VkVideoDecodeInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoDecodeH265PictureInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PICTURE_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    pStdPictureInfo: ?*const StdVideoDecodeH265PictureInfo = null,
    // Extern sync: false
    // Optional: false
    sliceSegmentCount: u32 = 0,
    // Length member: sliceSegmentCount
    // Extern sync: false
    // Optional: false
    pSliceSegmentOffsets: ?[*]const u32 = null,
};
// Extension: VK_KHR_video_decode_h265
// Extends: VkVideoReferenceSlotInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoDecodeH265DpbSlotInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_DPB_SLOT_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    pStdReferenceInfo: ?*const StdVideoDecodeH265ReferenceInfo = null,
};
// Extension: VK_KHR_video_decode_vp9
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceVideoDecodeVP9FeaturesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_DECODE_VP9_FEATURES_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    videoDecodeVP9: u32 = 0,
};
// Extension: VK_KHR_video_decode_vp9
// Extends: VkVideoProfileInfoKHR,VkQueryPoolCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoDecodeVP9ProfileInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_DECODE_VP9_PROFILE_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
};
// Extension: VK_KHR_video_decode_vp9
// Extends: VkVideoCapabilitiesKHR
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkVideoDecodeVP9CapabilitiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_DECODE_VP9_CAPABILITIES_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
};
// Extension: VK_KHR_video_decode_vp9
// Extends: VkVideoDecodeInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoDecodeVP9PictureInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_DECODE_VP9_PICTURE_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    pStdPictureInfo: ?*const StdVideoDecodeVP9PictureInfo = null,
    // Extern sync: false
    // Optional: false
    referenceNameSlotIndices: [VK_MAX_VIDEO_VP9_REFERENCES_PER_FRAME_KHR]i32 = @import("std").mem.zeroes([VK_MAX_VIDEO_VP9_REFERENCES_PER_FRAME_KHR]i32),
    // Extern sync: false
    // Optional: false
    uncompressedHeaderOffset: u32 = 0,
    // Extern sync: false
    // Optional: false
    compressedHeaderOffset: u32 = 0,
    // Extern sync: false
    // Optional: false
    tilesOffset: u32 = 0,
};
// Extension: VK_KHR_video_decode_av1
// Extends: VkVideoProfileInfoKHR,VkQueryPoolCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoDecodeAV1ProfileInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_PROFILE_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Extern sync: false
    // Optional: false
    filmGrainSupport: u32 = 0,
};
// Extension: VK_KHR_video_decode_av1
// Extends: VkVideoCapabilitiesKHR
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkVideoDecodeAV1CapabilitiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_CAPABILITIES_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
};
// Extension: VK_KHR_video_decode_av1
// Extends: VkVideoSessionParametersCreateInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoDecodeAV1SessionParametersCreateInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_SESSION_PARAMETERS_CREATE_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    pStdSequenceHeader: ?*const StdVideoAV1SequenceHeader = null,
};
// Extension: VK_KHR_video_maintenance2
// Extends: VkVideoDecodeInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoDecodeAV1InlineSessionParametersInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_INLINE_SESSION_PARAMETERS_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    pStdSequenceHeader: ?*const StdVideoAV1SequenceHeader = null,
};
// Extension: VK_KHR_video_decode_av1
// Extends: VkVideoDecodeInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoDecodeAV1PictureInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_PICTURE_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    pStdPictureInfo: ?*const StdVideoDecodeAV1PictureInfo = null,
    // Extern sync: false
    // Optional: false
    referenceNameSlotIndices: [VK_MAX_VIDEO_AV1_REFERENCES_PER_FRAME_KHR]i32 = @import("std").mem.zeroes([VK_MAX_VIDEO_AV1_REFERENCES_PER_FRAME_KHR]i32),
    // Extern sync: false
    // Optional: false
    frameHeaderOffset: u32 = 0,
    // Extern sync: false
    // Optional: false
    tileCount: u32 = 0,
    // Length member: tileCount
    // Extern sync: false
    // Optional: false
    pTileOffsets: ?[*]const u32 = null,
    // Length member: tileCount
    // Extern sync: false
    // Optional: false
    pTileSizes: ?[*]const u32 = null,
};
// Extension: VK_KHR_video_decode_av1
// Extends: VkVideoReferenceSlotInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoDecodeAV1DpbSlotInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_DPB_SLOT_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    pStdReferenceInfo: ?*const StdVideoDecodeAV1ReferenceInfo = null,
};
// Extension: VK_KHR_video_queue
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoSessionCreateInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_SESSION_CREATE_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    queueFamilyIndex: u32 = 0,
    // Extern sync: false
    // Optional: true
    flags: VkVideoSessionCreateFlagsKHR = .{},
    // Extern sync: false
    // Optional: false
    pVideoProfile: ?*const VkVideoProfileInfoKHR = null,
    // Extern sync: false
    // Optional: false
    pictureFormat: VkFormat,
    // Extern sync: false
    // Optional: false
    maxCodedExtent: VkExtent2D = .{},
    // Extern sync: false
    // Optional: false
    referencePictureFormat: VkFormat,
    // Extern sync: false
    // Optional: false
    maxDpbSlots: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxActiveReferencePictures: u32 = 0,
    // Extern sync: false
    // Optional: false
    pStdHeaderVersion: ?*const VkExtensionProperties = null,
};
// Extension: VK_KHR_video_queue
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoSessionParametersCreateInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_CREATE_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkVideoSessionParametersCreateFlagsKHR = .{},
    // Extern sync: false
    // Optional: true
    videoSessionParametersTemplate: VkVideoSessionParametersKHR = .none,
    // Extern sync: false
    // Optional: false
    videoSession: VkVideoSessionKHR = .none,
};
// Extension: VK_KHR_video_queue
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoSessionParametersUpdateInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_UPDATE_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    updateSequenceCount: u32 = 0,
};
// Extension: VK_KHR_video_encode_queue
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeSessionParametersGetInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_GET_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    videoSessionParameters: VkVideoSessionParametersKHR = .none,
};
// Extension: VK_KHR_video_encode_queue
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeSessionParametersFeedbackInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_FEEDBACK_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    hasOverrides: u32 = 0,
};
// Extension: VK_KHR_video_queue
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoBeginCodingInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_BEGIN_CODING_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkVideoBeginCodingFlagsKHR = .{},
    // Extern sync: false
    // Optional: false
    videoSession: VkVideoSessionKHR = .none,
    // Extern sync: false
    // Optional: true
    videoSessionParameters: VkVideoSessionParametersKHR = .none,
    // Extern sync: false
    // Optional: true
    referenceSlotCount: u32 = 0,
    // Length member: referenceSlotCount
    // Extern sync: false
    // Optional: false
    pReferenceSlots: ?[*]const VkVideoReferenceSlotInfoKHR = null,
};
// Extension: VK_KHR_video_queue
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoEndCodingInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_END_CODING_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkVideoEndCodingFlagsKHR = .{},
};
// Extension: VK_KHR_video_queue
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoCodingControlInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_CODING_CONTROL_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    flags: VkVideoCodingControlFlagsKHR = .{},
};
// Extension: VK_KHR_video_encode_queue
// Extends: VkVideoProfileInfoKHR,VkQueryPoolCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeUsageInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_USAGE_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    videoUsageHints: VkVideoEncodeUsageFlagsKHR = .{},
    // Extern sync: false
    // Optional: true
    videoContentHints: VkVideoEncodeContentFlagsKHR = .{},
    // Extern sync: false
    // Optional: true
    tuningMode: VkVideoEncodeTuningModeKHR,
};
// Extension: VK_KHR_video_encode_queue
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkVideoEncodeFlagsKHR = .{},
    // Extern sync: false
    // Optional: false
    dstBuffer: VkBuffer = .none,
    // Extern sync: false
    // Optional: false
    dstBufferOffset: u64 = 0,
    // Extern sync: false
    // Optional: false
    dstBufferRange: u64 = 0,
    // Extern sync: false
    // Optional: false
    srcPictureResource: VkVideoPictureResourceInfoKHR = .{},
    // Extern sync: false
    // Optional: true
    pSetupReferenceSlot: ?*const VkVideoReferenceSlotInfoKHR = null,
    // Extern sync: false
    // Optional: true
    referenceSlotCount: u32 = 0,
    // Length member: referenceSlotCount
    // Extern sync: false
    // Optional: false
    pReferenceSlots: ?[*]const VkVideoReferenceSlotInfoKHR = null,
    // Extern sync: false
    // Optional: false
    precedingExternallyEncodedBytes: u32 = 0,
};
// Extension: VK_KHR_video_encode_quantization_map
// Extends: VkVideoEncodeInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeQuantizationMapInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    quantizationMap: VkImageView = .none,
    // Extern sync: false
    // Optional: false
    quantizationMapExtent: VkExtent2D = .{},
};
// Extension: VK_KHR_video_encode_quantization_map
// Extends: VkVideoSessionParametersCreateInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_SESSION_PARAMETERS_CREATE_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    quantizationMapTexelSize: VkExtent2D = .{},
};
// Extension: VK_KHR_video_encode_quantization_map
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUANTIZATION_MAP_FEATURES_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    videoEncodeQuantizationMap: u32 = 0,
};
// Extension: VK_KHR_video_encode_queue
// Extends: VkQueryPoolCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkQueryPoolVideoEncodeFeedbackCreateInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_QUERY_POOL_VIDEO_ENCODE_FEEDBACK_CREATE_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    encodeFeedbackFlags: VkVideoEncodeFeedbackFlagsKHR = .{},
};
// Extension: VK_KHR_video_encode_queue
// Extends: VkVideoCodingControlInfoKHR,VkVideoSessionParametersCreateInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeQualityLevelInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    qualityLevel: u32 = 0,
};
// Extension: VK_KHR_video_encode_queue
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    pVideoProfile: ?*const VkVideoProfileInfoKHR = null,
    // Extern sync: false
    // Optional: false
    qualityLevel: u32 = 0,
};
// Extension: VK_KHR_video_encode_queue
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeQualityLevelPropertiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_PROPERTIES_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    preferredRateControlMode: VkVideoEncodeRateControlModeFlagsKHR = .{},
    // Extern sync: false
    // Optional: false
    preferredRateControlLayerCount: u32 = 0,
};
// Extension: VK_KHR_video_encode_queue
// Extends: VkVideoCodingControlInfoKHR,VkVideoBeginCodingInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeRateControlInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkVideoEncodeRateControlFlagsKHR = .{},
    // Extern sync: false
    // Optional: true
    rateControlMode: VkVideoEncodeRateControlModeFlagsKHR = .{},
    // Extern sync: false
    // Optional: true
    layerCount: u32 = 0,
    // Length member: layerCount
    // Extern sync: false
    // Optional: false
    pLayers: ?[*]const VkVideoEncodeRateControlLayerInfoKHR = null,
    // Extern sync: false
    // Optional: false
    virtualBufferSizeInMs: u32 = 0,
    // Extern sync: false
    // Optional: false
    initialVirtualBufferSizeInMs: u32 = 0,
};
// Extension: VK_KHR_video_encode_queue
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeRateControlLayerInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_LAYER_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    averageBitrate: u64 = 0,
    // Extern sync: false
    // Optional: false
    maxBitrate: u64 = 0,
    // Extern sync: false
    // Optional: false
    frameRateNumerator: u32 = 0,
    // Extern sync: false
    // Optional: false
    frameRateDenominator: u32 = 0,
};
// Extension: VK_KHR_video_encode_queue
// Extends: VkVideoCapabilitiesKHR
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeCapabilitiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_CAPABILITIES_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    flags: VkVideoEncodeCapabilityFlagsKHR = .{},
    // Extern sync: false
    // Optional: false
    rateControlModes: VkVideoEncodeRateControlModeFlagsKHR = .{},
    // Extern sync: false
    // Optional: false
    maxRateControlLayers: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxBitrate: u64 = 0,
    // Extern sync: false
    // Optional: false
    maxQualityLevels: u32 = 0,
    // Extern sync: false
    // Optional: false
    encodeInputPictureGranularity: VkExtent2D = .{},
    // Extern sync: false
    // Optional: false
    supportedEncodeFeedbackFlags: VkVideoEncodeFeedbackFlagsKHR = .{},
};
// Extension: VK_KHR_video_encode_h264
// Extends: VkVideoCapabilitiesKHR
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeH264CapabilitiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_CAPABILITIES_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    flags: VkVideoEncodeH264CapabilityFlagsKHR = .{},
    // Extern sync: false
    // Optional: false
    // Extern sync: false
    // Optional: false
    maxSliceCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxPPictureL0ReferenceCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxBPictureL0ReferenceCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxL1ReferenceCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxTemporalLayerCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    expectDyadicTemporalLayerPattern: u32 = 0,
    // Extern sync: false
    // Optional: false
    minQp: i32 = 0,
    // Extern sync: false
    // Optional: false
    maxQp: i32 = 0,
    // Extern sync: false
    // Optional: false
    prefersGopRemainingFrames: u32 = 0,
    // Extern sync: false
    // Optional: false
    requiresGopRemainingFrames: u32 = 0,
    // Extern sync: false
    // Optional: false
    stdSyntaxFlags: VkVideoEncodeH264StdFlagsKHR = .{},
};
// Extension: VK_KHR_video_encode_h264
// Extends: VkVideoEncodeQualityLevelPropertiesKHR
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeH264QualityLevelPropertiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_QUALITY_LEVEL_PROPERTIES_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    preferredRateControlFlags: VkVideoEncodeH264RateControlFlagsKHR = .{},
    // Extern sync: false
    // Optional: false
    preferredGopFrameCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    preferredIdrPeriod: u32 = 0,
    // Extern sync: false
    // Optional: false
    preferredConsecutiveBFrameCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    preferredTemporalLayerCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    preferredConstantQp: VkVideoEncodeH264QpKHR = .{},
    // Extern sync: false
    // Optional: false
    preferredMaxL0ReferenceCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    preferredMaxL1ReferenceCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    preferredStdEntropyCodingModeFlag: u32 = 0,
};
// Extension: VK_KHR_video_encode_h264
// Extends: VkVideoSessionCreateInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeH264SessionCreateInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_CREATE_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    useMaxLevelIdc: u32 = 0,
    // Extern sync: false
    // Optional: false
};
// Extension: VK_KHR_video_encode_h264
// Extends: VkVideoSessionParametersUpdateInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeH264SessionParametersAddInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    stdSPSCount: u32 = 0,
    // Length member: stdSPSCount
    // Extern sync: false
    // Optional: true
    pStdSPSs: ?[*]const StdVideoH264SequenceParameterSet = null,
    // Extern sync: false
    // Optional: true
    stdPPSCount: u32 = 0,
    // Length member: stdPPSCount
    // Extern sync: false
    // Optional: true
    // Comment: List of Picture Parameters associated with the spsStd, above
    pStdPPSs: ?[*]const StdVideoH264PictureParameterSet = null,
};
// Extension: VK_KHR_video_encode_h264
// Extends: VkVideoSessionParametersCreateInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeH264SessionParametersCreateInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    maxStdSPSCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxStdPPSCount: u32 = 0,
    // Extern sync: false
    // Optional: true
    pParametersAddInfo: ?*const VkVideoEncodeH264SessionParametersAddInfoKHR = null,
};
// Extension: VK_KHR_video_encode_h264
// Extends: VkVideoEncodeSessionParametersGetInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeH264SessionParametersGetInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_GET_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    writeStdSPS: u32 = 0,
    // Extern sync: false
    // Optional: false
    writeStdPPS: u32 = 0,
    // Extern sync: false
    // Optional: false
    stdSPSId: u32 = 0,
    // Extern sync: false
    // Optional: false
    stdPPSId: u32 = 0,
};
// Extension: VK_KHR_video_encode_h264
// Extends: VkVideoEncodeSessionParametersFeedbackInfoKHR
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeH264SessionParametersFeedbackInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_FEEDBACK_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    hasStdSPSOverrides: u32 = 0,
    // Extern sync: false
    // Optional: false
    hasStdPPSOverrides: u32 = 0,
};
// Extension: VK_KHR_video_encode_h264
// Extends: VkVideoReferenceSlotInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeH264DpbSlotInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_DPB_SLOT_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    pStdReferenceInfo: ?*const StdVideoEncodeH264ReferenceInfo = null,
};
// Extension: VK_KHR_video_encode_h264
// Extends: VkVideoEncodeInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeH264PictureInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PICTURE_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    naluSliceEntryCount: u32 = 0,
    // Length member: naluSliceEntryCount
    // Extern sync: false
    // Optional: false
    pNaluSliceEntries: ?[*]const VkVideoEncodeH264NaluSliceInfoKHR = null,
    // Extern sync: false
    // Optional: false
    pStdPictureInfo: ?*const StdVideoEncodeH264PictureInfo = null,
    // Extern sync: false
    // Optional: false
    generatePrefixNalu: u32 = 0,
};
// Extension: VK_KHR_video_encode_h264
// Extends: VkVideoProfileInfoKHR,VkQueryPoolCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeH264ProfileInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PROFILE_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
};
// Extension: VK_KHR_video_encode_h264
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeH264NaluSliceInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_NALU_SLICE_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    constantQp: i32 = 0,
    // Extern sync: false
    // Optional: false
    pStdSliceHeader: ?*const StdVideoEncodeH264SliceHeader = null,
};
// Extension: VK_KHR_video_encode_h264
// Extends: VkVideoCodingControlInfoKHR,VkVideoBeginCodingInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeH264RateControlInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkVideoEncodeH264RateControlFlagsKHR = .{},
    // Extern sync: false
    // Optional: false
    gopFrameCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    idrPeriod: u32 = 0,
    // Extern sync: false
    // Optional: false
    consecutiveBFrameCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    temporalLayerCount: u32 = 0,
};
// Extension: VK_KHR_video_encode_h264
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeH264QpKHR = extern struct {
    // Extern sync: false
    // Optional: false
    qpI: i32 = 0,
    // Extern sync: false
    // Optional: false
    qpP: i32 = 0,
    // Extern sync: false
    // Optional: false
    qpB: i32 = 0,
};
// Extension: VK_KHR_video_encode_h264
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeH264FrameSizeKHR = extern struct {
    // Extern sync: false
    // Optional: false
    frameISize: u32 = 0,
    // Extern sync: false
    // Optional: false
    framePSize: u32 = 0,
    // Extern sync: false
    // Optional: false
    frameBSize: u32 = 0,
};
// Extension: VK_KHR_video_encode_h264
// Extends: VkVideoBeginCodingInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeH264GopRemainingFrameInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_GOP_REMAINING_FRAME_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    useGopRemainingFrames: u32 = 0,
    // Extern sync: false
    // Optional: false
    gopRemainingI: u32 = 0,
    // Extern sync: false
    // Optional: false
    gopRemainingP: u32 = 0,
    // Extern sync: false
    // Optional: false
    gopRemainingB: u32 = 0,
};
// Extension: VK_KHR_video_encode_h264
// Extends: VkVideoEncodeRateControlLayerInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeH264RateControlLayerInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_LAYER_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    useMinQp: u32 = 0,
    // Extern sync: false
    // Optional: false
    minQp: VkVideoEncodeH264QpKHR = .{},
    // Extern sync: false
    // Optional: false
    useMaxQp: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxQp: VkVideoEncodeH264QpKHR = .{},
    // Extern sync: false
    // Optional: false
    useMaxFrameSize: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxFrameSize: VkVideoEncodeH264FrameSizeKHR = .{},
};
// Extension: VK_KHR_video_encode_h265
// Extends: VkVideoCapabilitiesKHR
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeH265CapabilitiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_CAPABILITIES_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    flags: VkVideoEncodeH265CapabilityFlagsKHR = .{},
    // Extern sync: false
    // Optional: false
    // Extern sync: false
    // Optional: false
    maxSliceSegmentCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxTiles: VkExtent2D = .{},
    // Extern sync: false
    // Optional: false
    ctbSizes: VkVideoEncodeH265CtbSizeFlagsKHR = .{},
    // Extern sync: false
    // Optional: false
    transformBlockSizes: VkVideoEncodeH265TransformBlockSizeFlagsKHR = .{},
    // Extern sync: false
    // Optional: false
    maxPPictureL0ReferenceCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxBPictureL0ReferenceCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxL1ReferenceCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxSubLayerCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    expectDyadicTemporalSubLayerPattern: u32 = 0,
    // Extern sync: false
    // Optional: false
    minQp: i32 = 0,
    // Extern sync: false
    // Optional: false
    maxQp: i32 = 0,
    // Extern sync: false
    // Optional: false
    prefersGopRemainingFrames: u32 = 0,
    // Extern sync: false
    // Optional: false
    requiresGopRemainingFrames: u32 = 0,
    // Extern sync: false
    // Optional: false
    stdSyntaxFlags: VkVideoEncodeH265StdFlagsKHR = .{},
};
// Extension: VK_KHR_video_encode_h265
// Extends: VkVideoEncodeQualityLevelPropertiesKHR
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeH265QualityLevelPropertiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_QUALITY_LEVEL_PROPERTIES_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    preferredRateControlFlags: VkVideoEncodeH265RateControlFlagsKHR = .{},
    // Extern sync: false
    // Optional: false
    preferredGopFrameCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    preferredIdrPeriod: u32 = 0,
    // Extern sync: false
    // Optional: false
    preferredConsecutiveBFrameCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    preferredSubLayerCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    preferredConstantQp: VkVideoEncodeH265QpKHR = .{},
    // Extern sync: false
    // Optional: false
    preferredMaxL0ReferenceCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    preferredMaxL1ReferenceCount: u32 = 0,
};
// Extension: VK_KHR_video_encode_h265
// Extends: VkVideoSessionCreateInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeH265SessionCreateInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_CREATE_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    useMaxLevelIdc: u32 = 0,
    // Extern sync: false
    // Optional: false
};
// Extension: VK_KHR_video_encode_h265
// Extends: VkVideoSessionParametersUpdateInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeH265SessionParametersAddInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    stdVPSCount: u32 = 0,
    // Length member: stdVPSCount
    // Extern sync: false
    // Optional: true
    pStdVPSs: ?[*]const StdVideoH265VideoParameterSet = null,
    // Extern sync: false
    // Optional: true
    stdSPSCount: u32 = 0,
    // Length member: stdSPSCount
    // Extern sync: false
    // Optional: true
    pStdSPSs: ?[*]const StdVideoH265SequenceParameterSet = null,
    // Extern sync: false
    // Optional: true
    stdPPSCount: u32 = 0,
    // Length member: stdPPSCount
    // Extern sync: false
    // Optional: true
    // Comment: List of Picture Parameters associated with the spsStd, above
    pStdPPSs: ?[*]const StdVideoH265PictureParameterSet = null,
};
// Extension: VK_KHR_video_encode_h265
// Extends: VkVideoSessionParametersCreateInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeH265SessionParametersCreateInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    maxStdVPSCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxStdSPSCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxStdPPSCount: u32 = 0,
    // Extern sync: false
    // Optional: true
    pParametersAddInfo: ?*const VkVideoEncodeH265SessionParametersAddInfoKHR = null,
};
// Extension: VK_KHR_video_encode_h265
// Extends: VkVideoEncodeSessionParametersGetInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeH265SessionParametersGetInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_GET_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    writeStdVPS: u32 = 0,
    // Extern sync: false
    // Optional: false
    writeStdSPS: u32 = 0,
    // Extern sync: false
    // Optional: false
    writeStdPPS: u32 = 0,
    // Extern sync: false
    // Optional: false
    stdVPSId: u32 = 0,
    // Extern sync: false
    // Optional: false
    stdSPSId: u32 = 0,
    // Extern sync: false
    // Optional: false
    stdPPSId: u32 = 0,
};
// Extension: VK_KHR_video_encode_h265
// Extends: VkVideoEncodeSessionParametersFeedbackInfoKHR
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeH265SessionParametersFeedbackInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_FEEDBACK_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    hasStdVPSOverrides: u32 = 0,
    // Extern sync: false
    // Optional: false
    hasStdSPSOverrides: u32 = 0,
    // Extern sync: false
    // Optional: false
    hasStdPPSOverrides: u32 = 0,
};
// Extension: VK_KHR_video_encode_h265
// Extends: VkVideoEncodeInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeH265PictureInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PICTURE_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    naluSliceSegmentEntryCount: u32 = 0,
    // Length member: naluSliceSegmentEntryCount
    // Extern sync: false
    // Optional: false
    pNaluSliceSegmentEntries: ?[*]const VkVideoEncodeH265NaluSliceSegmentInfoKHR = null,
    // Extern sync: false
    // Optional: false
    pStdPictureInfo: ?*const StdVideoEncodeH265PictureInfo = null,
};
// Extension: VK_KHR_video_encode_h265
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeH265NaluSliceSegmentInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_NALU_SLICE_SEGMENT_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    constantQp: i32 = 0,
    // Extern sync: false
    // Optional: false
    pStdSliceSegmentHeader: ?*const StdVideoEncodeH265SliceSegmentHeader = null,
};
// Extension: VK_KHR_video_encode_h265
// Extends: VkVideoCodingControlInfoKHR,VkVideoBeginCodingInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeH265RateControlInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkVideoEncodeH265RateControlFlagsKHR = .{},
    // Extern sync: false
    // Optional: false
    gopFrameCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    idrPeriod: u32 = 0,
    // Extern sync: false
    // Optional: false
    consecutiveBFrameCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    subLayerCount: u32 = 0,
};
// Extension: VK_KHR_video_encode_h265
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeH265QpKHR = extern struct {
    // Extern sync: false
    // Optional: false
    qpI: i32 = 0,
    // Extern sync: false
    // Optional: false
    qpP: i32 = 0,
    // Extern sync: false
    // Optional: false
    qpB: i32 = 0,
};
// Extension: VK_KHR_video_encode_h265
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeH265FrameSizeKHR = extern struct {
    // Extern sync: false
    // Optional: false
    frameISize: u32 = 0,
    // Extern sync: false
    // Optional: false
    framePSize: u32 = 0,
    // Extern sync: false
    // Optional: false
    frameBSize: u32 = 0,
};
// Extension: VK_KHR_video_encode_h265
// Extends: VkVideoBeginCodingInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeH265GopRemainingFrameInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_GOP_REMAINING_FRAME_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    useGopRemainingFrames: u32 = 0,
    // Extern sync: false
    // Optional: false
    gopRemainingI: u32 = 0,
    // Extern sync: false
    // Optional: false
    gopRemainingP: u32 = 0,
    // Extern sync: false
    // Optional: false
    gopRemainingB: u32 = 0,
};
// Extension: VK_KHR_video_encode_h265
// Extends: VkVideoEncodeRateControlLayerInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeH265RateControlLayerInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_LAYER_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    useMinQp: u32 = 0,
    // Extern sync: false
    // Optional: false
    minQp: VkVideoEncodeH265QpKHR = .{},
    // Extern sync: false
    // Optional: false
    useMaxQp: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxQp: VkVideoEncodeH265QpKHR = .{},
    // Extern sync: false
    // Optional: false
    useMaxFrameSize: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxFrameSize: VkVideoEncodeH265FrameSizeKHR = .{},
};
// Extension: VK_KHR_video_encode_h265
// Extends: VkVideoProfileInfoKHR,VkQueryPoolCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeH265ProfileInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PROFILE_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
};
// Extension: VK_KHR_video_encode_h265
// Extends: VkVideoReferenceSlotInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeH265DpbSlotInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_DPB_SLOT_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    pStdReferenceInfo: ?*const StdVideoEncodeH265ReferenceInfo = null,
};
// Extension: VK_KHR_video_encode_av1
// Extends: VkVideoCapabilitiesKHR
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeAV1CapabilitiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_CAPABILITIES_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    flags: VkVideoEncodeAV1CapabilityFlagsKHR = .{},
    // Extern sync: false
    // Optional: false
    // Extern sync: false
    // Optional: false
    codedPictureAlignment: VkExtent2D = .{},
    // Extern sync: false
    // Optional: false
    maxTiles: VkExtent2D = .{},
    // Extern sync: false
    // Optional: false
    minTileSize: VkExtent2D = .{},
    // Extern sync: false
    // Optional: false
    maxTileSize: VkExtent2D = .{},
    // Extern sync: false
    // Optional: false
    superblockSizes: VkVideoEncodeAV1SuperblockSizeFlagsKHR = .{},
    // Extern sync: false
    // Optional: false
    maxSingleReferenceCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    singleReferenceNameMask: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxUnidirectionalCompoundReferenceCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxUnidirectionalCompoundGroup1ReferenceCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    unidirectionalCompoundReferenceNameMask: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxBidirectionalCompoundReferenceCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxBidirectionalCompoundGroup1ReferenceCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxBidirectionalCompoundGroup2ReferenceCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    bidirectionalCompoundReferenceNameMask: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxTemporalLayerCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxSpatialLayerCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxOperatingPoints: u32 = 0,
    // Extern sync: false
    // Optional: false
    minQIndex: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxQIndex: u32 = 0,
    // Extern sync: false
    // Optional: false
    prefersGopRemainingFrames: u32 = 0,
    // Extern sync: false
    // Optional: false
    requiresGopRemainingFrames: u32 = 0,
    // Extern sync: false
    // Optional: false
    stdSyntaxFlags: VkVideoEncodeAV1StdFlagsKHR = .{},
};
// Extension: VK_KHR_video_encode_av1
// Extends: VkVideoEncodeQualityLevelPropertiesKHR
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeAV1QualityLevelPropertiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_QUALITY_LEVEL_PROPERTIES_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    preferredRateControlFlags: VkVideoEncodeAV1RateControlFlagsKHR = .{},
    // Extern sync: false
    // Optional: false
    preferredGopFrameCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    preferredKeyFramePeriod: u32 = 0,
    // Extern sync: false
    // Optional: false
    preferredConsecutiveBipredictiveFrameCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    preferredTemporalLayerCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    preferredConstantQIndex: VkVideoEncodeAV1QIndexKHR = .{},
    // Extern sync: false
    // Optional: false
    preferredMaxSingleReferenceCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    preferredSingleReferenceNameMask: u32 = 0,
    // Extern sync: false
    // Optional: false
    preferredMaxUnidirectionalCompoundReferenceCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    preferredMaxUnidirectionalCompoundGroup1ReferenceCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    preferredUnidirectionalCompoundReferenceNameMask: u32 = 0,
    // Extern sync: false
    // Optional: false
    preferredMaxBidirectionalCompoundReferenceCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    preferredMaxBidirectionalCompoundGroup1ReferenceCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    preferredMaxBidirectionalCompoundGroup2ReferenceCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    preferredBidirectionalCompoundReferenceNameMask: u32 = 0,
};
// Extension: VK_KHR_video_encode_av1
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceVideoEncodeAV1FeaturesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_AV1_FEATURES_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    videoEncodeAV1: u32 = 0,
};
// Extension: VK_KHR_video_encode_av1
// Extends: VkVideoSessionCreateInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeAV1SessionCreateInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_SESSION_CREATE_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    useMaxLevel: u32 = 0,
    // Extern sync: false
    // Optional: false
};
// Extension: VK_KHR_video_encode_av1
// Extends: VkVideoSessionParametersCreateInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeAV1SessionParametersCreateInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_SESSION_PARAMETERS_CREATE_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    pStdSequenceHeader: ?*const StdVideoAV1SequenceHeader = null,
    // Extern sync: false
    // Optional: true
    pStdDecoderModelInfo: ?*const StdVideoEncodeAV1DecoderModelInfo = null,
    // Extern sync: false
    // Optional: true
    stdOperatingPointCount: u32 = 0,
    // Length member: stdOperatingPointCount
    // Extern sync: false
    // Optional: true
    pStdOperatingPoints: ?[*]const StdVideoEncodeAV1OperatingPointInfo = null,
};
// Extension: VK_KHR_video_encode_av1
// Extends: VkVideoReferenceSlotInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeAV1DpbSlotInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_DPB_SLOT_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    pStdReferenceInfo: ?*const StdVideoEncodeAV1ReferenceInfo = null,
};
// Extension: VK_KHR_video_encode_av1
// Extends: VkVideoEncodeInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeAV1PictureInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_PICTURE_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    predictionMode: VkVideoEncodeAV1PredictionModeKHR,
    // Extern sync: false
    // Optional: false
    rateControlGroup: VkVideoEncodeAV1RateControlGroupKHR,
    // Extern sync: false
    // Optional: false
    constantQIndex: u32 = 0,
    // Extern sync: false
    // Optional: false
    pStdPictureInfo: ?*const StdVideoEncodeAV1PictureInfo = null,
    // Extern sync: false
    // Optional: false
    referenceNameSlotIndices: [VK_MAX_VIDEO_AV1_REFERENCES_PER_FRAME_KHR]i32 = @import("std").mem.zeroes([VK_MAX_VIDEO_AV1_REFERENCES_PER_FRAME_KHR]i32),
    // Extern sync: false
    // Optional: false
    primaryReferenceCdfOnly: u32 = 0,
    // Extern sync: false
    // Optional: false
    generateObuExtensionHeader: u32 = 0,
};
// Extension: VK_KHR_video_encode_av1
// Extends: VkVideoProfileInfoKHR,VkQueryPoolCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeAV1ProfileInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_PROFILE_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
};
// Extension: VK_KHR_video_encode_av1
// Extends: VkVideoCodingControlInfoKHR,VkVideoBeginCodingInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeAV1RateControlInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_RATE_CONTROL_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkVideoEncodeAV1RateControlFlagsKHR = .{},
    // Extern sync: false
    // Optional: false
    gopFrameCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    keyFramePeriod: u32 = 0,
    // Extern sync: false
    // Optional: false
    consecutiveBipredictiveFrameCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    temporalLayerCount: u32 = 0,
};
// Extension: VK_KHR_video_encode_av1
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeAV1QIndexKHR = extern struct {
    // Extern sync: false
    // Optional: false
    intraQIndex: u32 = 0,
    // Extern sync: false
    // Optional: false
    predictiveQIndex: u32 = 0,
    // Extern sync: false
    // Optional: false
    bipredictiveQIndex: u32 = 0,
};
// Extension: VK_KHR_video_encode_av1
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeAV1FrameSizeKHR = extern struct {
    // Extern sync: false
    // Optional: false
    intraFrameSize: u32 = 0,
    // Extern sync: false
    // Optional: false
    predictiveFrameSize: u32 = 0,
    // Extern sync: false
    // Optional: false
    bipredictiveFrameSize: u32 = 0,
};
// Extension: VK_KHR_video_encode_av1
// Extends: VkVideoBeginCodingInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeAV1GopRemainingFrameInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_GOP_REMAINING_FRAME_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    useGopRemainingFrames: u32 = 0,
    // Extern sync: false
    // Optional: false
    gopRemainingIntra: u32 = 0,
    // Extern sync: false
    // Optional: false
    gopRemainingPredictive: u32 = 0,
    // Extern sync: false
    // Optional: false
    gopRemainingBipredictive: u32 = 0,
};
// Extension: VK_KHR_video_encode_av1
// Extends: VkVideoEncodeRateControlLayerInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeAV1RateControlLayerInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_RATE_CONTROL_LAYER_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    useMinQIndex: u32 = 0,
    // Extern sync: false
    // Optional: false
    minQIndex: VkVideoEncodeAV1QIndexKHR = .{},
    // Extern sync: false
    // Optional: false
    useMaxQIndex: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxQIndex: VkVideoEncodeAV1QIndexKHR = .{},
    // Extern sync: false
    // Optional: false
    useMaxFrameSize: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxFrameSize: VkVideoEncodeAV1FrameSizeKHR = .{},
};
// Extension: VK_NV_inherited_viewport_scissor
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceInheritedViewportScissorFeaturesNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    inheritedViewportScissor2D: u32 = 0,
};
// Extension: VK_NV_inherited_viewport_scissor
// Extends: VkCommandBufferInheritanceInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkCommandBufferInheritanceViewportScissorInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_VIEWPORT_SCISSOR_INFO_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    viewportScissor2D: u32 = 0,
    // Extern sync: false
    // Optional: false
    viewportDepthCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    pViewportDepths: ?*const VkViewport = null,
};
// Extension: VK_EXT_ycbcr_2plane_444_formats
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    ycbcr2plane444Formats: u32 = 0,
};
// Extension: VK_EXT_provoking_vertex
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceProvokingVertexFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    provokingVertexLast: u32 = 0,
    // Extern sync: false
    // Optional: false
    transformFeedbackPreservesProvokingVertex: u32 = 0,
};
// Extension: VK_EXT_provoking_vertex
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceProvokingVertexPropertiesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    provokingVertexModePerPipeline: u32 = 0,
    // Extern sync: false
    // Optional: false
    transformFeedbackPreservesTriangleFanProvokingVertex: u32 = 0,
};
// Extension: VK_EXT_provoking_vertex
// Extends: VkPipelineRasterizationStateCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineRasterizationProvokingVertexStateCreateInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    provokingVertexMode: VkProvokingVertexModeEXT,
};
// Extension: VK_KHR_video_encode_intra_refresh
// Extends: VkVideoCapabilitiesKHR
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeIntraRefreshCapabilitiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_INTRA_REFRESH_CAPABILITIES_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: true
    intraRefreshModes: VkVideoEncodeIntraRefreshModeFlagsKHR = .{},
    // Extern sync: false
    // Optional: false
    maxIntraRefreshCycleDuration: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxIntraRefreshActiveReferencePictures: u32 = 0,
    // Extern sync: false
    // Optional: false
    partitionIndependentIntraRefreshRegions: u32 = 0,
    // Extern sync: false
    // Optional: false
    nonRectangularIntraRefreshRegions: u32 = 0,
};
// Extension: VK_KHR_video_encode_intra_refresh
// Extends: VkVideoSessionCreateInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeSessionIntraRefreshCreateInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_INTRA_REFRESH_CREATE_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    intraRefreshMode: VkVideoEncodeIntraRefreshModeFlagsKHR = .{},
};
// Extension: VK_KHR_video_encode_intra_refresh
// Extends: VkVideoEncodeInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeIntraRefreshInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_INTRA_REFRESH_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    intraRefreshCycleDuration: u32 = 0,
    // Extern sync: false
    // Optional: false
    intraRefreshIndex: u32 = 0,
};
// Extension: VK_KHR_video_encode_intra_refresh
// Extends: VkVideoReferenceSlotInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoReferenceIntraRefreshInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_REFERENCE_INTRA_REFRESH_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    dirtyIntraRefreshRegions: u32 = 0,
};
// Extension: VK_KHR_video_encode_intra_refresh
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_INTRA_REFRESH_FEATURES_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    videoEncodeIntraRefresh: u32 = 0,
};
// Extension: VK_NVX_binary_import
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkCuModuleCreateInfoNVX = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_CU_MODULE_CREATE_INFO_NVX,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    dataSize: u64 = 0,
    // Length member: dataSize
    // Extern sync: false
    // Optional: false
    pData: ?[*]const anyopaque = null,
};
// Extension: VK_NVX_binary_import
// Extends: VkCuModuleCreateInfoNVX
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkCuModuleTexturingModeCreateInfoNVX = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_CU_MODULE_TEXTURING_MODE_CREATE_INFO_NVX,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    use64bitTexturing: u32 = 0,
};
// Extension: VK_NVX_binary_import
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkCuFunctionCreateInfoNVX = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_CU_FUNCTION_CREATE_INFO_NVX,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    module: VkCuModuleNVX = .none,
    // Length member: null-terminated
    // Extern sync: false
    // Optional: false
    pName: ?[*:0]const u8 = null,
};
// Extension: VK_NVX_binary_import
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkCuLaunchInfoNVX = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_CU_LAUNCH_INFO_NVX,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    function: VkCuFunctionNVX = .none,
    // Extern sync: false
    // Optional: false
    gridDimX: u32 = 0,
    // Extern sync: false
    // Optional: false
    gridDimY: u32 = 0,
    // Extern sync: false
    // Optional: false
    gridDimZ: u32 = 0,
    // Extern sync: false
    // Optional: false
    blockDimX: u32 = 0,
    // Extern sync: false
    // Optional: false
    blockDimY: u32 = 0,
    // Extern sync: false
    // Optional: false
    blockDimZ: u32 = 0,
    // Extern sync: false
    // Optional: false
    sharedMemBytes: u32 = 0,
    // Extern sync: false
    // Optional: true
    paramCount: u64 = 0,
    // Length member: paramCount
    // Extern sync: false
    // Optional: false
    pParams: ?[*]const *const anyopaque = null,
    // Extern sync: false
    // Optional: true
    extraCount: u64 = 0,
    // Length member: extraCount
    // Extern sync: false
    // Optional: false
    pExtras: ?[*]const *const anyopaque = null,
};
// Extension: VK_EXT_descriptor_buffer
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceDescriptorBufferFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_FEATURES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    descriptorBuffer: u32 = 0,
    // Extern sync: false
    // Optional: false
    descriptorBufferCaptureReplay: u32 = 0,
    // Extern sync: false
    // Optional: false
    descriptorBufferImageLayoutIgnored: u32 = 0,
    // Extern sync: false
    // Optional: false
    descriptorBufferPushDescriptors: u32 = 0,
};
// Extension: VK_EXT_descriptor_buffer
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceDescriptorBufferPropertiesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_PROPERTIES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    combinedImageSamplerDescriptorSingleArray: u32 = 0,
    // Extern sync: false
    // Optional: false
    bufferlessPushDescriptors: u32 = 0,
    // Extern sync: false
    // Optional: false
    allowSamplerImageViewPostSubmitCreation: u32 = 0,
    // Extern sync: false
    // Optional: false
    descriptorBufferOffsetAlignment: u64 = 0,
    // Extern sync: false
    // Optional: false
    maxDescriptorBufferBindings: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxResourceDescriptorBufferBindings: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxSamplerDescriptorBufferBindings: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxEmbeddedImmutableSamplerBindings: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxEmbeddedImmutableSamplers: u32 = 0,
    // Extern sync: false
    // Optional: false
    bufferCaptureReplayDescriptorDataSize: u64 = 0,
    // Extern sync: false
    // Optional: false
    imageCaptureReplayDescriptorDataSize: u64 = 0,
    // Extern sync: false
    // Optional: false
    imageViewCaptureReplayDescriptorDataSize: u64 = 0,
    // Extern sync: false
    // Optional: false
    samplerCaptureReplayDescriptorDataSize: u64 = 0,
    // Extern sync: false
    // Optional: false
    accelerationStructureCaptureReplayDescriptorDataSize: u64 = 0,
    // Extern sync: false
    // Optional: false
    samplerDescriptorSize: u64 = 0,
    // Extern sync: false
    // Optional: false
    combinedImageSamplerDescriptorSize: u64 = 0,
    // Extern sync: false
    // Optional: false
    sampledImageDescriptorSize: u64 = 0,
    // Extern sync: false
    // Optional: false
    storageImageDescriptorSize: u64 = 0,
    // Extern sync: false
    // Optional: false
    uniformTexelBufferDescriptorSize: u64 = 0,
    // Extern sync: false
    // Optional: false
    robustUniformTexelBufferDescriptorSize: u64 = 0,
    // Extern sync: false
    // Optional: false
    storageTexelBufferDescriptorSize: u64 = 0,
    // Extern sync: false
    // Optional: false
    robustStorageTexelBufferDescriptorSize: u64 = 0,
    // Extern sync: false
    // Optional: false
    uniformBufferDescriptorSize: u64 = 0,
    // Extern sync: false
    // Optional: false
    robustUniformBufferDescriptorSize: u64 = 0,
    // Extern sync: false
    // Optional: false
    storageBufferDescriptorSize: u64 = 0,
    // Extern sync: false
    // Optional: false
    robustStorageBufferDescriptorSize: u64 = 0,
    // Extern sync: false
    // Optional: false
    inputAttachmentDescriptorSize: u64 = 0,
    // Extern sync: false
    // Optional: false
    accelerationStructureDescriptorSize: u64 = 0,
    // Extern sync: false
    // Optional: false
    maxSamplerDescriptorBufferRange: u64 = 0,
    // Extern sync: false
    // Optional: false
    maxResourceDescriptorBufferRange: u64 = 0,
    // Extern sync: false
    // Optional: false
    samplerDescriptorBufferAddressSpaceSize: u64 = 0,
    // Extern sync: false
    // Optional: false
    resourceDescriptorBufferAddressSpaceSize: u64 = 0,
    // Extern sync: false
    // Optional: false
    descriptorBufferAddressSpaceSize: u64 = 0,
};
// Extension: VK_EXT_descriptor_buffer
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_DENSITY_MAP_PROPERTIES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    combinedImageSamplerDensityMapDescriptorSize: u64 = 0,
};
// Extension: VK_EXT_descriptor_buffer
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDescriptorAddressInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_DESCRIPTOR_ADDRESS_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: true
    address: u64 = 0,
    // Extern sync: false
    // Optional: false
    range: u64 = 0,
    // Extern sync: false
    // Optional: false
    format: VkFormat,
};
// Extension: VK_EXT_descriptor_buffer
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDescriptorBufferBindingInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    address: u64 = 0,
    // Extern sync: false
    // Optional: true
    usage: VkBufferUsageFlags = .{},
};
// Extension: VK_EXT_descriptor_buffer
// Extends: VkDescriptorBufferBindingInfoEXT
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDescriptorBufferBindingPushDescriptorBufferHandleEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_PUSH_DESCRIPTOR_BUFFER_HANDLE_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    buffer: VkBuffer = .none,
};
// Extension: VK_EXT_descriptor_buffer
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDescriptorGetInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_DESCRIPTOR_GET_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    type: VkDescriptorType,
    // Extern sync: false
    // Optional: false
    // Selector member: type (What union field is valid)
    data: VkDescriptorDataEXT,
};
// Extension: VK_EXT_descriptor_buffer
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkBufferCaptureDescriptorDataInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_BUFFER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    buffer: VkBuffer = .none,
};
// Extension: VK_EXT_descriptor_buffer
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImageCaptureDescriptorDataInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_IMAGE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    image: VkImage = .none,
};
// Extension: VK_EXT_descriptor_buffer
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImageViewCaptureDescriptorDataInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_IMAGE_VIEW_CAPTURE_DESCRIPTOR_DATA_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    imageView: VkImageView = .none,
};
// Extension: VK_EXT_descriptor_buffer
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSamplerCaptureDescriptorDataInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_SAMPLER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    sampler: VkSampler = .none,
};
// Extension: VK_EXT_descriptor_buffer
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkAccelerationStructureCaptureDescriptorDataInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    accelerationStructure: VkAccelerationStructureKHR = .none,
    // Extern sync: false
    // Optional: true
    accelerationStructureNV: VkAccelerationStructureNV = .none,
};
// Extension: VK_EXT_descriptor_buffer
// Extends: VkBufferCreateInfo,VkImageCreateInfo,VkImageViewCreateInfo,VkSamplerCreateInfo,VkAccelerationStructureCreateInfoKHR,VkAccelerationStructureCreateInfoNV,VkTensorCreateInfoARM,VkTensorViewCreateInfoARM
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkOpaqueCaptureDescriptorDataCreateInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    opaqueCaptureDescriptorData: ?*const anyopaque = null,
};
// Extension: VK_COMPUTE_VERSION_1_3
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceShaderIntegerDotProductFeatures = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    shaderIntegerDotProduct: u32 = 0,
};
// Extension: VK_KHR_shader_integer_dot_product
pub const VkPhysicalDeviceShaderIntegerDotProductFeaturesKHR = VkPhysicalDeviceShaderIntegerDotProductFeatures;
// Extension: VK_COMPUTE_VERSION_1_3
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceShaderIntegerDotProductProperties = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    integerDotProduct8BitUnsignedAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProduct8BitSignedAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProduct8BitMixedSignednessAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProduct4x8BitPackedUnsignedAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProduct4x8BitPackedSignedAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProduct4x8BitPackedMixedSignednessAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProduct16BitUnsignedAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProduct16BitSignedAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProduct16BitMixedSignednessAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProduct32BitUnsignedAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProduct32BitSignedAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProduct32BitMixedSignednessAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProduct64BitUnsignedAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProduct64BitSignedAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProduct64BitMixedSignednessAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProductAccumulatingSaturating8BitUnsignedAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProductAccumulatingSaturating8BitSignedAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProductAccumulatingSaturating16BitUnsignedAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProductAccumulatingSaturating16BitSignedAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProductAccumulatingSaturating32BitUnsignedAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProductAccumulatingSaturating32BitSignedAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProductAccumulatingSaturating64BitUnsignedAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProductAccumulatingSaturating64BitSignedAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated: u32 = 0,
};
// Extension: VK_KHR_shader_integer_dot_product
pub const VkPhysicalDeviceShaderIntegerDotProductPropertiesKHR = VkPhysicalDeviceShaderIntegerDotProductProperties;
// Extension: VK_EXT_physical_device_drm
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceDrmPropertiesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRM_PROPERTIES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    hasPrimary: u32 = 0,
    // Extern sync: false
    // Optional: false
    hasRender: u32 = 0,
    // Extern sync: false
    // Optional: false
    primaryMajor: i64 = 0,
    // Extern sync: false
    // Optional: false
    primaryMinor: i64 = 0,
    // Extern sync: false
    // Optional: false
    renderMajor: i64 = 0,
    // Extern sync: false
    // Optional: false
    renderMinor: i64 = 0,
};
// Extension: VK_KHR_fragment_shader_barycentric
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    fragmentShaderBarycentric: u32 = 0,
};
// Extension: VK_KHR_fragment_shader_barycentric
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_PROPERTIES_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    triStripVertexOrderIndependentOfProvokingVertex: u32 = 0,
};
// Extension: VK_KHR_shader_fma
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceShaderFmaFeaturesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FMA_FEATURES_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    shaderFmaFloat16: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderFmaFloat32: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderFmaFloat64: u32 = 0,
};
// Extension: VK_NV_ray_tracing_motion_blur
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceRayTracingMotionBlurFeaturesNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    rayTracingMotionBlur: u32 = 0,
    // Extern sync: false
    // Optional: false
    rayTracingMotionBlurPipelineTraceRaysIndirect: u32 = 0,
};
// Extension: VK_NV_ray_tracing_validation
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceRayTracingValidationFeaturesNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_VALIDATION_FEATURES_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    rayTracingValidation: u32 = 0,
};
// Extension: VK_NV_ray_tracing_linear_swept_spheres
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_LINEAR_SWEPT_SPHERES_FEATURES_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    spheres: u32 = 0,
    // Extern sync: false
    // Optional: false
    linearSweptSpheres: u32 = 0,
};
// Extension: VK_NV_ray_tracing_motion_blur
// Extends: VkAccelerationStructureGeometryTrianglesDataKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkAccelerationStructureGeometryMotionTrianglesDataNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_MOTION_TRIANGLES_DATA_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    vertexData: VkDeviceOrHostAddressConstKHR,
};
// Extension: VK_NV_ray_tracing_motion_blur
// Extends: VkAccelerationStructureCreateInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkAccelerationStructureMotionInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MOTION_INFO_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    maxInstances: u32 = 0,
    // Extern sync: false
    // Optional: true
    flags: VkAccelerationStructureMotionInfoFlagsNV = .{},
};
// Extension: VK_NV_ray_tracing_motion_blur
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSRTDataNV = extern struct {
    // Extern sync: false
    // Optional: false
    sx: f32 = 0,
    // Extern sync: false
    // Optional: false
    a: f32 = 0,
    // Extern sync: false
    // Optional: false
    b: f32 = 0,
    // Extern sync: false
    // Optional: false
    pvx: f32 = 0,
    // Extern sync: false
    // Optional: false
    sy: f32 = 0,
    // Extern sync: false
    // Optional: false
    c: f32 = 0,
    // Extern sync: false
    // Optional: false
    pvy: f32 = 0,
    // Extern sync: false
    // Optional: false
    sz: f32 = 0,
    // Extern sync: false
    // Optional: false
    pvz: f32 = 0,
    // Extern sync: false
    // Optional: false
    qx: f32 = 0,
    // Extern sync: false
    // Optional: false
    qy: f32 = 0,
    // Extern sync: false
    // Optional: false
    qz: f32 = 0,
    // Extern sync: false
    // Optional: false
    qw: f32 = 0,
    // Extern sync: false
    // Optional: false
    tx: f32 = 0,
    // Extern sync: false
    // Optional: false
    ty: f32 = 0,
    // Extern sync: false
    // Optional: false
    tz: f32 = 0,
};
// Extension: VK_NV_ray_tracing_motion_blur
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkAccelerationStructureSRTMotionInstanceNV = extern struct {
};
// Extension: VK_NV_ray_tracing_motion_blur
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkAccelerationStructureMatrixMotionInstanceNV = extern struct {
};
// Extension: VK_NV_ray_tracing_motion_blur
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkAccelerationStructureMotionInstanceNV = extern struct {
    // Extern sync: false
    // Optional: false
    type: VkAccelerationStructureMotionInstanceTypeNV,
    // Extern sync: false
    // Optional: true
    flags: VkAccelerationStructureMotionInstanceFlagsNV = .{},
    // Extern sync: false
    // Optional: false
    // Selector member: type (What union field is valid)
    data: VkAccelerationStructureMotionInstanceDataNV,
};
// Extension: VK_NV_external_memory_rdma
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkMemoryGetRemoteAddressInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_MEMORY_GET_REMOTE_ADDRESS_INFO_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    memory: VkDeviceMemory = .none,
    // Extern sync: false
    // Optional: false
    handleType: VkExternalMemoryHandleTypeFlags = .{},
};
// Extension: VK_FUCHSIA_buffer_collection
// Extends: VkMemoryAllocateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImportMemoryBufferCollectionFUCHSIA = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_IMPORT_MEMORY_BUFFER_COLLECTION_FUCHSIA,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    collection: VkBufferCollectionFUCHSIA = .none,
    // Extern sync: false
    // Optional: false
    index: u32 = 0,
};
// Extension: VK_FUCHSIA_buffer_collection
// Extends: VkImageCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkBufferCollectionImageCreateInfoFUCHSIA = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_BUFFER_COLLECTION_IMAGE_CREATE_INFO_FUCHSIA,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    collection: VkBufferCollectionFUCHSIA = .none,
    // Extern sync: false
    // Optional: false
    index: u32 = 0,
};
// Extension: VK_FUCHSIA_buffer_collection
// Extends: VkBufferCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkBufferCollectionBufferCreateInfoFUCHSIA = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_BUFFER_COLLECTION_BUFFER_CREATE_INFO_FUCHSIA,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    collection: VkBufferCollectionFUCHSIA = .none,
    // Extern sync: false
    // Optional: false
    index: u32 = 0,
};
// Extension: VK_FUCHSIA_buffer_collection
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkBufferCollectionCreateInfoFUCHSIA = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_BUFFER_COLLECTION_CREATE_INFO_FUCHSIA,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
};
// Extension: VK_FUCHSIA_buffer_collection
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkBufferCollectionPropertiesFUCHSIA = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_BUFFER_COLLECTION_PROPERTIES_FUCHSIA,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    memoryTypeBits: u32 = 0,
    // Extern sync: false
    // Optional: false
    bufferCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    createInfoIndex: u32 = 0,
    // Extern sync: false
    // Optional: false
    sysmemPixelFormat: u64 = 0,
    // Extern sync: false
    // Optional: false
    formatFeatures: VkFormatFeatureFlags = .{},
    // Extern sync: false
    // Optional: false
    sysmemColorSpaceIndex: VkSysmemColorSpaceFUCHSIA = .{},
    // Extern sync: false
    // Optional: false
    samplerYcbcrConversionComponents: VkComponentMapping = .{},
    // Extern sync: false
    // Optional: false
    suggestedYcbcrModel: VkSamplerYcbcrModelConversion,
    // Extern sync: false
    // Optional: false
    suggestedYcbcrRange: VkSamplerYcbcrRange,
    // Extern sync: false
    // Optional: false
    suggestedXChromaOffset: VkChromaLocation,
    // Extern sync: false
    // Optional: false
    suggestedYChromaOffset: VkChromaLocation,
};
// Extension: VK_FUCHSIA_buffer_collection
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkBufferConstraintsInfoFUCHSIA = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_BUFFER_CONSTRAINTS_INFO_FUCHSIA,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    createInfo: VkBufferCreateInfo = .{},
    // Extern sync: false
    // Optional: true
    requiredFormatFeatures: VkFormatFeatureFlags = .{},
    // Extern sync: false
    // Optional: false
    bufferCollectionConstraints: VkBufferCollectionConstraintsInfoFUCHSIA = .{},
};
// Extension: VK_FUCHSIA_buffer_collection
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSysmemColorSpaceFUCHSIA = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_SYSMEM_COLOR_SPACE_FUCHSIA,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    colorSpace: u32 = 0,
};
// Extension: VK_FUCHSIA_buffer_collection
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImageFormatConstraintsInfoFUCHSIA = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_IMAGE_FORMAT_CONSTRAINTS_INFO_FUCHSIA,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    imageCreateInfo: VkImageCreateInfo = .{},
    // Extern sync: false
    // Optional: false
    requiredFormatFeatures: VkFormatFeatureFlags = .{},
    // Extern sync: false
    // Optional: true
    flags: VkImageFormatConstraintsFlagsFUCHSIA = .{},
    // Extern sync: false
    // Optional: true
    sysmemPixelFormat: u64 = 0,
    // Extern sync: false
    // Optional: false
    colorSpaceCount: u32 = 0,
    // Length member: colorSpaceCount
    // Extern sync: false
    // Optional: false
    pColorSpaces: ?[*]const VkSysmemColorSpaceFUCHSIA = null,
};
// Extension: VK_FUCHSIA_buffer_collection
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImageConstraintsInfoFUCHSIA = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_IMAGE_CONSTRAINTS_INFO_FUCHSIA,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    formatConstraintsCount: u32 = 0,
    // Length member: formatConstraintsCount
    // Extern sync: false
    // Optional: false
    pFormatConstraints: ?[*]const VkImageFormatConstraintsInfoFUCHSIA = null,
    // Extern sync: false
    // Optional: false
    bufferCollectionConstraints: VkBufferCollectionConstraintsInfoFUCHSIA = .{},
    // Extern sync: false
    // Optional: true
    flags: VkImageConstraintsInfoFlagsFUCHSIA = .{},
};
// Extension: VK_FUCHSIA_buffer_collection
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkBufferCollectionConstraintsInfoFUCHSIA = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_BUFFER_COLLECTION_CONSTRAINTS_INFO_FUCHSIA,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    minBufferCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxBufferCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    minBufferCountForCamping: u32 = 0,
    // Extern sync: false
    // Optional: false
    minBufferCountForDedicatedSlack: u32 = 0,
    // Extern sync: false
    // Optional: false
    minBufferCountForSharedSlack: u32 = 0,
};
// Extension: VK_NV_cuda_kernel_launch
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkCudaModuleCreateInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_CUDA_MODULE_CREATE_INFO_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    dataSize: u64 = 0,
    // Length member: dataSize
    // Extern sync: false
    // Optional: false
    pData: ?[*]const anyopaque = null,
};
// Extension: VK_NV_cuda_kernel_launch
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkCudaFunctionCreateInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_CUDA_FUNCTION_CREATE_INFO_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    module: VkCudaModuleNV = .none,
    // Length member: null-terminated
    // Extern sync: false
    // Optional: false
    pName: ?[*:0]const u8 = null,
};
// Extension: VK_NV_cuda_kernel_launch
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkCudaLaunchInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_CUDA_LAUNCH_INFO_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    function: VkCudaFunctionNV = .none,
    // Extern sync: false
    // Optional: false
    gridDimX: u32 = 0,
    // Extern sync: false
    // Optional: false
    gridDimY: u32 = 0,
    // Extern sync: false
    // Optional: false
    gridDimZ: u32 = 0,
    // Extern sync: false
    // Optional: false
    blockDimX: u32 = 0,
    // Extern sync: false
    // Optional: false
    blockDimY: u32 = 0,
    // Extern sync: false
    // Optional: false
    blockDimZ: u32 = 0,
    // Extern sync: false
    // Optional: false
    sharedMemBytes: u32 = 0,
    // Extern sync: false
    // Optional: true
    paramCount: u64 = 0,
    // Length member: paramCount
    // Extern sync: false
    // Optional: false
    pParams: ?[*]const *const anyopaque = null,
    // Extern sync: false
    // Optional: true
    extraCount: u64 = 0,
    // Length member: extraCount
    // Extern sync: false
    // Optional: false
    pExtras: ?[*]const *const anyopaque = null,
};
// Extension: VK_EXT_rgba10x6_formats
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    formatRgba10x6WithoutYCbCrSampler: u32 = 0,
};
// Extension: VK_BASE_VERSION_1_3
// Extends: VkFormatProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkFormatProperties3 = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: true
    linearTilingFeatures: VkFormatFeatureFlags2 = .{},
    // Extern sync: false
    // Optional: true
    optimalTilingFeatures: VkFormatFeatureFlags2 = .{},
    // Extern sync: false
    // Optional: true
    bufferFeatures: VkFormatFeatureFlags2 = .{},
};
// Extension: VK_KHR_format_feature_flags2
pub const VkFormatProperties3KHR = VkFormatProperties3;
// Extension: VK_EXT_image_drm_format_modifier
// Extends: VkFormatProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkDrmFormatModifierPropertiesList2EXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: true
    drmFormatModifierCount: u32 = 0,
    // Length member: drmFormatModifierCount
    // Extern sync: false
    // Optional: true
    pDrmFormatModifierProperties: ?[*]VkDrmFormatModifierProperties2EXT = null,
};
// Extension: VK_EXT_image_drm_format_modifier
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkDrmFormatModifierProperties2EXT = extern struct {
    // Extern sync: false
    // Optional: false
    drmFormatModifier: u64 = 0,
    // Extern sync: false
    // Optional: false
    drmFormatModifierPlaneCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    drmFormatModifierTilingFeatures: VkFormatFeatureFlags2 = .{},
};
// Extension: VK_ANDROID_external_memory_android_hardware_buffer
// Extends: VkAndroidHardwareBufferPropertiesANDROID
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkAndroidHardwareBufferFormatProperties2ANDROID = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_2_ANDROID,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    format: VkFormat,
    // Extern sync: false
    // Optional: false
    externalFormat: u64 = 0,
    // Extern sync: false
    // Optional: false
    formatFeatures: VkFormatFeatureFlags2 = .{},
    // Extern sync: false
    // Optional: false
    samplerYcbcrConversionComponents: VkComponentMapping = .{},
    // Extern sync: false
    // Optional: false
    suggestedYcbcrModel: VkSamplerYcbcrModelConversion,
    // Extern sync: false
    // Optional: false
    suggestedYcbcrRange: VkSamplerYcbcrRange,
    // Extern sync: false
    // Optional: false
    suggestedXChromaOffset: VkChromaLocation,
    // Extern sync: false
    // Optional: false
    suggestedYChromaOffset: VkChromaLocation,
};
// Extension: VK_GRAPHICS_VERSION_1_3
// Extends: VkGraphicsPipelineCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineRenderingCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    viewMask: u32 = 0,
    // Extern sync: false
    // Optional: true
    colorAttachmentCount: u32 = 0,
    // Length member: colorAttachmentCount
    // Extern sync: false
    // Optional: false
    pColorAttachmentFormats: ?[*]const VkFormat = null,
    // Extern sync: false
    // Optional: false
    depthAttachmentFormat: VkFormat,
    // Extern sync: false
    // Optional: false
    stencilAttachmentFormat: VkFormat,
};
// Extension: VK_KHR_dynamic_rendering
pub const VkPipelineRenderingCreateInfoKHR = VkPipelineRenderingCreateInfo;
// Extension: VK_GRAPHICS_VERSION_1_3
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkRenderingInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_RENDERING_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkRenderingFlags = .{},
    // Extern sync: false
    // Optional: false
    renderArea: VkRect2D = .{},
    // Extern sync: false
    // Optional: false
    layerCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    viewMask: u32 = 0,
    // Extern sync: false
    // Optional: true
    colorAttachmentCount: u32 = 0,
    // Length member: colorAttachmentCount
    // Extern sync: false
    // Optional: false
    pColorAttachments: ?[*]const VkRenderingAttachmentInfo = null,
    // Extern sync: false
    // Optional: true
    pDepthAttachment: ?*const VkRenderingAttachmentInfo = null,
    // Extern sync: false
    // Optional: true
    pStencilAttachment: ?*const VkRenderingAttachmentInfo = null,
};
// Extension: VK_KHR_dynamic_rendering
// Extension: VK_QCOM_tile_properties
pub const VkRenderingInfoKHR = VkRenderingInfo;
// Extension: VK_KHR_maintenance10
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkRenderingEndInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_RENDERING_END_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
};
// Extension: VK_EXT_fragment_density_map_offset
pub const VkRenderingEndInfoEXT = VkRenderingEndInfoKHR;
// Extension: VK_GRAPHICS_VERSION_1_3
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkRenderingAttachmentInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    imageView: VkImageView = .none,
    // Extern sync: false
    // Optional: false
    imageLayout: VkImageLayout,
    // Extern sync: false
    // Optional: true
    resolveMode: VkResolveModeFlags = .{},
    // Extern sync: false
    // Optional: true
    resolveImageView: VkImageView = .none,
    // Extern sync: false
    // Optional: false
    resolveImageLayout: VkImageLayout,
    // Extern sync: false
    // Optional: false
    loadOp: VkAttachmentLoadOp,
    // Extern sync: false
    // Optional: false
    storeOp: VkAttachmentStoreOp,
    // Extern sync: false
    // Optional: false
    clearValue: VkClearValue,
};
// Extension: VK_KHR_dynamic_rendering
pub const VkRenderingAttachmentInfoKHR = VkRenderingAttachmentInfo;
// Extension: VK_KHR_fragment_shading_rate
// Extends: VkRenderingInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkRenderingFragmentShadingRateAttachmentInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    imageView: VkImageView = .none,
    // Extern sync: false
    // Optional: false
    imageLayout: VkImageLayout,
    // Extern sync: false
    // Optional: false
    shadingRateAttachmentTexelSize: VkExtent2D = .{},
};
// Extension: VK_EXT_fragment_density_map
// Extends: VkRenderingInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkRenderingFragmentDensityMapAttachmentInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    imageView: VkImageView = .none,
    // Extern sync: false
    // Optional: false
    imageLayout: VkImageLayout,
};
// Extension: VK_GRAPHICS_VERSION_1_3
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceDynamicRenderingFeatures = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    dynamicRendering: u32 = 0,
};
// Extension: VK_KHR_dynamic_rendering
pub const VkPhysicalDeviceDynamicRenderingFeaturesKHR = VkPhysicalDeviceDynamicRenderingFeatures;
// Extension: VK_GRAPHICS_VERSION_1_3
// Extends: VkCommandBufferInheritanceInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkCommandBufferInheritanceRenderingInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkRenderingFlags = .{},
    // Extern sync: false
    // Optional: false
    viewMask: u32 = 0,
    // Extern sync: false
    // Optional: true
    colorAttachmentCount: u32 = 0,
};
// Extension: VK_KHR_dynamic_rendering
pub const VkCommandBufferInheritanceRenderingInfoKHR = VkCommandBufferInheritanceRenderingInfo;
// Extension: VK_AMD_mixed_attachment_samples
// Extends: VkCommandBufferInheritanceInfo,VkGraphicsPipelineCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkAttachmentSampleCountInfoAMD = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    colorAttachmentCount: u32 = 0,
    // Length member: colorAttachmentCount
    // Extern sync: false
    // Optional: false
    pColorAttachmentSamples: ?[*]const VkSampleCountFlags = null,
    // Extern sync: false
    // Optional: true
    depthStencilAttachmentSamples: VkSampleCountFlags = .{},
};
// Extension: VK_NV_framebuffer_mixed_samples
pub const VkAttachmentSampleCountInfoNV = VkAttachmentSampleCountInfoAMD;
// Extension: VK_NVX_multiview_per_view_attributes
// Extends: VkCommandBufferInheritanceInfo,VkGraphicsPipelineCreateInfo,VkRenderingInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkMultiviewPerViewAttributesInfoNVX = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_NVX,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    perViewAttributes: u32 = 0,
    // Extern sync: false
    // Optional: false
    perViewAttributesPositionXOnly: u32 = 0,
};
// Extension: VK_EXT_image_view_min_lod
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceImageViewMinLodFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    minLod: u32 = 0,
};
// Extension: VK_EXT_image_view_min_lod
// Extends: VkImageViewCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImageViewMinLodCreateInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_IMAGE_VIEW_MIN_LOD_CREATE_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    minLod: f32 = 0,
};
// Extension: VK_EXT_rasterization_order_attachment_access
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    rasterizationOrderColorAttachmentAccess: u32 = 0,
    // Extern sync: false
    // Optional: false
    rasterizationOrderDepthAttachmentAccess: u32 = 0,
    // Extern sync: false
    // Optional: false
    rasterizationOrderStencilAttachmentAccess: u32 = 0,
};
// Extension: VK_ARM_rasterization_order_attachment_access
pub const VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesARM = VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT;
// Extension: VK_NV_linear_color_attachment
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceLinearColorAttachmentFeaturesNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINEAR_COLOR_ATTACHMENT_FEATURES_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    linearColorAttachment: u32 = 0,
};
// Extension: VK_EXT_graphics_pipeline_library
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    graphicsPipelineLibrary: u32 = 0,
};
// Extension: VK_KHR_pipeline_binary
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDevicePipelineBinaryFeaturesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_FEATURES_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    pipelineBinaries: u32 = 0,
};
// Extension: VK_KHR_pipeline_binary
// Extends: VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDevicePipelineBinaryInternalCacheControlKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_DEVICE_PIPELINE_BINARY_INTERNAL_CACHE_CONTROL_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    disableInternalCache: u32 = 0,
};
// Extension: VK_KHR_pipeline_binary
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDevicePipelineBinaryPropertiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_PROPERTIES_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    pipelineBinaryInternalCache: u32 = 0,
    // Extern sync: false
    // Optional: false
    pipelineBinaryInternalCacheControl: u32 = 0,
    // Extern sync: false
    // Optional: false
    pipelineBinaryPrefersInternalCache: u32 = 0,
    // Extern sync: false
    // Optional: false
    pipelineBinaryPrecompiledInternalCache: u32 = 0,
    // Extern sync: false
    // Optional: false
    pipelineBinaryCompressedData: u32 = 0,
};
// Extension: VK_EXT_graphics_pipeline_library
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_PROPERTIES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    graphicsPipelineLibraryFastLinking: u32 = 0,
    // Extern sync: false
    // Optional: false
    graphicsPipelineLibraryIndependentInterpolationDecoration: u32 = 0,
};
// Extension: VK_EXT_graphics_pipeline_library
// Extends: VkGraphicsPipelineCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkGraphicsPipelineLibraryCreateInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_LIBRARY_CREATE_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    flags: VkGraphicsPipelineLibraryFlagsEXT = .{},
};
// Extension: VK_VALVE_descriptor_set_host_mapping
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    descriptorSetHostMapping: u32 = 0,
};
// Extension: VK_VALVE_descriptor_set_host_mapping
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDescriptorSetBindingReferenceVALVE = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_BINDING_REFERENCE_VALVE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    descriptorSetLayout: VkDescriptorSetLayout = .none,
    // Extern sync: false
    // Optional: false
    binding: u32 = 0,
};
// Extension: VK_VALVE_descriptor_set_host_mapping
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDescriptorSetLayoutHostMappingInfoVALVE = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_HOST_MAPPING_INFO_VALVE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    descriptorOffset: u64 = 0,
    // Extern sync: false
    // Optional: false
    descriptorSize: u32 = 0,
};
// Extension: VK_EXT_nested_command_buffer
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceNestedCommandBufferFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_FEATURES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    nestedCommandBuffer: u32 = 0,
    // Extern sync: false
    // Optional: false
    nestedCommandBufferRendering: u32 = 0,
    // Extern sync: false
    // Optional: false
    nestedCommandBufferSimultaneousUse: u32 = 0,
};
// Extension: VK_EXT_nested_command_buffer
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceNestedCommandBufferPropertiesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_PROPERTIES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    maxCommandBufferNestingLevel: u32 = 0,
};
// Extension: VK_EXT_shader_module_identifier
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    shaderModuleIdentifier: u32 = 0,
};
// Extension: VK_EXT_shader_module_identifier
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_PROPERTIES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    shaderModuleIdentifierAlgorithmUUID: [VK_UUID_SIZE]u8 = @import("std").mem.zeroes([VK_UUID_SIZE]u8),
};
// Extension: VK_EXT_shader_module_identifier
// Extends: VkPipelineShaderStageCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineShaderStageModuleIdentifierCreateInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_MODULE_IDENTIFIER_CREATE_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    identifierSize: u32 = 0,
    // Length member: identifierSize
    // Extern sync: false
    // Optional: false
    pIdentifier: ?[*]const u8 = null,
};
// Extension: VK_EXT_shader_module_identifier
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkShaderModuleIdentifierEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_SHADER_MODULE_IDENTIFIER_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    identifierSize: u32 = 0,
    // Length member: identifierSize
    // Extern sync: false
    // Optional: false
    identifier: [VK_MAX_SHADER_MODULE_IDENTIFIER_SIZE_EXT]u8 = @import("std").mem.zeroes([VK_MAX_SHADER_MODULE_IDENTIFIER_SIZE_EXT]u8),
};
// Extension: VK_EXT_image_compression_control
// Extends: VkImageCreateInfo,VkSwapchainCreateInfoKHR,VkPhysicalDeviceImageFormatInfo2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImageCompressionControlEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    flags: VkImageCompressionFlagsEXT = .{},
    // Extern sync: false
    // Optional: true
    compressionControlPlaneCount: u32 = 0,
    // Length member: compressionControlPlaneCount
    // Extern sync: false
    // Optional: false
    pFixedRateFlags: ?[*]VkImageCompressionFixedRateFlagsEXT = null,
};
// Extension: VK_EXT_image_compression_control
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceImageCompressionControlFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    imageCompressionControl: u32 = 0,
};
// Extension: VK_EXT_image_compression_control
// Extends: VkImageFormatProperties2,VkSurfaceFormat2KHR,VkSubresourceLayout2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkImageCompressionPropertiesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    imageCompressionFlags: VkImageCompressionFlagsEXT = .{},
    // Extern sync: false
    // Optional: false
    imageCompressionFixedRateFlags: VkImageCompressionFixedRateFlagsEXT = .{},
};
// Extension: VK_EXT_image_compression_control_swapchain
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    imageCompressionControlSwapchain: u32 = 0,
};
// Extension: VK_BASE_VERSION_1_4
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImageSubresource2 = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    imageSubresource: VkImageSubresource = .{},
};
// Extension: VK_KHR_maintenance5
pub const VkImageSubresource2KHR = VkImageSubresource2;
// Extension: VK_EXT_host_image_copy
// Extension: VK_EXT_image_compression_control
pub const VkImageSubresource2EXT = VkImageSubresource2;
// Extension: VK_BASE_VERSION_1_4
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkSubresourceLayout2 = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    subresourceLayout: VkSubresourceLayout = .{},
};
// Extension: VK_KHR_maintenance5
pub const VkSubresourceLayout2KHR = VkSubresourceLayout2;
// Extension: VK_EXT_host_image_copy
// Extension: VK_EXT_image_compression_control
pub const VkSubresourceLayout2EXT = VkSubresourceLayout2;
// Extension: VK_EXT_subpass_merge_feedback
// Extends: VkRenderPassCreateInfo2,VkSubpassDescription2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkRenderPassCreationControlEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_CONTROL_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    disallowMerging: u32 = 0,
};
// Extension: VK_EXT_subpass_merge_feedback
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkRenderPassCreationFeedbackInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    postMergeSubpassCount: u32 = 0,
};
// Extension: VK_EXT_subpass_merge_feedback
// Extends: VkRenderPassCreateInfo2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkRenderPassCreationFeedbackCreateInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_FEEDBACK_CREATE_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    pRenderPassFeedback: ?*VkRenderPassCreationFeedbackInfoEXT = null,
};
// Extension: VK_EXT_subpass_merge_feedback
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkRenderPassSubpassFeedbackInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    subpassMergeStatus: VkSubpassMergeStatusEXT,
    // Length member: null-terminated
    // Extern sync: false
    // Optional: false
    description: [VK_MAX_DESCRIPTION_SIZE]u8 = @import("std").mem.zeroes([VK_MAX_DESCRIPTION_SIZE]u8),
    // Extern sync: false
    // Optional: false
    postMergeIndex: u32 = 0,
};
// Extension: VK_EXT_subpass_merge_feedback
// Extends: VkSubpassDescription2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkRenderPassSubpassFeedbackCreateInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_RENDER_PASS_SUBPASS_FEEDBACK_CREATE_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    pSubpassFeedback: ?*VkRenderPassSubpassFeedbackInfoEXT = null,
};
// Extension: VK_EXT_subpass_merge_feedback
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    subpassMergeFeedback: u32 = 0,
};
// Extension: VK_EXT_opacity_micromap
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkMicromapBuildInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_MICROMAP_BUILD_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    type: VkMicromapTypeEXT,
    // Extern sync: false
    // Optional: true
    flags: VkBuildMicromapFlagsEXT = .{},
    // Extern sync: false
    // Optional: false
    mode: VkBuildMicromapModeEXT,
    // Extern sync: false
    // Optional: true
    dstMicromap: VkMicromapEXT = .none,
    // Extern sync: false
    // Optional: true
    usageCountsCount: u32 = 0,
    // Length member: usageCountsCount
    // Extern sync: false
    // Optional: true
    pUsageCounts: ?[*]const VkMicromapUsageEXT = null,
    // Length member: usageCountsCount,1
    // Extern sync: false
    // Optional: false
    ppUsageCounts: ?[*]const *const VkMicromapUsageEXT = null,
    // Extern sync: false
    // Optional: false
    data: VkDeviceOrHostAddressConstKHR,
    // Extern sync: false
    // Optional: false
    scratchData: VkDeviceOrHostAddressKHR,
    // Extern sync: false
    // Optional: false
    triangleArray: VkDeviceOrHostAddressConstKHR,
    // Extern sync: false
    // Optional: false
    triangleArrayStride: u64 = 0,
};
// Extension: VK_EXT_opacity_micromap
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkMicromapCreateInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_MICROMAP_CREATE_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    createFlags: VkMicromapCreateFlagsEXT = .{},
    // Extern sync: false
    // Optional: false
    buffer: VkBuffer = .none,
    // Extern sync: false
    // Optional: false
    // Comment: Specified in bytes
    offset: u64 = 0,
    // Extern sync: false
    // Optional: false
    size: u64 = 0,
    // Extern sync: false
    // Optional: false
    type: VkMicromapTypeEXT,
    // Extern sync: false
    // Optional: true
    deviceAddress: u64 = 0,
};
// Extension: VK_EXT_opacity_micromap
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkMicromapVersionInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_MICROMAP_VERSION_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Length member: 2*VK_UUID_SIZE
    // Extern sync: false
    // Optional: false
    pVersionData: ?[*]const u8 = null,
};
// Extension: VK_EXT_opacity_micromap
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkCopyMicromapInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_COPY_MICROMAP_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    src: VkMicromapEXT = .none,
    // Extern sync: false
    // Optional: false
    dst: VkMicromapEXT = .none,
    // Extern sync: false
    // Optional: false
    mode: VkCopyMicromapModeEXT,
};
// Extension: VK_EXT_opacity_micromap
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkCopyMicromapToMemoryInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_COPY_MICROMAP_TO_MEMORY_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    src: VkMicromapEXT = .none,
    // Extern sync: false
    // Optional: false
    dst: VkDeviceOrHostAddressKHR,
    // Extern sync: false
    // Optional: false
    mode: VkCopyMicromapModeEXT,
};
// Extension: VK_EXT_opacity_micromap
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkCopyMemoryToMicromapInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_COPY_MEMORY_TO_MICROMAP_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    src: VkDeviceOrHostAddressConstKHR,
    // Extern sync: false
    // Optional: false
    dst: VkMicromapEXT = .none,
    // Extern sync: false
    // Optional: false
    mode: VkCopyMicromapModeEXT,
};
// Extension: VK_EXT_opacity_micromap
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkMicromapBuildSizesInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_MICROMAP_BUILD_SIZES_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    micromapSize: u64 = 0,
    // Extern sync: false
    // Optional: false
    buildScratchSize: u64 = 0,
    // Extern sync: false
    // Optional: false
    discardable: u32 = 0,
};
// Extension: VK_EXT_opacity_micromap
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkMicromapUsageEXT = extern struct {
    // Extern sync: false
    // Optional: false
    count: u32 = 0,
    // Extern sync: false
    // Optional: false
    subdivisionLevel: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Interpretation depends on parent type
    format: u32 = 0,
};
// Extension: VK_EXT_opacity_micromap
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkMicromapTriangleEXT = extern struct {
    // Extern sync: false
    // Optional: false
    // Comment: Specified in bytes
    dataOffset: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Extern sync: false
    // Optional: false
};
// Extension: VK_EXT_opacity_micromap
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceOpacityMicromapFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_FEATURES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    micromap: u32 = 0,
    // Extern sync: false
    // Optional: false
    micromapCaptureReplay: u32 = 0,
    // Extern sync: false
    // Optional: false
    micromapHostCommands: u32 = 0,
};
// Extension: VK_EXT_opacity_micromap
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceOpacityMicromapPropertiesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_PROPERTIES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    maxOpacity2StateSubdivisionLevel: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxOpacity4StateSubdivisionLevel: u32 = 0,
};
// Extension: VK_EXT_opacity_micromap
// Extends: VkAccelerationStructureGeometryTrianglesDataKHR,VkAccelerationStructureDenseGeometryFormatTrianglesDataAMDX
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkAccelerationStructureTrianglesOpacityMicromapEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_OPACITY_MICROMAP_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    indexType: VkIndexType,
    // Extern sync: false
    // Optional: false
    indexBuffer: VkDeviceOrHostAddressConstKHR,
    // Extern sync: false
    // Optional: false
    indexStride: u64 = 0,
    // Extern sync: false
    // Optional: false
    baseTriangle: u32 = 0,
    // Extern sync: false
    // Optional: true
    usageCountsCount: u32 = 0,
    // Length member: usageCountsCount
    // Extern sync: false
    // Optional: true
    pUsageCounts: ?[*]const VkMicromapUsageEXT = null,
    // Length member: usageCountsCount,1
    // Extern sync: false
    // Optional: false
    ppUsageCounts: ?[*]const *const VkMicromapUsageEXT = null,
    // Extern sync: false
    // Optional: true
    micromap: VkMicromapEXT = .none,
};
// Extension: VK_NV_displacement_micromap
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceDisplacementMicromapFeaturesNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISPLACEMENT_MICROMAP_FEATURES_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    displacementMicromap: u32 = 0,
};
// Extension: VK_NV_displacement_micromap
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceDisplacementMicromapPropertiesNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISPLACEMENT_MICROMAP_PROPERTIES_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    maxDisplacementMicromapSubdivisionLevel: u32 = 0,
};
// Extension: VK_NV_displacement_micromap
// Extends: VkAccelerationStructureGeometryTrianglesDataKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkAccelerationStructureTrianglesDisplacementMicromapNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_DISPLACEMENT_MICROMAP_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    displacementBiasAndScaleFormat: VkFormat,
    // Extern sync: false
    // Optional: false
    displacementVectorFormat: VkFormat,
    // Extern sync: false
    // Optional: false
    displacementBiasAndScaleBuffer: VkDeviceOrHostAddressConstKHR,
    // Extern sync: false
    // Optional: false
    displacementBiasAndScaleStride: u64 = 0,
    // Extern sync: false
    // Optional: false
    displacementVectorBuffer: VkDeviceOrHostAddressConstKHR,
    // Extern sync: false
    // Optional: false
    displacementVectorStride: u64 = 0,
    // Extern sync: false
    // Optional: false
    displacedMicromapPrimitiveFlags: VkDeviceOrHostAddressConstKHR,
    // Extern sync: false
    // Optional: false
    displacedMicromapPrimitiveFlagsStride: u64 = 0,
    // Extern sync: false
    // Optional: false
    indexType: VkIndexType,
    // Extern sync: false
    // Optional: false
    indexBuffer: VkDeviceOrHostAddressConstKHR,
    // Extern sync: false
    // Optional: false
    indexStride: u64 = 0,
    // Extern sync: false
    // Optional: false
    baseTriangle: u32 = 0,
    // Extern sync: false
    // Optional: true
    usageCountsCount: u32 = 0,
    // Length member: usageCountsCount
    // Extern sync: false
    // Optional: true
    pUsageCounts: ?[*]const VkMicromapUsageEXT = null,
    // Length member: usageCountsCount,1
    // Extern sync: false
    // Optional: false
    ppUsageCounts: ?[*]const *const VkMicromapUsageEXT = null,
    // Extern sync: false
    // Optional: true
    micromap: VkMicromapEXT = .none,
};
// Extension: VK_EXT_pipeline_properties
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPipelinePropertiesIdentifierEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_PROPERTIES_IDENTIFIER_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    pipelineIdentifier: [VK_UUID_SIZE]u8 = @import("std").mem.zeroes([VK_UUID_SIZE]u8),
};
// Extension: VK_EXT_pipeline_properties
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDevicePipelinePropertiesFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROPERTIES_FEATURES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    pipelinePropertiesIdentifier: u32 = 0,
};
// Extension: VK_AMD_shader_early_and_late_fragment_tests
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_FEATURES_AMD,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    shaderEarlyAndLateFragmentTests: u32 = 0,
};
// Extension: VK_EXT_external_memory_acquire_unmodified
// Extends: VkBufferMemoryBarrier,VkBufferMemoryBarrier2,VkImageMemoryBarrier,VkImageMemoryBarrier2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkExternalMemoryAcquireUnmodifiedEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    acquireUnmodifiedMemory: u32 = 0,
};
// Extension: VK_EXT_metal_objects
// Extends: VkInstanceCreateInfo,VkMemoryAllocateInfo,VkImageCreateInfo,VkImageViewCreateInfo,VkBufferViewCreateInfo,VkSemaphoreCreateInfo,VkEventCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: true
pub const VkExportMetalObjectCreateInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    exportObjectType: VkExportMetalObjectTypeFlagsEXT = .{},
};
// Extension: VK_EXT_metal_objects
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkExportMetalObjectsInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECTS_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
};
// Extension: VK_EXT_metal_objects
// Extends: VkExportMetalObjectsInfoEXT
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkExportMetalDeviceInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_EXPORT_METAL_DEVICE_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
};
// Extension: VK_EXT_metal_objects
// Extends: VkExportMetalObjectsInfoEXT
// Returned only: false
// Allow duplicate in pNext chain: true
pub const VkExportMetalCommandQueueInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_EXPORT_METAL_COMMAND_QUEUE_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    queue: VkQueue = .none,
    // Extern sync: false
    // Optional: false
};
// Extension: VK_EXT_metal_objects
// Extends: VkExportMetalObjectsInfoEXT
// Returned only: false
// Allow duplicate in pNext chain: true
pub const VkExportMetalBufferInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_EXPORT_METAL_BUFFER_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    memory: VkDeviceMemory = .none,
    // Extern sync: false
    // Optional: false
};
// Extension: VK_EXT_metal_objects
// Extends: VkMemoryAllocateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImportMetalBufferInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_IMPORT_METAL_BUFFER_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
};
// Extension: VK_EXT_metal_objects
// Extends: VkExportMetalObjectsInfoEXT
// Returned only: false
// Allow duplicate in pNext chain: true
pub const VkExportMetalTextureInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_EXPORT_METAL_TEXTURE_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    image: VkImage = .none,
    // Extern sync: false
    // Optional: true
    imageView: VkImageView = .none,
    // Extern sync: false
    // Optional: true
    bufferView: VkBufferView = .none,
    // Extern sync: false
    // Optional: false
    plane: VkImageAspectFlags = .{},
    // Extern sync: false
    // Optional: false
};
// Extension: VK_EXT_metal_objects
// Extends: VkImageCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: true
pub const VkImportMetalTextureInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_IMPORT_METAL_TEXTURE_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    plane: VkImageAspectFlags = .{},
    // Extern sync: false
    // Optional: false
};
// Extension: VK_EXT_metal_objects
// Extends: VkExportMetalObjectsInfoEXT
// Returned only: false
// Allow duplicate in pNext chain: true
pub const VkExportMetalIOSurfaceInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_EXPORT_METAL_IO_SURFACE_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    image: VkImage = .none,
    // Extern sync: false
    // Optional: false
};
// Extension: VK_EXT_metal_objects
// Extends: VkImageCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImportMetalIOSurfaceInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_IMPORT_METAL_IO_SURFACE_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
};
// Extension: VK_EXT_metal_objects
// Extends: VkExportMetalObjectsInfoEXT
// Returned only: false
// Allow duplicate in pNext chain: true
pub const VkExportMetalSharedEventInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_EXPORT_METAL_SHARED_EVENT_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    semaphore: VkSemaphore = .none,
    // Extern sync: false
    // Optional: true
    event: VkEvent = .none,
    // Extern sync: false
    // Optional: false
};
// Extension: VK_EXT_metal_objects
// Extends: VkSemaphoreCreateInfo,VkEventCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImportMetalSharedEventInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_IMPORT_METAL_SHARED_EVENT_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
};
// Extension: VK_EXT_non_seamless_cube_map
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    nonSeamlessCubeMap: u32 = 0,
};
// Extension: VK_COMPUTE_VERSION_1_4
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDevicePipelineRobustnessFeatures = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    pipelineRobustness: u32 = 0,
};
// Extension: VK_EXT_pipeline_robustness
pub const VkPhysicalDevicePipelineRobustnessFeaturesEXT = VkPhysicalDevicePipelineRobustnessFeatures;
// Extension: VK_COMPUTE_VERSION_1_4
// Extends: VkGraphicsPipelineCreateInfo,VkComputePipelineCreateInfo,VkPipelineShaderStageCreateInfo,VkRayTracingPipelineCreateInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineRobustnessCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    storageBuffers: VkPipelineRobustnessBufferBehavior,
    // Extern sync: false
    // Optional: false
    uniformBuffers: VkPipelineRobustnessBufferBehavior,
    // Extern sync: false
    // Optional: false
    vertexInputs: VkPipelineRobustnessBufferBehavior,
    // Extern sync: false
    // Optional: false
    images: VkPipelineRobustnessImageBehavior,
};
// Extension: VK_EXT_pipeline_robustness
pub const VkPipelineRobustnessCreateInfoEXT = VkPipelineRobustnessCreateInfo;
// Extension: VK_COMPUTE_VERSION_1_4
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDevicePipelineRobustnessProperties = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    defaultRobustnessStorageBuffers: VkPipelineRobustnessBufferBehavior,
    // Extern sync: false
    // Optional: false
    defaultRobustnessUniformBuffers: VkPipelineRobustnessBufferBehavior,
    // Extern sync: false
    // Optional: false
    defaultRobustnessVertexInputs: VkPipelineRobustnessBufferBehavior,
    // Extern sync: false
    // Optional: false
    defaultRobustnessImages: VkPipelineRobustnessImageBehavior,
};
// Extension: VK_EXT_pipeline_robustness
pub const VkPhysicalDevicePipelineRobustnessPropertiesEXT = VkPhysicalDevicePipelineRobustnessProperties;
// Extension: VK_QCOM_image_processing
// Extends: VkImageViewCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImageViewSampleWeightCreateInfoQCOM = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_IMAGE_VIEW_SAMPLE_WEIGHT_CREATE_INFO_QCOM,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    filterCenter: VkOffset2D = .{},
    // Extern sync: false
    // Optional: false
    filterSize: VkExtent2D = .{},
    // Extern sync: false
    // Optional: false
    numPhases: u32 = 0,
};
// Extension: VK_QCOM_image_processing
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceImageProcessingFeaturesQCOM = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_FEATURES_QCOM,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    textureSampleWeighted: u32 = 0,
    // Extern sync: false
    // Optional: false
    textureBoxFilter: u32 = 0,
    // Extern sync: false
    // Optional: false
    textureBlockMatch: u32 = 0,
};
// Extension: VK_QCOM_image_processing
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceImageProcessingPropertiesQCOM = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_PROPERTIES_QCOM,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: true
    maxWeightFilterPhases: u32 = 0,
    // Extern sync: false
    // Optional: true
    maxWeightFilterDimension: VkExtent2D = .{},
    // Extern sync: false
    // Optional: true
    maxBlockMatchRegion: VkExtent2D = .{},
    // Extern sync: false
    // Optional: true
    maxBoxFilterBlockSize: VkExtent2D = .{},
};
// Extension: VK_QCOM_tile_properties
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceTilePropertiesFeaturesQCOM = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_PROPERTIES_FEATURES_QCOM,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    tileProperties: u32 = 0,
};
// Extension: VK_QCOM_tile_properties
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkTilePropertiesQCOM = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_TILE_PROPERTIES_QCOM,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    tileSize: VkExtent3D = .{},
    // Extern sync: false
    // Optional: false
    apronSize: VkExtent2D = .{},
    // Extern sync: false
    // Optional: false
    origin: VkOffset2D = .{},
};
// Extension: VK_QCOM_tile_memory_heap
// Extends: VkCommandBufferInheritanceInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkTileMemoryBindInfoQCOM = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_TILE_MEMORY_BIND_INFO_QCOM,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    memory: VkDeviceMemory = .none,
};
// Extension: VK_SEC_amigo_profiling
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceAmigoProfilingFeaturesSEC = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_AMIGO_PROFILING_FEATURES_SEC,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    amigoProfiling: u32 = 0,
};
// Extension: VK_SEC_amigo_profiling
// Extends: VkSubmitInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkAmigoProfilingSubmitInfoSEC = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_AMIGO_PROFILING_SUBMIT_INFO_SEC,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    firstDrawTimestamp: u64 = 0,
    // Extern sync: false
    // Optional: false
    swapBufferTimestamp: u64 = 0,
};
// Extension: VK_EXT_attachment_feedback_loop_layout
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    attachmentFeedbackLoopLayout: u32 = 0,
};
// Extension: VK_EXT_depth_clamp_zero_one
pub const VkPhysicalDeviceDepthClampZeroOneFeaturesEXT = VkPhysicalDeviceDepthClampZeroOneFeaturesKHR;
// Extension: VK_KHR_unified_image_layouts
// Extends: VkRenderingAttachmentInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkAttachmentFeedbackLoopInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_ATTACHMENT_FEEDBACK_LOOP_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    feedbackLoopEnable: u32 = 0,
};
// Extension: VK_EXT_device_address_binding_report
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceAddressBindingReportFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ADDRESS_BINDING_REPORT_FEATURES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    reportAddressBinding: u32 = 0,
};
// Extension: VK_KHR_maintenance10
// Extends: VkRenderingAttachmentInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkRenderingAttachmentFlagsInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_FLAGS_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkRenderingAttachmentFlagsKHR = .{},
};
// Extension: VK_KHR_maintenance10
// Extends: VkResolveImageInfo2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkResolveImageModeInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_RESOLVE_IMAGE_MODE_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkResolveImageFlagsKHR = .{},
    // Extern sync: false
    // Optional: true
    resolveMode: VkResolveModeFlags = .{},
    // Extern sync: false
    // Optional: true
    stencilResolveMode: VkResolveModeFlags = .{},
};
// Extension: VK_EXT_device_address_binding_report
// Extends: VkDebugUtilsMessengerCallbackDataEXT
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDeviceAddressBindingCallbackDataEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_DEVICE_ADDRESS_BINDING_CALLBACK_DATA_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkDeviceAddressBindingFlagsEXT = .{},
    // Extern sync: false
    // Optional: false
    baseAddress: u64 = 0,
    // Extern sync: false
    // Optional: false
    size: u64 = 0,
    // Extern sync: false
    // Optional: false
    bindingType: VkDeviceAddressBindingTypeEXT,
};
// Extension: VK_NV_optical_flow
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceOpticalFlowFeaturesNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_FEATURES_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    opticalFlow: u32 = 0,
};
// Extension: VK_NV_optical_flow
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceOpticalFlowPropertiesNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_PROPERTIES_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    supportedOutputGridSizes: VkOpticalFlowGridSizeFlagsNV = .{},
    // Extern sync: false
    // Optional: false
    supportedHintGridSizes: VkOpticalFlowGridSizeFlagsNV = .{},
    // Extern sync: false
    // Optional: false
    hintSupported: u32 = 0,
    // Extern sync: false
    // Optional: false
    costSupported: u32 = 0,
    // Extern sync: false
    // Optional: false
    bidirectionalFlowSupported: u32 = 0,
    // Extern sync: false
    // Optional: false
    globalFlowSupported: u32 = 0,
    // Extern sync: false
    // Optional: false
    minWidth: u32 = 0,
    // Extern sync: false
    // Optional: false
    minHeight: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxWidth: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxHeight: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxNumRegionsOfInterest: u32 = 0,
};
// Extension: VK_NV_optical_flow
// Extends: VkPhysicalDeviceImageFormatInfo2,VkImageCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkOpticalFlowImageFormatInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    usage: VkOpticalFlowUsageFlagsNV = .{},
};
// Extension: VK_NV_optical_flow
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkOpticalFlowImageFormatPropertiesNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_PROPERTIES_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    format: VkFormat,
};
// Extension: VK_NV_optical_flow
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkOpticalFlowSessionCreateInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_INFO_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    width: u32 = 0,
    // Extern sync: false
    // Optional: false
    height: u32 = 0,
    // Extern sync: false
    // Optional: false
    imageFormat: VkFormat,
    // Extern sync: false
    // Optional: false
    flowVectorFormat: VkFormat,
    // Extern sync: false
    // Optional: true
    costFormat: VkFormat,
    // Extern sync: false
    // Optional: false
    outputGridSize: VkOpticalFlowGridSizeFlagsNV = .{},
    // Extern sync: false
    // Optional: true
    hintGridSize: VkOpticalFlowGridSizeFlagsNV = .{},
    // Extern sync: false
    // Optional: true
    performanceLevel: VkOpticalFlowPerformanceLevelNV,
    // Extern sync: false
    // Optional: true
    flags: VkOpticalFlowSessionCreateFlagsNV = .{},
};
// Extension: VK_NV_optical_flow
// Extends: VkOpticalFlowSessionCreateInfoNV
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkOpticalFlowSessionCreatePrivateDataInfoNV = extern struct {
};
// Extension: VK_NV_optical_flow
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkOpticalFlowExecuteInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_OPTICAL_FLOW_EXECUTE_INFO_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkOpticalFlowExecuteFlagsNV = .{},
    // Extern sync: false
    // Optional: true
    regionCount: u32 = 0,
    // Length member: regionCount
    // Extern sync: false
    // Optional: false
    pRegions: ?[*]const VkRect2D = null,
};
// Extension: VK_EXT_device_fault
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceFaultFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FAULT_FEATURES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    deviceFault: u32 = 0,
    // Extern sync: false
    // Optional: false
    deviceFaultVendorBinary: u32 = 0,
};
// Extension: VK_EXT_device_fault
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDeviceFaultAddressInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    addressType: VkDeviceFaultAddressTypeEXT,
    // Extern sync: false
    // Optional: false
    reportedAddress: u64 = 0,
    // Extern sync: false
    // Optional: false
    addressPrecision: u64 = 0,
};
// Extension: VK_EXT_device_fault
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDeviceFaultVendorInfoEXT = extern struct {
    // Length member: null-terminated
    // Extern sync: false
    // Optional: false
    description: [VK_MAX_DESCRIPTION_SIZE]u8 = @import("std").mem.zeroes([VK_MAX_DESCRIPTION_SIZE]u8),
    // Extern sync: false
    // Optional: false
    vendorFaultCode: u64 = 0,
    // Extern sync: false
    // Optional: false
    vendorFaultData: u64 = 0,
};
// Extension: VK_EXT_device_fault
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDeviceFaultCountsEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_DEVICE_FAULT_COUNTS_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: true
    addressInfoCount: u32 = 0,
    // Extern sync: false
    // Optional: true
    vendorInfoCount: u32 = 0,
    // Extern sync: false
    // Optional: true
    // Comment: Specified in bytes
    vendorBinarySize: u64 = 0,
};
// Extension: VK_EXT_device_fault
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkDeviceFaultInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_DEVICE_FAULT_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Length member: null-terminated
    // Extern sync: false
    // Optional: false
    description: [VK_MAX_DESCRIPTION_SIZE]u8 = @import("std").mem.zeroes([VK_MAX_DESCRIPTION_SIZE]u8),
    // Extern sync: false
    // Optional: true
    pAddressInfos: ?*VkDeviceFaultAddressInfoEXT = null,
    // Extern sync: false
    // Optional: true
    pVendorInfos: ?*VkDeviceFaultVendorInfoEXT = null,
    // Extern sync: false
    // Optional: true
    pVendorBinaryData: ?*anyopaque = null,
};
// Extension: VK_EXT_device_fault
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDeviceFaultVendorBinaryHeaderVersionOneEXT = extern struct {
};
// Extension: VK_EXT_pipeline_library_group_handles
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_LIBRARY_GROUP_HANDLES_FEATURES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    pipelineLibraryGroupHandles: u32 = 0,
};
// Extension: VK_EXT_depth_bias_control
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDepthBiasInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_DEPTH_BIAS_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    depthBiasConstantFactor: f32 = 0,
    // Extern sync: false
    // Optional: false
    depthBiasClamp: f32 = 0,
    // Extern sync: false
    // Optional: false
    depthBiasSlopeFactor: f32 = 0,
};
// Extension: VK_EXT_depth_bias_control
// Extends: VkDepthBiasInfoEXT,VkPipelineRasterizationStateCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDepthBiasRepresentationInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_DEPTH_BIAS_REPRESENTATION_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    depthBiasRepresentation: VkDepthBiasRepresentationEXT,
    // Extern sync: false
    // Optional: false
    depthBiasExact: u32 = 0,
};
// Extension: VK_NV_memory_decompression
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDecompressMemoryRegionNV = extern struct {
    // Extern sync: false
    // Optional: false
    srcAddress: u64 = 0,
    // Extern sync: false
    // Optional: false
    dstAddress: u64 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Specified in bytes
    compressedSize: u64 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Specified in bytes
    decompressedSize: u64 = 0,
    // Extern sync: false
    // Optional: false
};
// Extension: VK_EXT_memory_decompression
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDecompressMemoryRegionEXT = extern struct {
    // Extern sync: false
    // Optional: false
    srcAddress: u64 = 0,
    // Extern sync: false
    // Optional: false
    dstAddress: u64 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Specified in bytes
    compressedSize: u64 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Specified in bytes
    decompressedSize: u64 = 0,
};
// Extension: VK_EXT_memory_decompression
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDecompressMemoryInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_DECOMPRESS_MEMORY_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    decompressionMethod: VkMemoryDecompressionMethodFlagsEXT = .{},
    // Extern sync: false
    // Optional: false
    regionCount: u32 = 0,
    // Length member: regionCount
    // Extern sync: false
    // Optional: false
    pRegions: ?[*]const VkDecompressMemoryRegionEXT = null,
};
// Extension: VK_ARM_shader_core_builtins
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_PROPERTIES_ARM,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    shaderCoreMask: u64 = 0,
    // Extern sync: false
    // Optional: false
    shaderCoreCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderWarpsPerCore: u32 = 0,
};
// Extension: VK_ARM_shader_core_builtins
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_FEATURES_ARM,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    shaderCoreBuiltins: u32 = 0,
};
// Extension: VK_EXT_frame_boundary
// Extends: VkSubmitInfo,VkSubmitInfo2,VkPresentInfoKHR,VkBindSparseInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkFrameBoundaryEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkFrameBoundaryFlagsEXT = .{},
    // Extern sync: false
    // Optional: false
    frameID: u64 = 0,
    // Extern sync: false
    // Optional: true
    imageCount: u32 = 0,
    // Length member: imageCount
    // Extern sync: false
    // Optional: true
    pImages: ?[*]const VkImage = null,
    // Extern sync: false
    // Optional: true
    bufferCount: u32 = 0,
    // Length member: bufferCount
    // Extern sync: false
    // Optional: true
    pBuffers: ?[*]const VkBuffer = null,
    // Extern sync: false
    // Optional: true
    tagName: u64 = 0,
    // Extern sync: false
    // Optional: true
    tagSize: u64 = 0,
    // Length member: tagSize
    // Extern sync: false
    // Optional: true
    pTag: ?[*]const anyopaque = null,
};
// Extension: VK_EXT_frame_boundary
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceFrameBoundaryFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAME_BOUNDARY_FEATURES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    frameBoundary: u32 = 0,
};
// Extension: VK_EXT_dynamic_rendering_unused_attachments
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_FEATURES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    dynamicRenderingUnusedAttachments: u32 = 0,
};
// Extension: VK_KHR_surface_maintenance1
// Extends: VkPhysicalDeviceSurfaceInfo2KHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSurfacePresentModeKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    presentMode: VkPresentModeKHR,
};
// Extension: VK_EXT_surface_maintenance1
pub const VkSurfacePresentModeEXT = VkSurfacePresentModeKHR;
// Extension: VK_KHR_surface_maintenance1
// Extends: VkSurfaceCapabilities2KHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSurfacePresentScalingCapabilitiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_SURFACE_PRESENT_SCALING_CAPABILITIES_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: true
    supportedPresentScaling: VkPresentScalingFlagsKHR = .{},
    // Extern sync: false
    // Optional: true
    supportedPresentGravityX: VkPresentGravityFlagsKHR = .{},
    // Extern sync: false
    // Optional: true
    supportedPresentGravityY: VkPresentGravityFlagsKHR = .{},
    // Extern sync: false
    // Optional: true
    // Comment: Supported minimum image width and height for the surface when scaling is used
    minScaledImageExtent: VkExtent2D = .{},
    // Extern sync: false
    // Optional: true
    // Comment: Supported maximum image width and height for the surface when scaling is used
    maxScaledImageExtent: VkExtent2D = .{},
};
// Extension: VK_EXT_surface_maintenance1
pub const VkSurfacePresentScalingCapabilitiesEXT = VkSurfacePresentScalingCapabilitiesKHR;
// Extension: VK_KHR_surface_maintenance1
// Extends: VkSurfaceCapabilities2KHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSurfacePresentModeCompatibilityKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_COMPATIBILITY_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: true
    presentModeCount: u32 = 0,
    // Length member: presentModeCount
    // Extern sync: false
    // Optional: true
    // Comment: Output list of present modes compatible with the one specified in VkSurfacePresentModeKHR
    pPresentModes: ?[*]VkPresentModeKHR = null,
};
// Extension: VK_EXT_surface_maintenance1
pub const VkSurfacePresentModeCompatibilityEXT = VkSurfacePresentModeCompatibilityKHR;
// Extension: VK_KHR_swapchain_maintenance1
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceSwapchainMaintenance1FeaturesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    swapchainMaintenance1: u32 = 0,
};
// Extension: VK_EXT_swapchain_maintenance1
pub const VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT = VkPhysicalDeviceSwapchainMaintenance1FeaturesKHR;
// Extension: VK_KHR_swapchain_maintenance1
// Extends: VkPresentInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSwapchainPresentFenceInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: Copy of VkPresentInfoKHR::swapchainCount
    swapchainCount: u32 = 0,
    // Length member: swapchainCount
    // Extern sync: false
    // Optional: false
    // Comment: Fence to signal for each swapchain
    pFences: ?[*]const VkFence = null,
};
// Extension: VK_EXT_swapchain_maintenance1
pub const VkSwapchainPresentFenceInfoEXT = VkSwapchainPresentFenceInfoKHR;
// Extension: VK_KHR_swapchain_maintenance1
// Extends: VkSwapchainCreateInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSwapchainPresentModesCreateInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODES_CREATE_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    presentModeCount: u32 = 0,
};
// Extension: VK_EXT_swapchain_maintenance1
pub const VkSwapchainPresentModesCreateInfoEXT = VkSwapchainPresentModesCreateInfoKHR;
// Extension: VK_KHR_swapchain_maintenance1
// Extends: VkPresentInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSwapchainPresentModeInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODE_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: Copy of VkPresentInfoKHR::swapchainCount
    swapchainCount: u32 = 0,
    // Length member: swapchainCount
    // Extern sync: false
    // Optional: false
    // Comment: Presentation mode for each swapchain
    pPresentModes: ?[*]const VkPresentModeKHR = null,
};
// Extension: VK_EXT_swapchain_maintenance1
pub const VkSwapchainPresentModeInfoEXT = VkSwapchainPresentModeInfoKHR;
// Extension: VK_KHR_swapchain_maintenance1
// Extends: VkSwapchainCreateInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSwapchainPresentScalingCreateInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_SCALING_CREATE_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    scalingBehavior: VkPresentScalingFlagsKHR = .{},
    // Extern sync: false
    // Optional: true
    presentGravityX: VkPresentGravityFlagsKHR = .{},
    // Extern sync: false
    // Optional: true
    presentGravityY: VkPresentGravityFlagsKHR = .{},
};
// Extension: VK_EXT_swapchain_maintenance1
pub const VkSwapchainPresentScalingCreateInfoEXT = VkSwapchainPresentScalingCreateInfoKHR;
// Extension: VK_KHR_swapchain_maintenance1
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkReleaseSwapchainImagesInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_RELEASE_SWAPCHAIN_IMAGES_INFO_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: true
    // Optional: false
    // Comment: Swapchain for which images are being released
    swapchain: VkSwapchainKHR = .none,
    // Extern sync: false
    // Optional: false
    // Comment: Number of indices to release
    imageIndexCount: u32 = 0,
    // Length member: imageIndexCount
    // Extern sync: false
    // Optional: false
    // Comment: Indices of which presentable images to release
    pImageIndices: ?[*]const u32 = null,
};
// Extension: VK_EXT_swapchain_maintenance1
pub const VkReleaseSwapchainImagesInfoEXT = VkReleaseSwapchainImagesInfoKHR;
// Extension: VK_EXT_depth_bias_control
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceDepthBiasControlFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_BIAS_CONTROL_FEATURES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    depthBiasControl: u32 = 0,
    // Extern sync: false
    // Optional: false
    leastRepresentableValueForceUnormRepresentation: u32 = 0,
    // Extern sync: false
    // Optional: false
    floatRepresentation: u32 = 0,
    // Extern sync: false
    // Optional: false
    depthBiasExact: u32 = 0,
};
// Extension: VK_EXT_ray_tracing_invocation_reorder
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceRayTracingInvocationReorderFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_FEATURES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    rayTracingInvocationReorder: u32 = 0,
};
// Extension: VK_NV_ray_tracing_invocation_reorder
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_FEATURES_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Feature link: rayTracingInvocationReorderNV
    rayTracingInvocationReorder: u32 = 0,
};
// Extension: VK_EXT_ray_tracing_invocation_reorder
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceRayTracingInvocationReorderPropertiesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_PROPERTIES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    rayTracingInvocationReorderReorderingHint: VkRayTracingInvocationReorderModeEXT,
    // Extern sync: false
    // Optional: false
    maxShaderBindingTableRecordIndex: u32 = 0,
};
// Extension: VK_NV_ray_tracing_invocation_reorder
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_PROPERTIES_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    rayTracingInvocationReorderReorderingHint: VkRayTracingInvocationReorderModeEXT,
};
// Extension: VK_NV_extended_sparse_address_space
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_FEATURES_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    extendedSparseAddressSpace: u32 = 0,
};
// Extension: VK_NV_extended_sparse_address_space
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_PROPERTIES_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: Total address space available for extended sparse allocations (bytes)
    extendedSparseAddressSpaceSize: u64 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Bitfield of which image usages are supported for extended sparse allocations
    extendedSparseImageUsageFlags: VkImageUsageFlags = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Bitfield of which buffer usages are supported for extended sparse allocations
    extendedSparseBufferUsageFlags: VkBufferUsageFlags = .{},
};
// Extension: VK_LUNARG_direct_driver_loading
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDirectDriverLoadingInfoLUNARG = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_INFO_LUNARG,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    flags: VkDirectDriverLoadingFlagsLUNARG = .{},
    // Extern sync: false
    // Optional: false
    pfnGetInstanceProcAddr: ?*const vkGetInstanceProcAddrLUNARG = null,
};
// Extension: VK_LUNARG_direct_driver_loading
// Extends: VkInstanceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDirectDriverLoadingListLUNARG = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_LIST_LUNARG,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    mode: VkDirectDriverLoadingModeLUNARG,
    // Extern sync: false
    // Optional: false
    driverCount: u32 = 0,
    // Length member: driverCount
    // Extern sync: false
    // Optional: false
    pDrivers: ?[*]const VkDirectDriverLoadingInfoLUNARG = null,
};
// Extension: VK_QCOM_multiview_per_view_viewports
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_VIEWPORTS_FEATURES_QCOM,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    multiviewPerViewViewports: u32 = 0,
};
// Extension: VK_KHR_ray_tracing_position_fetch
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_POSITION_FETCH_FEATURES_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    rayTracingPositionFetch: u32 = 0,
};
// Extension: VK_BASE_VERSION_1_4
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDeviceImageSubresourceInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_DEVICE_IMAGE_SUBRESOURCE_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    pCreateInfo: ?*const VkImageCreateInfo = null,
    // Extern sync: false
    // Optional: false
    pSubresource: ?*const VkImageSubresource2 = null,
};
// Extension: VK_KHR_maintenance5
pub const VkDeviceImageSubresourceInfoKHR = VkDeviceImageSubresourceInfo;
// Extension: VK_ARM_shader_core_properties
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceShaderCorePropertiesARM = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_ARM,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    pixelRate: u32 = 0,
    // Extern sync: false
    // Optional: false
    texelRate: u32 = 0,
    // Extern sync: false
    // Optional: false
    fmaRate: u32 = 0,
};
// Extension: VK_QCOM_multiview_per_view_render_areas
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_RENDER_AREAS_FEATURES_QCOM,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    multiviewPerViewRenderAreas: u32 = 0,
};
// Extension: VK_QCOM_multiview_per_view_render_areas
// Extends: VkRenderPassBeginInfo,VkRenderingInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_RENDER_AREAS_RENDER_PASS_BEGIN_INFO_QCOM,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    perViewRenderAreaCount: u32 = 0,
    // Length member: perViewRenderAreaCount
    // Extern sync: false
    // Optional: false
    pPerViewRenderAreas: ?[*]const VkRect2D = null,
};
// Extension: VK_NV_low_latency
// Extends: VkSemaphoreCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkQueryLowLatencySupportNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_QUERY_LOW_LATENCY_SUPPORT_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    pQueriedLowLatencyData: ?*anyopaque = null,
};
// Extension: VK_BASE_VERSION_1_4
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkMemoryMapInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_MEMORY_MAP_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkMemoryMapFlags = .{},
    // Extern sync: true
    // Optional: false
    memory: VkDeviceMemory = .none,
    // Extern sync: false
    // Optional: false
    offset: u64 = 0,
    // Extern sync: false
    // Optional: false
    size: u64 = 0,
};
// Extension: VK_KHR_map_memory2
pub const VkMemoryMapInfoKHR = VkMemoryMapInfo;
// Extension: VK_BASE_VERSION_1_4
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkMemoryUnmapInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_MEMORY_UNMAP_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkMemoryUnmapFlags = .{},
    // Extern sync: true
    // Optional: false
    memory: VkDeviceMemory = .none,
};
// Extension: VK_KHR_map_memory2
pub const VkMemoryUnmapInfoKHR = VkMemoryUnmapInfo;
// Extension: VK_EXT_shader_object
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceShaderObjectFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_FEATURES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    shaderObject: u32 = 0,
};
// Extension: VK_EXT_shader_object
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceShaderObjectPropertiesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_PROPERTIES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    shaderBinaryUUID: [VK_UUID_SIZE]u8 = @import("std").mem.zeroes([VK_UUID_SIZE]u8),
    // Extern sync: false
    // Optional: false
    shaderBinaryVersion: u32 = 0,
};
// Extension: VK_EXT_shader_object
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkShaderCreateInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_SHADER_CREATE_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkShaderCreateFlagsEXT = .{},
    // Extern sync: false
    // Optional: false
    stage: VkShaderStageFlags = .{},
    // Extern sync: false
    // Optional: true
    nextStage: VkShaderStageFlags = .{},
    // Extern sync: false
    // Optional: false
    codeType: VkShaderCodeTypeEXT,
    // Extern sync: false
    // Optional: false
    codeSize: u64 = 0,
    // Length member: codeSize
    // Extern sync: false
    // Optional: false
    pCode: ?[*]const anyopaque = null,
    // Length member: null-terminated
    // Extern sync: false
    // Optional: true
    pName: ?[*:0]const u8 = null,
    // Extern sync: false
    // Optional: true
    setLayoutCount: u32 = 0,
    // Length member: setLayoutCount
    // Extern sync: false
    // Optional: true
    pSetLayouts: ?[*]const VkDescriptorSetLayout = null,
    // Extern sync: false
    // Optional: true
    pushConstantRangeCount: u32 = 0,
    // Length member: pushConstantRangeCount
    // Extern sync: false
    // Optional: true
    pPushConstantRanges: ?[*]const VkPushConstantRange = null,
    // Extern sync: false
    // Optional: true
    pSpecializationInfo: ?*const VkSpecializationInfo = null,
};
// Extension: VK_EXT_shader_tile_image
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceShaderTileImageFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_FEATURES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    shaderTileImageColorReadAccess: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderTileImageDepthReadAccess: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderTileImageStencilReadAccess: u32 = 0,
};
// Extension: VK_EXT_shader_tile_image
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceShaderTileImagePropertiesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_PROPERTIES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    shaderTileImageCoherentReadAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderTileImageReadSampleFromPixelRateInvocation: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderTileImageReadFromHelperInvocation: u32 = 0,
};
// Extension: VK_QNX_external_memory_screen_buffer
// Extends: VkMemoryAllocateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImportScreenBufferInfoQNX = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_IMPORT_SCREEN_BUFFER_INFO_QNX,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    buffer: ?*_screen_buffer = null,
};
// Extension: VK_QNX_external_memory_screen_buffer
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkScreenBufferPropertiesQNX = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_SCREEN_BUFFER_PROPERTIES_QNX,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    allocationSize: u64 = 0,
    // Extern sync: false
    // Optional: false
    memoryTypeBits: u32 = 0,
};
// Extension: VK_QNX_external_memory_screen_buffer
// Extends: VkScreenBufferPropertiesQNX
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkScreenBufferFormatPropertiesQNX = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_SCREEN_BUFFER_FORMAT_PROPERTIES_QNX,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    format: VkFormat,
    // Extern sync: false
    // Optional: false
    externalFormat: u64 = 0,
    // Extern sync: false
    // Optional: false
    screenUsage: u64 = 0,
    // Extern sync: false
    // Optional: false
    formatFeatures: VkFormatFeatureFlags = .{},
    // Extern sync: false
    // Optional: false
    samplerYcbcrConversionComponents: VkComponentMapping = .{},
    // Extern sync: false
    // Optional: false
    suggestedYcbcrModel: VkSamplerYcbcrModelConversion,
    // Extern sync: false
    // Optional: false
    suggestedYcbcrRange: VkSamplerYcbcrRange,
    // Extern sync: false
    // Optional: false
    suggestedXChromaOffset: VkChromaLocation,
    // Extern sync: false
    // Optional: false
    suggestedYChromaOffset: VkChromaLocation,
};
// Extension: VK_QNX_external_memory_screen_buffer
// Extends: VkImageCreateInfo,VkSamplerYcbcrConversionCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkExternalFormatQNX = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_QNX,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    externalFormat: u64 = 0,
};
// Extension: VK_QNX_external_memory_screen_buffer
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_SCREEN_BUFFER_FEATURES_QNX,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    screenBufferImport: u32 = 0,
};
// Extension: VK_KHR_cooperative_matrix
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceCooperativeMatrixFeaturesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    cooperativeMatrix: u32 = 0,
    // Extern sync: false
    // Optional: false
    cooperativeMatrixRobustBufferAccess: u32 = 0,
};
// Extension: VK_KHR_cooperative_matrix
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkCooperativeMatrixPropertiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    MSize: u32 = 0,
    // Extern sync: false
    // Optional: false
    NSize: u32 = 0,
    // Extern sync: false
    // Optional: false
    KSize: u32 = 0,
    // Extern sync: false
    // Optional: false
    AType: VkComponentTypeKHR,
    // Extern sync: false
    // Optional: false
    BType: VkComponentTypeKHR,
    // Extern sync: false
    // Optional: false
    CType: VkComponentTypeKHR,
    // Extern sync: false
    // Optional: false
    ResultType: VkComponentTypeKHR,
    // Extern sync: false
    // Optional: false
    saturatingAccumulation: u32 = 0,
    // Extern sync: false
    // Optional: false
    scope: VkScopeKHR,
};
// Extension: VK_KHR_cooperative_matrix
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceCooperativeMatrixPropertiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    cooperativeMatrixSupportedStages: VkShaderStageFlags = .{},
};
// Extension: VK_AMDX_shader_enqueue
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceShaderEnqueuePropertiesAMDX = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ENQUEUE_PROPERTIES_AMDX,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    maxExecutionGraphDepth: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxExecutionGraphShaderOutputNodes: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxExecutionGraphShaderPayloadSize: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxExecutionGraphShaderPayloadCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    executionGraphDispatchAddressAlignment: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxExecutionGraphWorkgroupCount: [3]u32 = @import("std").mem.zeroes([3]u32),
    // Extern sync: false
    // Optional: false
    maxExecutionGraphWorkgroups: u32 = 0,
};
// Extension: VK_AMDX_shader_enqueue
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceShaderEnqueueFeaturesAMDX = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ENQUEUE_FEATURES_AMDX,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    shaderEnqueue: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderMeshEnqueue: u32 = 0,
};
// Extension: VK_AMDX_shader_enqueue
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkExecutionGraphPipelineCreateInfoAMDX = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_EXECUTION_GRAPH_PIPELINE_CREATE_INFO_AMDX,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkPipelineCreateFlags = .{},
    // Extern sync: false
    // Optional: true
    stageCount: u32 = 0,
    // Length member: stageCount
    // Extern sync: false
    // Optional: true
    pStages: ?[*]const VkPipelineShaderStageCreateInfo = null,
    // Extern sync: false
    // Optional: true
    pLibraryInfo: ?*const VkPipelineLibraryCreateInfoKHR = null,
    // Extern sync: false
    // Optional: false
    layout: VkPipelineLayout = .none,
    // Extern sync: false
    // Optional: true
    basePipelineHandle: VkPipeline = .none,
    // Extern sync: false
    // Optional: false
    basePipelineIndex: i32 = 0,
};
// Extension: VK_AMDX_shader_enqueue
// Extends: VkPipelineShaderStageCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineShaderStageNodeCreateInfoAMDX = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_NODE_CREATE_INFO_AMDX,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Length member: null-terminated
    // Extern sync: false
    // Optional: true
    pName: ?[*:0]const u8 = null,
    // Extern sync: false
    // Optional: false
    index: u32 = 0,
};
// Extension: VK_AMDX_shader_enqueue
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkExecutionGraphPipelineScratchSizeAMDX = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_EXECUTION_GRAPH_PIPELINE_SCRATCH_SIZE_AMDX,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    minSize: u64 = 0,
    // Extern sync: false
    // Optional: false
    maxSize: u64 = 0,
    // Extern sync: false
    // Optional: false
    sizeGranularity: u64 = 0,
};
// Extension: VK_AMDX_shader_enqueue
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDispatchGraphInfoAMDX = extern struct {
    // Extern sync: false
    // Optional: false
    nodeIndex: u32 = 0,
    // Extern sync: false
    // Optional: true
    payloadCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    payloads: VkDeviceOrHostAddressConstAMDX,
    // Extern sync: false
    // Optional: false
    payloadStride: u64 = 0,
};
// Extension: VK_AMDX_shader_enqueue
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDispatchGraphCountInfoAMDX = extern struct {
    // Extern sync: false
    // Optional: true
    count: u32 = 0,
    // Extern sync: false
    // Optional: false
    infos: VkDeviceOrHostAddressConstAMDX,
    // Extern sync: false
    // Optional: false
    stride: u64 = 0,
};
// Extension: VK_AMD_anti_lag
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceAntiLagFeaturesAMD = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ANTI_LAG_FEATURES_AMD,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    antiLag: u32 = 0,
};
// Extension: VK_AMD_anti_lag
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkAntiLagDataAMD = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_ANTI_LAG_DATA_AMD,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    mode: VkAntiLagModeAMD,
    // Extern sync: false
    // Optional: false
    maxFPS: u32 = 0,
    // Extern sync: false
    // Optional: true
    pPresentationInfo: ?*const VkAntiLagPresentationInfoAMD = null,
};
// Extension: VK_AMD_anti_lag
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkAntiLagPresentationInfoAMD = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_ANTI_LAG_PRESENTATION_INFO_AMD,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    stage: VkAntiLagStageAMD,
    // Extern sync: false
    // Optional: false
    frameIndex: u64 = 0,
};
// Extension: VK_BASE_VERSION_1_4
// Extends: VkBindBufferMemoryInfo,VkBindImageMemoryInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkBindMemoryStatus = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_BIND_MEMORY_STATUS,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    pResult: ?*VkResult = null,
};
// Extension: VK_QCOM_tile_memory_heap
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceTileMemoryHeapFeaturesQCOM = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_MEMORY_HEAP_FEATURES_QCOM,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    tileMemoryHeap: u32 = 0,
};
// Extension: VK_QCOM_tile_memory_heap
// Extends: VkPhysicalDeviceProperties2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceTileMemoryHeapPropertiesQCOM = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_MEMORY_HEAP_PROPERTIES_QCOM,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    queueSubmitBoundary: u32 = 0,
    // Extern sync: false
    // Optional: false
    tileBufferTransfers: u32 = 0,
};
// Extension: VK_QCOM_tile_memory_heap
// Extends: VkRenderPassCreateInfo,VkRenderPassCreateInfo2,VkRenderingInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkTileMemorySizeInfoQCOM = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_TILE_MEMORY_SIZE_INFO_QCOM,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    size: u64 = 0,
};
// Extension: VK_QCOM_tile_memory_heap
// Extends: VkMemoryRequirements2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkTileMemoryRequirementsQCOM = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_TILE_MEMORY_REQUIREMENTS_QCOM,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    size: u64 = 0,
    // Extern sync: false
    // Optional: false
    alignment: u64 = 0,
};
// Extension: VK_KHR_maintenance6
pub const VkBindMemoryStatusKHR = VkBindMemoryStatus;
// Extension: VK_COMPUTE_VERSION_1_4
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkBindDescriptorSetsInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_SETS_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    stageFlags: VkShaderStageFlags = .{},
    // Extern sync: false
    // Optional: true
    layout: VkPipelineLayout = .none,
    // Extern sync: false
    // Optional: true
    firstSet: u32 = 0,
    // Extern sync: false
    // Optional: false
    descriptorSetCount: u32 = 0,
    // Length member: descriptorSetCount
    // Extern sync: false
    // Optional: false
    pDescriptorSets: ?[*]const VkDescriptorSet = null,
    // Extern sync: false
    // Optional: true
    dynamicOffsetCount: u32 = 0,
    // Length member: dynamicOffsetCount
    // Extern sync: false
    // Optional: false
    pDynamicOffsets: ?[*]const u32 = null,
};
// Extension: VK_KHR_maintenance6
pub const VkBindDescriptorSetsInfoKHR = VkBindDescriptorSetsInfo;
// Extension: VK_COMPUTE_VERSION_1_4
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPushConstantsInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PUSH_CONSTANTS_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    layout: VkPipelineLayout = .none,
    // Extern sync: false
    // Optional: false
    stageFlags: VkShaderStageFlags = .{},
    // Extern sync: false
    // Optional: true
    offset: u32 = 0,
    // Extern sync: false
    // Optional: false
    size: u32 = 0,
    // Length member: size
    // Extern sync: false
    // Optional: false
    pValues: ?[*]const anyopaque = null,
};
// Extension: VK_KHR_maintenance6
pub const VkPushConstantsInfoKHR = VkPushConstantsInfo;
// Extension: VK_COMPUTE_VERSION_1_4
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPushDescriptorSetInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    stageFlags: VkShaderStageFlags = .{},
    // Extern sync: false
    // Optional: true
    layout: VkPipelineLayout = .none,
    // Extern sync: false
    // Optional: true
    set: u32 = 0,
    // Extern sync: false
    // Optional: false
    descriptorWriteCount: u32 = 0,
    // Length member: descriptorWriteCount
    // Extern sync: false
    // Optional: false
    pDescriptorWrites: ?[*]const VkWriteDescriptorSet = null,
};
// Extension: VK_KHR_maintenance6
pub const VkPushDescriptorSetInfoKHR = VkPushDescriptorSetInfo;
// Extension: VK_COMPUTE_VERSION_1_4
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPushDescriptorSetWithTemplateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_WITH_TEMPLATE_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    descriptorUpdateTemplate: VkDescriptorUpdateTemplate = .none,
    // Extern sync: false
    // Optional: true
    layout: VkPipelineLayout = .none,
    // Extern sync: false
    // Optional: true
    set: u32 = 0,
    // Extern sync: false
    // Optional: false
    pData: ?*const anyopaque = null,
};
// Extension: VK_KHR_maintenance6
pub const VkPushDescriptorSetWithTemplateInfoKHR = VkPushDescriptorSetWithTemplateInfo;
// Extension: VK_KHR_maintenance6
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSetDescriptorBufferOffsetsInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_SET_DESCRIPTOR_BUFFER_OFFSETS_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    stageFlags: VkShaderStageFlags = .{},
    // Extern sync: false
    // Optional: true
    layout: VkPipelineLayout = .none,
    // Extern sync: false
    // Optional: true
    firstSet: u32 = 0,
    // Extern sync: false
    // Optional: false
    setCount: u32 = 0,
    // Length member: setCount
    // Extern sync: false
    // Optional: false
    pBufferIndices: ?[*]const u32 = null,
    // Length member: setCount
    // Extern sync: false
    // Optional: false
    pOffsets: ?[*]const u64 = null,
};
// Extension: VK_KHR_maintenance6
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkBindDescriptorBufferEmbeddedSamplersInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_BUFFER_EMBEDDED_SAMPLERS_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    stageFlags: VkShaderStageFlags = .{},
    // Extern sync: false
    // Optional: true
    layout: VkPipelineLayout = .none,
    // Extern sync: false
    // Optional: true
    set: u32 = 0,
};
// Extension: VK_QCOM_filter_cubic_clamp
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceCubicClampFeaturesQCOM = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_CLAMP_FEATURES_QCOM,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    cubicRangeClamp: u32 = 0,
};
// Extension: VK_QCOM_ycbcr_degamma
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceYcbcrDegammaFeaturesQCOM = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_DEGAMMA_FEATURES_QCOM,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    ycbcrDegamma: u32 = 0,
};
// Extension: VK_QCOM_ycbcr_degamma
// Extends: VkSamplerYcbcrConversionCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_YCBCR_DEGAMMA_CREATE_INFO_QCOM,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    enableYDegamma: u32 = 0,
    // Extern sync: false
    // Optional: false
    enableCbCrDegamma: u32 = 0,
};
// Extension: VK_QCOM_filter_cubic_weights
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceCubicWeightsFeaturesQCOM = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_WEIGHTS_FEATURES_QCOM,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    selectableCubicWeights: u32 = 0,
};
// Extension: VK_QCOM_filter_cubic_weights
// Extends: VkSamplerCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSamplerCubicWeightsCreateInfoQCOM = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_SAMPLER_CUBIC_WEIGHTS_CREATE_INFO_QCOM,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    cubicWeights: VkCubicFilterWeightsQCOM,
};
// Extension: VK_QCOM_filter_cubic_weights
// Extends: VkBlitImageInfo2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkBlitImageCubicWeightsInfoQCOM = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_BLIT_IMAGE_CUBIC_WEIGHTS_INFO_QCOM,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    cubicWeights: VkCubicFilterWeightsQCOM,
};
// Extension: VK_QCOM_image_processing2
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceImageProcessing2FeaturesQCOM = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_FEATURES_QCOM,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    textureBlockMatch2: u32 = 0,
};
// Extension: VK_QCOM_image_processing2
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceImageProcessing2PropertiesQCOM = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_PROPERTIES_QCOM,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: true
    maxBlockMatchWindow: VkExtent2D = .{},
};
// Extension: VK_QCOM_image_processing2
// Extends: VkSamplerCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSamplerBlockMatchWindowCreateInfoQCOM = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_SAMPLER_BLOCK_MATCH_WINDOW_CREATE_INFO_QCOM,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    windowExtent: VkExtent2D = .{},
    // Extern sync: false
    // Optional: false
    windowCompareMode: VkBlockMatchWindowCompareModeQCOM,
};
// Extension: VK_NV_descriptor_pool_overallocation
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_POOL_OVERALLOCATION_FEATURES_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    descriptorPoolOverallocation: u32 = 0,
};
// Extension: VK_MSFT_layered_driver
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceLayeredDriverPropertiesMSFT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_DRIVER_PROPERTIES_MSFT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    underlyingAPI: VkLayeredDriverUnderlyingApiMSFT,
};
// Extension: VK_NV_per_stage_descriptor_set
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDevicePerStageDescriptorSetFeaturesNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PER_STAGE_DESCRIPTOR_SET_FEATURES_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    perStageDescriptorSet: u32 = 0,
    // Extern sync: false
    // Optional: false
    dynamicPipelineLayout: u32 = 0,
};
// Extension: VK_ANDROID_external_format_resolve
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceExternalFormatResolveFeaturesANDROID = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FORMAT_RESOLVE_FEATURES_ANDROID,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    externalFormatResolve: u32 = 0,
};
// Extension: VK_ANDROID_external_format_resolve
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceExternalFormatResolvePropertiesANDROID = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FORMAT_RESOLVE_PROPERTIES_ANDROID,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    nullColorAttachmentWithExternalFormatResolve: u32 = 0,
    // Extern sync: false
    // Optional: false
    externalFormatResolveChromaOffsetX: VkChromaLocation,
    // Extern sync: false
    // Optional: false
    externalFormatResolveChromaOffsetY: VkChromaLocation,
};
// Extension: VK_ANDROID_external_format_resolve
// Extends: VkAndroidHardwareBufferPropertiesANDROID
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkAndroidHardwareBufferFormatResolvePropertiesANDROID = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_RESOLVE_PROPERTIES_ANDROID,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    colorAttachmentFormat: VkFormat,
};
// Extension: VK_NV_low_latency2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkLatencySleepModeInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_LATENCY_SLEEP_MODE_INFO_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    lowLatencyMode: u32 = 0,
    // Extern sync: false
    // Optional: false
    lowLatencyBoost: u32 = 0,
    // Extern sync: false
    // Optional: false
    minimumIntervalUs: u32 = 0,
};
// Extension: VK_NV_low_latency2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkLatencySleepInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_LATENCY_SLEEP_INFO_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    signalSemaphore: VkSemaphore = .none,
    // Extern sync: false
    // Optional: false
    value: u64 = 0,
};
// Extension: VK_NV_low_latency2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSetLatencyMarkerInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_SET_LATENCY_MARKER_INFO_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    presentID: u64 = 0,
    // Extern sync: false
    // Optional: false
    marker: VkLatencyMarkerNV,
};
// Extension: VK_NV_low_latency2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkGetLatencyMarkerInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_GET_LATENCY_MARKER_INFO_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    timingCount: u32 = 0,
    // Length member: timingCount
    // Extern sync: false
    // Optional: true
    pTimings: ?[*]VkLatencyTimingsFrameReportNV = null,
};
// Extension: VK_NV_low_latency2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkLatencyTimingsFrameReportNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_LATENCY_TIMINGS_FRAME_REPORT_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    presentID: u64 = 0,
    // Extern sync: false
    // Optional: false
    inputSampleTimeUs: u64 = 0,
    // Extern sync: false
    // Optional: false
    simStartTimeUs: u64 = 0,
    // Extern sync: false
    // Optional: false
    simEndTimeUs: u64 = 0,
    // Extern sync: false
    // Optional: false
    renderSubmitStartTimeUs: u64 = 0,
    // Extern sync: false
    // Optional: false
    renderSubmitEndTimeUs: u64 = 0,
    // Extern sync: false
    // Optional: false
    presentStartTimeUs: u64 = 0,
    // Extern sync: false
    // Optional: false
    presentEndTimeUs: u64 = 0,
    // Extern sync: false
    // Optional: false
    driverStartTimeUs: u64 = 0,
    // Extern sync: false
    // Optional: false
    driverEndTimeUs: u64 = 0,
    // Extern sync: false
    // Optional: false
    osRenderQueueStartTimeUs: u64 = 0,
    // Extern sync: false
    // Optional: false
    osRenderQueueEndTimeUs: u64 = 0,
    // Extern sync: false
    // Optional: false
    gpuRenderStartTimeUs: u64 = 0,
    // Extern sync: false
    // Optional: false
    gpuRenderEndTimeUs: u64 = 0,
};
// Extension: VK_NV_low_latency2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkOutOfBandQueueTypeInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_OUT_OF_BAND_QUEUE_TYPE_INFO_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    queueType: VkOutOfBandQueueTypeNV,
};
// Extension: VK_NV_low_latency2
// Extends: VkSubmitInfo,VkSubmitInfo2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkLatencySubmissionPresentIdNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_LATENCY_SUBMISSION_PRESENT_ID_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    presentID: u64 = 0,
};
// Extension: VK_NV_low_latency2
// Extends: VkSwapchainCreateInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSwapchainLatencyCreateInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_SWAPCHAIN_LATENCY_CREATE_INFO_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    latencyModeEnable: u32 = 0,
};
// Extension: VK_NV_low_latency2
// Extends: VkSurfaceCapabilities2KHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkLatencySurfaceCapabilitiesNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_LATENCY_SURFACE_CAPABILITIES_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    presentModeCount: u32 = 0,
    // Length member: presentModeCount
    // Extern sync: false
    // Optional: true
    pPresentModes: ?[*]VkPresentModeKHR = null,
};
// Extension: VK_NV_cuda_kernel_launch
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceCudaKernelLaunchFeaturesNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUDA_KERNEL_LAUNCH_FEATURES_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    cudaKernelLaunchFeatures: u32 = 0,
};
// Extension: VK_NV_cuda_kernel_launch
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceCudaKernelLaunchPropertiesNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUDA_KERNEL_LAUNCH_PROPERTIES_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    computeCapabilityMinor: u32 = 0,
    // Extern sync: false
    // Optional: false
    computeCapabilityMajor: u32 = 0,
};
// Extension: VK_ARM_scheduling_controls
// Extends: VkDeviceQueueCreateInfo,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDeviceQueueShaderCoreControlCreateInfoARM = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_DEVICE_QUEUE_SHADER_CORE_CONTROL_CREATE_INFO_ARM,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    shaderCoreCount: u32 = 0,
};
// Extension: VK_ARM_scheduling_controls
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceSchedulingControlsFeaturesARM = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_FEATURES_ARM,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    schedulingControls: u32 = 0,
};
// Extension: VK_ARM_scheduling_controls
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceSchedulingControlsPropertiesARM = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_PROPERTIES_ARM,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    schedulingControlsFlags: VkPhysicalDeviceSchedulingControlsFlagsARM = .{},
};
// Extension: VK_IMG_relaxed_line_rasterization
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RELAXED_LINE_RASTERIZATION_FEATURES_IMG,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    relaxedLineRasterization: u32 = 0,
};
// Extension: VK_ARM_render_pass_striped
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceRenderPassStripedFeaturesARM = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_FEATURES_ARM,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    renderPassStriped: u32 = 0,
};
// Extension: VK_ARM_render_pass_striped
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceRenderPassStripedPropertiesARM = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_PROPERTIES_ARM,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    renderPassStripeGranularity: VkExtent2D = .{},
    // Extern sync: false
    // Optional: false
    maxRenderPassStripes: u32 = 0,
};
// Extension: VK_ARM_render_pass_striped
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkRenderPassStripeInfoARM = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_INFO_ARM,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    stripeArea: VkRect2D = .{},
};
// Extension: VK_ARM_render_pass_striped
// Extends: VkRenderingInfo,VkRenderPassBeginInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkRenderPassStripeBeginInfoARM = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_BEGIN_INFO_ARM,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    stripeInfoCount: u32 = 0,
    // Length member: stripeInfoCount
    // Extern sync: false
    // Optional: false
    pStripeInfos: ?[*]const VkRenderPassStripeInfoARM = null,
};
// Extension: VK_ARM_render_pass_striped
// Extends: VkCommandBufferSubmitInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkRenderPassStripeSubmitInfoARM = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_SUBMIT_INFO_ARM,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    stripeSemaphoreInfoCount: u32 = 0,
    // Length member: stripeSemaphoreInfoCount
    // Extern sync: false
    // Optional: false
    pStripeSemaphoreInfos: ?[*]const VkSemaphoreSubmitInfo = null,
};
// Extension: VK_ARM_pipeline_opacity_micromap
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDevicePipelineOpacityMicromapFeaturesARM = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_OPACITY_MICROMAP_FEATURES_ARM,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    pipelineOpacityMicromap: u32 = 0,
};
// Extension: VK_KHR_shader_maximal_reconvergence
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MAXIMAL_RECONVERGENCE_FEATURES_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    shaderMaximalReconvergence: u32 = 0,
};
// Extension: VK_COMPUTE_VERSION_1_4
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceShaderSubgroupRotateFeatures = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_ROTATE_FEATURES,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    shaderSubgroupRotate: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderSubgroupRotateClustered: u32 = 0,
};
// Extension: VK_KHR_shader_subgroup_rotate
pub const VkPhysicalDeviceShaderSubgroupRotateFeaturesKHR = VkPhysicalDeviceShaderSubgroupRotateFeatures;
// Extension: VK_COMPUTE_VERSION_1_4
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceShaderExpectAssumeFeatures = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EXPECT_ASSUME_FEATURES,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    shaderExpectAssume: u32 = 0,
};
// Extension: VK_KHR_shader_expect_assume
pub const VkPhysicalDeviceShaderExpectAssumeFeaturesKHR = VkPhysicalDeviceShaderExpectAssumeFeatures;
// Extension: VK_COMPUTE_VERSION_1_4
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceShaderFloatControls2Features = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT_CONTROLS_2_FEATURES,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    shaderFloatControls2: u32 = 0,
};
// Extension: VK_KHR_shader_float_controls2
pub const VkPhysicalDeviceShaderFloatControls2FeaturesKHR = VkPhysicalDeviceShaderFloatControls2Features;
// Extension: VK_GRAPHICS_VERSION_1_4
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceDynamicRenderingLocalReadFeatures = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_LOCAL_READ_FEATURES,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    dynamicRenderingLocalRead: u32 = 0,
};
// Extension: VK_KHR_dynamic_rendering_local_read
pub const VkPhysicalDeviceDynamicRenderingLocalReadFeaturesKHR = VkPhysicalDeviceDynamicRenderingLocalReadFeatures;
// Extension: VK_GRAPHICS_VERSION_1_4
// Extends: VkGraphicsPipelineCreateInfo,VkCommandBufferInheritanceInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkRenderingAttachmentLocationInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_LOCATION_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    colorAttachmentCount: u32 = 0,
    // Length member: colorAttachmentCount
    // Extern sync: false
    // Optional: false
    pColorAttachmentLocations: ?[*]const u32 = null,
};
// Extension: VK_KHR_dynamic_rendering_local_read
pub const VkRenderingAttachmentLocationInfoKHR = VkRenderingAttachmentLocationInfo;
// Extension: VK_GRAPHICS_VERSION_1_4
// Extends: VkGraphicsPipelineCreateInfo,VkCommandBufferInheritanceInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkRenderingInputAttachmentIndexInfo = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_RENDERING_INPUT_ATTACHMENT_INDEX_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    colorAttachmentCount: u32 = 0,
    // Length member: colorAttachmentCount
    // Extern sync: false
    // Optional: true
    pColorAttachmentInputIndices: ?[*]const u32 = null,
    // Extern sync: false
    // Optional: true
    pDepthInputAttachmentIndex: ?*const u32 = null,
    // Extern sync: false
    // Optional: true
    pStencilInputAttachmentIndex: ?*const u32 = null,
};
// Extension: VK_KHR_dynamic_rendering_local_read
pub const VkRenderingInputAttachmentIndexInfoKHR = VkRenderingInputAttachmentIndexInfo;
// Extension: VK_KHR_shader_quad_control
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceShaderQuadControlFeaturesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_QUAD_CONTROL_FEATURES_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    shaderQuadControl: u32 = 0,
};
// Extension: VK_NV_shader_atomic_float16_vector
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT16_VECTOR_FEATURES_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    shaderFloat16VectorAtomics: u32 = 0,
};
// Extension: VK_EXT_map_memory_placed
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceMapMemoryPlacedFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_FEATURES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    memoryMapPlaced: u32 = 0,
    // Extern sync: false
    // Optional: false
    memoryMapRangePlaced: u32 = 0,
    // Extern sync: false
    // Optional: false
    memoryUnmapReserve: u32 = 0,
};
// Extension: VK_EXT_map_memory_placed
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceMapMemoryPlacedPropertiesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_PROPERTIES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    minPlacedMemoryMapAlignment: u64 = 0,
};
// Extension: VK_EXT_map_memory_placed
// Extends: VkMemoryMapInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkMemoryMapPlacedInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_MEMORY_MAP_PLACED_INFO_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    pPlacedAddress: ?*anyopaque = null,
};
// Extension: VK_KHR_shader_bfloat16
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceShaderBfloat16FeaturesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_BFLOAT16_FEATURES_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    shaderBFloat16Type: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderBFloat16DotProduct: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderBFloat16CooperativeMatrix: u32 = 0,
};
// Extension: VK_NV_raw_access_chains
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceRawAccessChainsFeaturesNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAW_ACCESS_CHAINS_FEATURES_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    shaderRawAccessChains: u32 = 0,
};
// Extension: VK_NV_command_buffer_inheritance
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceCommandBufferInheritanceFeaturesNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMMAND_BUFFER_INHERITANCE_FEATURES_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    commandBufferInheritance: u32 = 0,
};
// Extension: VK_MESA_image_alignment_control
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceImageAlignmentControlFeaturesMESA = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_FEATURES_MESA,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    imageAlignmentControl: u32 = 0,
};
// Extension: VK_MESA_image_alignment_control
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceImageAlignmentControlPropertiesMESA = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_PROPERTIES_MESA,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    supportedImageAlignmentMask: u32 = 0,
};
// Extension: VK_MESA_image_alignment_control
// Extends: VkImageCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImageAlignmentControlCreateInfoMESA = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_IMAGE_ALIGNMENT_CONTROL_CREATE_INFO_MESA,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    maximumRequestedAlignment: u32 = 0,
};
// Extension: VK_EXT_shader_replicated_composites
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_REPLICATED_COMPOSITES_FEATURES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    shaderReplicatedComposites: u32 = 0,
};
// Extension: VK_EXT_present_mode_fifo_latest_ready
pub const VkPhysicalDevicePresentModeFifoLatestReadyFeaturesEXT = VkPhysicalDevicePresentModeFifoLatestReadyFeaturesKHR;
// Extension: VK_KHR_present_mode_fifo_latest_ready
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDevicePresentModeFifoLatestReadyFeaturesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_MODE_FIFO_LATEST_READY_FEATURES_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    presentModeFifoLatestReady: u32 = 0,
};
// Extension: VK_EXT_depth_clamp_control
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDepthClampRangeEXT = extern struct {
    // Extern sync: false
    // Optional: false
    minDepthClamp: f32 = 0,
    // Extern sync: false
    // Optional: false
    maxDepthClamp: f32 = 0,
};
// Extension: VK_NV_cooperative_matrix2
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceCooperativeMatrix2FeaturesNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_2_FEATURES_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    cooperativeMatrixWorkgroupScope: u32 = 0,
    // Extern sync: false
    // Optional: false
    cooperativeMatrixFlexibleDimensions: u32 = 0,
    // Extern sync: false
    // Optional: false
    cooperativeMatrixReductions: u32 = 0,
    // Extern sync: false
    // Optional: false
    cooperativeMatrixConversions: u32 = 0,
    // Extern sync: false
    // Optional: false
    cooperativeMatrixPerElementOperations: u32 = 0,
    // Extern sync: false
    // Optional: false
    cooperativeMatrixTensorAddressing: u32 = 0,
    // Extern sync: false
    // Optional: false
    cooperativeMatrixBlockLoads: u32 = 0,
};
// Extension: VK_NV_cooperative_matrix2
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceCooperativeMatrix2PropertiesNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_2_PROPERTIES_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    cooperativeMatrixWorkgroupScopeMaxWorkgroupSize: u32 = 0,
    // Extern sync: false
    // Optional: false
    cooperativeMatrixFlexibleDimensionsMaxDimension: u32 = 0,
    // Extern sync: false
    // Optional: false
    cooperativeMatrixWorkgroupScopeReservedSharedMemory: u32 = 0,
};
// Extension: VK_NV_cooperative_matrix2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkCooperativeMatrixFlexibleDimensionsPropertiesNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_FLEXIBLE_DIMENSIONS_PROPERTIES_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    MGranularity: u32 = 0,
    // Extern sync: false
    // Optional: false
    NGranularity: u32 = 0,
    // Extern sync: false
    // Optional: false
    KGranularity: u32 = 0,
    // Extern sync: false
    // Optional: false
    AType: VkComponentTypeKHR,
    // Extern sync: false
    // Optional: false
    BType: VkComponentTypeKHR,
    // Extern sync: false
    // Optional: false
    CType: VkComponentTypeKHR,
    // Extern sync: false
    // Optional: false
    ResultType: VkComponentTypeKHR,
    // Extern sync: false
    // Optional: false
    saturatingAccumulation: u32 = 0,
    // Extern sync: false
    // Optional: false
    scope: VkScopeKHR,
    // Extern sync: false
    // Optional: false
    workgroupInvocations: u32 = 0,
};
// Extension: VK_HUAWEI_hdr_vivid
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceHdrVividFeaturesHUAWEI = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HDR_VIVID_FEATURES_HUAWEI,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    hdrVivid: u32 = 0,
};
// Extension: VK_EXT_vertex_attribute_robustness
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_ROBUSTNESS_FEATURES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    vertexAttributeRobustness: u32 = 0,
};
// Extension: VK_AMDX_dense_geometry_format
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceDenseGeometryFormatFeaturesAMDX = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DENSE_GEOMETRY_FORMAT_FEATURES_AMDX,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    denseGeometryFormat: u32 = 0,
};
// Extension: VK_AMDX_dense_geometry_format
// Extends: VkAccelerationStructureGeometryKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkAccelerationStructureDenseGeometryFormatTrianglesDataAMDX = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DENSE_GEOMETRY_FORMAT_TRIANGLES_DATA_AMDX,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    compressedData: VkDeviceOrHostAddressConstKHR,
    // Extern sync: false
    // Optional: false
    dataSize: u64 = 0,
    // Extern sync: false
    // Optional: false
    numTriangles: u32 = 0,
    // Extern sync: false
    // Optional: false
    numVertices: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxPrimitiveIndex: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxGeometryIndex: u32 = 0,
    // Extern sync: false
    // Optional: false
    format: VkCompressedTriangleFormatAMDX,
};
// Extension: VK_KHR_depth_clamp_zero_one
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceDepthClampZeroOneFeaturesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    depthClampZeroOne: u32 = 0,
};
// Extension: VK_NV_cooperative_vector
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceCooperativeVectorFeaturesNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_VECTOR_FEATURES_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    cooperativeVector: u32 = 0,
    // Extern sync: false
    // Optional: false
    cooperativeVectorTraining: u32 = 0,
};
// Extension: VK_NV_cooperative_vector
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkCooperativeVectorPropertiesNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_COOPERATIVE_VECTOR_PROPERTIES_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    inputType: VkComponentTypeKHR,
    // Extern sync: false
    // Optional: false
    inputInterpretation: VkComponentTypeKHR,
    // Extern sync: false
    // Optional: false
    matrixInterpretation: VkComponentTypeKHR,
    // Extern sync: false
    // Optional: false
    biasInterpretation: VkComponentTypeKHR,
    // Extern sync: false
    // Optional: false
    resultType: VkComponentTypeKHR,
    // Extern sync: false
    // Optional: false
    transpose: u32 = 0,
};
// Extension: VK_NV_cooperative_vector
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceCooperativeVectorPropertiesNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_VECTOR_PROPERTIES_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    cooperativeVectorSupportedStages: VkShaderStageFlags = .{},
    // Extern sync: false
    // Optional: false
    cooperativeVectorTrainingFloat16Accumulation: u32 = 0,
    // Extern sync: false
    // Optional: false
    cooperativeVectorTrainingFloat32Accumulation: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxCooperativeVectorComponents: u32 = 0,
};
// Extension: VK_NV_cooperative_vector
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkConvertCooperativeVectorMatrixInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_CONVERT_COOPERATIVE_VECTOR_MATRIX_INFO_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    srcSize: u64 = 0,
    // Extern sync: false
    // Optional: false
    srcData: VkDeviceOrHostAddressConstKHR,
    // Extern sync: false
    // Optional: false
    pDstSize: ?*u64 = null,
    // Extern sync: false
    // Optional: false
    dstData: VkDeviceOrHostAddressKHR,
    // Extern sync: false
    // Optional: false
    srcComponentType: VkComponentTypeKHR,
    // Extern sync: false
    // Optional: false
    dstComponentType: VkComponentTypeKHR,
    // Extern sync: false
    // Optional: false
    numRows: u32 = 0,
    // Extern sync: false
    // Optional: false
    numColumns: u32 = 0,
    // Extern sync: false
    // Optional: false
    srcLayout: VkCooperativeVectorMatrixLayoutNV,
    // Extern sync: false
    // Optional: false
    srcStride: u64 = 0,
    // Extern sync: false
    // Optional: false
    dstLayout: VkCooperativeVectorMatrixLayoutNV,
    // Extern sync: false
    // Optional: false
    dstStride: u64 = 0,
};
// Extension: VK_QCOM_tile_shading
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceTileShadingFeaturesQCOM = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_SHADING_FEATURES_QCOM,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    tileShading: u32 = 0,
    // Extern sync: false
    // Optional: false
    tileShadingFragmentStage: u32 = 0,
    // Extern sync: false
    // Optional: false
    tileShadingColorAttachments: u32 = 0,
    // Extern sync: false
    // Optional: false
    tileShadingDepthAttachments: u32 = 0,
    // Extern sync: false
    // Optional: false
    tileShadingStencilAttachments: u32 = 0,
    // Extern sync: false
    // Optional: false
    tileShadingInputAttachments: u32 = 0,
    // Extern sync: false
    // Optional: false
    tileShadingSampledAttachments: u32 = 0,
    // Extern sync: false
    // Optional: false
    tileShadingPerTileDraw: u32 = 0,
    // Extern sync: false
    // Optional: false
    tileShadingPerTileDispatch: u32 = 0,
    // Extern sync: false
    // Optional: false
    tileShadingDispatchTile: u32 = 0,
    // Extern sync: false
    // Optional: false
    tileShadingApron: u32 = 0,
    // Extern sync: false
    // Optional: false
    tileShadingAnisotropicApron: u32 = 0,
    // Extern sync: false
    // Optional: false
    tileShadingAtomicOps: u32 = 0,
    // Extern sync: false
    // Optional: false
    tileShadingImageProcessing: u32 = 0,
};
// Extension: VK_QCOM_tile_shading
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceTileShadingPropertiesQCOM = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_SHADING_PROPERTIES_QCOM,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    maxApronSize: u32 = 0,
    // Extern sync: false
    // Optional: false
    preferNonCoherent: u32 = 0,
    // Extern sync: false
    // Optional: false
    tileGranularity: VkExtent2D = .{},
    // Extern sync: false
    // Optional: false
    maxTileShadingRate: VkExtent2D = .{},
};
// Extension: VK_QCOM_tile_shading
// Extends: VkRenderPassCreateInfo,VkRenderPassCreateInfo2,VkRenderingInfo,VkCommandBufferInheritanceInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkRenderPassTileShadingCreateInfoQCOM = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_RENDER_PASS_TILE_SHADING_CREATE_INFO_QCOM,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkTileShadingRenderPassFlagsQCOM = .{},
    // Extern sync: false
    // Optional: true
    tileApronSize: VkExtent2D = .{},
};
// Extension: VK_QCOM_tile_shading
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPerTileBeginInfoQCOM = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PER_TILE_BEGIN_INFO_QCOM,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
};
// Extension: VK_QCOM_tile_shading
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPerTileEndInfoQCOM = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PER_TILE_END_INFO_QCOM,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
};
// Extension: VK_QCOM_tile_shading
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDispatchTileInfoQCOM = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_DISPATCH_TILE_INFO_QCOM,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
};
// Extension: VK_VALVE_fragment_density_map_layered
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceFragmentDensityMapLayeredPropertiesVALVE = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_LAYERED_PROPERTIES_VALVE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    maxFragmentDensityMapLayers: u32 = 0,
};
// Extension: VK_VALVE_fragment_density_map_layered
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_LAYERED_FEATURES_VALVE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    fragmentDensityMapLayered: u32 = 0,
};
// Extension: VK_VALVE_fragment_density_map_layered
// Extends: VkGraphicsPipelineCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineFragmentDensityMapLayeredCreateInfoVALVE = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_DENSITY_MAP_LAYERED_CREATE_INFO_VALVE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    maxFragmentDensityMapLayers: u32 = 0,
};
// Extension: VK_NV_present_metering
// Extends: VkPresentInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSetPresentConfigNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_SET_PRESENT_CONFIG_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    numFramesPerBatch: u32 = 0,
    // Extern sync: false
    // Optional: false
    presentConfigFeedback: u32 = 0,
};
// Extension: VK_NV_present_metering
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDevicePresentMeteringFeaturesNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_METERING_FEATURES_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    presentMetering: u32 = 0,
};
// Extension: VK_NV_external_compute_queue
// Extends: VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkExternalComputeQueueDeviceCreateInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_EXTERNAL_COMPUTE_QUEUE_DEVICE_CREATE_INFO_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    reservedExternalQueues: u32 = 0,
};
// Extension: VK_NV_external_compute_queue
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkExternalComputeQueueCreateInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_EXTERNAL_COMPUTE_QUEUE_CREATE_INFO_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    preferredQueue: VkQueue = .none,
};
// Extension: VK_NV_external_compute_queue
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkExternalComputeQueueDataParamsNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_EXTERNAL_COMPUTE_QUEUE_DATA_PARAMS_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    deviceIndex: u32 = 0,
};
// Extension: VK_NV_external_compute_queue
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceExternalComputeQueuePropertiesNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_COMPUTE_QUEUE_PROPERTIES_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    externalDataSize: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxExternalQueues: u32 = 0,
};
// Extension: VK_EXT_shader_uniform_buffer_unsized_array
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceShaderUniformBufferUnsizedArrayFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_UNIFORM_BUFFER_UNSIZED_ARRAY_FEATURES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    shaderUniformBufferUnsizedArray: u32 = 0,
};
// Extension: VK_ARM_format_pack
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceFormatPackFeaturesARM = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FORMAT_PACK_FEATURES_ARM,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    formatPack: u32 = 0,
};
// Extension: VK_ARM_tensors
// Extends: VkDataGraphPipelineResourceInfoARM,VkDataGraphPipelineConstantARM
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkTensorDescriptionARM = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_TENSOR_DESCRIPTION_ARM,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    tiling: VkTensorTilingARM,
    // Extern sync: false
    // Optional: false
    format: VkFormat,
    // Extern sync: false
    // Optional: false
    dimensionCount: u32 = 0,
    // Length member: dimensionCount
    // Extern sync: false
    // Optional: false
    pDimensions: ?[*]const i64 = null,
    // Length member: dimensionCount
    // Extern sync: false
    // Optional: true
    pStrides: ?[*]const i64 = null,
    // Extern sync: false
    // Optional: false
    usage: VkTensorUsageFlagsARM = .{},
};
// Extension: VK_ARM_tensors
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkTensorCreateInfoARM = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_TENSOR_CREATE_INFO_ARM,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkTensorCreateFlagsARM = .{},
    // Extern sync: false
    // Optional: false
    pDescription: ?*const VkTensorDescriptionARM = null,
    // Extern sync: false
    // Optional: false
    sharingMode: VkSharingMode,
    // Extern sync: false
    // Optional: true
    queueFamilyIndexCount: u32 = 0,
    // Length member: queueFamilyIndexCount
    // Extern sync: false
    // Optional: false
    pQueueFamilyIndices: ?[*]const u32 = null,
};
// Extension: VK_ARM_tensors
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkTensorViewCreateInfoARM = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_TENSOR_VIEW_CREATE_INFO_ARM,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkTensorViewCreateFlagsARM = .{},
    // Extern sync: false
    // Optional: false
    tensor: VkTensorARM = .none,
    // Extern sync: false
    // Optional: false
    format: VkFormat,
};
// Extension: VK_ARM_tensors
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkTensorMemoryRequirementsInfoARM = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_TENSOR_MEMORY_REQUIREMENTS_INFO_ARM,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    tensor: VkTensorARM = .none,
};
// Extension: VK_ARM_tensors
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkBindTensorMemoryInfoARM = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_BIND_TENSOR_MEMORY_INFO_ARM,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: true
    // Optional: false
    tensor: VkTensorARM = .none,
    // Extern sync: false
    // Optional: false
    memory: VkDeviceMemory = .none,
    // Extern sync: false
    // Optional: false
    memoryOffset: u64 = 0,
};
// Extension: VK_ARM_tensors
// Extends: VkWriteDescriptorSet
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkWriteDescriptorSetTensorARM = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_TENSOR_ARM,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    tensorViewCount: u32 = 0,
    // Length member: tensorViewCount
    // Extern sync: false
    // Optional: false
    pTensorViews: ?[*]const VkTensorViewARM = null,
};
// Extension: VK_ARM_tensors
// Extends: VkFormatProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkTensorFormatPropertiesARM = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_TENSOR_FORMAT_PROPERTIES_ARM,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    optimalTilingTensorFeatures: VkFormatFeatureFlags2 = .{},
    // Extern sync: false
    // Optional: false
    linearTilingTensorFeatures: VkFormatFeatureFlags2 = .{},
};
// Extension: VK_ARM_tensors
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceTensorPropertiesARM = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TENSOR_PROPERTIES_ARM,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    maxTensorDimensionCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxTensorElements: u64 = 0,
    // Extern sync: false
    // Optional: false
    maxPerDimensionTensorElements: u64 = 0,
    // Extern sync: false
    // Optional: false
    maxTensorStride: i64 = 0,
    // Extern sync: false
    // Optional: false
    maxTensorSize: u64 = 0,
    // Extern sync: false
    // Optional: false
    maxTensorShaderAccessArrayLength: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxTensorShaderAccessSize: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxDescriptorSetStorageTensors: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxPerStageDescriptorSetStorageTensors: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxDescriptorSetUpdateAfterBindStorageTensors: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxPerStageDescriptorUpdateAfterBindStorageTensors: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderStorageTensorArrayNonUniformIndexingNative: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderTensorSupportedStages: VkShaderStageFlags = .{},
};
// Extension: VK_ARM_tensors
// Extends: VkDependencyInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkTensorMemoryBarrierARM = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_TENSOR_MEMORY_BARRIER_ARM,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    srcStageMask: VkPipelineStageFlags2 = .{},
    // Extern sync: false
    // Optional: true
    srcAccessMask: VkAccessFlags2 = .{},
    // Extern sync: false
    // Optional: true
    dstStageMask: VkPipelineStageFlags2 = .{},
    // Extern sync: false
    // Optional: true
    dstAccessMask: VkAccessFlags2 = .{},
    // Extern sync: false
    // Optional: false
    srcQueueFamilyIndex: u32 = 0,
    // Extern sync: false
    // Optional: false
    dstQueueFamilyIndex: u32 = 0,
    // Extern sync: false
    // Optional: false
    tensor: VkTensorARM = .none,
};
// Extension: VK_ARM_tensors
// Extends: VkDependencyInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkTensorDependencyInfoARM = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_TENSOR_DEPENDENCY_INFO_ARM,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    tensorMemoryBarrierCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    pTensorMemoryBarriers: ?*const VkTensorMemoryBarrierARM = null,
};
// Extension: VK_ARM_tensors
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceTensorFeaturesARM = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TENSOR_FEATURES_ARM,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    tensorNonPacked: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderTensorAccess: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderStorageTensorArrayDynamicIndexing: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderStorageTensorArrayNonUniformIndexing: u32 = 0,
    // Extern sync: false
    // Optional: false
    descriptorBindingStorageTensorUpdateAfterBind: u32 = 0,
    // Extern sync: false
    // Optional: false
    tensors: u32 = 0,
};
// Extension: VK_ARM_tensors
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDeviceTensorMemoryRequirementsARM = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_DEVICE_TENSOR_MEMORY_REQUIREMENTS_ARM,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    pCreateInfo: ?*const VkTensorCreateInfoARM = null,
};
// Extension: VK_ARM_tensors
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkCopyTensorInfoARM = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_COPY_TENSOR_INFO_ARM,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    srcTensor: VkTensorARM = .none,
    // Extern sync: false
    // Optional: false
    dstTensor: VkTensorARM = .none,
    // Extern sync: false
    // Optional: false
    regionCount: u32 = 0,
    // Length member: regionCount
    // Extern sync: false
    // Optional: false
    pRegions: ?[*]const VkTensorCopyARM = null,
};
// Extension: VK_ARM_tensors
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkTensorCopyARM = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_TENSOR_COPY_ARM,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    dimensionCount: u32 = 0,
    // Length member: dimensionCount
    // Extern sync: false
    // Optional: true
    pSrcOffset: ?[*]const u64 = null,
    // Length member: dimensionCount
    // Extern sync: false
    // Optional: true
    pDstOffset: ?[*]const u64 = null,
    // Length member: dimensionCount
    // Extern sync: false
    // Optional: true
    pExtent: ?[*]const u64 = null,
};
// Extension: VK_ARM_tensors
// Extends: VkMemoryAllocateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkMemoryDedicatedAllocateInfoTensorARM = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_TENSOR_ARM,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: Tensor that this allocation will be bound to
    tensor: VkTensorARM = .none,
};
// Extension: VK_ARM_tensors
// Extends: VkPhysicalDeviceProperties2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceDescriptorBufferTensorPropertiesARM = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_TENSOR_PROPERTIES_ARM,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    tensorCaptureReplayDescriptorDataSize: u64 = 0,
    // Extern sync: false
    // Optional: false
    tensorViewCaptureReplayDescriptorDataSize: u64 = 0,
    // Extern sync: false
    // Optional: false
    tensorDescriptorSize: u64 = 0,
};
// Extension: VK_ARM_tensors
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceDescriptorBufferTensorFeaturesARM = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_TENSOR_FEATURES_ARM,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    descriptorBufferTensorDescriptors: u32 = 0,
};
// Extension: VK_ARM_tensors
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkTensorCaptureDescriptorDataInfoARM = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_TENSOR_CAPTURE_DESCRIPTOR_DATA_INFO_ARM,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    tensor: VkTensorARM = .none,
};
// Extension: VK_ARM_tensors
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkTensorViewCaptureDescriptorDataInfoARM = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_TENSOR_VIEW_CAPTURE_DESCRIPTOR_DATA_INFO_ARM,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    tensorView: VkTensorViewARM = .none,
};
// Extension: VK_ARM_tensors
// Extends: VkDescriptorGetInfoEXT
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDescriptorGetTensorInfoARM = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_DESCRIPTOR_GET_TENSOR_INFO_ARM,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    tensorView: VkTensorViewARM = .none,
};
// Extension: VK_ARM_tensors
// Extends: VkSubmitInfo,VkSubmitInfo2,VkPresentInfoKHR,VkBindSparseInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkFrameBoundaryTensorsARM = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_FRAME_BOUNDARY_TENSORS_ARM,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    tensorCount: u32 = 0,
    // Length member: tensorCount
    // Extern sync: false
    // Optional: false
    pTensors: ?[*]const VkTensorARM = null,
};
// Extension: VK_ARM_tensors
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceExternalTensorInfoARM = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_TENSOR_INFO_ARM,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkTensorCreateFlagsARM = .{},
    // Extern sync: false
    // Optional: false
    pDescription: ?*const VkTensorDescriptionARM = null,
    // Extern sync: false
    // Optional: false
    handleType: VkExternalMemoryHandleTypeFlags = .{},
};
// Extension: VK_ARM_tensors
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkExternalTensorPropertiesARM = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_EXTERNAL_TENSOR_PROPERTIES_ARM,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    externalMemoryProperties: VkExternalMemoryProperties = .{},
};
// Extension: VK_ARM_tensors
// Extends: VkTensorCreateInfoARM
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkExternalMemoryTensorCreateInfoARM = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_TENSOR_CREATE_INFO_ARM,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    handleTypes: VkExternalMemoryHandleTypeFlags = .{},
};
// Extension: VK_EXT_shader_float8
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceShaderFloat8FeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT8_FEATURES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    shaderFloat8: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderFloat8CooperativeMatrix: u32 = 0,
};
// Extension: VK_OHOS_surface
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSurfaceCreateInfoOHOS = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_SURFACE_CREATE_INFO_OHOS,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkSurfaceCreateFlagsOHOS = .{},
    // Extern sync: false
    // Optional: false
    window: ?*OHNativeWindow = null,
};
// Extension: VK_ARM_data_graph
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceDataGraphFeaturesARM = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DATA_GRAPH_FEATURES_ARM,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    dataGraph: u32 = 0,
    // Extern sync: false
    // Optional: false
    dataGraphUpdateAfterBind: u32 = 0,
    // Extern sync: false
    // Optional: false
    dataGraphSpecializationConstants: u32 = 0,
    // Extern sync: false
    // Optional: false
    dataGraphDescriptorBuffer: u32 = 0,
    // Extern sync: false
    // Optional: false
    dataGraphShaderModule: u32 = 0,
};
// Extension: VK_ARM_data_graph
// Extends: VkDataGraphPipelineConstantARM
// Returned only: false
// Allow duplicate in pNext chain: true
pub const VkDataGraphPipelineConstantTensorSemiStructuredSparsityInfoARM = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_CONSTANT_TENSOR_SEMI_STRUCTURED_SPARSITY_INFO_ARM,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    dimension: u32 = 0,
    // Extern sync: false
    // Optional: false
    zeroCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    groupSize: u32 = 0,
};
// Extension: VK_ARM_data_graph
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDataGraphPipelineConstantARM = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_CONSTANT_ARM,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    id: u32 = 0,
    // Extern sync: false
    // Optional: false
    pConstantData: ?*const anyopaque = null,
};
// Extension: VK_ARM_data_graph
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDataGraphPipelineResourceInfoARM = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_RESOURCE_INFO_ARM,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    descriptorSet: u32 = 0,
    // Extern sync: false
    // Optional: false
    binding: u32 = 0,
    // Extern sync: false
    // Optional: true
    arrayElement: u32 = 0,
};
// Extension: VK_ARM_data_graph
// Extends: VkDataGraphPipelineCreateInfoARM
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDataGraphPipelineCompilerControlCreateInfoARM = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_COMPILER_CONTROL_CREATE_INFO_ARM,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Length member: null-terminated
    // Extern sync: false
    // Optional: false
    pVendorOptions: ?[*:0]const u8 = null,
};
// Extension: VK_ARM_data_graph
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDataGraphPipelineCreateInfoARM = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_CREATE_INFO_ARM,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    // Extern sync: false
    // Optional: false
    layout: VkPipelineLayout = .none,
    // Extern sync: false
    // Optional: false
    resourceInfoCount: u32 = 0,
    // Length member: resourceInfoCount
    // Extern sync: false
    // Optional: false
    pResourceInfos: ?[*]const VkDataGraphPipelineResourceInfoARM = null,
};
// Extension: VK_ARM_data_graph
// Extends: VkDataGraphPipelineCreateInfoARM
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDataGraphPipelineShaderModuleCreateInfoARM = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SHADER_MODULE_CREATE_INFO_ARM,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    module: VkShaderModule = .none,
    // Length member: null-terminated
    // Extern sync: false
    // Optional: false
    pName: ?[*:0]const u8 = null,
    // Extern sync: false
    // Optional: true
    pSpecializationInfo: ?*const VkSpecializationInfo = null,
    // Extern sync: false
    // Optional: true
    constantCount: u32 = 0,
    // Length member: constantCount
    // Extern sync: false
    // Optional: true
    pConstants: ?[*]const VkDataGraphPipelineConstantARM = null,
};
// Extension: VK_ARM_data_graph
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDataGraphPipelineSessionCreateInfoARM = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_CREATE_INFO_ARM,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkDataGraphPipelineSessionCreateFlagsARM = .{},
    // Extern sync: false
    // Optional: false
    dataGraphPipeline: VkPipeline = .none,
};
// Extension: VK_ARM_data_graph
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDataGraphPipelineSessionBindPointRequirementsInfoARM = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_REQUIREMENTS_INFO_ARM,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    session: VkDataGraphPipelineSessionARM = .none,
};
// Extension: VK_ARM_data_graph
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDataGraphPipelineSessionBindPointRequirementARM = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_REQUIREMENT_ARM,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    bindPoint: VkDataGraphPipelineSessionBindPointARM,
    // Extern sync: false
    // Optional: false
    bindPointType: VkDataGraphPipelineSessionBindPointTypeARM,
    // Extern sync: false
    // Optional: false
    numObjects: u32 = 0,
};
// Extension: VK_ARM_data_graph
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDataGraphPipelineSessionMemoryRequirementsInfoARM = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_MEMORY_REQUIREMENTS_INFO_ARM,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    session: VkDataGraphPipelineSessionARM = .none,
    // Extern sync: false
    // Optional: false
    bindPoint: VkDataGraphPipelineSessionBindPointARM,
    // Extern sync: false
    // Optional: false
    objectIndex: u32 = 0,
};
// Extension: VK_ARM_data_graph
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkBindDataGraphPipelineSessionMemoryInfoARM = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_BIND_DATA_GRAPH_PIPELINE_SESSION_MEMORY_INFO_ARM,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    session: VkDataGraphPipelineSessionARM = .none,
    // Extern sync: false
    // Optional: false
    bindPoint: VkDataGraphPipelineSessionBindPointARM,
    // Extern sync: false
    // Optional: false
    objectIndex: u32 = 0,
    // Extern sync: false
    // Optional: false
    memory: VkDeviceMemory = .none,
    // Extern sync: false
    // Optional: false
    memoryOffset: u64 = 0,
};
// Extension: VK_ARM_data_graph
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDataGraphPipelineInfoARM = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_INFO_ARM,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    dataGraphPipeline: VkPipeline = .none,
};
// Extension: VK_ARM_data_graph
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDataGraphPipelinePropertyQueryResultARM = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_PROPERTY_QUERY_RESULT_ARM,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    property: VkDataGraphPipelinePropertyARM,
    // Extern sync: false
    // Optional: false
    isText: u32 = 0,
    // Extern sync: false
    // Optional: true
    dataSize: u64 = 0,
    // Length member: dataSize
    // Extern sync: false
    // Optional: true
    pData: ?[*]anyopaque = null,
};
// Extension: VK_ARM_data_graph
// Extends: VkDataGraphPipelineCreateInfoARM
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDataGraphPipelineIdentifierCreateInfoARM = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_IDENTIFIER_CREATE_INFO_ARM,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    identifierSize: u32 = 0,
    // Length member: identifierSize
    // Extern sync: false
    // Optional: false
    pIdentifier: ?[*]const u8 = null,
};
// Extension: VK_ARM_data_graph
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDataGraphPipelineDispatchInfoARM = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_DISPATCH_INFO_ARM,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkDataGraphPipelineDispatchFlagsARM = .{},
};
// Extension: VK_ARM_data_graph
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceDataGraphProcessingEngineARM = extern struct {
    // Extern sync: false
    // Optional: false
    type: VkPhysicalDeviceDataGraphProcessingEngineTypeARM,
    // Extern sync: false
    // Optional: false
    isForeign: u32 = 0,
};
// Extension: VK_ARM_data_graph
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceDataGraphOperationSupportARM = extern struct {
    // Extern sync: false
    // Optional: false
    operationType: VkPhysicalDeviceDataGraphOperationTypeARM,
    // Length member: null-terminated
    // Extern sync: false
    // Optional: false
    name: [VK_MAX_PHYSICAL_DEVICE_DATA_GRAPH_OPERATION_SET_NAME_SIZE_ARM]u8 = @import("std").mem.zeroes([VK_MAX_PHYSICAL_DEVICE_DATA_GRAPH_OPERATION_SET_NAME_SIZE_ARM]u8),
    // Extern sync: false
    // Optional: false
    version: u32 = 0,
};
// Extension: VK_ARM_data_graph
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkQueueFamilyDataGraphPropertiesARM = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_QUEUE_FAMILY_DATA_GRAPH_PROPERTIES_ARM,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    engine: VkPhysicalDeviceDataGraphProcessingEngineARM = .{},
    // Extern sync: false
    // Optional: false
    operation: VkPhysicalDeviceDataGraphOperationSupportARM = .{},
};
// Extension: VK_ARM_data_graph
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARM = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_QUEUE_FAMILY_DATA_GRAPH_PROCESSING_ENGINE_INFO_ARM,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    queueFamilyIndex: u32 = 0,
    // Extern sync: false
    // Optional: false
    engineType: VkPhysicalDeviceDataGraphProcessingEngineTypeARM,
};
// Extension: VK_ARM_data_graph
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkQueueFamilyDataGraphProcessingEnginePropertiesARM = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_QUEUE_FAMILY_DATA_GRAPH_PROCESSING_ENGINE_PROPERTIES_ARM,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    foreignSemaphoreHandleTypes: VkExternalSemaphoreHandleTypeFlags = .{},
    // Extern sync: false
    // Optional: false
    foreignMemoryHandleTypes: VkExternalMemoryHandleTypeFlags = .{},
};
// Extension: VK_ARM_data_graph
// Extends: VkDataGraphPipelineCreateInfoARM,VkDescriptorPoolCreateInfo,VkCommandPoolCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDataGraphProcessingEngineCreateInfoARM = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_DATA_GRAPH_PROCESSING_ENGINE_CREATE_INFO_ARM,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    processingEngineCount: u32 = 0,
    // Length member: processingEngineCount
    // Extern sync: false
    // Optional: false
    pProcessingEngines: ?[*]VkPhysicalDeviceDataGraphProcessingEngineARM = null,
};
// Extension: VK_SEC_pipeline_cache_incremental_mode
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDevicePipelineCacheIncrementalModeFeaturesSEC = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CACHE_INCREMENTAL_MODE_FEATURES_SEC,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    pipelineCacheIncrementalMode: u32 = 0,
};
// Extension: VK_QCOM_data_graph_model
// Extends: VkDataGraphPipelineCreateInfoARM
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDataGraphPipelineBuiltinModelCreateInfoQCOM = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_BUILTIN_MODEL_CREATE_INFO_QCOM,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    pOperation: ?*const VkPhysicalDeviceDataGraphOperationSupportARM = null,
};
// Extension: VK_QCOM_data_graph_model
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceDataGraphModelFeaturesQCOM = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DATA_GRAPH_MODEL_FEATURES_QCOM,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Feature link: dataGraphModelQCOM
    dataGraphModel: u32 = 0,
};
// Extension: VK_KHR_shader_untyped_pointers
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceShaderUntypedPointersFeaturesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_UNTYPED_POINTERS_FEATURES_KHR,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    shaderUntypedPointers: u32 = 0,
};
// Extension: VK_OHOS_native_buffer
// Extends: VkImageCreateInfo,VkBindImageMemoryInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkNativeBufferOHOS = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_NATIVE_BUFFER_OHOS,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    handle: ?*OHBufferHandle = null,
};
// Extension: VK_OHOS_native_buffer
// Extends: VkImageCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSwapchainImageCreateInfoOHOS = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_SWAPCHAIN_IMAGE_CREATE_INFO_OHOS,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    usage: VkSwapchainImageUsageFlagsOHOS = .{},
};
// Extension: VK_OHOS_native_buffer
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDevicePresentationPropertiesOHOS = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENTATION_PROPERTIES_OHOS,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    sharedImage: u32 = 0,
};
// Extension: VK_VALVE_video_encode_rgb_conversion
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceVideoEncodeRgbConversionFeaturesVALVE = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_RGB_CONVERSION_FEATURES_VALVE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    videoEncodeRgbConversion: u32 = 0,
};
// Extension: VK_VALVE_video_encode_rgb_conversion
// Extends: VkVideoCapabilitiesKHR
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeRgbConversionCapabilitiesVALVE = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_RGB_CONVERSION_CAPABILITIES_VALVE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    rgbModels: VkVideoEncodeRgbModelConversionFlagsVALVE = .{},
    // Extern sync: false
    // Optional: false
    rgbRanges: VkVideoEncodeRgbRangeCompressionFlagsVALVE = .{},
    // Extern sync: false
    // Optional: false
    xChromaOffsets: VkVideoEncodeRgbChromaOffsetFlagsVALVE = .{},
    // Extern sync: false
    // Optional: false
    yChromaOffsets: VkVideoEncodeRgbChromaOffsetFlagsVALVE = .{},
};
// Extension: VK_VALVE_video_encode_rgb_conversion
// Extends: VkVideoProfileInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeProfileRgbConversionInfoVALVE = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_PROFILE_RGB_CONVERSION_INFO_VALVE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    performEncodeRgbConversion: u32 = 0,
};
// Extension: VK_VALVE_video_encode_rgb_conversion
// Extends: VkVideoSessionCreateInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeSessionRgbConversionCreateInfoVALVE = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_RGB_CONVERSION_CREATE_INFO_VALVE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    rgbModel: VkVideoEncodeRgbModelConversionFlagsVALVE = .{},
    // Extern sync: false
    // Optional: false
    rgbRange: VkVideoEncodeRgbRangeCompressionFlagsVALVE = .{},
    // Extern sync: false
    // Optional: false
    xChromaOffset: VkVideoEncodeRgbChromaOffsetFlagsVALVE = .{},
    // Extern sync: false
    // Optional: false
    yChromaOffset: VkVideoEncodeRgbChromaOffsetFlagsVALVE = .{},
};
// Extension: VK_EXT_shader_64bit_indexing
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceShader64BitIndexingFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_64_BIT_INDEXING_FEATURES_EXT,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    shader64BitIndexing: u32 = 0,
};
// Extension: VK_OHOS_external_memory
// Extends: VkImageFormatProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkNativeBufferUsageOHOS = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_NATIVE_BUFFER_USAGE_OHOS,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    OHOSNativeBufferUsage: u64 = 0,
};
// Extension: VK_OHOS_external_memory
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkNativeBufferPropertiesOHOS = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_NATIVE_BUFFER_PROPERTIES_OHOS,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    allocationSize: u64 = 0,
    // Extern sync: false
    // Optional: false
    memoryTypeBits: u32 = 0,
};
// Extension: VK_OHOS_external_memory
// Extends: VkNativeBufferPropertiesOHOS
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkNativeBufferFormatPropertiesOHOS = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_NATIVE_BUFFER_FORMAT_PROPERTIES_OHOS,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    format: VkFormat,
    // Extern sync: false
    // Optional: false
    externalFormat: u64 = 0,
    // Extern sync: false
    // Optional: false
    formatFeatures: VkFormatFeatureFlags = .{},
    // Extern sync: false
    // Optional: false
    samplerYcbcrConversionComponents: VkComponentMapping = .{},
    // Extern sync: false
    // Optional: false
    suggestedYcbcrModel: VkSamplerYcbcrModelConversion,
    // Extern sync: false
    // Optional: false
    suggestedYcbcrRange: VkSamplerYcbcrRange,
    // Extern sync: false
    // Optional: false
    suggestedXChromaOffset: VkChromaLocation,
    // Extern sync: false
    // Optional: false
    suggestedYChromaOffset: VkChromaLocation,
};
// Extension: VK_OHOS_external_memory
// Extends: VkMemoryAllocateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImportNativeBufferInfoOHOS = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_IMPORT_NATIVE_BUFFER_INFO_OHOS,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    buffer: ?*OH_NativeBuffer = null,
};
// Extension: VK_OHOS_external_memory
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkMemoryGetNativeBufferInfoOHOS = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_MEMORY_GET_NATIVE_BUFFER_INFO_OHOS,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    memory: VkDeviceMemory = .none,
};
// Extension: VK_OHOS_external_memory
// Extends: VkImageCreateInfo,VkSamplerYcbcrConversionCreateInfo,VkAttachmentDescription2,VkGraphicsPipelineCreateInfo,VkCommandBufferInheritanceInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkExternalFormatOHOS = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_OHOS,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    externalFormat: u64 = 0,
};
// Extension: VK_ARM_performance_counters_by_region
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDevicePerformanceCountersByRegionFeaturesARM = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_COUNTERS_BY_REGION_FEATURES_ARM,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    performanceCountersByRegion: u32 = 0,
};
// Extension: VK_ARM_performance_counters_by_region
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDevicePerformanceCountersByRegionPropertiesARM = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_COUNTERS_BY_REGION_PROPERTIES_ARM,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    maxPerRegionPerformanceCounters: u32 = 0,
    // Extern sync: false
    // Optional: false
    performanceCounterRegionSize: VkExtent2D = .{},
    // Extern sync: false
    // Optional: false
    rowStrideAlignment: u32 = 0,
    // Extern sync: false
    // Optional: false
    regionAlignment: u32 = 0,
    // Extern sync: false
    // Optional: false
    identityTransformOrder: u32 = 0,
};
// Extension: VK_ARM_performance_counters_by_region
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPerformanceCounterARM = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_ARM,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    counterID: u32 = 0,
};
// Extension: VK_ARM_performance_counters_by_region
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPerformanceCounterDescriptionARM = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_DESCRIPTION_ARM,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkPerformanceCounterDescriptionFlagsARM = .{},
    // Length member: null-terminated
    // Extern sync: false
    // Optional: false
    name: [VK_MAX_DESCRIPTION_SIZE]u8 = @import("std").mem.zeroes([VK_MAX_DESCRIPTION_SIZE]u8),
};
// Extension: VK_ARM_performance_counters_by_region
// Extends: VkRenderPassBeginInfo,VkRenderingInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkRenderPassPerformanceCountersByRegionBeginInfoARM = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_RENDER_PASS_PERFORMANCE_COUNTERS_BY_REGION_BEGIN_INFO_ARM,
    // Extern sync: false
    // Optional: true
    // Comment: Pointer to next structure
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    counterAddressCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    pCounterAddresses: ?*const u64 = null,
    // Extern sync: false
    // Optional: false
    serializeRegions: u32 = 0,
    // Extern sync: false
    // Optional: false
    counterIndexCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    pCounterIndices: ?*u32 = null,
};
// Extension: VK_NV_compute_occupancy_priority
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkComputeOccupancyPriorityParametersNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_COMPUTE_OCCUPANCY_PRIORITY_PARAMETERS_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    occupancyPriority: f32 = 0,
    // Extern sync: false
    // Optional: false
    occupancyThrottling: f32 = 0,
};
// Extension: VK_NV_compute_occupancy_priority
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceComputeOccupancyPriorityFeaturesNV = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_OCCUPANCY_PRIORITY_FEATURES_NV,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    computeOccupancyPriority: u32 = 0,
};

// Unions
// Extension: VK_COMPUTE_VERSION_1_0
// Comment: // Union allowing specification of floating-point, integer, or unsigned integer color data. Actual value selected is based on image/attachment being cleared.
pub const VkClearColorValue = extern union {
    float32: [4]f32,
    int32: [4]i32,
    uint32: [4]u32,
};
// Extension: VK_GRAPHICS_VERSION_1_0
// Comment: // Union allowing specification of color or depth and stencil values. Actual value selected is based on attachment being cleared.
pub const VkClearValue = extern union {
    color: VkClearColorValue,
    depthStencil: VkClearDepthStencilValue,
};
// Extension: VK_NV_cluster_acceleration_structure
pub const VkClusterAccelerationStructureOpInputNV = extern union {
    // Selected with: VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_BUILD_CLUSTERS_BOTTOM_LEVEL_NV
    pClustersBottomLevel: *VkClusterAccelerationStructureClustersBottomLevelInputNV,
    // Selected with: VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_BUILD_TRIANGLE_CLUSTER_NV,VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_BUILD_TRIANGLE_CLUSTER_TEMPLATE_NV,VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_INSTANTIATE_TRIANGLE_CLUSTER_NV,VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_GET_CLUSTER_TEMPLATE_INDICES_NV
    pTriangleClusters: *VkClusterAccelerationStructureTriangleClusterInputNV,
    // Selected with: VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_MOVE_OBJECTS_NV
    pMoveObjects: *VkClusterAccelerationStructureMoveObjectsInputNV,
};
// Extension: VK_KHR_performance_query
// Comment: // Union of all the possible return types a counter result could return
pub const VkPerformanceCounterResultKHR = extern union {
    int32: i32,
    int64: i64,
    uint32: u32,
    uint64: u64,
    float32: f32,
    float64: f64,
};
// Extension: VK_INTEL_performance_query
pub const VkPerformanceValueDataINTEL = extern union {
    // Selected with: VK_PERFORMANCE_VALUE_TYPE_UINT32_INTEL
    value32: u32,
    // Selected with: VK_PERFORMANCE_VALUE_TYPE_UINT64_INTEL
    value64: u64,
    // Selected with: VK_PERFORMANCE_VALUE_TYPE_FLOAT_INTEL
    valueFloat: f32,
    // Selected with: VK_PERFORMANCE_VALUE_TYPE_BOOL_INTEL
    valueBool: u32,
    // Selected with: VK_PERFORMANCE_VALUE_TYPE_STRING_INTEL
    valueString: [*:0]const u8,
};
// Extension: VK_KHR_pipeline_executable_properties
pub const VkPipelineExecutableStatisticValueKHR = extern union {
    // Selected with: VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_BOOL32_KHR
    b32: u32,
    // Selected with: VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_INT64_KHR
    i64: i64,
    // Selected with: VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_UINT64_KHR
    u64: u64,
    // Selected with: VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_FLOAT64_KHR
    f64: f64,
};
// Extension: VK_KHR_acceleration_structure
// Extension: VK_NV_cooperative_vector
pub const VkDeviceOrHostAddressKHR = extern union {
    deviceAddress: u64,
    hostAddress: *anyopaque,
};
// Extension: VK_KHR_acceleration_structure
// Extension: VK_NV_cooperative_vector
pub const VkDeviceOrHostAddressConstKHR = extern union {
    deviceAddress: u64,
    hostAddress: *const anyopaque,
};
// Extension: VK_AMDX_shader_enqueue
pub const VkDeviceOrHostAddressConstAMDX = extern union {
    deviceAddress: u64,
    hostAddress: *const anyopaque,
};
// Extension: VK_KHR_acceleration_structure
pub const VkAccelerationStructureGeometryDataKHR = extern union {
    // Selected with: VK_GEOMETRY_TYPE_TRIANGLES_KHR
    triangles: VkAccelerationStructureGeometryTrianglesDataKHR,
    // Selected with: VK_GEOMETRY_TYPE_AABBS_KHR
    aabbs: VkAccelerationStructureGeometryAabbsDataKHR,
    // Selected with: VK_GEOMETRY_TYPE_INSTANCES_KHR
    instances: VkAccelerationStructureGeometryInstancesDataKHR,
};
// Extension: VK_EXT_device_generated_commands
pub const VkIndirectExecutionSetInfoEXT = extern union {
    // Selected with: VK_INDIRECT_EXECUTION_SET_INFO_TYPE_PIPELINES_EXT
    pPipelineInfo: *const VkIndirectExecutionSetPipelineInfoEXT,
    // Selected with: VK_INDIRECT_EXECUTION_SET_INFO_TYPE_SHADER_OBJECTS_EXT
    pShaderInfo: *const VkIndirectExecutionSetShaderInfoEXT,
};
// Extension: VK_EXT_device_generated_commands
pub const VkIndirectCommandsTokenDataEXT = extern union {
    // Selected with: VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_EXT,VK_INDIRECT_COMMANDS_TOKEN_TYPE_SEQUENCE_INDEX_EXT
    pPushConstant: *const VkIndirectCommandsPushConstantTokenEXT,
    // Selected with: VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_EXT
    pVertexBuffer: *const VkIndirectCommandsVertexBufferTokenEXT,
    // Selected with: VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_EXT
    pIndexBuffer: *const VkIndirectCommandsIndexBufferTokenEXT,
    // Selected with: VK_INDIRECT_COMMANDS_TOKEN_TYPE_EXECUTION_SET_EXT
    pExecutionSet: *const VkIndirectCommandsExecutionSetTokenEXT,
};
// Extension: VK_EXT_descriptor_buffer
pub const VkDescriptorDataEXT = extern union {
    // Selected with: VK_DESCRIPTOR_TYPE_SAMPLER
    pSampler: *const VkSampler,
    // Selected with: VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER
    pCombinedImageSampler: *const VkDescriptorImageInfo,
    // Selected with: VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT
    pInputAttachmentImage: *const VkDescriptorImageInfo,
    // Selected with: VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE
    pSampledImage: *const VkDescriptorImageInfo,
    // Selected with: VK_DESCRIPTOR_TYPE_STORAGE_IMAGE
    pStorageImage: *const VkDescriptorImageInfo,
    // Selected with: VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER
    pUniformTexelBuffer: *const VkDescriptorAddressInfoEXT,
    // Selected with: VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER
    pStorageTexelBuffer: *const VkDescriptorAddressInfoEXT,
    // Selected with: VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER
    pUniformBuffer: *const VkDescriptorAddressInfoEXT,
    // Selected with: VK_DESCRIPTOR_TYPE_STORAGE_BUFFER
    pStorageBuffer: *const VkDescriptorAddressInfoEXT,
    // Selected with: VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR,VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV
    accelerationStructure: u64,
};
// Extension: VK_NV_ray_tracing_motion_blur
pub const VkAccelerationStructureMotionInstanceDataNV = extern union {
    // Selected with: VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_STATIC_NV
    staticInstance: VkAccelerationStructureInstanceKHR,
    // Selected with: VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_MATRIX_MOTION_NV
    matrixMotionInstance: VkAccelerationStructureMatrixMotionInstanceNV,
    // Selected with: VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_SRT_MOTION_NV
    srtMotionInstance: VkAccelerationStructureSRTMotionInstanceNV,
};

// Functions
// Can be used without queues: false
pub const vkInternalAllocationNotification = fn (
    pUserData: *anyopaque,
    size: u64,
    allocationType: VkInternalAllocationType,
    allocationScope: VkSystemAllocationScope,
) callconv(.c) void;
// Can be used without queues: false
pub const vkInternalFreeNotification = fn (
    pUserData: *anyopaque,
    size: u64,
    allocationType: VkInternalAllocationType,
    allocationScope: VkSystemAllocationScope,
) callconv(.c) void;
// Can be used without queues: false
pub const vkReallocationFunction = fn (
    pUserData: *anyopaque,
    pOriginal: *anyopaque,
    size: u64,
    alignment: u64,
    allocationScope: VkSystemAllocationScope,
) callconv(.c) [*]u8;
// Can be used without queues: false
pub const vkAllocationFunction = fn (
    pUserData: *anyopaque,
    size: u64,
    alignment: u64,
    allocationScope: VkSystemAllocationScope,
) callconv(.c) [*]u8;
// Can be used without queues: false
pub const vkFreeFunction = fn (
    pUserData: *anyopaque,
    pMemory: *anyopaque,
) callconv(.c) void;
// Can be used without queues: false
pub const vkVoidFunction = fn (
    pUserData: *anyopaque,
    pMemory: *anyopaque,
) callconv(.c) void;
// Can be used without queues: false
pub const vkDebugReportCallbackEXT = fn (
    flags: VkDebugReportFlagsEXT,
    objectType: VkDebugReportObjectTypeEXT,
    object: u64,
    location: u64,
    messageCode: i32,
    pLayerPrefix: *const u8,
    pMessage: *const u8,
    pUserData: *anyopaque,
) callconv(.c) u32;
// Can be used without queues: false
pub const vkDebugUtilsMessengerCallbackEXT = fn (
    messageSeverity: VkDebugUtilsMessageSeverityFlagsEXT,
    messageTypes: VkDebugUtilsMessageTypeFlagsEXT,
    pCallbackData: *const VkDebugUtilsMessengerCallbackDataEXT,
    pUserData: *anyopaque,
) callconv(.c) u32;
// Can be used without queues: false
pub const vkFaultCallbackFunction = fn (
    unrecordedFaults: u32,
    faultCount: u32,
    pFaults: *const anyopaque,
) callconv(.c) void;
// Can be used without queues: false
pub const vkDeviceMemoryReportCallbackEXT = fn (
    pCallbackData: *const VkDeviceMemoryReportCallbackDataEXT,
    pUserData: *const anyopaque,
) callconv(.c) void;
// Can be used without queues: false
pub const vkGetInstanceProcAddrLUNARG = fn (
    instance: VkInstance,
    pName: *const u8,
) callconv(.c) *const vkVoidFunction;

// Commands
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_LAYER_NOT_PRESENT,VK_ERROR_EXTENSION_NOT_PRESENT,VK_ERROR_INCOMPATIBLE_DRIVER,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateInstance = fn (
    pCreateInfo: *const VkInstanceCreateInfo,
    pAllocator: ?*const VkAllocationCallbacks,
    pInstance: *VkInstance,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkDestroyInstance = fn (
    instance: ?VkInstance,
    pAllocator: ?*const VkAllocationCallbacks,
) callconv(.c) void;
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkEnumeratePhysicalDevices = fn (
    instance: VkInstance,
    pPhysicalDeviceCount: *u32,
    // len: pPhysicalDeviceCount
    pPhysicalDevices: ?[*]VkPhysicalDevice,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkGetDeviceProcAddr = fn (
    device: VkDevice,
    // len: null-terminated
    pName: [*:0]const u8,
) callconv(.c) *const vkVoidFunction;
// Can be used without queues: false
pub const vkGetInstanceProcAddr = fn (
    instance: ?VkInstance,
    // len: null-terminated
    pName: [*:0]const u8,
) callconv(.c) *const vkVoidFunction;
// Can be used without queues: false
pub const vkGetPhysicalDeviceProperties = fn (
    physicalDevice: VkPhysicalDevice,
    pProperties: *VkPhysicalDeviceProperties,
) callconv(.c) void;
// Can be used without queues: false
pub const vkGetPhysicalDeviceQueueFamilyProperties = fn (
    physicalDevice: VkPhysicalDevice,
    pQueueFamilyPropertyCount: *u32,
    // len: pQueueFamilyPropertyCount
    pQueueFamilyProperties: ?[*]VkQueueFamilyProperties,
) callconv(.c) void;
// Can be used without queues: false
pub const vkGetPhysicalDeviceMemoryProperties = fn (
    physicalDevice: VkPhysicalDevice,
    pMemoryProperties: *VkPhysicalDeviceMemoryProperties,
) callconv(.c) void;
// Can be used without queues: false
pub const vkGetPhysicalDeviceFeatures = fn (
    physicalDevice: VkPhysicalDevice,
    pFeatures: *VkPhysicalDeviceFeatures,
) callconv(.c) void;
// Can be used without queues: false
pub const vkGetPhysicalDeviceFormatProperties = fn (
    physicalDevice: VkPhysicalDevice,
    format: VkFormat,
    pFormatProperties: *VkFormatProperties,
) callconv(.c) void;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_FORMAT_NOT_SUPPORTED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetPhysicalDeviceImageFormatProperties = fn (
    physicalDevice: VkPhysicalDevice,
    format: VkFormat,
    type: VkImageType,
    tiling: VkImageTiling,
    usage: VkImageUsageFlags,
    flags: ?VkImageCreateFlags,
    pImageFormatProperties: *VkImageFormatProperties,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_EXTENSION_NOT_PRESENT,VK_ERROR_FEATURE_NOT_PRESENT,VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_DEVICE_LOST,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateDevice = fn (
    physicalDevice: VkPhysicalDevice,
    pCreateInfo: *const VkDeviceCreateInfo,
    pAllocator: ?*const VkAllocationCallbacks,
    pDevice: *VkDevice,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkDestroyDevice = fn (
    device: ?VkDevice,
    pAllocator: ?*const VkAllocationCallbacks,
) callconv(.c) void;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkEnumerateInstanceVersion = fn (
    pApiVersion: *u32,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkEnumerateInstanceLayerProperties = fn (
    pPropertyCount: *u32,
    // len: pPropertyCount
    pProperties: ?[*]VkLayerProperties,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_LAYER_NOT_PRESENT,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkEnumerateInstanceExtensionProperties = fn (
    // len: null-terminated
    pLayerName: ?[*:0]const u8,
    pPropertyCount: *u32,
    // len: pPropertyCount
    pProperties: ?[*]VkExtensionProperties,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkEnumerateDeviceLayerProperties = fn (
    physicalDevice: VkPhysicalDevice,
    pPropertyCount: *u32,
    // len: pPropertyCount
    pProperties: ?[*]VkLayerProperties,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_LAYER_NOT_PRESENT,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkEnumerateDeviceExtensionProperties = fn (
    physicalDevice: VkPhysicalDevice,
    // len: null-terminated
    pLayerName: ?[*:0]const u8,
    pPropertyCount: *u32,
    // len: pPropertyCount
    pProperties: ?[*]VkExtensionProperties,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkGetDeviceQueue = fn (
    device: VkDevice,
    queueFamilyIndex: u32,
    queueIndex: u32,
    pQueue: *VkQueue,
) callconv(.c) void;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkQueueSubmit = fn (
    queue: VkQueue,
    submitCount: ?u32,
    // len: submitCount
    pSubmits: [*]const VkSubmitInfo,
    fence: ?VkFence,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkQueueWaitIdle = fn (
    queue: VkQueue,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkDeviceWaitIdle = fn (
    device: VkDevice,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INVALID_EXTERNAL_HANDLE,VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkAllocateMemory = fn (
    device: VkDevice,
    pAllocateInfo: *const VkMemoryAllocateInfo,
    pAllocator: ?*const VkAllocationCallbacks,
    pMemory: *VkDeviceMemory,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkFreeMemory = fn (
    device: VkDevice,
    memory: ?VkDeviceMemory,
    pAllocator: ?*const VkAllocationCallbacks,
) callconv(.c) void;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_MEMORY_MAP_FAILED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkMapMemory = fn (
    device: VkDevice,
    memory: VkDeviceMemory,
    offset: u64,
    size: u64,
    flags: ?VkMemoryMapFlags,
    ppData: **anyopaque,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkUnmapMemory = fn (
    device: VkDevice,
    memory: VkDeviceMemory,
) callconv(.c) void;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkFlushMappedMemoryRanges = fn (
    device: VkDevice,
    memoryRangeCount: u32,
    // len: memoryRangeCount
    pMemoryRanges: [*]const VkMappedMemoryRange,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkInvalidateMappedMemoryRanges = fn (
    device: VkDevice,
    memoryRangeCount: u32,
    // len: memoryRangeCount
    pMemoryRanges: [*]const VkMappedMemoryRange,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkGetDeviceMemoryCommitment = fn (
    device: VkDevice,
    memory: VkDeviceMemory,
    pCommittedMemoryInBytes: *u64,
) callconv(.c) void;
// Can be used without queues: false
pub const vkGetBufferMemoryRequirements = fn (
    device: VkDevice,
    buffer: VkBuffer,
    pMemoryRequirements: *VkMemoryRequirements,
) callconv(.c) void;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkBindBufferMemory = fn (
    device: VkDevice,
    buffer: VkBuffer,
    memory: VkDeviceMemory,
    memoryOffset: u64,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkGetImageMemoryRequirements = fn (
    device: VkDevice,
    image: VkImage,
    pMemoryRequirements: *VkMemoryRequirements,
) callconv(.c) void;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkBindImageMemory = fn (
    device: VkDevice,
    image: VkImage,
    memory: VkDeviceMemory,
    memoryOffset: u64,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkGetImageSparseMemoryRequirements = fn (
    device: VkDevice,
    image: VkImage,
    pSparseMemoryRequirementCount: *u32,
    // len: pSparseMemoryRequirementCount
    pSparseMemoryRequirements: ?[*]VkSparseImageMemoryRequirements,
) callconv(.c) void;
// Can be used without queues: false
pub const vkGetPhysicalDeviceSparseImageFormatProperties = fn (
    physicalDevice: VkPhysicalDevice,
    format: VkFormat,
    type: VkImageType,
    samples: VkSampleCountFlags,
    usage: VkImageUsageFlags,
    tiling: VkImageTiling,
    pPropertyCount: *u32,
    // len: pPropertyCount
    pProperties: ?[*]VkSparseImageFormatProperties,
) callconv(.c) void;
// Queues: VK_QUEUE_SPARSE_BINDING_BIT
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkQueueBindSparse = fn (
    queue: VkQueue,
    bindInfoCount: ?u32,
    // len: bindInfoCount
    pBindInfo: [*]const VkBindSparseInfo,
    fence: ?VkFence,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateFence = fn (
    device: VkDevice,
    pCreateInfo: *const VkFenceCreateInfo,
    pAllocator: ?*const VkAllocationCallbacks,
    pFence: *VkFence,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkDestroyFence = fn (
    device: VkDevice,
    fence: ?VkFence,
    pAllocator: ?*const VkAllocationCallbacks,
) callconv(.c) void;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkResetFences = fn (
    device: VkDevice,
    fenceCount: u32,
    // len: fenceCount
    pFences: [*]const VkFence,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS,VK_NOT_READY
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetFenceStatus = fn (
    device: VkDevice,
    fence: VkFence,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS,VK_TIMEOUT
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkWaitForFences = fn (
    device: VkDevice,
    fenceCount: u32,
    // len: fenceCount
    pFences: [*]const VkFence,
    waitAll: u32,
    timeout: u64,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateSemaphore = fn (
    device: VkDevice,
    pCreateInfo: *const VkSemaphoreCreateInfo,
    pAllocator: ?*const VkAllocationCallbacks,
    pSemaphore: *VkSemaphore,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkDestroySemaphore = fn (
    device: VkDevice,
    semaphore: ?VkSemaphore,
    pAllocator: ?*const VkAllocationCallbacks,
) callconv(.c) void;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateEvent = fn (
    device: VkDevice,
    pCreateInfo: *const VkEventCreateInfo,
    pAllocator: ?*const VkAllocationCallbacks,
    pEvent: *VkEvent,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkDestroyEvent = fn (
    device: VkDevice,
    event: ?VkEvent,
    pAllocator: ?*const VkAllocationCallbacks,
) callconv(.c) void;
// Success codes: VK_EVENT_SET,VK_EVENT_RESET
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetEventStatus = fn (
    device: VkDevice,
    event: VkEvent,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkSetEvent = fn (
    device: VkDevice,
    event: VkEvent,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkResetEvent = fn (
    device: VkDevice,
    event: VkEvent,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateQueryPool = fn (
    device: VkDevice,
    pCreateInfo: *const VkQueryPoolCreateInfo,
    pAllocator: ?*const VkAllocationCallbacks,
    pQueryPool: *VkQueryPool,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkDestroyQueryPool = fn (
    device: VkDevice,
    queryPool: ?VkQueryPool,
    pAllocator: ?*const VkAllocationCallbacks,
) callconv(.c) void;
// Success codes: VK_SUCCESS,VK_NOT_READY
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetQueryPoolResults = fn (
    device: VkDevice,
    queryPool: VkQueryPool,
    firstQuery: u32,
    queryCount: u32,
    dataSize: u64,
    // len: dataSize
    pData: [*]anyopaque,
    stride: u64,
    flags: ?VkQueryResultFlags,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkResetQueryPool = fn (
    device: VkDevice,
    queryPool: VkQueryPool,
    firstQuery: u32,
    queryCount: u32,
) callconv(.c) void;
// Extension: VK_EXT_host_query_reset
pub const vkResetQueryPoolEXT = vkResetQueryPool;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateBuffer = fn (
    device: VkDevice,
    pCreateInfo: *const VkBufferCreateInfo,
    pAllocator: ?*const VkAllocationCallbacks,
    pBuffer: *VkBuffer,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkDestroyBuffer = fn (
    device: VkDevice,
    buffer: ?VkBuffer,
    pAllocator: ?*const VkAllocationCallbacks,
) callconv(.c) void;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateBufferView = fn (
    device: VkDevice,
    pCreateInfo: *const VkBufferViewCreateInfo,
    pAllocator: ?*const VkAllocationCallbacks,
    pView: *VkBufferView,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkDestroyBufferView = fn (
    device: VkDevice,
    bufferView: ?VkBufferView,
    pAllocator: ?*const VkAllocationCallbacks,
) callconv(.c) void;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_COMPRESSION_EXHAUSTED_EXT,VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateImage = fn (
    device: VkDevice,
    pCreateInfo: *const VkImageCreateInfo,
    pAllocator: ?*const VkAllocationCallbacks,
    pImage: *VkImage,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkDestroyImage = fn (
    device: VkDevice,
    image: ?VkImage,
    pAllocator: ?*const VkAllocationCallbacks,
) callconv(.c) void;
// Can be used without queues: false
pub const vkGetImageSubresourceLayout = fn (
    device: VkDevice,
    image: VkImage,
    pSubresource: *const VkImageSubresource,
    pLayout: *VkSubresourceLayout,
) callconv(.c) void;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateImageView = fn (
    device: VkDevice,
    pCreateInfo: *const VkImageViewCreateInfo,
    pAllocator: ?*const VkAllocationCallbacks,
    pView: *VkImageView,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkDestroyImageView = fn (
    device: VkDevice,
    imageView: ?VkImageView,
    pAllocator: ?*const VkAllocationCallbacks,
) callconv(.c) void;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INVALID_SHADER_NV,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: true
pub const vkCreateShaderModule = fn (
    device: VkDevice,
    pCreateInfo: *const VkShaderModuleCreateInfo,
    pAllocator: ?*const VkAllocationCallbacks,
    pShaderModule: *VkShaderModule,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkDestroyShaderModule = fn (
    device: VkDevice,
    shaderModule: ?VkShaderModule,
    pAllocator: ?*const VkAllocationCallbacks,
) callconv(.c) void;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: true
pub const vkCreatePipelineCache = fn (
    device: VkDevice,
    pCreateInfo: *const VkPipelineCacheCreateInfo,
    pAllocator: ?*const VkAllocationCallbacks,
    pPipelineCache: *VkPipelineCache,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkDestroyPipelineCache = fn (
    device: VkDevice,
    pipelineCache: ?VkPipelineCache,
    pAllocator: ?*const VkAllocationCallbacks,
) callconv(.c) void;
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetPipelineCacheData = fn (
    device: VkDevice,
    pipelineCache: VkPipelineCache,
    pDataSize: *u64,
    // len: pDataSize
    pData: ?[*]anyopaque,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkMergePipelineCaches = fn (
    device: VkDevice,
    dstCache: VkPipelineCache,
    srcCacheCount: u32,
    // len: srcCacheCount
    pSrcCaches: [*]const VkPipelineCache,
) callconv(.c) VkResult;
// Extension: VK_KHR_pipeline_binary
// Success codes: VK_SUCCESS,VK_INCOMPLETE,VK_PIPELINE_BINARY_MISSING_KHR
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: true
pub const vkCreatePipelineBinariesKHR = fn (
    device: VkDevice,
    pCreateInfo: *const VkPipelineBinaryCreateInfoKHR,
    pAllocator: ?*const VkAllocationCallbacks,
    pBinaries: *VkPipelineBinaryHandlesInfoKHR,
) callconv(.c) VkResult;
// Extension: VK_KHR_pipeline_binary
// Can be used without queues: false
pub const vkDestroyPipelineBinaryKHR = fn (
    device: VkDevice,
    pipelineBinary: ?VkPipelineBinaryKHR,
    pAllocator: ?*const VkAllocationCallbacks,
) callconv(.c) void;
// Extension: VK_KHR_pipeline_binary
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetPipelineKeyKHR = fn (
    device: VkDevice,
    pPipelineCreateInfo: ?*const VkPipelineCreateInfoKHR,
    pPipelineKey: *VkPipelineBinaryKeyKHR,
) callconv(.c) VkResult;
// Extension: VK_KHR_pipeline_binary
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_NOT_ENOUGH_SPACE_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetPipelineBinaryDataKHR = fn (
    device: VkDevice,
    pInfo: *const VkPipelineBinaryDataInfoKHR,
    pPipelineBinaryKey: *VkPipelineBinaryKeyKHR,
    pPipelineBinaryDataSize: *u64,
    // len: pPipelineBinaryDataSize
    pPipelineBinaryData: ?[*]anyopaque,
) callconv(.c) VkResult;
// Extension: VK_KHR_pipeline_binary
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkReleaseCapturedPipelineDataKHR = fn (
    device: VkDevice,
    pInfo: *const VkReleaseCapturedPipelineDataInfoKHR,
    pAllocator: ?*const VkAllocationCallbacks,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS,VK_PIPELINE_COMPILE_REQUIRED_EXT
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INVALID_SHADER_NV,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: true
pub const vkCreateGraphicsPipelines = fn (
    device: VkDevice,
    pipelineCache: ?VkPipelineCache,
    createInfoCount: u32,
    // len: createInfoCount
    pCreateInfos: [*]const VkGraphicsPipelineCreateInfo,
    pAllocator: ?*const VkAllocationCallbacks,
    // len: createInfoCount
    pPipelines: [*]VkPipeline,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS,VK_PIPELINE_COMPILE_REQUIRED_EXT
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INVALID_SHADER_NV,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: true
pub const vkCreateComputePipelines = fn (
    device: VkDevice,
    pipelineCache: ?VkPipelineCache,
    createInfoCount: u32,
    // len: createInfoCount
    pCreateInfos: [*]const VkComputePipelineCreateInfo,
    pAllocator: ?*const VkAllocationCallbacks,
    // len: createInfoCount
    pPipelines: [*]VkPipeline,
) callconv(.c) VkResult;
// Extension: VK_HUAWEI_subpass_shading
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI = fn (
    device: VkDevice,
    renderpass: VkRenderPass,
    // len: 1
    pMaxWorkgroupSize: *VkExtent2D,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkDestroyPipeline = fn (
    device: VkDevice,
    pipeline: ?VkPipeline,
    pAllocator: ?*const VkAllocationCallbacks,
) callconv(.c) void;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: true
pub const vkCreatePipelineLayout = fn (
    device: VkDevice,
    pCreateInfo: *const VkPipelineLayoutCreateInfo,
    pAllocator: ?*const VkAllocationCallbacks,
    pPipelineLayout: *VkPipelineLayout,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkDestroyPipelineLayout = fn (
    device: VkDevice,
    pipelineLayout: ?VkPipelineLayout,
    pAllocator: ?*const VkAllocationCallbacks,
) callconv(.c) void;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: true
pub const vkCreateSampler = fn (
    device: VkDevice,
    pCreateInfo: *const VkSamplerCreateInfo,
    pAllocator: ?*const VkAllocationCallbacks,
    pSampler: *VkSampler,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkDestroySampler = fn (
    device: VkDevice,
    sampler: ?VkSampler,
    pAllocator: ?*const VkAllocationCallbacks,
) callconv(.c) void;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: true
pub const vkCreateDescriptorSetLayout = fn (
    device: VkDevice,
    pCreateInfo: *const VkDescriptorSetLayoutCreateInfo,
    pAllocator: ?*const VkAllocationCallbacks,
    pSetLayout: *VkDescriptorSetLayout,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkDestroyDescriptorSetLayout = fn (
    device: VkDevice,
    descriptorSetLayout: ?VkDescriptorSetLayout,
    pAllocator: ?*const VkAllocationCallbacks,
) callconv(.c) void;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_FRAGMENTATION_EXT,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateDescriptorPool = fn (
    device: VkDevice,
    pCreateInfo: *const VkDescriptorPoolCreateInfo,
    pAllocator: ?*const VkAllocationCallbacks,
    pDescriptorPool: *VkDescriptorPool,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkDestroyDescriptorPool = fn (
    device: VkDevice,
    descriptorPool: ?VkDescriptorPool,
    pAllocator: ?*const VkAllocationCallbacks,
) callconv(.c) void;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkResetDescriptorPool = fn (
    device: VkDevice,
    descriptorPool: VkDescriptorPool,
    flags: ?VkDescriptorPoolResetFlags,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_FRAGMENTED_POOL,VK_ERROR_OUT_OF_POOL_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkAllocateDescriptorSets = fn (
    device: VkDevice,
    pAllocateInfo: *const VkDescriptorSetAllocateInfo,
    // len: pAllocateInfo-&gt;descriptorSetCount
    pDescriptorSets: [*]VkDescriptorSet,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkFreeDescriptorSets = fn (
    device: VkDevice,
    descriptorPool: VkDescriptorPool,
    descriptorSetCount: u32,
    // len: descriptorSetCount
    pDescriptorSets: [*]const VkDescriptorSet,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkUpdateDescriptorSets = fn (
    device: VkDevice,
    descriptorWriteCount: ?u32,
    // len: descriptorWriteCount
    pDescriptorWrites: [*]const VkWriteDescriptorSet,
    descriptorCopyCount: ?u32,
    // len: descriptorCopyCount
    pDescriptorCopies: [*]const VkCopyDescriptorSet,
) callconv(.c) void;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateFramebuffer = fn (
    device: VkDevice,
    pCreateInfo: *const VkFramebufferCreateInfo,
    pAllocator: ?*const VkAllocationCallbacks,
    pFramebuffer: *VkFramebuffer,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkDestroyFramebuffer = fn (
    device: VkDevice,
    framebuffer: ?VkFramebuffer,
    pAllocator: ?*const VkAllocationCallbacks,
) callconv(.c) void;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: true
pub const vkCreateRenderPass = fn (
    device: VkDevice,
    pCreateInfo: *const VkRenderPassCreateInfo,
    pAllocator: ?*const VkAllocationCallbacks,
    pRenderPass: *VkRenderPass,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkDestroyRenderPass = fn (
    device: VkDevice,
    renderPass: ?VkRenderPass,
    pAllocator: ?*const VkAllocationCallbacks,
) callconv(.c) void;
// Can be used without queues: false
pub const vkGetRenderAreaGranularity = fn (
    device: VkDevice,
    renderPass: VkRenderPass,
    pGranularity: *VkExtent2D,
) callconv(.c) void;
// Can be used without queues: false
pub const vkGetRenderingAreaGranularity = fn (
    device: VkDevice,
    pRenderingAreaInfo: *const VkRenderingAreaInfo,
    pGranularity: *VkExtent2D,
) callconv(.c) void;
// Extension: VK_KHR_maintenance5
pub const vkGetRenderingAreaGranularityKHR = vkGetRenderingAreaGranularity;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateCommandPool = fn (
    device: VkDevice,
    pCreateInfo: *const VkCommandPoolCreateInfo,
    pAllocator: ?*const VkAllocationCallbacks,
    pCommandPool: *VkCommandPool,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkDestroyCommandPool = fn (
    device: VkDevice,
    commandPool: ?VkCommandPool,
    pAllocator: ?*const VkAllocationCallbacks,
) callconv(.c) void;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkResetCommandPool = fn (
    device: VkDevice,
    commandPool: VkCommandPool,
    flags: ?VkCommandPoolResetFlags,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkAllocateCommandBuffers = fn (
    device: VkDevice,
    pAllocateInfo: *const VkCommandBufferAllocateInfo,
    // len: pAllocateInfo-&gt;commandBufferCount
    pCommandBuffers: [*]VkCommandBuffer,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkFreeCommandBuffers = fn (
    device: VkDevice,
    commandPool: VkCommandPool,
    commandBufferCount: u32,
    // len: commandBufferCount
    pCommandBuffers: [*]const VkCommandBuffer,
) callconv(.c) void;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkBeginCommandBuffer = fn (
    commandBuffer: VkCommandBuffer,
    pBeginInfo: *const VkCommandBufferBeginInfo,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INVALID_VIDEO_STD_PARAMETERS_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkEndCommandBuffer = fn (
    commandBuffer: VkCommandBuffer,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkResetCommandBuffer = fn (
    commandBuffer: VkCommandBuffer,
    flags: ?VkCommandBufferResetFlags,
) callconv(.c) VkResult;
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT,VK_QUEUE_DATA_GRAPH_BIT_ARM
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdBindPipeline = fn (
    commandBuffer: VkCommandBuffer,
    pipelineBindPoint: VkPipelineBindPoint,
    pipeline: VkPipeline,
) callconv(.c) void;
// Extension: VK_EXT_attachment_feedback_loop_dynamic_state
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetAttachmentFeedbackLoopEnableEXT = fn (
    commandBuffer: VkCommandBuffer,
    aspectMask: ?VkImageAspectFlags,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetViewport = fn (
    commandBuffer: VkCommandBuffer,
    firstViewport: u32,
    viewportCount: u32,
    // len: viewportCount
    pViewports: [*]const VkViewport,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetScissor = fn (
    commandBuffer: VkCommandBuffer,
    firstScissor: u32,
    scissorCount: u32,
    // len: scissorCount
    pScissors: [*]const VkRect2D,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetLineWidth = fn (
    commandBuffer: VkCommandBuffer,
    lineWidth: f32,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetDepthBias = fn (
    commandBuffer: VkCommandBuffer,
    depthBiasConstantFactor: f32,
    depthBiasClamp: f32,
    depthBiasSlopeFactor: f32,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetBlendConstants = fn (
    commandBuffer: VkCommandBuffer,
    blendConstants: *const [4]f32,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetDepthBounds = fn (
    commandBuffer: VkCommandBuffer,
    minDepthBounds: f32,
    maxDepthBounds: f32,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetStencilCompareMask = fn (
    commandBuffer: VkCommandBuffer,
    faceMask: VkStencilFaceFlags,
    compareMask: u32,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetStencilWriteMask = fn (
    commandBuffer: VkCommandBuffer,
    faceMask: VkStencilFaceFlags,
    writeMask: u32,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetStencilReference = fn (
    commandBuffer: VkCommandBuffer,
    faceMask: VkStencilFaceFlags,
    reference: u32,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT,VK_QUEUE_DATA_GRAPH_BIT_ARM
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdBindDescriptorSets = fn (
    commandBuffer: VkCommandBuffer,
    pipelineBindPoint: VkPipelineBindPoint,
    layout: VkPipelineLayout,
    firstSet: u32,
    descriptorSetCount: u32,
    // len: descriptorSetCount
    pDescriptorSets: [*]const VkDescriptorSet,
    dynamicOffsetCount: ?u32,
    // len: dynamicOffsetCount
    pDynamicOffsets: [*]const u32,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdBindIndexBuffer = fn (
    commandBuffer: VkCommandBuffer,
    buffer: ?VkBuffer,
    offset: u64,
    indexType: VkIndexType,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdBindVertexBuffers = fn (
    commandBuffer: VkCommandBuffer,
    firstBinding: u32,
    bindingCount: u32,
    // len: bindingCount
    pBuffers: [*]const VkBuffer,
    // len: bindingCount
    pOffsets: [*]const u64,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: inside
// Command buffer levels: primary,secondary
// Conditional rendering: true
// Can be used without queues: false
pub const vkCmdDraw = fn (
    commandBuffer: VkCommandBuffer,
    vertexCount: u32,
    instanceCount: u32,
    firstVertex: u32,
    firstInstance: u32,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: inside
// Command buffer levels: primary,secondary
// Conditional rendering: true
// Can be used without queues: false
pub const vkCmdDrawIndexed = fn (
    commandBuffer: VkCommandBuffer,
    indexCount: u32,
    instanceCount: u32,
    firstIndex: u32,
    vertexOffset: i32,
    firstInstance: u32,
) callconv(.c) void;
// Extension: VK_EXT_multi_draw
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: inside
// Command buffer levels: primary,secondary
// Conditional rendering: true
// Can be used without queues: false
pub const vkCmdDrawMultiEXT = fn (
    commandBuffer: VkCommandBuffer,
    drawCount: ?u32,
    // len: drawCount
    pVertexInfo: [*]const VkMultiDrawInfoEXT,
    instanceCount: u32,
    firstInstance: u32,
    stride: u32,
) callconv(.c) void;
// Extension: VK_EXT_multi_draw
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: inside
// Command buffer levels: primary,secondary
// Conditional rendering: true
// Can be used without queues: false
pub const vkCmdDrawMultiIndexedEXT = fn (
    commandBuffer: VkCommandBuffer,
    drawCount: ?u32,
    // len: drawCount
    pIndexInfo: [*]const VkMultiDrawIndexedInfoEXT,
    instanceCount: u32,
    firstInstance: u32,
    stride: u32,
    pVertexOffset: ?*const i32,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: inside
// Command buffer levels: primary,secondary
// Conditional rendering: true
// Can be used without queues: false
pub const vkCmdDrawIndirect = fn (
    commandBuffer: VkCommandBuffer,
    buffer: VkBuffer,
    offset: u64,
    drawCount: u32,
    stride: u32,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: inside
// Command buffer levels: primary,secondary
// Conditional rendering: true
// Can be used without queues: false
pub const vkCmdDrawIndexedIndirect = fn (
    commandBuffer: VkCommandBuffer,
    buffer: VkBuffer,
    offset: u64,
    drawCount: u32,
    stride: u32,
) callconv(.c) void;
// Queues: VK_QUEUE_COMPUTE_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: true
// Can be used without queues: false
pub const vkCmdDispatch = fn (
    commandBuffer: VkCommandBuffer,
    groupCountX: u32,
    groupCountY: u32,
    groupCountZ: u32,
) callconv(.c) void;
// Queues: VK_QUEUE_COMPUTE_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: true
// Can be used without queues: false
pub const vkCmdDispatchIndirect = fn (
    commandBuffer: VkCommandBuffer,
    buffer: VkBuffer,
    offset: u64,
) callconv(.c) void;
// Extension: VK_HUAWEI_subpass_shading
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: inside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSubpassShadingHUAWEI = fn (
    commandBuffer: VkCommandBuffer,
) callconv(.c) void;
// Extension: VK_HUAWEI_cluster_culling_shader
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: inside
// Command buffer levels: primary,secondary
// Conditional rendering: true
// Can be used without queues: false
pub const vkCmdDrawClusterHUAWEI = fn (
    commandBuffer: VkCommandBuffer,
    groupCountX: u32,
    groupCountY: u32,
    groupCountZ: u32,
) callconv(.c) void;
// Extension: VK_HUAWEI_cluster_culling_shader
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: inside
// Command buffer levels: primary,secondary
// Conditional rendering: true
// Can be used without queues: false
pub const vkCmdDrawClusterIndirectHUAWEI = fn (
    commandBuffer: VkCommandBuffer,
    buffer: VkBuffer,
    offset: u64,
) callconv(.c) void;
// Extension: VK_NV_device_generated_commands_compute
// Queues: VK_QUEUE_TRANSFER_BIT,VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdUpdatePipelineIndirectBufferNV = fn (
    commandBuffer: VkCommandBuffer,
    pipelineBindPoint: VkPipelineBindPoint,
    pipeline: VkPipeline,
) callconv(.c) void;
// Queues: VK_QUEUE_TRANSFER_BIT,VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdCopyBuffer = fn (
    commandBuffer: VkCommandBuffer,
    srcBuffer: VkBuffer,
    dstBuffer: VkBuffer,
    regionCount: u32,
    // len: regionCount
    pRegions: [*]const VkBufferCopy,
) callconv(.c) void;
// Queues: VK_QUEUE_TRANSFER_BIT,VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdCopyImage = fn (
    commandBuffer: VkCommandBuffer,
    srcImage: VkImage,
    srcImageLayout: VkImageLayout,
    dstImage: VkImage,
    dstImageLayout: VkImageLayout,
    regionCount: u32,
    // len: regionCount
    pRegions: [*]const VkImageCopy,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdBlitImage = fn (
    commandBuffer: VkCommandBuffer,
    srcImage: VkImage,
    srcImageLayout: VkImageLayout,
    dstImage: VkImage,
    dstImageLayout: VkImageLayout,
    regionCount: u32,
    // len: regionCount
    pRegions: [*]const VkImageBlit,
    filter: VkFilter,
) callconv(.c) void;
// Queues: VK_QUEUE_TRANSFER_BIT,VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdCopyBufferToImage = fn (
    commandBuffer: VkCommandBuffer,
    srcBuffer: VkBuffer,
    dstImage: VkImage,
    dstImageLayout: VkImageLayout,
    regionCount: u32,
    // len: regionCount
    pRegions: [*]const VkBufferImageCopy,
) callconv(.c) void;
// Queues: VK_QUEUE_TRANSFER_BIT,VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdCopyImageToBuffer = fn (
    commandBuffer: VkCommandBuffer,
    srcImage: VkImage,
    srcImageLayout: VkImageLayout,
    dstBuffer: VkBuffer,
    regionCount: u32,
    // len: regionCount
    pRegions: [*]const VkBufferImageCopy,
) callconv(.c) void;
// Extension: VK_NV_copy_memory_indirect
// Queues: VK_QUEUE_TRANSFER_BIT,VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdCopyMemoryIndirectNV = fn (
    commandBuffer: VkCommandBuffer,
    copyBufferAddress: u64,
    copyCount: u32,
    stride: u32,
) callconv(.c) void;
// Extension: VK_KHR_copy_memory_indirect
// Queues: VK_QUEUE_TRANSFER_BIT,VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdCopyMemoryIndirectKHR = fn (
    commandBuffer: VkCommandBuffer,
    pCopyMemoryIndirectInfo: *const VkCopyMemoryIndirectInfoKHR,
) callconv(.c) void;
// Extension: VK_NV_copy_memory_indirect
// Queues: VK_QUEUE_TRANSFER_BIT,VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdCopyMemoryToImageIndirectNV = fn (
    commandBuffer: VkCommandBuffer,
    copyBufferAddress: u64,
    copyCount: u32,
    stride: u32,
    dstImage: VkImage,
    dstImageLayout: VkImageLayout,
    // len: copyCount
    pImageSubresources: [*]const VkImageSubresourceLayers,
) callconv(.c) void;
// Extension: VK_KHR_copy_memory_indirect
// Queues: VK_QUEUE_TRANSFER_BIT,VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdCopyMemoryToImageIndirectKHR = fn (
    commandBuffer: VkCommandBuffer,
    pCopyMemoryToImageIndirectInfo: *const VkCopyMemoryToImageIndirectInfoKHR,
) callconv(.c) void;
// Queues: VK_QUEUE_TRANSFER_BIT,VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdUpdateBuffer = fn (
    commandBuffer: VkCommandBuffer,
    dstBuffer: VkBuffer,
    dstOffset: u64,
    dataSize: u64,
    // len: dataSize
    pData: [*]const anyopaque,
) callconv(.c) void;
// Queues: VK_QUEUE_TRANSFER_BIT,VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
// Comment: transfer support is only available when VK_KHR_maintenance1 is enabled, as documented in valid usage language in the specification
pub const vkCmdFillBuffer = fn (
    commandBuffer: VkCommandBuffer,
    dstBuffer: VkBuffer,
    dstOffset: u64,
    size: u64,
    data: u32,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdClearColorImage = fn (
    commandBuffer: VkCommandBuffer,
    image: VkImage,
    imageLayout: VkImageLayout,
    pColor: *const VkClearColorValue,
    rangeCount: u32,
    // len: rangeCount
    pRanges: [*]const VkImageSubresourceRange,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdClearDepthStencilImage = fn (
    commandBuffer: VkCommandBuffer,
    image: VkImage,
    imageLayout: VkImageLayout,
    pDepthStencil: *const VkClearDepthStencilValue,
    rangeCount: u32,
    // len: rangeCount
    pRanges: [*]const VkImageSubresourceRange,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: inside
// Command buffer levels: primary,secondary
// Conditional rendering: true
// Can be used without queues: false
pub const vkCmdClearAttachments = fn (
    commandBuffer: VkCommandBuffer,
    attachmentCount: u32,
    // len: attachmentCount
    pAttachments: [*]const VkClearAttachment,
    rectCount: u32,
    // len: rectCount
    pRects: [*]const VkClearRect,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdResolveImage = fn (
    commandBuffer: VkCommandBuffer,
    srcImage: VkImage,
    srcImageLayout: VkImageLayout,
    dstImage: VkImage,
    dstImageLayout: VkImageLayout,
    regionCount: u32,
    // len: regionCount
    pRegions: [*]const VkImageResolve,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT,VK_QUEUE_VIDEO_DECODE_BIT_KHR,VK_QUEUE_VIDEO_ENCODE_BIT_KHR
// Render pass: outside
// Video conding: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetEvent = fn (
    commandBuffer: VkCommandBuffer,
    event: VkEvent,
    stageMask: ?VkPipelineStageFlags,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT,VK_QUEUE_VIDEO_DECODE_BIT_KHR,VK_QUEUE_VIDEO_ENCODE_BIT_KHR
// Render pass: outside
// Video conding: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdResetEvent = fn (
    commandBuffer: VkCommandBuffer,
    event: VkEvent,
    stageMask: ?VkPipelineStageFlags,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT,VK_QUEUE_VIDEO_DECODE_BIT_KHR,VK_QUEUE_VIDEO_ENCODE_BIT_KHR
// Render pass: both
// Video conding: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdWaitEvents = fn (
    commandBuffer: VkCommandBuffer,
    eventCount: u32,
    // len: eventCount
    pEvents: [*]const VkEvent,
    srcStageMask: ?VkPipelineStageFlags,
    dstStageMask: ?VkPipelineStageFlags,
    memoryBarrierCount: ?u32,
    // len: memoryBarrierCount
    pMemoryBarriers: [*]const VkMemoryBarrier,
    bufferMemoryBarrierCount: ?u32,
    // len: bufferMemoryBarrierCount
    pBufferMemoryBarriers: [*]const VkBufferMemoryBarrier,
    imageMemoryBarrierCount: ?u32,
    // len: imageMemoryBarrierCount
    pImageMemoryBarriers: [*]const VkImageMemoryBarrier,
) callconv(.c) void;
// Queues: VK_QUEUE_TRANSFER_BIT,VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT,VK_QUEUE_VIDEO_DECODE_BIT_KHR,VK_QUEUE_VIDEO_ENCODE_BIT_KHR
// Render pass: both
// Video conding: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdPipelineBarrier = fn (
    commandBuffer: VkCommandBuffer,
    srcStageMask: ?VkPipelineStageFlags,
    dstStageMask: ?VkPipelineStageFlags,
    dependencyFlags: ?VkDependencyFlags,
    memoryBarrierCount: ?u32,
    // len: memoryBarrierCount
    pMemoryBarriers: [*]const VkMemoryBarrier,
    bufferMemoryBarrierCount: ?u32,
    // len: bufferMemoryBarrierCount
    pBufferMemoryBarriers: [*]const VkBufferMemoryBarrier,
    imageMemoryBarrierCount: ?u32,
    // len: imageMemoryBarrierCount
    pImageMemoryBarriers: [*]const VkImageMemoryBarrier,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT,VK_QUEUE_VIDEO_DECODE_BIT_KHR,VK_QUEUE_VIDEO_ENCODE_BIT_KHR
// Render pass: both
// Video conding: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdBeginQuery = fn (
    commandBuffer: VkCommandBuffer,
    queryPool: VkQueryPool,
    query: u32,
    flags: ?VkQueryControlFlags,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT,VK_QUEUE_VIDEO_DECODE_BIT_KHR,VK_QUEUE_VIDEO_ENCODE_BIT_KHR
// Render pass: both
// Video conding: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdEndQuery = fn (
    commandBuffer: VkCommandBuffer,
    queryPool: VkQueryPool,
    query: u32,
) callconv(.c) void;
// Extension: VK_EXT_conditional_rendering
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdBeginConditionalRenderingEXT = fn (
    commandBuffer: VkCommandBuffer,
    pConditionalRenderingBegin: *const VkConditionalRenderingBeginInfoEXT,
) callconv(.c) void;
// Extension: VK_EXT_conditional_rendering
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdEndConditionalRenderingEXT = fn (
    commandBuffer: VkCommandBuffer,
) callconv(.c) void;
// Extension: VK_EXT_custom_resolve
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: inside
// Command buffer levels: primary,secondary
// Conditional rendering: true
// Can be used without queues: false
pub const vkCmdBeginCustomResolveEXT = fn (
    commandBuffer: VkCommandBuffer,
    pBeginCustomResolveInfo: ?*const VkBeginCustomResolveInfoEXT,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT,VK_QUEUE_VIDEO_DECODE_BIT_KHR,VK_QUEUE_VIDEO_ENCODE_BIT_KHR,VK_QUEUE_OPTICAL_FLOW_BIT_NV
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdResetQueryPool = fn (
    commandBuffer: VkCommandBuffer,
    queryPool: VkQueryPool,
    firstQuery: u32,
    queryCount: u32,
) callconv(.c) void;
// Queues: VK_QUEUE_TRANSFER_BIT,VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT,VK_QUEUE_VIDEO_DECODE_BIT_KHR,VK_QUEUE_VIDEO_ENCODE_BIT_KHR,VK_QUEUE_OPTICAL_FLOW_BIT_NV
// Render pass: both
// Video conding: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdWriteTimestamp = fn (
    commandBuffer: VkCommandBuffer,
    pipelineStage: VkPipelineStageFlags,
    queryPool: VkQueryPool,
    query: u32,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdCopyQueryPoolResults = fn (
    commandBuffer: VkCommandBuffer,
    queryPool: VkQueryPool,
    firstQuery: u32,
    queryCount: u32,
    dstBuffer: VkBuffer,
    dstOffset: u64,
    stride: u64,
    flags: ?VkQueryResultFlags,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdPushConstants = fn (
    commandBuffer: VkCommandBuffer,
    layout: VkPipelineLayout,
    stageFlags: VkShaderStageFlags,
    offset: u32,
    size: u32,
    // len: size
    pValues: [*]const anyopaque,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: outside
// Command buffer levels: primary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdBeginRenderPass = fn (
    commandBuffer: VkCommandBuffer,
    pRenderPassBegin: *const VkRenderPassBeginInfo,
    contents: VkSubpassContents,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: inside
// Command buffer levels: primary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdNextSubpass = fn (
    commandBuffer: VkCommandBuffer,
    contents: VkSubpassContents,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: inside
// Command buffer levels: primary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdEndRenderPass = fn (
    commandBuffer: VkCommandBuffer,
) callconv(.c) void;
// Queues: VK_QUEUE_TRANSFER_BIT,VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdExecuteCommands = fn (
    commandBuffer: VkCommandBuffer,
    commandBufferCount: u32,
    // len: commandBufferCount
    pCommandBuffers: [*]const VkCommandBuffer,
) callconv(.c) void;
// Extension: VK_KHR_android_surface
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_NATIVE_WINDOW_IN_USE_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateAndroidSurfaceKHR = fn (
    instance: VkInstance,
    pCreateInfo: *const VkAndroidSurfaceCreateInfoKHR,
    pAllocator: ?*const VkAllocationCallbacks,
    pSurface: *VkSurfaceKHR,
) callconv(.c) VkResult;
// Extension: VK_OHOS_surface
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateSurfaceOHOS = fn (
    instance: VkInstance,
    pCreateInfo: *const VkSurfaceCreateInfoOHOS,
    pAllocator: ?*const VkAllocationCallbacks,
    pSurface: *VkSurfaceKHR,
) callconv(.c) VkResult;
// Extension: VK_KHR_display
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetPhysicalDeviceDisplayPropertiesKHR = fn (
    physicalDevice: VkPhysicalDevice,
    pPropertyCount: *u32,
    // len: pPropertyCount
    pProperties: ?[*]VkDisplayPropertiesKHR,
) callconv(.c) VkResult;
// Extension: VK_KHR_display
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetPhysicalDeviceDisplayPlanePropertiesKHR = fn (
    physicalDevice: VkPhysicalDevice,
    pPropertyCount: *u32,
    // len: pPropertyCount
    pProperties: ?[*]VkDisplayPlanePropertiesKHR,
) callconv(.c) VkResult;
// Extension: VK_KHR_display
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetDisplayPlaneSupportedDisplaysKHR = fn (
    physicalDevice: VkPhysicalDevice,
    planeIndex: u32,
    pDisplayCount: *u32,
    // len: pDisplayCount
    pDisplays: ?[*]VkDisplayKHR,
) callconv(.c) VkResult;
// Extension: VK_KHR_display
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetDisplayModePropertiesKHR = fn (
    physicalDevice: VkPhysicalDevice,
    display: VkDisplayKHR,
    pPropertyCount: *u32,
    // len: pPropertyCount
    pProperties: ?[*]VkDisplayModePropertiesKHR,
) callconv(.c) VkResult;
// Extension: VK_KHR_display
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateDisplayModeKHR = fn (
    physicalDevice: VkPhysicalDevice,
    display: VkDisplayKHR,
    pCreateInfo: *const VkDisplayModeCreateInfoKHR,
    pAllocator: ?*const VkAllocationCallbacks,
    pMode: *VkDisplayModeKHR,
) callconv(.c) VkResult;
// Extension: VK_KHR_display
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetDisplayPlaneCapabilitiesKHR = fn (
    physicalDevice: VkPhysicalDevice,
    mode: VkDisplayModeKHR,
    planeIndex: u32,
    pCapabilities: *VkDisplayPlaneCapabilitiesKHR,
) callconv(.c) VkResult;
// Extension: VK_KHR_display
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateDisplayPlaneSurfaceKHR = fn (
    instance: VkInstance,
    pCreateInfo: *const VkDisplaySurfaceCreateInfoKHR,
    pAllocator: ?*const VkAllocationCallbacks,
    pSurface: *VkSurfaceKHR,
) callconv(.c) VkResult;
// Extension: VK_KHR_display_swapchain
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INCOMPATIBLE_DISPLAY_KHR,VK_ERROR_DEVICE_LOST,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateSharedSwapchainsKHR = fn (
    device: VkDevice,
    swapchainCount: u32,
    // len: swapchainCount
    pCreateInfos: [*]const VkSwapchainCreateInfoKHR,
    // len: swapchainCount
    pCreateInfos: [*]const VkSwapchainCreateInfoKHR,
    pAllocator: ?*const VkAllocationCallbacks,
    // len: swapchainCount
    pSwapchains: [*]VkSwapchainKHR,
) callconv(.c) VkResult;
// Extension: VK_KHR_surface
// Can be used without queues: false
pub const vkDestroySurfaceKHR = fn (
    instance: VkInstance,
    surface: ?VkSurfaceKHR,
    pAllocator: ?*const VkAllocationCallbacks,
) callconv(.c) void;
// Extension: VK_KHR_surface
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetPhysicalDeviceSurfaceSupportKHR = fn (
    physicalDevice: VkPhysicalDevice,
    queueFamilyIndex: u32,
    surface: VkSurfaceKHR,
    pSupported: *u32,
) callconv(.c) VkResult;
// Extension: VK_KHR_surface
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetPhysicalDeviceSurfaceCapabilitiesKHR = fn (
    physicalDevice: VkPhysicalDevice,
    surface: VkSurfaceKHR,
    pSurfaceCapabilities: *VkSurfaceCapabilitiesKHR,
) callconv(.c) VkResult;
// Extension: VK_KHR_surface
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetPhysicalDeviceSurfaceFormatsKHR = fn (
    physicalDevice: VkPhysicalDevice,
    surface: ?VkSurfaceKHR,
    pSurfaceFormatCount: *u32,
    // len: pSurfaceFormatCount
    pSurfaceFormats: ?[*]VkSurfaceFormatKHR,
) callconv(.c) VkResult;
// Extension: VK_KHR_surface
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetPhysicalDeviceSurfacePresentModesKHR = fn (
    physicalDevice: VkPhysicalDevice,
    surface: ?VkSurfaceKHR,
    pPresentModeCount: *u32,
    // len: pPresentModeCount
    pPresentModes: ?[*]VkPresentModeKHR,
) callconv(.c) VkResult;
// Extension: VK_KHR_swapchain
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_NATIVE_WINDOW_IN_USE_KHR,VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_COMPRESSION_EXHAUSTED_EXT,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateSwapchainKHR = fn (
    device: VkDevice,
    pCreateInfo: *const VkSwapchainCreateInfoKHR,
    pCreateInfo: *const VkSwapchainCreateInfoKHR,
    pAllocator: ?*const VkAllocationCallbacks,
    pSwapchain: *VkSwapchainKHR,
) callconv(.c) VkResult;
// Extension: VK_KHR_swapchain
// Can be used without queues: false
pub const vkDestroySwapchainKHR = fn (
    device: VkDevice,
    swapchain: ?VkSwapchainKHR,
    pAllocator: ?*const VkAllocationCallbacks,
) callconv(.c) void;
// Extension: VK_KHR_swapchain
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetSwapchainImagesKHR = fn (
    device: VkDevice,
    swapchain: VkSwapchainKHR,
    pSwapchainImageCount: *u32,
    // len: pSwapchainImageCount
    pSwapchainImages: ?[*]VkImage,
) callconv(.c) VkResult;
// Extension: VK_KHR_swapchain
// Success codes: VK_SUCCESS,VK_TIMEOUT,VK_NOT_READY,VK_SUBOPTIMAL_KHR
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_OUT_OF_DATE_KHR,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkAcquireNextImageKHR = fn (
    device: VkDevice,
    swapchain: VkSwapchainKHR,
    timeout: u64,
    semaphore: ?VkSemaphore,
    fence: ?VkFence,
    pImageIndex: *u32,
) callconv(.c) VkResult;
// Extension: VK_KHR_swapchain
// Success codes: VK_SUCCESS,VK_SUBOPTIMAL_KHR
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_OUT_OF_DATE_KHR,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED,VK_ERROR_PRESENT_TIMING_QUEUE_FULL_EXT
// Can be used without queues: false
pub const vkQueuePresentKHR = fn (
    queue: VkQueue,
    pPresentInfo: *const VkPresentInfoKHR,
) callconv(.c) VkResult;
// Extension: VK_NN_vi_surface
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_NATIVE_WINDOW_IN_USE_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateViSurfaceNN = fn (
    instance: VkInstance,
    pCreateInfo: *const VkViSurfaceCreateInfoNN,
    pAllocator: ?*const VkAllocationCallbacks,
    pSurface: *VkSurfaceKHR,
) callconv(.c) VkResult;
// Extension: VK_KHR_wayland_surface
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateWaylandSurfaceKHR = fn (
    instance: VkInstance,
    pCreateInfo: *const VkWaylandSurfaceCreateInfoKHR,
    pAllocator: ?*const VkAllocationCallbacks,
    pSurface: *VkSurfaceKHR,
) callconv(.c) VkResult;
// Extension: VK_KHR_wayland_surface
// Can be used without queues: false
pub const vkGetPhysicalDeviceWaylandPresentationSupportKHR = fn (
    physicalDevice: VkPhysicalDevice,
    queueFamilyIndex: u32,
    display: *wl_display,
) callconv(.c) u32;
// Extension: VK_KHR_win32_surface
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateWin32SurfaceKHR = fn (
    instance: VkInstance,
    pCreateInfo: *const VkWin32SurfaceCreateInfoKHR,
    pAllocator: ?*const VkAllocationCallbacks,
    pSurface: *VkSurfaceKHR,
) callconv(.c) VkResult;
// Extension: VK_KHR_win32_surface
// Can be used without queues: false
pub const vkGetPhysicalDeviceWin32PresentationSupportKHR = fn (
    physicalDevice: VkPhysicalDevice,
    queueFamilyIndex: u32,
) callconv(.c) u32;
// Extension: VK_KHR_xlib_surface
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateXlibSurfaceKHR = fn (
    instance: VkInstance,
    pCreateInfo: *const VkXlibSurfaceCreateInfoKHR,
    pAllocator: ?*const VkAllocationCallbacks,
    pSurface: *VkSurfaceKHR,
) callconv(.c) VkResult;
// Extension: VK_KHR_xlib_surface
// Can be used without queues: false
pub const vkGetPhysicalDeviceXlibPresentationSupportKHR = fn (
    physicalDevice: VkPhysicalDevice,
    queueFamilyIndex: u32,
    dpy: *Display,
    visualID: VisualID,
) callconv(.c) u32;
// Extension: VK_KHR_xcb_surface
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateXcbSurfaceKHR = fn (
    instance: VkInstance,
    pCreateInfo: *const VkXcbSurfaceCreateInfoKHR,
    pAllocator: ?*const VkAllocationCallbacks,
    pSurface: *VkSurfaceKHR,
) callconv(.c) VkResult;
// Extension: VK_KHR_xcb_surface
// Can be used without queues: false
pub const vkGetPhysicalDeviceXcbPresentationSupportKHR = fn (
    physicalDevice: VkPhysicalDevice,
    queueFamilyIndex: u32,
    connection: *xcb_connection_t,
    visual_id: xcb_visualid_t,
) callconv(.c) u32;
// Extension: VK_EXT_directfb_surface
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateDirectFBSurfaceEXT = fn (
    instance: VkInstance,
    pCreateInfo: *const VkDirectFBSurfaceCreateInfoEXT,
    pAllocator: ?*const VkAllocationCallbacks,
    pSurface: *VkSurfaceKHR,
) callconv(.c) VkResult;
// Extension: VK_EXT_directfb_surface
// Can be used without queues: false
pub const vkGetPhysicalDeviceDirectFBPresentationSupportEXT = fn (
    physicalDevice: VkPhysicalDevice,
    queueFamilyIndex: u32,
    dfb: *IDirectFB,
) callconv(.c) u32;
// Extension: VK_FUCHSIA_imagepipe_surface
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateImagePipeSurfaceFUCHSIA = fn (
    instance: VkInstance,
    pCreateInfo: *const VkImagePipeSurfaceCreateInfoFUCHSIA,
    pAllocator: ?*const VkAllocationCallbacks,
    pSurface: *VkSurfaceKHR,
) callconv(.c) VkResult;
// Extension: VK_GGP_stream_descriptor_surface
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_NATIVE_WINDOW_IN_USE_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateStreamDescriptorSurfaceGGP = fn (
    instance: VkInstance,
    pCreateInfo: *const VkStreamDescriptorSurfaceCreateInfoGGP,
    pAllocator: ?*const VkAllocationCallbacks,
    pSurface: *VkSurfaceKHR,
) callconv(.c) VkResult;
// Extension: VK_QNX_screen_surface
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateScreenSurfaceQNX = fn (
    instance: VkInstance,
    pCreateInfo: *const VkScreenSurfaceCreateInfoQNX,
    pAllocator: ?*const VkAllocationCallbacks,
    pSurface: *VkSurfaceKHR,
) callconv(.c) VkResult;
// Extension: VK_QNX_screen_surface
// Can be used without queues: false
pub const vkGetPhysicalDeviceScreenPresentationSupportQNX = fn (
    physicalDevice: VkPhysicalDevice,
    queueFamilyIndex: u32,
    window: *_screen_window,
) callconv(.c) u32;
// Extension: VK_EXT_debug_report
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateDebugReportCallbackEXT = fn (
    instance: VkInstance,
    pCreateInfo: *const VkDebugReportCallbackCreateInfoEXT,
    pAllocator: ?*const VkAllocationCallbacks,
    pCallback: *VkDebugReportCallbackEXT,
) callconv(.c) VkResult;
// Extension: VK_EXT_debug_report
// Can be used without queues: false
pub const vkDestroyDebugReportCallbackEXT = fn (
    instance: VkInstance,
    callback: ?VkDebugReportCallbackEXT,
    pAllocator: ?*const VkAllocationCallbacks,
) callconv(.c) void;
// Extension: VK_EXT_debug_report
// Can be used without queues: false
pub const vkDebugReportMessageEXT = fn (
    instance: VkInstance,
    flags: VkDebugReportFlagsEXT,
    objectType: VkDebugReportObjectTypeEXT,
    object: u64,
    location: u64,
    messageCode: i32,
    // len: null-terminated
    pLayerPrefix: [*:0]const u8,
    // len: null-terminated
    pMessage: [*:0]const u8,
) callconv(.c) void;
// Extension: VK_EXT_debug_marker
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkDebugMarkerSetObjectNameEXT = fn (
    device: VkDevice,
    pNameInfo: *const VkDebugMarkerObjectNameInfoEXT,
) callconv(.c) VkResult;
// Extension: VK_EXT_debug_marker
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkDebugMarkerSetObjectTagEXT = fn (
    device: VkDevice,
    pTagInfo: *const VkDebugMarkerObjectTagInfoEXT,
) callconv(.c) VkResult;
// Extension: VK_EXT_debug_marker
// Queues: VK_QUEUE_TRANSFER_BIT,VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT,VK_QUEUE_VIDEO_DECODE_BIT_KHR,VK_QUEUE_VIDEO_ENCODE_BIT_KHR,VK_QUEUE_OPTICAL_FLOW_BIT_NV
// Render pass: both
// Video conding: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdDebugMarkerBeginEXT = fn (
    commandBuffer: VkCommandBuffer,
    pMarkerInfo: *const VkDebugMarkerMarkerInfoEXT,
) callconv(.c) void;
// Extension: VK_EXT_debug_marker
// Queues: VK_QUEUE_TRANSFER_BIT,VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT,VK_QUEUE_VIDEO_DECODE_BIT_KHR,VK_QUEUE_VIDEO_ENCODE_BIT_KHR,VK_QUEUE_OPTICAL_FLOW_BIT_NV
// Render pass: both
// Video conding: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdDebugMarkerEndEXT = fn (
    commandBuffer: VkCommandBuffer,
) callconv(.c) void;
// Extension: VK_EXT_debug_marker
// Queues: VK_QUEUE_TRANSFER_BIT,VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT,VK_QUEUE_VIDEO_DECODE_BIT_KHR,VK_QUEUE_VIDEO_ENCODE_BIT_KHR,VK_QUEUE_OPTICAL_FLOW_BIT_NV
// Render pass: both
// Video conding: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdDebugMarkerInsertEXT = fn (
    commandBuffer: VkCommandBuffer,
    pMarkerInfo: *const VkDebugMarkerMarkerInfoEXT,
) callconv(.c) void;
// Extension: VK_NV_external_memory_capabilities
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_FORMAT_NOT_SUPPORTED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetPhysicalDeviceExternalImageFormatPropertiesNV = fn (
    physicalDevice: VkPhysicalDevice,
    format: VkFormat,
    type: VkImageType,
    tiling: VkImageTiling,
    usage: VkImageUsageFlags,
    flags: ?VkImageCreateFlags,
    externalHandleType: ?VkExternalMemoryHandleTypeFlagsNV,
    pExternalImageFormatProperties: *VkExternalImageFormatPropertiesNV,
) callconv(.c) VkResult;
// Extension: VK_NV_external_memory_win32
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetMemoryWin32HandleNV = fn (
    device: VkDevice,
    memory: VkDeviceMemory,
    handleType: VkExternalMemoryHandleTypeFlagsNV,
    pHandle: *HANDLE,
) callconv(.c) VkResult;
// Extension: VK_NV_device_generated_commands
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT
// Render pass: inside
// Command buffer levels: primary,secondary
// Conditional rendering: true
// Can be used without queues: false
pub const vkCmdExecuteGeneratedCommandsNV = fn (
    commandBuffer: VkCommandBuffer,
    isPreprocessed: u32,
    pGeneratedCommandsInfo: *const VkGeneratedCommandsInfoNV,
) callconv(.c) void;
// Extension: VK_NV_device_generated_commands
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdPreprocessGeneratedCommandsNV = fn (
    commandBuffer: VkCommandBuffer,
    pGeneratedCommandsInfo: *const VkGeneratedCommandsInfoNV,
) callconv(.c) void;
// Extension: VK_NV_device_generated_commands
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdBindPipelineShaderGroupNV = fn (
    commandBuffer: VkCommandBuffer,
    pipelineBindPoint: VkPipelineBindPoint,
    pipeline: VkPipeline,
    groupIndex: u32,
) callconv(.c) void;
// Extension: VK_NV_device_generated_commands
// Can be used without queues: false
pub const vkGetGeneratedCommandsMemoryRequirementsNV = fn (
    device: VkDevice,
    pInfo: *const VkGeneratedCommandsMemoryRequirementsInfoNV,
    pMemoryRequirements: *VkMemoryRequirements2,
) callconv(.c) void;
// Extension: VK_NV_device_generated_commands
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateIndirectCommandsLayoutNV = fn (
    device: VkDevice,
    pCreateInfo: *const VkIndirectCommandsLayoutCreateInfoNV,
    pAllocator: ?*const VkAllocationCallbacks,
    pIndirectCommandsLayout: *VkIndirectCommandsLayoutNV,
) callconv(.c) VkResult;
// Extension: VK_NV_device_generated_commands
// Can be used without queues: false
pub const vkDestroyIndirectCommandsLayoutNV = fn (
    device: VkDevice,
    indirectCommandsLayout: ?VkIndirectCommandsLayoutNV,
    pAllocator: ?*const VkAllocationCallbacks,
) callconv(.c) void;
// Extension: VK_EXT_device_generated_commands
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT
// Render pass: both
// Command buffer levels: primary
// Conditional rendering: true
// Can be used without queues: false
pub const vkCmdExecuteGeneratedCommandsEXT = fn (
    commandBuffer: VkCommandBuffer,
    isPreprocessed: u32,
    pGeneratedCommandsInfo: *const VkGeneratedCommandsInfoEXT,
) callconv(.c) void;
// Extension: VK_EXT_device_generated_commands
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT
// Render pass: outside
// Command buffer levels: primary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdPreprocessGeneratedCommandsEXT = fn (
    commandBuffer: VkCommandBuffer,
    pGeneratedCommandsInfo: *const VkGeneratedCommandsInfoEXT,
    stateCommandBuffer: VkCommandBuffer,
) callconv(.c) void;
// Extension: VK_EXT_device_generated_commands
// Can be used without queues: false
pub const vkGetGeneratedCommandsMemoryRequirementsEXT = fn (
    device: VkDevice,
    pInfo: *const VkGeneratedCommandsMemoryRequirementsInfoEXT,
    pMemoryRequirements: *VkMemoryRequirements2,
) callconv(.c) void;
// Extension: VK_EXT_device_generated_commands
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateIndirectCommandsLayoutEXT = fn (
    device: VkDevice,
    pCreateInfo: *const VkIndirectCommandsLayoutCreateInfoEXT,
    pAllocator: ?*const VkAllocationCallbacks,
    pIndirectCommandsLayout: *VkIndirectCommandsLayoutEXT,
) callconv(.c) VkResult;
// Extension: VK_EXT_device_generated_commands
// Can be used without queues: false
pub const vkDestroyIndirectCommandsLayoutEXT = fn (
    device: VkDevice,
    indirectCommandsLayout: ?VkIndirectCommandsLayoutEXT,
    pAllocator: ?*const VkAllocationCallbacks,
) callconv(.c) void;
// Extension: VK_EXT_device_generated_commands
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateIndirectExecutionSetEXT = fn (
    device: VkDevice,
    pCreateInfo: *const VkIndirectExecutionSetCreateInfoEXT,
    pAllocator: ?*const VkAllocationCallbacks,
    pIndirectExecutionSet: *VkIndirectExecutionSetEXT,
) callconv(.c) VkResult;
// Extension: VK_EXT_device_generated_commands
// Can be used without queues: false
pub const vkDestroyIndirectExecutionSetEXT = fn (
    device: VkDevice,
    indirectExecutionSet: ?VkIndirectExecutionSetEXT,
    pAllocator: ?*const VkAllocationCallbacks,
) callconv(.c) void;
// Extension: VK_EXT_device_generated_commands
// Can be used without queues: false
pub const vkUpdateIndirectExecutionSetPipelineEXT = fn (
    device: VkDevice,
    indirectExecutionSet: VkIndirectExecutionSetEXT,
    executionSetWriteCount: u32,
    // len: executionSetWriteCount
    pExecutionSetWrites: [*]const VkWriteIndirectExecutionSetPipelineEXT,
) callconv(.c) void;
// Extension: VK_EXT_device_generated_commands
// Can be used without queues: false
pub const vkUpdateIndirectExecutionSetShaderEXT = fn (
    device: VkDevice,
    indirectExecutionSet: VkIndirectExecutionSetEXT,
    executionSetWriteCount: u32,
    // len: executionSetWriteCount
    pExecutionSetWrites: [*]const VkWriteIndirectExecutionSetShaderEXT,
) callconv(.c) void;
// Can be used without queues: false
pub const vkGetPhysicalDeviceFeatures2 = fn (
    physicalDevice: VkPhysicalDevice,
    pFeatures: *VkPhysicalDeviceFeatures2,
) callconv(.c) void;
// Extension: VK_KHR_get_physical_device_properties2
pub const vkGetPhysicalDeviceFeatures2KHR = vkGetPhysicalDeviceFeatures2;
// Can be used without queues: false
pub const vkGetPhysicalDeviceProperties2 = fn (
    physicalDevice: VkPhysicalDevice,
    pProperties: *VkPhysicalDeviceProperties2,
) callconv(.c) void;
// Extension: VK_KHR_get_physical_device_properties2
pub const vkGetPhysicalDeviceProperties2KHR = vkGetPhysicalDeviceProperties2;
// Can be used without queues: false
pub const vkGetPhysicalDeviceFormatProperties2 = fn (
    physicalDevice: VkPhysicalDevice,
    format: VkFormat,
    pFormatProperties: *VkFormatProperties2,
) callconv(.c) void;
// Extension: VK_KHR_get_physical_device_properties2
pub const vkGetPhysicalDeviceFormatProperties2KHR = vkGetPhysicalDeviceFormatProperties2;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_FORMAT_NOT_SUPPORTED,VK_ERROR_IMAGE_USAGE_NOT_SUPPORTED_KHR,VK_ERROR_VIDEO_PROFILE_OPERATION_NOT_SUPPORTED_KHR,VK_ERROR_VIDEO_PROFILE_FORMAT_NOT_SUPPORTED_KHR,VK_ERROR_VIDEO_PICTURE_LAYOUT_NOT_SUPPORTED_KHR,VK_ERROR_VIDEO_PROFILE_CODEC_NOT_SUPPORTED_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetPhysicalDeviceImageFormatProperties2 = fn (
    physicalDevice: VkPhysicalDevice,
    pImageFormatInfo: *const VkPhysicalDeviceImageFormatInfo2,
    pImageFormatProperties: *VkImageFormatProperties2,
) callconv(.c) VkResult;
// Extension: VK_KHR_get_physical_device_properties2
pub const vkGetPhysicalDeviceImageFormatProperties2KHR = vkGetPhysicalDeviceImageFormatProperties2;
// Can be used without queues: false
pub const vkGetPhysicalDeviceQueueFamilyProperties2 = fn (
    physicalDevice: VkPhysicalDevice,
    pQueueFamilyPropertyCount: *u32,
    // len: pQueueFamilyPropertyCount
    pQueueFamilyProperties: ?[*]VkQueueFamilyProperties2,
) callconv(.c) void;
// Extension: VK_KHR_get_physical_device_properties2
pub const vkGetPhysicalDeviceQueueFamilyProperties2KHR = vkGetPhysicalDeviceQueueFamilyProperties2;
// Can be used without queues: false
pub const vkGetPhysicalDeviceMemoryProperties2 = fn (
    physicalDevice: VkPhysicalDevice,
    pMemoryProperties: *VkPhysicalDeviceMemoryProperties2,
) callconv(.c) void;
// Extension: VK_KHR_get_physical_device_properties2
pub const vkGetPhysicalDeviceMemoryProperties2KHR = vkGetPhysicalDeviceMemoryProperties2;
// Can be used without queues: false
pub const vkGetPhysicalDeviceSparseImageFormatProperties2 = fn (
    physicalDevice: VkPhysicalDevice,
    pFormatInfo: *const VkPhysicalDeviceSparseImageFormatInfo2,
    pPropertyCount: *u32,
    // len: pPropertyCount
    pProperties: ?[*]VkSparseImageFormatProperties2,
) callconv(.c) void;
// Extension: VK_KHR_get_physical_device_properties2
pub const vkGetPhysicalDeviceSparseImageFormatProperties2KHR = vkGetPhysicalDeviceSparseImageFormatProperties2;
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdPushDescriptorSet = fn (
    commandBuffer: VkCommandBuffer,
    pipelineBindPoint: VkPipelineBindPoint,
    layout: VkPipelineLayout,
    set: u32,
    descriptorWriteCount: u32,
    // len: descriptorWriteCount
    pDescriptorWrites: [*]const VkWriteDescriptorSet,
) callconv(.c) void;
// Extension: VK_KHR_push_descriptor
pub const vkCmdPushDescriptorSetKHR = vkCmdPushDescriptorSet;
// Can be used without queues: false
pub const vkTrimCommandPool = fn (
    device: VkDevice,
    commandPool: VkCommandPool,
    flags: ?VkCommandPoolTrimFlags,
) callconv(.c) void;
// Extension: VK_KHR_maintenance1
pub const vkTrimCommandPoolKHR = vkTrimCommandPool;
// Can be used without queues: false
pub const vkGetPhysicalDeviceExternalBufferProperties = fn (
    physicalDevice: VkPhysicalDevice,
    pExternalBufferInfo: *const VkPhysicalDeviceExternalBufferInfo,
    pExternalBufferProperties: *VkExternalBufferProperties,
) callconv(.c) void;
// Extension: VK_KHR_external_memory_capabilities
pub const vkGetPhysicalDeviceExternalBufferPropertiesKHR = vkGetPhysicalDeviceExternalBufferProperties;
// Extension: VK_KHR_external_memory_win32
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetMemoryWin32HandleKHR = fn (
    device: VkDevice,
    pGetWin32HandleInfo: *const VkMemoryGetWin32HandleInfoKHR,
    pHandle: *HANDLE,
) callconv(.c) VkResult;
// Extension: VK_KHR_external_memory_win32
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_INVALID_EXTERNAL_HANDLE,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetMemoryWin32HandlePropertiesKHR = fn (
    device: VkDevice,
    handleType: VkExternalMemoryHandleTypeFlags,
    handle: HANDLE,
    pMemoryWin32HandleProperties: *VkMemoryWin32HandlePropertiesKHR,
) callconv(.c) VkResult;
// Extension: VK_KHR_external_memory_fd
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetMemoryFdKHR = fn (
    device: VkDevice,
    pGetFdInfo: *const VkMemoryGetFdInfoKHR,
    pFd: *int,
) callconv(.c) VkResult;
// Extension: VK_KHR_external_memory_fd
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_INVALID_EXTERNAL_HANDLE,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetMemoryFdPropertiesKHR = fn (
    device: VkDevice,
    handleType: VkExternalMemoryHandleTypeFlags,
    fd: int,
    pMemoryFdProperties: *VkMemoryFdPropertiesKHR,
) callconv(.c) VkResult;
// Extension: VK_FUCHSIA_external_memory
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetMemoryZirconHandleFUCHSIA = fn (
    device: VkDevice,
    pGetZirconHandleInfo: *const VkMemoryGetZirconHandleInfoFUCHSIA,
    pZirconHandle: *zx_handle_t,
) callconv(.c) VkResult;
// Extension: VK_FUCHSIA_external_memory
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_INVALID_EXTERNAL_HANDLE,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetMemoryZirconHandlePropertiesFUCHSIA = fn (
    device: VkDevice,
    handleType: VkExternalMemoryHandleTypeFlags,
    zirconHandle: zx_handle_t,
    pMemoryZirconHandleProperties: *VkMemoryZirconHandlePropertiesFUCHSIA,
) callconv(.c) VkResult;
// Extension: VK_NV_external_memory_rdma
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_INVALID_EXTERNAL_HANDLE,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetMemoryRemoteAddressNV = fn (
    device: VkDevice,
    pMemoryGetRemoteAddressInfo: *const VkMemoryGetRemoteAddressInfoNV,
    pAddress: **anyopaque,
) callconv(.c) VkResult;
// Extension: VK_NV_external_memory_sci_buf
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetMemorySciBufNV = fn (
    device: VkDevice,
    pGetSciBufInfo: *const VkMemoryGetSciBufInfoNV,
    pHandle: *NvSciBufObj,
) callconv(.c) VkResult;
// Extension: VK_NV_external_memory_sci_buf
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_INVALID_EXTERNAL_HANDLE,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetPhysicalDeviceExternalMemorySciBufPropertiesNV = fn (
    physicalDevice: VkPhysicalDevice,
    handleType: VkExternalMemoryHandleTypeFlags,
    handle: NvSciBufObj,
    pMemorySciBufProperties: *VkMemorySciBufPropertiesNV,
) callconv(.c) VkResult;
// Extension: VK_NV_external_memory_sci_buf
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetPhysicalDeviceSciBufAttributesNV = fn (
    physicalDevice: VkPhysicalDevice,
    pAttributes: NvSciBufAttrList,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkGetPhysicalDeviceExternalSemaphoreProperties = fn (
    physicalDevice: VkPhysicalDevice,
    pExternalSemaphoreInfo: *const VkPhysicalDeviceExternalSemaphoreInfo,
    pExternalSemaphoreProperties: *VkExternalSemaphoreProperties,
) callconv(.c) void;
// Extension: VK_KHR_external_semaphore_capabilities
pub const vkGetPhysicalDeviceExternalSemaphorePropertiesKHR = vkGetPhysicalDeviceExternalSemaphoreProperties;
// Extension: VK_KHR_external_semaphore_win32
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetSemaphoreWin32HandleKHR = fn (
    device: VkDevice,
    pGetWin32HandleInfo: *const VkSemaphoreGetWin32HandleInfoKHR,
    pHandle: *HANDLE,
) callconv(.c) VkResult;
// Extension: VK_KHR_external_semaphore_win32
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_INVALID_EXTERNAL_HANDLE,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkImportSemaphoreWin32HandleKHR = fn (
    device: VkDevice,
    pImportSemaphoreWin32HandleInfo: *const VkImportSemaphoreWin32HandleInfoKHR,
) callconv(.c) VkResult;
// Extension: VK_KHR_external_semaphore_fd
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetSemaphoreFdKHR = fn (
    device: VkDevice,
    pGetFdInfo: *const VkSemaphoreGetFdInfoKHR,
    pFd: *int,
) callconv(.c) VkResult;
// Extension: VK_KHR_external_semaphore_fd
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_INVALID_EXTERNAL_HANDLE,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkImportSemaphoreFdKHR = fn (
    device: VkDevice,
    pImportSemaphoreFdInfo: *const VkImportSemaphoreFdInfoKHR,
) callconv(.c) VkResult;
// Extension: VK_FUCHSIA_external_semaphore
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetSemaphoreZirconHandleFUCHSIA = fn (
    device: VkDevice,
    pGetZirconHandleInfo: *const VkSemaphoreGetZirconHandleInfoFUCHSIA,
    pZirconHandle: *zx_handle_t,
) callconv(.c) VkResult;
// Extension: VK_FUCHSIA_external_semaphore
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_INVALID_EXTERNAL_HANDLE,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkImportSemaphoreZirconHandleFUCHSIA = fn (
    device: VkDevice,
    pImportSemaphoreZirconHandleInfo: *const VkImportSemaphoreZirconHandleInfoFUCHSIA,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkGetPhysicalDeviceExternalFenceProperties = fn (
    physicalDevice: VkPhysicalDevice,
    pExternalFenceInfo: *const VkPhysicalDeviceExternalFenceInfo,
    pExternalFenceProperties: *VkExternalFenceProperties,
) callconv(.c) void;
// Extension: VK_KHR_external_fence_capabilities
pub const vkGetPhysicalDeviceExternalFencePropertiesKHR = vkGetPhysicalDeviceExternalFenceProperties;
// Extension: VK_KHR_external_fence_win32
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetFenceWin32HandleKHR = fn (
    device: VkDevice,
    pGetWin32HandleInfo: *const VkFenceGetWin32HandleInfoKHR,
    pHandle: *HANDLE,
) callconv(.c) VkResult;
// Extension: VK_KHR_external_fence_win32
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_INVALID_EXTERNAL_HANDLE,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkImportFenceWin32HandleKHR = fn (
    device: VkDevice,
    pImportFenceWin32HandleInfo: *const VkImportFenceWin32HandleInfoKHR,
) callconv(.c) VkResult;
// Extension: VK_KHR_external_fence_fd
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetFenceFdKHR = fn (
    device: VkDevice,
    pGetFdInfo: *const VkFenceGetFdInfoKHR,
    pFd: *int,
) callconv(.c) VkResult;
// Extension: VK_KHR_external_fence_fd
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_INVALID_EXTERNAL_HANDLE,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkImportFenceFdKHR = fn (
    device: VkDevice,
    pImportFenceFdInfo: *const VkImportFenceFdInfoKHR,
) callconv(.c) VkResult;
// Extension: VK_NV_external_sci_sync
// Extension: VK_NV_external_sci_sync2
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_INVALID_EXTERNAL_HANDLE,VK_ERROR_NOT_PERMITTED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetFenceSciSyncFenceNV = fn (
    device: VkDevice,
    pGetSciSyncHandleInfo: *const VkFenceGetSciSyncInfoNV,
    pHandle: *anyopaque,
) callconv(.c) VkResult;
// Extension: VK_NV_external_sci_sync
// Extension: VK_NV_external_sci_sync2
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_INVALID_EXTERNAL_HANDLE,VK_ERROR_NOT_PERMITTED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetFenceSciSyncObjNV = fn (
    device: VkDevice,
    pGetSciSyncHandleInfo: *const VkFenceGetSciSyncInfoNV,
    pHandle: *anyopaque,
) callconv(.c) VkResult;
// Extension: VK_NV_external_sci_sync
// Extension: VK_NV_external_sci_sync2
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_INVALID_EXTERNAL_HANDLE,VK_ERROR_NOT_PERMITTED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkImportFenceSciSyncFenceNV = fn (
    device: VkDevice,
    pImportFenceSciSyncInfo: *const VkImportFenceSciSyncInfoNV,
) callconv(.c) VkResult;
// Extension: VK_NV_external_sci_sync
// Extension: VK_NV_external_sci_sync2
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_INVALID_EXTERNAL_HANDLE,VK_ERROR_NOT_PERMITTED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkImportFenceSciSyncObjNV = fn (
    device: VkDevice,
    pImportFenceSciSyncInfo: *const VkImportFenceSciSyncInfoNV,
) callconv(.c) VkResult;
// Extension: VK_NV_external_sci_sync
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_INVALID_EXTERNAL_HANDLE,VK_ERROR_NOT_PERMITTED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetSemaphoreSciSyncObjNV = fn (
    device: VkDevice,
    pGetSciSyncInfo: *const VkSemaphoreGetSciSyncInfoNV,
    pHandle: *anyopaque,
) callconv(.c) VkResult;
// Extension: VK_NV_external_sci_sync
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_INVALID_EXTERNAL_HANDLE,VK_ERROR_NOT_PERMITTED,VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkImportSemaphoreSciSyncObjNV = fn (
    device: VkDevice,
    pImportSemaphoreSciSyncInfo: *const VkImportSemaphoreSciSyncInfoNV,
) callconv(.c) VkResult;
// Extension: VK_NV_external_sci_sync
// Extension: VK_NV_external_sci_sync2
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetPhysicalDeviceSciSyncAttributesNV = fn (
    physicalDevice: VkPhysicalDevice,
    pSciSyncAttributesInfo: *const VkSciSyncAttributesInfoNV,
    pAttributes: NvSciSyncAttrList,
) callconv(.c) VkResult;
// Extension: VK_NV_external_sci_sync2
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateSemaphoreSciSyncPoolNV = fn (
    device: VkDevice,
    pCreateInfo: *const VkSemaphoreSciSyncPoolCreateInfoNV,
    pAllocator: ?*const VkAllocationCallbacks,
    pSemaphorePool: *VkSemaphoreSciSyncPoolNV,
) callconv(.c) VkResult;
// Extension: VK_NV_external_sci_sync2
// Can be used without queues: false
pub const vkDestroySemaphoreSciSyncPoolNV = fn (
    device: VkDevice,
    semaphorePool: ?VkSemaphoreSciSyncPoolNV,
    pAllocator: ?*const VkAllocationCallbacks,
) callconv(.c) void;
// Extension: VK_EXT_direct_mode_display
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkReleaseDisplayEXT = fn (
    physicalDevice: VkPhysicalDevice,
    display: VkDisplayKHR,
) callconv(.c) VkResult;
// Extension: VK_EXT_acquire_xlib_display
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkAcquireXlibDisplayEXT = fn (
    physicalDevice: VkPhysicalDevice,
    dpy: *Display,
    display: VkDisplayKHR,
) callconv(.c) VkResult;
// Extension: VK_EXT_acquire_xlib_display
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetRandROutputDisplayEXT = fn (
    physicalDevice: VkPhysicalDevice,
    dpy: *Display,
    rrOutput: RROutput,
    pDisplay: *VkDisplayKHR,
) callconv(.c) VkResult;
// Extension: VK_NV_acquire_winrt_display
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkAcquireWinrtDisplayNV = fn (
    physicalDevice: VkPhysicalDevice,
    display: VkDisplayKHR,
) callconv(.c) VkResult;
// Extension: VK_NV_acquire_winrt_display
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetWinrtDisplayNV = fn (
    physicalDevice: VkPhysicalDevice,
    deviceRelativeId: u32,
    pDisplay: *VkDisplayKHR,
) callconv(.c) VkResult;
// Extension: VK_EXT_display_control
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkDisplayPowerControlEXT = fn (
    device: VkDevice,
    display: VkDisplayKHR,
    pDisplayPowerInfo: *const VkDisplayPowerInfoEXT,
) callconv(.c) VkResult;
// Extension: VK_EXT_display_control
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkRegisterDeviceEventEXT = fn (
    device: VkDevice,
    pDeviceEventInfo: *const VkDeviceEventInfoEXT,
    pAllocator: ?*const VkAllocationCallbacks,
    pFence: *VkFence,
) callconv(.c) VkResult;
// Extension: VK_EXT_display_control
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkRegisterDisplayEventEXT = fn (
    device: VkDevice,
    display: VkDisplayKHR,
    pDisplayEventInfo: *const VkDisplayEventInfoEXT,
    pAllocator: ?*const VkAllocationCallbacks,
    pFence: *VkFence,
) callconv(.c) VkResult;
// Extension: VK_EXT_display_control
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_OUT_OF_DATE_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetSwapchainCounterEXT = fn (
    device: VkDevice,
    swapchain: VkSwapchainKHR,
    counter: VkSurfaceCounterFlagsEXT,
    pCounterValue: *u64,
) callconv(.c) VkResult;
// Extension: VK_EXT_display_surface_counter
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetPhysicalDeviceSurfaceCapabilities2EXT = fn (
    physicalDevice: VkPhysicalDevice,
    surface: VkSurfaceKHR,
    pSurfaceCapabilities: *VkSurfaceCapabilities2EXT,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkEnumeratePhysicalDeviceGroups = fn (
    instance: VkInstance,
    pPhysicalDeviceGroupCount: *u32,
    // len: pPhysicalDeviceGroupCount
    pPhysicalDeviceGroupProperties: ?[*]VkPhysicalDeviceGroupProperties,
) callconv(.c) VkResult;
// Extension: VK_KHR_device_group_creation
pub const vkEnumeratePhysicalDeviceGroupsKHR = vkEnumeratePhysicalDeviceGroups;
// Can be used without queues: false
pub const vkGetDeviceGroupPeerMemoryFeatures = fn (
    device: VkDevice,
    heapIndex: u32,
    localDeviceIndex: u32,
    remoteDeviceIndex: u32,
    pPeerMemoryFeatures: *VkPeerMemoryFeatureFlags,
) callconv(.c) void;
// Extension: VK_KHR_device_group
pub const vkGetDeviceGroupPeerMemoryFeaturesKHR = vkGetDeviceGroupPeerMemoryFeatures;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkBindBufferMemory2 = fn (
    device: VkDevice,
    bindInfoCount: u32,
    // len: bindInfoCount
    pBindInfos: [*]const VkBindBufferMemoryInfo,
) callconv(.c) VkResult;
// Extension: VK_KHR_bind_memory2
pub const vkBindBufferMemory2KHR = vkBindBufferMemory2;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkBindImageMemory2 = fn (
    device: VkDevice,
    bindInfoCount: u32,
    // len: bindInfoCount
    pBindInfos: [*]const VkBindImageMemoryInfo,
) callconv(.c) VkResult;
// Extension: VK_KHR_bind_memory2
pub const vkBindImageMemory2KHR = vkBindImageMemory2;
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT,VK_QUEUE_TRANSFER_BIT
// Render pass: both
// Video conding: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetDeviceMask = fn (
    commandBuffer: VkCommandBuffer,
    deviceMask: u32,
) callconv(.c) void;
// Extension: VK_KHR_device_group
pub const vkCmdSetDeviceMaskKHR = vkCmdSetDeviceMask;
// Extension: VK_KHR_swapchain
// Extension: VK_KHR_device_group
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetDeviceGroupPresentCapabilitiesKHR = fn (
    device: VkDevice,
    pDeviceGroupPresentCapabilities: *VkDeviceGroupPresentCapabilitiesKHR,
) callconv(.c) VkResult;
// Extension: VK_KHR_swapchain
// Extension: VK_KHR_device_group
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetDeviceGroupSurfacePresentModesKHR = fn (
    device: VkDevice,
    surface: VkSurfaceKHR,
    pModes: *VkDeviceGroupPresentModeFlagsKHR,
) callconv(.c) VkResult;
// Extension: VK_KHR_swapchain
// Extension: VK_KHR_device_group
// Success codes: VK_SUCCESS,VK_TIMEOUT,VK_NOT_READY,VK_SUBOPTIMAL_KHR
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_OUT_OF_DATE_KHR,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkAcquireNextImage2KHR = fn (
    device: VkDevice,
    pAcquireInfo: *const VkAcquireNextImageInfoKHR,
    pImageIndex: *u32,
) callconv(.c) VkResult;
// Queues: VK_QUEUE_COMPUTE_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: true
// Can be used without queues: false
pub const vkCmdDispatchBase = fn (
    commandBuffer: VkCommandBuffer,
    baseGroupX: u32,
    baseGroupY: u32,
    baseGroupZ: u32,
    groupCountX: u32,
    groupCountY: u32,
    groupCountZ: u32,
) callconv(.c) void;
// Extension: VK_KHR_device_group
pub const vkCmdDispatchBaseKHR = vkCmdDispatchBase;
// Extension: VK_KHR_swapchain
// Extension: VK_KHR_device_group
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetPhysicalDevicePresentRectanglesKHR = fn (
    physicalDevice: VkPhysicalDevice,
    surface: VkSurfaceKHR,
    pRectCount: *u32,
    // len: pRectCount
    pRects: ?[*]VkRect2D,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateDescriptorUpdateTemplate = fn (
    device: VkDevice,
    pCreateInfo: *const VkDescriptorUpdateTemplateCreateInfo,
    pAllocator: ?*const VkAllocationCallbacks,
    pDescriptorUpdateTemplate: *VkDescriptorUpdateTemplate,
) callconv(.c) VkResult;
// Extension: VK_KHR_descriptor_update_template
pub const vkCreateDescriptorUpdateTemplateKHR = vkCreateDescriptorUpdateTemplate;
// Can be used without queues: false
pub const vkDestroyDescriptorUpdateTemplate = fn (
    device: VkDevice,
    descriptorUpdateTemplate: ?VkDescriptorUpdateTemplate,
    pAllocator: ?*const VkAllocationCallbacks,
) callconv(.c) void;
// Extension: VK_KHR_descriptor_update_template
pub const vkDestroyDescriptorUpdateTemplateKHR = vkDestroyDescriptorUpdateTemplate;
// Can be used without queues: false
pub const vkUpdateDescriptorSetWithTemplate = fn (
    device: VkDevice,
    descriptorSet: VkDescriptorSet,
    descriptorUpdateTemplate: VkDescriptorUpdateTemplate,
    pData: *const anyopaque,
) callconv(.c) void;
// Extension: VK_KHR_descriptor_update_template
pub const vkUpdateDescriptorSetWithTemplateKHR = vkUpdateDescriptorSetWithTemplate;
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdPushDescriptorSetWithTemplate = fn (
    commandBuffer: VkCommandBuffer,
    descriptorUpdateTemplate: VkDescriptorUpdateTemplate,
    layout: VkPipelineLayout,
    set: u32,
    pData: *const anyopaque,
) callconv(.c) void;
// Extension: VK_KHR_push_descriptor
// Extension: VK_KHR_descriptor_update_template
pub const vkCmdPushDescriptorSetWithTemplateKHR = vkCmdPushDescriptorSetWithTemplate;
// Extension: VK_EXT_hdr_metadata
// Can be used without queues: false
pub const vkSetHdrMetadataEXT = fn (
    device: VkDevice,
    swapchainCount: u32,
    // len: swapchainCount
    pSwapchains: [*]const VkSwapchainKHR,
    // len: swapchainCount
    pMetadata: [*]const VkHdrMetadataEXT,
) callconv(.c) void;
// Extension: VK_KHR_shared_presentable_image
// Success codes: VK_SUCCESS,VK_SUBOPTIMAL_KHR
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_OUT_OF_DATE_KHR,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetSwapchainStatusKHR = fn (
    device: VkDevice,
    swapchain: VkSwapchainKHR,
) callconv(.c) VkResult;
// Extension: VK_GOOGLE_display_timing
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetRefreshCycleDurationGOOGLE = fn (
    device: VkDevice,
    swapchain: VkSwapchainKHR,
    pDisplayTimingProperties: *VkRefreshCycleDurationGOOGLE,
) callconv(.c) VkResult;
// Extension: VK_GOOGLE_display_timing
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_OUT_OF_DATE_KHR,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetPastPresentationTimingGOOGLE = fn (
    device: VkDevice,
    swapchain: VkSwapchainKHR,
    pPresentationTimingCount: *u32,
    // len: pPresentationTimingCount
    pPresentationTimings: ?[*]VkPastPresentationTimingGOOGLE,
) callconv(.c) VkResult;
// Extension: VK_MVK_ios_surface
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_NATIVE_WINDOW_IN_USE_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateIOSSurfaceMVK = fn (
    instance: VkInstance,
    pCreateInfo: *const VkIOSSurfaceCreateInfoMVK,
    pAllocator: ?*const VkAllocationCallbacks,
    pSurface: *VkSurfaceKHR,
) callconv(.c) VkResult;
// Extension: VK_MVK_macos_surface
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_NATIVE_WINDOW_IN_USE_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateMacOSSurfaceMVK = fn (
    instance: VkInstance,
    pCreateInfo: *const VkMacOSSurfaceCreateInfoMVK,
    pAllocator: ?*const VkAllocationCallbacks,
    pSurface: *VkSurfaceKHR,
) callconv(.c) VkResult;
// Extension: VK_EXT_metal_surface
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_NATIVE_WINDOW_IN_USE_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateMetalSurfaceEXT = fn (
    instance: VkInstance,
    pCreateInfo: *const VkMetalSurfaceCreateInfoEXT,
    pAllocator: ?*const VkAllocationCallbacks,
    pSurface: *VkSurfaceKHR,
) callconv(.c) VkResult;
// Extension: VK_NV_clip_space_w_scaling
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetViewportWScalingNV = fn (
    commandBuffer: VkCommandBuffer,
    firstViewport: u32,
    viewportCount: u32,
    // len: viewportCount
    pViewportWScalings: [*]const VkViewportWScalingNV,
) callconv(.c) void;
// Extension: VK_EXT_discard_rectangles
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetDiscardRectangleEXT = fn (
    commandBuffer: VkCommandBuffer,
    firstDiscardRectangle: u32,
    discardRectangleCount: u32,
    // len: discardRectangleCount
    pDiscardRectangles: [*]const VkRect2D,
) callconv(.c) void;
// Extension: VK_EXT_discard_rectangles
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetDiscardRectangleEnableEXT = fn (
    commandBuffer: VkCommandBuffer,
    discardRectangleEnable: u32,
) callconv(.c) void;
// Extension: VK_EXT_discard_rectangles
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetDiscardRectangleModeEXT = fn (
    commandBuffer: VkCommandBuffer,
    discardRectangleMode: VkDiscardRectangleModeEXT,
) callconv(.c) void;
// Extension: VK_EXT_sample_locations
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetSampleLocationsEXT = fn (
    commandBuffer: VkCommandBuffer,
    pSampleLocationsInfo: *const VkSampleLocationsInfoEXT,
) callconv(.c) void;
// Extension: VK_EXT_sample_locations
// Can be used without queues: false
pub const vkGetPhysicalDeviceMultisamplePropertiesEXT = fn (
    physicalDevice: VkPhysicalDevice,
    samples: VkSampleCountFlags,
    pMultisampleProperties: *VkMultisamplePropertiesEXT,
) callconv(.c) void;
// Extension: VK_KHR_get_surface_capabilities2
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetPhysicalDeviceSurfaceCapabilities2KHR = fn (
    physicalDevice: VkPhysicalDevice,
    pSurfaceInfo: *const VkPhysicalDeviceSurfaceInfo2KHR,
    pSurfaceCapabilities: *VkSurfaceCapabilities2KHR,
) callconv(.c) VkResult;
// Extension: VK_KHR_get_surface_capabilities2
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetPhysicalDeviceSurfaceFormats2KHR = fn (
    physicalDevice: VkPhysicalDevice,
    pSurfaceInfo: *const VkPhysicalDeviceSurfaceInfo2KHR,
    pSurfaceFormatCount: *u32,
    // len: pSurfaceFormatCount
    pSurfaceFormats: ?[*]VkSurfaceFormat2KHR,
) callconv(.c) VkResult;
// Extension: VK_KHR_get_display_properties2
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetPhysicalDeviceDisplayProperties2KHR = fn (
    physicalDevice: VkPhysicalDevice,
    pPropertyCount: *u32,
    // len: pPropertyCount
    pProperties: ?[*]VkDisplayProperties2KHR,
) callconv(.c) VkResult;
// Extension: VK_KHR_get_display_properties2
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetPhysicalDeviceDisplayPlaneProperties2KHR = fn (
    physicalDevice: VkPhysicalDevice,
    pPropertyCount: *u32,
    // len: pPropertyCount
    pProperties: ?[*]VkDisplayPlaneProperties2KHR,
) callconv(.c) VkResult;
// Extension: VK_KHR_get_display_properties2
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetDisplayModeProperties2KHR = fn (
    physicalDevice: VkPhysicalDevice,
    display: VkDisplayKHR,
    pPropertyCount: *u32,
    // len: pPropertyCount
    pProperties: ?[*]VkDisplayModeProperties2KHR,
) callconv(.c) VkResult;
// Extension: VK_KHR_get_display_properties2
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetDisplayPlaneCapabilities2KHR = fn (
    physicalDevice: VkPhysicalDevice,
    pDisplayPlaneInfo: *const VkDisplayPlaneInfo2KHR,
    pCapabilities: *VkDisplayPlaneCapabilities2KHR,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkGetBufferMemoryRequirements2 = fn (
    device: VkDevice,
    pInfo: *const VkBufferMemoryRequirementsInfo2,
    pMemoryRequirements: *VkMemoryRequirements2,
) callconv(.c) void;
// Extension: VK_KHR_get_memory_requirements2
pub const vkGetBufferMemoryRequirements2KHR = vkGetBufferMemoryRequirements2;
// Can be used without queues: false
pub const vkGetImageMemoryRequirements2 = fn (
    device: VkDevice,
    pInfo: *const VkImageMemoryRequirementsInfo2,
    pMemoryRequirements: *VkMemoryRequirements2,
) callconv(.c) void;
// Extension: VK_KHR_get_memory_requirements2
pub const vkGetImageMemoryRequirements2KHR = vkGetImageMemoryRequirements2;
// Can be used without queues: false
pub const vkGetImageSparseMemoryRequirements2 = fn (
    device: VkDevice,
    pInfo: *const VkImageSparseMemoryRequirementsInfo2,
    pSparseMemoryRequirementCount: *u32,
    // len: pSparseMemoryRequirementCount
    pSparseMemoryRequirements: ?[*]VkSparseImageMemoryRequirements2,
) callconv(.c) void;
// Extension: VK_KHR_get_memory_requirements2
pub const vkGetImageSparseMemoryRequirements2KHR = vkGetImageSparseMemoryRequirements2;
// Can be used without queues: false
pub const vkGetDeviceBufferMemoryRequirements = fn (
    device: VkDevice,
    pInfo: *const VkDeviceBufferMemoryRequirements,
    pMemoryRequirements: *VkMemoryRequirements2,
) callconv(.c) void;
// Extension: VK_KHR_maintenance4
pub const vkGetDeviceBufferMemoryRequirementsKHR = vkGetDeviceBufferMemoryRequirements;
// Can be used without queues: false
pub const vkGetDeviceImageMemoryRequirements = fn (
    device: VkDevice,
    pInfo: *const VkDeviceImageMemoryRequirements,
    pMemoryRequirements: *VkMemoryRequirements2,
) callconv(.c) void;
// Extension: VK_KHR_maintenance4
pub const vkGetDeviceImageMemoryRequirementsKHR = vkGetDeviceImageMemoryRequirements;
// Can be used without queues: false
pub const vkGetDeviceImageSparseMemoryRequirements = fn (
    device: VkDevice,
    pInfo: *const VkDeviceImageMemoryRequirements,
    pSparseMemoryRequirementCount: *u32,
    // len: pSparseMemoryRequirementCount
    pSparseMemoryRequirements: ?[*]VkSparseImageMemoryRequirements2,
) callconv(.c) void;
// Extension: VK_KHR_maintenance4
pub const vkGetDeviceImageSparseMemoryRequirementsKHR = vkGetDeviceImageSparseMemoryRequirements;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: true
pub const vkCreateSamplerYcbcrConversion = fn (
    device: VkDevice,
    pCreateInfo: *const VkSamplerYcbcrConversionCreateInfo,
    pAllocator: ?*const VkAllocationCallbacks,
    pYcbcrConversion: *VkSamplerYcbcrConversion,
) callconv(.c) VkResult;
// Extension: VK_KHR_sampler_ycbcr_conversion
pub const vkCreateSamplerYcbcrConversionKHR = vkCreateSamplerYcbcrConversion;
// Can be used without queues: false
pub const vkDestroySamplerYcbcrConversion = fn (
    device: VkDevice,
    ycbcrConversion: ?VkSamplerYcbcrConversion,
    pAllocator: ?*const VkAllocationCallbacks,
) callconv(.c) void;
// Extension: VK_KHR_sampler_ycbcr_conversion
pub const vkDestroySamplerYcbcrConversionKHR = vkDestroySamplerYcbcrConversion;
// Can be used without queues: false
pub const vkGetDeviceQueue2 = fn (
    device: VkDevice,
    pQueueInfo: *const VkDeviceQueueInfo2,
    pQueue: *VkQueue,
) callconv(.c) void;
// Extension: VK_EXT_validation_cache
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateValidationCacheEXT = fn (
    device: VkDevice,
    pCreateInfo: *const VkValidationCacheCreateInfoEXT,
    pAllocator: ?*const VkAllocationCallbacks,
    pValidationCache: *VkValidationCacheEXT,
) callconv(.c) VkResult;
// Extension: VK_EXT_validation_cache
// Can be used without queues: false
pub const vkDestroyValidationCacheEXT = fn (
    device: VkDevice,
    validationCache: ?VkValidationCacheEXT,
    pAllocator: ?*const VkAllocationCallbacks,
) callconv(.c) void;
// Extension: VK_EXT_validation_cache
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetValidationCacheDataEXT = fn (
    device: VkDevice,
    validationCache: VkValidationCacheEXT,
    pDataSize: *u64,
    // len: pDataSize
    pData: ?[*]anyopaque,
) callconv(.c) VkResult;
// Extension: VK_EXT_validation_cache
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkMergeValidationCachesEXT = fn (
    device: VkDevice,
    dstCache: VkValidationCacheEXT,
    srcCacheCount: u32,
    // len: srcCacheCount
    pSrcCaches: [*]const VkValidationCacheEXT,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkGetDescriptorSetLayoutSupport = fn (
    device: VkDevice,
    pCreateInfo: *const VkDescriptorSetLayoutCreateInfo,
    pSupport: *VkDescriptorSetLayoutSupport,
) callconv(.c) void;
// Extension: VK_KHR_maintenance3
pub const vkGetDescriptorSetLayoutSupportKHR = vkGetDescriptorSetLayoutSupport;
// Extension: VK_ANDROID_native_buffer
// Can be used without queues: false
pub const vkGetSwapchainGrallocUsageANDROID = fn (
    device: VkDevice,
    format: VkFormat,
    imageUsage: VkImageUsageFlags,
    grallocUsage: *int,
) callconv(.c) VkResult;
// Extension: VK_ANDROID_native_buffer
// Can be used without queues: false
pub const vkGetSwapchainGrallocUsage2ANDROID = fn (
    device: VkDevice,
    format: VkFormat,
    imageUsage: VkImageUsageFlags,
    swapchainImageUsage: VkSwapchainImageUsageFlagsANDROID,
    grallocConsumerUsage: *u64,
    grallocProducerUsage: *u64,
) callconv(.c) VkResult;
// Extension: VK_ANDROID_native_buffer
// Can be used without queues: false
pub const vkAcquireImageANDROID = fn (
    device: VkDevice,
    image: VkImage,
    nativeFenceFd: int,
    semaphore: ?VkSemaphore,
    fence: ?VkFence,
) callconv(.c) VkResult;
// Extension: VK_ANDROID_native_buffer
// Can be used without queues: false
pub const vkQueueSignalReleaseImageANDROID = fn (
    queue: VkQueue,
    waitSemaphoreCount: u32,
    // len: waitSemaphoreCount
    pWaitSemaphores: [*]const VkSemaphore,
    image: VkImage,
    pNativeFenceFd: *int,
) callconv(.c) VkResult;
// Extension: VK_AMD_shader_info
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_FEATURE_NOT_PRESENT,VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetShaderInfoAMD = fn (
    device: VkDevice,
    pipeline: VkPipeline,
    shaderStage: VkShaderStageFlags,
    infoType: VkShaderInfoTypeAMD,
    pInfoSize: *u64,
    // len: pInfoSize
    pInfo: ?[*]anyopaque,
) callconv(.c) VkResult;
// Extension: VK_AMD_display_native_hdr
// Can be used without queues: false
pub const vkSetLocalDimmingAMD = fn (
    device: VkDevice,
    swapChain: VkSwapchainKHR,
    localDimmingEnable: u32,
) callconv(.c) void;
// Extension: VK_KHR_calibrated_timestamps
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetPhysicalDeviceCalibrateableTimeDomainsKHR = fn (
    physicalDevice: VkPhysicalDevice,
    pTimeDomainCount: *u32,
    // len: pTimeDomainCount
    pTimeDomains: ?[*]VkTimeDomainKHR,
) callconv(.c) VkResult;
// Extension: VK_EXT_calibrated_timestamps
pub const vkGetPhysicalDeviceCalibrateableTimeDomainsEXT = vkGetPhysicalDeviceCalibrateableTimeDomainsKHR;
// Extension: VK_KHR_calibrated_timestamps
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetCalibratedTimestampsKHR = fn (
    device: VkDevice,
    timestampCount: u32,
    // len: timestampCount
    pTimestampInfos: [*]const VkCalibratedTimestampInfoKHR,
    // len: timestampCount
    pTimestamps: [*]u64,
    pMaxDeviation: *u64,
) callconv(.c) VkResult;
// Extension: VK_EXT_calibrated_timestamps
pub const vkGetCalibratedTimestampsEXT = vkGetCalibratedTimestampsKHR;
// Extension: VK_EXT_debug_utils
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkSetDebugUtilsObjectNameEXT = fn (
    device: VkDevice,
    pNameInfo: *const VkDebugUtilsObjectNameInfoEXT,
) callconv(.c) VkResult;
// Extension: VK_EXT_debug_utils
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkSetDebugUtilsObjectTagEXT = fn (
    device: VkDevice,
    pTagInfo: *const VkDebugUtilsObjectTagInfoEXT,
) callconv(.c) VkResult;
// Extension: VK_EXT_debug_utils
// Can be used without queues: false
pub const vkQueueBeginDebugUtilsLabelEXT = fn (
    queue: VkQueue,
    pLabelInfo: *const VkDebugUtilsLabelEXT,
) callconv(.c) void;
// Extension: VK_EXT_debug_utils
// Can be used without queues: false
pub const vkQueueEndDebugUtilsLabelEXT = fn (
    queue: VkQueue,
) callconv(.c) void;
// Extension: VK_EXT_debug_utils
// Can be used without queues: false
pub const vkQueueInsertDebugUtilsLabelEXT = fn (
    queue: VkQueue,
    pLabelInfo: *const VkDebugUtilsLabelEXT,
) callconv(.c) void;
// Extension: VK_EXT_debug_utils
// Queues: VK_QUEUE_TRANSFER_BIT,VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT,VK_QUEUE_VIDEO_DECODE_BIT_KHR,VK_QUEUE_VIDEO_ENCODE_BIT_KHR,VK_QUEUE_OPTICAL_FLOW_BIT_NV
// Render pass: both
// Video conding: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdBeginDebugUtilsLabelEXT = fn (
    commandBuffer: VkCommandBuffer,
    pLabelInfo: *const VkDebugUtilsLabelEXT,
) callconv(.c) void;
// Extension: VK_EXT_debug_utils
// Queues: VK_QUEUE_TRANSFER_BIT,VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT,VK_QUEUE_VIDEO_DECODE_BIT_KHR,VK_QUEUE_VIDEO_ENCODE_BIT_KHR,VK_QUEUE_OPTICAL_FLOW_BIT_NV
// Render pass: both
// Video conding: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdEndDebugUtilsLabelEXT = fn (
    commandBuffer: VkCommandBuffer,
) callconv(.c) void;
// Extension: VK_EXT_debug_utils
// Queues: VK_QUEUE_TRANSFER_BIT,VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT,VK_QUEUE_VIDEO_DECODE_BIT_KHR,VK_QUEUE_VIDEO_ENCODE_BIT_KHR,VK_QUEUE_OPTICAL_FLOW_BIT_NV
// Render pass: both
// Video conding: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdInsertDebugUtilsLabelEXT = fn (
    commandBuffer: VkCommandBuffer,
    pLabelInfo: *const VkDebugUtilsLabelEXT,
) callconv(.c) void;
// Extension: VK_EXT_debug_utils
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateDebugUtilsMessengerEXT = fn (
    instance: VkInstance,
    pCreateInfo: *const VkDebugUtilsMessengerCreateInfoEXT,
    pAllocator: ?*const VkAllocationCallbacks,
    pMessenger: *VkDebugUtilsMessengerEXT,
) callconv(.c) VkResult;
// Extension: VK_EXT_debug_utils
// Can be used without queues: false
pub const vkDestroyDebugUtilsMessengerEXT = fn (
    instance: VkInstance,
    messenger: ?VkDebugUtilsMessengerEXT,
    pAllocator: ?*const VkAllocationCallbacks,
) callconv(.c) void;
// Extension: VK_EXT_debug_utils
// Can be used without queues: false
pub const vkSubmitDebugUtilsMessageEXT = fn (
    instance: VkInstance,
    messageSeverity: VkDebugUtilsMessageSeverityFlagsEXT,
    messageTypes: VkDebugUtilsMessageTypeFlagsEXT,
    pCallbackData: *const VkDebugUtilsMessengerCallbackDataEXT,
) callconv(.c) void;
// Extension: VK_EXT_external_memory_host
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_INVALID_EXTERNAL_HANDLE,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetMemoryHostPointerPropertiesEXT = fn (
    device: VkDevice,
    handleType: VkExternalMemoryHandleTypeFlags,
    pHostPointer: *const anyopaque,
    pMemoryHostPointerProperties: *VkMemoryHostPointerPropertiesEXT,
) callconv(.c) VkResult;
// Extension: VK_AMD_buffer_marker
// Queues: VK_QUEUE_TRANSFER_BIT,VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdWriteBufferMarkerAMD = fn (
    commandBuffer: VkCommandBuffer,
    pipelineStage: ?VkPipelineStageFlags,
    dstBuffer: VkBuffer,
    dstOffset: u64,
    marker: u32,
) callconv(.c) void;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: true
pub const vkCreateRenderPass2 = fn (
    device: VkDevice,
    pCreateInfo: *const VkRenderPassCreateInfo2,
    pAllocator: ?*const VkAllocationCallbacks,
    pRenderPass: *VkRenderPass,
) callconv(.c) VkResult;
// Extension: VK_KHR_create_renderpass2
pub const vkCreateRenderPass2KHR = vkCreateRenderPass2;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: outside
// Command buffer levels: primary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdBeginRenderPass2 = fn (
    commandBuffer: VkCommandBuffer,
    pRenderPassBegin: *const VkRenderPassBeginInfo,
    pSubpassBeginInfo: *const VkSubpassBeginInfo,
) callconv(.c) void;
// Extension: VK_KHR_create_renderpass2
pub const vkCmdBeginRenderPass2KHR = vkCmdBeginRenderPass2;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: inside
// Command buffer levels: primary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdNextSubpass2 = fn (
    commandBuffer: VkCommandBuffer,
    pSubpassBeginInfo: *const VkSubpassBeginInfo,
    pSubpassEndInfo: *const VkSubpassEndInfo,
) callconv(.c) void;
// Extension: VK_KHR_create_renderpass2
pub const vkCmdNextSubpass2KHR = vkCmdNextSubpass2;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: inside
// Command buffer levels: primary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdEndRenderPass2 = fn (
    commandBuffer: VkCommandBuffer,
    pSubpassEndInfo: *const VkSubpassEndInfo,
) callconv(.c) void;
// Extension: VK_KHR_create_renderpass2
pub const vkCmdEndRenderPass2KHR = vkCmdEndRenderPass2;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetSemaphoreCounterValue = fn (
    device: VkDevice,
    semaphore: VkSemaphore,
    pValue: *u64,
) callconv(.c) VkResult;
// Extension: VK_KHR_timeline_semaphore
pub const vkGetSemaphoreCounterValueKHR = vkGetSemaphoreCounterValue;
// Success codes: VK_SUCCESS,VK_TIMEOUT
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkWaitSemaphores = fn (
    device: VkDevice,
    pWaitInfo: *const VkSemaphoreWaitInfo,
    timeout: u64,
) callconv(.c) VkResult;
// Extension: VK_KHR_timeline_semaphore
pub const vkWaitSemaphoresKHR = vkWaitSemaphores;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkSignalSemaphore = fn (
    device: VkDevice,
    pSignalInfo: *const VkSemaphoreSignalInfo,
) callconv(.c) VkResult;
// Extension: VK_KHR_timeline_semaphore
pub const vkSignalSemaphoreKHR = vkSignalSemaphore;
// Extension: VK_ANDROID_external_memory_android_hardware_buffer
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_INVALID_EXTERNAL_HANDLE_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetAndroidHardwareBufferPropertiesANDROID = fn (
    device: VkDevice,
    buffer: *const AHardwareBuffer,
    pProperties: *VkAndroidHardwareBufferPropertiesANDROID,
) callconv(.c) VkResult;
// Extension: VK_ANDROID_external_memory_android_hardware_buffer
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetMemoryAndroidHardwareBufferANDROID = fn (
    device: VkDevice,
    pInfo: *const VkMemoryGetAndroidHardwareBufferInfoANDROID,
    pBuffer: **AHardwareBuffer,
) callconv(.c) VkResult;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: inside
// Command buffer levels: primary,secondary
// Conditional rendering: true
// Can be used without queues: false
pub const vkCmdDrawIndirectCount = fn (
    commandBuffer: VkCommandBuffer,
    buffer: VkBuffer,
    offset: u64,
    countBuffer: VkBuffer,
    countBufferOffset: u64,
    maxDrawCount: u32,
    stride: u32,
) callconv(.c) void;
// Extension: VK_KHR_draw_indirect_count
pub const vkCmdDrawIndirectCountKHR = vkCmdDrawIndirectCount;
// Extension: VK_AMD_draw_indirect_count
pub const vkCmdDrawIndirectCountAMD = vkCmdDrawIndirectCount;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: inside
// Command buffer levels: primary,secondary
// Conditional rendering: true
// Can be used without queues: false
pub const vkCmdDrawIndexedIndirectCount = fn (
    commandBuffer: VkCommandBuffer,
    buffer: VkBuffer,
    offset: u64,
    countBuffer: VkBuffer,
    countBufferOffset: u64,
    maxDrawCount: u32,
    stride: u32,
) callconv(.c) void;
// Extension: VK_KHR_draw_indirect_count
pub const vkCmdDrawIndexedIndirectCountKHR = vkCmdDrawIndexedIndirectCount;
// Extension: VK_AMD_draw_indirect_count
pub const vkCmdDrawIndexedIndirectCountAMD = vkCmdDrawIndexedIndirectCount;
// Extension: VK_NV_device_diagnostic_checkpoints
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT,VK_QUEUE_TRANSFER_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetCheckpointNV = fn (
    commandBuffer: VkCommandBuffer,
    pCheckpointMarker: *const anyopaque,
) callconv(.c) void;
// Extension: VK_NV_device_diagnostic_checkpoints
// Can be used without queues: false
pub const vkGetQueueCheckpointDataNV = fn (
    queue: VkQueue,
    pCheckpointDataCount: *u32,
    // len: pCheckpointDataCount
    pCheckpointData: ?[*]VkCheckpointDataNV,
) callconv(.c) void;
// Extension: VK_EXT_transform_feedback
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdBindTransformFeedbackBuffersEXT = fn (
    commandBuffer: VkCommandBuffer,
    firstBinding: u32,
    bindingCount: u32,
    // len: bindingCount
    pBuffers: [*]const VkBuffer,
    // len: bindingCount
    pOffsets: [*]const u64,
    // len: bindingCount
    pSizes: ?[*]const u64,
) callconv(.c) void;
// Extension: VK_EXT_transform_feedback
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: inside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdBeginTransformFeedbackEXT = fn (
    commandBuffer: VkCommandBuffer,
    firstCounterBuffer: u32,
    counterBufferCount: ?u32,
    // len: counterBufferCount
    pCounterBuffers: [*]const VkBuffer,
    // len: counterBufferCount
    pCounterBufferOffsets: ?[*]const u64,
) callconv(.c) void;
// Extension: VK_EXT_transform_feedback
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: inside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdEndTransformFeedbackEXT = fn (
    commandBuffer: VkCommandBuffer,
    firstCounterBuffer: u32,
    counterBufferCount: ?u32,
    // len: counterBufferCount
    pCounterBuffers: [*]const VkBuffer,
    // len: counterBufferCount
    pCounterBufferOffsets: ?[*]const u64,
) callconv(.c) void;
// Extension: VK_EXT_transform_feedback
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT,VK_QUEUE_VIDEO_DECODE_BIT_KHR,VK_QUEUE_VIDEO_ENCODE_BIT_KHR
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdBeginQueryIndexedEXT = fn (
    commandBuffer: VkCommandBuffer,
    queryPool: VkQueryPool,
    query: u32,
    flags: ?VkQueryControlFlags,
    index: u32,
) callconv(.c) void;
// Extension: VK_EXT_transform_feedback
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT,VK_QUEUE_VIDEO_DECODE_BIT_KHR,VK_QUEUE_VIDEO_ENCODE_BIT_KHR
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdEndQueryIndexedEXT = fn (
    commandBuffer: VkCommandBuffer,
    queryPool: VkQueryPool,
    query: u32,
    index: u32,
) callconv(.c) void;
// Extension: VK_EXT_transform_feedback
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: inside
// Command buffer levels: primary,secondary
// Conditional rendering: true
// Can be used without queues: false
pub const vkCmdDrawIndirectByteCountEXT = fn (
    commandBuffer: VkCommandBuffer,
    instanceCount: u32,
    firstInstance: u32,
    counterBuffer: VkBuffer,
    counterBufferOffset: u64,
    counterOffset: u32,
    vertexStride: u32,
) callconv(.c) void;
// Extension: VK_NV_scissor_exclusive
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetExclusiveScissorNV = fn (
    commandBuffer: VkCommandBuffer,
    firstExclusiveScissor: u32,
    exclusiveScissorCount: u32,
    // len: exclusiveScissorCount
    pExclusiveScissors: [*]const VkRect2D,
) callconv(.c) void;
// Extension: VK_NV_scissor_exclusive
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetExclusiveScissorEnableNV = fn (
    commandBuffer: VkCommandBuffer,
    firstExclusiveScissor: u32,
    exclusiveScissorCount: u32,
    // len: exclusiveScissorCount
    pExclusiveScissorEnables: [*]const u32,
) callconv(.c) void;
// Extension: VK_NV_shading_rate_image
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdBindShadingRateImageNV = fn (
    commandBuffer: VkCommandBuffer,
    imageView: ?VkImageView,
    imageLayout: VkImageLayout,
) callconv(.c) void;
// Extension: VK_NV_shading_rate_image
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetViewportShadingRatePaletteNV = fn (
    commandBuffer: VkCommandBuffer,
    firstViewport: u32,
    viewportCount: u32,
    // len: viewportCount
    pShadingRatePalettes: [*]const VkShadingRatePaletteNV,
) callconv(.c) void;
// Extension: VK_NV_shading_rate_image
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetCoarseSampleOrderNV = fn (
    commandBuffer: VkCommandBuffer,
    sampleOrderType: VkCoarseSampleOrderTypeNV,
    customSampleOrderCount: ?u32,
    // len: customSampleOrderCount
    pCustomSampleOrders: [*]const VkCoarseSampleOrderCustomNV,
) callconv(.c) void;
// Extension: VK_NV_mesh_shader
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: inside
// Command buffer levels: primary,secondary
// Conditional rendering: true
// Can be used without queues: false
pub const vkCmdDrawMeshTasksNV = fn (
    commandBuffer: VkCommandBuffer,
    taskCount: u32,
    firstTask: u32,
) callconv(.c) void;
// Extension: VK_NV_mesh_shader
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: inside
// Command buffer levels: primary,secondary
// Conditional rendering: true
// Can be used without queues: false
pub const vkCmdDrawMeshTasksIndirectNV = fn (
    commandBuffer: VkCommandBuffer,
    buffer: VkBuffer,
    offset: u64,
    drawCount: u32,
    stride: u32,
) callconv(.c) void;
// Extension: VK_NV_mesh_shader
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: inside
// Command buffer levels: primary,secondary
// Conditional rendering: true
// Can be used without queues: false
pub const vkCmdDrawMeshTasksIndirectCountNV = fn (
    commandBuffer: VkCommandBuffer,
    buffer: VkBuffer,
    offset: u64,
    countBuffer: VkBuffer,
    countBufferOffset: u64,
    maxDrawCount: u32,
    stride: u32,
) callconv(.c) void;
// Extension: VK_EXT_mesh_shader
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: inside
// Command buffer levels: primary,secondary
// Conditional rendering: true
// Can be used without queues: false
pub const vkCmdDrawMeshTasksEXT = fn (
    commandBuffer: VkCommandBuffer,
    groupCountX: u32,
    groupCountY: u32,
    groupCountZ: u32,
) callconv(.c) void;
// Extension: VK_EXT_mesh_shader
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: inside
// Command buffer levels: primary,secondary
// Conditional rendering: true
// Can be used without queues: false
pub const vkCmdDrawMeshTasksIndirectEXT = fn (
    commandBuffer: VkCommandBuffer,
    buffer: VkBuffer,
    offset: u64,
    drawCount: u32,
    stride: u32,
) callconv(.c) void;
// Extension: VK_EXT_mesh_shader
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: inside
// Command buffer levels: primary,secondary
// Conditional rendering: true
// Can be used without queues: false
pub const vkCmdDrawMeshTasksIndirectCountEXT = fn (
    commandBuffer: VkCommandBuffer,
    buffer: VkBuffer,
    offset: u64,
    countBuffer: VkBuffer,
    countBufferOffset: u64,
    maxDrawCount: u32,
    stride: u32,
) callconv(.c) void;
// Extension: VK_NV_ray_tracing
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCompileDeferredNV = fn (
    device: VkDevice,
    pipeline: VkPipeline,
    shader: u32,
) callconv(.c) VkResult;
// Extension: VK_NV_ray_tracing
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateAccelerationStructureNV = fn (
    device: VkDevice,
    pCreateInfo: *const VkAccelerationStructureCreateInfoNV,
    pAllocator: ?*const VkAllocationCallbacks,
    pAccelerationStructure: *VkAccelerationStructureNV,
) callconv(.c) VkResult;
// Extension: VK_HUAWEI_invocation_mask
// Queues: VK_QUEUE_COMPUTE_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdBindInvocationMaskHUAWEI = fn (
    commandBuffer: VkCommandBuffer,
    imageView: ?VkImageView,
    imageLayout: VkImageLayout,
) callconv(.c) void;
// Extension: VK_KHR_acceleration_structure
// Can be used without queues: false
pub const vkDestroyAccelerationStructureKHR = fn (
    device: VkDevice,
    accelerationStructure: ?VkAccelerationStructureKHR,
    pAllocator: ?*const VkAllocationCallbacks,
) callconv(.c) void;
// Extension: VK_NV_ray_tracing
// Can be used without queues: false
pub const vkDestroyAccelerationStructureNV = fn (
    device: VkDevice,
    accelerationStructure: ?VkAccelerationStructureNV,
    pAllocator: ?*const VkAllocationCallbacks,
) callconv(.c) void;
// Extension: VK_NV_ray_tracing
// Can be used without queues: false
pub const vkGetAccelerationStructureMemoryRequirementsNV = fn (
    device: VkDevice,
    pInfo: *const VkAccelerationStructureMemoryRequirementsInfoNV,
    pMemoryRequirements: *VkMemoryRequirements2KHR,
) callconv(.c) void;
// Extension: VK_NV_ray_tracing
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkBindAccelerationStructureMemoryNV = fn (
    device: VkDevice,
    bindInfoCount: u32,
    // len: bindInfoCount
    pBindInfos: [*]const VkBindAccelerationStructureMemoryInfoNV,
) callconv(.c) VkResult;
// Extension: VK_NV_ray_tracing
// Queues: VK_QUEUE_COMPUTE_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdCopyAccelerationStructureNV = fn (
    commandBuffer: VkCommandBuffer,
    dst: VkAccelerationStructureNV,
    src: VkAccelerationStructureNV,
    mode: VkCopyAccelerationStructureModeKHR,
) callconv(.c) void;
// Extension: VK_KHR_acceleration_structure
// Queues: VK_QUEUE_COMPUTE_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdCopyAccelerationStructureKHR = fn (
    commandBuffer: VkCommandBuffer,
    pInfo: *const VkCopyAccelerationStructureInfoKHR,
) callconv(.c) void;
// Extension: VK_KHR_acceleration_structure
// Success codes: VK_SUCCESS,VK_OPERATION_DEFERRED_KHR,VK_OPERATION_NOT_DEFERRED_KHR
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCopyAccelerationStructureKHR = fn (
    device: VkDevice,
    deferredOperation: ?VkDeferredOperationKHR,
    pInfo: *const VkCopyAccelerationStructureInfoKHR,
) callconv(.c) VkResult;
// Extension: VK_KHR_acceleration_structure
// Queues: VK_QUEUE_COMPUTE_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdCopyAccelerationStructureToMemoryKHR = fn (
    commandBuffer: VkCommandBuffer,
    pInfo: *const VkCopyAccelerationStructureToMemoryInfoKHR,
) callconv(.c) void;
// Extension: VK_KHR_acceleration_structure
// Success codes: VK_SUCCESS,VK_OPERATION_DEFERRED_KHR,VK_OPERATION_NOT_DEFERRED_KHR
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCopyAccelerationStructureToMemoryKHR = fn (
    device: VkDevice,
    deferredOperation: ?VkDeferredOperationKHR,
    pInfo: *const VkCopyAccelerationStructureToMemoryInfoKHR,
) callconv(.c) VkResult;
// Extension: VK_KHR_acceleration_structure
// Queues: VK_QUEUE_COMPUTE_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdCopyMemoryToAccelerationStructureKHR = fn (
    commandBuffer: VkCommandBuffer,
    pInfo: *const VkCopyMemoryToAccelerationStructureInfoKHR,
) callconv(.c) void;
// Extension: VK_KHR_acceleration_structure
// Success codes: VK_SUCCESS,VK_OPERATION_DEFERRED_KHR,VK_OPERATION_NOT_DEFERRED_KHR
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCopyMemoryToAccelerationStructureKHR = fn (
    device: VkDevice,
    deferredOperation: ?VkDeferredOperationKHR,
    pInfo: *const VkCopyMemoryToAccelerationStructureInfoKHR,
) callconv(.c) VkResult;
// Extension: VK_KHR_acceleration_structure
// Queues: VK_QUEUE_COMPUTE_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdWriteAccelerationStructuresPropertiesKHR = fn (
    commandBuffer: VkCommandBuffer,
    accelerationStructureCount: u32,
    // len: accelerationStructureCount
    pAccelerationStructures: [*]const VkAccelerationStructureKHR,
    queryType: VkQueryType,
    queryPool: VkQueryPool,
    firstQuery: u32,
) callconv(.c) void;
// Extension: VK_NV_ray_tracing
// Queues: VK_QUEUE_COMPUTE_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdWriteAccelerationStructuresPropertiesNV = fn (
    commandBuffer: VkCommandBuffer,
    accelerationStructureCount: u32,
    // len: accelerationStructureCount
    pAccelerationStructures: [*]const VkAccelerationStructureNV,
    queryType: VkQueryType,
    queryPool: VkQueryPool,
    firstQuery: u32,
) callconv(.c) void;
// Extension: VK_NV_ray_tracing
// Queues: VK_QUEUE_COMPUTE_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdBuildAccelerationStructureNV = fn (
    commandBuffer: VkCommandBuffer,
    pInfo: *const VkAccelerationStructureInfoNV,
    instanceData: ?VkBuffer,
    instanceOffset: u64,
    update: u32,
    dst: VkAccelerationStructureNV,
    src: ?VkAccelerationStructureNV,
    scratch: VkBuffer,
    scratchOffset: u64,
) callconv(.c) void;
// Extension: VK_KHR_acceleration_structure
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkWriteAccelerationStructuresPropertiesKHR = fn (
    device: VkDevice,
    accelerationStructureCount: u32,
    // len: accelerationStructureCount
    pAccelerationStructures: [*]const VkAccelerationStructureKHR,
    queryType: VkQueryType,
    dataSize: u64,
    // len: dataSize
    pData: [*]anyopaque,
    stride: u64,
) callconv(.c) VkResult;
// Extension: VK_KHR_ray_tracing_pipeline
// Queues: VK_QUEUE_COMPUTE_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdTraceRaysKHR = fn (
    commandBuffer: VkCommandBuffer,
    pRaygenShaderBindingTable: *const VkStridedDeviceAddressRegionKHR,
    pMissShaderBindingTable: *const VkStridedDeviceAddressRegionKHR,
    pHitShaderBindingTable: *const VkStridedDeviceAddressRegionKHR,
    pCallableShaderBindingTable: *const VkStridedDeviceAddressRegionKHR,
    width: u32,
    height: u32,
    depth: u32,
) callconv(.c) void;
// Extension: VK_NV_ray_tracing
// Queues: VK_QUEUE_COMPUTE_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdTraceRaysNV = fn (
    commandBuffer: VkCommandBuffer,
    raygenShaderBindingTableBuffer: VkBuffer,
    raygenShaderBindingOffset: u64,
    missShaderBindingTableBuffer: ?VkBuffer,
    missShaderBindingOffset: u64,
    missShaderBindingStride: u64,
    hitShaderBindingTableBuffer: ?VkBuffer,
    hitShaderBindingOffset: u64,
    hitShaderBindingStride: u64,
    callableShaderBindingTableBuffer: ?VkBuffer,
    callableShaderBindingOffset: u64,
    callableShaderBindingStride: u64,
    width: u32,
    height: u32,
    depth: u32,
) callconv(.c) void;
// Extension: VK_KHR_ray_tracing_pipeline
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetRayTracingShaderGroupHandlesKHR = fn (
    device: VkDevice,
    pipeline: VkPipeline,
    firstGroup: u32,
    groupCount: u32,
    dataSize: u64,
    // len: dataSize
    pData: [*]anyopaque,
) callconv(.c) VkResult;
// Extension: VK_NV_ray_tracing
pub const vkGetRayTracingShaderGroupHandlesNV = vkGetRayTracingShaderGroupHandlesKHR;
// Extension: VK_KHR_ray_tracing_pipeline
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetRayTracingCaptureReplayShaderGroupHandlesKHR = fn (
    device: VkDevice,
    pipeline: VkPipeline,
    firstGroup: u32,
    groupCount: u32,
    dataSize: u64,
    // len: dataSize
    pData: [*]anyopaque,
) callconv(.c) VkResult;
// Extension: VK_NV_ray_tracing
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetAccelerationStructureHandleNV = fn (
    device: VkDevice,
    accelerationStructure: VkAccelerationStructureNV,
    dataSize: u64,
    // len: dataSize
    pData: [*]anyopaque,
) callconv(.c) VkResult;
// Extension: VK_NV_ray_tracing
// Success codes: VK_SUCCESS,VK_PIPELINE_COMPILE_REQUIRED_EXT
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INVALID_SHADER_NV,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: true
pub const vkCreateRayTracingPipelinesNV = fn (
    device: VkDevice,
    pipelineCache: ?VkPipelineCache,
    createInfoCount: u32,
    // len: createInfoCount
    pCreateInfos: [*]const VkRayTracingPipelineCreateInfoNV,
    pAllocator: ?*const VkAllocationCallbacks,
    // len: createInfoCount
    pPipelines: [*]VkPipeline,
) callconv(.c) VkResult;
// Extension: VK_KHR_ray_tracing_pipeline
// Success codes: VK_SUCCESS,VK_OPERATION_DEFERRED_KHR,VK_OPERATION_NOT_DEFERRED_KHR,VK_PIPELINE_COMPILE_REQUIRED_EXT
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: true
pub const vkCreateRayTracingPipelinesKHR = fn (
    device: VkDevice,
    deferredOperation: ?VkDeferredOperationKHR,
    pipelineCache: ?VkPipelineCache,
    createInfoCount: u32,
    // len: createInfoCount
    pCreateInfos: [*]const VkRayTracingPipelineCreateInfoKHR,
    pAllocator: ?*const VkAllocationCallbacks,
    // len: createInfoCount
    pPipelines: [*]VkPipeline,
) callconv(.c) VkResult;
// Extension: VK_NV_cooperative_matrix
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetPhysicalDeviceCooperativeMatrixPropertiesNV = fn (
    physicalDevice: VkPhysicalDevice,
    pPropertyCount: *u32,
    // len: pPropertyCount
    pProperties: ?[*]VkCooperativeMatrixPropertiesNV,
) callconv(.c) VkResult;
// Extension: VK_KHR_ray_tracing_pipeline
// Queues: VK_QUEUE_COMPUTE_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdTraceRaysIndirectKHR = fn (
    commandBuffer: VkCommandBuffer,
    pRaygenShaderBindingTable: *const VkStridedDeviceAddressRegionKHR,
    pMissShaderBindingTable: *const VkStridedDeviceAddressRegionKHR,
    pHitShaderBindingTable: *const VkStridedDeviceAddressRegionKHR,
    pCallableShaderBindingTable: *const VkStridedDeviceAddressRegionKHR,
    indirectDeviceAddress: u64,
) callconv(.c) void;
// Extension: VK_KHR_ray_tracing_maintenance1
// Queues: VK_QUEUE_COMPUTE_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdTraceRaysIndirect2KHR = fn (
    commandBuffer: VkCommandBuffer,
    indirectDeviceAddress: u64,
) callconv(.c) void;
// Extension: VK_NV_cluster_acceleration_structure
// Can be used without queues: false
pub const vkGetClusterAccelerationStructureBuildSizesNV = fn (
    device: VkDevice,
    pInfo: *const VkClusterAccelerationStructureInputInfoNV,
    pSizeInfo: *VkAccelerationStructureBuildSizesInfoKHR,
) callconv(.c) void;
// Extension: VK_NV_cluster_acceleration_structure
// Queues: VK_QUEUE_COMPUTE_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdBuildClusterAccelerationStructureIndirectNV = fn (
    commandBuffer: VkCommandBuffer,
    pCommandInfos: *const VkClusterAccelerationStructureCommandsInfoNV,
) callconv(.c) void;
// Extension: VK_KHR_acceleration_structure
// Can be used without queues: false
pub const vkGetDeviceAccelerationStructureCompatibilityKHR = fn (
    device: VkDevice,
    pVersionInfo: *const VkAccelerationStructureVersionInfoKHR,
    pCompatibility: *VkAccelerationStructureCompatibilityKHR,
) callconv(.c) void;
// Extension: VK_KHR_ray_tracing_pipeline
// Can be used without queues: false
pub const vkGetRayTracingShaderGroupStackSizeKHR = fn (
    device: VkDevice,
    pipeline: VkPipeline,
    group: u32,
    groupShader: VkShaderGroupShaderKHR,
) callconv(.c) u64;
// Extension: VK_KHR_ray_tracing_pipeline
// Queues: VK_QUEUE_COMPUTE_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetRayTracingPipelineStackSizeKHR = fn (
    commandBuffer: VkCommandBuffer,
    pipelineStackSize: u32,
) callconv(.c) void;
// Extension: VK_NVX_image_view_handle
// Can be used without queues: false
pub const vkGetImageViewHandleNVX = fn (
    device: VkDevice,
    pInfo: *const VkImageViewHandleInfoNVX,
) callconv(.c) u32;
// Extension: VK_NVX_image_view_handle
// Can be used without queues: false
pub const vkGetImageViewHandle64NVX = fn (
    device: VkDevice,
    pInfo: *const VkImageViewHandleInfoNVX,
) callconv(.c) u64;
// Extension: VK_NVX_image_view_handle
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetImageViewAddressNVX = fn (
    device: VkDevice,
    imageView: VkImageView,
    pProperties: *VkImageViewAddressPropertiesNVX,
) callconv(.c) VkResult;
// Extension: VK_EXT_full_screen_exclusive
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetPhysicalDeviceSurfacePresentModes2EXT = fn (
    physicalDevice: VkPhysicalDevice,
    pSurfaceInfo: *const VkPhysicalDeviceSurfaceInfo2KHR,
    pPresentModeCount: *u32,
    // len: pPresentModeCount
    pPresentModes: ?[*]VkPresentModeKHR,
) callconv(.c) VkResult;
// Extension: VK_EXT_full_screen_exclusive
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetDeviceGroupSurfacePresentModes2EXT = fn (
    device: VkDevice,
    pSurfaceInfo: *const VkPhysicalDeviceSurfaceInfo2KHR,
    pModes: *VkDeviceGroupPresentModeFlagsKHR,
) callconv(.c) VkResult;
// Extension: VK_EXT_full_screen_exclusive
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkAcquireFullScreenExclusiveModeEXT = fn (
    device: VkDevice,
    swapchain: VkSwapchainKHR,
) callconv(.c) VkResult;
// Extension: VK_EXT_full_screen_exclusive
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkReleaseFullScreenExclusiveModeEXT = fn (
    device: VkDevice,
    swapchain: VkSwapchainKHR,
) callconv(.c) VkResult;
// Extension: VK_KHR_performance_query
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR = fn (
    physicalDevice: VkPhysicalDevice,
    queueFamilyIndex: u32,
    pCounterCount: *u32,
    // len: pCounterCount
    pCounters: ?[*]VkPerformanceCounterKHR,
    // len: pCounterCount
    pCounterDescriptions: ?[*]VkPerformanceCounterDescriptionKHR,
) callconv(.c) VkResult;
// Extension: VK_KHR_performance_query
// Can be used without queues: false
pub const vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR = fn (
    physicalDevice: VkPhysicalDevice,
    pPerformanceQueryCreateInfo: *const VkQueryPoolPerformanceCreateInfoKHR,
    pNumPasses: *u32,
) callconv(.c) void;
// Extension: VK_KHR_performance_query
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_TIMEOUT,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkAcquireProfilingLockKHR = fn (
    device: VkDevice,
    pInfo: *const VkAcquireProfilingLockInfoKHR,
) callconv(.c) VkResult;
// Extension: VK_KHR_performance_query
// Can be used without queues: false
pub const vkReleaseProfilingLockKHR = fn (
    device: VkDevice,
) callconv(.c) void;
// Extension: VK_EXT_image_drm_format_modifier
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetImageDrmFormatModifierPropertiesEXT = fn (
    device: VkDevice,
    image: VkImage,
    pProperties: *VkImageDrmFormatModifierPropertiesEXT,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkGetBufferOpaqueCaptureAddress = fn (
    device: VkDevice,
    pInfo: *const VkBufferDeviceAddressInfo,
) callconv(.c) u64;
// Extension: VK_KHR_buffer_device_address
pub const vkGetBufferOpaqueCaptureAddressKHR = vkGetBufferOpaqueCaptureAddress;
// Can be used without queues: false
pub const vkGetBufferDeviceAddress = fn (
    device: VkDevice,
    pInfo: *const VkBufferDeviceAddressInfo,
) callconv(.c) u64;
// Extension: VK_KHR_buffer_device_address
pub const vkGetBufferDeviceAddressKHR = vkGetBufferDeviceAddress;
// Extension: VK_EXT_buffer_device_address
pub const vkGetBufferDeviceAddressEXT = vkGetBufferDeviceAddress;
// Extension: VK_EXT_headless_surface
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateHeadlessSurfaceEXT = fn (
    instance: VkInstance,
    pCreateInfo: *const VkHeadlessSurfaceCreateInfoEXT,
    pAllocator: ?*const VkAllocationCallbacks,
    pSurface: *VkSurfaceKHR,
) callconv(.c) VkResult;
// Extension: VK_NV_coverage_reduction_mode
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV = fn (
    physicalDevice: VkPhysicalDevice,
    pCombinationCount: *u32,
    // len: pCombinationCount
    pCombinations: ?[*]VkFramebufferMixedSamplesCombinationNV,
) callconv(.c) VkResult;
// Extension: VK_INTEL_performance_query
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkInitializePerformanceApiINTEL = fn (
    device: VkDevice,
    pInitializeInfo: *const VkInitializePerformanceApiInfoINTEL,
) callconv(.c) VkResult;
// Extension: VK_INTEL_performance_query
// Can be used without queues: false
pub const vkUninitializePerformanceApiINTEL = fn (
    device: VkDevice,
) callconv(.c) void;
// Extension: VK_INTEL_performance_query
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT,VK_QUEUE_TRANSFER_BIT
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetPerformanceMarkerINTEL = fn (
    commandBuffer: VkCommandBuffer,
    pMarkerInfo: *const VkPerformanceMarkerInfoINTEL,
) callconv(.c) VkResult;
// Extension: VK_INTEL_performance_query
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT,VK_QUEUE_TRANSFER_BIT
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetPerformanceStreamMarkerINTEL = fn (
    commandBuffer: VkCommandBuffer,
    pMarkerInfo: *const VkPerformanceStreamMarkerInfoINTEL,
) callconv(.c) VkResult;
// Extension: VK_INTEL_performance_query
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT,VK_QUEUE_TRANSFER_BIT
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetPerformanceOverrideINTEL = fn (
    commandBuffer: VkCommandBuffer,
    pOverrideInfo: *const VkPerformanceOverrideInfoINTEL,
) callconv(.c) VkResult;
// Extension: VK_INTEL_performance_query
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkAcquirePerformanceConfigurationINTEL = fn (
    device: VkDevice,
    pAcquireInfo: *const VkPerformanceConfigurationAcquireInfoINTEL,
    pConfiguration: *VkPerformanceConfigurationINTEL,
) callconv(.c) VkResult;
// Extension: VK_INTEL_performance_query
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkReleasePerformanceConfigurationINTEL = fn (
    device: VkDevice,
    configuration: ?VkPerformanceConfigurationINTEL,
) callconv(.c) VkResult;
// Extension: VK_INTEL_performance_query
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkQueueSetPerformanceConfigurationINTEL = fn (
    queue: VkQueue,
    configuration: VkPerformanceConfigurationINTEL,
) callconv(.c) VkResult;
// Extension: VK_INTEL_performance_query
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetPerformanceParameterINTEL = fn (
    device: VkDevice,
    parameter: VkPerformanceParameterTypeINTEL,
    pValue: *VkPerformanceValueINTEL,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkGetDeviceMemoryOpaqueCaptureAddress = fn (
    device: VkDevice,
    pInfo: *const VkDeviceMemoryOpaqueCaptureAddressInfo,
) callconv(.c) u64;
// Extension: VK_KHR_buffer_device_address
pub const vkGetDeviceMemoryOpaqueCaptureAddressKHR = vkGetDeviceMemoryOpaqueCaptureAddress;
// Extension: VK_KHR_pipeline_executable_properties
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetPipelineExecutablePropertiesKHR = fn (
    device: VkDevice,
    pPipelineInfo: *const VkPipelineInfoKHR,
    pExecutableCount: *u32,
    // len: pExecutableCount
    pProperties: ?[*]VkPipelineExecutablePropertiesKHR,
) callconv(.c) VkResult;
// Extension: VK_KHR_pipeline_executable_properties
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetPipelineExecutableStatisticsKHR = fn (
    device: VkDevice,
    pExecutableInfo: *const VkPipelineExecutableInfoKHR,
    pStatisticCount: *u32,
    // len: pStatisticCount
    pStatistics: ?[*]VkPipelineExecutableStatisticKHR,
) callconv(.c) VkResult;
// Extension: VK_KHR_pipeline_executable_properties
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetPipelineExecutableInternalRepresentationsKHR = fn (
    device: VkDevice,
    pExecutableInfo: *const VkPipelineExecutableInfoKHR,
    pInternalRepresentationCount: *u32,
    // len: pInternalRepresentationCount
    pInternalRepresentations: ?[*]VkPipelineExecutableInternalRepresentationKHR,
) callconv(.c) VkResult;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetLineStipple = fn (
    commandBuffer: VkCommandBuffer,
    lineStippleFactor: u32,
    lineStipplePattern: uint16_t,
) callconv(.c) void;
// Extension: VK_KHR_line_rasterization
pub const vkCmdSetLineStippleKHR = vkCmdSetLineStipple;
// Extension: VK_EXT_line_rasterization
pub const vkCmdSetLineStippleEXT = vkCmdSetLineStipple;
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetFaultData = fn (
    device: VkDevice,
    faultQueryBehavior: VkFaultQueryBehavior,
    pUnrecordedFaults: *u32,
    pFaultCount: *u32,
    // len: pFaultCount
    pFaults: ?[*]VkFaultData,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetPhysicalDeviceToolProperties = fn (
    physicalDevice: VkPhysicalDevice,
    pToolCount: *u32,
    // len: pToolCount
    pToolProperties: ?[*]VkPhysicalDeviceToolProperties,
) callconv(.c) VkResult;
// Extension: VK_EXT_tooling_info
pub const vkGetPhysicalDeviceToolPropertiesEXT = vkGetPhysicalDeviceToolProperties;
// Extension: VK_KHR_acceleration_structure
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateAccelerationStructureKHR = fn (
    device: VkDevice,
    pCreateInfo: *const VkAccelerationStructureCreateInfoKHR,
    pAllocator: ?*const VkAllocationCallbacks,
    pAccelerationStructure: *VkAccelerationStructureKHR,
) callconv(.c) VkResult;
// Extension: VK_KHR_acceleration_structure
// Queues: VK_QUEUE_COMPUTE_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdBuildAccelerationStructuresKHR = fn (
    commandBuffer: VkCommandBuffer,
    infoCount: u32,
    // len: infoCount
    pInfos: [*]const VkAccelerationStructureBuildGeometryInfoKHR,
    // len: infoCount
    ppBuildRangeInfos: [*]const *const VkAccelerationStructureBuildRangeInfoKHR,
) callconv(.c) void;
// Extension: VK_KHR_acceleration_structure
// Queues: VK_QUEUE_COMPUTE_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdBuildAccelerationStructuresIndirectKHR = fn (
    commandBuffer: VkCommandBuffer,
    infoCount: u32,
    // len: infoCount
    pInfos: [*]const VkAccelerationStructureBuildGeometryInfoKHR,
    // len: infoCount
    pIndirectDeviceAddresses: [*]const u64,
    // len: infoCount
    pIndirectStrides: [*]const u32,
    // len: infoCount
    ppMaxPrimitiveCounts: [*]const *const u32,
) callconv(.c) void;
// Extension: VK_KHR_acceleration_structure
// Success codes: VK_SUCCESS,VK_OPERATION_DEFERRED_KHR,VK_OPERATION_NOT_DEFERRED_KHR
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkBuildAccelerationStructuresKHR = fn (
    device: VkDevice,
    deferredOperation: ?VkDeferredOperationKHR,
    infoCount: u32,
    // len: infoCount
    pInfos: [*]const VkAccelerationStructureBuildGeometryInfoKHR,
    // len: infoCount
    ppBuildRangeInfos: [*]const *const VkAccelerationStructureBuildRangeInfoKHR,
) callconv(.c) VkResult;
// Extension: VK_KHR_acceleration_structure
// Can be used without queues: false
pub const vkGetAccelerationStructureDeviceAddressKHR = fn (
    device: VkDevice,
    pInfo: *const VkAccelerationStructureDeviceAddressInfoKHR,
) callconv(.c) u64;
// Extension: VK_KHR_deferred_host_operations
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateDeferredOperationKHR = fn (
    device: VkDevice,
    pAllocator: ?*const VkAllocationCallbacks,
    pDeferredOperation: *VkDeferredOperationKHR,
) callconv(.c) VkResult;
// Extension: VK_KHR_deferred_host_operations
// Can be used without queues: false
pub const vkDestroyDeferredOperationKHR = fn (
    device: VkDevice,
    operation: ?VkDeferredOperationKHR,
    pAllocator: ?*const VkAllocationCallbacks,
) callconv(.c) void;
// Extension: VK_KHR_deferred_host_operations
// Can be used without queues: false
pub const vkGetDeferredOperationMaxConcurrencyKHR = fn (
    device: VkDevice,
    operation: VkDeferredOperationKHR,
) callconv(.c) u32;
// Extension: VK_KHR_deferred_host_operations
// Success codes: VK_SUCCESS,VK_NOT_READY
// Error codes: VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetDeferredOperationResultKHR = fn (
    device: VkDevice,
    operation: VkDeferredOperationKHR,
) callconv(.c) VkResult;
// Extension: VK_KHR_deferred_host_operations
// Success codes: VK_SUCCESS,VK_THREAD_DONE_KHR,VK_THREAD_IDLE_KHR
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkDeferredOperationJoinKHR = fn (
    device: VkDevice,
    operation: VkDeferredOperationKHR,
) callconv(.c) VkResult;
// Extension: VK_NV_device_generated_commands_compute
// Can be used without queues: false
pub const vkGetPipelineIndirectMemoryRequirementsNV = fn (
    device: VkDevice,
    pCreateInfo: *const VkComputePipelineCreateInfo,
    pMemoryRequirements: *VkMemoryRequirements2,
) callconv(.c) void;
// Extension: VK_NV_device_generated_commands_compute
// Can be used without queues: false
pub const vkGetPipelineIndirectDeviceAddressNV = fn (
    device: VkDevice,
    pInfo: *const VkPipelineIndirectDeviceAddressInfoNV,
) callconv(.c) u64;
// Extension: VK_AMD_anti_lag
// Can be used without queues: false
pub const vkAntiLagUpdateAMD = fn (
    device: VkDevice,
    pData: *const VkAntiLagDataAMD,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetCullMode = fn (
    commandBuffer: VkCommandBuffer,
    cullMode: ?VkCullModeFlags,
) callconv(.c) void;
// Extension: VK_EXT_extended_dynamic_state
// Extension: VK_EXT_shader_object
pub const vkCmdSetCullModeEXT = vkCmdSetCullMode;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetFrontFace = fn (
    commandBuffer: VkCommandBuffer,
    frontFace: VkFrontFace,
) callconv(.c) void;
// Extension: VK_EXT_extended_dynamic_state
// Extension: VK_EXT_shader_object
pub const vkCmdSetFrontFaceEXT = vkCmdSetFrontFace;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetPrimitiveTopology = fn (
    commandBuffer: VkCommandBuffer,
    primitiveTopology: VkPrimitiveTopology,
) callconv(.c) void;
// Extension: VK_EXT_extended_dynamic_state
// Extension: VK_EXT_shader_object
pub const vkCmdSetPrimitiveTopologyEXT = vkCmdSetPrimitiveTopology;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetViewportWithCount = fn (
    commandBuffer: VkCommandBuffer,
    viewportCount: u32,
    // len: viewportCount
    pViewports: [*]const VkViewport,
) callconv(.c) void;
// Extension: VK_EXT_extended_dynamic_state
// Extension: VK_EXT_shader_object
pub const vkCmdSetViewportWithCountEXT = vkCmdSetViewportWithCount;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetScissorWithCount = fn (
    commandBuffer: VkCommandBuffer,
    scissorCount: u32,
    // len: scissorCount
    pScissors: [*]const VkRect2D,
) callconv(.c) void;
// Extension: VK_EXT_extended_dynamic_state
// Extension: VK_EXT_shader_object
pub const vkCmdSetScissorWithCountEXT = vkCmdSetScissorWithCount;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdBindIndexBuffer2 = fn (
    commandBuffer: VkCommandBuffer,
    buffer: ?VkBuffer,
    offset: u64,
    size: u64,
    indexType: VkIndexType,
) callconv(.c) void;
// Extension: VK_KHR_maintenance5
pub const vkCmdBindIndexBuffer2KHR = vkCmdBindIndexBuffer2;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdBindVertexBuffers2 = fn (
    commandBuffer: VkCommandBuffer,
    firstBinding: u32,
    bindingCount: u32,
    // len: bindingCount
    pBuffers: [*]const VkBuffer,
    // len: bindingCount
    pOffsets: [*]const u64,
    // len: bindingCount
    pSizes: ?[*]const u64,
    // len: bindingCount
    pStrides: ?[*]const u64,
) callconv(.c) void;
// Extension: VK_EXT_extended_dynamic_state
// Extension: VK_EXT_shader_object
pub const vkCmdBindVertexBuffers2EXT = vkCmdBindVertexBuffers2;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetDepthTestEnable = fn (
    commandBuffer: VkCommandBuffer,
    depthTestEnable: u32,
) callconv(.c) void;
// Extension: VK_EXT_extended_dynamic_state
// Extension: VK_EXT_shader_object
pub const vkCmdSetDepthTestEnableEXT = vkCmdSetDepthTestEnable;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetDepthWriteEnable = fn (
    commandBuffer: VkCommandBuffer,
    depthWriteEnable: u32,
) callconv(.c) void;
// Extension: VK_EXT_extended_dynamic_state
// Extension: VK_EXT_shader_object
pub const vkCmdSetDepthWriteEnableEXT = vkCmdSetDepthWriteEnable;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetDepthCompareOp = fn (
    commandBuffer: VkCommandBuffer,
    depthCompareOp: VkCompareOp,
) callconv(.c) void;
// Extension: VK_EXT_extended_dynamic_state
// Extension: VK_EXT_shader_object
pub const vkCmdSetDepthCompareOpEXT = vkCmdSetDepthCompareOp;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetDepthBoundsTestEnable = fn (
    commandBuffer: VkCommandBuffer,
    depthBoundsTestEnable: u32,
) callconv(.c) void;
// Extension: VK_EXT_extended_dynamic_state
// Extension: VK_EXT_shader_object
pub const vkCmdSetDepthBoundsTestEnableEXT = vkCmdSetDepthBoundsTestEnable;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetStencilTestEnable = fn (
    commandBuffer: VkCommandBuffer,
    stencilTestEnable: u32,
) callconv(.c) void;
// Extension: VK_EXT_extended_dynamic_state
// Extension: VK_EXT_shader_object
pub const vkCmdSetStencilTestEnableEXT = vkCmdSetStencilTestEnable;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetStencilOp = fn (
    commandBuffer: VkCommandBuffer,
    faceMask: VkStencilFaceFlags,
    failOp: VkStencilOp,
    passOp: VkStencilOp,
    depthFailOp: VkStencilOp,
    compareOp: VkCompareOp,
) callconv(.c) void;
// Extension: VK_EXT_extended_dynamic_state
// Extension: VK_EXT_shader_object
pub const vkCmdSetStencilOpEXT = vkCmdSetStencilOp;
// Extension: VK_EXT_extended_dynamic_state2
// Extension: VK_EXT_shader_object
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetPatchControlPointsEXT = fn (
    commandBuffer: VkCommandBuffer,
    patchControlPoints: u32,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetRasterizerDiscardEnable = fn (
    commandBuffer: VkCommandBuffer,
    rasterizerDiscardEnable: u32,
) callconv(.c) void;
// Extension: VK_EXT_extended_dynamic_state2
// Extension: VK_EXT_shader_object
pub const vkCmdSetRasterizerDiscardEnableEXT = vkCmdSetRasterizerDiscardEnable;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetDepthBiasEnable = fn (
    commandBuffer: VkCommandBuffer,
    depthBiasEnable: u32,
) callconv(.c) void;
// Extension: VK_EXT_extended_dynamic_state2
// Extension: VK_EXT_shader_object
pub const vkCmdSetDepthBiasEnableEXT = vkCmdSetDepthBiasEnable;
// Extension: VK_EXT_extended_dynamic_state2
// Extension: VK_EXT_shader_object
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetLogicOpEXT = fn (
    commandBuffer: VkCommandBuffer,
    logicOp: VkLogicOp,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetPrimitiveRestartEnable = fn (
    commandBuffer: VkCommandBuffer,
    primitiveRestartEnable: u32,
) callconv(.c) void;
// Extension: VK_EXT_extended_dynamic_state2
// Extension: VK_EXT_shader_object
pub const vkCmdSetPrimitiveRestartEnableEXT = vkCmdSetPrimitiveRestartEnable;
// Extension: VK_EXT_extended_dynamic_state3
// Extension: VK_EXT_shader_object
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetTessellationDomainOriginEXT = fn (
    commandBuffer: VkCommandBuffer,
    domainOrigin: VkTessellationDomainOrigin,
) callconv(.c) void;
// Extension: VK_EXT_extended_dynamic_state3
// Extension: VK_EXT_shader_object
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetDepthClampEnableEXT = fn (
    commandBuffer: VkCommandBuffer,
    depthClampEnable: u32,
) callconv(.c) void;
// Extension: VK_EXT_extended_dynamic_state3
// Extension: VK_EXT_shader_object
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetPolygonModeEXT = fn (
    commandBuffer: VkCommandBuffer,
    polygonMode: VkPolygonMode,
) callconv(.c) void;
// Extension: VK_EXT_extended_dynamic_state3
// Extension: VK_EXT_shader_object
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetRasterizationSamplesEXT = fn (
    commandBuffer: VkCommandBuffer,
    rasterizationSamples: VkSampleCountFlags,
) callconv(.c) void;
// Extension: VK_EXT_extended_dynamic_state3
// Extension: VK_EXT_shader_object
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetSampleMaskEXT = fn (
    commandBuffer: VkCommandBuffer,
    samples: VkSampleCountFlags,
    // len: (samples + 31) / 32
    pSampleMask: ?[*]const u32,
) callconv(.c) void;
// Extension: VK_EXT_extended_dynamic_state3
// Extension: VK_EXT_shader_object
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetAlphaToCoverageEnableEXT = fn (
    commandBuffer: VkCommandBuffer,
    alphaToCoverageEnable: u32,
) callconv(.c) void;
// Extension: VK_EXT_extended_dynamic_state3
// Extension: VK_EXT_shader_object
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetAlphaToOneEnableEXT = fn (
    commandBuffer: VkCommandBuffer,
    alphaToOneEnable: u32,
) callconv(.c) void;
// Extension: VK_EXT_extended_dynamic_state3
// Extension: VK_EXT_shader_object
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetLogicOpEnableEXT = fn (
    commandBuffer: VkCommandBuffer,
    logicOpEnable: u32,
) callconv(.c) void;
// Extension: VK_EXT_extended_dynamic_state3
// Extension: VK_EXT_shader_object
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetColorBlendEnableEXT = fn (
    commandBuffer: VkCommandBuffer,
    firstAttachment: u32,
    attachmentCount: u32,
    // len: attachmentCount
    pColorBlendEnables: [*]const u32,
) callconv(.c) void;
// Extension: VK_EXT_extended_dynamic_state3
// Extension: VK_EXT_shader_object
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetColorBlendEquationEXT = fn (
    commandBuffer: VkCommandBuffer,
    firstAttachment: u32,
    attachmentCount: u32,
    // len: attachmentCount
    pColorBlendEquations: [*]const VkColorBlendEquationEXT,
) callconv(.c) void;
// Extension: VK_EXT_extended_dynamic_state3
// Extension: VK_EXT_shader_object
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetColorWriteMaskEXT = fn (
    commandBuffer: VkCommandBuffer,
    firstAttachment: u32,
    attachmentCount: u32,
    // len: attachmentCount
    pColorWriteMasks: [*]const VkColorComponentFlags,
) callconv(.c) void;
// Extension: VK_EXT_extended_dynamic_state3
// Extension: VK_EXT_shader_object
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetRasterizationStreamEXT = fn (
    commandBuffer: VkCommandBuffer,
    rasterizationStream: u32,
) callconv(.c) void;
// Extension: VK_EXT_extended_dynamic_state3
// Extension: VK_EXT_shader_object
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetConservativeRasterizationModeEXT = fn (
    commandBuffer: VkCommandBuffer,
    conservativeRasterizationMode: VkConservativeRasterizationModeEXT,
) callconv(.c) void;
// Extension: VK_EXT_extended_dynamic_state3
// Extension: VK_EXT_shader_object
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetExtraPrimitiveOverestimationSizeEXT = fn (
    commandBuffer: VkCommandBuffer,
    extraPrimitiveOverestimationSize: f32,
) callconv(.c) void;
// Extension: VK_EXT_extended_dynamic_state3
// Extension: VK_EXT_shader_object
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetDepthClipEnableEXT = fn (
    commandBuffer: VkCommandBuffer,
    depthClipEnable: u32,
) callconv(.c) void;
// Extension: VK_EXT_extended_dynamic_state3
// Extension: VK_EXT_shader_object
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetSampleLocationsEnableEXT = fn (
    commandBuffer: VkCommandBuffer,
    sampleLocationsEnable: u32,
) callconv(.c) void;
// Extension: VK_EXT_extended_dynamic_state3
// Extension: VK_EXT_shader_object
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetColorBlendAdvancedEXT = fn (
    commandBuffer: VkCommandBuffer,
    firstAttachment: u32,
    attachmentCount: u32,
    // len: attachmentCount
    pColorBlendAdvanced: [*]const VkColorBlendAdvancedEXT,
) callconv(.c) void;
// Extension: VK_EXT_extended_dynamic_state3
// Extension: VK_EXT_shader_object
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetProvokingVertexModeEXT = fn (
    commandBuffer: VkCommandBuffer,
    provokingVertexMode: VkProvokingVertexModeEXT,
) callconv(.c) void;
// Extension: VK_EXT_extended_dynamic_state3
// Extension: VK_EXT_shader_object
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetLineRasterizationModeEXT = fn (
    commandBuffer: VkCommandBuffer,
    lineRasterizationMode: VkLineRasterizationMode,
) callconv(.c) void;
// Extension: VK_EXT_extended_dynamic_state3
// Extension: VK_EXT_shader_object
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetLineStippleEnableEXT = fn (
    commandBuffer: VkCommandBuffer,
    stippledLineEnable: u32,
) callconv(.c) void;
// Extension: VK_EXT_extended_dynamic_state3
// Extension: VK_EXT_shader_object
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetDepthClipNegativeOneToOneEXT = fn (
    commandBuffer: VkCommandBuffer,
    negativeOneToOne: u32,
) callconv(.c) void;
// Extension: VK_EXT_extended_dynamic_state3
// Extension: VK_EXT_shader_object
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetViewportWScalingEnableNV = fn (
    commandBuffer: VkCommandBuffer,
    viewportWScalingEnable: u32,
) callconv(.c) void;
// Extension: VK_EXT_extended_dynamic_state3
// Extension: VK_EXT_shader_object
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetViewportSwizzleNV = fn (
    commandBuffer: VkCommandBuffer,
    firstViewport: u32,
    viewportCount: u32,
    // len: viewportCount
    pViewportSwizzles: [*]const VkViewportSwizzleNV,
) callconv(.c) void;
// Extension: VK_EXT_extended_dynamic_state3
// Extension: VK_EXT_shader_object
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetCoverageToColorEnableNV = fn (
    commandBuffer: VkCommandBuffer,
    coverageToColorEnable: u32,
) callconv(.c) void;
// Extension: VK_EXT_extended_dynamic_state3
// Extension: VK_EXT_shader_object
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetCoverageToColorLocationNV = fn (
    commandBuffer: VkCommandBuffer,
    coverageToColorLocation: u32,
) callconv(.c) void;
// Extension: VK_EXT_extended_dynamic_state3
// Extension: VK_EXT_shader_object
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetCoverageModulationModeNV = fn (
    commandBuffer: VkCommandBuffer,
    coverageModulationMode: VkCoverageModulationModeNV,
) callconv(.c) void;
// Extension: VK_EXT_extended_dynamic_state3
// Extension: VK_EXT_shader_object
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetCoverageModulationTableEnableNV = fn (
    commandBuffer: VkCommandBuffer,
    coverageModulationTableEnable: u32,
) callconv(.c) void;
// Extension: VK_EXT_extended_dynamic_state3
// Extension: VK_EXT_shader_object
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetCoverageModulationTableNV = fn (
    commandBuffer: VkCommandBuffer,
    coverageModulationTableCount: u32,
    // len: coverageModulationTableCount
    pCoverageModulationTable: [*]const f32,
) callconv(.c) void;
// Extension: VK_EXT_extended_dynamic_state3
// Extension: VK_EXT_shader_object
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetShadingRateImageEnableNV = fn (
    commandBuffer: VkCommandBuffer,
    shadingRateImageEnable: u32,
) callconv(.c) void;
// Extension: VK_EXT_extended_dynamic_state3
// Extension: VK_EXT_shader_object
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetCoverageReductionModeNV = fn (
    commandBuffer: VkCommandBuffer,
    coverageReductionMode: VkCoverageReductionModeNV,
) callconv(.c) void;
// Extension: VK_EXT_extended_dynamic_state3
// Extension: VK_EXT_shader_object
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetRepresentativeFragmentTestEnableNV = fn (
    commandBuffer: VkCommandBuffer,
    representativeFragmentTestEnable: u32,
) callconv(.c) void;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreatePrivateDataSlot = fn (
    device: VkDevice,
    pCreateInfo: *const VkPrivateDataSlotCreateInfo,
    pAllocator: ?*const VkAllocationCallbacks,
    pPrivateDataSlot: *VkPrivateDataSlot,
) callconv(.c) VkResult;
// Extension: VK_EXT_private_data
pub const vkCreatePrivateDataSlotEXT = vkCreatePrivateDataSlot;
// Can be used without queues: false
pub const vkDestroyPrivateDataSlot = fn (
    device: VkDevice,
    privateDataSlot: ?VkPrivateDataSlot,
    pAllocator: ?*const VkAllocationCallbacks,
) callconv(.c) void;
// Extension: VK_EXT_private_data
pub const vkDestroyPrivateDataSlotEXT = vkDestroyPrivateDataSlot;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkSetPrivateData = fn (
    device: VkDevice,
    objectType: VkObjectType,
    objectHandle: u64,
    privateDataSlot: VkPrivateDataSlot,
    data: u64,
) callconv(.c) VkResult;
// Extension: VK_EXT_private_data
pub const vkSetPrivateDataEXT = vkSetPrivateData;
// Can be used without queues: false
pub const vkGetPrivateData = fn (
    device: VkDevice,
    objectType: VkObjectType,
    objectHandle: u64,
    privateDataSlot: VkPrivateDataSlot,
    pData: *u64,
) callconv(.c) void;
// Extension: VK_EXT_private_data
pub const vkGetPrivateDataEXT = vkGetPrivateData;
// Queues: VK_QUEUE_TRANSFER_BIT,VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdCopyBuffer2 = fn (
    commandBuffer: VkCommandBuffer,
    pCopyBufferInfo: *const VkCopyBufferInfo2,
) callconv(.c) void;
// Extension: VK_KHR_copy_commands2
pub const vkCmdCopyBuffer2KHR = vkCmdCopyBuffer2;
// Queues: VK_QUEUE_TRANSFER_BIT,VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdCopyImage2 = fn (
    commandBuffer: VkCommandBuffer,
    pCopyImageInfo: *const VkCopyImageInfo2,
) callconv(.c) void;
// Extension: VK_KHR_copy_commands2
pub const vkCmdCopyImage2KHR = vkCmdCopyImage2;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdBlitImage2 = fn (
    commandBuffer: VkCommandBuffer,
    pBlitImageInfo: *const VkBlitImageInfo2,
) callconv(.c) void;
// Extension: VK_KHR_copy_commands2
pub const vkCmdBlitImage2KHR = vkCmdBlitImage2;
// Queues: VK_QUEUE_TRANSFER_BIT,VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdCopyBufferToImage2 = fn (
    commandBuffer: VkCommandBuffer,
    pCopyBufferToImageInfo: *const VkCopyBufferToImageInfo2,
) callconv(.c) void;
// Extension: VK_KHR_copy_commands2
pub const vkCmdCopyBufferToImage2KHR = vkCmdCopyBufferToImage2;
// Queues: VK_QUEUE_TRANSFER_BIT,VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdCopyImageToBuffer2 = fn (
    commandBuffer: VkCommandBuffer,
    pCopyImageToBufferInfo: *const VkCopyImageToBufferInfo2,
) callconv(.c) void;
// Extension: VK_KHR_copy_commands2
pub const vkCmdCopyImageToBuffer2KHR = vkCmdCopyImageToBuffer2;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdResolveImage2 = fn (
    commandBuffer: VkCommandBuffer,
    pResolveImageInfo: *const VkResolveImageInfo2,
) callconv(.c) void;
// Extension: VK_KHR_copy_commands2
pub const vkCmdResolveImage2KHR = vkCmdResolveImage2;
// Extension: VK_KHR_object_refresh
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT,VK_QUEUE_TRANSFER_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdRefreshObjectsKHR = fn (
    commandBuffer: VkCommandBuffer,
    pRefreshObjects: *const VkRefreshObjectListKHR,
) callconv(.c) void;
// Extension: VK_KHR_object_refresh
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetPhysicalDeviceRefreshableObjectTypesKHR = fn (
    physicalDevice: VkPhysicalDevice,
    pRefreshableObjectTypeCount: *u32,
    // len: pRefreshableObjectTypeCount
    pRefreshableObjectTypes: ?[*]VkObjectType,
) callconv(.c) VkResult;
// Extension: VK_KHR_fragment_shading_rate
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetFragmentShadingRateKHR = fn (
    commandBuffer: VkCommandBuffer,
    pFragmentSize: *const VkExtent2D,
    combinerOps: *const [2]VkFragmentShadingRateCombinerOpKHR,
) callconv(.c) void;
// Extension: VK_KHR_fragment_shading_rate
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetPhysicalDeviceFragmentShadingRatesKHR = fn (
    physicalDevice: VkPhysicalDevice,
    pFragmentShadingRateCount: *u32,
    // len: pFragmentShadingRateCount
    pFragmentShadingRates: ?[*]VkPhysicalDeviceFragmentShadingRateKHR,
) callconv(.c) VkResult;
// Extension: VK_NV_fragment_shading_rate_enums
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetFragmentShadingRateEnumNV = fn (
    commandBuffer: VkCommandBuffer,
    shadingRate: VkFragmentShadingRateNV,
    combinerOps: *const [2]VkFragmentShadingRateCombinerOpKHR,
) callconv(.c) void;
// Extension: VK_KHR_acceleration_structure
// Can be used without queues: false
pub const vkGetAccelerationStructureBuildSizesKHR = fn (
    device: VkDevice,
    buildType: VkAccelerationStructureBuildTypeKHR,
    pBuildInfo: *const VkAccelerationStructureBuildGeometryInfoKHR,
    // len: pBuildInfo-&gt;geometryCount
    pMaxPrimitiveCounts: ?[*]const u32,
    pSizeInfo: *VkAccelerationStructureBuildSizesInfoKHR,
) callconv(.c) void;
// Extension: VK_EXT_vertex_input_dynamic_state
// Extension: VK_EXT_shader_object
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetVertexInputEXT = fn (
    commandBuffer: VkCommandBuffer,
    vertexBindingDescriptionCount: ?u32,
    // len: vertexBindingDescriptionCount
    pVertexBindingDescriptions: [*]const VkVertexInputBindingDescription2EXT,
    vertexAttributeDescriptionCount: ?u32,
    // len: vertexAttributeDescriptionCount
    pVertexAttributeDescriptions: [*]const VkVertexInputAttributeDescription2EXT,
) callconv(.c) void;
// Extension: VK_EXT_color_write_enable
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetColorWriteEnableEXT = fn (
    commandBuffer: VkCommandBuffer,
    attachmentCount: u32,
    // len: attachmentCount
    pColorWriteEnables: [*]const u32,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT,VK_QUEUE_VIDEO_DECODE_BIT_KHR,VK_QUEUE_VIDEO_ENCODE_BIT_KHR
// Render pass: outside
// Video conding: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetEvent2 = fn (
    commandBuffer: VkCommandBuffer,
    event: VkEvent,
    pDependencyInfo: *const VkDependencyInfo,
) callconv(.c) void;
// Extension: VK_KHR_synchronization2
pub const vkCmdSetEvent2KHR = vkCmdSetEvent2;
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT,VK_QUEUE_VIDEO_DECODE_BIT_KHR,VK_QUEUE_VIDEO_ENCODE_BIT_KHR
// Render pass: outside
// Video conding: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdResetEvent2 = fn (
    commandBuffer: VkCommandBuffer,
    event: VkEvent,
    stageMask: ?VkPipelineStageFlags2,
) callconv(.c) void;
// Extension: VK_KHR_synchronization2
pub const vkCmdResetEvent2KHR = vkCmdResetEvent2;
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT,VK_QUEUE_VIDEO_DECODE_BIT_KHR,VK_QUEUE_VIDEO_ENCODE_BIT_KHR
// Render pass: both
// Video conding: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdWaitEvents2 = fn (
    commandBuffer: VkCommandBuffer,
    eventCount: u32,
    // len: eventCount
    pEvents: [*]const VkEvent,
    // len: eventCount
    pDependencyInfos: [*]const VkDependencyInfo,
) callconv(.c) void;
// Extension: VK_KHR_synchronization2
pub const vkCmdWaitEvents2KHR = vkCmdWaitEvents2;
// Queues: VK_QUEUE_TRANSFER_BIT,VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT,VK_QUEUE_VIDEO_DECODE_BIT_KHR,VK_QUEUE_VIDEO_ENCODE_BIT_KHR
// Render pass: both
// Video conding: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdPipelineBarrier2 = fn (
    commandBuffer: VkCommandBuffer,
    pDependencyInfo: *const VkDependencyInfo,
) callconv(.c) void;
// Extension: VK_KHR_synchronization2
pub const vkCmdPipelineBarrier2KHR = vkCmdPipelineBarrier2;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkQueueSubmit2 = fn (
    queue: VkQueue,
    submitCount: ?u32,
    // len: submitCount
    pSubmits: [*]const VkSubmitInfo2,
    fence: ?VkFence,
) callconv(.c) VkResult;
// Extension: VK_KHR_synchronization2
pub const vkQueueSubmit2KHR = vkQueueSubmit2;
// Queues: VK_QUEUE_TRANSFER_BIT,VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT,VK_QUEUE_VIDEO_DECODE_BIT_KHR,VK_QUEUE_VIDEO_ENCODE_BIT_KHR
// Render pass: both
// Video conding: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdWriteTimestamp2 = fn (
    commandBuffer: VkCommandBuffer,
    stage: ?VkPipelineStageFlags2,
    queryPool: VkQueryPool,
    query: u32,
) callconv(.c) void;
// Extension: VK_KHR_synchronization2
pub const vkCmdWriteTimestamp2KHR = vkCmdWriteTimestamp2;
// Extension: VK_AMD_buffer_marker
// Queues: VK_QUEUE_TRANSFER_BIT,VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdWriteBufferMarker2AMD = fn (
    commandBuffer: VkCommandBuffer,
    stage: ?VkPipelineStageFlags2,
    dstBuffer: VkBuffer,
    dstOffset: u64,
    marker: u32,
) callconv(.c) void;
// Extension: VK_NV_device_diagnostic_checkpoints
// Can be used without queues: false
pub const vkGetQueueCheckpointData2NV = fn (
    queue: VkQueue,
    pCheckpointDataCount: *u32,
    // len: pCheckpointDataCount
    pCheckpointData: ?[*]VkCheckpointData2NV,
) callconv(.c) void;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_MEMORY_MAP_FAILED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCopyMemoryToImage = fn (
    device: VkDevice,
    pCopyMemoryToImageInfo: *const VkCopyMemoryToImageInfo,
) callconv(.c) VkResult;
// Extension: VK_EXT_host_image_copy
pub const vkCopyMemoryToImageEXT = vkCopyMemoryToImage;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_MEMORY_MAP_FAILED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCopyImageToMemory = fn (
    device: VkDevice,
    pCopyImageToMemoryInfo: *const VkCopyImageToMemoryInfo,
) callconv(.c) VkResult;
// Extension: VK_EXT_host_image_copy
pub const vkCopyImageToMemoryEXT = vkCopyImageToMemory;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_MEMORY_MAP_FAILED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCopyImageToImage = fn (
    device: VkDevice,
    pCopyImageToImageInfo: *const VkCopyImageToImageInfo,
) callconv(.c) VkResult;
// Extension: VK_EXT_host_image_copy
pub const vkCopyImageToImageEXT = vkCopyImageToImage;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_MEMORY_MAP_FAILED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkTransitionImageLayout = fn (
    device: VkDevice,
    transitionCount: u32,
    // len: transitionCount
    pTransitions: [*]const VkHostImageLayoutTransitionInfo,
) callconv(.c) VkResult;
// Extension: VK_EXT_host_image_copy
pub const vkTransitionImageLayoutEXT = vkTransitionImageLayout;
// Can be used without queues: false
pub const vkGetCommandPoolMemoryConsumption = fn (
    device: VkDevice,
    commandPool: VkCommandPool,
    commandBuffer: ?VkCommandBuffer,
    pConsumption: *VkCommandPoolMemoryConsumption,
) callconv(.c) void;
// Extension: VK_KHR_video_queue
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_VIDEO_PROFILE_OPERATION_NOT_SUPPORTED_KHR,VK_ERROR_VIDEO_PROFILE_FORMAT_NOT_SUPPORTED_KHR,VK_ERROR_VIDEO_PICTURE_LAYOUT_NOT_SUPPORTED_KHR,VK_ERROR_VIDEO_PROFILE_CODEC_NOT_SUPPORTED_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetPhysicalDeviceVideoCapabilitiesKHR = fn (
    physicalDevice: VkPhysicalDevice,
    pVideoProfile: *const VkVideoProfileInfoKHR,
    pCapabilities: *VkVideoCapabilitiesKHR,
) callconv(.c) VkResult;
// Extension: VK_KHR_video_queue
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_IMAGE_USAGE_NOT_SUPPORTED_KHR,VK_ERROR_VIDEO_PROFILE_OPERATION_NOT_SUPPORTED_KHR,VK_ERROR_VIDEO_PROFILE_FORMAT_NOT_SUPPORTED_KHR,VK_ERROR_VIDEO_PICTURE_LAYOUT_NOT_SUPPORTED_KHR,VK_ERROR_VIDEO_PROFILE_CODEC_NOT_SUPPORTED_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetPhysicalDeviceVideoFormatPropertiesKHR = fn (
    physicalDevice: VkPhysicalDevice,
    pVideoFormatInfo: *const VkPhysicalDeviceVideoFormatInfoKHR,
    pVideoFormatPropertyCount: *u32,
    // len: pVideoFormatPropertyCount
    pVideoFormatProperties: ?[*]VkVideoFormatPropertiesKHR,
) callconv(.c) VkResult;
// Extension: VK_KHR_video_encode_queue
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_VIDEO_PROFILE_OPERATION_NOT_SUPPORTED_KHR,VK_ERROR_VIDEO_PROFILE_FORMAT_NOT_SUPPORTED_KHR,VK_ERROR_VIDEO_PICTURE_LAYOUT_NOT_SUPPORTED_KHR,VK_ERROR_VIDEO_PROFILE_CODEC_NOT_SUPPORTED_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR = fn (
    physicalDevice: VkPhysicalDevice,
    pQualityLevelInfo: *const VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR,
    pQualityLevelProperties: *VkVideoEncodeQualityLevelPropertiesKHR,
) callconv(.c) VkResult;
// Extension: VK_KHR_video_queue
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_VIDEO_STD_VERSION_NOT_SUPPORTED_KHR,VK_ERROR_INVALID_VIDEO_STD_PARAMETERS_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateVideoSessionKHR = fn (
    device: VkDevice,
    pCreateInfo: *const VkVideoSessionCreateInfoKHR,
    pAllocator: ?*const VkAllocationCallbacks,
    pVideoSession: *VkVideoSessionKHR,
) callconv(.c) VkResult;
// Extension: VK_KHR_video_queue
// Can be used without queues: false
pub const vkDestroyVideoSessionKHR = fn (
    device: VkDevice,
    videoSession: ?VkVideoSessionKHR,
    pAllocator: ?*const VkAllocationCallbacks,
) callconv(.c) void;
// Extension: VK_KHR_video_queue
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_INVALID_VIDEO_STD_PARAMETERS_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateVideoSessionParametersKHR = fn (
    device: VkDevice,
    pCreateInfo: *const VkVideoSessionParametersCreateInfoKHR,
    pAllocator: ?*const VkAllocationCallbacks,
    pVideoSessionParameters: *VkVideoSessionParametersKHR,
) callconv(.c) VkResult;
// Extension: VK_KHR_video_queue
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INVALID_VIDEO_STD_PARAMETERS_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkUpdateVideoSessionParametersKHR = fn (
    device: VkDevice,
    videoSessionParameters: VkVideoSessionParametersKHR,
    pUpdateInfo: *const VkVideoSessionParametersUpdateInfoKHR,
) callconv(.c) VkResult;
// Extension: VK_KHR_video_encode_queue
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetEncodedVideoSessionParametersKHR = fn (
    device: VkDevice,
    pVideoSessionParametersInfo: *const VkVideoEncodeSessionParametersGetInfoKHR,
    pFeedbackInfo: ?*VkVideoEncodeSessionParametersFeedbackInfoKHR,
    pDataSize: *u64,
    // len: pDataSize
    pData: ?[*]anyopaque,
) callconv(.c) VkResult;
// Extension: VK_KHR_video_queue
// Can be used without queues: false
pub const vkDestroyVideoSessionParametersKHR = fn (
    device: VkDevice,
    videoSessionParameters: ?VkVideoSessionParametersKHR,
    pAllocator: ?*const VkAllocationCallbacks,
) callconv(.c) void;
// Extension: VK_KHR_video_queue
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetVideoSessionMemoryRequirementsKHR = fn (
    device: VkDevice,
    videoSession: VkVideoSessionKHR,
    pMemoryRequirementsCount: *u32,
    // len: pMemoryRequirementsCount
    pMemoryRequirements: ?[*]VkVideoSessionMemoryRequirementsKHR,
) callconv(.c) VkResult;
// Extension: VK_KHR_video_queue
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkBindVideoSessionMemoryKHR = fn (
    device: VkDevice,
    videoSession: VkVideoSessionKHR,
    bindSessionMemoryInfoCount: u32,
    // len: bindSessionMemoryInfoCount
    pBindSessionMemoryInfos: [*]const VkBindVideoSessionMemoryInfoKHR,
) callconv(.c) VkResult;
// Extension: VK_KHR_video_decode_queue
// Queues: VK_QUEUE_VIDEO_DECODE_BIT_KHR
// Render pass: outside
// Video conding: inside
// Command buffer levels: primary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdDecodeVideoKHR = fn (
    commandBuffer: VkCommandBuffer,
    pDecodeInfo: *const VkVideoDecodeInfoKHR,
) callconv(.c) void;
// Extension: VK_KHR_video_queue
// Queues: VK_QUEUE_VIDEO_DECODE_BIT_KHR,VK_QUEUE_VIDEO_ENCODE_BIT_KHR
// Render pass: outside
// Video conding: outside
// Command buffer levels: primary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdBeginVideoCodingKHR = fn (
    commandBuffer: VkCommandBuffer,
    pBeginInfo: *const VkVideoBeginCodingInfoKHR,
) callconv(.c) void;
// Extension: VK_KHR_video_queue
// Queues: VK_QUEUE_VIDEO_DECODE_BIT_KHR,VK_QUEUE_VIDEO_ENCODE_BIT_KHR
// Render pass: outside
// Video conding: inside
// Command buffer levels: primary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdControlVideoCodingKHR = fn (
    commandBuffer: VkCommandBuffer,
    pCodingControlInfo: *const VkVideoCodingControlInfoKHR,
) callconv(.c) void;
// Extension: VK_KHR_video_queue
// Queues: VK_QUEUE_VIDEO_DECODE_BIT_KHR,VK_QUEUE_VIDEO_ENCODE_BIT_KHR
// Render pass: outside
// Video conding: inside
// Command buffer levels: primary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdEndVideoCodingKHR = fn (
    commandBuffer: VkCommandBuffer,
    pEndCodingInfo: *const VkVideoEndCodingInfoKHR,
) callconv(.c) void;
// Extension: VK_KHR_video_encode_queue
// Queues: VK_QUEUE_VIDEO_ENCODE_BIT_KHR
// Render pass: outside
// Video conding: inside
// Command buffer levels: primary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdEncodeVideoKHR = fn (
    commandBuffer: VkCommandBuffer,
    pEncodeInfo: *const VkVideoEncodeInfoKHR,
) callconv(.c) void;
// Extension: VK_NV_memory_decompression
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdDecompressMemoryNV = fn (
    commandBuffer: VkCommandBuffer,
    decompressRegionCount: u32,
    // len: decompressRegionCount
    pDecompressMemoryRegions: [*]const VkDecompressMemoryRegionNV,
) callconv(.c) void;
// Extension: VK_NV_memory_decompression
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdDecompressMemoryIndirectCountNV = fn (
    commandBuffer: VkCommandBuffer,
    indirectCommandsAddress: u64,
    indirectCommandsCountAddress: u64,
    stride: u32,
) callconv(.c) void;
// Extension: VK_NV_partitioned_acceleration_structure
// Can be used without queues: false
pub const vkGetPartitionedAccelerationStructuresBuildSizesNV = fn (
    device: VkDevice,
    pInfo: *const VkPartitionedAccelerationStructureInstancesInputNV,
    pSizeInfo: *VkAccelerationStructureBuildSizesInfoKHR,
) callconv(.c) void;
// Extension: VK_NV_partitioned_acceleration_structure
// Queues: VK_QUEUE_COMPUTE_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdBuildPartitionedAccelerationStructuresNV = fn (
    commandBuffer: VkCommandBuffer,
    pBuildInfo: *const VkBuildPartitionedAccelerationStructureInfoNV,
) callconv(.c) void;
// Extension: VK_EXT_memory_decompression
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdDecompressMemoryEXT = fn (
    commandBuffer: VkCommandBuffer,
    pDecompressMemoryInfoEXT: *const VkDecompressMemoryInfoEXT,
) callconv(.c) void;
// Extension: VK_EXT_memory_decompression
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdDecompressMemoryIndirectCountEXT = fn (
    commandBuffer: VkCommandBuffer,
    decompressionMethod: VkMemoryDecompressionMethodFlagsEXT,
    indirectCommandsAddress: u64,
    indirectCommandsCountAddress: u64,
    maxDecompressionCount: u32,
    stride: u32,
) callconv(.c) void;
// Extension: VK_NVX_binary_import
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateCuModuleNVX = fn (
    device: VkDevice,
    pCreateInfo: *const VkCuModuleCreateInfoNVX,
    pAllocator: ?*const VkAllocationCallbacks,
    pModule: *VkCuModuleNVX,
) callconv(.c) VkResult;
// Extension: VK_NVX_binary_import
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateCuFunctionNVX = fn (
    device: VkDevice,
    pCreateInfo: *const VkCuFunctionCreateInfoNVX,
    pAllocator: ?*const VkAllocationCallbacks,
    pFunction: *VkCuFunctionNVX,
) callconv(.c) VkResult;
// Extension: VK_NVX_binary_import
// Can be used without queues: false
pub const vkDestroyCuModuleNVX = fn (
    device: VkDevice,
    module: VkCuModuleNVX,
    pAllocator: ?*const VkAllocationCallbacks,
) callconv(.c) void;
// Extension: VK_NVX_binary_import
// Can be used without queues: false
pub const vkDestroyCuFunctionNVX = fn (
    device: VkDevice,
    function: VkCuFunctionNVX,
    pAllocator: ?*const VkAllocationCallbacks,
) callconv(.c) void;
// Extension: VK_NVX_binary_import
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdCuLaunchKernelNVX = fn (
    commandBuffer: VkCommandBuffer,
    pLaunchInfo: *const VkCuLaunchInfoNVX,
) callconv(.c) void;
// Extension: VK_EXT_descriptor_buffer
// Can be used without queues: false
pub const vkGetDescriptorSetLayoutSizeEXT = fn (
    device: VkDevice,
    layout: VkDescriptorSetLayout,
    pLayoutSizeInBytes: *u64,
) callconv(.c) void;
// Extension: VK_EXT_descriptor_buffer
// Can be used without queues: false
pub const vkGetDescriptorSetLayoutBindingOffsetEXT = fn (
    device: VkDevice,
    layout: VkDescriptorSetLayout,
    binding: u32,
    pOffset: *u64,
) callconv(.c) void;
// Extension: VK_EXT_descriptor_buffer
// Can be used without queues: false
pub const vkGetDescriptorEXT = fn (
    device: VkDevice,
    pDescriptorInfo: *const VkDescriptorGetInfoEXT,
    dataSize: u64,
    // len: dataSize
    pDescriptor: [*]anyopaque,
) callconv(.c) void;
// Extension: VK_EXT_descriptor_buffer
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT,VK_QUEUE_DATA_GRAPH_BIT_ARM
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdBindDescriptorBuffersEXT = fn (
    commandBuffer: VkCommandBuffer,
    bufferCount: u32,
    // len: bufferCount
    pBindingInfos: [*]const VkDescriptorBufferBindingInfoEXT,
) callconv(.c) void;
// Extension: VK_EXT_descriptor_buffer
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT,VK_QUEUE_DATA_GRAPH_BIT_ARM
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetDescriptorBufferOffsetsEXT = fn (
    commandBuffer: VkCommandBuffer,
    pipelineBindPoint: VkPipelineBindPoint,
    layout: VkPipelineLayout,
    firstSet: u32,
    setCount: u32,
    // len: setCount
    pBufferIndices: [*]const u32,
    // len: setCount
    pOffsets: [*]const u64,
) callconv(.c) void;
// Extension: VK_EXT_descriptor_buffer
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdBindDescriptorBufferEmbeddedSamplersEXT = fn (
    commandBuffer: VkCommandBuffer,
    pipelineBindPoint: VkPipelineBindPoint,
    layout: VkPipelineLayout,
    set: u32,
) callconv(.c) void;
// Extension: VK_EXT_descriptor_buffer
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetBufferOpaqueCaptureDescriptorDataEXT = fn (
    device: VkDevice,
    pInfo: *const VkBufferCaptureDescriptorDataInfoEXT,
    pData: *anyopaque,
) callconv(.c) VkResult;
// Extension: VK_EXT_descriptor_buffer
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetImageOpaqueCaptureDescriptorDataEXT = fn (
    device: VkDevice,
    pInfo: *const VkImageCaptureDescriptorDataInfoEXT,
    pData: *anyopaque,
) callconv(.c) VkResult;
// Extension: VK_EXT_descriptor_buffer
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetImageViewOpaqueCaptureDescriptorDataEXT = fn (
    device: VkDevice,
    pInfo: *const VkImageViewCaptureDescriptorDataInfoEXT,
    pData: *anyopaque,
) callconv(.c) VkResult;
// Extension: VK_EXT_descriptor_buffer
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetSamplerOpaqueCaptureDescriptorDataEXT = fn (
    device: VkDevice,
    pInfo: *const VkSamplerCaptureDescriptorDataInfoEXT,
    pData: *anyopaque,
) callconv(.c) VkResult;
// Extension: VK_EXT_descriptor_buffer
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT = fn (
    device: VkDevice,
    pInfo: *const VkAccelerationStructureCaptureDescriptorDataInfoEXT,
    pData: *anyopaque,
) callconv(.c) VkResult;
// Extension: VK_EXT_pageable_device_local_memory
// Can be used without queues: false
pub const vkSetDeviceMemoryPriorityEXT = fn (
    device: VkDevice,
    memory: VkDeviceMemory,
    priority: f32,
) callconv(.c) void;
// Extension: VK_EXT_acquire_drm_display
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkAcquireDrmDisplayEXT = fn (
    physicalDevice: VkPhysicalDevice,
    drmFd: i32,
    display: VkDisplayKHR,
) callconv(.c) VkResult;
// Extension: VK_EXT_acquire_drm_display
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetDrmDisplayEXT = fn (
    physicalDevice: VkPhysicalDevice,
    drmFd: i32,
    connectorId: u32,
    display: *VkDisplayKHR,
) callconv(.c) VkResult;
// Extension: VK_KHR_present_wait2
// Success codes: VK_SUCCESS,VK_TIMEOUT,VK_SUBOPTIMAL_KHR
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_OUT_OF_DATE_KHR,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkWaitForPresent2KHR = fn (
    device: VkDevice,
    swapchain: VkSwapchainKHR,
    pPresentWait2Info: *const VkPresentWait2InfoKHR,
) callconv(.c) VkResult;
// Extension: VK_KHR_present_wait
// Success codes: VK_SUCCESS,VK_TIMEOUT,VK_SUBOPTIMAL_KHR
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_OUT_OF_DATE_KHR,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkWaitForPresentKHR = fn (
    device: VkDevice,
    swapchain: VkSwapchainKHR,
    presentId: u64,
    timeout: u64,
) callconv(.c) VkResult;
// Extension: VK_FUCHSIA_buffer_collection
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_INVALID_EXTERNAL_HANDLE,VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateBufferCollectionFUCHSIA = fn (
    device: VkDevice,
    pCreateInfo: *const VkBufferCollectionCreateInfoFUCHSIA,
    pAllocator: ?*const VkAllocationCallbacks,
    pCollection: *VkBufferCollectionFUCHSIA,
) callconv(.c) VkResult;
// Extension: VK_FUCHSIA_buffer_collection
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_FORMAT_NOT_SUPPORTED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkSetBufferCollectionBufferConstraintsFUCHSIA = fn (
    device: VkDevice,
    collection: VkBufferCollectionFUCHSIA,
    pBufferConstraintsInfo: *const VkBufferConstraintsInfoFUCHSIA,
) callconv(.c) VkResult;
// Extension: VK_FUCHSIA_buffer_collection
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_FORMAT_NOT_SUPPORTED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkSetBufferCollectionImageConstraintsFUCHSIA = fn (
    device: VkDevice,
    collection: VkBufferCollectionFUCHSIA,
    pImageConstraintsInfo: *const VkImageConstraintsInfoFUCHSIA,
) callconv(.c) VkResult;
// Extension: VK_FUCHSIA_buffer_collection
// Can be used without queues: false
pub const vkDestroyBufferCollectionFUCHSIA = fn (
    device: VkDevice,
    collection: VkBufferCollectionFUCHSIA,
    pAllocator: ?*const VkAllocationCallbacks,
) callconv(.c) void;
// Extension: VK_FUCHSIA_buffer_collection
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetBufferCollectionPropertiesFUCHSIA = fn (
    device: VkDevice,
    collection: VkBufferCollectionFUCHSIA,
    pProperties: *VkBufferCollectionPropertiesFUCHSIA,
) callconv(.c) VkResult;
// Extension: VK_NV_cuda_kernel_launch
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateCudaModuleNV = fn (
    device: VkDevice,
    pCreateInfo: *const VkCudaModuleCreateInfoNV,
    pAllocator: ?*const VkAllocationCallbacks,
    pModule: *VkCudaModuleNV,
) callconv(.c) VkResult;
// Extension: VK_NV_cuda_kernel_launch
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetCudaModuleCacheNV = fn (
    device: VkDevice,
    module: VkCudaModuleNV,
    pCacheSize: *u64,
    // len: pCacheSize
    pCacheData: ?[*]anyopaque,
) callconv(.c) VkResult;
// Extension: VK_NV_cuda_kernel_launch
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateCudaFunctionNV = fn (
    device: VkDevice,
    pCreateInfo: *const VkCudaFunctionCreateInfoNV,
    pAllocator: ?*const VkAllocationCallbacks,
    pFunction: *VkCudaFunctionNV,
) callconv(.c) VkResult;
// Extension: VK_NV_cuda_kernel_launch
// Can be used without queues: false
pub const vkDestroyCudaModuleNV = fn (
    device: VkDevice,
    module: VkCudaModuleNV,
    pAllocator: ?*const VkAllocationCallbacks,
) callconv(.c) void;
// Extension: VK_NV_cuda_kernel_launch
// Can be used without queues: false
pub const vkDestroyCudaFunctionNV = fn (
    device: VkDevice,
    function: VkCudaFunctionNV,
    pAllocator: ?*const VkAllocationCallbacks,
) callconv(.c) void;
// Extension: VK_NV_cuda_kernel_launch
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdCudaLaunchKernelNV = fn (
    commandBuffer: VkCommandBuffer,
    pLaunchInfo: *const VkCudaLaunchInfoNV,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdBeginRendering = fn (
    commandBuffer: VkCommandBuffer,
    pRenderingInfo: *const VkRenderingInfo,
) callconv(.c) void;
// Extension: VK_KHR_dynamic_rendering
pub const vkCmdBeginRenderingKHR = vkCmdBeginRendering;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: inside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdEndRendering = fn (
    commandBuffer: VkCommandBuffer,
) callconv(.c) void;
// Extension: VK_KHR_maintenance10
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: inside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdEndRendering2KHR = fn (
    commandBuffer: VkCommandBuffer,
    pRenderingEndInfo: ?*const VkRenderingEndInfoKHR,
) callconv(.c) void;
// Extension: VK_EXT_fragment_density_map_offset
pub const vkCmdEndRendering2EXT = vkCmdEndRendering2KHR;
// Extension: VK_KHR_dynamic_rendering
pub const vkCmdEndRenderingKHR = vkCmdEndRendering;
// Extension: VK_VALVE_descriptor_set_host_mapping
// Can be used without queues: false
pub const vkGetDescriptorSetLayoutHostMappingInfoVALVE = fn (
    device: VkDevice,
    pBindingReference: *const VkDescriptorSetBindingReferenceVALVE,
    pHostMapping: *VkDescriptorSetLayoutHostMappingInfoVALVE,
) callconv(.c) void;
// Extension: VK_VALVE_descriptor_set_host_mapping
// Can be used without queues: false
pub const vkGetDescriptorSetHostMappingVALVE = fn (
    device: VkDevice,
    descriptorSet: VkDescriptorSet,
    ppData: **anyopaque,
) callconv(.c) void;
// Extension: VK_EXT_opacity_micromap
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateMicromapEXT = fn (
    device: VkDevice,
    pCreateInfo: *const VkMicromapCreateInfoEXT,
    pAllocator: ?*const VkAllocationCallbacks,
    pMicromap: *VkMicromapEXT,
) callconv(.c) VkResult;
// Extension: VK_EXT_opacity_micromap
// Queues: VK_QUEUE_COMPUTE_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdBuildMicromapsEXT = fn (
    commandBuffer: VkCommandBuffer,
    infoCount: u32,
    // len: infoCount
    pInfos: [*]const VkMicromapBuildInfoEXT,
) callconv(.c) void;
// Extension: VK_EXT_opacity_micromap
// Success codes: VK_SUCCESS,VK_OPERATION_DEFERRED_KHR,VK_OPERATION_NOT_DEFERRED_KHR
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkBuildMicromapsEXT = fn (
    device: VkDevice,
    deferredOperation: ?VkDeferredOperationKHR,
    infoCount: u32,
    // len: infoCount
    pInfos: [*]const VkMicromapBuildInfoEXT,
) callconv(.c) VkResult;
// Extension: VK_EXT_opacity_micromap
// Can be used without queues: false
pub const vkDestroyMicromapEXT = fn (
    device: VkDevice,
    micromap: ?VkMicromapEXT,
    pAllocator: ?*const VkAllocationCallbacks,
) callconv(.c) void;
// Extension: VK_EXT_opacity_micromap
// Queues: VK_QUEUE_COMPUTE_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdCopyMicromapEXT = fn (
    commandBuffer: VkCommandBuffer,
    pInfo: *const VkCopyMicromapInfoEXT,
) callconv(.c) void;
// Extension: VK_EXT_opacity_micromap
// Success codes: VK_SUCCESS,VK_OPERATION_DEFERRED_KHR,VK_OPERATION_NOT_DEFERRED_KHR
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCopyMicromapEXT = fn (
    device: VkDevice,
    deferredOperation: ?VkDeferredOperationKHR,
    pInfo: *const VkCopyMicromapInfoEXT,
) callconv(.c) VkResult;
// Extension: VK_EXT_opacity_micromap
// Queues: VK_QUEUE_COMPUTE_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdCopyMicromapToMemoryEXT = fn (
    commandBuffer: VkCommandBuffer,
    pInfo: *const VkCopyMicromapToMemoryInfoEXT,
) callconv(.c) void;
// Extension: VK_EXT_opacity_micromap
// Success codes: VK_SUCCESS,VK_OPERATION_DEFERRED_KHR,VK_OPERATION_NOT_DEFERRED_KHR
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCopyMicromapToMemoryEXT = fn (
    device: VkDevice,
    deferredOperation: ?VkDeferredOperationKHR,
    pInfo: *const VkCopyMicromapToMemoryInfoEXT,
) callconv(.c) VkResult;
// Extension: VK_EXT_opacity_micromap
// Queues: VK_QUEUE_COMPUTE_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdCopyMemoryToMicromapEXT = fn (
    commandBuffer: VkCommandBuffer,
    pInfo: *const VkCopyMemoryToMicromapInfoEXT,
) callconv(.c) void;
// Extension: VK_EXT_opacity_micromap
// Success codes: VK_SUCCESS,VK_OPERATION_DEFERRED_KHR,VK_OPERATION_NOT_DEFERRED_KHR
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCopyMemoryToMicromapEXT = fn (
    device: VkDevice,
    deferredOperation: ?VkDeferredOperationKHR,
    pInfo: *const VkCopyMemoryToMicromapInfoEXT,
) callconv(.c) VkResult;
// Extension: VK_EXT_opacity_micromap
// Queues: VK_QUEUE_COMPUTE_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdWriteMicromapsPropertiesEXT = fn (
    commandBuffer: VkCommandBuffer,
    micromapCount: u32,
    // len: micromapCount
    pMicromaps: [*]const VkMicromapEXT,
    queryType: VkQueryType,
    queryPool: VkQueryPool,
    firstQuery: u32,
) callconv(.c) void;
// Extension: VK_EXT_opacity_micromap
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkWriteMicromapsPropertiesEXT = fn (
    device: VkDevice,
    micromapCount: u32,
    // len: micromapCount
    pMicromaps: [*]const VkMicromapEXT,
    queryType: VkQueryType,
    dataSize: u64,
    // len: dataSize
    pData: [*]anyopaque,
    stride: u64,
) callconv(.c) VkResult;
// Extension: VK_EXT_opacity_micromap
// Can be used without queues: false
pub const vkGetDeviceMicromapCompatibilityEXT = fn (
    device: VkDevice,
    pVersionInfo: *const VkMicromapVersionInfoEXT,
    pCompatibility: *VkAccelerationStructureCompatibilityKHR,
) callconv(.c) void;
// Extension: VK_EXT_opacity_micromap
// Can be used without queues: false
pub const vkGetMicromapBuildSizesEXT = fn (
    device: VkDevice,
    buildType: VkAccelerationStructureBuildTypeKHR,
    pBuildInfo: *const VkMicromapBuildInfoEXT,
    pSizeInfo: *VkMicromapBuildSizesInfoEXT,
) callconv(.c) void;
// Extension: VK_EXT_shader_module_identifier
// Can be used without queues: false
pub const vkGetShaderModuleIdentifierEXT = fn (
    device: VkDevice,
    shaderModule: VkShaderModule,
    pIdentifier: *VkShaderModuleIdentifierEXT,
) callconv(.c) void;
// Extension: VK_EXT_shader_module_identifier
// Can be used without queues: false
pub const vkGetShaderModuleCreateInfoIdentifierEXT = fn (
    device: VkDevice,
    pCreateInfo: *const VkShaderModuleCreateInfo,
    pIdentifier: *VkShaderModuleIdentifierEXT,
) callconv(.c) void;
// Can be used without queues: false
pub const vkGetImageSubresourceLayout2 = fn (
    device: VkDevice,
    image: VkImage,
    pSubresource: *const VkImageSubresource2,
    pLayout: *VkSubresourceLayout2,
) callconv(.c) void;
// Extension: VK_KHR_maintenance5
pub const vkGetImageSubresourceLayout2KHR = vkGetImageSubresourceLayout2;
// Extension: VK_EXT_host_image_copy
// Extension: VK_EXT_image_compression_control
pub const vkGetImageSubresourceLayout2EXT = vkGetImageSubresourceLayout2;
// Extension: VK_EXT_pipeline_properties
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetPipelinePropertiesEXT = fn (
    device: VkDevice,
    pPipelineInfo: *const VkPipelineInfoEXT,
    // valid structs: VkPipelinePropertiesIdentifierEXT
    pPipelineProperties: *VkBaseOutStructure,
) callconv(.c) VkResult;
// Extension: VK_EXT_metal_objects
// Can be used without queues: false
pub const vkExportMetalObjectsEXT = fn (
    device: VkDevice,
    pMetalObjectsInfo: *VkExportMetalObjectsInfoEXT,
) callconv(.c) void;
// Extension: VK_QCOM_tile_memory_heap
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdBindTileMemoryQCOM = fn (
    commandBuffer: VkCommandBuffer,
    pTileMemoryBindInfo: ?*const VkTileMemoryBindInfoQCOM,
) callconv(.c) void;
// Extension: VK_QCOM_tile_properties
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetFramebufferTilePropertiesQCOM = fn (
    device: VkDevice,
    framebuffer: VkFramebuffer,
    pPropertiesCount: *u32,
    // len: pPropertiesCount
    pProperties: ?[*]VkTilePropertiesQCOM,
) callconv(.c) VkResult;
// Extension: VK_QCOM_tile_properties
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetDynamicRenderingTilePropertiesQCOM = fn (
    device: VkDevice,
    pRenderingInfo: *const VkRenderingInfo,
    pProperties: *VkTilePropertiesQCOM,
) callconv(.c) VkResult;
// Extension: VK_NV_optical_flow
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_EXTENSION_NOT_PRESENT,VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_FORMAT_NOT_SUPPORTED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetPhysicalDeviceOpticalFlowImageFormatsNV = fn (
    physicalDevice: VkPhysicalDevice,
    pOpticalFlowImageFormatInfo: *const VkOpticalFlowImageFormatInfoNV,
    pFormatCount: *u32,
    // len: pFormatCount
    pImageFormatProperties: ?[*]VkOpticalFlowImageFormatPropertiesNV,
) callconv(.c) VkResult;
// Extension: VK_NV_optical_flow
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateOpticalFlowSessionNV = fn (
    device: VkDevice,
    pCreateInfo: *const VkOpticalFlowSessionCreateInfoNV,
    pAllocator: ?*const VkAllocationCallbacks,
    pSession: *VkOpticalFlowSessionNV,
) callconv(.c) VkResult;
// Extension: VK_NV_optical_flow
// Can be used without queues: false
pub const vkDestroyOpticalFlowSessionNV = fn (
    device: VkDevice,
    session: VkOpticalFlowSessionNV,
    pAllocator: ?*const VkAllocationCallbacks,
) callconv(.c) void;
// Extension: VK_NV_optical_flow
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkBindOpticalFlowSessionImageNV = fn (
    device: VkDevice,
    session: VkOpticalFlowSessionNV,
    bindingPoint: VkOpticalFlowSessionBindingPointNV,
    view: ?VkImageView,
    layout: VkImageLayout,
) callconv(.c) VkResult;
// Extension: VK_NV_optical_flow
// Queues: VK_QUEUE_OPTICAL_FLOW_BIT_NV
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdOpticalFlowExecuteNV = fn (
    commandBuffer: VkCommandBuffer,
    session: VkOpticalFlowSessionNV,
    pExecuteInfo: *const VkOpticalFlowExecuteInfoNV,
) callconv(.c) void;
// Extension: VK_EXT_device_fault
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetDeviceFaultInfoEXT = fn (
    device: VkDevice,
    pFaultCounts: *VkDeviceFaultCountsEXT,
    pFaultInfo: ?*VkDeviceFaultInfoEXT,
) callconv(.c) VkResult;
// Extension: VK_EXT_depth_bias_control
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetDepthBias2EXT = fn (
    commandBuffer: VkCommandBuffer,
    pDepthBiasInfo: *const VkDepthBiasInfoEXT,
) callconv(.c) void;
// Extension: VK_KHR_swapchain_maintenance1
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkReleaseSwapchainImagesKHR = fn (
    device: VkDevice,
    pReleaseInfo: *const VkReleaseSwapchainImagesInfoKHR,
) callconv(.c) VkResult;
// Extension: VK_EXT_swapchain_maintenance1
pub const vkReleaseSwapchainImagesEXT = vkReleaseSwapchainImagesKHR;
// Can be used without queues: false
pub const vkGetDeviceImageSubresourceLayout = fn (
    device: VkDevice,
    pInfo: *const VkDeviceImageSubresourceInfo,
    pLayout: *VkSubresourceLayout2,
) callconv(.c) void;
// Extension: VK_KHR_maintenance5
pub const vkGetDeviceImageSubresourceLayoutKHR = vkGetDeviceImageSubresourceLayout;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_MEMORY_MAP_FAILED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkMapMemory2 = fn (
    device: VkDevice,
    pMemoryMapInfo: *const VkMemoryMapInfo,
    ppData: **anyopaque,
) callconv(.c) VkResult;
// Extension: VK_KHR_map_memory2
pub const vkMapMemory2KHR = vkMapMemory2;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_MEMORY_MAP_FAILED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkUnmapMemory2 = fn (
    device: VkDevice,
    pMemoryUnmapInfo: *const VkMemoryUnmapInfo,
) callconv(.c) VkResult;
// Extension: VK_KHR_map_memory2
pub const vkUnmapMemory2KHR = vkUnmapMemory2;
// Extension: VK_EXT_shader_object
// Success codes: VK_SUCCESS,VK_INCOMPATIBLE_SHADER_BINARY_EXT
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: true
pub const vkCreateShadersEXT = fn (
    device: VkDevice,
    createInfoCount: u32,
    // len: createInfoCount
    pCreateInfos: [*]const VkShaderCreateInfoEXT,
    pAllocator: ?*const VkAllocationCallbacks,
    // len: createInfoCount
    pShaders: [*]VkShaderEXT,
) callconv(.c) VkResult;
// Extension: VK_EXT_shader_object
// Can be used without queues: false
pub const vkDestroyShaderEXT = fn (
    device: VkDevice,
    shader: ?VkShaderEXT,
    pAllocator: ?*const VkAllocationCallbacks,
) callconv(.c) void;
// Extension: VK_EXT_shader_object
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetShaderBinaryDataEXT = fn (
    device: VkDevice,
    shader: VkShaderEXT,
    pDataSize: *u64,
    // len: pDataSize
    pData: ?[*]anyopaque,
) callconv(.c) VkResult;
// Extension: VK_EXT_shader_object
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdBindShadersEXT = fn (
    commandBuffer: VkCommandBuffer,
    stageCount: u32,
    // len: stageCount
    pStages: [*]const VkShaderStageFlags,
    // len: stageCount
    pShaders: [*]const VkShaderEXT,
) callconv(.c) void;
// Extension: VK_EXT_present_timing
// Success codes: VK_SUCCESS,VK_NOT_READY
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkSetSwapchainPresentTimingQueueSizeEXT = fn (
    device: VkDevice,
    swapchain: VkSwapchainKHR,
    size: u32,
) callconv(.c) VkResult;
// Extension: VK_EXT_present_timing
// Success codes: VK_SUCCESS,VK_NOT_READY
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetSwapchainTimingPropertiesEXT = fn (
    device: VkDevice,
    swapchain: VkSwapchainKHR,
    pSwapchainTimingProperties: *VkSwapchainTimingPropertiesEXT,
    pSwapchainTimingPropertiesCounter: ?*u64,
) callconv(.c) VkResult;
// Extension: VK_EXT_present_timing
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetSwapchainTimeDomainPropertiesEXT = fn (
    device: VkDevice,
    swapchain: VkSwapchainKHR,
    pSwapchainTimeDomainProperties: *VkSwapchainTimeDomainPropertiesEXT,
    pTimeDomainsCounter: ?*u64,
) callconv(.c) VkResult;
// Extension: VK_EXT_present_timing
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_DEVICE_LOST,VK_ERROR_OUT_OF_DATE_KHR,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetPastPresentationTimingEXT = fn (
    device: VkDevice,
    pPastPresentationTimingInfo: *const VkPastPresentationTimingInfoEXT,
    pPastPresentationTimingProperties: *VkPastPresentationTimingPropertiesEXT,
) callconv(.c) VkResult;
// Extension: VK_QNX_external_memory_screen_buffer
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_INVALID_EXTERNAL_HANDLE_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetScreenBufferPropertiesQNX = fn (
    device: VkDevice,
    buffer: *const _screen_buffer,
    pProperties: *VkScreenBufferPropertiesQNX,
) callconv(.c) VkResult;
// Extension: VK_KHR_cooperative_matrix
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR = fn (
    physicalDevice: VkPhysicalDevice,
    pPropertyCount: *u32,
    // len: pPropertyCount
    pProperties: ?[*]VkCooperativeMatrixPropertiesKHR,
) callconv(.c) VkResult;
// Extension: VK_AMDX_shader_enqueue
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetExecutionGraphPipelineScratchSizeAMDX = fn (
    device: VkDevice,
    executionGraph: VkPipeline,
    pSizeInfo: *VkExecutionGraphPipelineScratchSizeAMDX,
) callconv(.c) VkResult;
// Extension: VK_AMDX_shader_enqueue
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetExecutionGraphPipelineNodeIndexAMDX = fn (
    device: VkDevice,
    executionGraph: VkPipeline,
    pNodeInfo: *const VkPipelineShaderStageNodeCreateInfoAMDX,
    pNodeIndex: *u32,
) callconv(.c) VkResult;
// Extension: VK_AMDX_shader_enqueue
// Success codes: VK_SUCCESS,VK_PIPELINE_COMPILE_REQUIRED_EXT
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: true
pub const vkCreateExecutionGraphPipelinesAMDX = fn (
    device: VkDevice,
    pipelineCache: ?VkPipelineCache,
    createInfoCount: u32,
    // len: createInfoCount
    pCreateInfos: [*]const VkExecutionGraphPipelineCreateInfoAMDX,
    pAllocator: ?*const VkAllocationCallbacks,
    // len: createInfoCount
    pPipelines: [*]VkPipeline,
) callconv(.c) VkResult;
// Extension: VK_AMDX_shader_enqueue
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT
// Render pass: both
// Command buffer levels: primary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdInitializeGraphScratchMemoryAMDX = fn (
    commandBuffer: VkCommandBuffer,
    executionGraph: VkPipeline,
    scratch: u64,
    scratchSize: u64,
) callconv(.c) void;
// Extension: VK_AMDX_shader_enqueue
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT
// Render pass: both
// Command buffer levels: primary
// Conditional rendering: true
// Can be used without queues: false
pub const vkCmdDispatchGraphAMDX = fn (
    commandBuffer: VkCommandBuffer,
    scratch: u64,
    scratchSize: u64,
    pCountInfo: *const VkDispatchGraphCountInfoAMDX,
) callconv(.c) void;
// Extension: VK_AMDX_shader_enqueue
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT
// Render pass: both
// Command buffer levels: primary
// Conditional rendering: true
// Can be used without queues: false
pub const vkCmdDispatchGraphIndirectAMDX = fn (
    commandBuffer: VkCommandBuffer,
    scratch: u64,
    scratchSize: u64,
    pCountInfo: *const VkDispatchGraphCountInfoAMDX,
) callconv(.c) void;
// Extension: VK_AMDX_shader_enqueue
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT
// Render pass: both
// Command buffer levels: primary
// Conditional rendering: true
// Can be used without queues: false
pub const vkCmdDispatchGraphIndirectCountAMDX = fn (
    commandBuffer: VkCommandBuffer,
    scratch: u64,
    scratchSize: u64,
    countInfo: u64,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdBindDescriptorSets2 = fn (
    commandBuffer: VkCommandBuffer,
    pBindDescriptorSetsInfo: *const VkBindDescriptorSetsInfo,
) callconv(.c) void;
// Extension: VK_KHR_maintenance6
pub const vkCmdBindDescriptorSets2KHR = vkCmdBindDescriptorSets2;
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdPushConstants2 = fn (
    commandBuffer: VkCommandBuffer,
    pPushConstantsInfo: *const VkPushConstantsInfo,
) callconv(.c) void;
// Extension: VK_KHR_maintenance6
pub const vkCmdPushConstants2KHR = vkCmdPushConstants2;
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdPushDescriptorSet2 = fn (
    commandBuffer: VkCommandBuffer,
    pPushDescriptorSetInfo: *const VkPushDescriptorSetInfo,
) callconv(.c) void;
// Extension: VK_KHR_maintenance6
pub const vkCmdPushDescriptorSet2KHR = vkCmdPushDescriptorSet2;
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdPushDescriptorSetWithTemplate2 = fn (
    commandBuffer: VkCommandBuffer,
    pPushDescriptorSetWithTemplateInfo: *const VkPushDescriptorSetWithTemplateInfo,
) callconv(.c) void;
// Extension: VK_KHR_maintenance6
pub const vkCmdPushDescriptorSetWithTemplate2KHR = vkCmdPushDescriptorSetWithTemplate2;
// Extension: VK_KHR_maintenance6
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT,VK_QUEUE_DATA_GRAPH_BIT_ARM
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetDescriptorBufferOffsets2EXT = fn (
    commandBuffer: VkCommandBuffer,
    pSetDescriptorBufferOffsetsInfo: *const VkSetDescriptorBufferOffsetsInfoEXT,
) callconv(.c) void;
// Extension: VK_KHR_maintenance6
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdBindDescriptorBufferEmbeddedSamplers2EXT = fn (
    commandBuffer: VkCommandBuffer,
    pBindDescriptorBufferEmbeddedSamplersInfo: *const VkBindDescriptorBufferEmbeddedSamplersInfoEXT,
) callconv(.c) void;
// Extension: VK_NV_low_latency2
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkSetLatencySleepModeNV = fn (
    device: VkDevice,
    swapchain: VkSwapchainKHR,
    pSleepModeInfo: *const VkLatencySleepModeInfoNV,
) callconv(.c) VkResult;
// Extension: VK_NV_low_latency2
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkLatencySleepNV = fn (
    device: VkDevice,
    swapchain: VkSwapchainKHR,
    pSleepInfo: *const VkLatencySleepInfoNV,
) callconv(.c) VkResult;
// Extension: VK_NV_low_latency2
// Can be used without queues: false
pub const vkSetLatencyMarkerNV = fn (
    device: VkDevice,
    swapchain: VkSwapchainKHR,
    pLatencyMarkerInfo: *const VkSetLatencyMarkerInfoNV,
) callconv(.c) void;
// Extension: VK_NV_low_latency2
// Can be used without queues: false
pub const vkGetLatencyTimingsNV = fn (
    device: VkDevice,
    swapchain: VkSwapchainKHR,
    pLatencyMarkerInfo: *VkGetLatencyMarkerInfoNV,
) callconv(.c) void;
// Extension: VK_NV_low_latency2
// Can be used without queues: false
pub const vkQueueNotifyOutOfBandNV = fn (
    queue: VkQueue,
    pQueueTypeInfo: *const VkOutOfBandQueueTypeInfoNV,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: inside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetRenderingAttachmentLocations = fn (
    commandBuffer: VkCommandBuffer,
    pLocationInfo: *const VkRenderingAttachmentLocationInfo,
) callconv(.c) void;
// Extension: VK_KHR_dynamic_rendering_local_read
pub const vkCmdSetRenderingAttachmentLocationsKHR = vkCmdSetRenderingAttachmentLocations;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: inside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetRenderingInputAttachmentIndices = fn (
    commandBuffer: VkCommandBuffer,
    pInputAttachmentIndexInfo: *const VkRenderingInputAttachmentIndexInfo,
) callconv(.c) void;
// Extension: VK_KHR_dynamic_rendering_local_read
pub const vkCmdSetRenderingInputAttachmentIndicesKHR = vkCmdSetRenderingInputAttachmentIndices;
// Extension: VK_EXT_shader_object
// Extension: VK_EXT_depth_clamp_control
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetDepthClampRangeEXT = fn (
    commandBuffer: VkCommandBuffer,
    depthClampMode: VkDepthClampModeEXT,
    pDepthClampRange: ?*const VkDepthClampRangeEXT,
) callconv(.c) void;
// Extension: VK_NV_cooperative_matrix2
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV = fn (
    physicalDevice: VkPhysicalDevice,
    pPropertyCount: *u32,
    // len: pPropertyCount
    pProperties: ?[*]VkCooperativeMatrixFlexibleDimensionsPropertiesNV,
) callconv(.c) VkResult;
// Extension: VK_EXT_external_memory_metal
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetMemoryMetalHandleEXT = fn (
    device: VkDevice,
    pGetMetalHandleInfo: *const VkMemoryGetMetalHandleInfoEXT,
    pHandle: **anyopaque,
) callconv(.c) VkResult;
// Extension: VK_EXT_external_memory_metal
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_INVALID_EXTERNAL_HANDLE,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetMemoryMetalHandlePropertiesEXT = fn (
    device: VkDevice,
    handleType: VkExternalMemoryHandleTypeFlags,
    pHandle: *const anyopaque,
    pMemoryMetalHandleProperties: *VkMemoryMetalHandlePropertiesEXT,
) callconv(.c) VkResult;
// Extension: VK_NV_cooperative_vector
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetPhysicalDeviceCooperativeVectorPropertiesNV = fn (
    physicalDevice: VkPhysicalDevice,
    pPropertyCount: *u32,
    // len: pPropertyCount
    pProperties: ?[*]VkCooperativeVectorPropertiesNV,
) callconv(.c) VkResult;
// Extension: VK_NV_cooperative_vector
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkConvertCooperativeVectorMatrixNV = fn (
    device: VkDevice,
    pInfo: *const VkConvertCooperativeVectorMatrixInfoNV,
) callconv(.c) VkResult;
// Extension: VK_NV_cooperative_vector
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdConvertCooperativeVectorMatrixNV = fn (
    commandBuffer: VkCommandBuffer,
    infoCount: u32,
    // len: infoCount
    pInfos: [*]const VkConvertCooperativeVectorMatrixInfoNV,
) callconv(.c) void;
// Extension: VK_QCOM_tile_shading
// Queues: VK_QUEUE_COMPUTE_BIT
// Render pass: inside
// Command buffer levels: primary,secondary
// Conditional rendering: true
// Can be used without queues: false
pub const vkCmdDispatchTileQCOM = fn (
    commandBuffer: VkCommandBuffer,
    pDispatchTileInfo: *const VkDispatchTileInfoQCOM,
) callconv(.c) void;
// Extension: VK_QCOM_tile_shading
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT
// Render pass: inside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdBeginPerTileExecutionQCOM = fn (
    commandBuffer: VkCommandBuffer,
    pPerTileBeginInfo: *const VkPerTileBeginInfoQCOM,
) callconv(.c) void;
// Extension: VK_QCOM_tile_shading
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT
// Render pass: inside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdEndPerTileExecutionQCOM = fn (
    commandBuffer: VkCommandBuffer,
    pPerTileEndInfo: *const VkPerTileEndInfoQCOM,
) callconv(.c) void;
// Extension: VK_NV_external_compute_queue
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateExternalComputeQueueNV = fn (
    device: VkDevice,
    pCreateInfo: *const VkExternalComputeQueueCreateInfoNV,
    pAllocator: ?*const VkAllocationCallbacks,
    pExternalQueue: *VkExternalComputeQueueNV,
) callconv(.c) VkResult;
// Extension: VK_NV_external_compute_queue
// Can be used without queues: false
pub const vkDestroyExternalComputeQueueNV = fn (
    device: VkDevice,
    externalQueue: VkExternalComputeQueueNV,
    pAllocator: ?*const VkAllocationCallbacks,
) callconv(.c) void;
// Extension: VK_NV_external_compute_queue
// Can be used without queues: false
pub const vkGetExternalComputeQueueDataNV = fn (
    externalQueue: VkExternalComputeQueueNV,
    params: *VkExternalComputeQueueDataParamsNV,
    pData: *anyopaque,
) callconv(.c) void;
// Extension: VK_ARM_tensors
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateTensorARM = fn (
    device: VkDevice,
    pCreateInfo: *const VkTensorCreateInfoARM,
    pAllocator: ?*const VkAllocationCallbacks,
    pTensor: *VkTensorARM,
) callconv(.c) VkResult;
// Extension: VK_ARM_tensors
// Can be used without queues: false
pub const vkDestroyTensorARM = fn (
    device: VkDevice,
    tensor: ?VkTensorARM,
    pAllocator: ?*const VkAllocationCallbacks,
) callconv(.c) void;
// Extension: VK_ARM_tensors
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateTensorViewARM = fn (
    device: VkDevice,
    pCreateInfo: *const VkTensorViewCreateInfoARM,
    pAllocator: ?*const VkAllocationCallbacks,
    pView: *VkTensorViewARM,
) callconv(.c) VkResult;
// Extension: VK_ARM_tensors
// Can be used without queues: false
pub const vkDestroyTensorViewARM = fn (
    device: VkDevice,
    tensorView: ?VkTensorViewARM,
    pAllocator: ?*const VkAllocationCallbacks,
) callconv(.c) void;
// Extension: VK_ARM_tensors
// Can be used without queues: false
pub const vkGetTensorMemoryRequirementsARM = fn (
    device: VkDevice,
    pInfo: *const VkTensorMemoryRequirementsInfoARM,
    pMemoryRequirements: *VkMemoryRequirements2,
) callconv(.c) void;
// Extension: VK_ARM_tensors
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkBindTensorMemoryARM = fn (
    device: VkDevice,
    bindInfoCount: u32,
    // len: bindInfoCount
    pBindInfos: [*]const VkBindTensorMemoryInfoARM,
) callconv(.c) VkResult;
// Extension: VK_ARM_tensors
// Can be used without queues: false
pub const vkGetDeviceTensorMemoryRequirementsARM = fn (
    device: VkDevice,
    pInfo: *const VkDeviceTensorMemoryRequirementsARM,
    pMemoryRequirements: *VkMemoryRequirements2,
) callconv(.c) void;
// Extension: VK_ARM_tensors
// Queues: VK_QUEUE_TRANSFER_BIT,VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdCopyTensorARM = fn (
    commandBuffer: VkCommandBuffer,
    pCopyTensorInfo: *const VkCopyTensorInfoARM,
) callconv(.c) void;
// Extension: VK_ARM_tensors
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetTensorOpaqueCaptureDescriptorDataARM = fn (
    device: VkDevice,
    pInfo: *const VkTensorCaptureDescriptorDataInfoARM,
    pData: *anyopaque,
) callconv(.c) VkResult;
// Extension: VK_ARM_tensors
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetTensorViewOpaqueCaptureDescriptorDataARM = fn (
    device: VkDevice,
    pInfo: *const VkTensorViewCaptureDescriptorDataInfoARM,
    pData: *anyopaque,
) callconv(.c) VkResult;
// Extension: VK_ARM_tensors
// Can be used without queues: false
pub const vkGetPhysicalDeviceExternalTensorPropertiesARM = fn (
    physicalDevice: VkPhysicalDevice,
    pExternalTensorInfo: *const VkPhysicalDeviceExternalTensorInfoARM,
    pExternalTensorProperties: *VkExternalTensorPropertiesARM,
) callconv(.c) void;
// Extension: VK_ARM_data_graph
// Success codes: VK_SUCCESS,VK_PIPELINE_COMPILE_REQUIRED_EXT
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateDataGraphPipelinesARM = fn (
    device: VkDevice,
    deferredOperation: ?VkDeferredOperationKHR,
    pipelineCache: ?VkPipelineCache,
    createInfoCount: u32,
    // len: createInfoCount
    pCreateInfos: [*]const VkDataGraphPipelineCreateInfoARM,
    pAllocator: ?*const VkAllocationCallbacks,
    // len: createInfoCount
    pPipelines: [*]VkPipeline,
) callconv(.c) VkResult;
// Extension: VK_ARM_data_graph
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateDataGraphPipelineSessionARM = fn (
    device: VkDevice,
    pCreateInfo: *const VkDataGraphPipelineSessionCreateInfoARM,
    pAllocator: ?*const VkAllocationCallbacks,
    pSession: *VkDataGraphPipelineSessionARM,
) callconv(.c) VkResult;
// Extension: VK_ARM_data_graph
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetDataGraphPipelineSessionBindPointRequirementsARM = fn (
    device: VkDevice,
    pInfo: *const VkDataGraphPipelineSessionBindPointRequirementsInfoARM,
    pBindPointRequirementCount: *u32,
    // len: pBindPointRequirementCount
    pBindPointRequirements: ?[*]VkDataGraphPipelineSessionBindPointRequirementARM,
) callconv(.c) VkResult;
// Extension: VK_ARM_data_graph
// Can be used without queues: false
pub const vkGetDataGraphPipelineSessionMemoryRequirementsARM = fn (
    device: VkDevice,
    pInfo: *const VkDataGraphPipelineSessionMemoryRequirementsInfoARM,
    pMemoryRequirements: *VkMemoryRequirements2,
) callconv(.c) void;
// Extension: VK_ARM_data_graph
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkBindDataGraphPipelineSessionMemoryARM = fn (
    device: VkDevice,
    bindInfoCount: u32,
    // len: bindInfoCount
    pBindInfos: [*]const VkBindDataGraphPipelineSessionMemoryInfoARM,
) callconv(.c) VkResult;
// Extension: VK_ARM_data_graph
// Can be used without queues: false
pub const vkDestroyDataGraphPipelineSessionARM = fn (
    device: VkDevice,
    session: VkDataGraphPipelineSessionARM,
    pAllocator: ?*const VkAllocationCallbacks,
) callconv(.c) void;
// Extension: VK_ARM_data_graph
// Queues: VK_QUEUE_DATA_GRAPH_BIT_ARM
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: true
// Can be used without queues: false
pub const vkCmdDispatchDataGraphARM = fn (
    commandBuffer: VkCommandBuffer,
    session: VkDataGraphPipelineSessionARM,
    pInfo: ?*const VkDataGraphPipelineDispatchInfoARM,
) callconv(.c) void;
// Extension: VK_ARM_data_graph
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetDataGraphPipelineAvailablePropertiesARM = fn (
    device: VkDevice,
    pPipelineInfo: *const VkDataGraphPipelineInfoARM,
    pPropertiesCount: *u32,
    // len: pPropertiesCount
    pProperties: ?[*]VkDataGraphPipelinePropertyARM,
) callconv(.c) VkResult;
// Extension: VK_ARM_data_graph
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetDataGraphPipelinePropertiesARM = fn (
    device: VkDevice,
    pPipelineInfo: *const VkDataGraphPipelineInfoARM,
    propertiesCount: u32,
    // len: propertiesCount
    pProperties: [*]VkDataGraphPipelinePropertyQueryResultARM,
) callconv(.c) VkResult;
// Extension: VK_ARM_data_graph
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetPhysicalDeviceQueueFamilyDataGraphPropertiesARM = fn (
    physicalDevice: VkPhysicalDevice,
    queueFamilyIndex: u32,
    pQueueFamilyDataGraphPropertyCount: *u32,
    // len: pQueueFamilyDataGraphPropertyCount
    pQueueFamilyDataGraphProperties: ?[*]VkQueueFamilyDataGraphPropertiesARM,
) callconv(.c) VkResult;
// Extension: VK_ARM_data_graph
// Can be used without queues: false
pub const vkGetPhysicalDeviceQueueFamilyDataGraphProcessingEnginePropertiesARM = fn (
    physicalDevice: VkPhysicalDevice,
    pQueueFamilyDataGraphProcessingEngineInfo: *const VkPhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARM,
    pQueueFamilyDataGraphProcessingEngineProperties: *VkQueueFamilyDataGraphProcessingEnginePropertiesARM,
) callconv(.c) void;
// Extension: VK_OHOS_external_memory
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INVALID_EXTERNAL_HANDLE_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetNativeBufferPropertiesOHOS = fn (
    device: VkDevice,
    buffer: *const OH_NativeBuffer,
    pProperties: *VkNativeBufferPropertiesOHOS,
) callconv(.c) VkResult;
// Extension: VK_OHOS_external_memory
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetMemoryNativeBufferOHOS = fn (
    device: VkDevice,
    pInfo: *const VkMemoryGetNativeBufferInfoOHOS,
    pBuffer: **OH_NativeBuffer,
) callconv(.c) VkResult;
// Extension: VK_OHOS_native_buffer
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetSwapchainGrallocUsageOHOS = fn (
    device: VkDevice,
    format: VkFormat,
    imageUsage: VkImageUsageFlags,
    grallocUsage: *u64,
) callconv(.c) VkResult;
// Extension: VK_OHOS_native_buffer
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkAcquireImageOHOS = fn (
    device: VkDevice,
    image: VkImage,
    nativeFenceFd: i32,
    semaphore: ?VkSemaphore,
    fence: ?VkFence,
) callconv(.c) VkResult;
// Extension: VK_OHOS_native_buffer
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkQueueSignalReleaseImageOHOS = fn (
    queue: VkQueue,
    waitSemaphoreCount: u32,
    // len: waitSemaphoreCount
    pWaitSemaphores: [*]const VkSemaphore,
    image: VkImage,
    pNativeFenceFd: *i32,
) callconv(.c) VkResult;
// Extension: VK_ARM_performance_counters_by_region
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkEnumeratePhysicalDeviceQueueFamilyPerformanceCountersByRegionARM = fn (
    physicalDevice: VkPhysicalDevice,
    queueFamilyIndex: u32,
    pCounterCount: *u32,
    // len: pCounterCount
    pCounters: ?[*]VkPerformanceCounterARM,
    // len: pCounterCount
    pCounterDescriptions: ?[*]VkPerformanceCounterDescriptionARM,
) callconv(.c) VkResult;
// Extension: VK_NV_compute_occupancy_priority
// Queues: VK_QUEUE_COMPUTE_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetComputeOccupancyPriorityNV = fn (
    commandBuffer: VkCommandBuffer,
    pParameters: *const VkComputeOccupancyPriorityParametersNV,
) callconv(.c) void;

// Extensions
// Extension: VK_KHR_surface
// Number: 1
// Type: instance
// Author: KHR
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_SURFACE_SPEC_VERSION
//             Negative: false
//             Value: 25
//         Enum:
//             Name: VK_KHR_SURFACE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_surface&quot;
//         Enum:
//             Name: VK_ERROR_SURFACE_LOST_KHR
//             Negative: true
//             Extends: VkResult
//             Offset: 0
//         Enum:
//             Name: VK_ERROR_NATIVE_WINDOW_IN_USE_KHR
//             Negative: true
//             Extends: VkResult
//             Offset: 1
//         Enum:
//             Name: VK_OBJECT_TYPE_SURFACE_KHR
//             Negative: false
//             Extends: VkObjectType
//             Offset: 0
//         Type:
//             Name: VkSurfaceKHR
//         Type:
//             Name: VkSurfaceTransformFlagBitsKHR
//         Type:
//             Name: VkPresentModeKHR
//         Type:
//             Name: VkColorSpaceKHR
//         Type:
//             Name: VkCompositeAlphaFlagBitsKHR
//         Type:
//             Name: VkCompositeAlphaFlagsKHR
//         Type:
//             Name: VkSurfaceCapabilitiesKHR
//         Type:
//             Name: VkSurfaceFormatKHR
//         Command:
//             Name: vkDestroySurfaceKHR
//         Command:
//             Name: vkGetPhysicalDeviceSurfaceSupportKHR
//         Command:
//             Name: vkGetPhysicalDeviceSurfaceCapabilitiesKHR
//         Command:
//             Name: vkGetPhysicalDeviceSurfaceFormatsKHR
//         Command:
//             Name: vkGetPhysicalDeviceSurfacePresentModesKHR
// Extension: VK_KHR_swapchain
// Number: 2
// Type: device
// Author: KHR
// Depends: VK_KHR_surface
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_SWAPCHAIN_SPEC_VERSION
//             Negative: false
//             Value: 70
//         Enum:
//             Name: VK_KHR_SWAPCHAIN_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_swapchain&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PRESENT_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_IMAGE_LAYOUT_PRESENT_SRC_KHR
//             Negative: false
//             Extends: VkImageLayout
//             Offset: 2
//         Enum:
//             Name: VK_SUBOPTIMAL_KHR
//             Negative: false
//             Extends: VkResult
//             Offset: 3
//         Enum:
//             Name: VK_ERROR_OUT_OF_DATE_KHR
//             Negative: true
//             Extends: VkResult
//             Offset: 4
//         Enum:
//             Name: VK_OBJECT_TYPE_SWAPCHAIN_KHR
//             Negative: false
//             Extends: VkObjectType
//             Offset: 0
//         Type:
//             Name: VkSwapchainCreateFlagBitsKHR
//         Type:
//             Name: VkSwapchainCreateFlagsKHR
//         Type:
//             Name: VkSwapchainCreateInfoKHR
//         Type:
//             Name: VkSwapchainKHR
//         Type:
//             Name: VkPresentInfoKHR
//         Command:
//             Name: vkCreateSwapchainKHR
//         Command:
//             Name: vkDestroySwapchainKHR
//         Command:
//             Name: vkGetSwapchainImagesKHR
//         Command:
//             Name: vkAcquireNextImageKHR
//         Command:
//             Name: vkQueuePresentKHR
//     Depends: VK_VERSION_1_1
//         Comment:
//             This duplicates definitions in VK_KHR_device_group below
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Extnumber: 61
//             Offset: 7
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Extnumber: 61
//             Offset: 8
//         Enum:
//             Name: VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Extnumber: 61
//             Offset: 9
//         Enum:
//             Name: VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Extnumber: 61
//             Offset: 10
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Extnumber: 61
//             Offset: 11
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Extnumber: 61
//             Offset: 12
//         Enum:
//             Name: VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR
//             Negative: false
//             Bitpos: 0
//             Extends: VkSwapchainCreateFlagBitsKHR
//             Comment:
//                 Allow images with VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT
//         Type:
//             Name: VkImageSwapchainCreateInfoKHR
//         Type:
//             Name: VkBindImageMemorySwapchainInfoKHR
//         Type:
//             Name: VkAcquireNextImageInfoKHR
//         Type:
//             Name: VkDeviceGroupPresentModeFlagBitsKHR
//         Type:
//             Name: VkDeviceGroupPresentModeFlagsKHR
//         Type:
//             Name: VkDeviceGroupPresentCapabilitiesKHR
//         Type:
//             Name: VkDeviceGroupPresentInfoKHR
//         Type:
//             Name: VkDeviceGroupSwapchainCreateInfoKHR
//         Command:
//             Name: vkGetDeviceGroupPresentCapabilitiesKHR
//         Command:
//             Name: vkGetDeviceGroupSurfacePresentModesKHR
//         Command:
//             Name: vkGetPhysicalDevicePresentRectanglesKHR
//         Command:
//             Name: vkAcquireNextImage2KHR
//         Enum:
//             Name: VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR
//             Negative: false
//             Bitpos: 1
//             Extends: VkSwapchainCreateFlagBitsKHR
//             Comment:
//                 Swapchain is protected
// Extension: VK_KHR_display
// Number: 3
// Type: instance
// Author: KHR
// Depends: VK_KHR_surface
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_DISPLAY_SPEC_VERSION
//             Negative: false
//             Value: 23
//         Enum:
//             Name: VK_KHR_DISPLAY_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_display&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_OBJECT_TYPE_DISPLAY_KHR
//             Negative: false
//             Extends: VkObjectType
//             Offset: 0
//         Enum:
//             Name: VK_OBJECT_TYPE_DISPLAY_MODE_KHR
//             Negative: false
//             Extends: VkObjectType
//             Offset: 1
//         Type:
//             Name: VkDisplayKHR
//         Type:
//             Name: VkDisplayModeCreateFlagsKHR
//         Type:
//             Name: VkDisplayModeCreateInfoKHR
//         Type:
//             Name: VkDisplayModeKHR
//         Type:
//             Name: VkDisplayModeParametersKHR
//         Type:
//             Name: VkDisplayModePropertiesKHR
//         Type:
//             Name: VkDisplayPlaneAlphaFlagBitsKHR
//         Type:
//             Name: VkDisplayPlaneAlphaFlagsKHR
//         Type:
//             Name: VkDisplayPlaneCapabilitiesKHR
//         Type:
//             Name: VkDisplayPlanePropertiesKHR
//         Type:
//             Name: VkDisplayPropertiesKHR
//         Type:
//             Name: VkDisplaySurfaceCreateFlagsKHR
//         Type:
//             Name: VkDisplaySurfaceCreateInfoKHR
//         Type:
//             Name: VkSurfaceTransformFlagsKHR
//         Command:
//             Name: vkGetPhysicalDeviceDisplayPropertiesKHR
//         Command:
//             Name: vkGetPhysicalDeviceDisplayPlanePropertiesKHR
//         Command:
//             Name: vkGetDisplayPlaneSupportedDisplaysKHR
//         Command:
//             Name: vkGetDisplayModePropertiesKHR
//         Command:
//             Name: vkCreateDisplayModeKHR
//         Command:
//             Name: vkGetDisplayPlaneCapabilitiesKHR
//         Command:
//             Name: vkCreateDisplayPlaneSurfaceKHR
// Extension: VK_KHR_display_swapchain
// Number: 4
// Type: device
// Author: KHR
// Depends: VK_KHR_swapchain+VK_KHR_display
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_DISPLAY_SWAPCHAIN_SPEC_VERSION
//             Negative: false
//             Value: 10
//         Enum:
//             Name: VK_KHR_DISPLAY_SWAPCHAIN_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_display_swapchain&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_ERROR_INCOMPATIBLE_DISPLAY_KHR
//             Negative: true
//             Extends: VkResult
//             Offset: 1
//         Type:
//             Name: VkDisplayPresentInfoKHR
//         Command:
//             Name: vkCreateSharedSwapchainsKHR
// Extension: VK_KHR_xlib_surface
// Number: 5
// Type: instance
// Author: KHR
// Depends: VK_KHR_surface
// Platform: xlib
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_XLIB_SURFACE_SPEC_VERSION
//             Negative: false
//             Value: 6
//         Enum:
//             Name: VK_KHR_XLIB_SURFACE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_xlib_surface&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkXlibSurfaceCreateFlagsKHR
//         Type:
//             Name: VkXlibSurfaceCreateInfoKHR
//         Command:
//             Name: vkCreateXlibSurfaceKHR
//         Command:
//             Name: vkGetPhysicalDeviceXlibPresentationSupportKHR
// Extension: VK_KHR_xcb_surface
// Number: 6
// Type: instance
// Author: KHR
// Depends: VK_KHR_surface
// Platform: xcb
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_XCB_SURFACE_SPEC_VERSION
//             Negative: false
//             Value: 6
//         Enum:
//             Name: VK_KHR_XCB_SURFACE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_xcb_surface&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkXcbSurfaceCreateFlagsKHR
//         Type:
//             Name: VkXcbSurfaceCreateInfoKHR
//         Command:
//             Name: vkCreateXcbSurfaceKHR
//         Command:
//             Name: vkGetPhysicalDeviceXcbPresentationSupportKHR
// Extension: VK_KHR_wayland_surface
// Number: 7
// Type: instance
// Author: KHR
// Depends: VK_KHR_surface
// Platform: wayland
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_WAYLAND_SURFACE_SPEC_VERSION
//             Negative: false
//             Value: 6
//         Enum:
//             Name: VK_KHR_WAYLAND_SURFACE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_wayland_surface&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkWaylandSurfaceCreateFlagsKHR
//         Type:
//             Name: VkWaylandSurfaceCreateInfoKHR
//         Command:
//             Name: vkCreateWaylandSurfaceKHR
//         Command:
//             Name: vkGetPhysicalDeviceWaylandPresentationSupportKHR
// Extension: VK_KHR_mir_surface
// Number: 8
// Type: instance
// Author: KHR
// Depends: VK_KHR_surface
// Supported: disabled
// Comment:
//     Extension permanently disabled. Extension number should not be reused
// Unlocks:
//         Enum:
//             Name: VK_KHR_MIR_SURFACE_SPEC_VERSION
//             Negative: false
//             Value: 4
//         Enum:
//             Name: VK_KHR_MIR_SURFACE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_mir_surface&quot;
// Extension: VK_KHR_android_surface
// Number: 9
// Type: instance
// Author: KHR
// Depends: VK_KHR_surface
// Platform: android
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_ANDROID_SURFACE_SPEC_VERSION
//             Negative: false
//             Value: 6
//         Enum:
//             Name: VK_KHR_ANDROID_SURFACE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_android_surface&quot;
//         Type:
//             Name: ANativeWindow
//         Enum:
//             Name: VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkAndroidSurfaceCreateFlagsKHR
//         Type:
//             Name: VkAndroidSurfaceCreateInfoKHR
//         Command:
//             Name: vkCreateAndroidSurfaceKHR
// Extension: VK_KHR_win32_surface
// Number: 10
// Type: instance
// Author: KHR
// Depends: VK_KHR_surface
// Platform: win32
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_WIN32_SURFACE_SPEC_VERSION
//             Negative: false
//             Value: 6
//         Enum:
//             Name: VK_KHR_WIN32_SURFACE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_win32_surface&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkWin32SurfaceCreateFlagsKHR
//         Type:
//             Name: VkWin32SurfaceCreateInfoKHR
//         Command:
//             Name: vkCreateWin32SurfaceKHR
//         Command:
//             Name: vkGetPhysicalDeviceWin32PresentationSupportKHR
// Extension: VK_ANDROID_native_buffer
// Number: 11
// Type: device
// Author: ANDROID
// Platform: android
// Supported: disabled
// Unlocks:
//         Comment:
//             VK_ANDROID_native_buffer is used between the Android Vulkan loader and drivers to implement the WSI extensions. It is not exposed to applications and uses types that are not part of Android's stable public API, so it is left disabled to keep it out of the standard Vulkan headers.
//         Enum:
//             Name: VK_ANDROID_NATIVE_BUFFER_SPEC_VERSION
//             Negative: false
//             Value: 8
//         Enum:
//             Name: VK_ANDROID_NATIVE_BUFFER_NUMBER
//             Negative: false
//             Value: 11
//         Enum:
//             Name: VK_ANDROID_NATIVE_BUFFER_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_ANDROID_native_buffer&quot;
//         Enum:
//             Name: VK_ANDROID_NATIVE_BUFFER_NAME
//             Negative: false
//             Alias: VK_ANDROID_NATIVE_BUFFER_EXTENSION_NAME
//         Enum:
//             Name: VK_STRUCTURE_TYPE_NATIVE_BUFFER_ANDROID
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SWAPCHAIN_IMAGE_CREATE_INFO_ANDROID
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENTATION_PROPERTIES_ANDROID
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Type:
//             Name: VkNativeBufferANDROID
//         Type:
//             Name: VkSwapchainImageCreateInfoANDROID
//         Type:
//             Name: VkPhysicalDevicePresentationPropertiesANDROID
//         Type:
//             Name: VkNativeBufferUsage2ANDROID
//         Type:
//             Name: VkSwapchainImageUsageFlagBitsANDROID
//         Type:
//             Name: VkSwapchainImageUsageFlagsANDROID
//         Command:
//             Name: vkGetSwapchainGrallocUsageANDROID
//         Command:
//             Name: vkAcquireImageANDROID
//         Command:
//             Name: vkQueueSignalReleaseImageANDROID
//         Command:
//             Name: vkGetSwapchainGrallocUsage2ANDROID
// Extension: VK_EXT_debug_report
// Number: 12
// Type: instance
// Author: GOOGLE
// Supported: supported
// Deprecated by: VK_EXT_debug_utils
// Unlocks:
//         Enum:
//             Name: VK_EXT_DEBUG_REPORT_SPEC_VERSION
//             Negative: false
//             Value: 10
//         Enum:
//             Name: VK_EXT_DEBUG_REPORT_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_debug_report&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DEBUG_REPORT_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT
//         Enum:
//             Name: VK_ERROR_VALIDATION_FAILED_EXT
//             Negative: false
//             Extends: VkResult
//             Alias: VK_ERROR_VALIDATION_FAILED
//         Enum:
//             Name: VK_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT
//             Negative: false
//             Extends: VkObjectType
//             Offset: 0
//         Type:
//             Name: VkDebugReportCallbackEXT
//         Type:
//             Name: PFN_vkDebugReportCallbackEXT
//         Type:
//             Name: VkDebugReportFlagBitsEXT
//         Type:
//             Name: VkDebugReportFlagsEXT
//         Type:
//             Name: VkDebugReportObjectTypeEXT
//         Type:
//             Name: VkDebugReportCallbackCreateInfoEXT
//         Command:
//             Name: vkCreateDebugReportCallbackEXT
//         Command:
//             Name: vkDestroyDebugReportCallbackEXT
//         Command:
//             Name: vkDebugReportMessageEXT
//     Depends: VK_VERSION_1_1
//         Comment:
//             This duplicates definitions in other extensions, below
//         Enum:
//             Name: VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT
//             Negative: false
//             Extends: VkDebugReportObjectTypeEXT
//             Extnumber: 157
//             Offset: 0
//         Enum:
//             Name: VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_EXT
//             Negative: false
//             Extends: VkDebugReportObjectTypeEXT
//             Extnumber: 86
//             Offset: 0
// Extension: VK_NV_glsl_shader
// Number: 13
// Type: device
// Author: NV
// Supported: supported
// Deprecated by: 
// Unlocks:
//         Enum:
//             Name: VK_NV_GLSL_SHADER_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_NV_GLSL_SHADER_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_glsl_shader&quot;
//         Enum:
//             Name: VK_ERROR_INVALID_SHADER_NV
//             Negative: true
//             Extends: VkResult
//             Offset: 0
// Extension: VK_EXT_depth_range_unrestricted
// Number: 14
// Type: device
// Author: NV
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_DEPTH_RANGE_UNRESTRICTED_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_DEPTH_RANGE_UNRESTRICTED_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_depth_range_unrestricted&quot;
// Extension: VK_KHR_sampler_mirror_clamp_to_edge
// Number: 15
// Type: device
// Author: KHR
// Supported: supported
// Promoted to: VK_VERSION_1_2
// Unlocks:
//         Enum:
//             Name: VK_KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE_SPEC_VERSION
//             Negative: false
//             Value: 3
//         Enum:
//             Name: VK_KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_sampler_mirror_clamp_to_edge&quot;
//         Enum:
//             Name: VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE
//             Negative: false
//             Value: 4
//             Extends: VkSamplerAddressMode
//             Comment:
//                 Note that this defines what was previously a core enum, and so uses the 'value' attribute rather than 'offset', and does not have a suffix. This is a special case, and should not be repeated
//         Enum:
//             Name: VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE_KHR
//             Negative: false
//             Extends: VkSamplerAddressMode
//             Alias: VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE
//             Comment:
//                 Introduced for consistency with extension suffixing rules
// Extension: VK_IMG_filter_cubic
// Number: 16
// Type: device
// Author: IMG
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_IMG_FILTER_CUBIC_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_IMG_FILTER_CUBIC_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_IMG_filter_cubic&quot;
//         Enum:
//             Name: VK_FILTER_CUBIC_IMG
//             Negative: false
//             Extends: VkFilter
//             Alias: VK_FILTER_CUBIC_EXT
//         Enum:
//             Name: VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG
//             Negative: false
//             Extends: VkFormatFeatureFlagBits
//             Alias: VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT
//             Comment:
//                 Format can be filtered with VK_FILTER_CUBIC_IMG when being sampled
// Extension: VK_AMD_extension_17
// Number: 17
// Type: invalid
// Author: AMD
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_AMD_EXTENSION_17_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_AMD_EXTENSION_17_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_extension_17&quot;
// Extension: VK_AMD_extension_18
// Number: 18
// Type: invalid
// Author: AMD
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_AMD_EXTENSION_18_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_AMD_EXTENSION_18_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_extension_18&quot;
// Extension: VK_AMD_rasterization_order
// Number: 19
// Type: device
// Author: AMD
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_AMD_RASTERIZATION_ORDER_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_AMD_RASTERIZATION_ORDER_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_rasterization_order&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkRasterizationOrderAMD
//         Type:
//             Name: VkPipelineRasterizationStateRasterizationOrderAMD
// Extension: VK_AMD_extension_20
// Number: 20
// Type: invalid
// Author: AMD
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_AMD_EXTENSION_20_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_AMD_EXTENSION_20_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_extension_20&quot;
// Extension: VK_AMD_shader_trinary_minmax
// Number: 21
// Type: device
// Author: AMD
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_AMD_SHADER_TRINARY_MINMAX_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_AMD_SHADER_TRINARY_MINMAX_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_shader_trinary_minmax&quot;
// Extension: VK_AMD_shader_explicit_vertex_parameter
// Number: 22
// Type: device
// Author: AMD
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_AMD_SHADER_EXPLICIT_VERTEX_PARAMETER_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_AMD_SHADER_EXPLICIT_VERTEX_PARAMETER_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_shader_explicit_vertex_parameter&quot;
// Extension: VK_EXT_debug_marker
// Number: 23
// Type: device
// Author: Baldur Karlsson
// Depends: VK_EXT_debug_report
// Supported: supported
// Promoted to: VK_EXT_debug_utils
// Unlocks:
//         Enum:
//             Name: VK_EXT_DEBUG_MARKER_SPEC_VERSION
//             Negative: false
//             Value: 4
//         Enum:
//             Name: VK_EXT_DEBUG_MARKER_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_debug_marker&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Type:
//             Name: VkDebugReportObjectTypeEXT
//         Type:
//             Name: VkDebugMarkerObjectNameInfoEXT
//         Type:
//             Name: VkDebugMarkerObjectTagInfoEXT
//         Type:
//             Name: VkDebugMarkerMarkerInfoEXT
//         Command:
//             Name: vkDebugMarkerSetObjectTagEXT
//         Command:
//             Name: vkDebugMarkerSetObjectNameEXT
//         Command:
//             Name: vkCmdDebugMarkerBeginEXT
//         Command:
//             Name: vkCmdDebugMarkerEndEXT
//         Command:
//             Name: vkCmdDebugMarkerInsertEXT
// Extension: VK_KHR_video_queue
// Number: 24
// Type: device
// Author: KHR
// Depends: (VK_VERSION_1_1+VK_KHR_synchronization2),VK_VERSION_1_3
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_VIDEO_QUEUE_SPEC_VERSION
//             Negative: false
//             Value: 8
//         Enum:
//             Name: VK_KHR_VIDEO_QUEUE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_video_queue&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_PROFILE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_CAPABILITIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_PICTURE_RESOURCE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_SESSION_MEMORY_REQUIREMENTS_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Enum:
//             Name: VK_STRUCTURE_TYPE_BIND_VIDEO_SESSION_MEMORY_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 4
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_SESSION_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 5
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 6
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_UPDATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 7
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_BEGIN_CODING_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 8
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_END_CODING_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 9
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_CODING_CONTROL_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 10
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_REFERENCE_SLOT_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 11
//         Enum:
//             Name: VK_STRUCTURE_TYPE_QUEUE_FAMILY_VIDEO_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 12
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 13
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_FORMAT_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 14
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_FORMAT_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 15
//         Enum:
//             Name: VK_STRUCTURE_TYPE_QUEUE_FAMILY_QUERY_RESULT_STATUS_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 16
//         Enum:
//             Name: VK_OBJECT_TYPE_VIDEO_SESSION_KHR
//             Negative: false
//             Extends: VkObjectType
//             Offset: 0
//             Comment:
//                 VkVideoSessionKHR
//         Enum:
//             Name: VK_OBJECT_TYPE_VIDEO_SESSION_PARAMETERS_KHR
//             Negative: false
//             Extends: VkObjectType
//             Offset: 1
//             Comment:
//                 VkVideoSessionParametersKHR
//         Enum:
//             Name: VK_QUERY_TYPE_RESULT_STATUS_ONLY_KHR
//             Negative: false
//             Extends: VkQueryType
//             Offset: 0
//         Enum:
//             Name: VK_QUERY_RESULT_WITH_STATUS_BIT_KHR
//             Negative: false
//             Bitpos: 4
//             Extends: VkQueryResultFlagBits
//         Enum:
//             Name: VK_ERROR_IMAGE_USAGE_NOT_SUPPORTED_KHR
//             Negative: true
//             Extends: VkResult
//             Offset: 0
//         Enum:
//             Name: VK_ERROR_VIDEO_PICTURE_LAYOUT_NOT_SUPPORTED_KHR
//             Negative: true
//             Extends: VkResult
//             Offset: 1
//         Enum:
//             Name: VK_ERROR_VIDEO_PROFILE_OPERATION_NOT_SUPPORTED_KHR
//             Negative: true
//             Extends: VkResult
//             Offset: 2
//         Enum:
//             Name: VK_ERROR_VIDEO_PROFILE_FORMAT_NOT_SUPPORTED_KHR
//             Negative: true
//             Extends: VkResult
//             Offset: 3
//         Enum:
//             Name: VK_ERROR_VIDEO_PROFILE_CODEC_NOT_SUPPORTED_KHR
//             Negative: true
//             Extends: VkResult
//             Offset: 4
//         Enum:
//             Name: VK_ERROR_VIDEO_STD_VERSION_NOT_SUPPORTED_KHR
//             Negative: true
//             Extends: VkResult
//             Offset: 5
//         Type:
//             Name: VkVideoSessionKHR
//         Type:
//             Name: VkVideoSessionParametersKHR
//         Type:
//             Name: VkVideoCodecOperationFlagBitsKHR
//         Type:
//             Name: VkVideoCodecOperationFlagsKHR
//         Type:
//             Name: VkVideoChromaSubsamplingFlagBitsKHR
//         Type:
//             Name: VkVideoChromaSubsamplingFlagsKHR
//         Type:
//             Name: VkVideoComponentBitDepthFlagBitsKHR
//         Type:
//             Name: VkVideoComponentBitDepthFlagsKHR
//         Type:
//             Name: VkVideoCapabilityFlagBitsKHR
//         Type:
//             Name: VkVideoCapabilityFlagsKHR
//         Type:
//             Name: VkVideoSessionCreateFlagBitsKHR
//         Type:
//             Name: VkVideoSessionCreateFlagsKHR
//         Type:
//             Name: VkVideoSessionParametersCreateFlagsKHR
//         Type:
//             Name: VkVideoBeginCodingFlagsKHR
//         Type:
//             Name: VkVideoEndCodingFlagsKHR
//         Type:
//             Name: VkVideoCodingControlFlagBitsKHR
//         Type:
//             Name: VkVideoCodingControlFlagsKHR
//         Type:
//             Name: VkQueueFamilyQueryResultStatusPropertiesKHR
//         Type:
//             Name: VkQueryResultStatusKHR
//         Type:
//             Name: VkQueueFamilyVideoPropertiesKHR
//         Type:
//             Name: VkVideoProfileInfoKHR
//         Type:
//             Name: VkVideoProfileListInfoKHR
//         Type:
//             Name: VkVideoCapabilitiesKHR
//         Type:
//             Name: VkPhysicalDeviceVideoFormatInfoKHR
//         Type:
//             Name: VkVideoFormatPropertiesKHR
//         Type:
//             Name: VkVideoPictureResourceInfoKHR
//         Type:
//             Name: VkVideoReferenceSlotInfoKHR
//         Type:
//             Name: VkVideoSessionMemoryRequirementsKHR
//         Type:
//             Name: VkBindVideoSessionMemoryInfoKHR
//         Type:
//             Name: VkVideoSessionCreateInfoKHR
//         Type:
//             Name: VkVideoSessionParametersCreateInfoKHR
//         Type:
//             Name: VkVideoSessionParametersUpdateInfoKHR
//         Type:
//             Name: VkVideoBeginCodingInfoKHR
//         Type:
//             Name: VkVideoEndCodingInfoKHR
//         Type:
//             Name: VkVideoCodingControlInfoKHR
//         Command:
//             Name: vkGetPhysicalDeviceVideoCapabilitiesKHR
//         Command:
//             Name: vkGetPhysicalDeviceVideoFormatPropertiesKHR
//         Command:
//             Name: vkCreateVideoSessionKHR
//         Command:
//             Name: vkDestroyVideoSessionKHR
//         Command:
//             Name: vkGetVideoSessionMemoryRequirementsKHR
//         Command:
//             Name: vkBindVideoSessionMemoryKHR
//         Command:
//             Name: vkCreateVideoSessionParametersKHR
//         Command:
//             Name: vkUpdateVideoSessionParametersKHR
//         Command:
//             Name: vkDestroyVideoSessionParametersKHR
//         Command:
//             Name: vkCmdBeginVideoCodingKHR
//         Command:
//             Name: vkCmdEndVideoCodingKHR
//         Command:
//             Name: vkCmdControlVideoCodingKHR
// Extension: VK_KHR_video_decode_queue
// Number: 25
// Type: device
// Author: KHR
// Depends: VK_KHR_video_queue+(VK_KHR_synchronization2,VK_VERSION_1_3)
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_VIDEO_DECODE_QUEUE_SPEC_VERSION
//             Negative: false
//             Value: 8
//         Enum:
//             Name: VK_KHR_VIDEO_DECODE_QUEUE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_video_decode_queue&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_DECODE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_DECODE_CAPABILITIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_DECODE_USAGE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_QUEUE_VIDEO_DECODE_BIT_KHR
//             Negative: false
//             Bitpos: 5
//             Extends: VkQueueFlagBits
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_VIDEO_DECODE_BIT_KHR
//             Negative: false
//             Bitpos: 26
//             Extends: VkPipelineStageFlagBits2
//         Enum:
//             Name: VK_ACCESS_2_VIDEO_DECODE_READ_BIT_KHR
//             Negative: false
//             Bitpos: 35
//             Extends: VkAccessFlagBits2
//         Enum:
//             Name: VK_ACCESS_2_VIDEO_DECODE_WRITE_BIT_KHR
//             Negative: false
//             Bitpos: 36
//             Extends: VkAccessFlagBits2
//         Enum:
//             Name: VK_BUFFER_USAGE_VIDEO_DECODE_SRC_BIT_KHR
//             Negative: false
//             Bitpos: 13
//             Extends: VkBufferUsageFlagBits
//         Enum:
//             Name: VK_BUFFER_USAGE_VIDEO_DECODE_DST_BIT_KHR
//             Negative: false
//             Bitpos: 14
//             Extends: VkBufferUsageFlagBits
//         Enum:
//             Name: VK_IMAGE_USAGE_VIDEO_DECODE_DST_BIT_KHR
//             Negative: false
//             Bitpos: 10
//             Extends: VkImageUsageFlagBits
//         Enum:
//             Name: VK_IMAGE_USAGE_VIDEO_DECODE_SRC_BIT_KHR
//             Negative: false
//             Bitpos: 11
//             Extends: VkImageUsageFlagBits
//         Enum:
//             Name: VK_IMAGE_USAGE_VIDEO_DECODE_DPB_BIT_KHR
//             Negative: false
//             Bitpos: 12
//             Extends: VkImageUsageFlagBits
//         Enum:
//             Name: VK_FORMAT_FEATURE_VIDEO_DECODE_OUTPUT_BIT_KHR
//             Negative: false
//             Bitpos: 25
//             Extends: VkFormatFeatureFlagBits
//         Enum:
//             Name: VK_FORMAT_FEATURE_VIDEO_DECODE_DPB_BIT_KHR
//             Negative: false
//             Bitpos: 26
//             Extends: VkFormatFeatureFlagBits
//         Enum:
//             Name: VK_IMAGE_LAYOUT_VIDEO_DECODE_DST_KHR
//             Negative: false
//             Extends: VkImageLayout
//             Offset: 0
//         Enum:
//             Name: VK_IMAGE_LAYOUT_VIDEO_DECODE_SRC_KHR
//             Negative: false
//             Extends: VkImageLayout
//             Offset: 1
//         Enum:
//             Name: VK_IMAGE_LAYOUT_VIDEO_DECODE_DPB_KHR
//             Negative: false
//             Extends: VkImageLayout
//             Offset: 2
//         Type:
//             Name: VkVideoDecodeCapabilityFlagBitsKHR
//         Type:
//             Name: VkVideoDecodeCapabilityFlagsKHR
//         Type:
//             Name: VkVideoDecodeCapabilitiesKHR
//         Type:
//             Name: VkVideoDecodeUsageFlagBitsKHR
//         Type:
//             Name: VkVideoDecodeUsageFlagsKHR
//         Type:
//             Name: VkVideoDecodeUsageInfoKHR
//         Type:
//             Name: VkVideoDecodeFlagsKHR
//         Type:
//             Name: VkVideoDecodeInfoKHR
//         Command:
//             Name: vkCmdDecodeVideoKHR
//     Depends: VK_KHR_format_feature_flags2,VK_VERSION_1_3
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_VIDEO_DECODE_OUTPUT_BIT_KHR
//             Negative: false
//             Bitpos: 25
//             Extends: VkFormatFeatureFlagBits2
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_VIDEO_DECODE_DPB_BIT_KHR
//             Negative: false
//             Bitpos: 26
//             Extends: VkFormatFeatureFlagBits2
// Extension: VK_AMD_gcn_shader
// Number: 26
// Type: device
// Author: AMD
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_AMD_GCN_SHADER_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_AMD_GCN_SHADER_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_gcn_shader&quot;
// Extension: VK_NV_dedicated_allocation
// Number: 27
// Type: device
// Author: NV
// Supported: supported
// Deprecated by: VK_KHR_dedicated_allocation
// Unlocks:
//         Enum:
//             Name: VK_NV_DEDICATED_ALLOCATION_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_NV_DEDICATED_ALLOCATION_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_dedicated_allocation&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Type:
//             Name: VkDedicatedAllocationImageCreateInfoNV
//         Type:
//             Name: VkDedicatedAllocationBufferCreateInfoNV
//         Type:
//             Name: VkDedicatedAllocationMemoryAllocateInfoNV
// Extension: VK_EXT_extension_28
// Number: 28
// Type: invalid
// Author: NV
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_28_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_28_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_28&quot;
// Extension: VK_EXT_transform_feedback
// Number: 29
// Type: device
// Author: NV
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_TRANSFORM_FEEDBACK_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_TRANSFORM_FEEDBACK_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_transform_feedback&quot;
//         Command:
//             Name: vkCmdBindTransformFeedbackBuffersEXT
//         Command:
//             Name: vkCmdBeginTransformFeedbackEXT
//         Command:
//             Name: vkCmdEndTransformFeedbackEXT
//         Command:
//             Name: vkCmdBeginQueryIndexedEXT
//         Command:
//             Name: vkCmdEndQueryIndexedEXT
//         Command:
//             Name: vkCmdDrawIndirectByteCountEXT
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT
//             Negative: false
//             Extends: VkQueryType
//             Offset: 4
//         Enum:
//             Name: VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT
//             Negative: false
//             Bitpos: 11
//             Extends: VkBufferUsageFlagBits
//         Enum:
//             Name: VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT
//             Negative: false
//             Bitpos: 12
//             Extends: VkBufferUsageFlagBits
//         Enum:
//             Name: VK_ACCESS_TRANSFORM_FEEDBACK_WRITE_BIT_EXT
//             Negative: false
//             Bitpos: 25
//             Extends: VkAccessFlagBits
//         Enum:
//             Name: VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT
//             Negative: false
//             Bitpos: 26
//             Extends: VkAccessFlagBits
//         Enum:
//             Name: VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT
//             Negative: false
//             Bitpos: 27
//             Extends: VkAccessFlagBits
//         Enum:
//             Name: VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT
//             Negative: false
//             Bitpos: 24
//             Extends: VkPipelineStageFlagBits
//         Type:
//             Name: VkPhysicalDeviceTransformFeedbackFeaturesEXT
//         Type:
//             Name: VkPhysicalDeviceTransformFeedbackPropertiesEXT
//         Type:
//             Name: VkPipelineRasterizationStateStreamCreateInfoEXT
//         Type:
//             Name: VkPipelineRasterizationStateStreamCreateFlagsEXT
//         Feature:
//             Name: transformFeedback
//             Struct: VkPhysicalDeviceTransformFeedbackFeaturesEXT
// Extension: VK_NVX_binary_import
// Number: 30
// Type: device
// Author: NVX
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NVX_BINARY_IMPORT_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_NVX_BINARY_IMPORT_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NVX_binary_import&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_CU_MODULE_CREATE_INFO_NVX
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_CU_FUNCTION_CREATE_INFO_NVX
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_CU_LAUNCH_INFO_NVX
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_CU_MODULE_TEXTURING_MODE_CREATE_INFO_NVX
//             Negative: false
//             Extends: VkStructureType
//             Offset: 4
//         Enum:
//             Name: VK_OBJECT_TYPE_CU_MODULE_NVX
//             Negative: false
//             Extends: VkObjectType
//             Offset: 0
//         Enum:
//             Name: VK_OBJECT_TYPE_CU_FUNCTION_NVX
//             Negative: false
//             Extends: VkObjectType
//             Offset: 1
//         Type:
//             Name: VkCuModuleNVX
//         Type:
//             Name: VkCuFunctionNVX
//         Type:
//             Name: VkCuModuleCreateInfoNVX
//         Type:
//             Name: VkCuModuleTexturingModeCreateInfoNVX
//         Type:
//             Name: VkCuFunctionCreateInfoNVX
//         Type:
//             Name: VkCuLaunchInfoNVX
//         Command:
//             Name: vkCreateCuModuleNVX
//         Command:
//             Name: vkCreateCuFunctionNVX
//         Command:
//             Name: vkDestroyCuModuleNVX
//         Command:
//             Name: vkDestroyCuFunctionNVX
//         Command:
//             Name: vkCmdCuLaunchKernelNVX
//     Depends: VK_EXT_debug_report
//         Enum:
//             Name: VK_DEBUG_REPORT_OBJECT_TYPE_CU_MODULE_NVX_EXT
//             Negative: false
//             Extends: VkDebugReportObjectTypeEXT
//             Offset: 0
//         Enum:
//             Name: VK_DEBUG_REPORT_OBJECT_TYPE_CU_FUNCTION_NVX_EXT
//             Negative: false
//             Extends: VkDebugReportObjectTypeEXT
//             Offset: 1
// Extension: VK_NVX_image_view_handle
// Number: 31
// Type: device
// Author: NVX
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NVX_IMAGE_VIEW_HANDLE_SPEC_VERSION
//             Negative: false
//             Value: 3
//         Enum:
//             Name: VK_NVX_IMAGE_VIEW_HANDLE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NVX_image_view_handle&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMAGE_VIEW_HANDLE_INFO_NVX
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMAGE_VIEW_ADDRESS_PROPERTIES_NVX
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Type:
//             Name: VkImageViewHandleInfoNVX
//         Type:
//             Name: VkImageViewAddressPropertiesNVX
//         Command:
//             Name: vkGetImageViewHandleNVX
//         Command:
//             Name: vkGetImageViewHandle64NVX
//         Command:
//             Name: vkGetImageViewAddressNVX
// Extension: VK_AMD_extension_32
// Number: 32
// Type: invalid
// Author: AMD
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_AMD_EXTENSION_32_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_AMD_EXTENSION_32_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_extension_32&quot;
// Extension: VK_AMD_extension_33
// Number: 33
// Type: invalid
// Author: AMD
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_AMD_EXTENSION_33_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_AMD_EXTENSION_33_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_extension_33&quot;
// Extension: VK_AMD_draw_indirect_count
// Number: 34
// Type: device
// Author: AMD
// Supported: supported
// Promoted to: VK_KHR_draw_indirect_count
// Unlocks:
//         Enum:
//             Name: VK_AMD_DRAW_INDIRECT_COUNT_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_AMD_DRAW_INDIRECT_COUNT_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_draw_indirect_count&quot;
//         Command:
//             Name: vkCmdDrawIndirectCountAMD
//         Command:
//             Name: vkCmdDrawIndexedIndirectCountAMD
// Extension: VK_AMD_extension_35
// Number: 35
// Type: invalid
// Author: AMD
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_AMD_EXTENSION_35_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_AMD_EXTENSION_35_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_extension_35&quot;
// Extension: VK_AMD_negative_viewport_height
// Number: 36
// Type: device
// Author: AMD
// Supported: supported
// Obsoleted by: VK_KHR_maintenance1
// Unlocks:
//         Enum:
//             Name: VK_AMD_NEGATIVE_VIEWPORT_HEIGHT_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_AMD_NEGATIVE_VIEWPORT_HEIGHT_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_negative_viewport_height&quot;
// Extension: VK_AMD_gpu_shader_half_float
// Number: 37
// Type: device
// Author: AMD
// Supported: supported
// Deprecated by: VK_KHR_shader_float16_int8
// Unlocks:
//         Enum:
//             Name: VK_AMD_GPU_SHADER_HALF_FLOAT_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_AMD_GPU_SHADER_HALF_FLOAT_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_gpu_shader_half_float&quot;
// Extension: VK_AMD_shader_ballot
// Number: 38
// Type: device
// Author: AMD
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_AMD_SHADER_BALLOT_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_AMD_SHADER_BALLOT_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_shader_ballot&quot;
// Extension: VK_KHR_video_encode_h264
// Number: 39
// Type: device
// Author: KHR
// Depends: VK_KHR_video_encode_queue
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_VIDEO_ENCODE_H264_SPEC_VERSION
//             Negative: false
//             Value: 14
//         Enum:
//             Name: VK_KHR_VIDEO_ENCODE_H264_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_video_encode_h264&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_CAPABILITIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PICTURE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_DPB_SLOT_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 4
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_NALU_SLICE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 5
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_GOP_REMAINING_FRAME_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 6
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PROFILE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 7
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 8
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_LAYER_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 9
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 10
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_QUALITY_LEVEL_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 11
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_GET_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 12
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_FEEDBACK_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 13
//         Enum:
//             Name: VK_VIDEO_CODEC_OPERATION_ENCODE_H264_BIT_KHR
//             Negative: false
//             Bitpos: 16
//             Extends: VkVideoCodecOperationFlagBitsKHR
//         Type:
//             Name: VkVideoEncodeH264CapabilityFlagBitsKHR
//         Type:
//             Name: VkVideoEncodeH264CapabilityFlagsKHR
//         Type:
//             Name: VkVideoEncodeH264StdFlagBitsKHR
//         Type:
//             Name: VkVideoEncodeH264StdFlagsKHR
//         Type:
//             Name: VkVideoEncodeH264CapabilitiesKHR
//         Type:
//             Name: VkVideoEncodeH264QualityLevelPropertiesKHR
//         Type:
//             Name: VkVideoEncodeH264SessionCreateInfoKHR
//         Type:
//             Name: VkVideoEncodeH264SessionParametersCreateInfoKHR
//         Type:
//             Name: VkVideoEncodeH264SessionParametersAddInfoKHR
//         Type:
//             Name: VkVideoEncodeH264SessionParametersGetInfoKHR
//         Type:
//             Name: VkVideoEncodeH264SessionParametersFeedbackInfoKHR
//         Type:
//             Name: VkVideoEncodeH264PictureInfoKHR
//         Type:
//             Name: VkVideoEncodeH264DpbSlotInfoKHR
//         Type:
//             Name: VkVideoEncodeH264NaluSliceInfoKHR
//         Type:
//             Name: VkVideoEncodeH264ProfileInfoKHR
//         Type:
//             Name: VkVideoEncodeH264RateControlInfoKHR
//         Type:
//             Name: VkVideoEncodeH264RateControlFlagBitsKHR
//         Type:
//             Name: VkVideoEncodeH264RateControlFlagsKHR
//         Type:
//             Name: VkVideoEncodeH264RateControlLayerInfoKHR
//         Type:
//             Name: VkVideoEncodeH264QpKHR
//         Type:
//             Name: VkVideoEncodeH264FrameSizeKHR
//         Type:
//             Name: VkVideoEncodeH264GopRemainingFrameInfoKHR
// Extension: VK_KHR_video_encode_h265
// Number: 40
// Type: device
// Author: KHR
// Depends: VK_KHR_video_encode_queue
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_VIDEO_ENCODE_H265_SPEC_VERSION
//             Negative: false
//             Value: 14
//         Enum:
//             Name: VK_KHR_VIDEO_ENCODE_H265_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_video_encode_h265&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_CAPABILITIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PICTURE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_DPB_SLOT_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 4
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_NALU_SLICE_SEGMENT_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 5
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_GOP_REMAINING_FRAME_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 6
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PROFILE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 7
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 9
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_LAYER_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 10
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 11
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_QUALITY_LEVEL_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 12
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_GET_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 13
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_FEEDBACK_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 14
//         Enum:
//             Name: VK_VIDEO_CODEC_OPERATION_ENCODE_H265_BIT_KHR
//             Negative: false
//             Bitpos: 17
//             Extends: VkVideoCodecOperationFlagBitsKHR
//         Type:
//             Name: VkVideoEncodeH265CapabilityFlagBitsKHR
//         Type:
//             Name: VkVideoEncodeH265CapabilityFlagsKHR
//         Type:
//             Name: VkVideoEncodeH265StdFlagBitsKHR
//         Type:
//             Name: VkVideoEncodeH265StdFlagsKHR
//         Type:
//             Name: VkVideoEncodeH265CtbSizeFlagBitsKHR
//         Type:
//             Name: VkVideoEncodeH265CtbSizeFlagsKHR
//         Type:
//             Name: VkVideoEncodeH265TransformBlockSizeFlagBitsKHR
//         Type:
//             Name: VkVideoEncodeH265TransformBlockSizeFlagsKHR
//         Type:
//             Name: VkVideoEncodeH265CapabilitiesKHR
//         Type:
//             Name: VkVideoEncodeH265SessionCreateInfoKHR
//         Type:
//             Name: VkVideoEncodeH265QualityLevelPropertiesKHR
//         Type:
//             Name: VkVideoEncodeH265SessionParametersCreateInfoKHR
//         Type:
//             Name: VkVideoEncodeH265SessionParametersAddInfoKHR
//         Type:
//             Name: VkVideoEncodeH265SessionParametersGetInfoKHR
//         Type:
//             Name: VkVideoEncodeH265SessionParametersFeedbackInfoKHR
//         Type:
//             Name: VkVideoEncodeH265PictureInfoKHR
//         Type:
//             Name: VkVideoEncodeH265DpbSlotInfoKHR
//         Type:
//             Name: VkVideoEncodeH265NaluSliceSegmentInfoKHR
//         Type:
//             Name: VkVideoEncodeH265ProfileInfoKHR
//         Type:
//             Name: VkVideoEncodeH265RateControlInfoKHR
//         Type:
//             Name: VkVideoEncodeH265RateControlFlagBitsKHR
//         Type:
//             Name: VkVideoEncodeH265RateControlFlagsKHR
//         Type:
//             Name: VkVideoEncodeH265RateControlLayerInfoKHR
//         Type:
//             Name: VkVideoEncodeH265QpKHR
//         Type:
//             Name: VkVideoEncodeH265FrameSizeKHR
//         Type:
//             Name: VkVideoEncodeH265GopRemainingFrameInfoKHR
// Extension: VK_KHR_video_decode_h264
// Number: 41
// Type: device
// Author: KHR
// Depends: VK_KHR_video_decode_queue
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_VIDEO_DECODE_H264_SPEC_VERSION
//             Negative: false
//             Value: 9
//         Enum:
//             Name: VK_KHR_VIDEO_DECODE_H264_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_video_decode_h264&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_CAPABILITIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PICTURE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PROFILE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 4
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 5
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_DPB_SLOT_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 6
//         Enum:
//             Name: VK_VIDEO_CODEC_OPERATION_DECODE_H264_BIT_KHR
//             Negative: false
//             Bitpos: 0
//             Extends: VkVideoCodecOperationFlagBitsKHR
//         Type:
//             Name: VkVideoDecodeH264PictureLayoutFlagBitsKHR
//         Type:
//             Name: VkVideoDecodeH264PictureLayoutFlagsKHR
//         Type:
//             Name: VkVideoDecodeH264ProfileInfoKHR
//         Type:
//             Name: VkVideoDecodeH264CapabilitiesKHR
//         Type:
//             Name: VkVideoDecodeH264SessionParametersCreateInfoKHR
//         Type:
//             Name: VkVideoDecodeH264SessionParametersAddInfoKHR
//         Type:
//             Name: VkVideoDecodeH264PictureInfoKHR
//         Type:
//             Name: VkVideoDecodeH264DpbSlotInfoKHR
// Extension: VK_AMD_texture_gather_bias_lod
// Number: 42
// Type: device
// Author: AMD
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_AMD_TEXTURE_GATHER_BIAS_LOD_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_AMD_TEXTURE_GATHER_BIAS_LOD_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_texture_gather_bias_lod&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkTextureLODGatherFormatPropertiesAMD
// Extension: VK_AMD_shader_info
// Number: 43
// Type: device
// Author: AMD
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_AMD_SHADER_INFO_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_AMD_SHADER_INFO_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_shader_info&quot;
//         Type:
//             Name: VkShaderInfoTypeAMD
//         Type:
//             Name: VkShaderResourceUsageAMD
//         Type:
//             Name: VkShaderStatisticsInfoAMD
//         Command:
//             Name: vkGetShaderInfoAMD
// Extension: VK_AMD_extension_44
// Number: 44
// Type: invalid
// Author: AMD
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_AMD_EXTENSION_44_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_AMD_EXTENSION_44_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_extension_44&quot;
// Extension: VK_KHR_dynamic_rendering
// Number: 45
// Type: device
// Author: KHR
// Depends: ((VK_KHR_get_physical_device_properties2,VK_VERSION_1_1)+VK_KHR_depth_stencil_resolve),VK_VERSION_1_2
// Supported: supported
// Promoted to: VK_VERSION_1_3
// Unlocks:
//         Enum:
//             Name: VK_KHR_DYNAMIC_RENDERING_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_DYNAMIC_RENDERING_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_dynamic_rendering&quot;
//         Command:
//             Name: vkCmdBeginRenderingKHR
//         Command:
//             Name: vkCmdEndRenderingKHR
//         Enum:
//             Name: VK_STRUCTURE_TYPE_RENDERING_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_RENDERING_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES
//         Enum:
//             Name: VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO
//         Enum:
//             Name: VK_ATTACHMENT_STORE_OP_NONE_KHR
//             Negative: false
//             Extends: VkAttachmentStoreOp
//             Alias: VK_ATTACHMENT_STORE_OP_NONE
//         Enum:
//             Name: VK_RENDERING_CONTENTS_SECONDARY_COMMAND_BUFFERS_BIT_KHR
//             Negative: false
//             Extends: VkRenderingFlagBits
//             Alias: VK_RENDERING_CONTENTS_SECONDARY_COMMAND_BUFFERS_BIT
//         Enum:
//             Name: VK_RENDERING_SUSPENDING_BIT_KHR
//             Negative: false
//             Extends: VkRenderingFlagBits
//             Alias: VK_RENDERING_SUSPENDING_BIT
//         Enum:
//             Name: VK_RENDERING_RESUMING_BIT_KHR
//             Negative: false
//             Extends: VkRenderingFlagBits
//             Alias: VK_RENDERING_RESUMING_BIT
//         Type:
//             Name: VkRenderingInfoKHR
//         Type:
//             Name: VkRenderingAttachmentInfoKHR
//         Type:
//             Name: VkPipelineRenderingCreateInfoKHR
//         Type:
//             Name: VkPhysicalDeviceDynamicRenderingFeaturesKHR
//         Type:
//             Name: VkCommandBufferInheritanceRenderingInfoKHR
//         Type:
//             Name: VkRenderingFlagsKHR
//         Type:
//             Name: VkRenderingFlagBitsKHR
//         Feature:
//             Name: dynamicRendering
//             Struct: VkPhysicalDeviceDynamicRenderingFeaturesKHR
// Extension: VK_AMD_extension_46
// Number: 46
// Type: invalid
// Author: AMD
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_AMD_EXTENSION_46_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_AMD_EXTENSION_46_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_extension_46&quot;
// Extension: VK_AMD_shader_image_load_store_lod
// Number: 47
// Type: device
// Author: AMD
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_AMD_SHADER_IMAGE_LOAD_STORE_LOD_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_AMD_SHADER_IMAGE_LOAD_STORE_LOD_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_shader_image_load_store_lod&quot;
// Extension: VK_NVX_extension_48
// Number: 48
// Type: invalid
// Author: NVX
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_NVX_EXTENSION_48_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_NVX_EXTENSION_48_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NVX_extension_48&quot;
// Extension: VK_GOOGLE_extension_49
// Number: 49
// Type: invalid
// Author: GOOGLE
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_GOOGLE_EXTENSION_49_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_GOOGLE_EXTENSION_49_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_GOOGLE_extension_49&quot;
// Extension: VK_GGP_stream_descriptor_surface
// Number: 50
// Type: instance
// Author: GGP
// Depends: VK_KHR_surface
// Platform: ggp
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_GGP_STREAM_DESCRIPTOR_SURFACE_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_GGP_STREAM_DESCRIPTOR_SURFACE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_GGP_stream_descriptor_surface&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_STREAM_DESCRIPTOR_SURFACE_CREATE_INFO_GGP
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkStreamDescriptorSurfaceCreateFlagsGGP
//         Type:
//             Name: VkStreamDescriptorSurfaceCreateInfoGGP
//         Command:
//             Name: vkCreateStreamDescriptorSurfaceGGP
// Extension: VK_NV_corner_sampled_image
// Number: 51
// Type: device
// Author: NV
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NV_CORNER_SAMPLED_IMAGE_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_NV_CORNER_SAMPLED_IMAGE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_corner_sampled_image&quot;
//         Enum:
//             Name: VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV
//             Negative: false
//             Bitpos: 13
//             Extends: VkImageCreateFlagBits
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceCornerSampledImageFeaturesNV
//         Feature:
//             Name: cornerSampledImage
//             Struct: VkPhysicalDeviceCornerSampledImageFeaturesNV
// Extension: VK_NV_private_vendor_info
// Number: 52
// Type: device
// Author: NV
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NV_PRIVATE_VENDOR_INFO_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_NV_PRIVATE_VENDOR_INFO_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_private_vendor_info&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PRIVATE_VENDOR_INFO_PLACEHOLDER_OFFSET_0_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
// Extension: VK_NV_extension_53
// Number: 53
// Type: invalid
// Author: NV
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_NV_EXTENSION_53_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_NV_EXTENSION_53_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_extension_53&quot;
// Extension: VK_KHR_multiview
// Number: 54
// Type: device
// Author: KHR
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_1
// Unlocks:
//         Enum:
//             Name: VK_KHR_MULTIVIEW_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_MULTIVIEW_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_multiview&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES
//         Enum:
//             Name: VK_DEPENDENCY_VIEW_LOCAL_BIT_KHR
//             Negative: false
//             Extends: VkDependencyFlagBits
//             Alias: VK_DEPENDENCY_VIEW_LOCAL_BIT
//         Type:
//             Name: VkRenderPassMultiviewCreateInfoKHR
//         Type:
//             Name: VkPhysicalDeviceMultiviewFeaturesKHR
//         Type:
//             Name: VkPhysicalDeviceMultiviewPropertiesKHR
//         Feature:
//             Name: multiview
//             Struct: VkPhysicalDeviceMultiviewFeaturesKHR
// Extension: VK_IMG_format_pvrtc
// Number: 55
// Type: device
// Author: IMG
// Supported: supported
// Deprecated by: 
// Unlocks:
//         Enum:
//             Name: VK_IMG_FORMAT_PVRTC_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_IMG_FORMAT_PVRTC_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_IMG_format_pvrtc&quot;
//         Enum:
//             Name: VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG
//             Negative: false
//             Extends: VkFormat
//             Offset: 0
//         Enum:
//             Name: VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG
//             Negative: false
//             Extends: VkFormat
//             Offset: 1
//         Enum:
//             Name: VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG
//             Negative: false
//             Extends: VkFormat
//             Offset: 2
//         Enum:
//             Name: VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG
//             Negative: false
//             Extends: VkFormat
//             Offset: 3
//         Enum:
//             Name: VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG
//             Negative: false
//             Extends: VkFormat
//             Offset: 4
//         Enum:
//             Name: VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG
//             Negative: false
//             Extends: VkFormat
//             Offset: 5
//         Enum:
//             Name: VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG
//             Negative: false
//             Extends: VkFormat
//             Offset: 6
//         Enum:
//             Name: VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG
//             Negative: false
//             Extends: VkFormat
//             Offset: 7
// Extension: VK_NV_external_memory_capabilities
// Number: 56
// Type: instance
// Author: NV
// Supported: supported
// Deprecated by: VK_KHR_external_memory_capabilities
// Unlocks:
//         Enum:
//             Name: VK_NV_EXTERNAL_MEMORY_CAPABILITIES_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_NV_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_external_memory_capabilities&quot;
//         Type:
//             Name: VkExternalMemoryHandleTypeFlagsNV
//         Type:
//             Name: VkExternalMemoryHandleTypeFlagBitsNV
//         Type:
//             Name: VkExternalMemoryFeatureFlagsNV
//         Type:
//             Name: VkExternalMemoryFeatureFlagBitsNV
//         Type:
//             Name: VkExternalImageFormatPropertiesNV
//         Command:
//             Name: vkGetPhysicalDeviceExternalImageFormatPropertiesNV
// Extension: VK_NV_external_memory
// Number: 57
// Type: device
// Author: NV
// Depends: VK_NV_external_memory_capabilities
// Supported: supported
// Deprecated by: VK_KHR_external_memory
// Unlocks:
//         Enum:
//             Name: VK_NV_EXTERNAL_MEMORY_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_NV_EXTERNAL_MEMORY_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_external_memory&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Type:
//             Name: VkExternalMemoryImageCreateInfoNV
//         Type:
//             Name: VkExportMemoryAllocateInfoNV
// Extension: VK_NV_external_memory_win32
// Number: 58
// Type: device
// Author: NV
// Depends: VK_NV_external_memory
// Platform: win32
// Supported: supported
// Deprecated by: VK_KHR_external_memory_win32
// Unlocks:
//         Enum:
//             Name: VK_NV_EXTERNAL_MEMORY_WIN32_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_NV_EXTERNAL_MEMORY_WIN32_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_external_memory_win32&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Type:
//             Name: VkImportMemoryWin32HandleInfoNV
//         Type:
//             Name: VkExportMemoryWin32HandleInfoNV
//         Command:
//             Name: vkGetMemoryWin32HandleNV
// Extension: VK_NV_win32_keyed_mutex
// Number: 59
// Type: device
// Author: NV
// Depends: VK_NV_external_memory_win32
// Platform: win32
// Supported: supported
// Promoted to: VK_KHR_win32_keyed_mutex
// Unlocks:
//         Enum:
//             Name: VK_NV_WIN32_KEYED_MUTEX_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_NV_WIN32_KEYED_MUTEX_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_win32_keyed_mutex&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkWin32KeyedMutexAcquireReleaseInfoNV
// Extension: VK_KHR_get_physical_device_properties2
// Number: 60
// Type: instance
// Author: KHR
// Supported: supported
// Promoted to: VK_VERSION_1_1
// Unlocks:
//         Enum:
//             Name: VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_get_physical_device_properties2&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2
//         Type:
//             Name: VkPhysicalDeviceFeatures2KHR
//         Type:
//             Name: VkPhysicalDeviceProperties2KHR
//         Type:
//             Name: VkFormatProperties2KHR
//         Type:
//             Name: VkImageFormatProperties2KHR
//         Type:
//             Name: VkPhysicalDeviceImageFormatInfo2KHR
//         Type:
//             Name: VkQueueFamilyProperties2KHR
//         Type:
//             Name: VkPhysicalDeviceMemoryProperties2KHR
//         Type:
//             Name: VkSparseImageFormatProperties2KHR
//         Type:
//             Name: VkPhysicalDeviceSparseImageFormatInfo2KHR
//         Command:
//             Name: vkGetPhysicalDeviceFeatures2KHR
//         Command:
//             Name: vkGetPhysicalDeviceProperties2KHR
//         Command:
//             Name: vkGetPhysicalDeviceFormatProperties2KHR
//         Command:
//             Name: vkGetPhysicalDeviceImageFormatProperties2KHR
//         Command:
//             Name: vkGetPhysicalDeviceQueueFamilyProperties2KHR
//         Command:
//             Name: vkGetPhysicalDeviceMemoryProperties2KHR
//         Command:
//             Name: vkGetPhysicalDeviceSparseImageFormatProperties2KHR
// Extension: VK_KHR_device_group
// Number: 61
// Type: device
// Author: KHR
// Depends: VK_KHR_device_group_creation
// Supported: supported
// Promoted to: VK_VERSION_1_1
// Unlocks:
//         Enum:
//             Name: VK_KHR_DEVICE_GROUP_SPEC_VERSION
//             Negative: false
//             Value: 4
//         Enum:
//             Name: VK_KHR_DEVICE_GROUP_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_device_group&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO
//         Type:
//             Name: VkPeerMemoryFeatureFlagsKHR
//         Type:
//             Name: VkPeerMemoryFeatureFlagBitsKHR
//         Enum:
//             Name: VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT_KHR
//             Negative: false
//             Extends: VkPeerMemoryFeatureFlagBits
//             Alias: VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT
//         Enum:
//             Name: VK_PEER_MEMORY_FEATURE_COPY_DST_BIT_KHR
//             Negative: false
//             Extends: VkPeerMemoryFeatureFlagBits
//             Alias: VK_PEER_MEMORY_FEATURE_COPY_DST_BIT
//         Enum:
//             Name: VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT_KHR
//             Negative: false
//             Extends: VkPeerMemoryFeatureFlagBits
//             Alias: VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT
//         Enum:
//             Name: VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT_KHR
//             Negative: false
//             Extends: VkPeerMemoryFeatureFlagBits
//             Alias: VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT
//         Type:
//             Name: VkMemoryAllocateFlagsKHR
//         Type:
//             Name: VkMemoryAllocateFlagBitsKHR
//         Enum:
//             Name: VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT_KHR
//             Negative: false
//             Extends: VkMemoryAllocateFlagBits
//             Alias: VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT
//         Type:
//             Name: VkMemoryAllocateFlagsInfoKHR
//         Type:
//             Name: VkDeviceGroupRenderPassBeginInfoKHR
//         Type:
//             Name: VkDeviceGroupCommandBufferBeginInfoKHR
//         Type:
//             Name: VkDeviceGroupSubmitInfoKHR
//         Type:
//             Name: VkDeviceGroupBindSparseInfoKHR
//         Command:
//             Name: vkGetDeviceGroupPeerMemoryFeaturesKHR
//         Command:
//             Name: vkCmdSetDeviceMaskKHR
//         Command:
//             Name: vkCmdDispatchBaseKHR
//         Enum:
//             Name: VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHR
//             Negative: false
//             Extends: VkPipelineCreateFlagBits
//             Alias: VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT
//         Enum:
//             Name: VK_PIPELINE_CREATE_DISPATCH_BASE_BIT_KHR
//             Negative: false
//             Extends: VkPipelineCreateFlagBits
//             Alias: VK_PIPELINE_CREATE_DISPATCH_BASE_BIT
//         Enum:
//             Name: VK_PIPELINE_CREATE_DISPATCH_BASE_KHR
//             Negative: false
//             Extends: VkPipelineCreateFlagBits
//             Alias: VK_PIPELINE_CREATE_DISPATCH_BASE_BIT
//         Enum:
//             Name: VK_DEPENDENCY_DEVICE_GROUP_BIT_KHR
//             Negative: false
//             Extends: VkDependencyFlagBits
//             Alias: VK_DEPENDENCY_DEVICE_GROUP_BIT
//     Depends: VK_KHR_bind_memory2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO
//         Type:
//             Name: VkBindBufferMemoryDeviceGroupInfoKHR
//         Type:
//             Name: VkBindImageMemoryDeviceGroupInfoKHR
//         Enum:
//             Name: VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR
//             Negative: false
//             Extends: VkImageCreateFlagBits
//             Alias: VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT
//     Depends: VK_KHR_surface
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 7
//         Type:
//             Name: VkDeviceGroupPresentModeFlagBitsKHR
//         Type:
//             Name: VkDeviceGroupPresentModeFlagsKHR
//         Type:
//             Name: VkDeviceGroupPresentCapabilitiesKHR
//         Command:
//             Name: vkGetDeviceGroupPresentCapabilitiesKHR
//         Command:
//             Name: vkGetDeviceGroupSurfacePresentModesKHR
//         Command:
//             Name: vkGetPhysicalDevicePresentRectanglesKHR
//     Depends: VK_KHR_swapchain
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 8
//         Enum:
//             Name: VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 9
//         Enum:
//             Name: VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 10
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 11
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 12
//         Enum:
//             Name: VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR
//             Negative: false
//             Bitpos: 0
//             Extends: VkSwapchainCreateFlagBitsKHR
//             Comment:
//                 Allow images with VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT
//         Type:
//             Name: VkImageSwapchainCreateInfoKHR
//         Type:
//             Name: VkBindImageMemorySwapchainInfoKHR
//         Type:
//             Name: VkAcquireNextImageInfoKHR
//         Type:
//             Name: VkDeviceGroupPresentInfoKHR
//         Type:
//             Name: VkDeviceGroupSwapchainCreateInfoKHR
//         Command:
//             Name: vkAcquireNextImage2KHR
// Extension: VK_EXT_validation_flags
// Number: 62
// Type: instance
// Author: GOOGLE
// Supported: supported
// Deprecated by: VK_EXT_layer_settings
// Unlocks:
//         Enum:
//             Name: VK_EXT_VALIDATION_FLAGS_SPEC_VERSION
//             Negative: false
//             Value: 3
//         Enum:
//             Name: VK_EXT_VALIDATION_FLAGS_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_validation_flags&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkValidationFlagsEXT
//         Type:
//             Name: VkValidationCheckEXT
// Extension: VK_NN_vi_surface
// Number: 63
// Type: instance
// Author: NN
// Depends: VK_KHR_surface
// Platform: vi
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NN_VI_SURFACE_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_NN_VI_SURFACE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NN_vi_surface&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkViSurfaceCreateFlagsNN
//         Type:
//             Name: VkViSurfaceCreateInfoNN
//         Command:
//             Name: vkCreateViSurfaceNN
// Extension: VK_KHR_shader_draw_parameters
// Number: 64
// Type: device
// Author: KHR
// Supported: supported
// Promoted to: VK_VERSION_1_1
// Unlocks:
//         Enum:
//             Name: VK_KHR_SHADER_DRAW_PARAMETERS_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_SHADER_DRAW_PARAMETERS_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_shader_draw_parameters&quot;
// Extension: VK_EXT_shader_subgroup_ballot
// Number: 65
// Type: device
// Author: NV
// Supported: supported
// Deprecated by: VK_VERSION_1_2
// Unlocks:
//         Enum:
//             Name: VK_EXT_SHADER_SUBGROUP_BALLOT_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_SHADER_SUBGROUP_BALLOT_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_shader_subgroup_ballot&quot;
// Extension: VK_EXT_shader_subgroup_vote
// Number: 66
// Type: device
// Author: NV
// Supported: supported
// Deprecated by: VK_VERSION_1_1
// Unlocks:
//         Enum:
//             Name: VK_EXT_SHADER_SUBGROUP_VOTE_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_SHADER_SUBGROUP_VOTE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_shader_subgroup_vote&quot;
// Extension: VK_EXT_texture_compression_astc_hdr
// Number: 67
// Type: device
// Author: ARM
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_3
// Unlocks:
//         Enum:
//             Name: VK_EXT_TEXTURE_COMPRESSION_ASTC_HDR_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_TEXTURE_COMPRESSION_ASTC_HDR_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_texture_compression_astc_hdr&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES
//         Type:
//             Name: VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT
//         Enum:
//             Name: VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK_EXT
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK
//         Enum:
//             Name: VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK_EXT
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK
//         Enum:
//             Name: VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK_EXT
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK
//         Enum:
//             Name: VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK_EXT
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK
//         Enum:
//             Name: VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK_EXT
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK
//         Enum:
//             Name: VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK_EXT
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK
//         Enum:
//             Name: VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK_EXT
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK
//         Enum:
//             Name: VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK_EXT
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK
//         Enum:
//             Name: VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK_EXT
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK
//         Enum:
//             Name: VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK_EXT
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK
//         Enum:
//             Name: VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK_EXT
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK
//         Enum:
//             Name: VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK_EXT
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK
//         Enum:
//             Name: VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK_EXT
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK
//         Enum:
//             Name: VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK_EXT
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK
//         Feature:
//             Name: textureCompressionASTC_HDR
//             Struct: VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT
// Extension: VK_EXT_astc_decode_mode
// Number: 68
// Type: device
// Author: ARM
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_ASTC_DECODE_MODE_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_ASTC_DECODE_MODE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_astc_decode_mode&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Type:
//             Name: VkImageViewASTCDecodeModeEXT
//         Type:
//             Name: VkPhysicalDeviceASTCDecodeFeaturesEXT
// Extension: VK_EXT_pipeline_robustness
// Number: 69
// Type: device
// Author: IMG
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_4
// Unlocks:
//         Enum:
//             Name: VK_EXT_PIPELINE_ROBUSTNESS_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_PIPELINE_ROBUSTNESS_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_pipeline_robustness&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES
//         Enum:
//             Name: VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DEVICE_DEFAULT_EXT
//             Negative: false
//             Extends: VkPipelineRobustnessBufferBehavior
//             Alias: VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DEVICE_DEFAULT
//         Enum:
//             Name: VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DISABLED_EXT
//             Negative: false
//             Extends: VkPipelineRobustnessBufferBehavior
//             Alias: VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DISABLED
//         Enum:
//             Name: VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT
//             Negative: false
//             Extends: VkPipelineRobustnessBufferBehavior
//             Alias: VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS
//         Enum:
//             Name: VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT
//             Negative: false
//             Extends: VkPipelineRobustnessBufferBehavior
//             Alias: VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2
//         Enum:
//             Name: VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DEVICE_DEFAULT_EXT
//             Negative: false
//             Extends: VkPipelineRobustnessImageBehavior
//             Alias: VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DEVICE_DEFAULT
//         Enum:
//             Name: VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DISABLED_EXT
//             Negative: false
//             Extends: VkPipelineRobustnessImageBehavior
//             Alias: VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DISABLED
//         Enum:
//             Name: VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS_EXT
//             Negative: false
//             Extends: VkPipelineRobustnessImageBehavior
//             Alias: VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS
//         Enum:
//             Name: VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS_2_EXT
//             Negative: false
//             Extends: VkPipelineRobustnessImageBehavior
//             Alias: VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS_2
//         Type:
//             Name: VkPhysicalDevicePipelineRobustnessFeaturesEXT
//         Type:
//             Name: VkPhysicalDevicePipelineRobustnessPropertiesEXT
//         Type:
//             Name: VkPipelineRobustnessCreateInfoEXT
//         Type:
//             Name: VkPipelineRobustnessBufferBehaviorEXT
//         Type:
//             Name: VkPipelineRobustnessImageBehaviorEXT
//         Feature:
//             Name: pipelineRobustness
//             Struct: VkPhysicalDevicePipelineRobustnessFeaturesEXT
// Extension: VK_KHR_maintenance1
// Number: 70
// Type: device
// Author: KHR
// Supported: supported
// Promoted to: VK_VERSION_1_1
// Unlocks:
//         Enum:
//             Name: VK_KHR_MAINTENANCE_1_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_KHR_MAINTENANCE_1_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_maintenance1&quot;
//         Enum:
//             Name: VK_KHR_MAINTENANCE1_SPEC_VERSION
//             Negative: false
//             Alias: VK_KHR_MAINTENANCE_1_SPEC_VERSION
//         Enum:
//             Name: VK_KHR_MAINTENANCE1_EXTENSION_NAME
//             Negative: false
//             Alias: VK_KHR_MAINTENANCE_1_EXTENSION_NAME
//         Enum:
//             Name: VK_ERROR_OUT_OF_POOL_MEMORY_KHR
//             Negative: false
//             Extends: VkResult
//             Alias: VK_ERROR_OUT_OF_POOL_MEMORY
//         Enum:
//             Name: VK_FORMAT_FEATURE_TRANSFER_SRC_BIT_KHR
//             Negative: false
//             Extends: VkFormatFeatureFlagBits
//             Alias: VK_FORMAT_FEATURE_TRANSFER_SRC_BIT
//         Enum:
//             Name: VK_FORMAT_FEATURE_TRANSFER_DST_BIT_KHR
//             Negative: false
//             Extends: VkFormatFeatureFlagBits
//             Alias: VK_FORMAT_FEATURE_TRANSFER_DST_BIT
//         Enum:
//             Name: VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT_KHR
//             Negative: false
//             Extends: VkImageCreateFlagBits
//             Alias: VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT
//         Type:
//             Name: VkCommandPoolTrimFlagsKHR
//         Command:
//             Name: vkTrimCommandPoolKHR
// Extension: VK_KHR_device_group_creation
// Number: 71
// Type: instance
// Author: KHR
// Supported: supported
// Promoted to: VK_VERSION_1_1
// Unlocks:
//         Enum:
//             Name: VK_KHR_DEVICE_GROUP_CREATION_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_DEVICE_GROUP_CREATION_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_device_group_creation&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO
//         Enum:
//             Name: VK_MAX_DEVICE_GROUP_SIZE_KHR
//             Negative: false
//             Alias: VK_MAX_DEVICE_GROUP_SIZE
//         Type:
//             Name: VkPhysicalDeviceGroupPropertiesKHR
//         Type:
//             Name: VkDeviceGroupDeviceCreateInfoKHR
//         Command:
//             Name: vkEnumeratePhysicalDeviceGroupsKHR
//         Enum:
//             Name: VK_MEMORY_HEAP_MULTI_INSTANCE_BIT_KHR
//             Negative: false
//             Extends: VkMemoryHeapFlagBits
//             Alias: VK_MEMORY_HEAP_MULTI_INSTANCE_BIT
// Extension: VK_KHR_external_memory_capabilities
// Number: 72
// Type: instance
// Author: KHR
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_1
// Unlocks:
//         Enum:
//             Name: VK_KHR_EXTERNAL_MEMORY_CAPABILITIES_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_external_memory_capabilities&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES
//         Enum:
//             Name: VK_LUID_SIZE_KHR
//             Negative: false
//             Alias: VK_LUID_SIZE
//         Type:
//             Name: VkExternalMemoryHandleTypeFlagsKHR
//         Type:
//             Name: VkExternalMemoryHandleTypeFlagBitsKHR
//         Enum:
//             Name: VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT_KHR
//             Negative: false
//             Extends: VkExternalMemoryHandleTypeFlagBits
//             Alias: VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT
//         Enum:
//             Name: VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR
//             Negative: false
//             Extends: VkExternalMemoryHandleTypeFlagBits
//             Alias: VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT
//         Enum:
//             Name: VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR
//             Negative: false
//             Extends: VkExternalMemoryHandleTypeFlagBits
//             Alias: VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT
//         Enum:
//             Name: VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT_KHR
//             Negative: false
//             Extends: VkExternalMemoryHandleTypeFlagBits
//             Alias: VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT
//         Enum:
//             Name: VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT_KHR
//             Negative: false
//             Extends: VkExternalMemoryHandleTypeFlagBits
//             Alias: VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT
//         Enum:
//             Name: VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT_KHR
//             Negative: false
//             Extends: VkExternalMemoryHandleTypeFlagBits
//             Alias: VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT
//         Enum:
//             Name: VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT_KHR
//             Negative: false
//             Extends: VkExternalMemoryHandleTypeFlagBits
//             Alias: VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT
//         Type:
//             Name: VkExternalMemoryFeatureFlagsKHR
//         Type:
//             Name: VkExternalMemoryFeatureFlagBitsKHR
//         Enum:
//             Name: VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_KHR
//             Negative: false
//             Extends: VkExternalMemoryFeatureFlagBits
//             Alias: VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT
//         Enum:
//             Name: VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_KHR
//             Negative: false
//             Extends: VkExternalMemoryFeatureFlagBits
//             Alias: VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT
//         Enum:
//             Name: VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_KHR
//             Negative: false
//             Extends: VkExternalMemoryFeatureFlagBits
//             Alias: VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT
//         Type:
//             Name: VkExternalMemoryPropertiesKHR
//         Type:
//             Name: VkPhysicalDeviceExternalImageFormatInfoKHR
//         Type:
//             Name: VkExternalImageFormatPropertiesKHR
//         Type:
//             Name: VkPhysicalDeviceExternalBufferInfoKHR
//         Type:
//             Name: VkExternalBufferPropertiesKHR
//         Type:
//             Name: VkPhysicalDeviceIDPropertiesKHR
//         Command:
//             Name: vkGetPhysicalDeviceExternalBufferPropertiesKHR
// Extension: VK_KHR_external_memory
// Number: 73
// Type: device
// Author: KHR
// Depends: VK_KHR_external_memory_capabilities,VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_1
// Unlocks:
//         Enum:
//             Name: VK_KHR_EXTERNAL_MEMORY_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_EXTERNAL_MEMORY_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_external_memory&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO
//         Enum:
//             Name: VK_ERROR_INVALID_EXTERNAL_HANDLE_KHR
//             Negative: false
//             Extends: VkResult
//             Alias: VK_ERROR_INVALID_EXTERNAL_HANDLE
//         Enum:
//             Name: VK_QUEUE_FAMILY_EXTERNAL_KHR
//             Negative: false
//             Alias: VK_QUEUE_FAMILY_EXTERNAL
//         Type:
//             Name: VkExternalMemoryImageCreateInfoKHR
//         Type:
//             Name: VkExternalMemoryBufferCreateInfoKHR
//         Type:
//             Name: VkExportMemoryAllocateInfoKHR
// Extension: VK_KHR_external_memory_win32
// Number: 74
// Type: device
// Author: KHR
// Depends: VK_KHR_external_memory,VK_VERSION_1_1
// Platform: win32
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_EXTERNAL_MEMORY_WIN32_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_EXTERNAL_MEMORY_WIN32_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_external_memory_win32&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Type:
//             Name: VkImportMemoryWin32HandleInfoKHR
//         Type:
//             Name: VkExportMemoryWin32HandleInfoKHR
//         Type:
//             Name: VkMemoryWin32HandlePropertiesKHR
//         Type:
//             Name: VkMemoryGetWin32HandleInfoKHR
//         Command:
//             Name: vkGetMemoryWin32HandleKHR
//         Command:
//             Name: vkGetMemoryWin32HandlePropertiesKHR
// Extension: VK_KHR_external_memory_fd
// Number: 75
// Type: device
// Author: KHR
// Depends: VK_KHR_external_memory,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_EXTERNAL_MEMORY_FD_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_EXTERNAL_MEMORY_FD_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_external_memory_fd&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Type:
//             Name: VkImportMemoryFdInfoKHR
//         Type:
//             Name: VkMemoryFdPropertiesKHR
//         Type:
//             Name: VkMemoryGetFdInfoKHR
//         Command:
//             Name: vkGetMemoryFdKHR
//         Command:
//             Name: vkGetMemoryFdPropertiesKHR
// Extension: VK_KHR_win32_keyed_mutex
// Number: 76
// Type: device
// Author: KHR
// Depends: VK_KHR_external_memory_win32
// Platform: win32
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_WIN32_KEYED_MUTEX_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_WIN32_KEYED_MUTEX_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_win32_keyed_mutex&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkWin32KeyedMutexAcquireReleaseInfoKHR
// Extension: VK_KHR_external_semaphore_capabilities
// Number: 77
// Type: instance
// Author: KHR
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_1
// Unlocks:
//         Enum:
//             Name: VK_KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_external_semaphore_capabilities&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES
//         Enum:
//             Name: VK_LUID_SIZE_KHR
//             Negative: false
//         Type:
//             Name: VkExternalSemaphoreHandleTypeFlagsKHR
//         Type:
//             Name: VkExternalSemaphoreHandleTypeFlagBitsKHR
//         Enum:
//             Name: VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR
//             Negative: false
//             Extends: VkExternalSemaphoreHandleTypeFlagBits
//             Alias: VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT
//         Enum:
//             Name: VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR
//             Negative: false
//             Extends: VkExternalSemaphoreHandleTypeFlagBits
//             Alias: VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT
//         Enum:
//             Name: VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR
//             Negative: false
//             Extends: VkExternalSemaphoreHandleTypeFlagBits
//             Alias: VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT
//         Enum:
//             Name: VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT_KHR
//             Negative: false
//             Extends: VkExternalSemaphoreHandleTypeFlagBits
//             Alias: VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT
//         Enum:
//             Name: VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT_KHR
//             Negative: false
//             Extends: VkExternalSemaphoreHandleTypeFlagBits
//             Alias: VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT
//         Type:
//             Name: VkExternalSemaphoreFeatureFlagsKHR
//         Type:
//             Name: VkExternalSemaphoreFeatureFlagBitsKHR
//         Enum:
//             Name: VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT_KHR
//             Negative: false
//             Extends: VkExternalSemaphoreFeatureFlagBits
//             Alias: VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT
//         Enum:
//             Name: VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT_KHR
//             Negative: false
//             Extends: VkExternalSemaphoreFeatureFlagBits
//             Alias: VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT
//         Type:
//             Name: VkPhysicalDeviceExternalSemaphoreInfoKHR
//         Type:
//             Name: VkExternalSemaphorePropertiesKHR
//         Type:
//             Name: VkPhysicalDeviceIDPropertiesKHR
//         Command:
//             Name: vkGetPhysicalDeviceExternalSemaphorePropertiesKHR
// Extension: VK_KHR_external_semaphore
// Number: 78
// Type: device
// Author: KHR
// Depends: VK_KHR_external_semaphore_capabilities
// Supported: supported
// Promoted to: VK_VERSION_1_1
// Unlocks:
//         Enum:
//             Name: VK_KHR_EXTERNAL_SEMAPHORE_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_EXTERNAL_SEMAPHORE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_external_semaphore&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO
//         Type:
//             Name: VkSemaphoreImportFlagsKHR
//         Type:
//             Name: VkSemaphoreImportFlagBitsKHR
//         Enum:
//             Name: VK_SEMAPHORE_IMPORT_TEMPORARY_BIT_KHR
//             Negative: false
//             Extends: VkSemaphoreImportFlagBits
//             Alias: VK_SEMAPHORE_IMPORT_TEMPORARY_BIT
//         Type:
//             Name: VkExportSemaphoreCreateInfoKHR
// Extension: VK_KHR_external_semaphore_win32
// Number: 79
// Type: device
// Author: KHR
// Depends: VK_KHR_external_semaphore
// Platform: win32
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_EXTERNAL_SEMAPHORE_WIN32_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_EXTERNAL_SEMAPHORE_WIN32_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_external_semaphore_win32&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Type:
//             Name: VkImportSemaphoreWin32HandleInfoKHR
//         Type:
//             Name: VkExportSemaphoreWin32HandleInfoKHR
//         Type:
//             Name: VkD3D12FenceSubmitInfoKHR
//         Type:
//             Name: VkSemaphoreGetWin32HandleInfoKHR
//         Command:
//             Name: vkImportSemaphoreWin32HandleKHR
//         Command:
//             Name: vkGetSemaphoreWin32HandleKHR
// Extension: VK_KHR_external_semaphore_fd
// Number: 80
// Type: device
// Author: KHR
// Depends: VK_KHR_external_semaphore,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_EXTERNAL_SEMAPHORE_FD_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_EXTERNAL_SEMAPHORE_FD_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_external_semaphore_fd&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Type:
//             Name: VkImportSemaphoreFdInfoKHR
//         Type:
//             Name: VkSemaphoreGetFdInfoKHR
//         Command:
//             Name: vkImportSemaphoreFdKHR
//         Command:
//             Name: vkGetSemaphoreFdKHR
// Extension: VK_KHR_push_descriptor
// Number: 81
// Type: device
// Author: KHR
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_4
// Unlocks:
//         Enum:
//             Name: VK_KHR_PUSH_DESCRIPTOR_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_KHR_PUSH_DESCRIPTOR_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_push_descriptor&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES
//         Enum:
//             Name: VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR
//             Negative: false
//             Extends: VkDescriptorSetLayoutCreateFlagBits
//             Alias: VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT
//             Comment:
//                 Descriptors are pushed via flink:vkCmdPushDescriptorSet
//         Command:
//             Name: vkCmdPushDescriptorSetKHR
//         Type:
//             Name: VkPhysicalDevicePushDescriptorPropertiesKHR
//     Depends: VK_VERSION_1_1,VK_KHR_descriptor_update_template
//         Command:
//             Name: vkCmdPushDescriptorSetWithTemplateKHR
//         Enum:
//             Name: VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR
//             Negative: false
//             Extends: VkDescriptorUpdateTemplateType
//             Alias: VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS
//             Comment:
//                 Create descriptor update template for pushed descriptor updates
// Extension: VK_EXT_conditional_rendering
// Number: 82
// Type: device
// Author: NV
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_CONDITIONAL_RENDERING_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_EXT_CONDITIONAL_RENDERING_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_conditional_rendering&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Type:
//             Name: VkConditionalRenderingFlagsEXT
//         Type:
//             Name: VkConditionalRenderingFlagBitsEXT
//         Enum:
//             Name: VK_ACCESS_CONDITIONAL_RENDERING_READ_BIT_EXT
//             Negative: false
//             Bitpos: 20
//             Extends: VkAccessFlagBits
//             Comment:
//                 read access flag for reading conditional rendering predicate
//         Enum:
//             Name: VK_BUFFER_USAGE_CONDITIONAL_RENDERING_BIT_EXT
//             Negative: false
//             Bitpos: 9
//             Extends: VkBufferUsageFlagBits
//             Comment:
//                 Specifies the buffer can be used as predicate in conditional rendering
//         Enum:
//             Name: VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT
//             Negative: false
//             Bitpos: 18
//             Extends: VkPipelineStageFlagBits
//             Comment:
//                 A pipeline stage for conditional rendering predicate fetch
//         Command:
//             Name: vkCmdBeginConditionalRenderingEXT
//         Command:
//             Name: vkCmdEndConditionalRenderingEXT
//         Type:
//             Name: VkConditionalRenderingBeginInfoEXT
//         Type:
//             Name: VkPhysicalDeviceConditionalRenderingFeaturesEXT
//         Type:
//             Name: VkCommandBufferInheritanceConditionalRenderingInfoEXT
//         Feature:
//             Name: conditionalRendering
//             Struct: VkPhysicalDeviceConditionalRenderingFeaturesEXT
// Extension: VK_KHR_shader_float16_int8
// Number: 83
// Type: device
// Author: KHR
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_2
// Unlocks:
//         Enum:
//             Name: VK_KHR_SHADER_FLOAT16_INT8_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_SHADER_FLOAT16_INT8_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_shader_float16_int8&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT16_INT8_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES
//         Type:
//             Name: VkPhysicalDeviceShaderFloat16Int8FeaturesKHR
//         Type:
//             Name: VkPhysicalDeviceFloat16Int8FeaturesKHR
//         Feature:
//             Name: shaderFloat16,shaderInt8
//             Struct: VkPhysicalDeviceShaderFloat16Int8FeaturesKHR
// Extension: VK_KHR_16bit_storage
// Number: 84
// Type: device
// Author: KHR
// Depends: (VK_KHR_get_physical_device_properties2+VK_KHR_storage_buffer_storage_class),VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_1
// Unlocks:
//         Enum:
//             Name: VK_KHR_16BIT_STORAGE_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_16BIT_STORAGE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_16bit_storage&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES
//         Type:
//             Name: VkPhysicalDevice16BitStorageFeaturesKHR
//         Feature:
//             Name: storageBuffer16BitAccess
//             Struct: VkPhysicalDevice16BitStorageFeaturesKHR
// Extension: VK_KHR_incremental_present
// Number: 85
// Type: device
// Author: KHR
// Depends: VK_KHR_swapchain
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_INCREMENTAL_PRESENT_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_KHR_INCREMENTAL_PRESENT_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_incremental_present&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPresentRegionsKHR
//         Type:
//             Name: VkPresentRegionKHR
//         Type:
//             Name: VkRectLayerKHR
// Extension: VK_KHR_descriptor_update_template
// Number: 86
// Type: device
// Author: KHR
// Supported: supported
// Promoted to: VK_VERSION_1_1
// Unlocks:
//         Enum:
//             Name: VK_KHR_DESCRIPTOR_UPDATE_TEMPLATE_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_DESCRIPTOR_UPDATE_TEMPLATE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_descriptor_update_template&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO
//         Enum:
//             Name: VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR
//             Negative: false
//             Extends: VkObjectType
//             Alias: VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE
//         Command:
//             Name: vkCreateDescriptorUpdateTemplateKHR
//         Command:
//             Name: vkDestroyDescriptorUpdateTemplateKHR
//         Command:
//             Name: vkUpdateDescriptorSetWithTemplateKHR
//         Type:
//             Name: VkDescriptorUpdateTemplateKHR
//         Type:
//             Name: VkDescriptorUpdateTemplateCreateFlagsKHR
//         Type:
//             Name: VkDescriptorUpdateTemplateTypeKHR
//         Type:
//             Name: VkDescriptorUpdateTemplateEntryKHR
//         Type:
//             Name: VkDescriptorUpdateTemplateCreateInfoKHR
//         Enum:
//             Name: VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET_KHR
//             Negative: false
//             Extends: VkDescriptorUpdateTemplateType
//             Alias: VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET
//     Depends: VK_KHR_push_descriptor
//         Command:
//             Name: vkCmdPushDescriptorSetWithTemplateKHR
//         Enum:
//             Name: VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR
//             Negative: false
//             Extends: VkDescriptorUpdateTemplateType
//             Alias: VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS
//             Comment:
//                 Create descriptor update template for pushed descriptor updates
//     Depends: VK_EXT_debug_report
//         Enum:
//             Name: VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR_EXT
//             Negative: false
//             Extends: VkDebugReportObjectTypeEXT
//             Alias: VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_EXT
// Extension: VK_NVX_device_generated_commands
// Number: 87
// Type: device
// Author: NVX
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_NVX_DEVICE_GENERATED_COMMANDS_SPEC_VERSION
//             Negative: false
//             Value: 3
//         Enum:
//             Name: VK_NVX_DEVICE_GENERATED_COMMANDS_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NVX_device_generated_commands&quot;
// Extension: VK_NV_clip_space_w_scaling
// Number: 88
// Type: device
// Author: NV
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NV_CLIP_SPACE_W_SCALING_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_NV_CLIP_SPACE_W_SCALING_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_clip_space_w_scaling&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV
//             Negative: false
//             Extends: VkDynamicState
//             Offset: 0
//         Type:
//             Name: VkViewportWScalingNV
//         Type:
//             Name: VkPipelineViewportWScalingStateCreateInfoNV
//         Command:
//             Name: vkCmdSetViewportWScalingNV
// Extension: VK_EXT_direct_mode_display
// Number: 89
// Type: instance
// Author: NV
// Depends: VK_KHR_display
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_DIRECT_MODE_DISPLAY_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_DIRECT_MODE_DISPLAY_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_direct_mode_display&quot;
//         Command:
//             Name: vkReleaseDisplayEXT
// Extension: VK_EXT_acquire_xlib_display
// Number: 90
// Type: instance
// Author: NV
// Depends: VK_EXT_direct_mode_display
// Platform: xlib_xrandr
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_ACQUIRE_XLIB_DISPLAY_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_ACQUIRE_XLIB_DISPLAY_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_acquire_xlib_display&quot;
//         Command:
//             Name: vkAcquireXlibDisplayEXT
//         Command:
//             Name: vkGetRandROutputDisplayEXT
// Extension: VK_EXT_display_surface_counter
// Number: 91
// Type: instance
// Author: NV
// Depends: VK_KHR_display
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_DISPLAY_SURFACE_COUNTER_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_DISPLAY_SURFACE_COUNTER_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_display_surface_counter&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES2_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT
//         Type:
//             Name: VkSurfaceCounterFlagsEXT
//         Type:
//             Name: VkSurfaceCounterFlagBitsEXT
//         Type:
//             Name: VkSurfaceCapabilities2EXT
//         Command:
//             Name: vkGetPhysicalDeviceSurfaceCapabilities2EXT
// Extension: VK_EXT_display_control
// Number: 92
// Type: device
// Author: NV
// Depends: VK_EXT_display_surface_counter+VK_KHR_swapchain
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_DISPLAY_CONTROL_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_DISPLAY_CONTROL_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_display_control&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Type:
//             Name: VkDisplayPowerStateEXT
//         Type:
//             Name: VkDeviceEventTypeEXT
//         Type:
//             Name: VkDisplayEventTypeEXT
//         Type:
//             Name: VkDisplayPowerInfoEXT
//         Type:
//             Name: VkDeviceEventInfoEXT
//         Type:
//             Name: VkDisplayEventInfoEXT
//         Type:
//             Name: VkSwapchainCounterCreateInfoEXT
//         Command:
//             Name: vkDisplayPowerControlEXT
//         Command:
//             Name: vkRegisterDeviceEventEXT
//         Command:
//             Name: vkRegisterDisplayEventEXT
//         Command:
//             Name: vkGetSwapchainCounterEXT
// Extension: VK_GOOGLE_display_timing
// Number: 93
// Type: device
// Author: GOOGLE
// Depends: VK_KHR_swapchain
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_GOOGLE_DISPLAY_TIMING_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_GOOGLE_DISPLAY_TIMING_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_GOOGLE_display_timing&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkRefreshCycleDurationGOOGLE
//         Type:
//             Name: VkPastPresentationTimingGOOGLE
//         Type:
//             Name: VkPresentTimesInfoGOOGLE
//         Type:
//             Name: VkPresentTimeGOOGLE
//         Command:
//             Name: vkGetRefreshCycleDurationGOOGLE
//         Command:
//             Name: vkGetPastPresentationTimingGOOGLE
// Extension: VK_RESERVED_do_not_use_94
// Number: 94
// Type: invalid
// Supported: disabled
// Comment:
//     Used for functionality subsumed into Vulkan 1.1 and not published as an extension
// Unlocks:
//         Enum:
//             Name: VK_RESERVED_DO_NOT_USE_94_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_RESERVED_DO_NOT_USE_94_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_RESERVED_do_not_use_94&quot;
// Extension: VK_NV_sample_mask_override_coverage
// Number: 95
// Type: device
// Author: NV
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NV_SAMPLE_MASK_OVERRIDE_COVERAGE_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_NV_SAMPLE_MASK_OVERRIDE_COVERAGE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_sample_mask_override_coverage&quot;
//         Comment:
//             enum offset=0 was mistakenly used for the 1.1 core enum
//             VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES
//             (value=1000094000). Fortunately, no conflict resulted.
// Extension: VK_NV_geometry_shader_passthrough
// Number: 96
// Type: device
// Author: NV
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NV_GEOMETRY_SHADER_PASSTHROUGH_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_NV_GEOMETRY_SHADER_PASSTHROUGH_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_geometry_shader_passthrough&quot;
// Extension: VK_NV_viewport_array2
// Number: 97
// Type: device
// Author: NV
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NV_VIEWPORT_ARRAY_2_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_NV_VIEWPORT_ARRAY_2_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_viewport_array2&quot;
//         Enum:
//             Name: VK_NV_VIEWPORT_ARRAY2_SPEC_VERSION
//             Negative: false
//             Alias: VK_NV_VIEWPORT_ARRAY_2_SPEC_VERSION
//         Enum:
//             Name: VK_NV_VIEWPORT_ARRAY2_EXTENSION_NAME
//             Negative: false
//             Alias: VK_NV_VIEWPORT_ARRAY_2_EXTENSION_NAME
// Extension: VK_NVX_multiview_per_view_attributes
// Number: 98
// Type: device
// Author: NVX
// Depends: VK_KHR_multiview,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NVX_MULTIVIEW_PER_VIEW_ATTRIBUTES_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_NVX_MULTIVIEW_PER_VIEW_ATTRIBUTES_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NVX_multiview_per_view_attributes&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX
//             Negative: false
//             Bitpos: 0
//             Extends: VkSubpassDescriptionFlagBits
//         Enum:
//             Name: VK_SUBPASS_DESCRIPTION_PER_VIEW_POSITION_X_ONLY_BIT_NVX
//             Negative: false
//             Bitpos: 1
//             Extends: VkSubpassDescriptionFlagBits
//         Type:
//             Name: VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX
//     Depends: VK_VERSION_1_3,VK_KHR_dynamic_rendering
//         Enum:
//             Name: VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_NVX
//             Negative: false
//             Extends: VkStructureType
//             Extnumber: 45
//             Offset: 9
//         Type:
//             Name: VkMultiviewPerViewAttributesInfoNVX
// Extension: VK_NV_viewport_swizzle
// Number: 99
// Type: device
// Author: NV
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NV_VIEWPORT_SWIZZLE_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_NV_VIEWPORT_SWIZZLE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_viewport_swizzle&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkViewportSwizzleNV
//         Type:
//             Name: VkViewportCoordinateSwizzleNV
//         Type:
//             Name: VkPipelineViewportSwizzleStateCreateInfoNV
//         Type:
//             Name: VkPipelineViewportSwizzleStateCreateFlagsNV
// Extension: VK_EXT_discard_rectangles
// Number: 100
// Type: device
// Author: NV
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_DISCARD_RECTANGLES_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_EXT_DISCARD_RECTANGLES_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_discard_rectangles&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT
//             Negative: false
//             Extends: VkDynamicState
//             Offset: 0
//         Enum:
//             Name: VK_DYNAMIC_STATE_DISCARD_RECTANGLE_ENABLE_EXT
//             Negative: false
//             Extends: VkDynamicState
//             Offset: 1
//         Enum:
//             Name: VK_DYNAMIC_STATE_DISCARD_RECTANGLE_MODE_EXT
//             Negative: false
//             Extends: VkDynamicState
//             Offset: 2
//         Type:
//             Name: VkPhysicalDeviceDiscardRectanglePropertiesEXT
//         Type:
//             Name: VkPipelineDiscardRectangleStateCreateInfoEXT
//         Type:
//             Name: VkPipelineDiscardRectangleStateCreateFlagsEXT
//         Type:
//             Name: VkDiscardRectangleModeEXT
//         Command:
//             Name: vkCmdSetDiscardRectangleEXT
//         Command:
//             Name: vkCmdSetDiscardRectangleEnableEXT
//         Command:
//             Name: vkCmdSetDiscardRectangleModeEXT
// Extension: VK_NV_extension_101
// Number: 101
// Type: invalid
// Author: NV
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_NV_EXTENSION_101_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_NV_EXTENSION_101_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_extension_101&quot;
// Extension: VK_EXT_conservative_rasterization
// Number: 102
// Type: device
// Author: NV
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_CONSERVATIVE_RASTERIZATION_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_CONSERVATIVE_RASTERIZATION_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_conservative_rasterization&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Type:
//             Name: VkPhysicalDeviceConservativeRasterizationPropertiesEXT
//         Type:
//             Name: VkPipelineRasterizationConservativeStateCreateInfoEXT
//         Type:
//             Name: VkPipelineRasterizationConservativeStateCreateFlagsEXT
//         Type:
//             Name: VkConservativeRasterizationModeEXT
// Extension: VK_EXT_depth_clip_enable
// Number: 103
// Type: device
// Author: EXT
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_DEPTH_CLIP_ENABLE_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_DEPTH_CLIP_ENABLE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_depth_clip_enable&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Type:
//             Name: VkPhysicalDeviceDepthClipEnableFeaturesEXT
//         Type:
//             Name: VkPipelineRasterizationDepthClipStateCreateInfoEXT
//         Type:
//             Name: VkPipelineRasterizationDepthClipStateCreateFlagsEXT
//         Feature:
//             Name: depthClipEnable
//             Struct: VkPhysicalDeviceDepthClipEnableFeaturesEXT
// Extension: VK_NV_extension_104
// Number: 104
// Type: invalid
// Author: NV
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_NV_EXTENSION_104_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_NV_EXTENSION_104_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_extension_104&quot;
//         Enum:
//             Name: VK_PRIVATE_DATA_SLOT_CREATE_RESERVED_0_BIT_NV
//             Negative: false
//             Bitpos: 0
//             Extends: VkPrivateDataSlotCreateFlagBits
// Extension: VK_EXT_swapchain_colorspace
// Number: 105
// Type: instance
// Author: GOOGLE
// Depends: VK_KHR_surface
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_SWAPCHAIN_COLOR_SPACE_SPEC_VERSION
//             Negative: false
//             Value: 5
//         Enum:
//             Name: VK_EXT_SWAPCHAIN_COLOR_SPACE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_swapchain_colorspace&quot;
//         Enum:
//             Name: VK_COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT
//             Negative: false
//             Extends: VkColorSpaceKHR
//             Offset: 1
//         Enum:
//             Name: VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT
//             Negative: false
//             Extends: VkColorSpaceKHR
//             Offset: 2
//         Enum:
//             Name: VK_COLOR_SPACE_DISPLAY_P3_LINEAR_EXT
//             Negative: false
//             Extends: VkColorSpaceKHR
//             Offset: 3
//         Enum:
//             Name: VK_COLOR_SPACE_DCI_P3_NONLINEAR_EXT
//             Negative: false
//             Extends: VkColorSpaceKHR
//             Offset: 4
//         Enum:
//             Name: VK_COLOR_SPACE_BT709_LINEAR_EXT
//             Negative: false
//             Extends: VkColorSpaceKHR
//             Offset: 5
//         Enum:
//             Name: VK_COLOR_SPACE_BT709_NONLINEAR_EXT
//             Negative: false
//             Extends: VkColorSpaceKHR
//             Offset: 6
//         Enum:
//             Name: VK_COLOR_SPACE_BT2020_LINEAR_EXT
//             Negative: false
//             Extends: VkColorSpaceKHR
//             Offset: 7
//         Enum:
//             Name: VK_COLOR_SPACE_HDR10_ST2084_EXT
//             Negative: false
//             Extends: VkColorSpaceKHR
//             Offset: 8
//         Enum:
//             Name: VK_COLOR_SPACE_DOLBYVISION_EXT
//             Negative: false
//             Extends: VkColorSpaceKHR
//             Offset: 9
//         Enum:
//             Name: VK_COLOR_SPACE_HDR10_HLG_EXT
//             Negative: false
//             Extends: VkColorSpaceKHR
//             Offset: 10
//         Enum:
//             Name: VK_COLOR_SPACE_ADOBERGB_LINEAR_EXT
//             Negative: false
//             Extends: VkColorSpaceKHR
//             Offset: 11
//         Enum:
//             Name: VK_COLOR_SPACE_ADOBERGB_NONLINEAR_EXT
//             Negative: false
//             Extends: VkColorSpaceKHR
//             Offset: 12
//         Enum:
//             Name: VK_COLOR_SPACE_PASS_THROUGH_EXT
//             Negative: false
//             Extends: VkColorSpaceKHR
//             Offset: 13
//         Enum:
//             Name: VK_COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT
//             Negative: false
//             Extends: VkColorSpaceKHR
//             Offset: 14
//         Enum:
//             Name: VK_COLOR_SPACE_DCI_P3_LINEAR_EXT
//             Negative: false
//             Extends: VkColorSpaceKHR
//             Alias: VK_COLOR_SPACE_DISPLAY_P3_LINEAR_EXT
// Extension: VK_EXT_hdr_metadata
// Number: 106
// Type: device
// Author: GOOGLE
// Depends: VK_KHR_swapchain
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_HDR_METADATA_SPEC_VERSION
//             Negative: false
//             Value: 3
//         Enum:
//             Name: VK_EXT_HDR_METADATA_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_hdr_metadata&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_HDR_METADATA_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkHdrMetadataEXT
//         Type:
//             Name: VkXYColorEXT
//         Command:
//             Name: vkSetHdrMetadataEXT
// Extension: VK_IMG_extension_107
// Number: 107
// Type: invalid
// Author: IMG
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_IMG_EXTENSION_107_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_IMG_EXTENSION_107_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_IMG_extension_107&quot;
//         Enum:
//             Name: VK_BUFFER_CREATE_RESERVED_7_BIT_IMG
//             Negative: false
//             Bitpos: 7
//             Extends: VkBufferCreateFlagBits
//         Enum:
//             Name: VK_IMAGE_CREATE_RESERVED_21_BIT_IMG
//             Negative: false
//             Bitpos: 21
//             Extends: VkImageCreateFlagBits
//         Enum:
//             Name: VK_PIPELINE_CREATE_2_RESERVED_46_BIT_IMG
//             Negative: false
//             Bitpos: 46
//             Extends: VkPipelineCreateFlagBits2
//         Enum:
//             Name: VK_SHADER_CREATE_RESERVED_17_BIT_IMG
//             Negative: false
//             Bitpos: 17
//             Extends: VkShaderCreateFlagBitsEXT
//         Enum:
//             Name: VK_RENDERING_RESERVED_9_BIT_IMG
//             Negative: false
//             Bitpos: 9
//             Extends: VkRenderingFlagBits
//         Enum:
//             Name: VK_RENDER_PASS_CREATE_RESERVED_3_BIT_IMG
//             Negative: false
//             Bitpos: 3
//             Extends: VkRenderPassCreateFlagBits
// Extension: VK_IMG_extension_108
// Number: 108
// Type: invalid
// Author: IMG
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_IMG_EXTENSION_108_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_IMG_EXTENSION_108_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_IMG_extension_108&quot;
// Extension: VK_KHR_imageless_framebuffer
// Number: 109
// Type: device
// Author: KHR
// Depends: (((VK_KHR_get_physical_device_properties2+VK_KHR_maintenance2),VK_VERSION_1_1)+VK_KHR_image_format_list),VK_VERSION_1_2
// Supported: supported
// Promoted to: VK_VERSION_1_2
// Unlocks:
//         Enum:
//             Name: VK_KHR_IMAGELESS_FRAMEBUFFER_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_IMAGELESS_FRAMEBUFFER_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_imageless_framebuffer&quot;
//         Type:
//             Name: VkPhysicalDeviceImagelessFramebufferFeaturesKHR
//         Type:
//             Name: VkFramebufferAttachmentsCreateInfoKHR
//         Type:
//             Name: VkFramebufferAttachmentImageInfoKHR
//         Type:
//             Name: VkRenderPassAttachmentBeginInfoKHR
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES
//         Enum:
//             Name: VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO
//         Enum:
//             Name: VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT_KHR
//             Negative: false
//             Extends: VkFramebufferCreateFlagBits
//             Alias: VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT
//         Feature:
//             Name: imagelessFramebuffer
//             Struct: VkPhysicalDeviceImagelessFramebufferFeaturesKHR
// Extension: VK_KHR_create_renderpass2
// Number: 110
// Type: device
// Author: KHR
// Depends: (VK_KHR_multiview+VK_KHR_maintenance2),VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_2
// Unlocks:
//         Enum:
//             Name: VK_KHR_CREATE_RENDERPASS_2_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_CREATE_RENDERPASS_2_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_create_renderpass2&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SUBPASS_END_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_SUBPASS_END_INFO
//         Command:
//             Name: vkCreateRenderPass2KHR
//         Command:
//             Name: vkCmdBeginRenderPass2KHR
//         Command:
//             Name: vkCmdNextSubpass2KHR
//         Command:
//             Name: vkCmdEndRenderPass2KHR
//         Type:
//             Name: VkRenderPassCreateInfo2KHR
//         Type:
//             Name: VkAttachmentDescription2KHR
//         Type:
//             Name: VkAttachmentReference2KHR
//         Type:
//             Name: VkSubpassDescription2KHR
//         Type:
//             Name: VkSubpassDependency2KHR
//         Type:
//             Name: VkSubpassBeginInfoKHR
//         Type:
//             Name: VkSubpassEndInfoKHR
// Extension: VK_IMG_relaxed_line_rasterization
// Number: 111
// Type: device
// Author: IMG
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_IMG_RELAXED_LINE_RASTERIZATION_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_IMG_RELAXED_LINE_RASTERIZATION_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_IMG_relaxed_line_rasterization&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RELAXED_LINE_RASTERIZATION_FEATURES_IMG
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG
//         Feature:
//             Name: relaxedLineRasterization
//             Struct: VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG
// Extension: VK_KHR_shared_presentable_image
// Number: 112
// Type: device
// Author: KHR
// Depends: VK_KHR_swapchain+VK_KHR_get_surface_capabilities2+(VK_KHR_get_physical_device_properties2,VK_VERSION_1_1)
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_SHARED_PRESENTABLE_IMAGE_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_SHARED_PRESENTABLE_IMAGE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_shared_presentable_image&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR
//             Negative: false
//             Extends: VkPresentModeKHR
//             Offset: 0
//         Enum:
//             Name: VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR
//             Negative: false
//             Extends: VkPresentModeKHR
//             Offset: 1
//         Enum:
//             Name: VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR
//             Negative: false
//             Extends: VkImageLayout
//             Offset: 0
//         Type:
//             Name: VkSharedPresentSurfaceCapabilitiesKHR
//         Command:
//             Name: vkGetSwapchainStatusKHR
// Extension: VK_KHR_external_fence_capabilities
// Number: 113
// Type: instance
// Author: KHR
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_1
// Unlocks:
//         Enum:
//             Name: VK_KHR_EXTERNAL_FENCE_CAPABILITIES_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_EXTERNAL_FENCE_CAPABILITIES_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_external_fence_capabilities&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES
//         Enum:
//             Name: VK_LUID_SIZE_KHR
//             Negative: false
//         Type:
//             Name: VkExternalFenceHandleTypeFlagsKHR
//         Type:
//             Name: VkExternalFenceHandleTypeFlagBitsKHR
//         Enum:
//             Name: VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR
//             Negative: false
//             Extends: VkExternalFenceHandleTypeFlagBits
//             Alias: VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT
//         Enum:
//             Name: VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR
//             Negative: false
//             Extends: VkExternalFenceHandleTypeFlagBits
//             Alias: VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT
//         Enum:
//             Name: VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR
//             Negative: false
//             Extends: VkExternalFenceHandleTypeFlagBits
//             Alias: VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT
//         Enum:
//             Name: VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT_KHR
//             Negative: false
//             Extends: VkExternalFenceHandleTypeFlagBits
//             Alias: VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT
//         Type:
//             Name: VkExternalFenceFeatureFlagsKHR
//         Type:
//             Name: VkExternalFenceFeatureFlagBitsKHR
//         Enum:
//             Name: VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT_KHR
//             Negative: false
//             Extends: VkExternalFenceFeatureFlagBits
//             Alias: VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT
//         Enum:
//             Name: VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT_KHR
//             Negative: false
//             Extends: VkExternalFenceFeatureFlagBits
//             Alias: VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT
//         Type:
//             Name: VkPhysicalDeviceExternalFenceInfoKHR
//         Type:
//             Name: VkExternalFencePropertiesKHR
//         Type:
//             Name: VkPhysicalDeviceIDPropertiesKHR
//         Command:
//             Name: vkGetPhysicalDeviceExternalFencePropertiesKHR
// Extension: VK_KHR_external_fence
// Number: 114
// Type: device
// Author: KHR
// Depends: VK_KHR_external_fence_capabilities
// Supported: supported
// Promoted to: VK_VERSION_1_1
// Unlocks:
//         Enum:
//             Name: VK_KHR_EXTERNAL_FENCE_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_EXTERNAL_FENCE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_external_fence&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO
//         Type:
//             Name: VkFenceImportFlagsKHR
//         Type:
//             Name: VkFenceImportFlagBitsKHR
//         Enum:
//             Name: VK_FENCE_IMPORT_TEMPORARY_BIT_KHR
//             Negative: false
//             Extends: VkFenceImportFlagBits
//             Alias: VK_FENCE_IMPORT_TEMPORARY_BIT
//         Type:
//             Name: VkExportFenceCreateInfoKHR
// Extension: VK_KHR_external_fence_win32
// Number: 115
// Type: device
// Author: KHR
// Depends: VK_KHR_external_fence
// Platform: win32
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_EXTERNAL_FENCE_WIN32_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_EXTERNAL_FENCE_WIN32_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_external_fence_win32&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Type:
//             Name: VkImportFenceWin32HandleInfoKHR
//         Type:
//             Name: VkExportFenceWin32HandleInfoKHR
//         Type:
//             Name: VkFenceGetWin32HandleInfoKHR
//         Command:
//             Name: vkImportFenceWin32HandleKHR
//         Command:
//             Name: vkGetFenceWin32HandleKHR
// Extension: VK_KHR_external_fence_fd
// Number: 116
// Type: device
// Author: KHR
// Depends: VK_KHR_external_fence,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_EXTERNAL_FENCE_FD_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_EXTERNAL_FENCE_FD_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_external_fence_fd&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Type:
//             Name: VkImportFenceFdInfoKHR
//         Type:
//             Name: VkFenceGetFdInfoKHR
//         Command:
//             Name: vkImportFenceFdKHR
//         Command:
//             Name: vkGetFenceFdKHR
// Extension: VK_KHR_performance_query
// Number: 117
// Type: device
// Author: KHR
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_PERFORMANCE_QUERY_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_PERFORMANCE_QUERY_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_performance_query&quot;
//         Enum:
//             Name: VK_QUERY_TYPE_PERFORMANCE_QUERY_KHR
//             Negative: false
//             Extends: VkQueryType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Enum:
//             Name: VK_STRUCTURE_TYPE_ACQUIRE_PROFILING_LOCK_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 4
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 5
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_DESCRIPTION_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 6
//         Type:
//             Name: VkPhysicalDevicePerformanceQueryFeaturesKHR
//         Type:
//             Name: VkPhysicalDevicePerformanceQueryPropertiesKHR
//         Type:
//             Name: VkPerformanceCounterKHR
//         Type:
//             Name: VkPerformanceCounterDescriptionKHR
//         Type:
//             Name: VkPerformanceCounterDescriptionFlagsKHR
//         Type:
//             Name: VkPerformanceCounterDescriptionFlagBitsKHR
//         Type:
//             Name: VkQueryPoolPerformanceCreateInfoKHR
//         Type:
//             Name: VkPerformanceCounterScopeKHR
//         Type:
//             Name: VkPerformanceCounterStorageKHR
//         Type:
//             Name: VkPerformanceCounterUnitKHR
//         Type:
//             Name: VkPerformanceCounterResultKHR
//         Type:
//             Name: VkAcquireProfilingLockInfoKHR
//         Type:
//             Name: VkAcquireProfilingLockFlagsKHR
//         Type:
//             Name: VkAcquireProfilingLockFlagBitsKHR
//         Type:
//             Name: VkPerformanceQuerySubmitInfoKHR
//         Command:
//             Name: vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR
//         Command:
//             Name: vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR
//         Command:
//             Name: vkAcquireProfilingLockKHR
//         Command:
//             Name: vkReleaseProfilingLockKHR
//         Feature:
//             Name: performanceCounterQueryPools
//             Struct: VkPhysicalDevicePerformanceQueryFeaturesKHR
//     Depends: VKSC_VERSION_1_0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_RESERVATION_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 7
//         Type:
//             Name: VkPerformanceQueryReservationInfoKHR
// Extension: VK_KHR_maintenance2
// Number: 118
// Type: device
// Author: KHR
// Supported: supported
// Promoted to: VK_VERSION_1_1
// Unlocks:
//         Enum:
//             Name: VK_KHR_MAINTENANCE_2_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_MAINTENANCE_2_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_maintenance2&quot;
//         Enum:
//             Name: VK_KHR_MAINTENANCE2_SPEC_VERSION
//             Negative: false
//             Alias: VK_KHR_MAINTENANCE_2_SPEC_VERSION
//         Enum:
//             Name: VK_KHR_MAINTENANCE2_EXTENSION_NAME
//             Negative: false
//             Alias: VK_KHR_MAINTENANCE_2_EXTENSION_NAME
//         Enum:
//             Name: VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT_KHR
//             Negative: false
//             Extends: VkImageCreateFlagBits
//             Alias: VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT
//         Enum:
//             Name: VK_IMAGE_CREATE_EXTENDED_USAGE_BIT_KHR
//             Negative: false
//             Extends: VkImageCreateFlagBits
//             Alias: VK_IMAGE_CREATE_EXTENDED_USAGE_BIT
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES
//         Enum:
//             Name: VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO
//         Enum:
//             Name: VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL_KHR
//             Negative: false
//             Extends: VkImageLayout
//             Alias: VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL
//         Enum:
//             Name: VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL_KHR
//             Negative: false
//             Extends: VkImageLayout
//             Alias: VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL
//         Type:
//             Name: VkPhysicalDevicePointClippingPropertiesKHR
//         Type:
//             Name: VkPointClippingBehaviorKHR
//         Enum:
//             Name: VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES_KHR
//             Negative: false
//             Extends: VkPointClippingBehavior
//             Alias: VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES
//         Enum:
//             Name: VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY_KHR
//             Negative: false
//             Extends: VkPointClippingBehavior
//             Alias: VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY
//         Type:
//             Name: VkRenderPassInputAttachmentAspectCreateInfoKHR
//         Type:
//             Name: VkInputAttachmentAspectReferenceKHR
//         Type:
//             Name: VkImageViewUsageCreateInfoKHR
//         Type:
//             Name: VkTessellationDomainOriginKHR
//         Enum:
//             Name: VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT_KHR
//             Negative: false
//             Extends: VkTessellationDomainOrigin
//             Alias: VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT
//         Enum:
//             Name: VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT_KHR
//             Negative: false
//             Extends: VkTessellationDomainOrigin
//             Alias: VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT
//         Type:
//             Name: VkPipelineTessellationDomainOriginStateCreateInfoKHR
// Extension: VK_KHR_extension_119
// Number: 119
// Type: invalid
// Author: KHR
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_KHR_EXTENSION_119_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_KHR_EXTENSION_119_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_extension_119&quot;
// Extension: VK_KHR_get_surface_capabilities2
// Number: 120
// Type: instance
// Author: KHR
// Depends: VK_KHR_surface
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_GET_SURFACE_CAPABILITIES_2_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_GET_SURFACE_CAPABILITIES_2_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_get_surface_capabilities2&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Type:
//             Name: VkPhysicalDeviceSurfaceInfo2KHR
//         Type:
//             Name: VkSurfaceCapabilities2KHR
//         Type:
//             Name: VkSurfaceFormat2KHR
//         Command:
//             Name: vkGetPhysicalDeviceSurfaceCapabilities2KHR
//         Command:
//             Name: vkGetPhysicalDeviceSurfaceFormats2KHR
// Extension: VK_KHR_variable_pointers
// Number: 121
// Type: device
// Author: KHR
// Depends: (VK_KHR_get_physical_device_properties2+VK_KHR_storage_buffer_storage_class),VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_1
// Unlocks:
//         Enum:
//             Name: VK_KHR_VARIABLE_POINTERS_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_VARIABLE_POINTERS_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_variable_pointers&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES_KHR
//         Type:
//             Name: VkPhysicalDeviceVariablePointerFeaturesKHR
//         Type:
//             Name: VkPhysicalDeviceVariablePointersFeaturesKHR
//         Feature:
//             Name: variablePointersStorageBuffer
//             Struct: VkPhysicalDeviceVariablePointerFeaturesKHR
// Extension: VK_KHR_get_display_properties2
// Number: 122
// Type: instance
// Author: KHR
// Depends: VK_KHR_display
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_GET_DISPLAY_PROPERTIES_2_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_GET_DISPLAY_PROPERTIES_2_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_get_display_properties2&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 4
//         Type:
//             Name: VkDisplayProperties2KHR
//         Type:
//             Name: VkDisplayPlaneProperties2KHR
//         Type:
//             Name: VkDisplayModeProperties2KHR
//         Type:
//             Name: VkDisplayPlaneInfo2KHR
//         Type:
//             Name: VkDisplayPlaneCapabilities2KHR
//         Command:
//             Name: vkGetPhysicalDeviceDisplayProperties2KHR
//         Command:
//             Name: vkGetPhysicalDeviceDisplayPlaneProperties2KHR
//         Command:
//             Name: vkGetDisplayModeProperties2KHR
//         Command:
//             Name: vkGetDisplayPlaneCapabilities2KHR
// Extension: VK_MVK_ios_surface
// Number: 123
// Type: instance
// Author: MVK
// Depends: VK_KHR_surface
// Platform: ios
// Supported: supported
// Deprecated by: VK_EXT_metal_surface
// Unlocks:
//         Enum:
//             Name: VK_MVK_IOS_SURFACE_SPEC_VERSION
//             Negative: false
//             Value: 3
//         Enum:
//             Name: VK_MVK_IOS_SURFACE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_MVK_ios_surface&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkIOSSurfaceCreateFlagsMVK
//         Type:
//             Name: VkIOSSurfaceCreateInfoMVK
//         Command:
//             Name: vkCreateIOSSurfaceMVK
// Extension: VK_MVK_macos_surface
// Number: 124
// Type: instance
// Author: MVK
// Depends: VK_KHR_surface
// Platform: macos
// Supported: supported
// Deprecated by: VK_EXT_metal_surface
// Unlocks:
//         Enum:
//             Name: VK_MVK_MACOS_SURFACE_SPEC_VERSION
//             Negative: false
//             Value: 3
//         Enum:
//             Name: VK_MVK_MACOS_SURFACE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_MVK_macos_surface&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkMacOSSurfaceCreateFlagsMVK
//         Type:
//             Name: VkMacOSSurfaceCreateInfoMVK
//         Command:
//             Name: vkCreateMacOSSurfaceMVK
// Extension: VK_MVK_moltenvk
// Number: 125
// Type: instance
// Author: MVK
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_MVK_MOLTENVK_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_MVK_MOLTENVK_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_MVK_moltenvk&quot;
// Extension: VK_EXT_external_memory_dma_buf
// Number: 126
// Type: device
// Author: EXT
// Depends: VK_KHR_external_memory_fd
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTERNAL_MEMORY_DMA_BUF_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_EXTERNAL_MEMORY_DMA_BUF_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_external_memory_dma_buf&quot;
//         Enum:
//             Name: VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT
//             Negative: false
//             Bitpos: 9
//             Extends: VkExternalMemoryHandleTypeFlagBits
// Extension: VK_EXT_queue_family_foreign
// Number: 127
// Type: device
// Author: EXT
// Depends: VK_KHR_external_memory,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_QUEUE_FAMILY_FOREIGN_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_QUEUE_FAMILY_FOREIGN_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_queue_family_foreign&quot;
//         Enum:
//             Name: VK_QUEUE_FAMILY_FOREIGN_EXT
//             Negative: false
// Extension: VK_KHR_dedicated_allocation
// Number: 128
// Type: device
// Author: KHR
// Depends: VK_KHR_get_memory_requirements2,VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_1
// Unlocks:
//         Enum:
//             Name: VK_KHR_DEDICATED_ALLOCATION_SPEC_VERSION
//             Negative: false
//             Value: 3
//         Enum:
//             Name: VK_KHR_DEDICATED_ALLOCATION_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_dedicated_allocation&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS
//         Enum:
//             Name: VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO
//         Type:
//             Name: VkMemoryDedicatedRequirementsKHR
//         Type:
//             Name: VkMemoryDedicatedAllocateInfoKHR
// Extension: VK_EXT_debug_utils
// Number: 129
// Type: instance
// Author: EXT
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_DEBUG_UTILS_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_EXT_DEBUG_UTILS_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_debug_utils&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 4
//         Enum:
//             Name: VK_OBJECT_TYPE_DEBUG_UTILS_MESSENGER_EXT
//             Negative: false
//             Extends: VkObjectType
//             Offset: 0
//         Type:
//             Name: PFN_vkDebugUtilsMessengerCallbackEXT
//         Type:
//             Name: VkDebugUtilsLabelEXT
//         Type:
//             Name: VkDebugUtilsMessageSeverityFlagBitsEXT
//         Type:
//             Name: VkDebugUtilsMessageSeverityFlagsEXT
//         Type:
//             Name: VkDebugUtilsMessageTypeFlagBitsEXT
//         Type:
//             Name: VkDebugUtilsMessageTypeFlagsEXT
//         Type:
//             Name: VkDebugUtilsMessengerCallbackDataEXT
//         Type:
//             Name: VkDebugUtilsMessengerCallbackDataFlagsEXT
//         Type:
//             Name: VkDebugUtilsMessengerCreateFlagsEXT
//         Type:
//             Name: VkDebugUtilsMessengerCreateInfoEXT
//         Type:
//             Name: VkDebugUtilsMessengerEXT
//         Type:
//             Name: VkDebugUtilsObjectNameInfoEXT
//         Type:
//             Name: VkDebugUtilsObjectTagInfoEXT
//         Command:
//             Name: vkSetDebugUtilsObjectNameEXT
//         Command:
//             Name: vkSetDebugUtilsObjectTagEXT
//         Command:
//             Name: vkQueueBeginDebugUtilsLabelEXT
//         Command:
//             Name: vkQueueEndDebugUtilsLabelEXT
//         Command:
//             Name: vkQueueInsertDebugUtilsLabelEXT
//         Command:
//             Name: vkCmdBeginDebugUtilsLabelEXT
//         Command:
//             Name: vkCmdEndDebugUtilsLabelEXT
//         Command:
//             Name: vkCmdInsertDebugUtilsLabelEXT
//         Command:
//             Name: vkCreateDebugUtilsMessengerEXT
//         Command:
//             Name: vkDestroyDebugUtilsMessengerEXT
//         Command:
//             Name: vkSubmitDebugUtilsMessageEXT
// Extension: VK_ANDROID_external_memory_android_hardware_buffer
// Number: 130
// Type: device
// Author: ANDROID
// Depends: ((VK_KHR_sampler_ycbcr_conversion+VK_KHR_external_memory+VK_KHR_dedicated_allocation),VK_VERSION_1_1)+VK_EXT_queue_family_foreign
// Platform: android
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_SPEC_VERSION
//             Negative: false
//             Value: 5
//         Enum:
//             Name: VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_ANDROID_external_memory_android_hardware_buffer&quot;
//         Enum:
//             Name: VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID
//             Negative: false
//             Bitpos: 10
//             Extends: VkExternalMemoryHandleTypeFlagBits
//         Enum:
//             Name: VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Enum:
//             Name: VK_STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID
//             Negative: false
//             Extends: VkStructureType
//             Offset: 4
//         Enum:
//             Name: VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID
//             Negative: false
//             Extends: VkStructureType
//             Offset: 5
//         Type:
//             Name: VkAndroidHardwareBufferUsageANDROID
//         Type:
//             Name: VkAndroidHardwareBufferPropertiesANDROID
//         Type:
//             Name: VkAndroidHardwareBufferFormatPropertiesANDROID
//         Type:
//             Name: VkImportAndroidHardwareBufferInfoANDROID
//         Type:
//             Name: VkMemoryGetAndroidHardwareBufferInfoANDROID
//         Type:
//             Name: VkExternalFormatANDROID
//         Command:
//             Name: vkGetAndroidHardwareBufferPropertiesANDROID
//         Command:
//             Name: vkGetMemoryAndroidHardwareBufferANDROID
//         Type:
//             Name: AHardwareBuffer
//     Depends: VK_KHR_format_feature_flags2,VK_VERSION_1_3
//         Type:
//             Name: VkAndroidHardwareBufferFormatProperties2ANDROID
//         Enum:
//             Name: VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_2_ANDROID
//             Negative: false
//             Extends: VkStructureType
//             Offset: 6
// Extension: VK_EXT_sampler_filter_minmax
// Number: 131
// Type: device
// Author: NV
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_2
// Unlocks:
//         Enum:
//             Name: VK_EXT_SAMPLER_FILTER_MINMAX_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_EXT_SAMPLER_FILTER_MINMAX_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_sampler_filter_minmax&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO
//         Enum:
//             Name: VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT_EXT
//             Negative: false
//             Extends: VkFormatFeatureFlagBits
//             Alias: VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT
//         Enum:
//             Name: VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_EXT
//             Negative: false
//             Extends: VkSamplerReductionMode
//             Alias: VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE
//         Enum:
//             Name: VK_SAMPLER_REDUCTION_MODE_MIN_EXT
//             Negative: false
//             Extends: VkSamplerReductionMode
//             Alias: VK_SAMPLER_REDUCTION_MODE_MIN
//         Enum:
//             Name: VK_SAMPLER_REDUCTION_MODE_MAX_EXT
//             Negative: false
//             Extends: VkSamplerReductionMode
//             Alias: VK_SAMPLER_REDUCTION_MODE_MAX
//         Type:
//             Name: VkSamplerReductionModeEXT
//         Type:
//             Name: VkSamplerReductionModeCreateInfoEXT
//         Type:
//             Name: VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT
// Extension: VK_KHR_storage_buffer_storage_class
// Number: 132
// Type: device
// Author: KHR
// Supported: supported
// Promoted to: VK_VERSION_1_1
// Unlocks:
//         Enum:
//             Name: VK_KHR_STORAGE_BUFFER_STORAGE_CLASS_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_STORAGE_BUFFER_STORAGE_CLASS_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_storage_buffer_storage_class&quot;
// Extension: VK_AMD_gpu_shader_int16
// Number: 133
// Type: device
// Author: AMD
// Supported: supported
// Deprecated by: VK_KHR_shader_float16_int8
// Unlocks:
//         Enum:
//             Name: VK_AMD_GPU_SHADER_INT16_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_AMD_GPU_SHADER_INT16_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_gpu_shader_int16&quot;
// Extension: VK_AMD_extension_134
// Number: 134
// Type: invalid
// Author: AMD
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_AMD_EXTENSION_134_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_AMD_EXTENSION_134_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_extension_134&quot;
// Extension: VK_AMDX_shader_enqueue
// Number: 135
// Type: device
// Author: AMD
// Depends: ((VK_KHR_synchronization2+VK_KHR_spirv_1_4+VK_EXT_extended_dynamic_state),VK_VERSION_1_3)+VK_KHR_maintenance5+VK_KHR_pipeline_library
// Platform: provisional
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_AMDX_SHADER_ENQUEUE_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_AMDX_SHADER_ENQUEUE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMDX_shader_enqueue&quot;
//         Enum:
//             Name: VK_SHADER_INDEX_UNUSED_AMDX
//             Negative: false
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ENQUEUE_FEATURES_AMDX
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ENQUEUE_PROPERTIES_AMDX
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_EXECUTION_GRAPH_PIPELINE_SCRATCH_SIZE_AMDX
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_EXECUTION_GRAPH_PIPELINE_CREATE_INFO_AMDX
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_NODE_CREATE_INFO_AMDX
//             Negative: false
//             Extends: VkStructureType
//             Offset: 4
//         Enum:
//             Name: VK_BUFFER_USAGE_EXECUTION_GRAPH_SCRATCH_BIT_AMDX
//             Negative: false
//             Bitpos: 25
//             Extends: VkBufferUsageFlagBits
//         Enum:
//             Name: VK_PIPELINE_BIND_POINT_EXECUTION_GRAPH_AMDX
//             Negative: false
//             Extends: VkPipelineBindPoint
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceShaderEnqueueFeaturesAMDX
//         Type:
//             Name: VkPhysicalDeviceShaderEnqueuePropertiesAMDX
//         Type:
//             Name: VkExecutionGraphPipelineScratchSizeAMDX
//         Type:
//             Name: VkExecutionGraphPipelineCreateInfoAMDX
//         Type:
//             Name: VkDispatchGraphInfoAMDX
//         Type:
//             Name: VkDispatchGraphCountInfoAMDX
//         Type:
//             Name: VkPipelineShaderStageNodeCreateInfoAMDX
//         Type:
//             Name: VkDeviceOrHostAddressConstAMDX
//         Command:
//             Name: vkCreateExecutionGraphPipelinesAMDX
//         Command:
//             Name: vkGetExecutionGraphPipelineScratchSizeAMDX
//         Command:
//             Name: vkGetExecutionGraphPipelineNodeIndexAMDX
//         Command:
//             Name: vkCmdInitializeGraphScratchMemoryAMDX
//         Command:
//             Name: vkCmdDispatchGraphAMDX
//         Command:
//             Name: vkCmdDispatchGraphIndirectAMDX
//         Command:
//             Name: vkCmdDispatchGraphIndirectCountAMDX
//         Feature:
//             Name: shaderEnqueue
//             Struct: VkPhysicalDeviceShaderEnqueueFeaturesAMDX
//     Depends: VK_KHR_maintenance5,VK_VERSION_1_4
//         Enum:
//             Name: VK_BUFFER_USAGE_2_EXECUTION_GRAPH_SCRATCH_BIT_AMDX
//             Negative: false
//             Bitpos: 25
//             Extends: VkBufferUsageFlagBits2
//         Enum:
//             Name: VK_PIPELINE_CREATE_2_EXECUTION_GRAPH_BIT_AMDX
//             Negative: false
//             Bitpos: 32
//             Extends: VkPipelineCreateFlagBits2
//     Depends: VK_EXT_mesh_shader
//         Feature:
//             Name: shaderMeshEnqueue
//             Struct: VkPhysicalDeviceShaderEnqueueFeaturesAMDX
// Extension: VK_KHR_extension_136
// Number: 136
// Type: device
// Author: KHR
// Depends: VK_KHR_maintenance5
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_KHR_EXTENSION_136_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_KHR_EXTENSION_136_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_extension_136&quot;
//         Enum:
//             Name: VK_BUFFER_USAGE_RESERVED_28_BIT_KHR
//             Negative: false
//             Bitpos: 28
//             Extends: VkBufferUsageFlagBits
//         Enum:
//             Name: VK_PIPELINE_CREATE_RESERVED_36_BIT_KHR
//             Negative: false
//             Bitpos: 36
//             Extends: VkPipelineCreateFlagBits2
//         Enum:
//             Name: VK_PIPELINE_CREATE_RESERVED_39_BIT_KHR
//             Negative: false
//             Bitpos: 39
//             Extends: VkPipelineCreateFlagBits2
//         Enum:
//             Name: VK_ACCESS_2_RESERVED_57_BIT_KHR
//             Negative: false
//             Bitpos: 57
//             Extends: VkAccessFlagBits2
//         Enum:
//             Name: VK_ACCESS_2_RESERVED_58_BIT_KHR
//             Negative: false
//             Bitpos: 58
//             Extends: VkAccessFlagBits2
//         Enum:
//             Name: VK_ACCESS_2_RESERVED_59_BIT_KHR
//             Negative: false
//             Bitpos: 59
//             Extends: VkAccessFlagBits2
//     Depends: VK_KHR_maintenance5,VK_VERSION_1_4
//         Enum:
//             Name: VK_BUFFER_USAGE_2_RESERVED_28_BIT_KHR
//             Negative: false
//             Bitpos: 28
//             Extends: VkBufferUsageFlagBits2
//     Depends: VK_EXT_shader_object
//         Enum:
//             Name: VK_SHADER_CREATE_RESERVED_10_BIT_KHR
//             Negative: false
//             Bitpos: 10
//             Extends: VkShaderCreateFlagBitsEXT
//         Enum:
//             Name: VK_SHADER_CREATE_RESERVED_11_BIT_KHR
//             Negative: false
//             Bitpos: 11
//             Extends: VkShaderCreateFlagBitsEXT
//     Depends: VK_ARM_tensors
//         Enum:
//             Name: VK_TENSOR_CREATE_RESERVED_3_BIT_ARM
//             Negative: false
//             Bitpos: 3
//             Extends: VkTensorCreateFlagBitsARM
// Extension: VK_AMD_mixed_attachment_samples
// Number: 137
// Type: device
// Author: AMD
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_AMD_MIXED_ATTACHMENT_SAMPLES_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_AMD_MIXED_ATTACHMENT_SAMPLES_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_mixed_attachment_samples&quot;
//     Depends: VK_VERSION_1_3,VK_KHR_dynamic_rendering
//         Enum:
//             Name: VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD
//             Negative: false
//             Extends: VkStructureType
//             Extnumber: 45
//             Offset: 8
//         Type:
//             Name: VkAttachmentSampleCountInfoAMD
// Extension: VK_AMD_shader_fragment_mask
// Number: 138
// Type: device
// Author: AMD
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_AMD_SHADER_FRAGMENT_MASK_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_AMD_SHADER_FRAGMENT_MASK_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_shader_fragment_mask&quot;
// Extension: VK_EXT_inline_uniform_block
// Number: 139
// Type: device
// Author: EXT
// Depends: (VK_KHR_get_physical_device_properties2+VK_KHR_maintenance1),VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_3
// Unlocks:
//         Enum:
//             Name: VK_EXT_INLINE_UNIFORM_BLOCK_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_INLINE_UNIFORM_BLOCK_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_inline_uniform_block&quot;
//         Enum:
//             Name: VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT
//             Negative: false
//             Extends: VkDescriptorType
//             Alias: VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES
//         Enum:
//             Name: VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO
//         Type:
//             Name: VkPhysicalDeviceInlineUniformBlockFeaturesEXT
//         Type:
//             Name: VkPhysicalDeviceInlineUniformBlockPropertiesEXT
//         Type:
//             Name: VkWriteDescriptorSetInlineUniformBlockEXT
//         Type:
//             Name: VkDescriptorPoolInlineUniformBlockCreateInfoEXT
//         Feature:
//             Name: inlineUniformBlock
//             Struct: VkPhysicalDeviceInlineUniformBlockFeaturesEXT
//     Depends: VK_EXT_descriptor_indexing
//         Feature:
//             Name: descriptorBindingInlineUniformBlockUpdateAfterBind
//             Struct: VkPhysicalDeviceInlineUniformBlockFeatures
//     Depends: VK_VERSION_1_2+VkPhysicalDeviceVulkan12Features::descriptorIndexing
//         Feature:
//             Name: descriptorBindingInlineUniformBlockUpdateAfterBind
//             Struct: VkPhysicalDeviceInlineUniformBlockFeatures
// Extension: VK_AMD_extension_140
// Number: 140
// Type: invalid
// Author: AMD
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_AMD_EXTENSION_140_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_AMD_EXTENSION_140_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_extension_140&quot;
// Extension: VK_EXT_shader_stencil_export
// Number: 141
// Type: device
// Author: EXT
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_SHADER_STENCIL_EXPORT_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_SHADER_STENCIL_EXPORT_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_shader_stencil_export&quot;
// Extension: VK_KHR_shader_bfloat16
// Number: 142
// Type: device
// Author: KHR
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_SHADER_BFLOAT16_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_SHADER_BFLOAT16_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_shader_bfloat16&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_BFLOAT16_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceShaderBfloat16FeaturesKHR
//         Feature:
//             Name: shaderBFloat16Type
//             Struct: VkPhysicalDeviceShaderBfloat16FeaturesKHR
//         Feature:
//             Name: shaderBFloat16CooperativeMatrix,shaderBFloat16DotProduct
//             Struct: VkPhysicalDeviceShaderBfloat16FeaturesKHR
//     Depends: VK_KHR_cooperative_matrix
//         Enum:
//             Name: VK_COMPONENT_TYPE_BFLOAT16_KHR
//             Negative: false
//             Extends: VkComponentTypeKHR
//             Offset: 0
// Extension: VK_AMD_extension_143
// Number: 143
// Type: invalid
// Author: AMD
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_AMD_EXTENSION_143_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_AMD_EXTENSION_143_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_extension_143&quot;
// Extension: VK_EXT_sample_locations
// Number: 144
// Type: device
// Author: AMD
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_SAMPLE_LOCATIONS_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_SAMPLE_LOCATIONS_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_sample_locations&quot;
//         Enum:
//             Name: VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT
//             Negative: false
//             Bitpos: 12
//             Extends: VkImageCreateFlagBits
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Enum:
//             Name: VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 4
//         Enum:
//             Name: VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT
//             Negative: false
//             Extends: VkDynamicState
//             Offset: 0
//         Type:
//             Name: VkSampleLocationEXT
//         Type:
//             Name: VkSampleLocationsInfoEXT
//         Type:
//             Name: VkAttachmentSampleLocationsEXT
//         Type:
//             Name: VkSubpassSampleLocationsEXT
//         Type:
//             Name: VkRenderPassSampleLocationsBeginInfoEXT
//         Type:
//             Name: VkPipelineSampleLocationsStateCreateInfoEXT
//         Type:
//             Name: VkPhysicalDeviceSampleLocationsPropertiesEXT
//         Type:
//             Name: VkMultisamplePropertiesEXT
//         Command:
//             Name: vkCmdSetSampleLocationsEXT
//         Command:
//             Name: vkGetPhysicalDeviceMultisamplePropertiesEXT
// Extension: VK_KHR_relaxed_block_layout
// Number: 145
// Type: device
// Author: KHR
// Supported: supported
// Promoted to: VK_VERSION_1_1
// Unlocks:
//         Enum:
//             Name: VK_KHR_RELAXED_BLOCK_LAYOUT_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_RELAXED_BLOCK_LAYOUT_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_relaxed_block_layout&quot;
// Extension: VK_RESERVED_do_not_use_146
// Number: 146
// Type: invalid
// Supported: disabled
// Comment:
//     Used for functionality subsumed into Vulkan 1.1 and not published as an extension
// Unlocks:
//         Enum:
//             Name: VK_RESERVED_DO_NOT_USE_146_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_RESERVED_DO_NOT_USE_146_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_RESERVED_do_not_use_146&quot;
// Extension: VK_KHR_get_memory_requirements2
// Number: 147
// Type: device
// Author: KHR
// Supported: supported
// Promoted to: VK_VERSION_1_1
// Unlocks:
//         Enum:
//             Name: VK_KHR_GET_MEMORY_REQUIREMENTS_2_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_GET_MEMORY_REQUIREMENTS_2_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_get_memory_requirements2&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2
//         Type:
//             Name: VkBufferMemoryRequirementsInfo2KHR
//         Type:
//             Name: VkImageMemoryRequirementsInfo2KHR
//         Type:
//             Name: VkImageSparseMemoryRequirementsInfo2KHR
//         Type:
//             Name: VkMemoryRequirements2KHR
//         Type:
//             Name: VkSparseImageMemoryRequirements2KHR
//         Command:
//             Name: vkGetImageMemoryRequirements2KHR
//         Command:
//             Name: vkGetBufferMemoryRequirements2KHR
//         Command:
//             Name: vkGetImageSparseMemoryRequirements2KHR
// Extension: VK_KHR_image_format_list
// Number: 148
// Type: device
// Author: KHR
// Supported: supported
// Promoted to: VK_VERSION_1_2
// Unlocks:
//         Enum:
//             Name: VK_KHR_IMAGE_FORMAT_LIST_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_IMAGE_FORMAT_LIST_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_image_format_list&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO
//         Type:
//             Name: VkImageFormatListCreateInfoKHR
// Extension: VK_EXT_blend_operation_advanced
// Number: 149
// Type: device
// Author: NV
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_BLEND_OPERATION_ADVANCED_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_EXT_BLEND_OPERATION_ADVANCED_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_blend_operation_advanced&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Type:
//             Name: VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT
//         Type:
//             Name: VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT
//         Type:
//             Name: VkPipelineColorBlendAdvancedStateCreateInfoEXT
//         Type:
//             Name: VkBlendOverlapEXT
//         Enum:
//             Name: VK_BLEND_OP_ZERO_EXT
//             Negative: false
//             Extends: VkBlendOp
//             Offset: 0
//         Enum:
//             Name: VK_BLEND_OP_SRC_EXT
//             Negative: false
//             Extends: VkBlendOp
//             Offset: 1
//         Enum:
//             Name: VK_BLEND_OP_DST_EXT
//             Negative: false
//             Extends: VkBlendOp
//             Offset: 2
//         Enum:
//             Name: VK_BLEND_OP_SRC_OVER_EXT
//             Negative: false
//             Extends: VkBlendOp
//             Offset: 3
//         Enum:
//             Name: VK_BLEND_OP_DST_OVER_EXT
//             Negative: false
//             Extends: VkBlendOp
//             Offset: 4
//         Enum:
//             Name: VK_BLEND_OP_SRC_IN_EXT
//             Negative: false
//             Extends: VkBlendOp
//             Offset: 5
//         Enum:
//             Name: VK_BLEND_OP_DST_IN_EXT
//             Negative: false
//             Extends: VkBlendOp
//             Offset: 6
//         Enum:
//             Name: VK_BLEND_OP_SRC_OUT_EXT
//             Negative: false
//             Extends: VkBlendOp
//             Offset: 7
//         Enum:
//             Name: VK_BLEND_OP_DST_OUT_EXT
//             Negative: false
//             Extends: VkBlendOp
//             Offset: 8
//         Enum:
//             Name: VK_BLEND_OP_SRC_ATOP_EXT
//             Negative: false
//             Extends: VkBlendOp
//             Offset: 9
//         Enum:
//             Name: VK_BLEND_OP_DST_ATOP_EXT
//             Negative: false
//             Extends: VkBlendOp
//             Offset: 10
//         Enum:
//             Name: VK_BLEND_OP_XOR_EXT
//             Negative: false
//             Extends: VkBlendOp
//             Offset: 11
//         Enum:
//             Name: VK_BLEND_OP_MULTIPLY_EXT
//             Negative: false
//             Extends: VkBlendOp
//             Offset: 12
//         Enum:
//             Name: VK_BLEND_OP_SCREEN_EXT
//             Negative: false
//             Extends: VkBlendOp
//             Offset: 13
//         Enum:
//             Name: VK_BLEND_OP_OVERLAY_EXT
//             Negative: false
//             Extends: VkBlendOp
//             Offset: 14
//         Enum:
//             Name: VK_BLEND_OP_DARKEN_EXT
//             Negative: false
//             Extends: VkBlendOp
//             Offset: 15
//         Enum:
//             Name: VK_BLEND_OP_LIGHTEN_EXT
//             Negative: false
//             Extends: VkBlendOp
//             Offset: 16
//         Enum:
//             Name: VK_BLEND_OP_COLORDODGE_EXT
//             Negative: false
//             Extends: VkBlendOp
//             Offset: 17
//         Enum:
//             Name: VK_BLEND_OP_COLORBURN_EXT
//             Negative: false
//             Extends: VkBlendOp
//             Offset: 18
//         Enum:
//             Name: VK_BLEND_OP_HARDLIGHT_EXT
//             Negative: false
//             Extends: VkBlendOp
//             Offset: 19
//         Enum:
//             Name: VK_BLEND_OP_SOFTLIGHT_EXT
//             Negative: false
//             Extends: VkBlendOp
//             Offset: 20
//         Enum:
//             Name: VK_BLEND_OP_DIFFERENCE_EXT
//             Negative: false
//             Extends: VkBlendOp
//             Offset: 21
//         Enum:
//             Name: VK_BLEND_OP_EXCLUSION_EXT
//             Negative: false
//             Extends: VkBlendOp
//             Offset: 22
//         Enum:
//             Name: VK_BLEND_OP_INVERT_EXT
//             Negative: false
//             Extends: VkBlendOp
//             Offset: 23
//         Enum:
//             Name: VK_BLEND_OP_INVERT_RGB_EXT
//             Negative: false
//             Extends: VkBlendOp
//             Offset: 24
//         Enum:
//             Name: VK_BLEND_OP_LINEARDODGE_EXT
//             Negative: false
//             Extends: VkBlendOp
//             Offset: 25
//         Enum:
//             Name: VK_BLEND_OP_LINEARBURN_EXT
//             Negative: false
//             Extends: VkBlendOp
//             Offset: 26
//         Enum:
//             Name: VK_BLEND_OP_VIVIDLIGHT_EXT
//             Negative: false
//             Extends: VkBlendOp
//             Offset: 27
//         Enum:
//             Name: VK_BLEND_OP_LINEARLIGHT_EXT
//             Negative: false
//             Extends: VkBlendOp
//             Offset: 28
//         Enum:
//             Name: VK_BLEND_OP_PINLIGHT_EXT
//             Negative: false
//             Extends: VkBlendOp
//             Offset: 29
//         Enum:
//             Name: VK_BLEND_OP_HARDMIX_EXT
//             Negative: false
//             Extends: VkBlendOp
//             Offset: 30
//         Enum:
//             Name: VK_BLEND_OP_HSL_HUE_EXT
//             Negative: false
//             Extends: VkBlendOp
//             Offset: 31
//         Enum:
//             Name: VK_BLEND_OP_HSL_SATURATION_EXT
//             Negative: false
//             Extends: VkBlendOp
//             Offset: 32
//         Enum:
//             Name: VK_BLEND_OP_HSL_COLOR_EXT
//             Negative: false
//             Extends: VkBlendOp
//             Offset: 33
//         Enum:
//             Name: VK_BLEND_OP_HSL_LUMINOSITY_EXT
//             Negative: false
//             Extends: VkBlendOp
//             Offset: 34
//         Enum:
//             Name: VK_BLEND_OP_PLUS_EXT
//             Negative: false
//             Extends: VkBlendOp
//             Offset: 35
//         Enum:
//             Name: VK_BLEND_OP_PLUS_CLAMPED_EXT
//             Negative: false
//             Extends: VkBlendOp
//             Offset: 36
//         Enum:
//             Name: VK_BLEND_OP_PLUS_CLAMPED_ALPHA_EXT
//             Negative: false
//             Extends: VkBlendOp
//             Offset: 37
//         Enum:
//             Name: VK_BLEND_OP_PLUS_DARKER_EXT
//             Negative: false
//             Extends: VkBlendOp
//             Offset: 38
//         Enum:
//             Name: VK_BLEND_OP_MINUS_EXT
//             Negative: false
//             Extends: VkBlendOp
//             Offset: 39
//         Enum:
//             Name: VK_BLEND_OP_MINUS_CLAMPED_EXT
//             Negative: false
//             Extends: VkBlendOp
//             Offset: 40
//         Enum:
//             Name: VK_BLEND_OP_CONTRAST_EXT
//             Negative: false
//             Extends: VkBlendOp
//             Offset: 41
//         Enum:
//             Name: VK_BLEND_OP_INVERT_OVG_EXT
//             Negative: false
//             Extends: VkBlendOp
//             Offset: 42
//         Enum:
//             Name: VK_BLEND_OP_RED_EXT
//             Negative: false
//             Extends: VkBlendOp
//             Offset: 43
//         Enum:
//             Name: VK_BLEND_OP_GREEN_EXT
//             Negative: false
//             Extends: VkBlendOp
//             Offset: 44
//         Enum:
//             Name: VK_BLEND_OP_BLUE_EXT
//             Negative: false
//             Extends: VkBlendOp
//             Offset: 45
//         Enum:
//             Name: VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT
//             Negative: false
//             Bitpos: 19
//             Extends: VkAccessFlagBits
// Extension: VK_NV_fragment_coverage_to_color
// Number: 150
// Type: device
// Author: NV
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NV_FRAGMENT_COVERAGE_TO_COLOR_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_NV_FRAGMENT_COVERAGE_TO_COLOR_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_fragment_coverage_to_color&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPipelineCoverageToColorStateCreateFlagsNV
//         Type:
//             Name: VkPipelineCoverageToColorStateCreateInfoNV
// Extension: VK_KHR_acceleration_structure
// Number: 151
// Type: device
// Author: KHR
// Depends: ((VK_VERSION_1_1+VK_EXT_descriptor_indexing+VK_KHR_buffer_device_address),VK_VERSION_1_2)+VK_KHR_deferred_host_operations
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_ACCELERATION_STRUCTURE_SPEC_VERSION
//             Negative: false
//             Value: 13
//         Enum:
//             Name: VK_KHR_ACCELERATION_STRUCTURE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_acceleration_structure&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 7
//         Enum:
//             Name: VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_AABBS_DATA_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Enum:
//             Name: VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 4
//         Enum:
//             Name: VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 5
//         Enum:
//             Name: VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 6
//         Enum:
//             Name: VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_VERSION_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 9
//         Enum:
//             Name: VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 10
//         Enum:
//             Name: VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 11
//         Enum:
//             Name: VK_STRUCTURE_TYPE_COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 12
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 13
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 14
//         Enum:
//             Name: VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 17
//         Enum:
//             Name: VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 20
//         Enum:
//             Name: VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR
//             Negative: false
//             Bitpos: 25
//             Extends: VkPipelineStageFlagBits
//         Enum:
//             Name: VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR
//             Negative: false
//             Extends: VkDescriptorType
//             Offset: 0
//         Enum:
//             Name: VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR
//             Negative: false
//             Bitpos: 21
//             Extends: VkAccessFlagBits
//         Enum:
//             Name: VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_KHR
//             Negative: false
//             Bitpos: 22
//             Extends: VkAccessFlagBits
//         Enum:
//             Name: VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_KHR
//             Negative: false
//             Extends: VkQueryType
//             Offset: 0
//         Enum:
//             Name: VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_SIZE_KHR
//             Negative: false
//             Extends: VkQueryType
//             Offset: 1
//         Enum:
//             Name: VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_KHR
//             Negative: false
//             Extends: VkObjectType
//             Offset: 0
//         Enum:
//             Name: VK_INDEX_TYPE_NONE_KHR
//             Negative: false
//             Extends: VkIndexType
//             Extnumber: 166
//             Offset: 0
//         Enum:
//             Name: VK_FORMAT_FEATURE_ACCELERATION_STRUCTURE_VERTEX_BUFFER_BIT_KHR
//             Negative: false
//             Bitpos: 29
//             Extends: VkFormatFeatureFlagBits
//         Enum:
//             Name: VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR
//             Negative: false
//             Bitpos: 19
//             Extends: VkBufferUsageFlagBits
//         Enum:
//             Name: VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR
//             Negative: false
//             Bitpos: 20
//             Extends: VkBufferUsageFlagBits
//         Enum:
//             Name: VK_COPY_ACCELERATION_STRUCTURE_MODE_SERIALIZE_KHR
//             Negative: false
//             Value: 2
//             Extends: VkCopyAccelerationStructureModeKHR
//         Enum:
//             Name: VK_COPY_ACCELERATION_STRUCTURE_MODE_DESERIALIZE_KHR
//             Negative: false
//             Value: 3
//             Extends: VkCopyAccelerationStructureModeKHR
//         Type:
//             Name: VkAccelerationStructureTypeKHR
//         Type:
//             Name: VkDeviceOrHostAddressKHR
//         Type:
//             Name: VkDeviceOrHostAddressConstKHR
//         Type:
//             Name: VkAccelerationStructureBuildRangeInfoKHR
//         Type:
//             Name: VkAabbPositionsKHR
//         Type:
//             Name: VkAccelerationStructureGeometryTrianglesDataKHR
//         Type:
//             Name: VkTransformMatrixKHR
//         Type:
//             Name: VkAccelerationStructureBuildGeometryInfoKHR
//         Type:
//             Name: VkAccelerationStructureBuildTypeKHR
//         Type:
//             Name: VkAccelerationStructureGeometryAabbsDataKHR
//         Type:
//             Name: VkAccelerationStructureInstanceKHR
//         Type:
//             Name: VkAccelerationStructureGeometryInstancesDataKHR
//         Type:
//             Name: VkAccelerationStructureGeometryDataKHR
//         Type:
//             Name: VkAccelerationStructureGeometryKHR
//         Type:
//             Name: VkGeometryFlagsKHR
//         Type:
//             Name: VkGeometryInstanceFlagsKHR
//         Type:
//             Name: VkGeometryFlagBitsKHR
//         Type:
//             Name: VkGeometryInstanceFlagBitsKHR
//         Type:
//             Name: VkAccelerationStructureCreateInfoKHR
//         Type:
//             Name: VkAccelerationStructureKHR
//         Type:
//             Name: VkBuildAccelerationStructureFlagBitsKHR
//         Type:
//             Name: VkBuildAccelerationStructureFlagsKHR
//         Type:
//             Name: VkCopyAccelerationStructureModeKHR
//         Type:
//             Name: VkGeometryTypeKHR
//         Type:
//             Name: VkWriteDescriptorSetAccelerationStructureKHR
//         Type:
//             Name: VkPhysicalDeviceAccelerationStructureFeaturesKHR
//         Type:
//             Name: VkPhysicalDeviceAccelerationStructurePropertiesKHR
//         Type:
//             Name: VkAccelerationStructureDeviceAddressInfoKHR
//         Type:
//             Name: VkAccelerationStructureVersionInfoKHR
//         Type:
//             Name: VkCopyAccelerationStructureToMemoryInfoKHR
//         Type:
//             Name: VkCopyMemoryToAccelerationStructureInfoKHR
//         Type:
//             Name: VkCopyAccelerationStructureInfoKHR
//         Type:
//             Name: VkAccelerationStructureCompatibilityKHR
//         Type:
//             Name: VkAccelerationStructureCreateFlagBitsKHR
//         Type:
//             Name: VkAccelerationStructureCreateFlagsKHR
//         Type:
//             Name: VkBuildAccelerationStructureModeKHR
//         Type:
//             Name: VkAccelerationStructureBuildSizesInfoKHR
//         Command:
//             Name: vkCreateAccelerationStructureKHR
//         Command:
//             Name: vkDestroyAccelerationStructureKHR
//         Command:
//             Name: vkCmdBuildAccelerationStructuresKHR
//         Command:
//             Name: vkCmdBuildAccelerationStructuresIndirectKHR
//         Command:
//             Name: vkBuildAccelerationStructuresKHR
//         Command:
//             Name: vkCopyAccelerationStructureKHR
//         Command:
//             Name: vkCopyAccelerationStructureToMemoryKHR
//         Command:
//             Name: vkCopyMemoryToAccelerationStructureKHR
//         Command:
//             Name: vkWriteAccelerationStructuresPropertiesKHR
//         Command:
//             Name: vkCmdCopyAccelerationStructureKHR
//         Command:
//             Name: vkCmdCopyAccelerationStructureToMemoryKHR
//         Command:
//             Name: vkCmdCopyMemoryToAccelerationStructureKHR
//         Command:
//             Name: vkGetAccelerationStructureDeviceAddressKHR
//         Command:
//             Name: vkCmdWriteAccelerationStructuresPropertiesKHR
//         Command:
//             Name: vkGetDeviceAccelerationStructureCompatibilityKHR
//         Command:
//             Name: vkGetAccelerationStructureBuildSizesKHR
//         Feature:
//             Name: accelerationStructure
//             Struct: VkPhysicalDeviceAccelerationStructureFeaturesKHR
//         Feature:
//             Name: bufferDeviceAddress
//             Struct: VkPhysicalDeviceBufferDeviceAddressFeatures
//         Feature:
//             Name: descriptorBindingAccelerationStructureUpdateAfterBind
//             Struct: VkPhysicalDeviceAccelerationStructureFeaturesKHR
//     Depends: VK_KHR_format_feature_flags2,VK_VERSION_1_3
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_ACCELERATION_STRUCTURE_VERTEX_BUFFER_BIT_KHR
//             Negative: false
//             Bitpos: 29
//             Extends: VkFormatFeatureFlagBits2
//     Depends: VK_EXT_debug_report
//         Enum:
//             Name: VK_DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_KHR_EXT
//             Negative: false
//             Extends: VkDebugReportObjectTypeEXT
//             Offset: 0
//     Depends: VK_VERSION_1_2
//         Feature:
//             Name: descriptorIndexing
//             Struct: VkPhysicalDeviceVulkan12Features
// Extension: VK_KHR_ray_tracing_pipeline
// Number: 348
// Type: device
// Author: KHR
// Depends: (VK_KHR_spirv_1_4,VK_VERSION_1_2)+VK_KHR_acceleration_structure
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_RAY_TRACING_PIPELINE_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_RAY_TRACING_PIPELINE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_ray_tracing_pipeline&quot;
//         Enum:
//             Name: VK_SHADER_UNUSED_KHR
//             Negative: false
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Extnumber: 151
//             Offset: 15
//         Enum:
//             Name: VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Extnumber: 151
//             Offset: 16
//         Enum:
//             Name: VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_INTERFACE_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Extnumber: 151
//             Offset: 18
//         Enum:
//             Name: VK_SHADER_STAGE_RAYGEN_BIT_KHR
//             Negative: false
//             Bitpos: 8
//             Extends: VkShaderStageFlagBits
//         Enum:
//             Name: VK_SHADER_STAGE_ANY_HIT_BIT_KHR
//             Negative: false
//             Bitpos: 9
//             Extends: VkShaderStageFlagBits
//         Enum:
//             Name: VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR
//             Negative: false
//             Bitpos: 10
//             Extends: VkShaderStageFlagBits
//         Enum:
//             Name: VK_SHADER_STAGE_MISS_BIT_KHR
//             Negative: false
//             Bitpos: 11
//             Extends: VkShaderStageFlagBits
//         Enum:
//             Name: VK_SHADER_STAGE_INTERSECTION_BIT_KHR
//             Negative: false
//             Bitpos: 12
//             Extends: VkShaderStageFlagBits
//         Enum:
//             Name: VK_SHADER_STAGE_CALLABLE_BIT_KHR
//             Negative: false
//             Bitpos: 13
//             Extends: VkShaderStageFlagBits
//         Enum:
//             Name: VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_KHR
//             Negative: false
//             Bitpos: 21
//             Extends: VkPipelineStageFlagBits
//         Enum:
//             Name: VK_BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR
//             Negative: false
//             Bitpos: 10
//             Extends: VkBufferUsageFlagBits
//         Enum:
//             Name: VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR
//             Negative: false
//             Extends: VkPipelineBindPoint
//             Extnumber: 166
//             Offset: 0
//         Enum:
//             Name: VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR
//             Negative: false
//             Bitpos: 14
//             Extends: VkPipelineCreateFlagBits
//         Enum:
//             Name: VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR
//             Negative: false
//             Bitpos: 15
//             Extends: VkPipelineCreateFlagBits
//         Enum:
//             Name: VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR
//             Negative: false
//             Bitpos: 16
//             Extends: VkPipelineCreateFlagBits
//         Enum:
//             Name: VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR
//             Negative: false
//             Bitpos: 17
//             Extends: VkPipelineCreateFlagBits
//         Enum:
//             Name: VK_PIPELINE_CREATE_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR
//             Negative: false
//             Bitpos: 12
//             Extends: VkPipelineCreateFlagBits
//         Enum:
//             Name: VK_PIPELINE_CREATE_RAY_TRACING_SKIP_AABBS_BIT_KHR
//             Negative: false
//             Bitpos: 13
//             Extends: VkPipelineCreateFlagBits
//         Enum:
//             Name: VK_PIPELINE_CREATE_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR
//             Negative: false
//             Bitpos: 19
//             Extends: VkPipelineCreateFlagBits
//         Enum:
//             Name: VK_DYNAMIC_STATE_RAY_TRACING_PIPELINE_STACK_SIZE_KHR
//             Negative: false
//             Extends: VkDynamicState
//             Offset: 0
//         Enum:
//             Name: VK_PIPELINE_CREATE_2_RAY_TRACING_SKIP_BUILT_IN_PRIMITIVES_BIT_KHR
//             Negative: false
//             Extends: VkPipelineCreateFlagBits2
//             Alias: VK_PIPELINE_CREATE_2_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR
//         Type:
//             Name: VkRayTracingShaderGroupCreateInfoKHR
//         Type:
//             Name: VkRayTracingShaderGroupTypeKHR
//         Type:
//             Name: VkRayTracingPipelineCreateInfoKHR
//         Type:
//             Name: VkPhysicalDeviceRayTracingPipelineFeaturesKHR
//         Type:
//             Name: VkPhysicalDeviceRayTracingPipelinePropertiesKHR
//         Type:
//             Name: VkStridedDeviceAddressRegionKHR
//         Type:
//             Name: VkTraceRaysIndirectCommandKHR
//         Type:
//             Name: VkRayTracingPipelineInterfaceCreateInfoKHR
//         Type:
//             Name: VkShaderGroupShaderKHR
//         Command:
//             Name: vkCmdTraceRaysKHR
//         Command:
//             Name: vkCreateRayTracingPipelinesKHR
//         Command:
//             Name: vkGetRayTracingShaderGroupHandlesKHR
//         Command:
//             Name: vkGetRayTracingCaptureReplayShaderGroupHandlesKHR
//         Command:
//             Name: vkCmdTraceRaysIndirectKHR
//         Command:
//             Name: vkGetRayTracingShaderGroupStackSizeKHR
//         Command:
//             Name: vkCmdSetRayTracingPipelineStackSizeKHR
//         Feature:
//             Name: rayTracingPipeline
//             Struct: VkPhysicalDeviceRayTracingPipelineFeaturesKHR
//         Feature:
//             Name: rayTracingPipelineTraceRaysIndirect
//             Struct: VkPhysicalDeviceRayTracingPipelineFeaturesKHR
//     Depends: VK_KHR_ray_query
//         Feature:
//             Name: rayTraversalPrimitiveCulling
//             Struct: VkPhysicalDeviceRayTracingPipelineFeaturesKHR
// Extension: VK_KHR_ray_query
// Number: 349
// Type: device
// Author: KHR
// Depends: (VK_KHR_spirv_1_4,VK_VERSION_1_2)+VK_KHR_acceleration_structure
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_RAY_QUERY_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_RAY_QUERY_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_ray_query&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 13
//         Type:
//             Name: VkPhysicalDeviceRayQueryFeaturesKHR
//         Feature:
//             Name: rayQuery
//             Struct: VkPhysicalDeviceRayQueryFeaturesKHR
// Extension: VK_NV_extension_152
// Number: 152
// Type: invalid
// Author: NV
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_NV_EXTENSION_152_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_NV_EXTENSION_152_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_extension_152&quot;
// Extension: VK_NV_framebuffer_mixed_samples
// Number: 153
// Type: device
// Author: NV
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NV_FRAMEBUFFER_MIXED_SAMPLES_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_NV_FRAMEBUFFER_MIXED_SAMPLES_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_framebuffer_mixed_samples&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPipelineCoverageModulationStateCreateInfoNV
//         Type:
//             Name: VkPipelineCoverageModulationStateCreateFlagsNV
//         Type:
//             Name: VkCoverageModulationModeNV
//     Depends: VK_VERSION_1_3,VK_KHR_dynamic_rendering
//         Enum:
//             Name: VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD
//         Type:
//             Name: VkAttachmentSampleCountInfoNV
// Extension: VK_NV_fill_rectangle
// Number: 154
// Type: device
// Author: NV
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NV_FILL_RECTANGLE_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_NV_FILL_RECTANGLE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_fill_rectangle&quot;
//         Enum:
//             Name: VK_POLYGON_MODE_FILL_RECTANGLE_NV
//             Negative: false
//             Extends: VkPolygonMode
//             Offset: 0
// Extension: VK_NV_shader_sm_builtins
// Number: 155
// Type: device
// Author: NV
// Depends: VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NV_SHADER_SM_BUILTINS_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_NV_SHADER_SM_BUILTINS_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_shader_sm_builtins&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Type:
//             Name: VkPhysicalDeviceShaderSMBuiltinsPropertiesNV
//         Type:
//             Name: VkPhysicalDeviceShaderSMBuiltinsFeaturesNV
//         Feature:
//             Name: shaderSMBuiltins
//             Struct: VkPhysicalDeviceShaderSMBuiltinsFeaturesNV
// Extension: VK_EXT_post_depth_coverage
// Number: 156
// Type: device
// Author: NV
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_POST_DEPTH_COVERAGE_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_POST_DEPTH_COVERAGE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_post_depth_coverage&quot;
// Extension: VK_KHR_sampler_ycbcr_conversion
// Number: 157
// Type: device
// Author: KHR
// Depends: (VK_KHR_maintenance1+VK_KHR_bind_memory2+VK_KHR_get_memory_requirements2+VK_KHR_get_physical_device_properties2),VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_1
// Unlocks:
//         Enum:
//             Name: VK_KHR_SAMPLER_YCBCR_CONVERSION_SPEC_VERSION
//             Negative: false
//             Value: 14
//         Enum:
//             Name: VK_KHR_SAMPLER_YCBCR_CONVERSION_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_sampler_ycbcr_conversion&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES
//         Enum:
//             Name: VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR
//             Negative: false
//             Extends: VkObjectType
//             Alias: VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION
//         Enum:
//             Name: VK_FORMAT_G8B8G8R8_422_UNORM_KHR
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_G8B8G8R8_422_UNORM
//         Enum:
//             Name: VK_FORMAT_B8G8R8G8_422_UNORM_KHR
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_B8G8R8G8_422_UNORM
//         Enum:
//             Name: VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM_KHR
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM
//         Enum:
//             Name: VK_FORMAT_G8_B8R8_2PLANE_420_UNORM_KHR
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_G8_B8R8_2PLANE_420_UNORM
//         Enum:
//             Name: VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM_KHR
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM
//         Enum:
//             Name: VK_FORMAT_G8_B8R8_2PLANE_422_UNORM_KHR
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_G8_B8R8_2PLANE_422_UNORM
//         Enum:
//             Name: VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM_KHR
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM
//         Enum:
//             Name: VK_FORMAT_R10X6_UNORM_PACK16_KHR
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_R10X6_UNORM_PACK16
//         Enum:
//             Name: VK_FORMAT_R10X6G10X6_UNORM_2PACK16_KHR
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_R10X6G10X6_UNORM_2PACK16
//         Enum:
//             Name: VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16_KHR
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16
//         Enum:
//             Name: VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16_KHR
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16
//         Enum:
//             Name: VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16_KHR
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16
//         Enum:
//             Name: VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16_KHR
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16
//         Enum:
//             Name: VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16_KHR
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16
//         Enum:
//             Name: VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16_KHR
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16
//         Enum:
//             Name: VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16_KHR
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16
//         Enum:
//             Name: VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16_KHR
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16
//         Enum:
//             Name: VK_FORMAT_R12X4_UNORM_PACK16_KHR
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_R12X4_UNORM_PACK16
//         Enum:
//             Name: VK_FORMAT_R12X4G12X4_UNORM_2PACK16_KHR
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_R12X4G12X4_UNORM_2PACK16
//         Enum:
//             Name: VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16_KHR
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16
//         Enum:
//             Name: VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16_KHR
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16
//         Enum:
//             Name: VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16_KHR
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16
//         Enum:
//             Name: VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16_KHR
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16
//         Enum:
//             Name: VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16_KHR
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16
//         Enum:
//             Name: VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16_KHR
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16
//         Enum:
//             Name: VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16_KHR
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16
//         Enum:
//             Name: VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16_KHR
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16
//         Enum:
//             Name: VK_FORMAT_G16B16G16R16_422_UNORM_KHR
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_G16B16G16R16_422_UNORM
//         Enum:
//             Name: VK_FORMAT_B16G16R16G16_422_UNORM_KHR
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_B16G16R16G16_422_UNORM
//         Enum:
//             Name: VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM_KHR
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM
//         Enum:
//             Name: VK_FORMAT_G16_B16R16_2PLANE_420_UNORM_KHR
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_G16_B16R16_2PLANE_420_UNORM
//         Enum:
//             Name: VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM_KHR
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM
//         Enum:
//             Name: VK_FORMAT_G16_B16R16_2PLANE_422_UNORM_KHR
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_G16_B16R16_2PLANE_422_UNORM
//         Enum:
//             Name: VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM_KHR
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM
//         Enum:
//             Name: VK_IMAGE_ASPECT_PLANE_0_BIT_KHR
//             Negative: false
//             Extends: VkImageAspectFlagBits
//             Alias: VK_IMAGE_ASPECT_PLANE_0_BIT
//         Enum:
//             Name: VK_IMAGE_ASPECT_PLANE_1_BIT_KHR
//             Negative: false
//             Extends: VkImageAspectFlagBits
//             Alias: VK_IMAGE_ASPECT_PLANE_1_BIT
//         Enum:
//             Name: VK_IMAGE_ASPECT_PLANE_2_BIT_KHR
//             Negative: false
//             Extends: VkImageAspectFlagBits
//             Alias: VK_IMAGE_ASPECT_PLANE_2_BIT
//         Enum:
//             Name: VK_IMAGE_CREATE_DISJOINT_BIT_KHR
//             Negative: false
//             Extends: VkImageCreateFlagBits
//             Alias: VK_IMAGE_CREATE_DISJOINT_BIT
//         Enum:
//             Name: VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT_KHR
//             Negative: false
//             Extends: VkFormatFeatureFlagBits
//             Alias: VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT
//         Enum:
//             Name: VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR
//             Negative: false
//             Extends: VkFormatFeatureFlagBits
//             Alias: VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT
//         Enum:
//             Name: VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR
//             Negative: false
//             Extends: VkFormatFeatureFlagBits
//             Alias: VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT
//         Enum:
//             Name: VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR
//             Negative: false
//             Extends: VkFormatFeatureFlagBits
//             Alias: VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT
//         Enum:
//             Name: VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR
//             Negative: false
//             Extends: VkFormatFeatureFlagBits
//             Alias: VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT
//         Enum:
//             Name: VK_FORMAT_FEATURE_DISJOINT_BIT_KHR
//             Negative: false
//             Extends: VkFormatFeatureFlagBits
//             Alias: VK_FORMAT_FEATURE_DISJOINT_BIT
//         Enum:
//             Name: VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT_KHR
//             Negative: false
//             Extends: VkFormatFeatureFlagBits
//             Alias: VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT
//         Type:
//             Name: VkSamplerYcbcrConversionCreateInfoKHR
//         Type:
//             Name: VkSamplerYcbcrConversionInfoKHR
//         Type:
//             Name: VkBindImagePlaneMemoryInfoKHR
//         Type:
//             Name: VkImagePlaneMemoryRequirementsInfoKHR
//         Type:
//             Name: VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR
//         Type:
//             Name: VkSamplerYcbcrConversionImageFormatPropertiesKHR
//         Command:
//             Name: vkCreateSamplerYcbcrConversionKHR
//         Command:
//             Name: vkDestroySamplerYcbcrConversionKHR
//         Type:
//             Name: VkSamplerYcbcrConversionKHR
//         Type:
//             Name: VkSamplerYcbcrModelConversionKHR
//         Enum:
//             Name: VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY_KHR
//             Negative: false
//             Extends: VkSamplerYcbcrModelConversion
//             Alias: VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY
//         Enum:
//             Name: VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY_KHR
//             Negative: false
//             Extends: VkSamplerYcbcrModelConversion
//             Alias: VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY
//         Enum:
//             Name: VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709_KHR
//             Negative: false
//             Extends: VkSamplerYcbcrModelConversion
//             Alias: VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709
//         Enum:
//             Name: VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601_KHR
//             Negative: false
//             Extends: VkSamplerYcbcrModelConversion
//             Alias: VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601
//         Enum:
//             Name: VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020_KHR
//             Negative: false
//             Extends: VkSamplerYcbcrModelConversion
//             Alias: VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020
//         Type:
//             Name: VkSamplerYcbcrRangeKHR
//         Enum:
//             Name: VK_SAMPLER_YCBCR_RANGE_ITU_FULL_KHR
//             Negative: false
//             Extends: VkSamplerYcbcrRange
//             Alias: VK_SAMPLER_YCBCR_RANGE_ITU_FULL
//         Enum:
//             Name: VK_SAMPLER_YCBCR_RANGE_ITU_NARROW_KHR
//             Negative: false
//             Extends: VkSamplerYcbcrRange
//             Alias: VK_SAMPLER_YCBCR_RANGE_ITU_NARROW
//         Type:
//             Name: VkChromaLocationKHR
//         Enum:
//             Name: VK_CHROMA_LOCATION_COSITED_EVEN_KHR
//             Negative: false
//             Extends: VkChromaLocation
//             Alias: VK_CHROMA_LOCATION_COSITED_EVEN
//         Enum:
//             Name: VK_CHROMA_LOCATION_MIDPOINT_KHR
//             Negative: false
//             Extends: VkChromaLocation
//             Alias: VK_CHROMA_LOCATION_MIDPOINT
//         Feature:
//             Name: samplerYcbcrConversion
//             Struct: VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR
//     Depends: VK_EXT_debug_report
//         Enum:
//             Name: VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT
//             Negative: false
//             Extends: VkDebugReportObjectTypeEXT
//             Offset: 0
//         Enum:
//             Name: VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR_EXT
//             Negative: false
//             Extends: VkDebugReportObjectTypeEXT
//             Alias: VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT
// Extension: VK_KHR_bind_memory2
// Number: 158
// Type: device
// Author: KHR
// Supported: supported
// Promoted to: VK_VERSION_1_1
// Unlocks:
//         Enum:
//             Name: VK_KHR_BIND_MEMORY_2_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_BIND_MEMORY_2_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_bind_memory2&quot;
//         Command:
//             Name: vkBindBufferMemory2KHR
//         Command:
//             Name: vkBindImageMemory2KHR
//         Enum:
//             Name: VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO
//         Enum:
//             Name: VK_IMAGE_CREATE_ALIAS_BIT_KHR
//             Negative: false
//             Extends: VkImageCreateFlagBits
//             Alias: VK_IMAGE_CREATE_ALIAS_BIT
//         Type:
//             Name: VkBindBufferMemoryInfoKHR
//         Type:
//             Name: VkBindImageMemoryInfoKHR
// Extension: VK_EXT_image_drm_format_modifier
// Number: 159
// Type: device
// Author: EXT
// Depends: (((VK_KHR_bind_memory2+VK_KHR_get_physical_device_properties2+VK_KHR_sampler_ycbcr_conversion),VK_VERSION_1_1)+VK_KHR_image_format_list),VK_VERSION_1_2
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_IMAGE_DRM_FORMAT_MODIFIER_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_EXT_IMAGE_DRM_FORMAT_MODIFIER_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_image_drm_format_modifier&quot;
//         Enum:
//             Name: VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT
//             Negative: true
//             Extends: VkResult
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 4
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 5
//         Enum:
//             Name: VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT
//             Negative: false
//             Extends: VkImageTiling
//             Offset: 0
//         Enum:
//             Name: VK_IMAGE_ASPECT_MEMORY_PLANE_0_BIT_EXT
//             Negative: false
//             Bitpos: 7
//             Extends: VkImageAspectFlagBits
//         Enum:
//             Name: VK_IMAGE_ASPECT_MEMORY_PLANE_1_BIT_EXT
//             Negative: false
//             Bitpos: 8
//             Extends: VkImageAspectFlagBits
//         Enum:
//             Name: VK_IMAGE_ASPECT_MEMORY_PLANE_2_BIT_EXT
//             Negative: false
//             Bitpos: 9
//             Extends: VkImageAspectFlagBits
//         Enum:
//             Name: VK_IMAGE_ASPECT_MEMORY_PLANE_3_BIT_EXT
//             Negative: false
//             Bitpos: 10
//             Extends: VkImageAspectFlagBits
//         Type:
//             Name: VkDrmFormatModifierPropertiesListEXT
//         Type:
//             Name: VkDrmFormatModifierPropertiesEXT
//         Type:
//             Name: VkPhysicalDeviceImageDrmFormatModifierInfoEXT
//         Type:
//             Name: VkImageDrmFormatModifierListCreateInfoEXT
//         Type:
//             Name: VkImageDrmFormatModifierExplicitCreateInfoEXT
//         Type:
//             Name: VkImageDrmFormatModifierPropertiesEXT
//         Command:
//             Name: vkGetImageDrmFormatModifierPropertiesEXT
//     Depends: VK_KHR_format_feature_flags2,VK_VERSION_1_3
//         Type:
//             Name: VkDrmFormatModifierPropertiesList2EXT
//         Type:
//             Name: VkDrmFormatModifierProperties2EXT
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 6
// Extension: VK_EXT_extension_160
// Number: 160
// Type: invalid
// Author: EXT
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_160_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_160_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_160&quot;
// Extension: VK_EXT_validation_cache
// Number: 161
// Type: device
// Author: GOOGLE
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_VALIDATION_CACHE_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_VALIDATION_CACHE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_validation_cache&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_OBJECT_TYPE_VALIDATION_CACHE_EXT
//             Negative: false
//             Extends: VkObjectType
//             Offset: 0
//         Type:
//             Name: VkValidationCacheEXT
//         Type:
//             Name: VkValidationCacheCreateInfoEXT
//         Type:
//             Name: VkShaderModuleValidationCacheCreateInfoEXT
//         Type:
//             Name: VkValidationCacheHeaderVersionEXT
//         Type:
//             Name: VkValidationCacheCreateFlagsEXT
//         Command:
//             Name: vkCreateValidationCacheEXT
//         Command:
//             Name: vkDestroyValidationCacheEXT
//         Command:
//             Name: vkMergeValidationCachesEXT
//         Command:
//             Name: vkGetValidationCacheDataEXT
// Extension: VK_EXT_descriptor_indexing
// Number: 162
// Type: device
// Author: NV
// Depends: (VK_KHR_get_physical_device_properties2+VK_KHR_maintenance3),VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_2
// Unlocks:
//         Enum:
//             Name: VK_EXT_DESCRIPTOR_INDEXING_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_EXT_DESCRIPTOR_INDEXING_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_descriptor_indexing&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT
//         Enum:
//             Name: VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT
//             Negative: false
//             Extends: VkDescriptorBindingFlagBits
//             Alias: VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT
//         Enum:
//             Name: VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT_EXT
//             Negative: false
//             Extends: VkDescriptorBindingFlagBits
//             Alias: VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT
//         Enum:
//             Name: VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT_EXT
//             Negative: false
//             Extends: VkDescriptorBindingFlagBits
//             Alias: VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT
//         Enum:
//             Name: VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT
//             Negative: false
//             Extends: VkDescriptorBindingFlagBits
//             Alias: VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT
//         Enum:
//             Name: VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT
//             Negative: false
//             Extends: VkDescriptorPoolCreateFlagBits
//             Alias: VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT
//         Enum:
//             Name: VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT
//             Negative: false
//             Extends: VkDescriptorSetLayoutCreateFlagBits
//             Alias: VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT
//         Enum:
//             Name: VK_ERROR_FRAGMENTATION_EXT
//             Negative: false
//             Extends: VkResult
//             Alias: VK_ERROR_FRAGMENTATION
//         Type:
//             Name: VkDescriptorSetLayoutBindingFlagsCreateInfoEXT
//         Type:
//             Name: VkPhysicalDeviceDescriptorIndexingFeaturesEXT
//         Type:
//             Name: VkPhysicalDeviceDescriptorIndexingPropertiesEXT
//         Type:
//             Name: VkDescriptorSetVariableDescriptorCountAllocateInfoEXT
//         Type:
//             Name: VkDescriptorSetVariableDescriptorCountLayoutSupportEXT
//         Type:
//             Name: VkDescriptorBindingFlagBitsEXT
//         Type:
//             Name: VkDescriptorBindingFlagsEXT
//         Feature:
//             Name: shaderSampledImageArrayDynamicIndexing
//             Struct: VkPhysicalDeviceFeatures
//         Feature:
//             Name: shaderStorageBufferArrayDynamicIndexing
//             Struct: VkPhysicalDeviceFeatures
//         Feature:
//             Name: shaderUniformTexelBufferArrayDynamicIndexing
//             Struct: VkPhysicalDeviceDescriptorIndexingFeaturesEXT
//         Feature:
//             Name: shaderStorageTexelBufferArrayDynamicIndexing
//             Struct: VkPhysicalDeviceDescriptorIndexingFeaturesEXT
//         Feature:
//             Name: shaderSampledImageArrayNonUniformIndexing
//             Struct: VkPhysicalDeviceDescriptorIndexingFeaturesEXT
//         Feature:
//             Name: shaderStorageBufferArrayNonUniformIndexing
//             Struct: VkPhysicalDeviceDescriptorIndexingFeaturesEXT
//         Feature:
//             Name: shaderUniformTexelBufferArrayNonUniformIndexing
//             Struct: VkPhysicalDeviceDescriptorIndexingFeaturesEXT
//         Feature:
//             Name: descriptorBindingSampledImageUpdateAfterBind
//             Struct: VkPhysicalDeviceDescriptorIndexingFeaturesEXT
//         Feature:
//             Name: descriptorBindingStorageImageUpdateAfterBind
//             Struct: VkPhysicalDeviceDescriptorIndexingFeaturesEXT
//         Feature:
//             Name: descriptorBindingStorageBufferUpdateAfterBind
//             Struct: VkPhysicalDeviceDescriptorIndexingFeaturesEXT
//         Feature:
//             Name: descriptorBindingUniformTexelBufferUpdateAfterBind
//             Struct: VkPhysicalDeviceDescriptorIndexingFeaturesEXT
//         Feature:
//             Name: descriptorBindingStorageTexelBufferUpdateAfterBind
//             Struct: VkPhysicalDeviceDescriptorIndexingFeaturesEXT
//         Feature:
//             Name: descriptorBindingUpdateUnusedWhilePending
//             Struct: VkPhysicalDeviceDescriptorIndexingFeaturesEXT
//         Feature:
//             Name: descriptorBindingPartiallyBound
//             Struct: VkPhysicalDeviceDescriptorIndexingFeaturesEXT
//         Feature:
//             Name: runtimeDescriptorArray
//             Struct: VkPhysicalDeviceDescriptorIndexingFeaturesEXT
// Extension: VK_EXT_shader_viewport_index_layer
// Number: 163
// Type: device
// Author: NV
// Supported: supported
// Promoted to: VK_VERSION_1_2
// Unlocks:
//         Enum:
//             Name: VK_EXT_SHADER_VIEWPORT_INDEX_LAYER_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_SHADER_VIEWPORT_INDEX_LAYER_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_shader_viewport_index_layer&quot;
// Extension: VK_KHR_portability_subset
// Number: 164
// Type: device
// Author: KHR
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Platform: provisional
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_PORTABILITY_SUBSET_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_PORTABILITY_SUBSET_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_portability_subset&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Type:
//             Name: VkPhysicalDevicePortabilitySubsetFeaturesKHR
//         Type:
//             Name: VkPhysicalDevicePortabilitySubsetPropertiesKHR
// Extension: VK_NV_shading_rate_image
// Number: 165
// Type: device
// Author: NV
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NV_SHADING_RATE_IMAGE_SPEC_VERSION
//             Negative: false
//             Value: 3
//         Enum:
//             Name: VK_NV_SHADING_RATE_IMAGE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_shading_rate_image&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_IMAGE_LAYOUT_SHADING_RATE_OPTIMAL_NV
//             Negative: false
//             Extends: VkImageLayout
//             Alias: VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR
//         Enum:
//             Name: VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV
//             Negative: false
//             Extends: VkDynamicState
//             Offset: 4
//         Enum:
//             Name: VK_ACCESS_SHADING_RATE_IMAGE_READ_BIT_NV
//             Negative: false
//             Extends: VkAccessFlagBits
//             Alias: VK_ACCESS_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR
//         Enum:
//             Name: VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV
//             Negative: false
//             Extends: VkImageUsageFlagBits
//             Alias: VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR
//         Enum:
//             Name: VK_PIPELINE_STAGE_SHADING_RATE_IMAGE_BIT_NV
//             Negative: false
//             Extends: VkPipelineStageFlagBits
//             Alias: VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 5
//         Enum:
//             Name: VK_DYNAMIC_STATE_VIEWPORT_COARSE_SAMPLE_ORDER_NV
//             Negative: false
//             Extends: VkDynamicState
//             Offset: 6
//         Type:
//             Name: VkShadingRatePaletteEntryNV
//         Type:
//             Name: VkShadingRatePaletteNV
//         Type:
//             Name: VkPipelineViewportShadingRateImageStateCreateInfoNV
//         Type:
//             Name: VkPhysicalDeviceShadingRateImageFeaturesNV
//         Type:
//             Name: VkPhysicalDeviceShadingRateImagePropertiesNV
//         Type:
//             Name: VkCoarseSampleLocationNV
//         Type:
//             Name: VkCoarseSampleOrderCustomNV
//         Type:
//             Name: VkPipelineViewportCoarseSampleOrderStateCreateInfoNV
//         Type:
//             Name: VkCoarseSampleOrderTypeNV
//         Command:
//             Name: vkCmdBindShadingRateImageNV
//         Command:
//             Name: vkCmdSetViewportShadingRatePaletteNV
//         Command:
//             Name: vkCmdSetCoarseSampleOrderNV
//         Feature:
//             Name: shadingRateImage
//             Struct: VkPhysicalDeviceShadingRateImageFeaturesNV
// Extension: VK_NV_ray_tracing
// Number: 166
// Type: device
// Author: NV
// Depends: (VK_KHR_get_physical_device_properties2+VK_KHR_get_memory_requirements2),VK_VERSION_1_1
// Supported: supported
// Deprecated by: VK_KHR_ray_tracing_pipeline
// Unlocks:
//         Enum:
//             Name: VK_NV_RAY_TRACING_SPEC_VERSION
//             Negative: false
//             Value: 3
//         Enum:
//             Name: VK_NV_RAY_TRACING_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_ray_tracing&quot;
//         Enum:
//             Name: VK_SHADER_UNUSED_NV
//             Negative: false
//             Alias: VK_SHADER_UNUSED_KHR
//         Enum:
//             Name: VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_GEOMETRY_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Enum:
//             Name: VK_STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 4
//         Enum:
//             Name: VK_STRUCTURE_TYPE_GEOMETRY_AABB_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 5
//         Enum:
//             Name: VK_STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 6
//         Enum:
//             Name: VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 7
//         Enum:
//             Name: VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 8
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 9
//         Enum:
//             Name: VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 11
//         Enum:
//             Name: VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 12
//         Enum:
//             Name: VK_SHADER_STAGE_RAYGEN_BIT_NV
//             Negative: false
//             Extends: VkShaderStageFlagBits
//             Alias: VK_SHADER_STAGE_RAYGEN_BIT_KHR
//         Enum:
//             Name: VK_SHADER_STAGE_ANY_HIT_BIT_NV
//             Negative: false
//             Extends: VkShaderStageFlagBits
//             Alias: VK_SHADER_STAGE_ANY_HIT_BIT_KHR
//         Enum:
//             Name: VK_SHADER_STAGE_CLOSEST_HIT_BIT_NV
//             Negative: false
//             Extends: VkShaderStageFlagBits
//             Alias: VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR
//         Enum:
//             Name: VK_SHADER_STAGE_MISS_BIT_NV
//             Negative: false
//             Extends: VkShaderStageFlagBits
//             Alias: VK_SHADER_STAGE_MISS_BIT_KHR
//         Enum:
//             Name: VK_SHADER_STAGE_INTERSECTION_BIT_NV
//             Negative: false
//             Extends: VkShaderStageFlagBits
//             Alias: VK_SHADER_STAGE_INTERSECTION_BIT_KHR
//         Enum:
//             Name: VK_SHADER_STAGE_CALLABLE_BIT_NV
//             Negative: false
//             Extends: VkShaderStageFlagBits
//             Alias: VK_SHADER_STAGE_CALLABLE_BIT_KHR
//         Enum:
//             Name: VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_NV
//             Negative: false
//             Extends: VkPipelineStageFlagBits
//             Alias: VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_KHR
//         Enum:
//             Name: VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_NV
//             Negative: false
//             Extends: VkPipelineStageFlagBits
//             Alias: VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR
//         Enum:
//             Name: VK_BUFFER_USAGE_RAY_TRACING_BIT_NV
//             Negative: false
//             Extends: VkBufferUsageFlagBits
//             Alias: VK_BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR
//         Enum:
//             Name: VK_PIPELINE_BIND_POINT_RAY_TRACING_NV
//             Negative: false
//             Extends: VkPipelineBindPoint
//             Alias: VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR
//         Enum:
//             Name: VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV
//             Negative: false
//             Extends: VkDescriptorType
//             Offset: 0
//         Enum:
//             Name: VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_NV
//             Negative: false
//             Extends: VkAccessFlagBits
//             Alias: VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR
//         Enum:
//             Name: VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_NV
//             Negative: false
//             Extends: VkAccessFlagBits
//             Alias: VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_KHR
//         Enum:
//             Name: VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_NV
//             Negative: false
//             Extends: VkQueryType
//             Offset: 0
//         Enum:
//             Name: VK_PIPELINE_CREATE_DEFER_COMPILE_BIT_NV
//             Negative: false
//             Bitpos: 5
//             Extends: VkPipelineCreateFlagBits
//         Enum:
//             Name: VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV
//             Negative: false
//             Extends: VkObjectType
//             Offset: 0
//         Enum:
//             Name: VK_INDEX_TYPE_NONE_NV
//             Negative: false
//             Extends: VkIndexType
//             Alias: VK_INDEX_TYPE_NONE_KHR
//         Type:
//             Name: VkRayTracingShaderGroupCreateInfoNV
//         Type:
//             Name: VkRayTracingShaderGroupTypeNV
//         Enum:
//             Name: VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_NV
//             Negative: false
//             Extends: VkRayTracingShaderGroupTypeKHR
//             Alias: VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR
//         Enum:
//             Name: VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_NV
//             Negative: false
//             Extends: VkRayTracingShaderGroupTypeKHR
//             Alias: VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_KHR
//         Enum:
//             Name: VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_NV
//             Negative: false
//             Extends: VkRayTracingShaderGroupTypeKHR
//             Alias: VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_KHR
//         Type:
//             Name: VkRayTracingPipelineCreateInfoNV
//         Type:
//             Name: VkGeometryTypeNV
//         Enum:
//             Name: VK_GEOMETRY_TYPE_TRIANGLES_NV
//             Negative: false
//             Extends: VkGeometryTypeKHR
//             Alias: VK_GEOMETRY_TYPE_TRIANGLES_KHR
//         Enum:
//             Name: VK_GEOMETRY_TYPE_AABBS_NV
//             Negative: false
//             Extends: VkGeometryTypeKHR
//             Alias: VK_GEOMETRY_TYPE_AABBS_KHR
//         Type:
//             Name: VkAccelerationStructureTypeNV
//         Enum:
//             Name: VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_NV
//             Negative: false
//             Extends: VkAccelerationStructureTypeKHR
//             Alias: VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR
//         Enum:
//             Name: VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_NV
//             Negative: false
//             Extends: VkAccelerationStructureTypeKHR
//             Alias: VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR
//         Type:
//             Name: VkGeometryTrianglesNV
//         Type:
//             Name: VkGeometryAABBNV
//         Type:
//             Name: VkGeometryDataNV
//         Type:
//             Name: VkGeometryNV
//         Type:
//             Name: VkGeometryFlagsNV
//         Type:
//             Name: VkGeometryFlagBitsNV
//         Enum:
//             Name: VK_GEOMETRY_OPAQUE_BIT_NV
//             Negative: false
//             Extends: VkGeometryFlagBitsKHR
//             Alias: VK_GEOMETRY_OPAQUE_BIT_KHR
//         Enum:
//             Name: VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_NV
//             Negative: false
//             Extends: VkGeometryFlagBitsKHR
//             Alias: VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_KHR
//         Type:
//             Name: VkGeometryInstanceFlagsNV
//         Type:
//             Name: VkGeometryInstanceFlagBitsNV
//         Enum:
//             Name: VK_GEOMETRY_INSTANCE_TRIANGLE_CULL_DISABLE_BIT_NV
//             Negative: false
//             Extends: VkGeometryInstanceFlagBitsKHR
//             Alias: VK_GEOMETRY_INSTANCE_TRIANGLE_FACING_CULL_DISABLE_BIT_KHR
//         Enum:
//             Name: VK_GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_NV
//             Negative: false
//             Extends: VkGeometryInstanceFlagBitsKHR
//             Alias: VK_GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_KHR
//         Enum:
//             Name: VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_NV
//             Negative: false
//             Extends: VkGeometryInstanceFlagBitsKHR
//             Alias: VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_KHR
//         Enum:
//             Name: VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_NV
//             Negative: false
//             Extends: VkGeometryInstanceFlagBitsKHR
//             Alias: VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_KHR
//         Type:
//             Name: VkAccelerationStructureInfoNV
//         Type:
//             Name: VkAccelerationStructureCreateInfoNV
//         Type:
//             Name: VkAccelerationStructureNV
//         Type:
//             Name: VkBuildAccelerationStructureFlagBitsNV
//         Enum:
//             Name: VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_NV
//             Negative: false
//             Extends: VkBuildAccelerationStructureFlagBitsKHR
//             Alias: VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_KHR
//         Enum:
//             Name: VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_NV
//             Negative: false
//             Extends: VkBuildAccelerationStructureFlagBitsKHR
//             Alias: VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_KHR
//         Enum:
//             Name: VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_NV
//             Negative: false
//             Extends: VkBuildAccelerationStructureFlagBitsKHR
//             Alias: VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_KHR
//         Enum:
//             Name: VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_NV
//             Negative: false
//             Extends: VkBuildAccelerationStructureFlagBitsKHR
//             Alias: VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_KHR
//         Enum:
//             Name: VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_NV
//             Negative: false
//             Extends: VkBuildAccelerationStructureFlagBitsKHR
//             Alias: VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_KHR
//         Type:
//             Name: VkBuildAccelerationStructureFlagsNV
//         Type:
//             Name: VkCopyAccelerationStructureModeNV
//         Enum:
//             Name: VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_NV
//             Negative: false
//             Extends: VkCopyAccelerationStructureModeKHR
//             Alias: VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_KHR
//         Enum:
//             Name: VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_NV
//             Negative: false
//             Extends: VkCopyAccelerationStructureModeKHR
//             Alias: VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_KHR
//         Type:
//             Name: VkBindAccelerationStructureMemoryInfoNV
//         Type:
//             Name: VkWriteDescriptorSetAccelerationStructureNV
//         Type:
//             Name: VkAccelerationStructureMemoryRequirementsInfoNV
//         Type:
//             Name: VkPhysicalDeviceRayTracingPropertiesNV
//         Type:
//             Name: VkAccelerationStructureMemoryRequirementsTypeNV
//         Type:
//             Name: VkTransformMatrixNV
//         Type:
//             Name: VkAabbPositionsNV
//         Type:
//             Name: VkAccelerationStructureInstanceNV
//         Command:
//             Name: vkCreateAccelerationStructureNV
//         Command:
//             Name: vkDestroyAccelerationStructureNV
//         Command:
//             Name: vkGetAccelerationStructureMemoryRequirementsNV
//         Command:
//             Name: vkBindAccelerationStructureMemoryNV
//         Command:
//             Name: vkCmdBuildAccelerationStructureNV
//         Command:
//             Name: vkCmdCopyAccelerationStructureNV
//         Command:
//             Name: vkCmdTraceRaysNV
//         Command:
//             Name: vkCreateRayTracingPipelinesNV
//         Command:
//             Name: vkGetRayTracingShaderGroupHandlesNV
//         Command:
//             Name: vkGetAccelerationStructureHandleNV
//         Command:
//             Name: vkCmdWriteAccelerationStructuresPropertiesNV
//         Command:
//             Name: vkCompileDeferredNV
//     Depends: VK_KHR_get_memory_requirements2,VK_VERSION_1_1
//         Type:
//             Name: VkMemoryRequirements2KHR
//     Depends: VK_EXT_debug_report
//         Enum:
//             Name: VK_DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV_EXT
//             Negative: false
//             Extends: VkDebugReportObjectTypeEXT
//             Offset: 0
// Extension: VK_NV_representative_fragment_test
// Number: 167
// Type: device
// Author: NV
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NV_REPRESENTATIVE_FRAGMENT_TEST_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_NV_REPRESENTATIVE_FRAGMENT_TEST_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_representative_fragment_test&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Type:
//             Name: VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV
//         Type:
//             Name: VkPipelineRepresentativeFragmentTestStateCreateInfoNV
//         Feature:
//             Name: representativeFragmentTest
//             Struct: VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV
// Extension: VK_NV_extension_168
// Number: 168
// Type: invalid
// Author: NV
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_NV_EXTENSION_168_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_NV_EXTENSION_168_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_extension_168&quot;
// Extension: VK_KHR_maintenance3
// Number: 169
// Type: device
// Author: KHR
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_1
// Unlocks:
//         Enum:
//             Name: VK_KHR_MAINTENANCE_3_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_MAINTENANCE_3_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_maintenance3&quot;
//         Enum:
//             Name: VK_KHR_MAINTENANCE3_SPEC_VERSION
//             Negative: false
//             Alias: VK_KHR_MAINTENANCE_3_SPEC_VERSION
//         Enum:
//             Name: VK_KHR_MAINTENANCE3_EXTENSION_NAME
//             Negative: false
//             Alias: VK_KHR_MAINTENANCE_3_EXTENSION_NAME
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT
//         Type:
//             Name: VkPhysicalDeviceMaintenance3PropertiesKHR
//         Type:
//             Name: VkDescriptorSetLayoutSupportKHR
//         Command:
//             Name: vkGetDescriptorSetLayoutSupportKHR
// Extension: VK_KHR_draw_indirect_count
// Number: 170
// Type: device
// Author: KHR
// Supported: supported
// Promoted to: VK_VERSION_1_2
// Unlocks:
//         Enum:
//             Name: VK_KHR_DRAW_INDIRECT_COUNT_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_DRAW_INDIRECT_COUNT_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_draw_indirect_count&quot;
//         Command:
//             Name: vkCmdDrawIndirectCountKHR
//         Command:
//             Name: vkCmdDrawIndexedIndirectCountKHR
// Extension: VK_EXT_filter_cubic
// Number: 171
// Type: device
// Author: QCOM
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_FILTER_CUBIC_SPEC_VERSION
//             Negative: false
//             Value: 3
//         Enum:
//             Name: VK_EXT_FILTER_CUBIC_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_filter_cubic&quot;
//         Enum:
//             Name: VK_FILTER_CUBIC_EXT
//             Negative: false
//             Extends: VkFilter
//             Extnumber: 16
//             Offset: 0
//         Enum:
//             Name: VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT
//             Negative: false
//             Bitpos: 13
//             Extends: VkFormatFeatureFlagBits
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Type:
//             Name: VkPhysicalDeviceImageViewImageFormatInfoEXT
//         Type:
//             Name: VkFilterCubicImageViewImageFormatPropertiesEXT
// Extension: VK_QCOM_render_pass_shader_resolve
// Number: 172
// Type: device
// Author: QCOM
// Supported: supported
// Promoted to: VK_EXT_custom_resolve
// Unlocks:
//         Enum:
//             Name: VK_QCOM_RENDER_PASS_SHADER_RESOLVE_SPEC_VERSION
//             Negative: false
//             Value: 4
//         Enum:
//             Name: VK_QCOM_RENDER_PASS_SHADER_RESOLVE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_QCOM_render_pass_shader_resolve&quot;
//         Enum:
//             Name: VK_SUBPASS_DESCRIPTION_FRAGMENT_REGION_BIT_QCOM
//             Negative: false
//             Extends: VkSubpassDescriptionFlagBits
//             Alias: VK_SUBPASS_DESCRIPTION_FRAGMENT_REGION_BIT_EXT
//         Enum:
//             Name: VK_SUBPASS_DESCRIPTION_SHADER_RESOLVE_BIT_QCOM
//             Negative: false
//             Extends: VkSubpassDescriptionFlagBits
//             Alias: VK_SUBPASS_DESCRIPTION_CUSTOM_RESOLVE_BIT_EXT
// Extension: VK_QCOM_extension_173
// Number: 173
// Type: invalid
// Author: QCOM
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_QCOM_EXTENSION_173_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_QCOM_EXTENSION_173_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_QCOM_extension_173&quot;
// Extension: VK_QCOM_extension_174
// Number: 174
// Type: invalid
// Author: QCOM
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_QCOM_EXTENSION_174_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_QCOM_EXTENSION_174_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_QCOM_extension_174&quot;
// Extension: VK_EXT_global_priority
// Number: 175
// Type: device
// Author: EXT
// Supported: supported
// Promoted to: VK_KHR_global_priority
// Unlocks:
//         Enum:
//             Name: VK_EXT_GLOBAL_PRIORITY_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_EXT_GLOBAL_PRIORITY_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_global_priority&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO
//         Enum:
//             Name: VK_ERROR_NOT_PERMITTED_EXT
//             Negative: false
//             Extends: VkResult
//             Alias: VK_ERROR_NOT_PERMITTED
//         Enum:
//             Name: VK_QUEUE_GLOBAL_PRIORITY_LOW_EXT
//             Negative: false
//             Extends: VkQueueGlobalPriority
//             Alias: VK_QUEUE_GLOBAL_PRIORITY_LOW
//         Enum:
//             Name: VK_QUEUE_GLOBAL_PRIORITY_MEDIUM_EXT
//             Negative: false
//             Extends: VkQueueGlobalPriority
//             Alias: VK_QUEUE_GLOBAL_PRIORITY_MEDIUM
//         Enum:
//             Name: VK_QUEUE_GLOBAL_PRIORITY_HIGH_EXT
//             Negative: false
//             Extends: VkQueueGlobalPriority
//             Alias: VK_QUEUE_GLOBAL_PRIORITY_HIGH
//         Enum:
//             Name: VK_QUEUE_GLOBAL_PRIORITY_REALTIME_EXT
//             Negative: false
//             Extends: VkQueueGlobalPriority
//             Alias: VK_QUEUE_GLOBAL_PRIORITY_REALTIME
//         Type:
//             Name: VkDeviceQueueGlobalPriorityCreateInfoEXT
//         Type:
//             Name: VkQueueGlobalPriorityEXT
// Extension: VK_KHR_shader_subgroup_extended_types
// Number: 176
// Type: device
// Author: KHR
// Depends: VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_2
// Unlocks:
//         Enum:
//             Name: VK_KHR_SHADER_SUBGROUP_EXTENDED_TYPES_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_SHADER_SUBGROUP_EXTENDED_TYPES_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_shader_subgroup_extended_types&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES
//         Type:
//             Name: VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR
//         Feature:
//             Name: shaderSubgroupExtendedTypes
//             Struct: VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR
// Extension: VK_EXT_extension_177
// Number: 177
// Type: invalid
// Author: EXT
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_177_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_177_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_177&quot;
// Extension: VK_KHR_8bit_storage
// Number: 178
// Type: device
// Author: KHR
// Depends: (VK_KHR_get_physical_device_properties2+VK_KHR_storage_buffer_storage_class),VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_2
// Unlocks:
//         Enum:
//             Name: VK_KHR_8BIT_STORAGE_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_8BIT_STORAGE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_8bit_storage&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES
//         Type:
//             Name: VkPhysicalDevice8BitStorageFeaturesKHR
//         Feature:
//             Name: storageBuffer8BitAccess
//             Struct: VkPhysicalDevice8BitStorageFeaturesKHR
// Extension: VK_EXT_external_memory_host
// Number: 179
// Type: device
// Author: EXT
// Depends: VK_KHR_external_memory,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTERNAL_MEMORY_HOST_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_EXTERNAL_MEMORY_HOST_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_external_memory_host&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT
//             Negative: false
//             Bitpos: 7
//             Extends: VkExternalMemoryHandleTypeFlagBits
//         Enum:
//             Name: VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT
//             Negative: false
//             Bitpos: 8
//             Extends: VkExternalMemoryHandleTypeFlagBits
//         Type:
//             Name: VkImportMemoryHostPointerInfoEXT
//         Type:
//             Name: VkMemoryHostPointerPropertiesEXT
//         Type:
//             Name: VkPhysicalDeviceExternalMemoryHostPropertiesEXT
//         Command:
//             Name: vkGetMemoryHostPointerPropertiesEXT
// Extension: VK_AMD_buffer_marker
// Number: 180
// Type: device
// Author: AMD
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_AMD_BUFFER_MARKER_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_AMD_BUFFER_MARKER_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_buffer_marker&quot;
//         Command:
//             Name: vkCmdWriteBufferMarkerAMD
//     Depends: VK_VERSION_1_3,VK_KHR_synchronization2
//         Command:
//             Name: vkCmdWriteBufferMarker2AMD
// Extension: VK_KHR_shader_atomic_int64
// Number: 181
// Type: device
// Author: KHR
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_2
// Unlocks:
//         Enum:
//             Name: VK_KHR_SHADER_ATOMIC_INT64_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_SHADER_ATOMIC_INT64_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_shader_atomic_int64&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES
//         Type:
//             Name: VkPhysicalDeviceShaderAtomicInt64FeaturesKHR
//         Feature:
//             Name: shaderBufferInt64Atomics
//             Struct: VkPhysicalDeviceShaderAtomicInt64FeaturesKHR
// Extension: VK_KHR_shader_clock
// Number: 182
// Type: device
// Author: KHR
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_SHADER_CLOCK_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_SHADER_CLOCK_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_shader_clock&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceShaderClockFeaturesKHR
//         Feature:
//             Name: shaderSubgroupClock
//             Struct: VkPhysicalDeviceShaderClockFeaturesKHR
// Extension: VK_AMD_extension_183
// Number: 183
// Type: invalid
// Author: AMD
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_AMD_EXTENSION_183_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_AMD_EXTENSION_183_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_extension_183&quot;
// Extension: VK_AMD_pipeline_compiler_control
// Number: 184
// Type: device
// Author: AMD
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_AMD_PIPELINE_COMPILER_CONTROL_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_AMD_PIPELINE_COMPILER_CONTROL_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_pipeline_compiler_control&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPipelineCompilerControlFlagBitsAMD
//         Type:
//             Name: VkPipelineCompilerControlFlagsAMD
//         Type:
//             Name: VkPipelineCompilerControlCreateInfoAMD
// Extension: VK_EXT_calibrated_timestamps
// Number: 185
// Type: device
// Author: EXT
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_KHR_calibrated_timestamps
// Unlocks:
//         Enum:
//             Name: VK_EXT_CALIBRATED_TIMESTAMPS_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_EXT_CALIBRATED_TIMESTAMPS_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_calibrated_timestamps&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_KHR
//         Enum:
//             Name: VK_TIME_DOMAIN_DEVICE_EXT
//             Negative: false
//             Extends: VkTimeDomainKHR
//             Alias: VK_TIME_DOMAIN_DEVICE_KHR
//         Enum:
//             Name: VK_TIME_DOMAIN_CLOCK_MONOTONIC_EXT
//             Negative: false
//             Extends: VkTimeDomainKHR
//             Alias: VK_TIME_DOMAIN_CLOCK_MONOTONIC_KHR
//         Enum:
//             Name: VK_TIME_DOMAIN_CLOCK_MONOTONIC_RAW_EXT
//             Negative: false
//             Extends: VkTimeDomainKHR
//             Alias: VK_TIME_DOMAIN_CLOCK_MONOTONIC_RAW_KHR
//         Enum:
//             Name: VK_TIME_DOMAIN_QUERY_PERFORMANCE_COUNTER_EXT
//             Negative: false
//             Extends: VkTimeDomainKHR
//             Alias: VK_TIME_DOMAIN_QUERY_PERFORMANCE_COUNTER_KHR
//         Type:
//             Name: VkTimeDomainEXT
//         Type:
//             Name: VkCalibratedTimestampInfoEXT
//         Command:
//             Name: vkGetPhysicalDeviceCalibrateableTimeDomainsEXT
//         Command:
//             Name: vkGetCalibratedTimestampsEXT
// Extension: VK_AMD_shader_core_properties
// Number: 186
// Type: device
// Author: AMD
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_AMD_SHADER_CORE_PROPERTIES_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_AMD_SHADER_CORE_PROPERTIES_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_shader_core_properties&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceShaderCorePropertiesAMD
// Extension: VK_AMD_extension_187
// Number: 187
// Type: invalid
// Author: AMD
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_AMD_EXTENSION_187_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_AMD_EXTENSION_187_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_extension_187&quot;
// Extension: VK_KHR_video_decode_h265
// Number: 188
// Type: device
// Author: KHR
// Depends: VK_KHR_video_decode_queue
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_VIDEO_DECODE_H265_SPEC_VERSION
//             Negative: false
//             Value: 8
//         Enum:
//             Name: VK_KHR_VIDEO_DECODE_H265_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_video_decode_h265&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_CAPABILITIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PROFILE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PICTURE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 4
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_DPB_SLOT_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 5
//         Enum:
//             Name: VK_VIDEO_CODEC_OPERATION_DECODE_H265_BIT_KHR
//             Negative: false
//             Bitpos: 1
//             Extends: VkVideoCodecOperationFlagBitsKHR
//         Type:
//             Name: VkVideoDecodeH265ProfileInfoKHR
//         Type:
//             Name: VkVideoDecodeH265CapabilitiesKHR
//         Type:
//             Name: VkVideoDecodeH265SessionParametersCreateInfoKHR
//         Type:
//             Name: VkVideoDecodeH265SessionParametersAddInfoKHR
//         Type:
//             Name: VkVideoDecodeH265PictureInfoKHR
//         Type:
//             Name: VkVideoDecodeH265DpbSlotInfoKHR
// Extension: VK_KHR_global_priority
// Number: 189
// Type: device
// Author: KHR
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_4
// Unlocks:
//         Enum:
//             Name: VK_KHR_GLOBAL_PRIORITY_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_GLOBAL_PRIORITY_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_global_priority&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES
//         Enum:
//             Name: VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES
//         Enum:
//             Name: VK_ERROR_NOT_PERMITTED_KHR
//             Negative: false
//             Extends: VkResult
//             Alias: VK_ERROR_NOT_PERMITTED
//         Enum:
//             Name: VK_MAX_GLOBAL_PRIORITY_SIZE_KHR
//             Negative: false
//             Alias: VK_MAX_GLOBAL_PRIORITY_SIZE
//         Enum:
//             Name: VK_QUEUE_GLOBAL_PRIORITY_LOW_KHR
//             Negative: false
//             Extends: VkQueueGlobalPriority
//             Alias: VK_QUEUE_GLOBAL_PRIORITY_LOW
//         Enum:
//             Name: VK_QUEUE_GLOBAL_PRIORITY_MEDIUM_KHR
//             Negative: false
//             Extends: VkQueueGlobalPriority
//             Alias: VK_QUEUE_GLOBAL_PRIORITY_MEDIUM
//         Enum:
//             Name: VK_QUEUE_GLOBAL_PRIORITY_HIGH_KHR
//             Negative: false
//             Extends: VkQueueGlobalPriority
//             Alias: VK_QUEUE_GLOBAL_PRIORITY_HIGH
//         Enum:
//             Name: VK_QUEUE_GLOBAL_PRIORITY_REALTIME_KHR
//             Negative: false
//             Extends: VkQueueGlobalPriority
//             Alias: VK_QUEUE_GLOBAL_PRIORITY_REALTIME
//         Type:
//             Name: VkDeviceQueueGlobalPriorityCreateInfoKHR
//         Type:
//             Name: VkQueueGlobalPriorityKHR
//         Type:
//             Name: VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR
//         Type:
//             Name: VkQueueFamilyGlobalPriorityPropertiesKHR
//         Feature:
//             Name: globalPriorityQuery
//             Struct: VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR
// Extension: VK_AMD_memory_overallocation_behavior
// Number: 190
// Type: device
// Author: AMD
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_AMD_MEMORY_OVERALLOCATION_BEHAVIOR_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_AMD_MEMORY_OVERALLOCATION_BEHAVIOR_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_memory_overallocation_behavior&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkMemoryOverallocationBehaviorAMD
//         Type:
//             Name: VkDeviceMemoryOverallocationCreateInfoAMD
// Extension: VK_EXT_vertex_attribute_divisor
// Number: 191
// Type: device
// Author: NV
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_KHR_vertex_attribute_divisor
// Unlocks:
//         Enum:
//             Name: VK_EXT_VERTEX_ATTRIBUTE_DIVISOR_SPEC_VERSION
//             Negative: false
//             Value: 3
//         Enum:
//             Name: VK_EXT_VERTEX_ATTRIBUTE_DIVISOR_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_vertex_attribute_divisor&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES
//         Type:
//             Name: VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT
//         Type:
//             Name: VkVertexInputBindingDivisorDescriptionEXT
//         Type:
//             Name: VkPipelineVertexInputDivisorStateCreateInfoEXT
//         Type:
//             Name: VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT
//         Feature:
//             Name: vertexAttributeInstanceRateDivisor
//             Struct: VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT
// Extension: VK_GGP_frame_token
// Number: 192
// Type: device
// Author: GGP
// Depends: VK_KHR_swapchain+VK_GGP_stream_descriptor_surface
// Platform: ggp
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_GGP_FRAME_TOKEN_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_GGP_FRAME_TOKEN_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_GGP_frame_token&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPresentFrameTokenGGP
// Extension: VK_EXT_pipeline_creation_feedback
// Number: 193
// Type: device
// Author: GOOGLE
// Supported: supported
// Promoted to: VK_VERSION_1_3
// Unlocks:
//         Enum:
//             Name: VK_EXT_PIPELINE_CREATION_FEEDBACK_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_PIPELINE_CREATION_FEEDBACK_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_pipeline_creation_feedback&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO
//         Enum:
//             Name: VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT_EXT
//             Negative: false
//             Extends: VkPipelineCreationFeedbackFlagBits
//             Alias: VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT
//         Enum:
//             Name: VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT_EXT
//             Negative: false
//             Extends: VkPipelineCreationFeedbackFlagBits
//             Alias: VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT
//         Enum:
//             Name: VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT_EXT
//             Negative: false
//             Extends: VkPipelineCreationFeedbackFlagBits
//             Alias: VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT
//         Type:
//             Name: VkPipelineCreationFeedbackFlagBitsEXT
//         Type:
//             Name: VkPipelineCreationFeedbackFlagsEXT
//         Type:
//             Name: VkPipelineCreationFeedbackCreateInfoEXT
//         Type:
//             Name: VkPipelineCreationFeedbackEXT
// Extension: VK_GOOGLE_extension_194
// Number: 194
// Type: invalid
// Author: GOOGLE
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_GOOGLE_EXTENSION_194_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_GOOGLE_EXTENSION_194_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_GOOGLE_extension_194&quot;
// Extension: VK_GOOGLE_extension_195
// Number: 195
// Type: invalid
// Author: GOOGLE
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_GOOGLE_EXTENSION_195_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_GOOGLE_EXTENSION_195_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_GOOGLE_extension_195&quot;
// Extension: VK_GOOGLE_extension_196
// Number: 196
// Type: invalid
// Author: GOOGLE
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_GOOGLE_EXTENSION_196_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_GOOGLE_EXTENSION_196_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_GOOGLE_extension_196&quot;
// Extension: VK_KHR_driver_properties
// Number: 197
// Type: device
// Author: KHR
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_2
// Unlocks:
//         Enum:
//             Name: VK_KHR_DRIVER_PROPERTIES_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_DRIVER_PROPERTIES_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_driver_properties&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES
//         Enum:
//             Name: VK_MAX_DRIVER_NAME_SIZE_KHR
//             Negative: false
//             Alias: VK_MAX_DRIVER_NAME_SIZE
//         Enum:
//             Name: VK_MAX_DRIVER_INFO_SIZE_KHR
//             Negative: false
//             Alias: VK_MAX_DRIVER_INFO_SIZE
//         Type:
//             Name: VkDriverIdKHR
//         Enum:
//             Name: VK_DRIVER_ID_AMD_PROPRIETARY_KHR
//             Negative: false
//             Extends: VkDriverId
//             Alias: VK_DRIVER_ID_AMD_PROPRIETARY
//         Enum:
//             Name: VK_DRIVER_ID_AMD_OPEN_SOURCE_KHR
//             Negative: false
//             Extends: VkDriverId
//             Alias: VK_DRIVER_ID_AMD_OPEN_SOURCE
//         Enum:
//             Name: VK_DRIVER_ID_MESA_RADV_KHR
//             Negative: false
//             Extends: VkDriverId
//             Alias: VK_DRIVER_ID_MESA_RADV
//         Enum:
//             Name: VK_DRIVER_ID_NVIDIA_PROPRIETARY_KHR
//             Negative: false
//             Extends: VkDriverId
//             Alias: VK_DRIVER_ID_NVIDIA_PROPRIETARY
//         Enum:
//             Name: VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS_KHR
//             Negative: false
//             Extends: VkDriverId
//             Alias: VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS
//         Enum:
//             Name: VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA_KHR
//             Negative: false
//             Extends: VkDriverId
//             Alias: VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA
//         Enum:
//             Name: VK_DRIVER_ID_IMAGINATION_PROPRIETARY_KHR
//             Negative: false
//             Extends: VkDriverId
//             Alias: VK_DRIVER_ID_IMAGINATION_PROPRIETARY
//         Enum:
//             Name: VK_DRIVER_ID_QUALCOMM_PROPRIETARY_KHR
//             Negative: false
//             Extends: VkDriverId
//             Alias: VK_DRIVER_ID_QUALCOMM_PROPRIETARY
//         Enum:
//             Name: VK_DRIVER_ID_ARM_PROPRIETARY_KHR
//             Negative: false
//             Extends: VkDriverId
//             Alias: VK_DRIVER_ID_ARM_PROPRIETARY
//         Enum:
//             Name: VK_DRIVER_ID_GOOGLE_SWIFTSHADER_KHR
//             Negative: false
//             Extends: VkDriverId
//             Alias: VK_DRIVER_ID_GOOGLE_SWIFTSHADER
//         Enum:
//             Name: VK_DRIVER_ID_GGP_PROPRIETARY_KHR
//             Negative: false
//             Extends: VkDriverId
//             Alias: VK_DRIVER_ID_GGP_PROPRIETARY
//         Enum:
//             Name: VK_DRIVER_ID_BROADCOM_PROPRIETARY_KHR
//             Negative: false
//             Extends: VkDriverId
//             Alias: VK_DRIVER_ID_BROADCOM_PROPRIETARY
//         Type:
//             Name: VkConformanceVersionKHR
//         Type:
//             Name: VkPhysicalDeviceDriverPropertiesKHR
// Extension: VK_KHR_shader_float_controls
// Number: 198
// Type: device
// Author: KHR
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_2
// Unlocks:
//         Enum:
//             Name: VK_KHR_SHADER_FLOAT_CONTROLS_SPEC_VERSION
//             Negative: false
//             Value: 4
//         Enum:
//             Name: VK_KHR_SHADER_FLOAT_CONTROLS_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_shader_float_controls&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES
//         Type:
//             Name: VkPhysicalDeviceFloatControlsPropertiesKHR
//         Type:
//             Name: VkShaderFloatControlsIndependenceKHR
//         Enum:
//             Name: VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY_KHR
//             Negative: false
//             Extends: VkShaderFloatControlsIndependence
//             Alias: VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY
//         Enum:
//             Name: VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL_KHR
//             Negative: false
//             Extends: VkShaderFloatControlsIndependence
//             Alias: VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL
//         Enum:
//             Name: VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE_KHR
//             Negative: false
//             Extends: VkShaderFloatControlsIndependence
//             Alias: VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE
// Extension: VK_NV_shader_subgroup_partitioned
// Number: 199
// Type: device
// Author: NV
// Depends: VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NV_SHADER_SUBGROUP_PARTITIONED_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_NV_SHADER_SUBGROUP_PARTITIONED_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_shader_subgroup_partitioned&quot;
//         Enum:
//             Name: VK_SUBGROUP_FEATURE_PARTITIONED_BIT_NV
//             Negative: false
//             Bitpos: 8
//             Extends: VkSubgroupFeatureFlagBits
// Extension: VK_KHR_depth_stencil_resolve
// Number: 200
// Type: device
// Author: KHR
// Depends: VK_KHR_create_renderpass2,VK_VERSION_1_2
// Supported: supported
// Promoted to: VK_VERSION_1_2
// Unlocks:
//         Enum:
//             Name: VK_KHR_DEPTH_STENCIL_RESOLVE_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_DEPTH_STENCIL_RESOLVE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_depth_stencil_resolve&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE
//         Type:
//             Name: VkSubpassDescriptionDepthStencilResolveKHR
//         Type:
//             Name: VkPhysicalDeviceDepthStencilResolvePropertiesKHR
//         Type:
//             Name: VkResolveModeFlagBitsKHR
//         Type:
//             Name: VkResolveModeFlagsKHR
//         Enum:
//             Name: VK_RESOLVE_MODE_NONE_KHR
//             Negative: false
//             Extends: VkResolveModeFlagBits
//             Alias: VK_RESOLVE_MODE_NONE
//         Enum:
//             Name: VK_RESOLVE_MODE_SAMPLE_ZERO_BIT_KHR
//             Negative: false
//             Extends: VkResolveModeFlagBits
//             Alias: VK_RESOLVE_MODE_SAMPLE_ZERO_BIT
//         Enum:
//             Name: VK_RESOLVE_MODE_AVERAGE_BIT_KHR
//             Negative: false
//             Extends: VkResolveModeFlagBits
//             Alias: VK_RESOLVE_MODE_AVERAGE_BIT
//         Enum:
//             Name: VK_RESOLVE_MODE_MIN_BIT_KHR
//             Negative: false
//             Extends: VkResolveModeFlagBits
//             Alias: VK_RESOLVE_MODE_MIN_BIT
//         Enum:
//             Name: VK_RESOLVE_MODE_MAX_BIT_KHR
//             Negative: false
//             Extends: VkResolveModeFlagBits
//             Alias: VK_RESOLVE_MODE_MAX_BIT
// Extension: VK_KHR_swapchain_mutable_format
// Number: 201
// Type: device
// Author: KHR
// Depends: VK_KHR_swapchain+(VK_KHR_maintenance2,VK_VERSION_1_1)+(VK_KHR_image_format_list,VK_VERSION_1_2)
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_SWAPCHAIN_MUTABLE_FORMAT_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_SWAPCHAIN_MUTABLE_FORMAT_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_swapchain_mutable_format&quot;
//         Enum:
//             Name: VK_SWAPCHAIN_CREATE_MUTABLE_FORMAT_BIT_KHR
//             Negative: false
//             Bitpos: 2
//             Extends: VkSwapchainCreateFlagBitsKHR
// Extension: VK_NV_compute_shader_derivatives
// Number: 202
// Type: device
// Author: NV
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_KHR_compute_shader_derivatives
// Unlocks:
//         Enum:
//             Name: VK_NV_COMPUTE_SHADER_DERIVATIVES_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_NV_COMPUTE_SHADER_DERIVATIVES_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_compute_shader_derivatives&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_KHR
//         Type:
//             Name: VkPhysicalDeviceComputeShaderDerivativesFeaturesNV
//         Feature:
//             Name: computeDerivativeGroupQuads,computeDerivativeGroupLinear
//             Struct: VkPhysicalDeviceComputeShaderDerivativesFeaturesNV
// Extension: VK_NV_mesh_shader
// Number: 203
// Type: device
// Author: NV
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NV_MESH_SHADER_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_NV_MESH_SHADER_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_mesh_shader&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_SHADER_STAGE_TASK_BIT_NV
//             Negative: false
//             Extends: VkShaderStageFlagBits
//             Alias: VK_SHADER_STAGE_TASK_BIT_EXT
//         Enum:
//             Name: VK_SHADER_STAGE_MESH_BIT_NV
//             Negative: false
//             Extends: VkShaderStageFlagBits
//             Alias: VK_SHADER_STAGE_MESH_BIT_EXT
//         Enum:
//             Name: VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV
//             Negative: false
//             Extends: VkPipelineStageFlagBits
//             Alias: VK_PIPELINE_STAGE_TASK_SHADER_BIT_EXT
//         Enum:
//             Name: VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV
//             Negative: false
//             Extends: VkPipelineStageFlagBits
//             Alias: VK_PIPELINE_STAGE_MESH_SHADER_BIT_EXT
//         Command:
//             Name: vkCmdDrawMeshTasksNV
//         Command:
//             Name: vkCmdDrawMeshTasksIndirectNV
//         Type:
//             Name: VkPhysicalDeviceMeshShaderFeaturesNV
//         Type:
//             Name: VkPhysicalDeviceMeshShaderPropertiesNV
//         Type:
//             Name: VkDrawMeshTasksIndirectCommandNV
//         Feature:
//             Name: meshShader
//             Struct: VkPhysicalDeviceMeshShaderFeaturesNV
//     Depends: VK_VERSION_1_2,VK_KHR_draw_indirect_count,VK_AMD_draw_indirect_count
//         Command:
//             Name: vkCmdDrawMeshTasksIndirectCountNV
//     Depends: VK_EXT_device_generated_commands
//         Enum:
//             Name: VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_NV_EXT
//             Negative: false
//             Extends: VkIndirectCommandsTokenTypeEXT
//             Offset: 2
//         Enum:
//             Name: VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_COUNT_NV_EXT
//             Negative: false
//             Extends: VkIndirectCommandsTokenTypeEXT
//             Offset: 3
// Extension: VK_NV_fragment_shader_barycentric
// Number: 204
// Type: device
// Author: NV
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_KHR_fragment_shader_barycentric
// Unlocks:
//         Enum:
//             Name: VK_NV_FRAGMENT_SHADER_BARYCENTRIC_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_NV_FRAGMENT_SHADER_BARYCENTRIC_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_fragment_shader_barycentric&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_NV
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR
//         Type:
//             Name: VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV
// Extension: VK_NV_shader_image_footprint
// Number: 205
// Type: device
// Author: NV
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NV_SHADER_IMAGE_FOOTPRINT_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_NV_SHADER_IMAGE_FOOTPRINT_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_shader_image_footprint&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceShaderImageFootprintFeaturesNV
//         Feature:
//             Name: imageFootprint
//             Struct: VkPhysicalDeviceShaderImageFootprintFeaturesNV
// Extension: VK_NV_scissor_exclusive
// Number: 206
// Type: device
// Author: NV
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NV_SCISSOR_EXCLUSIVE_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_NV_SCISSOR_EXCLUSIVE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_scissor_exclusive&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_ENABLE_NV
//             Negative: false
//             Extends: VkDynamicState
//             Offset: 0
//         Enum:
//             Name: VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_NV
//             Negative: false
//             Extends: VkDynamicState
//             Offset: 1
//         Type:
//             Name: VkPipelineViewportExclusiveScissorStateCreateInfoNV
//         Type:
//             Name: VkPhysicalDeviceExclusiveScissorFeaturesNV
//         Command:
//             Name: vkCmdSetExclusiveScissorEnableNV
//         Command:
//             Name: vkCmdSetExclusiveScissorNV
//         Feature:
//             Name: exclusiveScissor
//             Struct: VkPhysicalDeviceExclusiveScissorFeaturesNV
// Extension: VK_NV_device_diagnostic_checkpoints
// Number: 207
// Type: device
// Author: NVIDIA
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NV_DEVICE_DIAGNOSTIC_CHECKPOINTS_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_NV_DEVICE_DIAGNOSTIC_CHECKPOINTS_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_device_diagnostic_checkpoints&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Type:
//             Name: VkQueueFamilyCheckpointPropertiesNV
//         Type:
//             Name: VkCheckpointDataNV
//         Command:
//             Name: vkCmdSetCheckpointNV
//         Command:
//             Name: vkGetQueueCheckpointDataNV
//     Depends: VK_VERSION_1_3,VK_KHR_synchronization2
//         Type:
//             Name: VkQueueFamilyCheckpointProperties2NV
//         Type:
//             Name: VkCheckpointData2NV
//         Command:
//             Name: vkGetQueueCheckpointData2NV
//         Enum:
//             Name: VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV
//             Negative: false
//             Extends: VkStructureType
//             Extnumber: 315
//             Offset: 8
//         Enum:
//             Name: VK_STRUCTURE_TYPE_CHECKPOINT_DATA_2_NV
//             Negative: false
//             Extends: VkStructureType
//             Extnumber: 315
//             Offset: 9
// Extension: VK_KHR_timeline_semaphore
// Number: 208
// Type: device
// Author: KHR
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_2
// Unlocks:
//         Enum:
//             Name: VK_KHR_TIMELINE_SEMAPHORE_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_KHR_TIMELINE_SEMAPHORE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_timeline_semaphore&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO
//         Enum:
//             Name: VK_SEMAPHORE_TYPE_BINARY_KHR
//             Negative: false
//             Extends: VkSemaphoreType
//             Alias: VK_SEMAPHORE_TYPE_BINARY
//         Enum:
//             Name: VK_SEMAPHORE_TYPE_TIMELINE_KHR
//             Negative: false
//             Extends: VkSemaphoreType
//             Alias: VK_SEMAPHORE_TYPE_TIMELINE
//         Enum:
//             Name: VK_SEMAPHORE_WAIT_ANY_BIT_KHR
//             Negative: false
//             Extends: VkSemaphoreWaitFlagBits
//             Alias: VK_SEMAPHORE_WAIT_ANY_BIT
//         Type:
//             Name: VkSemaphoreTypeKHR
//         Type:
//             Name: VkPhysicalDeviceTimelineSemaphoreFeaturesKHR
//         Type:
//             Name: VkPhysicalDeviceTimelineSemaphorePropertiesKHR
//         Type:
//             Name: VkSemaphoreTypeCreateInfoKHR
//         Type:
//             Name: VkTimelineSemaphoreSubmitInfoKHR
//         Type:
//             Name: VkSemaphoreWaitFlagBitsKHR
//         Type:
//             Name: VkSemaphoreWaitFlagsKHR
//         Type:
//             Name: VkSemaphoreWaitInfoKHR
//         Type:
//             Name: VkSemaphoreSignalInfoKHR
//         Command:
//             Name: vkGetSemaphoreCounterValueKHR
//         Command:
//             Name: vkWaitSemaphoresKHR
//         Command:
//             Name: vkSignalSemaphoreKHR
//         Feature:
//             Name: timelineSemaphore
//             Struct: VkPhysicalDeviceTimelineSemaphoreFeaturesKHR
// Extension: VK_EXT_present_timing
// Number: 209
// Type: device
// Author: EXT
// Depends: VK_KHR_swapchain+VK_KHR_present_id2+VK_KHR_get_surface_capabilities2+VK_KHR_calibrated_timestamps
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_PRESENT_TIMING_SPEC_VERSION
//             Negative: false
//             Value: 3
//         Enum:
//             Name: VK_EXT_PRESENT_TIMING_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_present_timing&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_TIMING_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SWAPCHAIN_TIMING_PROPERTIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SWAPCHAIN_TIME_DOMAIN_PROPERTIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PRESENT_TIMINGS_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PRESENT_TIMING_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 4
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PAST_PRESENTATION_TIMING_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 5
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PAST_PRESENTATION_TIMING_PROPERTIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 6
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PAST_PRESENTATION_TIMING_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 7
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PRESENT_TIMING_SURFACE_CAPABILITIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 8
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SWAPCHAIN_CALIBRATED_TIMESTAMP_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 9
//         Enum:
//             Name: VK_TIME_DOMAIN_PRESENT_STAGE_LOCAL_EXT
//             Negative: false
//             Extends: VkTimeDomainKHR
//             Offset: 0
//         Enum:
//             Name: VK_TIME_DOMAIN_SWAPCHAIN_LOCAL_EXT
//             Negative: false
//             Extends: VkTimeDomainKHR
//             Offset: 1
//         Enum:
//             Name: VK_ERROR_PRESENT_TIMING_QUEUE_FULL_EXT
//             Negative: true
//             Extends: VkResult
//             Offset: 0
//         Enum:
//             Name: VK_SWAPCHAIN_CREATE_PRESENT_TIMING_BIT_EXT
//             Negative: false
//             Bitpos: 9
//             Extends: VkSwapchainCreateFlagBitsKHR
//         Type:
//             Name: VkPhysicalDevicePresentTimingFeaturesEXT
//         Type:
//             Name: VkPresentTimingSurfaceCapabilitiesEXT
//         Type:
//             Name: VkSwapchainCalibratedTimestampInfoEXT
//         Type:
//             Name: VkSwapchainTimingPropertiesEXT
//         Type:
//             Name: VkSwapchainTimeDomainPropertiesEXT
//         Type:
//             Name: VkPastPresentationTimingInfoEXT
//         Type:
//             Name: VkPastPresentationTimingPropertiesEXT
//         Type:
//             Name: VkPastPresentationTimingEXT
//         Type:
//             Name: VkPresentTimingsInfoEXT
//         Type:
//             Name: VkPresentTimingInfoEXT
//         Type:
//             Name: VkPresentStageTimeEXT
//         Type:
//             Name: VkPresentStageFlagBitsEXT
//         Type:
//             Name: VkPresentStageFlagsEXT
//         Type:
//             Name: VkPresentTimingInfoFlagBitsEXT
//         Type:
//             Name: VkPresentTimingInfoFlagsEXT
//         Type:
//             Name: VkPastPresentationTimingFlagBitsEXT
//         Type:
//             Name: VkPastPresentationTimingFlagsEXT
//         Command:
//             Name: vkSetSwapchainPresentTimingQueueSizeEXT
//         Command:
//             Name: vkGetSwapchainTimingPropertiesEXT
//         Command:
//             Name: vkGetSwapchainTimeDomainPropertiesEXT
//         Command:
//             Name: vkGetPastPresentationTimingEXT
//         Feature:
//             Name: presentTiming
//             Struct: VkPhysicalDevicePresentTimingFeaturesEXT
// Extension: VK_INTEL_shader_integer_functions2
// Number: 210
// Type: device
// Author: INTEL
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_INTEL_SHADER_INTEGER_FUNCTIONS_2_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_INTEL_SHADER_INTEGER_FUNCTIONS_2_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_INTEL_shader_integer_functions2&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL
//         Feature:
//             Name: shaderIntegerFunctions2
//             Struct: VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL
// Extension: VK_INTEL_performance_query
// Number: 211
// Type: device
// Author: INTEL
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_INTEL_PERFORMANCE_QUERY_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_INTEL_PERFORMANCE_QUERY_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_INTEL_performance_query&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO_INTEL
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL
//         Enum:
//             Name: VK_STRUCTURE_TYPE_INITIALIZE_PERFORMANCE_API_INFO_INTEL
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PERFORMANCE_MARKER_INFO_INTEL
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PERFORMANCE_STREAM_MARKER_INFO_INTEL
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PERFORMANCE_OVERRIDE_INFO_INTEL
//             Negative: false
//             Extends: VkStructureType
//             Offset: 4
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL
//             Negative: false
//             Extends: VkStructureType
//             Offset: 5
//         Enum:
//             Name: VK_QUERY_TYPE_PERFORMANCE_QUERY_INTEL
//             Negative: false
//             Extends: VkQueryType
//             Offset: 0
//         Enum:
//             Name: VK_OBJECT_TYPE_PERFORMANCE_CONFIGURATION_INTEL
//             Negative: false
//             Extends: VkObjectType
//             Offset: 0
//         Type:
//             Name: VkPerformanceConfigurationTypeINTEL
//         Type:
//             Name: VkQueryPoolSamplingModeINTEL
//         Type:
//             Name: VkPerformanceOverrideTypeINTEL
//         Type:
//             Name: VkPerformanceParameterTypeINTEL
//         Type:
//             Name: VkPerformanceValueTypeINTEL
//         Type:
//             Name: VkPerformanceValueDataINTEL
//         Type:
//             Name: VkPerformanceValueINTEL
//         Type:
//             Name: VkInitializePerformanceApiInfoINTEL
//         Type:
//             Name: VkQueryPoolCreateInfoINTEL
//         Type:
//             Name: VkQueryPoolPerformanceQueryCreateInfoINTEL
//         Type:
//             Name: VkPerformanceMarkerInfoINTEL
//         Type:
//             Name: VkPerformanceStreamMarkerInfoINTEL
//         Type:
//             Name: VkPerformanceOverrideInfoINTEL
//         Type:
//             Name: VkPerformanceConfigurationAcquireInfoINTEL
//         Type:
//             Name: VkPerformanceConfigurationINTEL
//         Command:
//             Name: vkInitializePerformanceApiINTEL
//         Command:
//             Name: vkUninitializePerformanceApiINTEL
//         Command:
//             Name: vkCmdSetPerformanceMarkerINTEL
//         Command:
//             Name: vkCmdSetPerformanceStreamMarkerINTEL
//         Command:
//             Name: vkCmdSetPerformanceOverrideINTEL
//         Command:
//             Name: vkAcquirePerformanceConfigurationINTEL
//         Command:
//             Name: vkReleasePerformanceConfigurationINTEL
//         Command:
//             Name: vkQueueSetPerformanceConfigurationINTEL
//         Command:
//             Name: vkGetPerformanceParameterINTEL
// Extension: VK_KHR_vulkan_memory_model
// Number: 212
// Type: device
// Author: KHR
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_2
// Unlocks:
//         Enum:
//             Name: VK_KHR_VULKAN_MEMORY_MODEL_SPEC_VERSION
//             Negative: false
//             Value: 3
//         Enum:
//             Name: VK_KHR_VULKAN_MEMORY_MODEL_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_vulkan_memory_model&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES
//         Type:
//             Name: VkPhysicalDeviceVulkanMemoryModelFeaturesKHR
//         Feature:
//             Name: vulkanMemoryModel
//             Struct: VkPhysicalDeviceVulkanMemoryModelFeaturesKHR
// Extension: VK_EXT_pci_bus_info
// Number: 213
// Type: device
// Author: EXT
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_PCI_BUS_INFO_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_EXT_PCI_BUS_INFO_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_pci_bus_info&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDevicePCIBusInfoPropertiesEXT
// Extension: VK_AMD_display_native_hdr
// Number: 214
// Type: device
// Author: AMD
// Depends: (VK_KHR_get_physical_device_properties2,VK_VERSION_1_1)+VK_KHR_get_surface_capabilities2+VK_KHR_swapchain
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_AMD_DISPLAY_NATIVE_HDR_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_AMD_DISPLAY_NATIVE_HDR_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_display_native_hdr&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_COLOR_SPACE_DISPLAY_NATIVE_AMD
//             Negative: false
//             Extends: VkColorSpaceKHR
//             Offset: 0
//         Type:
//             Name: VkDisplayNativeHdrSurfaceCapabilitiesAMD
//         Type:
//             Name: VkSwapchainDisplayNativeHdrCreateInfoAMD
//         Command:
//             Name: vkSetLocalDimmingAMD
// Extension: VK_FUCHSIA_imagepipe_surface
// Number: 215
// Type: instance
// Author: FUCHSIA
// Depends: VK_KHR_surface
// Platform: fuchsia
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_FUCHSIA_IMAGEPIPE_SURFACE_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_FUCHSIA_IMAGEPIPE_SURFACE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_FUCHSIA_imagepipe_surface&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkImagePipeSurfaceCreateFlagsFUCHSIA
//         Type:
//             Name: VkImagePipeSurfaceCreateInfoFUCHSIA
//         Command:
//             Name: vkCreateImagePipeSurfaceFUCHSIA
// Extension: VK_KHR_shader_terminate_invocation
// Number: 216
// Type: device
// Author: KHR
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_3
// Unlocks:
//         Enum:
//             Name: VK_KHR_SHADER_TERMINATE_INVOCATION_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_SHADER_TERMINATE_INVOCATION_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_shader_terminate_invocation&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES
//         Type:
//             Name: VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR
//         Feature:
//             Name: shaderTerminateInvocation
//             Struct: VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR
// Extension: VK_GOOGLE_extension_217
// Number: 217
// Type: invalid
// Author: GOOGLE
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_GOOGLE_EXTENSION_217_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_GOOGLE_EXTENSION_217_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_GOOGLE_extension_217&quot;
// Extension: VK_EXT_metal_surface
// Number: 218
// Type: instance
// Author: EXT
// Depends: VK_KHR_surface
// Platform: metal
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_METAL_SURFACE_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_METAL_SURFACE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_metal_surface&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_METAL_SURFACE_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkMetalSurfaceCreateFlagsEXT
//         Type:
//             Name: VkMetalSurfaceCreateInfoEXT
//         Command:
//             Name: vkCreateMetalSurfaceEXT
//         Type:
//             Name: CAMetalLayer
// Extension: VK_EXT_fragment_density_map
// Number: 219
// Type: device
// Author: EXT
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_FRAGMENT_DENSITY_MAP_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_EXT_FRAGMENT_DENSITY_MAP_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_fragment_density_map&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT
//             Negative: false
//             Bitpos: 14
//             Extends: VkImageCreateFlagBits
//         Enum:
//             Name: VK_IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT
//             Negative: false
//             Extends: VkImageLayout
//             Offset: 0
//         Enum:
//             Name: VK_ACCESS_FRAGMENT_DENSITY_MAP_READ_BIT_EXT
//             Negative: false
//             Bitpos: 24
//             Extends: VkAccessFlagBits
//         Enum:
//             Name: VK_FORMAT_FEATURE_FRAGMENT_DENSITY_MAP_BIT_EXT
//             Negative: false
//             Bitpos: 24
//             Extends: VkFormatFeatureFlagBits
//         Enum:
//             Name: VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT
//             Negative: false
//             Bitpos: 9
//             Extends: VkImageUsageFlagBits
//         Enum:
//             Name: VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT
//             Negative: false
//             Bitpos: 0
//             Extends: VkImageViewCreateFlagBits
//         Enum:
//             Name: VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT
//             Negative: false
//             Bitpos: 23
//             Extends: VkPipelineStageFlagBits
//         Enum:
//             Name: VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT
//             Negative: false
//             Bitpos: 0
//             Extends: VkSamplerCreateFlagBits
//         Enum:
//             Name: VK_SAMPLER_CREATE_SUBSAMPLED_COARSE_RECONSTRUCTION_BIT_EXT
//             Negative: false
//             Bitpos: 1
//             Extends: VkSamplerCreateFlagBits
//         Type:
//             Name: VkPhysicalDeviceFragmentDensityMapFeaturesEXT
//         Type:
//             Name: VkPhysicalDeviceFragmentDensityMapPropertiesEXT
//         Type:
//             Name: VkRenderPassFragmentDensityMapCreateInfoEXT
//         Feature:
//             Name: fragmentDensityMap
//             Struct: VkPhysicalDeviceFragmentDensityMapFeaturesEXT
//     Depends: VK_KHR_format_feature_flags2,VK_VERSION_1_3
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_FRAGMENT_DENSITY_MAP_BIT_EXT
//             Negative: false
//             Bitpos: 24
//             Extends: VkFormatFeatureFlagBits2
//     Depends: VK_VERSION_1_3,VK_KHR_dynamic_rendering
//         Enum:
//             Name: VK_PIPELINE_CREATE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT
//             Negative: false
//             Bitpos: 22
//             Extends: VkPipelineCreateFlagBits
//         Enum:
//             Name: VK_PIPELINE_RASTERIZATION_STATE_CREATE_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT
//             Negative: false
//             Extends: VkPipelineCreateFlagBits
//             Alias: VK_PIPELINE_CREATE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT
//         Enum:
//             Name: VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Extnumber: 45
//             Offset: 7
//         Type:
//             Name: VkRenderingFragmentDensityMapAttachmentInfoEXT
// Extension: VK_EXT_extension_220
// Number: 220
// Type: invalid
// Author: EXT
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_220_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_220_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_220&quot;
// Extension: VK_KHR_extension_221
// Number: 221
// Type: invalid
// Author: KHR
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_KHR_EXTENSION_221_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_KHR_EXTENSION_221_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_extension_221&quot;
//         Enum:
//             Name: VK_RENDER_PASS_CREATE_RESERVED_0_BIT_KHR
//             Negative: false
//             Bitpos: 0
//             Extends: VkRenderPassCreateFlagBits
// Extension: VK_EXT_scalar_block_layout
// Number: 222
// Type: device
// Author: EXT
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_2
// Unlocks:
//         Enum:
//             Name: VK_EXT_SCALAR_BLOCK_LAYOUT_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_SCALAR_BLOCK_LAYOUT_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_scalar_block_layout&quot;
//         Type:
//             Name: VkPhysicalDeviceScalarBlockLayoutFeaturesEXT
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES
//         Feature:
//             Name: scalarBlockLayout
//             Struct: VkPhysicalDeviceScalarBlockLayoutFeaturesEXT
// Extension: VK_EXT_extension_223
// Number: 223
// Type: invalid
// Author: EXT
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_223_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_223_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_223&quot;
// Extension: VK_GOOGLE_hlsl_functionality1
// Number: 224
// Type: device
// Author: GOOGLE
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_GOOGLE_HLSL_FUNCTIONALITY_1_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_GOOGLE_HLSL_FUNCTIONALITY_1_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_GOOGLE_hlsl_functionality1&quot;
//         Enum:
//             Name: VK_GOOGLE_HLSL_FUNCTIONALITY1_SPEC_VERSION
//             Negative: false
//             Alias: VK_GOOGLE_HLSL_FUNCTIONALITY_1_SPEC_VERSION
//         Enum:
//             Name: VK_GOOGLE_HLSL_FUNCTIONALITY1_EXTENSION_NAME
//             Negative: false
//             Alias: VK_GOOGLE_HLSL_FUNCTIONALITY_1_EXTENSION_NAME
// Extension: VK_GOOGLE_decorate_string
// Number: 225
// Type: device
// Author: GOOGLE
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_GOOGLE_DECORATE_STRING_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_GOOGLE_DECORATE_STRING_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_GOOGLE_decorate_string&quot;
// Extension: VK_EXT_subgroup_size_control
// Number: 226
// Type: device
// Author: EXT
// Depends: VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_3
// Unlocks:
//         Enum:
//             Name: VK_EXT_SUBGROUP_SIZE_CONTROL_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_EXT_SUBGROUP_SIZE_CONTROL_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_subgroup_size_control&quot;
//         Type:
//             Name: VkPhysicalDeviceSubgroupSizeControlFeaturesEXT
//         Type:
//             Name: VkPhysicalDeviceSubgroupSizeControlPropertiesEXT
//         Type:
//             Name: VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES
//         Enum:
//             Name: VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT
//             Negative: false
//             Extends: VkPipelineShaderStageCreateFlagBits
//             Alias: VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT
//         Enum:
//             Name: VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT
//             Negative: false
//             Extends: VkPipelineShaderStageCreateFlagBits
//             Alias: VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT
//         Feature:
//             Name: subgroupSizeControl
//             Struct: VkPhysicalDeviceSubgroupSizeControlFeatures
//         Feature:
//             Name: computeFullSubgroups
//             Struct: VkPhysicalDeviceSubgroupSizeControlFeatures
// Extension: VK_KHR_fragment_shading_rate
// Number: 227
// Type: device
// Author: KHR
// Depends: ((VK_KHR_get_physical_device_properties2,VK_VERSION_1_1)+VK_KHR_create_renderpass2),VK_VERSION_1_2
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_FRAGMENT_SHADING_RATE_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_KHR_FRAGMENT_SHADING_RATE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_fragment_shading_rate&quot;
//         Type:
//             Name: VkFragmentShadingRateCombinerOpKHR
//         Type:
//             Name: VkFragmentShadingRateAttachmentInfoKHR
//         Type:
//             Name: VkPipelineFragmentShadingRateStateCreateInfoKHR
//         Type:
//             Name: VkPhysicalDeviceFragmentShadingRateFeaturesKHR
//         Type:
//             Name: VkPhysicalDeviceFragmentShadingRatePropertiesKHR
//         Type:
//             Name: VkPhysicalDeviceFragmentShadingRateKHR
//         Command:
//             Name: vkGetPhysicalDeviceFragmentShadingRatesKHR
//         Command:
//             Name: vkCmdSetFragmentShadingRateKHR
//         Enum:
//             Name: VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR
//             Negative: false
//             Extends: VkImageLayout
//             Extnumber: 165
//             Offset: 3
//         Enum:
//             Name: VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR
//             Negative: false
//             Extends: VkDynamicState
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 4
//         Enum:
//             Name: VK_ACCESS_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR
//             Negative: false
//             Bitpos: 23
//             Extends: VkAccessFlagBits
//         Enum:
//             Name: VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR
//             Negative: false
//             Bitpos: 8
//             Extends: VkImageUsageFlagBits
//         Enum:
//             Name: VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR
//             Negative: false
//             Bitpos: 22
//             Extends: VkPipelineStageFlagBits
//         Enum:
//             Name: VK_FORMAT_FEATURE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR
//             Negative: false
//             Bitpos: 30
//             Extends: VkFormatFeatureFlagBits
//         Feature:
//             Name: pipelineFragmentShadingRate
//             Struct: VkPhysicalDeviceFragmentShadingRateFeaturesKHR
//     Depends: VK_KHR_format_feature_flags2,VK_VERSION_1_3
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR
//             Negative: false
//             Bitpos: 30
//             Extends: VkFormatFeatureFlagBits2
//     Depends: VK_VERSION_1_3,VK_KHR_dynamic_rendering
//         Enum:
//             Name: VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Extnumber: 45
//             Offset: 6
//     Depends: VK_VERSION_1_3,VK_KHR_dynamic_rendering
//         Enum:
//             Name: VK_PIPELINE_CREATE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR
//             Negative: false
//             Bitpos: 21
//             Extends: VkPipelineCreateFlagBits
//         Enum:
//             Name: VK_PIPELINE_RASTERIZATION_STATE_CREATE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR
//             Negative: false
//             Extends: VkPipelineCreateFlagBits
//             Alias: VK_PIPELINE_CREATE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR
//         Type:
//             Name: VkRenderingFragmentShadingRateAttachmentInfoKHR
// Extension: VK_AMD_shader_core_properties2
// Number: 228
// Type: device
// Author: AMD
// Depends: VK_AMD_shader_core_properties
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_AMD_SHADER_CORE_PROPERTIES_2_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_AMD_SHADER_CORE_PROPERTIES_2_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_shader_core_properties2&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceShaderCoreProperties2AMD
//         Type:
//             Name: VkShaderCorePropertiesFlagBitsAMD
//         Type:
//             Name: VkShaderCorePropertiesFlagsAMD
// Extension: VK_AMD_extension_229
// Number: 229
// Type: invalid
// Author: AMD
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_AMD_EXTENSION_229_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_AMD_EXTENSION_229_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_extension_229&quot;
// Extension: VK_AMD_device_coherent_memory
// Number: 230
// Type: device
// Author: AMD
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_AMD_DEVICE_COHERENT_MEMORY_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_AMD_DEVICE_COHERENT_MEMORY_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_device_coherent_memory&quot;
//         Enum:
//             Name: VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD
//             Negative: false
//             Bitpos: 6
//             Extends: VkMemoryPropertyFlagBits
//         Enum:
//             Name: VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD
//             Negative: false
//             Bitpos: 7
//             Extends: VkMemoryPropertyFlagBits
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceCoherentMemoryFeaturesAMD
//         Feature:
//             Name: deviceCoherentMemory
//             Struct: VkPhysicalDeviceCoherentMemoryFeaturesAMD
// Extension: VK_AMD_extension_231
// Number: 231
// Type: invalid
// Author: AMD
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_AMD_EXTENSION_231_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_AMD_EXTENSION_231_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_extension_231&quot;
// Extension: VK_AMD_extension_232
// Number: 232
// Type: invalid
// Author: AMD
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_AMD_EXTENSION_232_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_AMD_EXTENSION_232_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_extension_232&quot;
// Extension: VK_KHR_dynamic_rendering_local_read
// Number: 233
// Type: device
// Author: AMD
// Depends: VK_KHR_dynamic_rendering,VK_VERSION_1_3
// Supported: supported
// Promoted to: VK_VERSION_1_4
// Unlocks:
//         Enum:
//             Name: VK_KHR_DYNAMIC_RENDERING_LOCAL_READ_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_DYNAMIC_RENDERING_LOCAL_READ_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_dynamic_rendering_local_read&quot;
//         Enum:
//             Name: VK_IMAGE_LAYOUT_RENDERING_LOCAL_READ_KHR
//             Negative: false
//             Extends: VkImageLayout
//             Alias: VK_IMAGE_LAYOUT_RENDERING_LOCAL_READ
//         Command:
//             Name: vkCmdSetRenderingAttachmentLocationsKHR
//         Command:
//             Name: vkCmdSetRenderingInputAttachmentIndicesKHR
//         Type:
//             Name: VkPhysicalDeviceDynamicRenderingLocalReadFeaturesKHR
//         Type:
//             Name: VkRenderingAttachmentLocationInfoKHR
//         Type:
//             Name: VkRenderingInputAttachmentIndexInfoKHR
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_LOCAL_READ_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_LOCAL_READ_FEATURES
//         Enum:
//             Name: VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_LOCATION_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_LOCATION_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_RENDERING_INPUT_ATTACHMENT_INDEX_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_RENDERING_INPUT_ATTACHMENT_INDEX_INFO
//         Feature:
//             Name: dynamicRenderingLocalRead
//             Struct: VkPhysicalDeviceDynamicRenderingLocalReadFeaturesKHR
// Extension: VK_AMD_extension_234
// Number: 234
// Type: invalid
// Author: AMD
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_AMD_EXTENSION_234_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_AMD_EXTENSION_234_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_extension_234&quot;
// Extension: VK_EXT_shader_image_atomic_int64
// Number: 235
// Type: device
// Author: EXT
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_SHADER_IMAGE_ATOMIC_INT64_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_SHADER_IMAGE_ATOMIC_INT64_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_shader_image_atomic_int64&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT
//         Feature:
//             Name: shaderInt64
//             Struct: VkPhysicalDeviceFeatures
//         Feature:
//             Name: shaderImageInt64Atomics
//             Struct: VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT
// Extension: VK_KHR_shader_quad_control
// Number: 236
// Type: device
// Author: KHR
// Depends: ((VK_VERSION_1_1+VK_KHR_vulkan_memory_model),VK_VERSION_1_2)+VK_KHR_shader_maximal_reconvergence
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_SHADER_QUAD_CONTROL_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_SHADER_QUAD_CONTROL_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_shader_quad_control&quot;
//         Type:
//             Name: VkPhysicalDeviceShaderQuadControlFeaturesKHR
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_QUAD_CONTROL_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Feature:
//             Name: shaderQuadControl
//             Struct: VkPhysicalDeviceShaderQuadControlFeaturesKHR
// Extension: VK_KHR_spirv_1_4
// Number: 237
// Type: device
// Author: KHR
// Depends: VK_VERSION_1_1+VK_KHR_shader_float_controls
// Supported: supported
// Promoted to: VK_VERSION_1_2
// Unlocks:
//         Enum:
//             Name: VK_KHR_SPIRV_1_4_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_SPIRV_1_4_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_spirv_1_4&quot;
// Extension: VK_EXT_memory_budget
// Number: 238
// Type: device
// Author: EXT
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_MEMORY_BUDGET_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_MEMORY_BUDGET_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_memory_budget&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceMemoryBudgetPropertiesEXT
// Extension: VK_EXT_memory_priority
// Number: 239
// Type: device
// Author: EXT
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_MEMORY_PRIORITY_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_MEMORY_PRIORITY_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_memory_priority&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Type:
//             Name: VkPhysicalDeviceMemoryPriorityFeaturesEXT
//         Type:
//             Name: VkMemoryPriorityAllocateInfoEXT
//         Feature:
//             Name: memoryPriority
//             Struct: VkPhysicalDeviceMemoryPriorityFeaturesEXT
// Extension: VK_KHR_surface_protected_capabilities
// Number: 240
// Type: instance
// Author: KHR
// Depends: VK_VERSION_1_1+VK_KHR_get_surface_capabilities2
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_SURFACE_PROTECTED_CAPABILITIES_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_SURFACE_PROTECTED_CAPABILITIES_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_surface_protected_capabilities&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkSurfaceProtectedCapabilitiesKHR
// Extension: VK_NV_dedicated_allocation_image_aliasing
// Number: 241
// Type: device
// Author: NVIDIA
// Depends: (VK_KHR_dedicated_allocation+VK_KHR_get_physical_device_properties2),VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NV_DEDICATED_ALLOCATION_IMAGE_ALIASING_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_NV_DEDICATED_ALLOCATION_IMAGE_ALIASING_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_dedicated_allocation_image_aliasing&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV
//         Feature:
//             Name: dedicatedAllocationImageAliasing
//             Struct: VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV
// Extension: VK_KHR_separate_depth_stencil_layouts
// Number: 242
// Type: device
// Author: KHR
// Depends: ((VK_KHR_get_physical_device_properties2,VK_VERSION_1_1)+VK_KHR_create_renderpass2),VK_VERSION_1_2
// Supported: supported
// Promoted to: VK_VERSION_1_2
// Unlocks:
//         Enum:
//             Name: VK_KHR_SEPARATE_DEPTH_STENCIL_LAYOUTS_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_SEPARATE_DEPTH_STENCIL_LAYOUTS_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_separate_depth_stencil_layouts&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES
//         Enum:
//             Name: VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT
//         Enum:
//             Name: VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT
//         Enum:
//             Name: VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL_KHR
//             Negative: false
//             Extends: VkImageLayout
//             Alias: VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL
//         Enum:
//             Name: VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL_KHR
//             Negative: false
//             Extends: VkImageLayout
//             Alias: VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL
//         Enum:
//             Name: VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL_KHR
//             Negative: false
//             Extends: VkImageLayout
//             Alias: VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL
//         Enum:
//             Name: VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL_KHR
//             Negative: false
//             Extends: VkImageLayout
//             Alias: VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL
//         Type:
//             Name: VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR
//         Type:
//             Name: VkAttachmentReferenceStencilLayoutKHR
//         Type:
//             Name: VkAttachmentDescriptionStencilLayoutKHR
//         Feature:
//             Name: separateDepthStencilLayouts
//             Struct: VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR
// Extension: VK_INTEL_extension_243
// Number: 243
// Type: invalid
// Author: INTEL
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_INTEL_EXTENSION_243_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_INTEL_EXTENSION_243_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_INTEL_extension_243&quot;
//         Enum:
//             Name: VK_ACCESS_2_RESERVED_46_BIT_INTEL
//             Negative: false
//             Bitpos: 46
//             Extends: VkAccessFlagBits2
// Extension: VK_MESA_extension_244
// Number: 244
// Type: invalid
// Author: MESA
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_MESA_EXTENSION_244_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_MESA_EXTENSION_244_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_MESA_extension_244&quot;
// Extension: VK_EXT_buffer_device_address
// Number: 245
// Type: device
// Author: NV
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Deprecated by: VK_KHR_buffer_device_address
// Unlocks:
//         Enum:
//             Name: VK_EXT_BUFFER_DEVICE_ADDRESS_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_EXT_BUFFER_DEVICE_ADDRESS_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_buffer_device_address&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_ADDRESS_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT
//         Enum:
//             Name: VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_EXT
//             Negative: false
//             Extends: VkBufferUsageFlagBits
//             Alias: VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT
//         Enum:
//             Name: VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT
//             Negative: false
//             Extends: VkBufferCreateFlagBits
//             Alias: VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT
//         Enum:
//             Name: VK_ERROR_INVALID_DEVICE_ADDRESS_EXT
//             Negative: false
//             Extends: VkResult
//             Alias: VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS
//         Type:
//             Name: VkPhysicalDeviceBufferAddressFeaturesEXT
//         Type:
//             Name: VkPhysicalDeviceBufferDeviceAddressFeaturesEXT
//         Type:
//             Name: VkBufferDeviceAddressInfoEXT
//         Type:
//             Name: VkBufferDeviceAddressCreateInfoEXT
//         Command:
//             Name: vkGetBufferDeviceAddressEXT
//         Feature:
//             Name: bufferDeviceAddress
//             Struct: VkPhysicalDeviceBufferDeviceAddressFeaturesEXT
// Extension: VK_EXT_tooling_info
// Number: 246
// Type: device
// Author: EXT
// Supported: supported
// Promoted to: VK_VERSION_1_3
// Unlocks:
//         Enum:
//             Name: VK_EXT_TOOLING_INFO_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_TOOLING_INFO_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_tooling_info&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES
//         Enum:
//             Name: VK_TOOL_PURPOSE_VALIDATION_BIT_EXT
//             Negative: false
//             Extends: VkToolPurposeFlagBits
//             Alias: VK_TOOL_PURPOSE_VALIDATION_BIT
//         Enum:
//             Name: VK_TOOL_PURPOSE_PROFILING_BIT_EXT
//             Negative: false
//             Extends: VkToolPurposeFlagBits
//             Alias: VK_TOOL_PURPOSE_PROFILING_BIT
//         Enum:
//             Name: VK_TOOL_PURPOSE_TRACING_BIT_EXT
//             Negative: false
//             Extends: VkToolPurposeFlagBits
//             Alias: VK_TOOL_PURPOSE_TRACING_BIT
//         Enum:
//             Name: VK_TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT_EXT
//             Negative: false
//             Extends: VkToolPurposeFlagBits
//             Alias: VK_TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT
//         Enum:
//             Name: VK_TOOL_PURPOSE_MODIFYING_FEATURES_BIT_EXT
//             Negative: false
//             Extends: VkToolPurposeFlagBits
//             Alias: VK_TOOL_PURPOSE_MODIFYING_FEATURES_BIT
//         Type:
//             Name: VkToolPurposeFlagBitsEXT
//         Type:
//             Name: VkToolPurposeFlagsEXT
//         Type:
//             Name: VkPhysicalDeviceToolPropertiesEXT
//         Command:
//             Name: vkGetPhysicalDeviceToolPropertiesEXT
//     Depends: VK_EXT_debug_report
//         Enum:
//             Name: VK_TOOL_PURPOSE_DEBUG_REPORTING_BIT_EXT
//             Negative: false
//             Bitpos: 5
//             Extends: VkToolPurposeFlagBits
//     Depends: VK_EXT_debug_marker
//         Enum:
//             Name: VK_TOOL_PURPOSE_DEBUG_MARKERS_BIT_EXT
//             Negative: false
//             Bitpos: 6
//             Extends: VkToolPurposeFlagBits
//     Depends: VK_EXT_debug_utils
//         Enum:
//             Name: VK_TOOL_PURPOSE_DEBUG_REPORTING_BIT_EXT
//             Negative: false
//             Bitpos: 5
//             Extends: VkToolPurposeFlagBits
//         Enum:
//             Name: VK_TOOL_PURPOSE_DEBUG_MARKERS_BIT_EXT
//             Negative: false
//             Bitpos: 6
//             Extends: VkToolPurposeFlagBits
// Extension: VK_EXT_separate_stencil_usage
// Number: 247
// Type: device
// Author: EXT
// Supported: supported
// Promoted to: VK_VERSION_1_2
// Unlocks:
//         Enum:
//             Name: VK_EXT_SEPARATE_STENCIL_USAGE_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_SEPARATE_STENCIL_USAGE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_separate_stencil_usage&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO
//         Type:
//             Name: VkImageStencilUsageCreateInfoEXT
// Extension: VK_EXT_validation_features
// Number: 248
// Type: instance
// Author: LUNARG
// Supported: supported
// Deprecated by: VK_EXT_layer_settings
// Unlocks:
//         Enum:
//             Name: VK_EXT_VALIDATION_FEATURES_SPEC_VERSION
//             Negative: false
//             Value: 6
//         Enum:
//             Name: VK_EXT_VALIDATION_FEATURES_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_validation_features&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkValidationFeaturesEXT
//         Type:
//             Name: VkValidationFeatureEnableEXT
//         Type:
//             Name: VkValidationFeatureDisableEXT
// Extension: VK_KHR_present_wait
// Number: 249
// Type: device
// Author: KHR
// Depends: VK_KHR_swapchain+VK_KHR_present_id
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_PRESENT_WAIT_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_PRESENT_WAIT_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_present_wait&quot;
//         Command:
//             Name: vkWaitForPresentKHR
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDevicePresentWaitFeaturesKHR
//         Feature:
//             Name: presentWait
//             Struct: VkPhysicalDevicePresentWaitFeaturesKHR
// Extension: VK_NV_cooperative_matrix
// Number: 250
// Type: device
// Author: NV
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NV_COOPERATIVE_MATRIX_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_NV_COOPERATIVE_MATRIX_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_cooperative_matrix&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Type:
//             Name: VkCooperativeMatrixPropertiesNV
//         Type:
//             Name: VkScopeNV
//         Enum:
//             Name: VK_SCOPE_DEVICE_NV
//             Negative: false
//             Extends: VkScopeKHR
//             Alias: VK_SCOPE_DEVICE_KHR
//         Enum:
//             Name: VK_SCOPE_WORKGROUP_NV
//             Negative: false
//             Extends: VkScopeKHR
//             Alias: VK_SCOPE_WORKGROUP_KHR
//         Enum:
//             Name: VK_SCOPE_SUBGROUP_NV
//             Negative: false
//             Extends: VkScopeKHR
//             Alias: VK_SCOPE_SUBGROUP_KHR
//         Enum:
//             Name: VK_SCOPE_QUEUE_FAMILY_NV
//             Negative: false
//             Extends: VkScopeKHR
//             Alias: VK_SCOPE_QUEUE_FAMILY_KHR
//         Type:
//             Name: VkComponentTypeNV
//         Enum:
//             Name: VK_COMPONENT_TYPE_FLOAT16_NV
//             Negative: false
//             Extends: VkComponentTypeKHR
//             Alias: VK_COMPONENT_TYPE_FLOAT16_KHR
//         Enum:
//             Name: VK_COMPONENT_TYPE_FLOAT32_NV
//             Negative: false
//             Extends: VkComponentTypeKHR
//             Alias: VK_COMPONENT_TYPE_FLOAT32_KHR
//         Enum:
//             Name: VK_COMPONENT_TYPE_FLOAT64_NV
//             Negative: false
//             Extends: VkComponentTypeKHR
//             Alias: VK_COMPONENT_TYPE_FLOAT64_KHR
//         Enum:
//             Name: VK_COMPONENT_TYPE_SINT8_NV
//             Negative: false
//             Extends: VkComponentTypeKHR
//             Alias: VK_COMPONENT_TYPE_SINT8_KHR
//         Enum:
//             Name: VK_COMPONENT_TYPE_SINT16_NV
//             Negative: false
//             Extends: VkComponentTypeKHR
//             Alias: VK_COMPONENT_TYPE_SINT16_KHR
//         Enum:
//             Name: VK_COMPONENT_TYPE_SINT32_NV
//             Negative: false
//             Extends: VkComponentTypeKHR
//             Alias: VK_COMPONENT_TYPE_SINT32_KHR
//         Enum:
//             Name: VK_COMPONENT_TYPE_SINT64_NV
//             Negative: false
//             Extends: VkComponentTypeKHR
//             Alias: VK_COMPONENT_TYPE_SINT64_KHR
//         Enum:
//             Name: VK_COMPONENT_TYPE_UINT8_NV
//             Negative: false
//             Extends: VkComponentTypeKHR
//             Alias: VK_COMPONENT_TYPE_UINT8_KHR
//         Enum:
//             Name: VK_COMPONENT_TYPE_UINT16_NV
//             Negative: false
//             Extends: VkComponentTypeKHR
//             Alias: VK_COMPONENT_TYPE_UINT16_KHR
//         Enum:
//             Name: VK_COMPONENT_TYPE_UINT32_NV
//             Negative: false
//             Extends: VkComponentTypeKHR
//             Alias: VK_COMPONENT_TYPE_UINT32_KHR
//         Enum:
//             Name: VK_COMPONENT_TYPE_UINT64_NV
//             Negative: false
//             Extends: VkComponentTypeKHR
//             Alias: VK_COMPONENT_TYPE_UINT64_KHR
//         Type:
//             Name: VkPhysicalDeviceCooperativeMatrixFeaturesNV
//         Type:
//             Name: VkPhysicalDeviceCooperativeMatrixPropertiesNV
//         Command:
//             Name: vkGetPhysicalDeviceCooperativeMatrixPropertiesNV
//         Feature:
//             Name: cooperativeMatrix
//             Struct: VkPhysicalDeviceCooperativeMatrixFeaturesNV
// Extension: VK_NV_coverage_reduction_mode
// Number: 251
// Type: device
// Author: NV
// Depends: VK_NV_framebuffer_mixed_samples+(VK_KHR_get_physical_device_properties2,VK_VERSION_1_1)
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NV_COVERAGE_REDUCTION_MODE_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_NV_COVERAGE_REDUCTION_MODE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_coverage_reduction_mode&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Type:
//             Name: VkPhysicalDeviceCoverageReductionModeFeaturesNV
//         Type:
//             Name: VkPipelineCoverageReductionStateCreateInfoNV
//         Type:
//             Name: VkPipelineCoverageReductionStateCreateFlagsNV
//         Type:
//             Name: VkCoverageReductionModeNV
//         Type:
//             Name: VkFramebufferMixedSamplesCombinationNV
//         Command:
//             Name: vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV
//         Feature:
//             Name: coverageReductionMode
//             Struct: VkPhysicalDeviceCoverageReductionModeFeaturesNV
// Extension: VK_EXT_fragment_shader_interlock
// Number: 252
// Type: device
// Author: EXT
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_FRAGMENT_SHADER_INTERLOCK_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_FRAGMENT_SHADER_INTERLOCK_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_fragment_shader_interlock&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT
//         Feature:
//             Name: fragmentShaderSampleInterlock,fragmentShaderPixelInterlock,fragmentShaderShadingRateInterlock
//             Struct: VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT
// Extension: VK_EXT_ycbcr_image_arrays
// Number: 253
// Type: device
// Author: EXT
// Depends: VK_KHR_sampler_ycbcr_conversion,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_YCBCR_IMAGE_ARRAYS_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_YCBCR_IMAGE_ARRAYS_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_ycbcr_image_arrays&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceYcbcrImageArraysFeaturesEXT
//         Feature:
//             Name: ycbcrImageArrays
//             Struct: VkPhysicalDeviceYcbcrImageArraysFeaturesEXT
// Extension: VK_KHR_uniform_buffer_standard_layout
// Number: 254
// Type: device
// Author: KHR
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_2
// Unlocks:
//         Enum:
//             Name: VK_KHR_UNIFORM_BUFFER_STANDARD_LAYOUT_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_UNIFORM_BUFFER_STANDARD_LAYOUT_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_uniform_buffer_standard_layout&quot;
//         Type:
//             Name: VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES
//         Feature:
//             Name: uniformBufferStandardLayout
//             Struct: VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR
// Extension: VK_EXT_provoking_vertex
// Number: 255
// Type: device
// Author: EXT
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_PROVOKING_VERTEX_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_PROVOKING_VERTEX_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_provoking_vertex&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Type:
//             Name: VkPhysicalDeviceProvokingVertexFeaturesEXT
//         Type:
//             Name: VkPhysicalDeviceProvokingVertexPropertiesEXT
//         Type:
//             Name: VkPipelineRasterizationProvokingVertexStateCreateInfoEXT
//         Type:
//             Name: VkProvokingVertexModeEXT
//         Feature:
//             Name: provokingVertexLast
//             Struct: VkPhysicalDeviceProvokingVertexFeaturesEXT
// Extension: VK_EXT_full_screen_exclusive
// Number: 256
// Type: device
// Author: EXT
// Depends: (VK_KHR_get_physical_device_properties2,VK_VERSION_1_1)+VK_KHR_surface+VK_KHR_get_surface_capabilities2+VK_KHR_swapchain
// Platform: win32
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_FULL_SCREEN_EXCLUSIVE_SPEC_VERSION
//             Negative: false
//             Value: 4
//         Enum:
//             Name: VK_EXT_FULL_SCREEN_EXCLUSIVE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_full_screen_exclusive&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT
//             Negative: true
//             Extends: VkResult
//             Offset: 0
//         Type:
//             Name: VkFullScreenExclusiveEXT
//         Type:
//             Name: VkSurfaceFullScreenExclusiveInfoEXT
//         Type:
//             Name: VkSurfaceCapabilitiesFullScreenExclusiveEXT
//         Command:
//             Name: vkGetPhysicalDeviceSurfacePresentModes2EXT
//         Command:
//             Name: vkAcquireFullScreenExclusiveModeEXT
//         Command:
//             Name: vkReleaseFullScreenExclusiveModeEXT
//     Depends: VK_KHR_win32_surface
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Type:
//             Name: VkSurfaceFullScreenExclusiveWin32InfoEXT
//     Depends: VK_KHR_device_group,VK_VERSION_1_1
//         Command:
//             Name: vkGetDeviceGroupSurfacePresentModes2EXT
// Extension: VK_EXT_headless_surface
// Number: 257
// Type: instance
// Author: EXT
// Depends: VK_KHR_surface
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_HEADLESS_SURFACE_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_HEADLESS_SURFACE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_headless_surface&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkHeadlessSurfaceCreateFlagsEXT
//         Type:
//             Name: VkHeadlessSurfaceCreateInfoEXT
//         Command:
//             Name: vkCreateHeadlessSurfaceEXT
// Extension: VK_KHR_buffer_device_address
// Number: 258
// Type: device
// Author: KHR
// Depends: (VK_KHR_get_physical_device_properties2+VK_KHR_device_group),VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_2
// Unlocks:
//         Enum:
//             Name: VK_KHR_BUFFER_DEVICE_ADDRESS_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_BUFFER_DEVICE_ADDRESS_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_buffer_device_address&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES
//         Enum:
//             Name: VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO
//         Enum:
//             Name: VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_KHR
//             Negative: false
//             Extends: VkBufferUsageFlagBits
//             Alias: VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT
//         Enum:
//             Name: VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR
//             Negative: false
//             Extends: VkBufferCreateFlagBits
//             Alias: VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT
//         Enum:
//             Name: VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT_KHR
//             Negative: false
//             Extends: VkMemoryAllocateFlagBits
//             Alias: VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT
//         Enum:
//             Name: VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR
//             Negative: false
//             Extends: VkMemoryAllocateFlagBits
//             Alias: VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT
//         Enum:
//             Name: VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS_KHR
//             Negative: false
//             Extends: VkResult
//             Alias: VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS
//         Type:
//             Name: VkPhysicalDeviceBufferDeviceAddressFeaturesKHR
//         Type:
//             Name: VkBufferDeviceAddressInfoKHR
//         Type:
//             Name: VkBufferOpaqueCaptureAddressCreateInfoKHR
//         Type:
//             Name: VkMemoryOpaqueCaptureAddressAllocateInfoKHR
//         Type:
//             Name: VkDeviceMemoryOpaqueCaptureAddressInfoKHR
//         Command:
//             Name: vkGetBufferDeviceAddressKHR
//         Command:
//             Name: vkGetBufferOpaqueCaptureAddressKHR
//         Command:
//             Name: vkGetDeviceMemoryOpaqueCaptureAddressKHR
//         Feature:
//             Name: bufferDeviceAddress
//             Struct: VkPhysicalDeviceBufferDeviceAddressFeaturesKHR
// Extension: VK_EXT_extension_259
// Number: 259
// Type: invalid
// Author: EXT
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_259_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_259_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_259&quot;
//     Depends: (VK_KHR_dynamic_rendering,VK_VERSION_1_3)+(VK_KHR_maintenance5,VK_VERSION_1_4)
//         Enum:
//             Name: VK_PIPELINE_CREATE_RESERVED_44_BIT_KHR
//             Negative: false
//             Bitpos: 44
//             Extends: VkPipelineCreateFlagBits2
//     Depends: VK_EXT_shader_object
//         Enum:
//             Name: VK_SHADER_CREATE_RESERVED_16_BIT_KHR
//             Negative: false
//             Bitpos: 16
//             Extends: VkShaderCreateFlagBitsEXT
// Extension: VK_EXT_line_rasterization
// Number: 260
// Type: device
// Author: EXT
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_KHR_line_rasterization
// Unlocks:
//         Enum:
//             Name: VK_EXT_LINE_RASTERIZATION_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_LINE_RASTERIZATION_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_line_rasterization&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES
//         Enum:
//             Name: VK_DYNAMIC_STATE_LINE_STIPPLE_EXT
//             Negative: false
//             Extends: VkDynamicState
//             Alias: VK_DYNAMIC_STATE_LINE_STIPPLE
//         Enum:
//             Name: VK_LINE_RASTERIZATION_MODE_DEFAULT_EXT
//             Negative: false
//             Extends: VkLineRasterizationMode
//             Alias: VK_LINE_RASTERIZATION_MODE_DEFAULT
//         Enum:
//             Name: VK_LINE_RASTERIZATION_MODE_RECTANGULAR_EXT
//             Negative: false
//             Extends: VkLineRasterizationMode
//             Alias: VK_LINE_RASTERIZATION_MODE_RECTANGULAR
//         Enum:
//             Name: VK_LINE_RASTERIZATION_MODE_BRESENHAM_EXT
//             Negative: false
//             Extends: VkLineRasterizationMode
//             Alias: VK_LINE_RASTERIZATION_MODE_BRESENHAM
//         Enum:
//             Name: VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_EXT
//             Negative: false
//             Extends: VkLineRasterizationMode
//             Alias: VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH
//         Type:
//             Name: VkPhysicalDeviceLineRasterizationFeaturesEXT
//         Type:
//             Name: VkPhysicalDeviceLineRasterizationPropertiesEXT
//         Type:
//             Name: VkPipelineRasterizationLineStateCreateInfoEXT
//         Type:
//             Name: VkLineRasterizationModeEXT
//         Command:
//             Name: vkCmdSetLineStippleEXT
//         Feature:
//             Name: rectangularLines,bresenhamLines,smoothLines,stippledRectangularLines,stippledBresenhamLines,stippledSmoothLines
//             Struct: VkPhysicalDeviceLineRasterizationFeaturesEXT
// Extension: VK_EXT_shader_atomic_float
// Number: 261
// Type: device
// Author: NV
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_SHADER_ATOMIC_FLOAT_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_SHADER_ATOMIC_FLOAT_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_shader_atomic_float&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceShaderAtomicFloatFeaturesEXT
//         Feature:
//             Name: shaderBufferFloat32Atomics,shaderBufferFloat32AtomicAdd,shaderBufferFloat64Atomics,shaderBufferFloat64AtomicAdd,shaderSharedFloat32Atomics,shaderSharedFloat32AtomicAdd,shaderSharedFloat64Atomics,shaderSharedFloat64AtomicAdd,shaderImageFloat32Atomics,shaderImageFloat32AtomicAdd
//             Struct: VkPhysicalDeviceShaderAtomicFloatFeaturesEXT
//     Depends: VkPhysicalDeviceShaderAtomicFloatFeaturesEXT::sparseImageFloat32Atomics
//         Feature:
//             Name: shaderImageFloat32Atomics
//             Struct: VkPhysicalDeviceShaderAtomicFloatFeaturesEXT
//     Depends: VkPhysicalDeviceShaderAtomicFloatFeaturesEXT::sparseImageFloat32AtomicAdd
//         Feature:
//             Name: shaderImageFloat32AtomicAdd
//             Struct: VkPhysicalDeviceShaderAtomicFloatFeaturesEXT
// Extension: VK_EXT_host_query_reset
// Number: 262
// Type: device
// Author: EXT
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_2
// Unlocks:
//         Enum:
//             Name: VK_EXT_HOST_QUERY_RESET_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_HOST_QUERY_RESET_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_host_query_reset&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES
//         Type:
//             Name: VkPhysicalDeviceHostQueryResetFeaturesEXT
//         Command:
//             Name: vkResetQueryPoolEXT
//         Feature:
//             Name: hostQueryReset
//             Struct: VkPhysicalDeviceHostQueryResetFeaturesEXT
// Extension: VK_GGP_extension_263
// Number: 263
// Type: invalid
// Author: GGP
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_GGP_EXTENSION_263_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_GGP_EXTENSION_263_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_GGP_extension_263&quot;
// Extension: VK_BRCM_extension_264
// Number: 264
// Type: invalid
// Author: BRCM
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_BRCM_EXTENSION_264_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_BRCM_EXTENSION_264_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_BRCM_extension_264&quot;
// Extension: VK_BRCM_extension_265
// Number: 265
// Type: invalid
// Author: BRCM
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_BRCM_EXTENSION_265_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_BRCM_EXTENSION_265_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_BRCM_extension_265&quot;
// Extension: VK_EXT_index_type_uint8
// Number: 266
// Type: device
// Author: EXT
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_KHR_index_type_uint8
// Unlocks:
//         Enum:
//             Name: VK_EXT_INDEX_TYPE_UINT8_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_INDEX_TYPE_UINT8_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_index_type_uint8&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES
//         Enum:
//             Name: VK_INDEX_TYPE_UINT8_EXT
//             Negative: false
//             Extends: VkIndexType
//             Alias: VK_INDEX_TYPE_UINT8
//         Type:
//             Name: VkPhysicalDeviceIndexTypeUint8FeaturesEXT
//         Feature:
//             Name: indexTypeUint8
//             Struct: VkPhysicalDeviceIndexTypeUint8FeaturesEXT
// Extension: VK_EXT_extension_267
// Number: 267
// Type: device
// Author: EXT
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_267_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_267_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_267&quot;
// Extension: VK_EXT_extended_dynamic_state
// Number: 268
// Type: device
// Author: EXT
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_3
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENDED_DYNAMIC_STATE_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_EXTENDED_DYNAMIC_STATE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extended_dynamic_state&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//             Comment:
//                 Not promoted to 1.3
//         Enum:
//             Name: VK_DYNAMIC_STATE_CULL_MODE_EXT
//             Negative: false
//             Extends: VkDynamicState
//             Alias: VK_DYNAMIC_STATE_CULL_MODE
//         Enum:
//             Name: VK_DYNAMIC_STATE_FRONT_FACE_EXT
//             Negative: false
//             Extends: VkDynamicState
//             Alias: VK_DYNAMIC_STATE_FRONT_FACE
//         Enum:
//             Name: VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY_EXT
//             Negative: false
//             Extends: VkDynamicState
//             Alias: VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY
//         Enum:
//             Name: VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT_EXT
//             Negative: false
//             Extends: VkDynamicState
//             Alias: VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT
//         Enum:
//             Name: VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT_EXT
//             Negative: false
//             Extends: VkDynamicState
//             Alias: VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT
//         Enum:
//             Name: VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE_EXT
//             Negative: false
//             Extends: VkDynamicState
//             Alias: VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE
//         Enum:
//             Name: VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE_EXT
//             Negative: false
//             Extends: VkDynamicState
//             Alias: VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE
//         Enum:
//             Name: VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE_EXT
//             Negative: false
//             Extends: VkDynamicState
//             Alias: VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE
//         Enum:
//             Name: VK_DYNAMIC_STATE_DEPTH_COMPARE_OP_EXT
//             Negative: false
//             Extends: VkDynamicState
//             Alias: VK_DYNAMIC_STATE_DEPTH_COMPARE_OP
//         Enum:
//             Name: VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE_EXT
//             Negative: false
//             Extends: VkDynamicState
//             Alias: VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE
//         Enum:
//             Name: VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE_EXT
//             Negative: false
//             Extends: VkDynamicState
//             Alias: VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE
//         Enum:
//             Name: VK_DYNAMIC_STATE_STENCIL_OP_EXT
//             Negative: false
//             Extends: VkDynamicState
//             Alias: VK_DYNAMIC_STATE_STENCIL_OP
//         Type:
//             Name: VkPhysicalDeviceExtendedDynamicStateFeaturesEXT
//         Command:
//             Name: vkCmdSetCullModeEXT
//         Command:
//             Name: vkCmdSetFrontFaceEXT
//         Command:
//             Name: vkCmdSetPrimitiveTopologyEXT
//         Command:
//             Name: vkCmdSetViewportWithCountEXT
//         Command:
//             Name: vkCmdSetScissorWithCountEXT
//         Command:
//             Name: vkCmdBindVertexBuffers2EXT
//         Command:
//             Name: vkCmdSetDepthTestEnableEXT
//         Command:
//             Name: vkCmdSetDepthWriteEnableEXT
//         Command:
//             Name: vkCmdSetDepthCompareOpEXT
//         Command:
//             Name: vkCmdSetDepthBoundsTestEnableEXT
//         Command:
//             Name: vkCmdSetStencilTestEnableEXT
//         Command:
//             Name: vkCmdSetStencilOpEXT
//         Feature:
//             Name: extendedDynamicState
//             Struct: VkPhysicalDeviceExtendedDynamicStateFeaturesEXT
// Extension: VK_KHR_deferred_host_operations
// Number: 269
// Type: device
// Author: KHR
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_DEFERRED_HOST_OPERATIONS_SPEC_VERSION
//             Negative: false
//             Value: 4
//         Enum:
//             Name: VK_KHR_DEFERRED_HOST_OPERATIONS_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_deferred_host_operations&quot;
//         Enum:
//             Name: VK_OBJECT_TYPE_DEFERRED_OPERATION_KHR
//             Negative: false
//             Extends: VkObjectType
//             Offset: 0
//         Type:
//             Name: VkDeferredOperationKHR
//         Command:
//             Name: vkCreateDeferredOperationKHR
//         Command:
//             Name: vkDestroyDeferredOperationKHR
//         Command:
//             Name: vkGetDeferredOperationMaxConcurrencyKHR
//         Command:
//             Name: vkGetDeferredOperationResultKHR
//         Command:
//             Name: vkDeferredOperationJoinKHR
//         Enum:
//             Name: VK_THREAD_IDLE_KHR
//             Negative: false
//             Extends: VkResult
//             Offset: 0
//         Enum:
//             Name: VK_THREAD_DONE_KHR
//             Negative: false
//             Extends: VkResult
//             Offset: 1
//         Enum:
//             Name: VK_OPERATION_DEFERRED_KHR
//             Negative: false
//             Extends: VkResult
//             Offset: 2
//         Enum:
//             Name: VK_OPERATION_NOT_DEFERRED_KHR
//             Negative: false
//             Extends: VkResult
//             Offset: 3
// Extension: VK_KHR_pipeline_executable_properties
// Number: 270
// Type: device
// Author: KHR
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_PIPELINE_EXECUTABLE_PROPERTIES_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_PIPELINE_EXECUTABLE_PROPERTIES_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_pipeline_executable_properties&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PIPELINE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_STATISTIC_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 4
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 5
//         Enum:
//             Name: VK_PIPELINE_CREATE_CAPTURE_STATISTICS_BIT_KHR
//             Negative: false
//             Bitpos: 6
//             Extends: VkPipelineCreateFlagBits
//         Enum:
//             Name: VK_PIPELINE_CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR
//             Negative: false
//             Bitpos: 7
//             Extends: VkPipelineCreateFlagBits
//         Type:
//             Name: VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR
//         Type:
//             Name: VkPipelineInfoKHR
//         Type:
//             Name: VkPipelineExecutablePropertiesKHR
//         Type:
//             Name: VkPipelineExecutableInfoKHR
//         Type:
//             Name: VkPipelineExecutableStatisticFormatKHR
//         Type:
//             Name: VkPipelineExecutableStatisticValueKHR
//         Type:
//             Name: VkPipelineExecutableStatisticKHR
//         Type:
//             Name: VkPipelineExecutableInternalRepresentationKHR
//         Command:
//             Name: vkGetPipelineExecutablePropertiesKHR
//         Command:
//             Name: vkGetPipelineExecutableStatisticsKHR
//         Command:
//             Name: vkGetPipelineExecutableInternalRepresentationsKHR
//         Feature:
//             Name: pipelineExecutableInfo
//             Struct: VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR
// Extension: VK_EXT_host_image_copy
// Number: 271
// Type: device
// Author: EXT
// Depends: ((VK_KHR_get_physical_device_properties2,VK_VERSION_1_1)+VK_KHR_copy_commands2+VK_KHR_format_feature_flags2),VK_VERSION_1_3
// Supported: supported
// Promoted to: VK_VERSION_1_4
// Unlocks:
//         Enum:
//             Name: VK_EXT_HOST_IMAGE_COPY_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_HOST_IMAGE_COPY_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_host_image_copy&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_PROPERTIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_PROPERTIES
//         Enum:
//             Name: VK_STRUCTURE_TYPE_MEMORY_TO_IMAGE_COPY_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_MEMORY_TO_IMAGE_COPY
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMAGE_TO_MEMORY_COPY_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_IMAGE_TO_MEMORY_COPY
//         Enum:
//             Name: VK_STRUCTURE_TYPE_COPY_IMAGE_TO_MEMORY_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_COPY_IMAGE_TO_MEMORY_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_COPY_MEMORY_TO_IMAGE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_COPY_MEMORY_TO_IMAGE_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_HOST_IMAGE_LAYOUT_TRANSITION_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_HOST_IMAGE_LAYOUT_TRANSITION_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_COPY_IMAGE_TO_IMAGE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_COPY_IMAGE_TO_IMAGE_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SUBRESOURCE_HOST_MEMCPY_SIZE_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_SUBRESOURCE_HOST_MEMCPY_SIZE
//         Enum:
//             Name: VK_STRUCTURE_TYPE_HOST_IMAGE_COPY_DEVICE_PERFORMANCE_QUERY_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_HOST_IMAGE_COPY_DEVICE_PERFORMANCE_QUERY
//         Enum:
//             Name: VK_IMAGE_USAGE_HOST_TRANSFER_BIT_EXT
//             Negative: false
//             Extends: VkImageUsageFlagBits
//             Alias: VK_IMAGE_USAGE_HOST_TRANSFER_BIT
//             Comment:
//                 Can be used with host image copies
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_HOST_IMAGE_TRANSFER_BIT_EXT
//             Negative: false
//             Extends: VkFormatFeatureFlagBits2
//             Alias: VK_FORMAT_FEATURE_2_HOST_IMAGE_TRANSFER_BIT
//             Comment:
//                 Host image copies are supported
//         Enum:
//             Name: VK_HOST_IMAGE_COPY_MEMCPY_BIT_EXT
//             Negative: false
//             Extends: VkHostImageCopyFlagBits
//             Alias: VK_HOST_IMAGE_COPY_MEMCPY_BIT
//         Enum:
//             Name: VK_HOST_IMAGE_COPY_MEMCPY_EXT
//             Negative: false
//             Extends: VkHostImageCopyFlagBits
//             Alias: VK_HOST_IMAGE_COPY_MEMCPY_BIT
//         Type:
//             Name: VkPhysicalDeviceHostImageCopyFeaturesEXT
//         Type:
//             Name: VkPhysicalDeviceHostImageCopyPropertiesEXT
//         Type:
//             Name: VkHostImageCopyFlagBitsEXT
//         Type:
//             Name: VkHostImageCopyFlagsEXT
//         Type:
//             Name: VkMemoryToImageCopyEXT
//         Type:
//             Name: VkImageToMemoryCopyEXT
//         Type:
//             Name: VkCopyMemoryToImageInfoEXT
//         Type:
//             Name: VkCopyImageToMemoryInfoEXT
//         Type:
//             Name: VkCopyImageToImageInfoEXT
//         Type:
//             Name: VkHostImageLayoutTransitionInfoEXT
//         Type:
//             Name: VkSubresourceHostMemcpySizeEXT
//         Type:
//             Name: VkHostImageCopyDevicePerformanceQueryEXT
//         Command:
//             Name: vkCopyMemoryToImageEXT
//         Command:
//             Name: vkCopyImageToMemoryEXT
//         Command:
//             Name: vkCopyImageToImageEXT
//         Command:
//             Name: vkTransitionImageLayoutEXT
//         Type:
//             Name: VkSubresourceLayout2EXT
//         Type:
//             Name: VkImageSubresource2EXT
//         Command:
//             Name: vkGetImageSubresourceLayout2EXT
//             Comment:
//                 Taken from VK_EXT_image_compression_control. VkStructureType enums defined in that extension
//         Feature:
//             Name: hostImageCopy
//             Struct: VkPhysicalDeviceHostImageCopyFeaturesEXT
// Extension: VK_KHR_map_memory2
// Number: 272
// Type: device
// Author: KHR
// Supported: supported
// Promoted to: VK_VERSION_1_4
// Unlocks:
//         Enum:
//             Name: VK_KHR_MAP_MEMORY_2_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_MAP_MEMORY_2_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_map_memory2&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_MEMORY_MAP_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_MEMORY_MAP_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_MEMORY_UNMAP_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_MEMORY_UNMAP_INFO
//         Type:
//             Name: VkMemoryMapInfoKHR
//         Type:
//             Name: VkMemoryUnmapInfoKHR
//         Type:
//             Name: VkMemoryUnmapFlagBitsKHR
//         Type:
//             Name: VkMemoryUnmapFlagsKHR
//         Command:
//             Name: vkMapMemory2KHR
//         Command:
//             Name: vkUnmapMemory2KHR
// Extension: VK_EXT_map_memory_placed
// Number: 273
// Type: device
// Author: EXT
// Depends: VK_KHR_map_memory2,VK_VERSION_1_4
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_MAP_MEMORY_PLACED_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_MAP_MEMORY_PLACED_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_map_memory_placed&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_PROPERTIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_MEMORY_MAP_PLACED_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_MEMORY_MAP_PLACED_BIT_EXT
//             Negative: false
//             Bitpos: 0
//             Extends: VkMemoryMapFlagBits
//         Enum:
//             Name: VK_MEMORY_UNMAP_RESERVE_BIT_EXT
//             Negative: false
//             Bitpos: 0
//             Extends: VkMemoryUnmapFlagBits
//         Type:
//             Name: VkPhysicalDeviceMapMemoryPlacedFeaturesEXT
//         Type:
//             Name: VkPhysicalDeviceMapMemoryPlacedPropertiesEXT
//         Type:
//             Name: VkMemoryMapPlacedInfoEXT
//         Feature:
//             Name: memoryMapPlaced
//             Struct: VkPhysicalDeviceMapMemoryPlacedFeaturesEXT
// Extension: VK_EXT_shader_atomic_float2
// Number: 274
// Type: device
// Author: EXT
// Depends: VK_EXT_shader_atomic_float
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_SHADER_ATOMIC_FLOAT_2_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_SHADER_ATOMIC_FLOAT_2_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_shader_atomic_float2&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT
//         Feature:
//             Name: shaderBufferFloat16Atomics,shaderBufferFloat16AtomicAdd,shaderBufferFloat16AtomicMinMax,shaderBufferFloat32AtomicMinMax,shaderBufferFloat64AtomicMinMax,shaderSharedFloat16Atomics,shaderSharedFloat16AtomicAdd,shaderSharedFloat16AtomicMinMax,shaderSharedFloat32AtomicMinMax,shaderSharedFloat64AtomicMinMax,shaderImageFloat32AtomicMinMax
//             Struct: VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT
//     Depends: VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT::sparseImageFloat32AtomicMinMax
//         Feature:
//             Name: shaderImageFloat32AtomicMinMax
//             Struct: VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT
// Extension: VK_EXT_surface_maintenance1
// Number: 275
// Type: instance
// Author: EXT
// Depends: VK_KHR_surface+VK_KHR_get_surface_capabilities2
// Supported: supported
// Promoted to: VK_KHR_surface_maintenance1
// Unlocks:
//         Enum:
//             Name: VK_EXT_SURFACE_MAINTENANCE_1_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_SURFACE_MAINTENANCE_1_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_surface_maintenance1&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_KHR
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SURFACE_PRESENT_SCALING_CAPABILITIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_SURFACE_PRESENT_SCALING_CAPABILITIES_KHR
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_COMPATIBILITY_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_COMPATIBILITY_KHR
//         Type:
//             Name: VkSurfacePresentModeEXT
//         Type:
//             Name: VkPresentScalingFlagBitsEXT
//         Type:
//             Name: VkPresentScalingFlagsEXT
//         Type:
//             Name: VkPresentGravityFlagBitsEXT
//         Type:
//             Name: VkPresentGravityFlagsEXT
//         Type:
//             Name: VkSurfacePresentScalingCapabilitiesEXT
//         Type:
//             Name: VkSurfacePresentModeCompatibilityEXT
// Extension: VK_EXT_swapchain_maintenance1
// Number: 276
// Type: device
// Author: EXT
// Depends: VK_KHR_swapchain+VK_EXT_surface_maintenance1+(VK_KHR_get_physical_device_properties2,VK_VERSION_1_1)
// Supported: supported
// Promoted to: VK_KHR_swapchain_maintenance1
// Unlocks:
//         Enum:
//             Name: VK_EXT_SWAPCHAIN_MAINTENANCE_1_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_SWAPCHAIN_MAINTENANCE_1_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_swapchain_maintenance1&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_KHR
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_KHR
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODES_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODES_CREATE_INFO_KHR
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODE_INFO_KHR
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_SCALING_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_SCALING_CREATE_INFO_KHR
//         Enum:
//             Name: VK_STRUCTURE_TYPE_RELEASE_SWAPCHAIN_IMAGES_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_RELEASE_SWAPCHAIN_IMAGES_INFO_KHR
//         Enum:
//             Name: VK_SWAPCHAIN_CREATE_DEFERRED_MEMORY_ALLOCATION_BIT_EXT
//             Negative: false
//             Extends: VkSwapchainCreateFlagBitsKHR
//             Alias: VK_SWAPCHAIN_CREATE_DEFERRED_MEMORY_ALLOCATION_BIT_KHR
//         Type:
//             Name: VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT
//         Type:
//             Name: VkSwapchainPresentFenceInfoEXT
//         Type:
//             Name: VkSwapchainPresentModesCreateInfoEXT
//         Type:
//             Name: VkSwapchainPresentModeInfoEXT
//         Type:
//             Name: VkSwapchainPresentScalingCreateInfoEXT
//         Type:
//             Name: VkReleaseSwapchainImagesInfoEXT
//         Command:
//             Name: vkReleaseSwapchainImagesEXT
//         Feature:
//             Name: swapchainMaintenance1
//             Struct: VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT
// Extension: VK_EXT_shader_demote_to_helper_invocation
// Number: 277
// Type: device
// Author: EXT
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_3
// Unlocks:
//         Enum:
//             Name: VK_EXT_SHADER_DEMOTE_TO_HELPER_INVOCATION_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_SHADER_DEMOTE_TO_HELPER_INVOCATION_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_shader_demote_to_helper_invocation&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES
//         Type:
//             Name: VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT
//         Feature:
//             Name: shaderDemoteToHelperInvocation
//             Struct: VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT
// Extension: VK_NV_device_generated_commands
// Number: 278
// Type: device
// Author: NV
// Depends: (VK_VERSION_1_1+VK_KHR_buffer_device_address),VK_VERSION_1_2
// Supported: supported
// Unlocks:
//         Comment:
//             This extension requires buffer_device_address functionality.
//             VK_EXT_buffer_device_address is also acceptable, but since it is deprecated the KHR version is preferred.
//         Enum:
//             Name: VK_NV_DEVICE_GENERATED_COMMANDS_SPEC_VERSION
//             Negative: false
//             Value: 3
//         Enum:
//             Name: VK_NV_DEVICE_GENERATED_COMMANDS_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_device_generated_commands&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_GRAPHICS_SHADER_GROUP_CREATE_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Enum:
//             Name: VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 4
//         Enum:
//             Name: VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 5
//         Enum:
//             Name: VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 6
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 7
//         Enum:
//             Name: VK_PIPELINE_CREATE_INDIRECT_BINDABLE_BIT_NV
//             Negative: false
//             Bitpos: 18
//             Extends: VkPipelineCreateFlagBits
//         Enum:
//             Name: VK_PIPELINE_STAGE_COMMAND_PREPROCESS_BIT_NV
//             Negative: false
//             Extends: VkPipelineStageFlagBits
//             Alias: VK_PIPELINE_STAGE_COMMAND_PREPROCESS_BIT_EXT
//         Enum:
//             Name: VK_ACCESS_COMMAND_PREPROCESS_READ_BIT_NV
//             Negative: false
//             Extends: VkAccessFlagBits
//             Alias: VK_ACCESS_COMMAND_PREPROCESS_READ_BIT_EXT
//         Enum:
//             Name: VK_ACCESS_COMMAND_PREPROCESS_WRITE_BIT_NV
//             Negative: false
//             Extends: VkAccessFlagBits
//             Alias: VK_ACCESS_COMMAND_PREPROCESS_WRITE_BIT_EXT
//         Enum:
//             Name: VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NV
//             Negative: false
//             Extends: VkObjectType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV
//         Type:
//             Name: VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV
//         Type:
//             Name: VkGraphicsShaderGroupCreateInfoNV
//         Type:
//             Name: VkGraphicsPipelineShaderGroupsCreateInfoNV
//         Type:
//             Name: VkBindShaderGroupIndirectCommandNV
//         Type:
//             Name: VkBindIndexBufferIndirectCommandNV
//         Type:
//             Name: VkBindVertexBufferIndirectCommandNV
//         Type:
//             Name: VkSetStateFlagsIndirectCommandNV
//         Type:
//             Name: VkIndirectStateFlagBitsNV
//         Type:
//             Name: VkIndirectStateFlagsNV
//         Type:
//             Name: VkIndirectCommandsLayoutNV
//         Type:
//             Name: VkIndirectCommandsTokenTypeNV
//         Type:
//             Name: VkIndirectCommandsLayoutUsageFlagBitsNV
//         Type:
//             Name: VkIndirectCommandsLayoutUsageFlagsNV
//         Type:
//             Name: VkIndirectCommandsStreamNV
//         Type:
//             Name: VkIndirectCommandsLayoutTokenNV
//         Type:
//             Name: VkIndirectCommandsLayoutCreateInfoNV
//         Type:
//             Name: VkGeneratedCommandsInfoNV
//         Type:
//             Name: VkGeneratedCommandsMemoryRequirementsInfoNV
//         Command:
//             Name: vkGetGeneratedCommandsMemoryRequirementsNV
//         Command:
//             Name: vkCmdPreprocessGeneratedCommandsNV
//         Command:
//             Name: vkCmdExecuteGeneratedCommandsNV
//         Command:
//             Name: vkCmdBindPipelineShaderGroupNV
//         Command:
//             Name: vkCreateIndirectCommandsLayoutNV
//         Command:
//             Name: vkDestroyIndirectCommandsLayoutNV
//         Feature:
//             Name: deviceGeneratedCommands
//             Struct: VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV
// Extension: VK_NV_inherited_viewport_scissor
// Number: 279
// Type: device
// Author: NV
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NV_INHERITED_VIEWPORT_SCISSOR_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_NV_INHERITED_VIEWPORT_SCISSOR_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_inherited_viewport_scissor&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_VIEWPORT_SCISSOR_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Type:
//             Name: VkPhysicalDeviceInheritedViewportScissorFeaturesNV
//         Type:
//             Name: VkCommandBufferInheritanceViewportScissorInfoNV
//         Feature:
//             Name: inheritedViewportScissor2D
//             Struct: VkPhysicalDeviceInheritedViewportScissorFeaturesNV
// Extension: VK_KHR_extension_280
// Number: 280
// Type: device
// Author: KHR
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_KHR_EXTENSION_280_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_KHR_EXTENSION_280_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_extension_280&quot;
// Extension: VK_KHR_shader_integer_dot_product
// Number: 281
// Type: device
// Author: KHR
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_3
// Unlocks:
//         Enum:
//             Name: VK_KHR_SHADER_INTEGER_DOT_PRODUCT_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_SHADER_INTEGER_DOT_PRODUCT_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_shader_integer_dot_product&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES
//         Type:
//             Name: VkPhysicalDeviceShaderIntegerDotProductFeaturesKHR
//         Type:
//             Name: VkPhysicalDeviceShaderIntegerDotProductPropertiesKHR
//         Feature:
//             Name: shaderIntegerDotProduct
//             Struct: VkPhysicalDeviceShaderIntegerDotProductFeaturesKHR
// Extension: VK_EXT_texel_buffer_alignment
// Number: 282
// Type: device
// Author: EXT
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_3
// Unlocks:
//         Enum:
//             Name: VK_EXT_TEXEL_BUFFER_ALIGNMENT_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_TEXEL_BUFFER_ALIGNMENT_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_texel_buffer_alignment&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//             Comment:
//                 Not promoted to 1.3
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES
//         Type:
//             Name: VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT
//         Type:
//             Name: VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT
//         Feature:
//             Name: texelBufferAlignment
//             Struct: VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT
// Extension: VK_QCOM_render_pass_transform
// Number: 283
// Type: device
// Author: QCOM
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_QCOM_RENDER_PASS_TRANSFORM_SPEC_VERSION
//             Negative: false
//             Value: 5
//         Enum:
//             Name: VK_QCOM_RENDER_PASS_TRANSFORM_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_QCOM_render_pass_transform&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_RENDER_PASS_CREATE_TRANSFORM_BIT_QCOM
//             Negative: false
//             Bitpos: 1
//             Extends: VkRenderPassCreateFlagBits
//         Type:
//             Name: VkRenderPassTransformBeginInfoQCOM
//         Type:
//             Name: VkCommandBufferInheritanceRenderPassTransformInfoQCOM
// Extension: VK_EXT_depth_bias_control
// Number: 284
// Type: device
// Author: EXT
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_DEPTH_BIAS_CONTROL_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_DEPTH_BIAS_CONTROL_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_depth_bias_control&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_BIAS_CONTROL_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DEPTH_BIAS_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DEPTH_BIAS_REPRESENTATION_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Type:
//             Name: VkPhysicalDeviceDepthBiasControlFeaturesEXT
//         Type:
//             Name: VkDepthBiasInfoEXT
//         Type:
//             Name: VkDepthBiasRepresentationEXT
//         Type:
//             Name: VkDepthBiasRepresentationInfoEXT
//         Command:
//             Name: vkCmdSetDepthBias2EXT
//         Feature:
//             Name: depthBiasControl
//             Struct: VkPhysicalDeviceDepthBiasControlFeaturesEXT
// Extension: VK_EXT_device_memory_report
// Number: 285
// Type: device
// Author: EXT
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_DEVICE_MEMORY_REPORT_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_EXT_DEVICE_MEMORY_REPORT_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_device_memory_report&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DEVICE_MEMORY_REPORT_CALLBACK_DATA_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Type:
//             Name: VkPhysicalDeviceDeviceMemoryReportFeaturesEXT
//         Type:
//             Name: VkDeviceDeviceMemoryReportCreateInfoEXT
//         Type:
//             Name: VkDeviceMemoryReportCallbackDataEXT
//         Type:
//             Name: VkDeviceMemoryReportFlagsEXT
//         Type:
//             Name: VkDeviceMemoryReportEventTypeEXT
//         Type:
//             Name: PFN_vkDeviceMemoryReportCallbackEXT
//         Feature:
//             Name: deviceMemoryReport
//             Struct: VkPhysicalDeviceDeviceMemoryReportFeaturesEXT
// Extension: VK_EXT_acquire_drm_display
// Number: 286
// Type: instance
// Author: EXT
// Depends: VK_EXT_direct_mode_display
// Supported: supported
// Comment:
//     codespell:ignore devault
// Unlocks:
//         Enum:
//             Name: VK_EXT_ACQUIRE_DRM_DISPLAY_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_ACQUIRE_DRM_DISPLAY_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_acquire_drm_display&quot;
//         Command:
//             Name: vkAcquireDrmDisplayEXT
//         Command:
//             Name: vkGetDrmDisplayEXT
// Extension: VK_EXT_robustness2
// Number: 287
// Type: device
// Author: EXT
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_KHR_robustness2
// Unlocks:
//         Enum:
//             Name: VK_EXT_ROBUSTNESS_2_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_ROBUSTNESS_2_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_robustness2&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_KHR
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_KHR
//         Type:
//             Name: VkPhysicalDeviceRobustness2FeaturesEXT
//         Type:
//             Name: VkPhysicalDeviceRobustness2PropertiesEXT
//         Feature:
//             Name: robustBufferAccess2,robustImageAccess2,nullDescriptor
//             Struct: VkPhysicalDeviceRobustness2FeaturesEXT
// Extension: VK_EXT_custom_border_color
// Number: 288
// Type: device
// Author: EXT
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_CUSTOM_BORDER_COLOR_SPEC_VERSION
//             Negative: false
//             Value: 12
//         Enum:
//             Name: VK_EXT_CUSTOM_BORDER_COLOR_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_custom_border_color&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_BORDER_COLOR_FLOAT_CUSTOM_EXT
//             Negative: false
//             Extends: VkBorderColor
//             Offset: 3
//         Enum:
//             Name: VK_BORDER_COLOR_INT_CUSTOM_EXT
//             Negative: false
//             Extends: VkBorderColor
//             Offset: 4
//         Type:
//             Name: VkSamplerCustomBorderColorCreateInfoEXT
//         Type:
//             Name: VkPhysicalDeviceCustomBorderColorPropertiesEXT
//         Type:
//             Name: VkPhysicalDeviceCustomBorderColorFeaturesEXT
//         Feature:
//             Name: customBorderColors
//             Struct: VkPhysicalDeviceCustomBorderColorFeaturesEXT
// Extension: VK_EXT_extension_289
// Number: 289
// Type: invalid
// Author: EXT
// Supported: disabled
// Unlocks:
//         Comment:
//             These enums are present only to inform downstream
//             consumers like KTX2. There is no actual Vulkan extension
//             corresponding to the enums.
//         Enum:
//             Name: VK_EXT_EXTENSION_289_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_289_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_289&quot;
//         Enum:
//             Name: VK_FORMAT_ASTC_3x3x3_UNORM_BLOCK_EXT
//             Negative: false
//             Extends: VkFormat
//             Extnumber: 289
//             Offset: 0
//         Enum:
//             Name: VK_FORMAT_ASTC_3x3x3_SRGB_BLOCK_EXT
//             Negative: false
//             Extends: VkFormat
//             Extnumber: 289
//             Offset: 1
//         Enum:
//             Name: VK_FORMAT_ASTC_3x3x3_SFLOAT_BLOCK_EXT
//             Negative: false
//             Extends: VkFormat
//             Extnumber: 289
//             Offset: 2
//         Enum:
//             Name: VK_FORMAT_ASTC_4x3x3_UNORM_BLOCK_EXT
//             Negative: false
//             Extends: VkFormat
//             Extnumber: 289
//             Offset: 3
//         Enum:
//             Name: VK_FORMAT_ASTC_4x3x3_SRGB_BLOCK_EXT
//             Negative: false
//             Extends: VkFormat
//             Extnumber: 289
//             Offset: 4
//         Enum:
//             Name: VK_FORMAT_ASTC_4x3x3_SFLOAT_BLOCK_EXT
//             Negative: false
//             Extends: VkFormat
//             Extnumber: 289
//             Offset: 5
//         Enum:
//             Name: VK_FORMAT_ASTC_4x4x3_UNORM_BLOCK_EXT
//             Negative: false
//             Extends: VkFormat
//             Extnumber: 289
//             Offset: 6
//         Enum:
//             Name: VK_FORMAT_ASTC_4x4x3_SRGB_BLOCK_EXT
//             Negative: false
//             Extends: VkFormat
//             Extnumber: 289
//             Offset: 7
//         Enum:
//             Name: VK_FORMAT_ASTC_4x4x3_SFLOAT_BLOCK_EXT
//             Negative: false
//             Extends: VkFormat
//             Extnumber: 289
//             Offset: 8
//         Enum:
//             Name: VK_FORMAT_ASTC_4x4x4_UNORM_BLOCK_EXT
//             Negative: false
//             Extends: VkFormat
//             Extnumber: 289
//             Offset: 9
//         Enum:
//             Name: VK_FORMAT_ASTC_4x4x4_SRGB_BLOCK_EXT
//             Negative: false
//             Extends: VkFormat
//             Extnumber: 289
//             Offset: 10
//         Enum:
//             Name: VK_FORMAT_ASTC_4x4x4_SFLOAT_BLOCK_EXT
//             Negative: false
//             Extends: VkFormat
//             Extnumber: 289
//             Offset: 11
//         Enum:
//             Name: VK_FORMAT_ASTC_5x4x4_UNORM_BLOCK_EXT
//             Negative: false
//             Extends: VkFormat
//             Extnumber: 289
//             Offset: 12
//         Enum:
//             Name: VK_FORMAT_ASTC_5x4x4_SRGB_BLOCK_EXT
//             Negative: false
//             Extends: VkFormat
//             Extnumber: 289
//             Offset: 13
//         Enum:
//             Name: VK_FORMAT_ASTC_5x4x4_SFLOAT_BLOCK_EXT
//             Negative: false
//             Extends: VkFormat
//             Extnumber: 289
//             Offset: 14
//         Enum:
//             Name: VK_FORMAT_ASTC_5x5x4_UNORM_BLOCK_EXT
//             Negative: false
//             Extends: VkFormat
//             Extnumber: 289
//             Offset: 15
//         Enum:
//             Name: VK_FORMAT_ASTC_5x5x4_SRGB_BLOCK_EXT
//             Negative: false
//             Extends: VkFormat
//             Extnumber: 289
//             Offset: 16
//         Enum:
//             Name: VK_FORMAT_ASTC_5x5x4_SFLOAT_BLOCK_EXT
//             Negative: false
//             Extends: VkFormat
//             Extnumber: 289
//             Offset: 17
//         Enum:
//             Name: VK_FORMAT_ASTC_5x5x5_UNORM_BLOCK_EXT
//             Negative: false
//             Extends: VkFormat
//             Extnumber: 289
//             Offset: 18
//         Enum:
//             Name: VK_FORMAT_ASTC_5x5x5_SRGB_BLOCK_EXT
//             Negative: false
//             Extends: VkFormat
//             Extnumber: 289
//             Offset: 19
//         Enum:
//             Name: VK_FORMAT_ASTC_5x5x5_SFLOAT_BLOCK_EXT
//             Negative: false
//             Extends: VkFormat
//             Extnumber: 289
//             Offset: 20
//         Enum:
//             Name: VK_FORMAT_ASTC_6x5x5_UNORM_BLOCK_EXT
//             Negative: false
//             Extends: VkFormat
//             Extnumber: 289
//             Offset: 21
//         Enum:
//             Name: VK_FORMAT_ASTC_6x5x5_SRGB_BLOCK_EXT
//             Negative: false
//             Extends: VkFormat
//             Extnumber: 289
//             Offset: 22
//         Enum:
//             Name: VK_FORMAT_ASTC_6x5x5_SFLOAT_BLOCK_EXT
//             Negative: false
//             Extends: VkFormat
//             Extnumber: 289
//             Offset: 23
//         Enum:
//             Name: VK_FORMAT_ASTC_6x6x5_UNORM_BLOCK_EXT
//             Negative: false
//             Extends: VkFormat
//             Extnumber: 289
//             Offset: 24
//         Enum:
//             Name: VK_FORMAT_ASTC_6x6x5_SRGB_BLOCK_EXT
//             Negative: false
//             Extends: VkFormat
//             Extnumber: 289
//             Offset: 25
//         Enum:
//             Name: VK_FORMAT_ASTC_6x6x5_SFLOAT_BLOCK_EXT
//             Negative: false
//             Extends: VkFormat
//             Extnumber: 289
//             Offset: 26
//         Enum:
//             Name: VK_FORMAT_ASTC_6x6x6_UNORM_BLOCK_EXT
//             Negative: false
//             Extends: VkFormat
//             Extnumber: 289
//             Offset: 27
//         Enum:
//             Name: VK_FORMAT_ASTC_6x6x6_SRGB_BLOCK_EXT
//             Negative: false
//             Extends: VkFormat
//             Extnumber: 289
//             Offset: 28
//         Enum:
//             Name: VK_FORMAT_ASTC_6x6x6_SFLOAT_BLOCK_EXT
//             Negative: false
//             Extends: VkFormat
//             Extnumber: 289
//             Offset: 29
// Extension: VK_GOOGLE_user_type
// Number: 290
// Type: device
// Author: GOOGLE
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_GOOGLE_USER_TYPE_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_GOOGLE_USER_TYPE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_GOOGLE_user_type&quot;
// Extension: VK_KHR_pipeline_library
// Number: 291
// Type: device
// Author: KHR
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_PIPELINE_LIBRARY_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_PIPELINE_LIBRARY_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_pipeline_library&quot;
//         Enum:
//             Name: VK_PIPELINE_CREATE_LIBRARY_BIT_KHR
//             Negative: false
//             Bitpos: 11
//             Extends: VkPipelineCreateFlagBits
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPipelineLibraryCreateInfoKHR
// Extension: VK_NV_extension_292
// Number: 292
// Type: invalid
// Author: NV
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_NV_EXTENSION_292_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_NV_EXTENSION_292_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_extension_292&quot;
// Extension: VK_NV_present_barrier
// Number: 293
// Type: device
// Author: NV
// Depends: (VK_KHR_get_physical_device_properties2,VK_VERSION_1_1)+VK_KHR_surface+VK_KHR_get_surface_capabilities2+VK_KHR_swapchain
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NV_PRESENT_BARRIER_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_NV_PRESENT_BARRIER_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_present_barrier&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_BARRIER_FEATURES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_BARRIER_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_BARRIER_CREATE_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Type:
//             Name: VkPhysicalDevicePresentBarrierFeaturesNV
//         Type:
//             Name: VkSurfaceCapabilitiesPresentBarrierNV
//         Type:
//             Name: VkSwapchainPresentBarrierCreateInfoNV
//         Feature:
//             Name: presentBarrier
//             Struct: VkPhysicalDevicePresentBarrierFeaturesNV
// Extension: VK_KHR_shader_non_semantic_info
// Number: 294
// Type: device
// Author: KHR
// Supported: supported
// Promoted to: VK_VERSION_1_3
// Unlocks:
//         Enum:
//             Name: VK_KHR_SHADER_NON_SEMANTIC_INFO_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_SHADER_NON_SEMANTIC_INFO_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_shader_non_semantic_info&quot;
// Extension: VK_KHR_present_id
// Number: 295
// Type: device
// Author: KHR
// Depends: VK_KHR_swapchain+VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_PRESENT_ID_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_PRESENT_ID_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_present_id&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PRESENT_ID_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPresentIdKHR
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Type:
//             Name: VkPhysicalDevicePresentIdFeaturesKHR
//         Feature:
//             Name: presentId
//             Struct: VkPhysicalDevicePresentIdFeaturesKHR
// Extension: VK_EXT_private_data
// Number: 296
// Type: device
// Author: NV
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_3
// Unlocks:
//         Enum:
//             Name: VK_EXT_PRIVATE_DATA_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_PRIVATE_DATA_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_private_data&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO
//         Enum:
//             Name: VK_OBJECT_TYPE_PRIVATE_DATA_SLOT_EXT
//             Negative: false
//             Extends: VkObjectType
//             Alias: VK_OBJECT_TYPE_PRIVATE_DATA_SLOT
//         Type:
//             Name: VkPhysicalDevicePrivateDataFeaturesEXT
//         Type:
//             Name: VkDevicePrivateDataCreateInfoEXT
//         Type:
//             Name: VkPrivateDataSlotCreateInfoEXT
//         Type:
//             Name: VkPrivateDataSlotEXT
//         Type:
//             Name: VkPrivateDataSlotCreateFlagsEXT
//         Command:
//             Name: vkCreatePrivateDataSlotEXT
//         Command:
//             Name: vkDestroyPrivateDataSlotEXT
//         Command:
//             Name: vkSetPrivateDataEXT
//         Command:
//             Name: vkGetPrivateDataEXT
//         Feature:
//             Name: privateData
//             Struct: VkPhysicalDevicePrivateDataFeaturesEXT
// Extension: VK_KHR_extension_297
// Number: 297
// Type: invalid
// Author: KHR
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_KHR_EXTENSION_297_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_KHR_EXTENSION_297_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_extension_297&quot;
//         Enum:
//             Name: VK_PIPELINE_SHADER_STAGE_CREATE_RESERVED_3_BIT_KHR
//             Negative: false
//             Bitpos: 3
//             Extends: VkPipelineShaderStageCreateFlagBits
// Extension: VK_EXT_pipeline_creation_cache_control
// Number: 298
// Type: device
// Author: AMD
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_3
// Unlocks:
//         Enum:
//             Name: VK_EXT_PIPELINE_CREATION_CACHE_CONTROL_SPEC_VERSION
//             Negative: false
//             Value: 3
//         Enum:
//             Name: VK_EXT_PIPELINE_CREATION_CACHE_CONTROL_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_pipeline_creation_cache_control&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES
//         Enum:
//             Name: VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT_EXT
//             Negative: false
//             Extends: VkPipelineCreateFlagBits
//             Alias: VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT
//         Enum:
//             Name: VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT_EXT
//             Negative: false
//             Extends: VkPipelineCreateFlagBits
//             Alias: VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT
//         Enum:
//             Name: VK_PIPELINE_COMPILE_REQUIRED_EXT
//             Negative: false
//             Extends: VkResult
//             Alias: VK_PIPELINE_COMPILE_REQUIRED
//         Enum:
//             Name: VK_ERROR_PIPELINE_COMPILE_REQUIRED_EXT
//             Negative: false
//             Extends: VkResult
//             Alias: VK_PIPELINE_COMPILE_REQUIRED
//         Enum:
//             Name: VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT_EXT
//             Negative: false
//             Extends: VkPipelineCacheCreateFlagBits
//             Alias: VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT
//         Type:
//             Name: VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT
//         Type:
//             Name: VkPipelineCacheCreateFlagBits
//         Feature:
//             Name: pipelineCreationCacheControl
//             Struct: VkPhysicalDevicePipelineCreationCacheControlFeatures
// Extension: VK_KHR_extension_299
// Number: 299
// Type: device
// Author: KHR
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_KHR_EXTENSION_299_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_KHR_EXTENSION_299_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_extension_299&quot;
// Extension: VK_KHR_video_encode_queue
// Number: 300
// Type: device
// Author: KHR
// Depends: VK_KHR_video_queue+(VK_KHR_synchronization2,VK_VERSION_1_3)
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_VIDEO_ENCODE_QUEUE_SPEC_VERSION
//             Negative: false
//             Value: 12
//         Enum:
//             Name: VK_KHR_VIDEO_ENCODE_QUEUE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_video_encode_queue&quot;
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_VIDEO_ENCODE_BIT_KHR
//             Negative: false
//             Bitpos: 27
//             Extends: VkPipelineStageFlagBits2
//         Enum:
//             Name: VK_ACCESS_2_VIDEO_ENCODE_READ_BIT_KHR
//             Negative: false
//             Bitpos: 37
//             Extends: VkAccessFlagBits2
//         Enum:
//             Name: VK_ACCESS_2_VIDEO_ENCODE_WRITE_BIT_KHR
//             Negative: false
//             Bitpos: 38
//             Extends: VkAccessFlagBits2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_LAYER_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_CAPABILITIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_USAGE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 4
//         Enum:
//             Name: VK_STRUCTURE_TYPE_QUERY_POOL_VIDEO_ENCODE_FEEDBACK_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 5
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 6
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 7
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 8
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_GET_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 9
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_FEEDBACK_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 10
//         Enum:
//             Name: VK_QUEUE_VIDEO_ENCODE_BIT_KHR
//             Negative: false
//             Bitpos: 6
//             Extends: VkQueueFlagBits
//         Enum:
//             Name: VK_VIDEO_CODING_CONTROL_ENCODE_RATE_CONTROL_BIT_KHR
//             Negative: false
//             Bitpos: 1
//             Extends: VkVideoCodingControlFlagBitsKHR
//         Enum:
//             Name: VK_VIDEO_CODING_CONTROL_ENCODE_QUALITY_LEVEL_BIT_KHR
//             Negative: false
//             Bitpos: 2
//             Extends: VkVideoCodingControlFlagBitsKHR
//         Enum:
//             Name: VK_BUFFER_USAGE_VIDEO_ENCODE_DST_BIT_KHR
//             Negative: false
//             Bitpos: 15
//             Extends: VkBufferUsageFlagBits
//         Enum:
//             Name: VK_BUFFER_USAGE_VIDEO_ENCODE_SRC_BIT_KHR
//             Negative: false
//             Bitpos: 16
//             Extends: VkBufferUsageFlagBits
//         Enum:
//             Name: VK_IMAGE_USAGE_VIDEO_ENCODE_DST_BIT_KHR
//             Negative: false
//             Bitpos: 13
//             Extends: VkImageUsageFlagBits
//         Enum:
//             Name: VK_IMAGE_USAGE_VIDEO_ENCODE_SRC_BIT_KHR
//             Negative: false
//             Bitpos: 14
//             Extends: VkImageUsageFlagBits
//         Enum:
//             Name: VK_IMAGE_USAGE_VIDEO_ENCODE_DPB_BIT_KHR
//             Negative: false
//             Bitpos: 15
//             Extends: VkImageUsageFlagBits
//         Enum:
//             Name: VK_FORMAT_FEATURE_VIDEO_ENCODE_INPUT_BIT_KHR
//             Negative: false
//             Bitpos: 27
//             Extends: VkFormatFeatureFlagBits
//         Enum:
//             Name: VK_FORMAT_FEATURE_VIDEO_ENCODE_DPB_BIT_KHR
//             Negative: false
//             Bitpos: 28
//             Extends: VkFormatFeatureFlagBits
//         Enum:
//             Name: VK_VIDEO_SESSION_CREATE_ALLOW_ENCODE_PARAMETER_OPTIMIZATIONS_BIT_KHR
//             Negative: false
//             Bitpos: 1
//             Extends: VkVideoSessionCreateFlagBitsKHR
//         Enum:
//             Name: VK_IMAGE_LAYOUT_VIDEO_ENCODE_DST_KHR
//             Negative: false
//             Extends: VkImageLayout
//             Offset: 0
//         Enum:
//             Name: VK_IMAGE_LAYOUT_VIDEO_ENCODE_SRC_KHR
//             Negative: false
//             Extends: VkImageLayout
//             Offset: 1
//         Enum:
//             Name: VK_IMAGE_LAYOUT_VIDEO_ENCODE_DPB_KHR
//             Negative: false
//             Extends: VkImageLayout
//             Offset: 2
//         Enum:
//             Name: VK_QUERY_TYPE_VIDEO_ENCODE_FEEDBACK_KHR
//             Negative: false
//             Extends: VkQueryType
//             Offset: 0
//         Enum:
//             Name: VK_QUERY_RESULT_STATUS_INSUFFICIENT_BITSTREAM_BUFFER_RANGE_KHR
//             Negative: true
//             Extends: VkQueryResultStatusKHR
//             Offset: 0
//         Enum:
//             Name: VK_ERROR_INVALID_VIDEO_STD_PARAMETERS_KHR
//             Negative: true
//             Extends: VkResult
//             Offset: 0
//         Type:
//             Name: VkVideoEncodeFlagsKHR
//         Type:
//             Name: VkVideoEncodeInfoKHR
//         Type:
//             Name: VkVideoEncodeCapabilityFlagBitsKHR
//         Type:
//             Name: VkVideoEncodeCapabilityFlagsKHR
//         Type:
//             Name: VkVideoEncodeCapabilitiesKHR
//         Type:
//             Name: VkQueryPoolVideoEncodeFeedbackCreateInfoKHR
//         Type:
//             Name: VkVideoEncodeFeedbackFlagBitsKHR
//         Type:
//             Name: VkVideoEncodeFeedbackFlagsKHR
//         Type:
//             Name: VkVideoEncodeUsageFlagBitsKHR
//         Type:
//             Name: VkVideoEncodeUsageFlagsKHR
//         Type:
//             Name: VkVideoEncodeContentFlagBitsKHR
//         Type:
//             Name: VkVideoEncodeContentFlagsKHR
//         Type:
//             Name: VkVideoEncodeTuningModeKHR
//         Type:
//             Name: VkVideoEncodeUsageInfoKHR
//         Type:
//             Name: VkVideoEncodeRateControlFlagsKHR
//         Type:
//             Name: VkVideoEncodeRateControlModeFlagBitsKHR
//         Type:
//             Name: VkVideoEncodeRateControlModeFlagsKHR
//         Type:
//             Name: VkVideoEncodeRateControlInfoKHR
//         Type:
//             Name: VkVideoEncodeRateControlLayerInfoKHR
//         Type:
//             Name: VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR
//         Type:
//             Name: VkVideoEncodeQualityLevelPropertiesKHR
//         Type:
//             Name: VkVideoEncodeQualityLevelInfoKHR
//         Type:
//             Name: VkVideoEncodeSessionParametersGetInfoKHR
//         Type:
//             Name: VkVideoEncodeSessionParametersFeedbackInfoKHR
//         Command:
//             Name: vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR
//         Command:
//             Name: vkGetEncodedVideoSessionParametersKHR
//         Command:
//             Name: vkCmdEncodeVideoKHR
//     Depends: VK_KHR_format_feature_flags2,VK_VERSION_1_3
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_VIDEO_ENCODE_INPUT_BIT_KHR
//             Negative: false
//             Bitpos: 27
//             Extends: VkFormatFeatureFlagBits2
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_VIDEO_ENCODE_DPB_BIT_KHR
//             Negative: false
//             Bitpos: 28
//             Extends: VkFormatFeatureFlagBits2
// Extension: VK_NV_device_diagnostics_config
// Number: 301
// Type: device
// Author: NV
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NV_DEVICE_DIAGNOSTICS_CONFIG_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_NV_DEVICE_DIAGNOSTICS_CONFIG_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_device_diagnostics_config&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Type:
//             Name: VkPhysicalDeviceDiagnosticsConfigFeaturesNV
//         Type:
//             Name: VkDeviceDiagnosticsConfigCreateInfoNV
//         Type:
//             Name: VkDeviceDiagnosticsConfigFlagsNV
//         Type:
//             Name: VkDeviceDiagnosticsConfigFlagBitsNV
//         Feature:
//             Name: diagnosticsConfig
//             Struct: VkPhysicalDeviceDiagnosticsConfigFeaturesNV
// Extension: VK_QCOM_render_pass_store_ops
// Number: 302
// Type: device
// Author: QCOM
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_QCOM_RENDER_PASS_STORE_OPS_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_QCOM_RENDER_PASS_STORE_OPS_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_QCOM_render_pass_store_ops&quot;
//         Enum:
//             Name: VK_ATTACHMENT_STORE_OP_NONE_QCOM
//             Negative: false
//             Extends: VkAttachmentStoreOp
//             Alias: VK_ATTACHMENT_STORE_OP_NONE
// Extension: VK_QCOM_extension_303
// Number: 303
// Type: invalid
// Author: QCOM
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_QCOM_EXTENSION_303_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_QCOM_EXTENSION_303_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_QCOM_extension_303&quot;
// Extension: VK_QCOM_extension_304
// Number: 304
// Type: invalid
// Author: QCOM
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_QCOM_EXTENSION_304_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_QCOM_EXTENSION_304_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_QCOM_extension_304&quot;
// Extension: VK_QCOM_extension_305
// Number: 305
// Type: invalid
// Author: QCOM
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_QCOM_EXTENSION_305_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_QCOM_EXTENSION_305_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_QCOM_extension_305&quot;
// Extension: VK_QCOM_extension_306
// Number: 306
// Type: invalid
// Author: QCOM
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_QCOM_EXTENSION_306_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_QCOM_EXTENSION_306_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_QCOM_extension_306&quot;
// Extension: VK_QCOM_extension_307
// Number: 307
// Type: invalid
// Author: QCOM
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_QCOM_EXTENSION_307_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_QCOM_EXTENSION_307_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_QCOM_extension_307&quot;
// Extension: VK_NV_cuda_kernel_launch
// Number: 308
// Type: device
// Author: NV
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Platform: provisional
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NV_CUDA_KERNEL_LAUNCH_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_NV_CUDA_KERNEL_LAUNCH_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_cuda_kernel_launch&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_CUDA_MODULE_CREATE_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_CUDA_FUNCTION_CREATE_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_CUDA_LAUNCH_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUDA_KERNEL_LAUNCH_FEATURES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUDA_KERNEL_LAUNCH_PROPERTIES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 4
//         Enum:
//             Name: VK_OBJECT_TYPE_CUDA_MODULE_NV
//             Negative: false
//             Extends: VkObjectType
//             Offset: 0
//         Enum:
//             Name: VK_OBJECT_TYPE_CUDA_FUNCTION_NV
//             Negative: false
//             Extends: VkObjectType
//             Offset: 1
//         Type:
//             Name: VkCudaModuleNV
//         Type:
//             Name: VkCudaFunctionNV
//         Type:
//             Name: VkCudaModuleCreateInfoNV
//         Type:
//             Name: VkCudaFunctionCreateInfoNV
//         Type:
//             Name: VkCudaLaunchInfoNV
//         Type:
//             Name: VkPhysicalDeviceCudaKernelLaunchFeaturesNV
//         Type:
//             Name: VkPhysicalDeviceCudaKernelLaunchPropertiesNV
//         Command:
//             Name: vkCreateCudaModuleNV
//         Command:
//             Name: vkGetCudaModuleCacheNV
//         Command:
//             Name: vkCreateCudaFunctionNV
//         Command:
//             Name: vkDestroyCudaModuleNV
//         Command:
//             Name: vkDestroyCudaFunctionNV
//         Command:
//             Name: vkCmdCudaLaunchKernelNV
//         Feature:
//             Name: cudaKernelLaunchFeatures
//             Struct: VkPhysicalDeviceCudaKernelLaunchFeaturesNV
//     Depends: VK_EXT_debug_report
//         Enum:
//             Name: VK_DEBUG_REPORT_OBJECT_TYPE_CUDA_MODULE_NV_EXT
//             Negative: false
//             Extends: VkDebugReportObjectTypeEXT
//             Offset: 0
//         Enum:
//             Name: VK_DEBUG_REPORT_OBJECT_TYPE_CUDA_FUNCTION_NV_EXT
//             Negative: false
//             Extends: VkDebugReportObjectTypeEXT
//             Offset: 1
// Extension: VK_KHR_object_refresh
// Number: 309
// Type: device
// Author: KHR
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_OBJECT_REFRESH_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_OBJECT_REFRESH_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_object_refresh&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_REFRESH_OBJECT_LIST_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkRefreshObjectListKHR
//         Type:
//             Name: VkRefreshObjectKHR
//         Type:
//             Name: VkRefreshObjectFlagBitsKHR
//         Type:
//             Name: VkRefreshObjectFlagsKHR
//         Command:
//             Name: vkCmdRefreshObjectsKHR
//         Command:
//             Name: vkGetPhysicalDeviceRefreshableObjectTypesKHR
// Extension: VK_QCOM_tile_shading
// Number: 310
// Type: device
// Author: QCOM
// Depends: VK_QCOM_tile_properties,VK_KHR_get_physical_device_properties2
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_QCOM_TILE_SHADING_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_QCOM_TILE_SHADING_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_QCOM_tile_shading&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_SHADING_FEATURES_QCOM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_SHADING_PROPERTIES_QCOM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_RENDER_PASS_TILE_SHADING_CREATE_INFO_QCOM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PER_TILE_BEGIN_INFO_QCOM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PER_TILE_END_INFO_QCOM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 4
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DISPATCH_TILE_INFO_QCOM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 5
//         Enum:
//             Name: VK_ACCESS_2_SHADER_TILE_ATTACHMENT_READ_BIT_QCOM
//             Negative: false
//             Bitpos: 51
//             Extends: VkAccessFlagBits2
//         Enum:
//             Name: VK_ACCESS_2_SHADER_TILE_ATTACHMENT_WRITE_BIT_QCOM
//             Negative: false
//             Bitpos: 52
//             Extends: VkAccessFlagBits2
//         Enum:
//             Name: VK_SUBPASS_DESCRIPTION_TILE_SHADING_APRON_BIT_QCOM
//             Negative: false
//             Bitpos: 8
//             Extends: VkSubpassDescriptionFlagBits
//         Type:
//             Name: VkPhysicalDeviceTileShadingFeaturesQCOM
//         Type:
//             Name: VkPhysicalDeviceTileShadingPropertiesQCOM
//         Type:
//             Name: VkRenderPassTileShadingCreateInfoQCOM
//         Type:
//             Name: VkPerTileBeginInfoQCOM
//         Type:
//             Name: VkPerTileEndInfoQCOM
//         Type:
//             Name: VkDispatchTileInfoQCOM
//         Type:
//             Name: VkTileShadingRenderPassFlagsQCOM
//         Type:
//             Name: VkTileShadingRenderPassFlagBitsQCOM
//         Command:
//             Name: vkCmdDispatchTileQCOM
//         Command:
//             Name: vkCmdBeginPerTileExecutionQCOM
//         Command:
//             Name: vkCmdEndPerTileExecutionQCOM
//         Feature:
//             Name: tileShading
//             Struct: VkPhysicalDeviceTileShadingFeaturesQCOM
//         Feature:
//             Name: tileShadingFragmentStage
//             Struct: VkPhysicalDeviceTileShadingFeaturesQCOM
//         Feature:
//             Name: tileShadingPerTileDispatch
//             Struct: VkPhysicalDeviceTileShadingFeaturesQCOM
//         Feature:
//             Name: tileShadingAtomicOps
//             Struct: VkPhysicalDeviceTileShadingFeaturesQCOM
//         Feature:
//             Name: tileShadingColorAttachments
//             Struct: VkPhysicalDeviceTileShadingFeaturesQCOM
//         Feature:
//             Name: tileShadingPerTileDraw
//             Struct: VkPhysicalDeviceTileShadingFeaturesQCOM
//         Feature:
//             Name: tileShadingDepthAttachments
//             Struct: VkPhysicalDeviceTileShadingFeaturesQCOM
//         Feature:
//             Name: tileShadingStencilAttachments
//             Struct: VkPhysicalDeviceTileShadingFeaturesQCOM
//         Feature:
//             Name: tileShadingInputAttachments
//             Struct: VkPhysicalDeviceTileShadingFeaturesQCOM
//         Feature:
//             Name: tileShadingSampledAttachments
//             Struct: VkPhysicalDeviceTileShadingFeaturesQCOM
// Extension: VK_NV_low_latency
// Number: 311
// Type: device
// Author: NV
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NV_LOW_LATENCY_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_NV_LOW_LATENCY_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_low_latency&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_QUERY_LOW_LATENCY_SUPPORT_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkQueryLowLatencySupportNV
// Extension: VK_EXT_metal_objects
// Number: 312
// Type: device
// Author: EXT
// Platform: metal
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_METAL_OBJECTS_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_EXT_METAL_OBJECTS_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_metal_objects&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECTS_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_EXPORT_METAL_DEVICE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_EXPORT_METAL_COMMAND_QUEUE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Enum:
//             Name: VK_STRUCTURE_TYPE_EXPORT_METAL_BUFFER_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 4
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMPORT_METAL_BUFFER_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 5
//         Enum:
//             Name: VK_STRUCTURE_TYPE_EXPORT_METAL_TEXTURE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 6
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMPORT_METAL_TEXTURE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 7
//         Enum:
//             Name: VK_STRUCTURE_TYPE_EXPORT_METAL_IO_SURFACE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 8
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMPORT_METAL_IO_SURFACE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 9
//         Enum:
//             Name: VK_STRUCTURE_TYPE_EXPORT_METAL_SHARED_EVENT_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 10
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMPORT_METAL_SHARED_EVENT_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 11
//         Type:
//             Name: VkExportMetalObjectTypeFlagBitsEXT
//         Type:
//             Name: VkExportMetalObjectTypeFlagsEXT
//         Type:
//             Name: VkExportMetalObjectCreateInfoEXT
//         Type:
//             Name: VkExportMetalObjectsInfoEXT
//         Type:
//             Name: VkExportMetalDeviceInfoEXT
//         Type:
//             Name: VkExportMetalCommandQueueInfoEXT
//         Type:
//             Name: VkExportMetalBufferInfoEXT
//         Type:
//             Name: VkImportMetalBufferInfoEXT
//         Type:
//             Name: VkExportMetalTextureInfoEXT
//         Type:
//             Name: VkImportMetalTextureInfoEXT
//         Type:
//             Name: VkExportMetalIOSurfaceInfoEXT
//         Type:
//             Name: VkImportMetalIOSurfaceInfoEXT
//         Type:
//             Name: VkExportMetalSharedEventInfoEXT
//         Type:
//             Name: VkImportMetalSharedEventInfoEXT
//         Type:
//             Name: MTLDevice_id
//         Type:
//             Name: MTLCommandQueue_id
//         Type:
//             Name: MTLBuffer_id
//         Type:
//             Name: MTLTexture_id
//         Type:
//             Name: MTLSharedEvent_id
//         Type:
//             Name: IOSurfaceRef
//         Command:
//             Name: vkExportMetalObjectsEXT
// Extension: VK_EXT_extension_313
// Number: 313
// Type: invalid
// Author: MVK
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_313_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_313_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_313&quot;
// Extension: VK_AMD_extension_314
// Number: 314
// Type: invalid
// Author: AMD
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_AMD_EXTENSION_314_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_AMD_EXTENSION_314_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_extension_314&quot;
// Extension: VK_KHR_synchronization2
// Number: 315
// Type: device
// Author: KHR
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_3
// Unlocks:
//         Enum:
//             Name: VK_KHR_SYNCHRONIZATION_2_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_SYNCHRONIZATION_2_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_synchronization2&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_MEMORY_BARRIER_2_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_MEMORY_BARRIER_2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DEPENDENCY_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_DEPENDENCY_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SUBMIT_INFO_2_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_SUBMIT_INFO_2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES
//         Enum:
//             Name: VK_EVENT_CREATE_DEVICE_ONLY_BIT_KHR
//             Negative: false
//             Extends: VkEventCreateFlagBits
//             Alias: VK_EVENT_CREATE_DEVICE_ONLY_BIT
//         Enum:
//             Name: VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL_KHR
//             Negative: false
//             Extends: VkImageLayout
//             Alias: VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL
//         Enum:
//             Name: VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL_KHR
//             Negative: false
//             Extends: VkImageLayout
//             Alias: VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL
//         Enum:
//             Name: VK_PIPELINE_STAGE_NONE_KHR
//             Negative: false
//             Extends: VkPipelineStageFlagBits
//             Alias: VK_PIPELINE_STAGE_NONE
//         Enum:
//             Name: VK_ACCESS_NONE_KHR
//             Negative: false
//             Extends: VkAccessFlagBits
//             Alias: VK_ACCESS_NONE
//         Enum:
//             Name: VK_ACCESS_2_NONE_KHR
//             Negative: false
//             Extends: VkAccessFlagBits2
//             Alias: VK_ACCESS_2_NONE
//         Enum:
//             Name: VK_ACCESS_2_INDIRECT_COMMAND_READ_BIT_KHR
//             Negative: false
//             Extends: VkAccessFlagBits2
//             Alias: VK_ACCESS_2_INDIRECT_COMMAND_READ_BIT
//         Enum:
//             Name: VK_ACCESS_2_INDEX_READ_BIT_KHR
//             Negative: false
//             Extends: VkAccessFlagBits2
//             Alias: VK_ACCESS_2_INDEX_READ_BIT
//         Enum:
//             Name: VK_ACCESS_2_VERTEX_ATTRIBUTE_READ_BIT_KHR
//             Negative: false
//             Extends: VkAccessFlagBits2
//             Alias: VK_ACCESS_2_VERTEX_ATTRIBUTE_READ_BIT
//         Enum:
//             Name: VK_ACCESS_2_UNIFORM_READ_BIT_KHR
//             Negative: false
//             Extends: VkAccessFlagBits2
//             Alias: VK_ACCESS_2_UNIFORM_READ_BIT
//         Enum:
//             Name: VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT_KHR
//             Negative: false
//             Extends: VkAccessFlagBits2
//             Alias: VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT
//         Enum:
//             Name: VK_ACCESS_2_SHADER_READ_BIT_KHR
//             Negative: false
//             Extends: VkAccessFlagBits2
//             Alias: VK_ACCESS_2_SHADER_READ_BIT
//         Enum:
//             Name: VK_ACCESS_2_SHADER_WRITE_BIT_KHR
//             Negative: false
//             Extends: VkAccessFlagBits2
//             Alias: VK_ACCESS_2_SHADER_WRITE_BIT
//         Enum:
//             Name: VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT_KHR
//             Negative: false
//             Extends: VkAccessFlagBits2
//             Alias: VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT
//         Enum:
//             Name: VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT_KHR
//             Negative: false
//             Extends: VkAccessFlagBits2
//             Alias: VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT
//         Enum:
//             Name: VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT_KHR
//             Negative: false
//             Extends: VkAccessFlagBits2
//             Alias: VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT
//         Enum:
//             Name: VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT_KHR
//             Negative: false
//             Extends: VkAccessFlagBits2
//             Alias: VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT
//         Enum:
//             Name: VK_ACCESS_2_TRANSFER_READ_BIT_KHR
//             Negative: false
//             Extends: VkAccessFlagBits2
//             Alias: VK_ACCESS_2_TRANSFER_READ_BIT
//         Enum:
//             Name: VK_ACCESS_2_TRANSFER_WRITE_BIT_KHR
//             Negative: false
//             Extends: VkAccessFlagBits2
//             Alias: VK_ACCESS_2_TRANSFER_WRITE_BIT
//         Enum:
//             Name: VK_ACCESS_2_HOST_READ_BIT_KHR
//             Negative: false
//             Extends: VkAccessFlagBits2
//             Alias: VK_ACCESS_2_HOST_READ_BIT
//         Enum:
//             Name: VK_ACCESS_2_HOST_WRITE_BIT_KHR
//             Negative: false
//             Extends: VkAccessFlagBits2
//             Alias: VK_ACCESS_2_HOST_WRITE_BIT
//         Enum:
//             Name: VK_ACCESS_2_MEMORY_READ_BIT_KHR
//             Negative: false
//             Extends: VkAccessFlagBits2
//             Alias: VK_ACCESS_2_MEMORY_READ_BIT
//         Enum:
//             Name: VK_ACCESS_2_MEMORY_WRITE_BIT_KHR
//             Negative: false
//             Extends: VkAccessFlagBits2
//             Alias: VK_ACCESS_2_MEMORY_WRITE_BIT
//         Enum:
//             Name: VK_ACCESS_2_SHADER_SAMPLED_READ_BIT_KHR
//             Negative: false
//             Extends: VkAccessFlagBits2
//             Alias: VK_ACCESS_2_SHADER_SAMPLED_READ_BIT
//         Enum:
//             Name: VK_ACCESS_2_SHADER_STORAGE_READ_BIT_KHR
//             Negative: false
//             Extends: VkAccessFlagBits2
//             Alias: VK_ACCESS_2_SHADER_STORAGE_READ_BIT
//         Enum:
//             Name: VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT_KHR
//             Negative: false
//             Extends: VkAccessFlagBits2
//             Alias: VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_NONE_KHR
//             Negative: false
//             Extends: VkPipelineStageFlagBits2
//             Alias: VK_PIPELINE_STAGE_2_NONE
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_TOP_OF_PIPE_BIT_KHR
//             Negative: false
//             Extends: VkPipelineStageFlagBits2
//             Alias: VK_PIPELINE_STAGE_2_TOP_OF_PIPE_BIT
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT_KHR
//             Negative: false
//             Extends: VkPipelineStageFlagBits2
//             Alias: VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT_KHR
//             Negative: false
//             Extends: VkPipelineStageFlagBits2
//             Alias: VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT_KHR
//             Negative: false
//             Extends: VkPipelineStageFlagBits2
//             Alias: VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT_KHR
//             Negative: false
//             Extends: VkPipelineStageFlagBits2
//             Alias: VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT_KHR
//             Negative: false
//             Extends: VkPipelineStageFlagBits2
//             Alias: VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT_KHR
//             Negative: false
//             Extends: VkPipelineStageFlagBits2
//             Alias: VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT_KHR
//             Negative: false
//             Extends: VkPipelineStageFlagBits2
//             Alias: VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT_KHR
//             Negative: false
//             Extends: VkPipelineStageFlagBits2
//             Alias: VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT_KHR
//             Negative: false
//             Extends: VkPipelineStageFlagBits2
//             Alias: VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT_KHR
//             Negative: false
//             Extends: VkPipelineStageFlagBits2
//             Alias: VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT_KHR
//             Negative: false
//             Extends: VkPipelineStageFlagBits2
//             Alias: VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT_KHR
//             Negative: false
//             Extends: VkPipelineStageFlagBits2
//             Alias: VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_TRANSFER_BIT_KHR
//             Negative: false
//             Extends: VkPipelineStageFlagBits2
//             Alias: VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_BOTTOM_OF_PIPE_BIT_KHR
//             Negative: false
//             Extends: VkPipelineStageFlagBits2
//             Alias: VK_PIPELINE_STAGE_2_BOTTOM_OF_PIPE_BIT
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_HOST_BIT_KHR
//             Negative: false
//             Extends: VkPipelineStageFlagBits2
//             Alias: VK_PIPELINE_STAGE_2_HOST_BIT
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT_KHR
//             Negative: false
//             Extends: VkPipelineStageFlagBits2
//             Alias: VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT_KHR
//             Negative: false
//             Extends: VkPipelineStageFlagBits2
//             Alias: VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_COPY_BIT_KHR
//             Negative: false
//             Extends: VkPipelineStageFlagBits2
//             Alias: VK_PIPELINE_STAGE_2_COPY_BIT
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_RESOLVE_BIT_KHR
//             Negative: false
//             Extends: VkPipelineStageFlagBits2
//             Alias: VK_PIPELINE_STAGE_2_RESOLVE_BIT
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_BLIT_BIT_KHR
//             Negative: false
//             Extends: VkPipelineStageFlagBits2
//             Alias: VK_PIPELINE_STAGE_2_BLIT_BIT
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_CLEAR_BIT_KHR
//             Negative: false
//             Extends: VkPipelineStageFlagBits2
//             Alias: VK_PIPELINE_STAGE_2_CLEAR_BIT
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT_KHR
//             Negative: false
//             Extends: VkPipelineStageFlagBits2
//             Alias: VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT_KHR
//             Negative: false
//             Extends: VkPipelineStageFlagBits2
//             Alias: VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_PRE_RASTERIZATION_SHADERS_BIT_KHR
//             Negative: false
//             Extends: VkPipelineStageFlagBits2
//             Alias: VK_PIPELINE_STAGE_2_PRE_RASTERIZATION_SHADERS_BIT
//         Enum:
//             Name: VK_SUBMIT_PROTECTED_BIT_KHR
//             Negative: false
//             Extends: VkSubmitFlagBits
//             Alias: VK_SUBMIT_PROTECTED_BIT
//         Type:
//             Name: VkFlags64
//         Type:
//             Name: VkPipelineStageFlags2KHR
//         Type:
//             Name: VkPipelineStageFlagBits2KHR
//         Type:
//             Name: VkAccessFlags2KHR
//         Type:
//             Name: VkAccessFlagBits2KHR
//         Type:
//             Name: VkMemoryBarrier2KHR
//         Type:
//             Name: VkBufferMemoryBarrier2KHR
//         Type:
//             Name: VkImageMemoryBarrier2KHR
//         Type:
//             Name: VkDependencyInfoKHR
//         Type:
//             Name: VkSubmitInfo2KHR
//         Type:
//             Name: VkSemaphoreSubmitInfoKHR
//         Type:
//             Name: VkCommandBufferSubmitInfoKHR
//         Type:
//             Name: VkSubmitFlagBitsKHR
//         Type:
//             Name: VkSubmitFlagsKHR
//         Type:
//             Name: VkPhysicalDeviceSynchronization2FeaturesKHR
//         Command:
//             Name: vkCmdSetEvent2KHR
//         Command:
//             Name: vkCmdResetEvent2KHR
//         Command:
//             Name: vkCmdWaitEvents2KHR
//         Command:
//             Name: vkCmdPipelineBarrier2KHR
//         Command:
//             Name: vkCmdWriteTimestamp2KHR
//         Command:
//             Name: vkQueueSubmit2KHR
//         Feature:
//             Name: synchronization2
//             Struct: VkPhysicalDeviceSynchronization2FeaturesKHR
//     Depends: VK_EXT_transform_feedback
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT
//             Negative: false
//             Bitpos: 24
//             Extends: VkPipelineStageFlagBits2
//         Enum:
//             Name: VK_ACCESS_2_TRANSFORM_FEEDBACK_WRITE_BIT_EXT
//             Negative: false
//             Bitpos: 25
//             Extends: VkAccessFlagBits2
//         Enum:
//             Name: VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT
//             Negative: false
//             Bitpos: 26
//             Extends: VkAccessFlagBits2
//         Enum:
//             Name: VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT
//             Negative: false
//             Bitpos: 27
//             Extends: VkAccessFlagBits2
//     Depends: VK_EXT_conditional_rendering
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT
//             Negative: false
//             Bitpos: 18
//             Extends: VkPipelineStageFlagBits2
//             Comment:
//                 A pipeline stage for conditional rendering predicate fetch
//         Enum:
//             Name: VK_ACCESS_2_CONDITIONAL_RENDERING_READ_BIT_EXT
//             Negative: false
//             Bitpos: 20
//             Extends: VkAccessFlagBits2
//             Comment:
//                 read access flag for reading conditional rendering predicate
//     Depends: VK_NV_device_generated_commands
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_NV
//             Negative: false
//             Extends: VkPipelineStageFlagBits2
//             Alias: VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_EXT
//         Enum:
//             Name: VK_ACCESS_2_COMMAND_PREPROCESS_READ_BIT_NV
//             Negative: false
//             Extends: VkAccessFlagBits2
//             Alias: VK_ACCESS_2_COMMAND_PREPROCESS_READ_BIT_EXT
//         Enum:
//             Name: VK_ACCESS_2_COMMAND_PREPROCESS_WRITE_BIT_NV
//             Negative: false
//             Extends: VkAccessFlagBits2
//             Alias: VK_ACCESS_2_COMMAND_PREPROCESS_WRITE_BIT_EXT
//     Depends: VK_EXT_device_generated_commands
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_EXT
//             Negative: false
//             Bitpos: 17
//             Extends: VkPipelineStageFlagBits2
//         Enum:
//             Name: VK_ACCESS_2_COMMAND_PREPROCESS_READ_BIT_EXT
//             Negative: false
//             Bitpos: 17
//             Extends: VkAccessFlagBits2
//         Enum:
//             Name: VK_ACCESS_2_COMMAND_PREPROCESS_WRITE_BIT_EXT
//             Negative: false
//             Bitpos: 18
//             Extends: VkAccessFlagBits2
//     Depends: VK_KHR_fragment_shading_rate
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR
//             Negative: false
//             Bitpos: 22
//             Extends: VkPipelineStageFlagBits2
//         Enum:
//             Name: VK_ACCESS_2_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR
//             Negative: false
//             Bitpos: 23
//             Extends: VkAccessFlagBits2
//     Depends: VK_NV_shading_rate_image
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_SHADING_RATE_IMAGE_BIT_NV
//             Negative: false
//             Extends: VkPipelineStageFlagBits2
//             Alias: VK_PIPELINE_STAGE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR
//         Enum:
//             Name: VK_ACCESS_2_SHADING_RATE_IMAGE_READ_BIT_NV
//             Negative: false
//             Extends: VkAccessFlagBits2
//             Alias: VK_ACCESS_2_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR
//     Depends: VK_KHR_acceleration_structure
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR
//             Negative: false
//             Bitpos: 25
//             Extends: VkPipelineStageFlagBits2
//         Enum:
//             Name: VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_KHR
//             Negative: false
//             Bitpos: 21
//             Extends: VkAccessFlagBits2
//         Enum:
//             Name: VK_ACCESS_2_ACCELERATION_STRUCTURE_WRITE_BIT_KHR
//             Negative: false
//             Bitpos: 22
//             Extends: VkAccessFlagBits2
//     Depends: VK_KHR_ray_tracing_pipeline
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR
//             Negative: false
//             Bitpos: 21
//             Extends: VkPipelineStageFlagBits2
//     Depends: VK_NV_ray_tracing
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_NV
//             Negative: false
//             Extends: VkPipelineStageFlagBits2
//             Alias: VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_NV
//             Negative: false
//             Extends: VkPipelineStageFlagBits2
//             Alias: VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR
//         Enum:
//             Name: VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_NV
//             Negative: false
//             Extends: VkAccessFlagBits2
//             Alias: VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_KHR
//         Enum:
//             Name: VK_ACCESS_2_ACCELERATION_STRUCTURE_WRITE_BIT_NV
//             Negative: false
//             Extends: VkAccessFlagBits2
//             Alias: VK_ACCESS_2_ACCELERATION_STRUCTURE_WRITE_BIT_KHR
//     Depends: VK_EXT_fragment_density_map
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_FRAGMENT_DENSITY_PROCESS_BIT_EXT
//             Negative: false
//             Bitpos: 23
//             Extends: VkPipelineStageFlagBits2
//         Enum:
//             Name: VK_ACCESS_2_FRAGMENT_DENSITY_MAP_READ_BIT_EXT
//             Negative: false
//             Bitpos: 24
//             Extends: VkAccessFlagBits2
//     Depends: VK_EXT_blend_operation_advanced
//         Enum:
//             Name: VK_ACCESS_2_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT
//             Negative: false
//             Bitpos: 19
//             Extends: VkAccessFlagBits2
//     Depends: VK_NV_mesh_shader
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_NV
//             Negative: false
//             Extends: VkPipelineStageFlagBits2
//             Alias: VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_EXT
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_NV
//             Negative: false
//             Extends: VkPipelineStageFlagBits2
//             Alias: VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_EXT
//     Depends: VK_EXT_mesh_shader
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_EXT
//             Negative: false
//             Bitpos: 19
//             Extends: VkPipelineStageFlagBits2
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_EXT
//             Negative: false
//             Bitpos: 20
//             Extends: VkPipelineStageFlagBits2
// Extension: VK_AMD_extension_316
// Number: 316
// Type: invalid
// Author: AMD
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_AMD_EXTENSION_316_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_AMD_EXTENSION_316_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_extension_316&quot;
// Extension: VK_EXT_descriptor_buffer
// Number: 317
// Type: device
// Author: EXT
// Depends: ((((VK_KHR_get_physical_device_properties2,VK_VERSION_1_1)+VK_KHR_buffer_device_address+VK_EXT_descriptor_indexing),VK_VERSION_1_2)+VK_KHR_synchronization2),VK_VERSION_1_3
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_DESCRIPTOR_BUFFER_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_DESCRIPTOR_BUFFER_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_descriptor_buffer&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_PROPERTIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_DENSITY_MAP_PROPERTIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DESCRIPTOR_ADDRESS_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DESCRIPTOR_GET_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 4
//         Enum:
//             Name: VK_STRUCTURE_TYPE_BUFFER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 5
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMAGE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 6
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMAGE_VIEW_CAPTURE_DESCRIPTOR_DATA_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 7
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SAMPLER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 8
//         Enum:
//             Name: VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 10
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 11
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_PUSH_DESCRIPTOR_BUFFER_HANDLE_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 12
//         Enum:
//             Name: VK_DESCRIPTOR_SET_LAYOUT_CREATE_DESCRIPTOR_BUFFER_BIT_EXT
//             Negative: false
//             Bitpos: 4
//             Extends: VkDescriptorSetLayoutCreateFlagBits
//         Enum:
//             Name: VK_DESCRIPTOR_SET_LAYOUT_CREATE_EMBEDDED_IMMUTABLE_SAMPLERS_BIT_EXT
//             Negative: false
//             Bitpos: 5
//             Extends: VkDescriptorSetLayoutCreateFlagBits
//         Enum:
//             Name: VK_BUFFER_USAGE_SAMPLER_DESCRIPTOR_BUFFER_BIT_EXT
//             Negative: false
//             Bitpos: 21
//             Extends: VkBufferUsageFlagBits
//         Enum:
//             Name: VK_BUFFER_USAGE_RESOURCE_DESCRIPTOR_BUFFER_BIT_EXT
//             Negative: false
//             Bitpos: 22
//             Extends: VkBufferUsageFlagBits
//         Enum:
//             Name: VK_BUFFER_USAGE_PUSH_DESCRIPTORS_DESCRIPTOR_BUFFER_BIT_EXT
//             Negative: false
//             Bitpos: 26
//             Extends: VkBufferUsageFlagBits
//         Enum:
//             Name: VK_BUFFER_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT
//             Negative: false
//             Bitpos: 5
//             Extends: VkBufferCreateFlagBits
//         Enum:
//             Name: VK_IMAGE_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT
//             Negative: false
//             Bitpos: 16
//             Extends: VkImageCreateFlagBits
//         Enum:
//             Name: VK_IMAGE_VIEW_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT
//             Negative: false
//             Bitpos: 2
//             Extends: VkImageViewCreateFlagBits
//         Enum:
//             Name: VK_SAMPLER_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT
//             Negative: false
//             Bitpos: 3
//             Extends: VkSamplerCreateFlagBits
//         Enum:
//             Name: VK_ACCELERATION_STRUCTURE_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT
//             Negative: false
//             Bitpos: 3
//             Extends: VkAccelerationStructureCreateFlagBitsKHR
//         Enum:
//             Name: VK_ACCESS_2_DESCRIPTOR_BUFFER_READ_BIT_EXT
//             Negative: false
//             Bitpos: 41
//             Extends: VkAccessFlagBits2
//         Enum:
//             Name: VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT
//             Negative: false
//             Bitpos: 29
//             Extends: VkPipelineCreateFlagBits
//         Type:
//             Name: VkPhysicalDeviceDescriptorBufferPropertiesEXT
//         Type:
//             Name: VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT
//         Type:
//             Name: VkPhysicalDeviceDescriptorBufferFeaturesEXT
//         Type:
//             Name: VkDescriptorAddressInfoEXT
//         Type:
//             Name: VkDescriptorBufferBindingInfoEXT
//         Type:
//             Name: VkDescriptorBufferBindingPushDescriptorBufferHandleEXT
//         Type:
//             Name: VkDescriptorDataEXT
//         Type:
//             Name: VkDescriptorGetInfoEXT
//         Type:
//             Name: VkBufferCaptureDescriptorDataInfoEXT
//         Type:
//             Name: VkImageCaptureDescriptorDataInfoEXT
//         Type:
//             Name: VkImageViewCaptureDescriptorDataInfoEXT
//         Type:
//             Name: VkSamplerCaptureDescriptorDataInfoEXT
//         Type:
//             Name: VkOpaqueCaptureDescriptorDataCreateInfoEXT
//         Command:
//             Name: vkGetDescriptorSetLayoutSizeEXT
//         Command:
//             Name: vkGetDescriptorSetLayoutBindingOffsetEXT
//         Command:
//             Name: vkGetDescriptorEXT
//         Command:
//             Name: vkCmdBindDescriptorBuffersEXT
//         Command:
//             Name: vkCmdSetDescriptorBufferOffsetsEXT
//         Command:
//             Name: vkCmdBindDescriptorBufferEmbeddedSamplersEXT
//         Command:
//             Name: vkGetBufferOpaqueCaptureDescriptorDataEXT
//         Command:
//             Name: vkGetImageOpaqueCaptureDescriptorDataEXT
//         Command:
//             Name: vkGetImageViewOpaqueCaptureDescriptorDataEXT
//         Command:
//             Name: vkGetSamplerOpaqueCaptureDescriptorDataEXT
//         Feature:
//             Name: descriptorBuffer
//             Struct: VkPhysicalDeviceDescriptorBufferFeaturesEXT
//     Depends: VK_KHR_acceleration_structure,VK_NV_ray_tracing
//         Enum:
//             Name: VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 9
//         Type:
//             Name: VkAccelerationStructureCaptureDescriptorDataInfoEXT
//         Command:
//             Name: vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT
// Extension: VK_AMD_extension_318
// Number: 318
// Type: invalid
// Author: AMD
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_AMD_EXTENSION_318_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_AMD_EXTENSION_318_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_extension_318&quot;
// Extension: VK_AMD_extension_319
// Number: 319
// Type: invalid
// Author: AMD
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_AMD_EXTENSION_319_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_AMD_EXTENSION_319_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_extension_319&quot;
//         Enum:
//             Name: VK_DESCRIPTOR_SET_LAYOUT_CREATE_RESERVED_3_BIT_AMD
//             Negative: false
//             Bitpos: 3
//             Extends: VkDescriptorSetLayoutCreateFlagBits
//         Enum:
//             Name: VK_PIPELINE_LAYOUT_CREATE_RESERVED_0_BIT_AMD
//             Negative: false
//             Bitpos: 0
//             Extends: VkPipelineLayoutCreateFlagBits
// Extension: VK_AMD_extension_320
// Number: 320
// Type: invalid
// Author: AMD
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_AMD_EXTENSION_320_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_AMD_EXTENSION_320_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_extension_320&quot;
// Extension: VK_EXT_graphics_pipeline_library
// Number: 321
// Type: device
// Author: AMD
// Depends: (VK_KHR_get_physical_device_properties2,VK_VERSION_1_1)+VK_KHR_pipeline_library
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_GRAPHICS_PIPELINE_LIBRARY_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_GRAPHICS_PIPELINE_LIBRARY_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_graphics_pipeline_library&quot;
//         Type:
//             Name: VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT
//         Type:
//             Name: VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT
//         Type:
//             Name: VkGraphicsPipelineLibraryCreateInfoEXT
//         Type:
//             Name: VkGraphicsPipelineLibraryFlagBitsEXT
//         Type:
//             Name: VkGraphicsPipelineLibraryFlagsEXT
//         Type:
//             Name: VkPipelineLayoutCreateFlagBits
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_PROPERTIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_LIBRARY_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_PIPELINE_CREATE_RETAIN_LINK_TIME_OPTIMIZATION_INFO_BIT_EXT
//             Negative: false
//             Bitpos: 23
//             Extends: VkPipelineCreateFlagBits
//         Enum:
//             Name: VK_PIPELINE_CREATE_LINK_TIME_OPTIMIZATION_BIT_EXT
//             Negative: false
//             Bitpos: 10
//             Extends: VkPipelineCreateFlagBits
//         Enum:
//             Name: VK_PIPELINE_LAYOUT_CREATE_INDEPENDENT_SETS_BIT_EXT
//             Negative: false
//             Bitpos: 1
//             Extends: VkPipelineLayoutCreateFlagBits
//         Feature:
//             Name: graphicsPipelineLibrary
//             Struct: VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT
// Extension: VK_AMD_shader_early_and_late_fragment_tests
// Number: 322
// Type: device
// Author: EXT
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_AMD_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_AMD_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_shader_early_and_late_fragment_tests&quot;
//         Type:
//             Name: VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_FEATURES_AMD
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Feature:
//             Name: shaderEarlyAndLateFragmentTests
//             Struct: VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD
// Extension: VK_KHR_fragment_shader_barycentric
// Number: 323
// Type: device
// Author: KHR
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_FRAGMENT_SHADER_BARYCENTRIC_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_FRAGMENT_SHADER_BARYCENTRIC_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_fragment_shader_barycentric&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Extnumber: 204
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR
//         Type:
//             Name: VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR
//         Feature:
//             Name: fragmentShaderBarycentric
//             Struct: VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR
// Extension: VK_KHR_shader_subgroup_uniform_control_flow
// Number: 324
// Type: device
// Author: KHR
// Depends: VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_shader_subgroup_uniform_control_flow&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR
//         Feature:
//             Name: shaderSubgroupUniformControlFlow
//             Struct: VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR
// Extension: VK_KHR_extension_325
// Number: 325
// Type: invalid
// Author: KHR
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_KHR_EXTENSION_325_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_KHR_EXTENSION_325_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_extension_325&quot;
// Extension: VK_KHR_zero_initialize_workgroup_memory
// Number: 326
// Type: device
// Author: KHR
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_3
// Unlocks:
//         Enum:
//             Name: VK_KHR_ZERO_INITIALIZE_WORKGROUP_MEMORY_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_ZERO_INITIALIZE_WORKGROUP_MEMORY_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_zero_initialize_workgroup_memory&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES
//         Type:
//             Name: VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR
//         Feature:
//             Name: shaderZeroInitializeWorkgroupMemory
//             Struct: VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR
// Extension: VK_NV_fragment_shading_rate_enums
// Number: 327
// Type: device
// Author: NV
// Depends: VK_KHR_fragment_shading_rate
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NV_FRAGMENT_SHADING_RATE_ENUMS_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_NV_FRAGMENT_SHADING_RATE_ENUMS_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_fragment_shading_rate_enums&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Type:
//             Name: VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV
//         Type:
//             Name: VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV
//         Type:
//             Name: VkPipelineFragmentShadingRateEnumStateCreateInfoNV
//         Type:
//             Name: VkFragmentShadingRateNV
//         Type:
//             Name: VkFragmentShadingRateTypeNV
//         Command:
//             Name: vkCmdSetFragmentShadingRateEnumNV
//         Feature:
//             Name: fragmentShadingRateEnums
//             Struct: VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV
// Extension: VK_NV_ray_tracing_motion_blur
// Number: 328
// Type: device
// Author: NV
// Depends: VK_KHR_ray_tracing_pipeline
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NV_RAY_TRACING_MOTION_BLUR_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_NV_RAY_TRACING_MOTION_BLUR_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_ray_tracing_motion_blur&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_MOTION_TRIANGLES_DATA_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MOTION_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_BUILD_ACCELERATION_STRUCTURE_MOTION_BIT_NV
//             Negative: false
//             Bitpos: 5
//             Extends: VkBuildAccelerationStructureFlagBitsKHR
//         Enum:
//             Name: VK_ACCELERATION_STRUCTURE_CREATE_MOTION_BIT_NV
//             Negative: false
//             Bitpos: 2
//             Extends: VkAccelerationStructureCreateFlagBitsKHR
//         Enum:
//             Name: VK_PIPELINE_CREATE_RAY_TRACING_ALLOW_MOTION_BIT_NV
//             Negative: false
//             Bitpos: 20
//             Extends: VkPipelineCreateFlagBits
//         Type:
//             Name: VkAccelerationStructureGeometryMotionTrianglesDataNV
//         Type:
//             Name: VkAccelerationStructureMotionInfoNV
//         Type:
//             Name: VkAccelerationStructureMotionInstanceNV
//         Type:
//             Name: VkAccelerationStructureMotionInstanceDataNV
//         Type:
//             Name: VkAccelerationStructureMatrixMotionInstanceNV
//         Type:
//             Name: VkAccelerationStructureSRTMotionInstanceNV
//         Type:
//             Name: VkSRTDataNV
//         Type:
//             Name: VkAccelerationStructureMotionInstanceTypeNV
//         Type:
//             Name: VkPhysicalDeviceRayTracingMotionBlurFeaturesNV
//         Type:
//             Name: VkAccelerationStructureMotionInfoFlagsNV
//         Type:
//             Name: VkAccelerationStructureMotionInstanceFlagsNV
//         Feature:
//             Name: rayTracingMotionBlur
//             Struct: VkPhysicalDeviceRayTracingMotionBlurFeaturesNV
// Extension: VK_EXT_mesh_shader
// Number: 329
// Type: device
// Author: EXT
// Depends: VK_KHR_spirv_1_4,VK_VERSION_1_2
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_MESH_SHADER_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_MESH_SHADER_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_mesh_shader&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_SHADER_STAGE_TASK_BIT_EXT
//             Negative: false
//             Bitpos: 6
//             Extends: VkShaderStageFlagBits
//         Enum:
//             Name: VK_SHADER_STAGE_MESH_BIT_EXT
//             Negative: false
//             Bitpos: 7
//             Extends: VkShaderStageFlagBits
//         Enum:
//             Name: VK_PIPELINE_STAGE_TASK_SHADER_BIT_EXT
//             Negative: false
//             Bitpos: 19
//             Extends: VkPipelineStageFlagBits
//         Enum:
//             Name: VK_PIPELINE_STAGE_MESH_SHADER_BIT_EXT
//             Negative: false
//             Bitpos: 20
//             Extends: VkPipelineStageFlagBits
//         Enum:
//             Name: VK_QUERY_TYPE_MESH_PRIMITIVES_GENERATED_EXT
//             Negative: false
//             Extends: VkQueryType
//             Offset: 0
//         Enum:
//             Name: VK_QUERY_PIPELINE_STATISTIC_TASK_SHADER_INVOCATIONS_BIT_EXT
//             Negative: false
//             Bitpos: 11
//             Extends: VkQueryPipelineStatisticFlagBits
//         Enum:
//             Name: VK_QUERY_PIPELINE_STATISTIC_MESH_SHADER_INVOCATIONS_BIT_EXT
//             Negative: false
//             Bitpos: 12
//             Extends: VkQueryPipelineStatisticFlagBits
//         Command:
//             Name: vkCmdDrawMeshTasksEXT
//         Command:
//             Name: vkCmdDrawMeshTasksIndirectEXT
//         Type:
//             Name: VkPhysicalDeviceMeshShaderFeaturesEXT
//         Type:
//             Name: VkPhysicalDeviceMeshShaderPropertiesEXT
//         Type:
//             Name: VkDrawMeshTasksIndirectCommandEXT
//         Feature:
//             Name: taskShader
//             Struct: VkPhysicalDeviceMeshShaderFeaturesEXT
//         Feature:
//             Name: meshShader
//             Struct: VkPhysicalDeviceMeshShaderFeaturesEXT
//     Depends: VK_VERSION_1_2,VK_KHR_draw_indirect_count,VK_AMD_draw_indirect_count
//         Command:
//             Name: vkCmdDrawMeshTasksIndirectCountEXT
//     Depends: VK_NV_device_generated_commands
//         Enum:
//             Name: VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_NV
//             Negative: false
//             Extends: VkIndirectCommandsTokenTypeNV
//             Offset: 0
//     Depends: VK_EXT_device_generated_commands
//         Enum:
//             Name: VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_EXT
//             Negative: false
//             Extends: VkIndirectCommandsTokenTypeEXT
//             Offset: 0
//         Enum:
//             Name: VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_COUNT_EXT
//             Negative: false
//             Extends: VkIndirectCommandsTokenTypeEXT
//             Offset: 1
//     Depends: VK_KHR_fragment_shading_rate+VkPhysicalDeviceMeshShaderFeaturesEXT::primitiveFragmentShadingRateMeshShader
//         Feature:
//             Name: primitiveFragmentShadingRate
//             Struct: VkPhysicalDeviceFragmentShadingRateFeaturesKHR
// Extension: VK_NV_extension_330
// Number: 330
// Type: invalid
// Author: NV
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_NV_EXTENSION_330_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_NV_EXTENSION_330_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_extension_330&quot;
// Extension: VK_EXT_ycbcr_2plane_444_formats
// Number: 331
// Type: device
// Author: EXT
// Depends: VK_KHR_sampler_ycbcr_conversion,VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_3
// Unlocks:
//         Comment:
//             VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT and
//             VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT
//             were not promoted to Vulkan 1.3.
//         Enum:
//             Name: VK_EXT_YCBCR_2PLANE_444_FORMATS_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_YCBCR_2PLANE_444_FORMATS_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_ycbcr_2plane_444_formats&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_FORMAT_G8_B8R8_2PLANE_444_UNORM_EXT
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_G8_B8R8_2PLANE_444_UNORM
//         Enum:
//             Name: VK_FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16_EXT
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16
//         Enum:
//             Name: VK_FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16_EXT
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16
//         Enum:
//             Name: VK_FORMAT_G16_B16R16_2PLANE_444_UNORM_EXT
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_G16_B16R16_2PLANE_444_UNORM
//         Type:
//             Name: VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT
//         Feature:
//             Name: ycbcr2plane444Formats
//             Struct: VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT
// Extension: VK_NV_extension_332
// Number: 332
// Type: invalid
// Author: NV
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_NV_EXTENSION_332_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_NV_EXTENSION_332_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_extension_332&quot;
// Extension: VK_EXT_fragment_density_map2
// Number: 333
// Type: device
// Author: EXT
// Depends: VK_EXT_fragment_density_map
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_FRAGMENT_DENSITY_MAP_2_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_FRAGMENT_DENSITY_MAP_2_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_fragment_density_map2&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DEFERRED_BIT_EXT
//             Negative: false
//             Bitpos: 1
//             Extends: VkImageViewCreateFlagBits
//         Type:
//             Name: VkPhysicalDeviceFragmentDensityMap2FeaturesEXT
//         Type:
//             Name: VkPhysicalDeviceFragmentDensityMap2PropertiesEXT
//         Feature:
//             Name: fragmentDensityMapDeferred
//             Struct: VkPhysicalDeviceFragmentDensityMap2FeaturesEXT
// Extension: VK_QCOM_rotated_copy_commands
// Number: 334
// Type: device
// Author: QCOM
// Depends: VK_KHR_copy_commands2,VK_VERSION_1_3
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_QCOM_ROTATED_COPY_COMMANDS_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_QCOM_ROTATED_COPY_COMMANDS_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_QCOM_rotated_copy_commands&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkCopyCommandTransformInfoQCOM
// Extension: VK_KHR_extension_335
// Number: 335
// Type: device
// Author: KHR
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_KHR_EXTENSION_335_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_KHR_EXTENSION_335_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_extension_335&quot;
// Extension: VK_EXT_image_robustness
// Number: 336
// Type: device
// Author: EXT
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_3
// Unlocks:
//         Enum:
//             Name: VK_EXT_IMAGE_ROBUSTNESS_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_IMAGE_ROBUSTNESS_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_image_robustness&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES
//         Type:
//             Name: VkPhysicalDeviceImageRobustnessFeaturesEXT
//         Feature:
//             Name: robustImageAccess
//             Struct: VkPhysicalDeviceImageRobustnessFeaturesEXT
// Extension: VK_KHR_workgroup_memory_explicit_layout
// Number: 337
// Type: device
// Author: KHR
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_workgroup_memory_explicit_layout&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR
//         Feature:
//             Name: workgroupMemoryExplicitLayout
//             Struct: VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR
// Extension: VK_KHR_copy_commands2
// Number: 338
// Type: device
// Author: KHR
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_3
// Unlocks:
//         Enum:
//             Name: VK_KHR_COPY_COMMANDS_2_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_COPY_COMMANDS_2_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_copy_commands2&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_BUFFER_COPY_2_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_BUFFER_COPY_2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMAGE_COPY_2_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_IMAGE_COPY_2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMAGE_BLIT_2_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_IMAGE_BLIT_2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2
//         Type:
//             Name: VkCopyBufferInfo2KHR
//         Type:
//             Name: VkCopyImageInfo2KHR
//         Type:
//             Name: VkCopyBufferToImageInfo2KHR
//         Type:
//             Name: VkCopyImageToBufferInfo2KHR
//         Type:
//             Name: VkBlitImageInfo2KHR
//         Type:
//             Name: VkResolveImageInfo2KHR
//         Type:
//             Name: VkBufferCopy2KHR
//         Type:
//             Name: VkImageCopy2KHR
//         Type:
//             Name: VkImageBlit2KHR
//         Type:
//             Name: VkBufferImageCopy2KHR
//         Type:
//             Name: VkImageResolve2KHR
//         Command:
//             Name: vkCmdCopyBuffer2KHR
//         Command:
//             Name: vkCmdCopyImage2KHR
//         Command:
//             Name: vkCmdCopyBufferToImage2KHR
//         Command:
//             Name: vkCmdCopyImageToBuffer2KHR
//         Command:
//             Name: vkCmdBlitImage2KHR
//         Command:
//             Name: vkCmdResolveImage2KHR
// Extension: VK_EXT_image_compression_control
// Number: 339
// Type: device
// Author: EXT
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_IMAGE_COMPRESSION_CONTROL_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_IMAGE_COMPRESSION_CONTROL_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_image_compression_control&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceImageCompressionControlFeaturesEXT
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Type:
//             Name: VkImageCompressionControlEXT
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2
//         Type:
//             Name: VkSubresourceLayout2EXT
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2
//         Type:
//             Name: VkImageSubresource2EXT
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 4
//         Type:
//             Name: VkImageCompressionPropertiesEXT
//         Type:
//             Name: VkImageCompressionFlagBitsEXT
//         Type:
//             Name: VkImageCompressionFlagsEXT
//         Type:
//             Name: VkImageCompressionFixedRateFlagBitsEXT
//         Type:
//             Name: VkImageCompressionFixedRateFlagsEXT
//         Enum:
//             Name: VK_ERROR_COMPRESSION_EXHAUSTED_EXT
//             Negative: true
//             Extends: VkResult
//             Offset: 0
//         Command:
//             Name: vkGetImageSubresourceLayout2EXT
//         Feature:
//             Name: imageCompressionControl
//             Struct: VkPhysicalDeviceImageCompressionControlFeaturesEXT
// Extension: VK_EXT_attachment_feedback_loop_layout
// Number: 340
// Type: device
// Author: EXT
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_EXT_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_attachment_feedback_loop_layout&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT
//             Negative: false
//             Extends: VkImageLayout
//             Offset: 0
//         Enum:
//             Name: VK_IMAGE_USAGE_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT
//             Negative: false
//             Bitpos: 19
//             Extends: VkImageUsageFlagBits
//         Enum:
//             Name: VK_PIPELINE_CREATE_COLOR_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT
//             Negative: false
//             Bitpos: 25
//             Extends: VkPipelineCreateFlagBits
//         Enum:
//             Name: VK_PIPELINE_CREATE_DEPTH_STENCIL_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT
//             Negative: false
//             Bitpos: 26
//             Extends: VkPipelineCreateFlagBits
//         Enum:
//             Name: VK_DEPENDENCY_FEEDBACK_LOOP_BIT_EXT
//             Negative: false
//             Bitpos: 3
//             Extends: VkDependencyFlagBits
//             Comment:
//                 Dependency may be a feedback loop
//         Type:
//             Name: VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT
//         Feature:
//             Name: attachmentFeedbackLoopLayout
//             Struct: VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT
// Extension: VK_EXT_4444_formats
// Number: 341
// Type: device
// Author: EXT
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_3
// Unlocks:
//         Comment:
//             VkPhysicalDevice4444FormatsFeaturesEXT and
//             VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT
//             were not promoted to Vulkan 1.3.
//         Enum:
//             Name: VK_EXT_4444_FORMATS_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_4444_FORMATS_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_4444_formats&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_FORMAT_A4R4G4B4_UNORM_PACK16_EXT
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_A4R4G4B4_UNORM_PACK16
//         Enum:
//             Name: VK_FORMAT_A4B4G4R4_UNORM_PACK16_EXT
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_A4B4G4R4_UNORM_PACK16
//         Type:
//             Name: VkPhysicalDevice4444FormatsFeaturesEXT
//         Feature:
//             Name: formatA4R4G4B4
//             Struct: VkPhysicalDevice4444FormatsFeaturesEXT
// Extension: VK_EXT_device_fault
// Number: 342
// Type: device
// Author: EXT
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_DEVICE_FAULT_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_EXT_DEVICE_FAULT_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_device_fault&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FAULT_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DEVICE_FAULT_COUNTS_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DEVICE_FAULT_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Type:
//             Name: VkPhysicalDeviceFaultFeaturesEXT
//         Type:
//             Name: VkDeviceFaultCountsEXT
//         Type:
//             Name: VkDeviceFaultInfoEXT
//         Type:
//             Name: VkDeviceFaultAddressInfoEXT
//         Type:
//             Name: VkDeviceFaultAddressTypeEXT
//         Type:
//             Name: VkDeviceFaultVendorInfoEXT
//         Type:
//             Name: VkDeviceFaultVendorBinaryHeaderVersionEXT
//         Type:
//             Name: VkDeviceFaultVendorBinaryHeaderVersionOneEXT
//         Command:
//             Name: vkGetDeviceFaultInfoEXT
//         Feature:
//             Name: deviceFault
//             Struct: VkPhysicalDeviceFaultFeaturesEXT
// Extension: VK_ARM_rasterization_order_attachment_access
// Number: 343
// Type: device
// Author: ARM
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_EXT_rasterization_order_attachment_access
// Unlocks:
//         Enum:
//             Name: VK_ARM_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_ARM_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_ARM_rasterization_order_attachment_access&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_ARM
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT
//         Type:
//             Name: VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesARM
//         Enum:
//             Name: VK_PIPELINE_COLOR_BLEND_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_BIT_ARM
//             Negative: false
//             Extends: VkPipelineColorBlendStateCreateFlagBits
//             Alias: VK_PIPELINE_COLOR_BLEND_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_BIT_EXT
//         Enum:
//             Name: VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_ARM
//             Negative: false
//             Extends: VkPipelineDepthStencilStateCreateFlagBits
//             Alias: VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_EXT
//         Enum:
//             Name: VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_ARM
//             Negative: false
//             Extends: VkPipelineDepthStencilStateCreateFlagBits
//             Alias: VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_EXT
//         Enum:
//             Name: VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_COLOR_ACCESS_BIT_ARM
//             Negative: false
//             Extends: VkSubpassDescriptionFlagBits
//             Alias: VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_COLOR_ACCESS_BIT_EXT
//         Enum:
//             Name: VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_ARM
//             Negative: false
//             Extends: VkSubpassDescriptionFlagBits
//             Alias: VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_EXT
//         Enum:
//             Name: VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_ARM
//             Negative: false
//             Extends: VkSubpassDescriptionFlagBits
//             Alias: VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_EXT
// Extension: VK_ARM_extension_344
// Number: 344
// Type: invalid
// Author: ARM
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_ARM_EXTENSION_344_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_ARM_EXTENSION_344_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_ARM_extension_344&quot;
// Extension: VK_EXT_rgba10x6_formats
// Number: 345
// Type: device
// Author: EXT
// Depends: VK_KHR_sampler_ycbcr_conversion,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_RGBA10X6_FORMATS_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_RGBA10X6_FORMATS_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_rgba10x6_formats&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT
//         Feature:
//             Name: formatRgba10x6WithoutYCbCrSampler
//             Struct: VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT
// Extension: VK_NV_acquire_winrt_display
// Number: 346
// Type: device
// Author: NV
// Depends: VK_EXT_direct_mode_display
// Platform: win32
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NV_ACQUIRE_WINRT_DISPLAY_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_NV_ACQUIRE_WINRT_DISPLAY_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_acquire_winrt_display&quot;
//         Command:
//             Name: vkAcquireWinrtDisplayNV
//         Command:
//             Name: vkGetWinrtDisplayNV
// Extension: VK_EXT_directfb_surface
// Number: 347
// Type: instance
// Author: EXT
// Depends: VK_KHR_surface
// Platform: directfb
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_DIRECTFB_SURFACE_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_DIRECTFB_SURFACE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_directfb_surface&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DIRECTFB_SURFACE_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkDirectFBSurfaceCreateFlagsEXT
//         Type:
//             Name: VkDirectFBSurfaceCreateInfoEXT
//         Command:
//             Name: vkCreateDirectFBSurfaceEXT
//         Command:
//             Name: vkGetPhysicalDeviceDirectFBPresentationSupportEXT
// Extension: VK_KHR_extension_350
// Number: 350
// Type: device
// Author: KHR
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_KHR_EXTENSION_350_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_KHR_EXTENSION_350_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_extension_350&quot;
// Extension: VK_NV_extension_351
// Number: 351
// Type: invalid
// Author: NV
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_NV_EXTENSION_351_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_NV_EXTENSION_351_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_extension_351&quot;
// Extension: VK_VALVE_mutable_descriptor_type
// Number: 352
// Type: device
// Author: VALVE
// Depends: VK_KHR_maintenance3
// Supported: supported
// Promoted to: VK_EXT_mutable_descriptor_type
// Unlocks:
//         Enum:
//             Name: VK_VALVE_MUTABLE_DESCRIPTOR_TYPE_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_VALVE_MUTABLE_DESCRIPTOR_TYPE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_VALVE_mutable_descriptor_type&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_VALVE
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT
//         Enum:
//             Name: VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_VALVE
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT
//         Enum:
//             Name: VK_DESCRIPTOR_TYPE_MUTABLE_VALVE
//             Negative: false
//             Extends: VkDescriptorType
//             Alias: VK_DESCRIPTOR_TYPE_MUTABLE_EXT
//         Enum:
//             Name: VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_VALVE
//             Negative: false
//             Extends: VkDescriptorPoolCreateFlagBits
//             Alias: VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_EXT
//         Enum:
//             Name: VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_VALVE
//             Negative: false
//             Extends: VkDescriptorSetLayoutCreateFlagBits
//             Alias: VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_EXT
//         Type:
//             Name: VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE
//         Type:
//             Name: VkMutableDescriptorTypeListVALVE
//         Type:
//             Name: VkMutableDescriptorTypeCreateInfoVALVE
//         Feature:
//             Name: mutableDescriptorType
//             Struct: VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE
// Extension: VK_EXT_vertex_input_dynamic_state
// Number: 353
// Type: device
// Author: EXT
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_VERTEX_INPUT_DYNAMIC_STATE_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_EXT_VERTEX_INPUT_DYNAMIC_STATE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_vertex_input_dynamic_state&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VERTEX_INPUT_BINDING_DESCRIPTION_2_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VERTEX_INPUT_ATTRIBUTE_DESCRIPTION_2_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_DYNAMIC_STATE_VERTEX_INPUT_EXT
//             Negative: false
//             Extends: VkDynamicState
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT
//         Type:
//             Name: VkVertexInputBindingDescription2EXT
//         Type:
//             Name: VkVertexInputAttributeDescription2EXT
//         Command:
//             Name: vkCmdSetVertexInputEXT
//         Feature:
//             Name: vertexInputDynamicState
//             Struct: VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT
// Extension: VK_EXT_physical_device_drm
// Number: 354
// Type: device
// Author: EXT
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_PHYSICAL_DEVICE_DRM_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_PHYSICAL_DEVICE_DRM_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_physical_device_drm&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRM_PROPERTIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceDrmPropertiesEXT
// Extension: VK_EXT_device_address_binding_report
// Number: 355
// Type: device
// Author: EXT
// Depends: (VK_KHR_get_physical_device_properties2,VK_VERSION_1_1)+VK_EXT_debug_utils
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_DEVICE_ADDRESS_BINDING_REPORT_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_DEVICE_ADDRESS_BINDING_REPORT_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_device_address_binding_report&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ADDRESS_BINDING_REPORT_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DEVICE_ADDRESS_BINDING_CALLBACK_DATA_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_DEBUG_UTILS_MESSAGE_TYPE_DEVICE_ADDRESS_BINDING_BIT_EXT
//             Negative: false
//             Bitpos: 3
//             Extends: VkDebugUtilsMessageTypeFlagBitsEXT
//         Type:
//             Name: VkPhysicalDeviceAddressBindingReportFeaturesEXT
//         Type:
//             Name: VkDeviceAddressBindingCallbackDataEXT
//         Type:
//             Name: VkDeviceAddressBindingFlagsEXT
//         Type:
//             Name: VkDeviceAddressBindingFlagBitsEXT
//         Type:
//             Name: VkDeviceAddressBindingTypeEXT
//         Feature:
//             Name: reportAddressBinding
//             Struct: VkPhysicalDeviceAddressBindingReportFeaturesEXT
// Extension: VK_EXT_depth_clip_control
// Number: 356
// Type: device
// Author: EXT
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_DEPTH_CLIP_CONTROL_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_DEPTH_CLIP_CONTROL_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_depth_clip_control&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLIP_CONTROL_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Type:
//             Name: VkPhysicalDeviceDepthClipControlFeaturesEXT
//         Type:
//             Name: VkPipelineViewportDepthClipControlCreateInfoEXT
//         Feature:
//             Name: depthClipControl
//             Struct: VkPhysicalDeviceDepthClipControlFeaturesEXT
// Extension: VK_EXT_primitive_topology_list_restart
// Number: 357
// Type: device
// Author: EXT
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_PRIMITIVE_TOPOLOGY_LIST_RESTART_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_PRIMITIVE_TOPOLOGY_LIST_RESTART_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_primitive_topology_list_restart&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT
//         Feature:
//             Name: primitiveTopologyListRestart
//             Struct: VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT
// Extension: VK_KHR_extension_358
// Number: 358
// Type: invalid
// Author: KHR
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_KHR_EXTENSION_358_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_KHR_EXTENSION_358_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_extension_358&quot;
// Extension: VK_EXT_extension_359
// Number: 359
// Type: invalid
// Author: EXT
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_359_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_359_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_359&quot;
// Extension: VK_EXT_extension_360
// Number: 360
// Type: invalid
// Author: EXT
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_360_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_360_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_360&quot;
// Extension: VK_KHR_format_feature_flags2
// Number: 361
// Type: device
// Author: KHR
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_3
// Unlocks:
//         Enum:
//             Name: VK_KHR_FORMAT_FEATURE_FLAGS_2_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_KHR_FORMAT_FEATURE_FLAGS_2_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_format_feature_flags2&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_BIT_KHR
//             Negative: false
//             Extends: VkFormatFeatureFlagBits2
//             Alias: VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_BIT
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_STORAGE_IMAGE_BIT_KHR
//             Negative: false
//             Extends: VkFormatFeatureFlagBits2
//             Alias: VK_FORMAT_FEATURE_2_STORAGE_IMAGE_BIT
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_STORAGE_IMAGE_ATOMIC_BIT_KHR
//             Negative: false
//             Extends: VkFormatFeatureFlagBits2
//             Alias: VK_FORMAT_FEATURE_2_STORAGE_IMAGE_ATOMIC_BIT
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_UNIFORM_TEXEL_BUFFER_BIT_KHR
//             Negative: false
//             Extends: VkFormatFeatureFlagBits2
//             Alias: VK_FORMAT_FEATURE_2_UNIFORM_TEXEL_BUFFER_BIT
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_BIT_KHR
//             Negative: false
//             Extends: VkFormatFeatureFlagBits2
//             Alias: VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_BIT
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_ATOMIC_BIT_KHR
//             Negative: false
//             Extends: VkFormatFeatureFlagBits2
//             Alias: VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_ATOMIC_BIT
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_VERTEX_BUFFER_BIT_KHR
//             Negative: false
//             Extends: VkFormatFeatureFlagBits2
//             Alias: VK_FORMAT_FEATURE_2_VERTEX_BUFFER_BIT
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BIT_KHR
//             Negative: false
//             Extends: VkFormatFeatureFlagBits2
//             Alias: VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BIT
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BLEND_BIT_KHR
//             Negative: false
//             Extends: VkFormatFeatureFlagBits2
//             Alias: VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BLEND_BIT
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_DEPTH_STENCIL_ATTACHMENT_BIT_KHR
//             Negative: false
//             Extends: VkFormatFeatureFlagBits2
//             Alias: VK_FORMAT_FEATURE_2_DEPTH_STENCIL_ATTACHMENT_BIT
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_BLIT_SRC_BIT_KHR
//             Negative: false
//             Extends: VkFormatFeatureFlagBits2
//             Alias: VK_FORMAT_FEATURE_2_BLIT_SRC_BIT
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_BLIT_DST_BIT_KHR
//             Negative: false
//             Extends: VkFormatFeatureFlagBits2
//             Alias: VK_FORMAT_FEATURE_2_BLIT_DST_BIT
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_LINEAR_BIT_KHR
//             Negative: false
//             Extends: VkFormatFeatureFlagBits2
//             Alias: VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_LINEAR_BIT
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_TRANSFER_SRC_BIT_KHR
//             Negative: false
//             Extends: VkFormatFeatureFlagBits2
//             Alias: VK_FORMAT_FEATURE_2_TRANSFER_SRC_BIT
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_TRANSFER_DST_BIT_KHR
//             Negative: false
//             Extends: VkFormatFeatureFlagBits2
//             Alias: VK_FORMAT_FEATURE_2_TRANSFER_DST_BIT
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_MIDPOINT_CHROMA_SAMPLES_BIT_KHR
//             Negative: false
//             Extends: VkFormatFeatureFlagBits2
//             Alias: VK_FORMAT_FEATURE_2_MIDPOINT_CHROMA_SAMPLES_BIT
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR
//             Negative: false
//             Extends: VkFormatFeatureFlagBits2
//             Alias: VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR
//             Negative: false
//             Extends: VkFormatFeatureFlagBits2
//             Alias: VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR
//             Negative: false
//             Extends: VkFormatFeatureFlagBits2
//             Alias: VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR
//             Negative: false
//             Extends: VkFormatFeatureFlagBits2
//             Alias: VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_DISJOINT_BIT_KHR
//             Negative: false
//             Extends: VkFormatFeatureFlagBits2
//             Alias: VK_FORMAT_FEATURE_2_DISJOINT_BIT
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_COSITED_CHROMA_SAMPLES_BIT_KHR
//             Negative: false
//             Extends: VkFormatFeatureFlagBits2
//             Alias: VK_FORMAT_FEATURE_2_COSITED_CHROMA_SAMPLES_BIT
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT_KHR
//             Negative: false
//             Extends: VkFormatFeatureFlagBits2
//             Alias: VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT_KHR
//             Negative: false
//             Extends: VkFormatFeatureFlagBits2
//             Alias: VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT_KHR
//             Negative: false
//             Extends: VkFormatFeatureFlagBits2
//             Alias: VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT
//         Type:
//             Name: VkFormatFeatureFlags2KHR
//         Type:
//             Name: VkFormatFeatureFlagBits2KHR
//         Type:
//             Name: VkFormatProperties3KHR
//     Depends: VK_VERSION_1_2,VK_EXT_sampler_filter_minmax
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_MINMAX_BIT_KHR
//             Negative: false
//             Extends: VkFormatFeatureFlagBits2
//             Alias: VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_MINMAX_BIT
//     Depends: VK_EXT_filter_cubic,VK_IMG_filter_cubic
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT
//             Negative: false
//             Extends: VkFormatFeatureFlagBits2
//             Alias: VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_CUBIC_BIT
// Extension: VK_EXT_present_mode_fifo_latest_ready
// Number: 362
// Type: device
// Author: EXT
// Depends: VK_KHR_swapchain
// Supported: supported
// Promoted to: VK_KHR_present_mode_fifo_latest_ready
// Unlocks:
//         Enum:
//             Name: VK_EXT_PRESENT_MODE_FIFO_LATEST_READY_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_PRESENT_MODE_FIFO_LATEST_READY_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_present_mode_fifo_latest_ready&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_MODE_FIFO_LATEST_READY_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_MODE_FIFO_LATEST_READY_FEATURES_KHR
//         Enum:
//             Name: VK_PRESENT_MODE_FIFO_LATEST_READY_EXT
//             Negative: false
//             Extends: VkPresentModeKHR
//             Alias: VK_PRESENT_MODE_FIFO_LATEST_READY_KHR
//         Type:
//             Name: VkPhysicalDevicePresentModeFifoLatestReadyFeaturesEXT
//         Feature:
//             Name: presentModeFifoLatestReady
//             Struct: VkPhysicalDevicePresentModeFifoLatestReadyFeaturesEXT
// Extension: VK_EXT_extension_363
// Number: 363
// Type: invalid
// Author: EXT
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_363_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_363_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_363&quot;
// Extension: VK_FUCHSIA_extension_364
// Number: 364
// Type: invalid
// Author: FUCHSIA
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_FUCHSIA_EXTENSION_364_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_FUCHSIA_EXTENSION_364_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_FUCHSIA_extension_364&quot;
// Extension: VK_FUCHSIA_external_memory
// Number: 365
// Type: device
// Author: FUCHSIA
// Depends: (VK_KHR_external_memory_capabilities+VK_KHR_external_memory),VK_VERSION_1_1
// Platform: fuchsia
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_FUCHSIA_EXTERNAL_MEMORY_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_FUCHSIA_EXTERNAL_MEMORY_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_FUCHSIA_external_memory&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMPORT_MEMORY_ZIRCON_HANDLE_INFO_FUCHSIA
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_MEMORY_ZIRCON_HANDLE_PROPERTIES_FUCHSIA
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_MEMORY_GET_ZIRCON_HANDLE_INFO_FUCHSIA
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_EXTERNAL_MEMORY_HANDLE_TYPE_ZIRCON_VMO_BIT_FUCHSIA
//             Negative: false
//             Bitpos: 11
//             Extends: VkExternalMemoryHandleTypeFlagBits
//         Type:
//             Name: VkImportMemoryZirconHandleInfoFUCHSIA
//         Type:
//             Name: VkMemoryZirconHandlePropertiesFUCHSIA
//         Type:
//             Name: VkMemoryGetZirconHandleInfoFUCHSIA
//         Command:
//             Name: vkGetMemoryZirconHandleFUCHSIA
//         Command:
//             Name: vkGetMemoryZirconHandlePropertiesFUCHSIA
// Extension: VK_FUCHSIA_external_semaphore
// Number: 366
// Type: device
// Author: FUCHSIA
// Depends: VK_KHR_external_semaphore_capabilities+VK_KHR_external_semaphore
// Platform: fuchsia
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_FUCHSIA_EXTERNAL_SEMAPHORE_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_FUCHSIA_EXTERNAL_SEMAPHORE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_FUCHSIA_external_semaphore&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_ZIRCON_HANDLE_INFO_FUCHSIA
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SEMAPHORE_GET_ZIRCON_HANDLE_INFO_FUCHSIA
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_ZIRCON_EVENT_BIT_FUCHSIA
//             Negative: false
//             Bitpos: 7
//             Extends: VkExternalSemaphoreHandleTypeFlagBits
//         Type:
//             Name: VkImportSemaphoreZirconHandleInfoFUCHSIA
//         Type:
//             Name: VkSemaphoreGetZirconHandleInfoFUCHSIA
//         Command:
//             Name: vkImportSemaphoreZirconHandleFUCHSIA
//         Command:
//             Name: vkGetSemaphoreZirconHandleFUCHSIA
// Extension: VK_FUCHSIA_buffer_collection
// Number: 367
// Type: device
// Author: FUCHSIA
// Depends: VK_FUCHSIA_external_memory+(VK_KHR_sampler_ycbcr_conversion,VK_VERSION_1_1)
// Platform: fuchsia
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_FUCHSIA_BUFFER_COLLECTION_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_FUCHSIA_BUFFER_COLLECTION_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_FUCHSIA_buffer_collection&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_BUFFER_COLLECTION_CREATE_INFO_FUCHSIA
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_OBJECT_TYPE_BUFFER_COLLECTION_FUCHSIA
//             Negative: false
//             Extends: VkObjectType
//             Offset: 0
//             Comment:
//                 VkBufferCollectionFUCHSIA
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMPORT_MEMORY_BUFFER_COLLECTION_FUCHSIA
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_BUFFER_COLLECTION_IMAGE_CREATE_INFO_FUCHSIA
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_BUFFER_COLLECTION_PROPERTIES_FUCHSIA
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Enum:
//             Name: VK_STRUCTURE_TYPE_BUFFER_CONSTRAINTS_INFO_FUCHSIA
//             Negative: false
//             Extends: VkStructureType
//             Offset: 4
//         Enum:
//             Name: VK_STRUCTURE_TYPE_BUFFER_COLLECTION_BUFFER_CREATE_INFO_FUCHSIA
//             Negative: false
//             Extends: VkStructureType
//             Offset: 5
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMAGE_CONSTRAINTS_INFO_FUCHSIA
//             Negative: false
//             Extends: VkStructureType
//             Offset: 6
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMAGE_FORMAT_CONSTRAINTS_INFO_FUCHSIA
//             Negative: false
//             Extends: VkStructureType
//             Offset: 7
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SYSMEM_COLOR_SPACE_FUCHSIA
//             Negative: false
//             Extends: VkStructureType
//             Offset: 8
//         Enum:
//             Name: VK_STRUCTURE_TYPE_BUFFER_COLLECTION_CONSTRAINTS_INFO_FUCHSIA
//             Negative: false
//             Extends: VkStructureType
//             Offset: 9
//         Type:
//             Name: VkBufferCollectionFUCHSIA
//         Type:
//             Name: VkBufferCollectionCreateInfoFUCHSIA
//         Type:
//             Name: VkImportMemoryBufferCollectionFUCHSIA
//         Type:
//             Name: VkBufferCollectionImageCreateInfoFUCHSIA
//         Type:
//             Name: VkBufferConstraintsInfoFUCHSIA
//         Type:
//             Name: VkBufferCollectionBufferCreateInfoFUCHSIA
//         Type:
//             Name: VkBufferCollectionPropertiesFUCHSIA
//         Type:
//             Name: VkImageFormatConstraintsFlagsFUCHSIA
//         Type:
//             Name: VkSysmemColorSpaceFUCHSIA
//         Type:
//             Name: VkImageConstraintsInfoFlagBitsFUCHSIA
//         Type:
//             Name: VkImageConstraintsInfoFlagsFUCHSIA
//         Type:
//             Name: VkImageConstraintsInfoFUCHSIA
//         Type:
//             Name: VkImageFormatConstraintsInfoFUCHSIA
//         Type:
//             Name: VkBufferCollectionConstraintsInfoFUCHSIA
//         Command:
//             Name: vkCreateBufferCollectionFUCHSIA
//         Command:
//             Name: vkSetBufferCollectionImageConstraintsFUCHSIA
//         Command:
//             Name: vkSetBufferCollectionBufferConstraintsFUCHSIA
//         Command:
//             Name: vkDestroyBufferCollectionFUCHSIA
//         Command:
//             Name: vkGetBufferCollectionPropertiesFUCHSIA
//     Depends: VK_EXT_debug_report
//         Enum:
//             Name: VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_COLLECTION_FUCHSIA_EXT
//             Negative: false
//             Extends: VkDebugReportObjectTypeEXT
//             Offset: 0
// Extension: VK_FUCHSIA_extension_368
// Number: 368
// Type: invalid
// Author: FUCHSIA
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_FUCHSIA_EXTENSION_368_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_FUCHSIA_EXTENSION_368_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_FUCHSIA_extension_368&quot;
// Extension: VK_QCOM_extension_369
// Number: 369
// Type: invalid
// Author: QCOM
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_QCOM_EXTENSION_369_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_QCOM_EXTENSION_369_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_QCOM_extension_369&quot;
//         Enum:
//             Name: VK_DESCRIPTOR_BINDING_RESERVED_4_BIT_QCOM
//             Negative: false
//             Bitpos: 4
//             Extends: VkDescriptorBindingFlagBits
// Extension: VK_HUAWEI_subpass_shading
// Number: 370
// Type: device
// Author: HUAWEI
// Depends: ((VK_KHR_create_renderpass2,VK_VERSION_1_2)+VK_KHR_synchronization2),VK_VERSION_1_3
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_HUAWEI_SUBPASS_SHADING_SPEC_VERSION
//             Negative: false
//             Value: 3
//         Enum:
//             Name: VK_HUAWEI_SUBPASS_SHADING_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_HUAWEI_subpass_shading&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SUBPASS_SHADING_PIPELINE_CREATE_INFO_HUAWEI
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_PROPERTIES_HUAWEI
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_PIPELINE_BIND_POINT_SUBPASS_SHADING_HUAWEI
//             Negative: false
//             Extends: VkPipelineBindPoint
//             Extnumber: 370
//             Offset: 3
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_SUBPASS_SHADER_BIT_HUAWEI
//             Negative: false
//             Bitpos: 39
//             Extends: VkPipelineStageFlagBits2
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI
//             Negative: false
//             Extends: VkPipelineStageFlagBits2
//             Alias: VK_PIPELINE_STAGE_2_SUBPASS_SHADER_BIT_HUAWEI
//         Enum:
//             Name: VK_SHADER_STAGE_SUBPASS_SHADING_BIT_HUAWEI
//             Negative: false
//             Bitpos: 14
//             Extends: VkShaderStageFlagBits
//         Type:
//             Name: VkSubpassShadingPipelineCreateInfoHUAWEI
//         Type:
//             Name: VkPhysicalDeviceSubpassShadingFeaturesHUAWEI
//         Type:
//             Name: VkPhysicalDeviceSubpassShadingPropertiesHUAWEI
//         Command:
//             Name: vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI
//         Command:
//             Name: vkCmdSubpassShadingHUAWEI
//         Feature:
//             Name: subpassShading
//             Struct: VkPhysicalDeviceSubpassShadingFeaturesHUAWEI
// Extension: VK_HUAWEI_invocation_mask
// Number: 371
// Type: device
// Author: Huawei
// Depends: VK_KHR_ray_tracing_pipeline+(VK_KHR_synchronization2,VK_VERSION_1_3)
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_HUAWEI_INVOCATION_MASK_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_HUAWEI_INVOCATION_MASK_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_HUAWEI_invocation_mask&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_ACCESS_2_INVOCATION_MASK_READ_BIT_HUAWEI
//             Negative: false
//             Bitpos: 39
//             Extends: VkAccessFlagBits2
//         Enum:
//             Name: VK_IMAGE_USAGE_INVOCATION_MASK_BIT_HUAWEI
//             Negative: false
//             Bitpos: 18
//             Extends: VkImageUsageFlagBits
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_INVOCATION_MASK_BIT_HUAWEI
//             Negative: false
//             Bitpos: 40
//             Extends: VkPipelineStageFlagBits2
//         Type:
//             Name: VkPhysicalDeviceInvocationMaskFeaturesHUAWEI
//         Command:
//             Name: vkCmdBindInvocationMaskHUAWEI
//         Feature:
//             Name: invocationMask
//             Struct: VkPhysicalDeviceInvocationMaskFeaturesHUAWEI
// Extension: VK_NV_external_memory_rdma
// Number: 372
// Type: device
// Author: NV
// Depends: VK_KHR_external_memory,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NV_EXTERNAL_MEMORY_RDMA_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_NV_EXTERNAL_MEMORY_RDMA_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_external_memory_rdma&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_MEMORY_GET_REMOTE_ADDRESS_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_RDMA_FEATURES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_MEMORY_PROPERTY_RDMA_CAPABLE_BIT_NV
//             Negative: false
//             Bitpos: 8
//             Extends: VkMemoryPropertyFlagBits
//         Enum:
//             Name: VK_EXTERNAL_MEMORY_HANDLE_TYPE_RDMA_ADDRESS_BIT_NV
//             Negative: false
//             Bitpos: 12
//             Extends: VkExternalMemoryHandleTypeFlagBits
//         Type:
//             Name: VkRemoteAddressNV
//         Type:
//             Name: VkMemoryGetRemoteAddressInfoNV
//         Type:
//             Name: VkPhysicalDeviceExternalMemoryRDMAFeaturesNV
//         Command:
//             Name: vkGetMemoryRemoteAddressNV
//         Feature:
//             Name: externalMemoryRDMA
//             Struct: VkPhysicalDeviceExternalMemoryRDMAFeaturesNV
// Extension: VK_EXT_pipeline_properties
// Number: 373
// Type: device
// Author: EXT
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_PIPELINE_PROPERTIES_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_PIPELINE_PROPERTIES_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_pipeline_properties&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PIPELINE_PROPERTIES_IDENTIFIER_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROPERTIES_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PIPELINE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PIPELINE_INFO_KHR
//         Type:
//             Name: VkPipelineInfoEXT
//         Type:
//             Name: VkPipelinePropertiesIdentifierEXT
//         Type:
//             Name: VkPhysicalDevicePipelinePropertiesFeaturesEXT
//         Command:
//             Name: vkGetPipelinePropertiesEXT
//         Feature:
//             Name: pipelinePropertiesIdentifier
//             Struct: VkPhysicalDevicePipelinePropertiesFeaturesEXT
// Extension: VK_NV_external_sci_sync
// Number: 374
// Type: device
// Author: NV
// Depends: VK_VERSION_1_1
// Platform: sci
// Supported: supported
// Deprecated by: VK_NV_external_sci_sync2
// Unlocks:
//         Enum:
//             Name: VK_NV_EXTERNAL_SCI_SYNC_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_NV_EXTERNAL_SCI_SYNC_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_external_sci_sync&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMPORT_FENCE_SCI_SYNC_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_EXPORT_FENCE_SCI_SYNC_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_FENCE_GET_SCI_SYNC_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SCI_SYNC_ATTRIBUTES_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_SCI_SYNC_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 4
//         Enum:
//             Name: VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_SCI_SYNC_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 5
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SEMAPHORE_GET_SCI_SYNC_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 6
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SCI_SYNC_FEATURES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 7
//         Enum:
//             Name: VK_EXTERNAL_FENCE_HANDLE_TYPE_SCI_SYNC_OBJ_BIT_NV
//             Negative: false
//             Bitpos: 4
//             Extends: VkExternalFenceHandleTypeFlagBits
//         Enum:
//             Name: VK_EXTERNAL_FENCE_HANDLE_TYPE_SCI_SYNC_FENCE_BIT_NV
//             Negative: false
//             Bitpos: 5
//             Extends: VkExternalFenceHandleTypeFlagBits
//         Enum:
//             Name: VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SCI_SYNC_OBJ_BIT_NV
//             Negative: false
//             Bitpos: 5
//             Extends: VkExternalSemaphoreHandleTypeFlagBits
//         Type:
//             Name: VkSciSyncClientTypeNV
//         Type:
//             Name: VkSciSyncPrimitiveTypeNV
//         Type:
//             Name: VkExportFenceSciSyncInfoNV
//         Type:
//             Name: VkImportFenceSciSyncInfoNV
//         Type:
//             Name: VkFenceGetSciSyncInfoNV
//         Type:
//             Name: VkSciSyncAttributesInfoNV
//         Type:
//             Name: VkExportSemaphoreSciSyncInfoNV
//         Type:
//             Name: VkImportSemaphoreSciSyncInfoNV
//         Type:
//             Name: VkSemaphoreGetSciSyncInfoNV
//         Type:
//             Name: VkPhysicalDeviceExternalSciSyncFeaturesNV
//         Command:
//             Name: vkGetFenceSciSyncFenceNV
//         Command:
//             Name: vkGetFenceSciSyncObjNV
//         Command:
//             Name: vkImportFenceSciSyncFenceNV
//         Command:
//             Name: vkImportFenceSciSyncObjNV
//         Command:
//             Name: vkGetPhysicalDeviceSciSyncAttributesNV
//         Command:
//             Name: vkGetSemaphoreSciSyncObjNV
//         Command:
//             Name: vkImportSemaphoreSciSyncObjNV
//         Feature:
//             Name: sciSyncFence,sciSyncSemaphore
//             Struct: VkPhysicalDeviceExternalSciSyncFeaturesNV
//         Feature:
//             Name: sciSyncImport,sciSyncExport
//             Struct: VkPhysicalDeviceExternalSciSyncFeaturesNV
// Extension: VK_NV_external_memory_sci_buf
// Number: 375
// Type: device
// Author: NV
// Depends: VK_VERSION_1_1
// Platform: sci
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NV_EXTERNAL_MEMORY_SCI_BUF_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_NV_EXTERNAL_MEMORY_SCI_BUF_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_external_memory_sci_buf&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMPORT_MEMORY_SCI_BUF_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_EXPORT_MEMORY_SCI_BUF_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_MEMORY_GET_SCI_BUF_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_MEMORY_SCI_BUF_PROPERTIES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_SCI_BUF_FEATURES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 4
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SCI_BUF_FEATURES_NV
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_SCI_BUF_FEATURES_NV
//         Enum:
//             Name: VK_EXTERNAL_MEMORY_HANDLE_TYPE_SCI_BUF_BIT_NV
//             Negative: false
//             Bitpos: 13
//             Extends: VkExternalMemoryHandleTypeFlagBits
//         Type:
//             Name: VkExportMemorySciBufInfoNV
//         Type:
//             Name: VkImportMemorySciBufInfoNV
//         Type:
//             Name: VkMemoryGetSciBufInfoNV
//         Type:
//             Name: VkMemorySciBufPropertiesNV
//         Type:
//             Name: VkPhysicalDeviceExternalMemorySciBufFeaturesNV
//         Type:
//             Name: VkPhysicalDeviceExternalSciBufFeaturesNV
//         Command:
//             Name: vkGetMemorySciBufNV
//         Command:
//             Name: vkGetPhysicalDeviceExternalMemorySciBufPropertiesNV
//         Command:
//             Name: vkGetPhysicalDeviceSciBufAttributesNV
//         Feature:
//             Name: sciBufImport,sciBufExport
//             Struct: VkPhysicalDeviceExternalSciBufFeaturesNV
// Extension: VK_EXT_frame_boundary
// Number: 376
// Type: device
// Author: EXT
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_FRAME_BOUNDARY_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_FRAME_BOUNDARY_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_frame_boundary&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAME_BOUNDARY_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Type:
//             Name: VkPhysicalDeviceFrameBoundaryFeaturesEXT
//         Type:
//             Name: VkFrameBoundaryEXT
//         Type:
//             Name: VkFrameBoundaryFlagBitsEXT
//         Type:
//             Name: VkFrameBoundaryFlagsEXT
//         Feature:
//             Name: frameBoundary
//             Struct: VkPhysicalDeviceFrameBoundaryFeaturesEXT
// Extension: VK_EXT_multisampled_render_to_single_sampled
// Number: 377
// Type: device
// Author: EXT
// Depends: (VK_KHR_create_renderpass2+VK_KHR_depth_stencil_resolve),VK_VERSION_1_2
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_multisampled_render_to_single_sampled&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SUBPASS_RESOLVE_PERFORMANCE_QUERY_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_IMAGE_CREATE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_BIT_EXT
//             Negative: false
//             Bitpos: 18
//             Extends: VkImageCreateFlagBits
//         Type:
//             Name: VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT
//         Type:
//             Name: VkSubpassResolvePerformanceQueryEXT
//         Type:
//             Name: VkMultisampledRenderToSingleSampledInfoEXT
//         Feature:
//             Name: multisampledRenderToSingleSampled
//             Struct: VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT
// Extension: VK_EXT_extended_dynamic_state2
// Number: 378
// Type: device
// Author: EXT
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_3
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENDED_DYNAMIC_STATE_2_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_EXTENDED_DYNAMIC_STATE_2_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extended_dynamic_state2&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//             Comment:
//                 Not promoted to 1.3
//         Enum:
//             Name: VK_DYNAMIC_STATE_PATCH_CONTROL_POINTS_EXT
//             Negative: false
//             Extends: VkDynamicState
//             Offset: 0
//             Comment:
//                 Not promoted to 1.3
//         Enum:
//             Name: VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE_EXT
//             Negative: false
//             Extends: VkDynamicState
//             Alias: VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE
//         Enum:
//             Name: VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE_EXT
//             Negative: false
//             Extends: VkDynamicState
//             Alias: VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE
//         Enum:
//             Name: VK_DYNAMIC_STATE_LOGIC_OP_EXT
//             Negative: false
//             Extends: VkDynamicState
//             Offset: 3
//             Comment:
//                 Not promoted to 1.3
//         Enum:
//             Name: VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE_EXT
//             Negative: false
//             Extends: VkDynamicState
//             Alias: VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE
//         Type:
//             Name: VkPhysicalDeviceExtendedDynamicState2FeaturesEXT
//         Command:
//             Name: vkCmdSetPatchControlPointsEXT
//             Comment:
//                 Not promoted to 1.3
//         Command:
//             Name: vkCmdSetRasterizerDiscardEnableEXT
//         Command:
//             Name: vkCmdSetDepthBiasEnableEXT
//         Command:
//             Name: vkCmdSetLogicOpEXT
//             Comment:
//                 Not promoted to 1.3
//         Command:
//             Name: vkCmdSetPrimitiveRestartEnableEXT
//         Feature:
//             Name: extendedDynamicState2
//             Struct: VkPhysicalDeviceExtendedDynamicState2FeaturesEXT
// Extension: VK_QNX_screen_surface
// Number: 379
// Type: instance
// Author: QNX
// Depends: VK_KHR_surface
// Platform: screen
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_QNX_SCREEN_SURFACE_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_QNX_SCREEN_SURFACE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_QNX_screen_surface&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SCREEN_SURFACE_CREATE_INFO_QNX
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkScreenSurfaceCreateFlagsQNX
//         Type:
//             Name: VkScreenSurfaceCreateInfoQNX
//         Command:
//             Name: vkCreateScreenSurfaceQNX
//         Command:
//             Name: vkGetPhysicalDeviceScreenPresentationSupportQNX
// Extension: VK_KHR_extension_380
// Number: 380
// Type: invalid
// Author: KHR
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_KHR_EXTENSION_380_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_KHR_EXTENSION_380_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_extension_380&quot;
//         Enum:
//             Name: VK_SWAPCHAIN_CREATE_RESERVED_5_BIT_EXT
//             Negative: false
//             Bitpos: 5
//             Extends: VkSwapchainCreateFlagBitsKHR
// Extension: VK_KHR_extension_381
// Number: 381
// Type: invalid
// Author: KHR
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_KHR_EXTENSION_381_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_KHR_EXTENSION_381_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_extension_381&quot;
// Extension: VK_EXT_color_write_enable
// Number: 382
// Type: device
// Author: EXT
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_COLOR_WRITE_ENABLE_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_COLOR_WRITE_ENABLE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_color_write_enable&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PIPELINE_COLOR_WRITE_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT
//             Negative: false
//             Extends: VkDynamicState
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceColorWriteEnableFeaturesEXT
//         Type:
//             Name: VkPipelineColorWriteCreateInfoEXT
//         Command:
//             Name: vkCmdSetColorWriteEnableEXT
//         Feature:
//             Name: colorWriteEnable
//             Struct: VkPhysicalDeviceColorWriteEnableFeaturesEXT
// Extension: VK_EXT_primitives_generated_query
// Number: 383
// Type: device
// Author: EXT
// Depends: VK_EXT_transform_feedback
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_PRIMITIVES_GENERATED_QUERY_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_PRIMITIVES_GENERATED_QUERY_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_primitives_generated_query&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT
//             Negative: false
//             Extends: VkQueryType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT
//         Feature:
//             Name: primitivesGeneratedQuery
//             Struct: VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT
// Extension: VK_EXT_extension_384
// Number: 384
// Type: instance
// Author: EXT
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_384_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_384_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_384&quot;
// Extension: VK_MESA_extension_385
// Number: 385
// Type: instance
// Author: MESA
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_MESA_EXTENSION_385_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_MESA_EXTENSION_385_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_MESA_extension_385&quot;
// Extension: VK_GOOGLE_extension_386
// Number: 386
// Type: invalid
// Author: GOOGLE
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_GOOGLE_EXTENSION_386_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_GOOGLE_EXTENSION_386_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_GOOGLE_extension_386&quot;
// Extension: VK_KHR_ray_tracing_maintenance1
// Number: 387
// Type: device
// Author: KHR
// Depends: VK_KHR_acceleration_structure
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_RAY_TRACING_MAINTENANCE_1_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_RAY_TRACING_MAINTENANCE_1_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_ray_tracing_maintenance1&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_BOTTOM_LEVEL_POINTERS_KHR
//             Negative: false
//             Extends: VkQueryType
//             Offset: 0
//         Enum:
//             Name: VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SIZE_KHR
//             Negative: false
//             Extends: VkQueryType
//             Offset: 1
//         Type:
//             Name: VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR
//         Feature:
//             Name: rayTracingMaintenance1
//             Struct: VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR
//     Depends: VK_KHR_synchronization2,VK_VERSION_1_3
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_COPY_BIT_KHR
//             Negative: false
//             Bitpos: 28
//             Extends: VkPipelineStageFlagBits2
//     Depends: (VK_KHR_synchronization2,VK_VERSION_1_3)+VK_KHR_ray_tracing_pipeline
//         Enum:
//             Name: VK_ACCESS_2_SHADER_BINDING_TABLE_READ_BIT_KHR
//             Negative: false
//             Bitpos: 40
//             Extends: VkAccessFlagBits2
//     Depends: VK_KHR_ray_tracing_pipeline
//         Type:
//             Name: VkTraceRaysIndirectCommand2KHR
//         Command:
//             Name: vkCmdTraceRaysIndirect2KHR
//     Depends: VK_EXT_device_generated_commands
//         Enum:
//             Name: VK_INDIRECT_COMMANDS_TOKEN_TYPE_TRACE_RAYS2_EXT
//             Negative: false
//             Extends: VkIndirectCommandsTokenTypeEXT
//             Offset: 4
// Extension: VK_KHR_shader_untyped_pointers
// Number: 388
// Type: device
// Author: KHR
// Depends: VK_KHR_get_physical_device_properties2
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_SHADER_UNTYPED_POINTERS_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_SHADER_UNTYPED_POINTERS_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_shader_untyped_pointers&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_UNTYPED_POINTERS_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceShaderUntypedPointersFeaturesKHR
//         Feature:
//             Name: shaderUntypedPointers
//             Struct: VkPhysicalDeviceShaderUntypedPointersFeaturesKHR
// Extension: VK_EXT_global_priority_query
// Number: 389
// Type: device
// Author: EXT
// Depends: VK_EXT_global_priority+(VK_KHR_get_physical_device_properties2,VK_VERSION_1_1)
// Supported: supported
// Promoted to: VK_KHR_global_priority
// Unlocks:
//         Enum:
//             Name: VK_EXT_GLOBAL_PRIORITY_QUERY_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_GLOBAL_PRIORITY_QUERY_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_global_priority_query&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES
//         Enum:
//             Name: VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES
//         Enum:
//             Name: VK_MAX_GLOBAL_PRIORITY_SIZE_EXT
//             Negative: false
//             Alias: VK_MAX_GLOBAL_PRIORITY_SIZE
//         Type:
//             Name: VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT
//         Type:
//             Name: VkQueueFamilyGlobalPriorityPropertiesEXT
//         Feature:
//             Name: globalPriorityQuery
//             Struct: VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT
// Extension: VK_EXT_extension_390
// Number: 390
// Type: invalid
// Author: EXT
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_390_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_390_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_390&quot;
// Extension: VK_VALVE_video_encode_rgb_conversion
// Number: 391
// Type: device
// Author: VALVE
// Depends: VK_KHR_video_encode_queue+(VK_KHR_sampler_ycbcr_conversion,VK_VERSION_1_1)
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_VALVE_VIDEO_ENCODE_RGB_CONVERSION_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_VALVE_VIDEO_ENCODE_RGB_CONVERSION_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_VALVE_video_encode_rgb_conversion&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_RGB_CONVERSION_FEATURES_VALVE
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_RGB_CONVERSION_CAPABILITIES_VALVE
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_PROFILE_RGB_CONVERSION_INFO_VALVE
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_RGB_CONVERSION_CREATE_INFO_VALVE
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Type:
//             Name: VkPhysicalDeviceVideoEncodeRgbConversionFeaturesVALVE
//         Type:
//             Name: VkVideoEncodeRgbConversionCapabilitiesVALVE
//         Type:
//             Name: VkVideoEncodeProfileRgbConversionInfoVALVE
//         Type:
//             Name: VkVideoEncodeSessionRgbConversionCreateInfoVALVE
//         Type:
//             Name: VkVideoEncodeRgbModelConversionFlagBitsVALVE
//         Type:
//             Name: VkVideoEncodeRgbModelConversionFlagsVALVE
//         Type:
//             Name: VkVideoEncodeRgbRangeCompressionFlagBitsVALVE
//         Type:
//             Name: VkVideoEncodeRgbRangeCompressionFlagsVALVE
//         Type:
//             Name: VkVideoEncodeRgbChromaOffsetFlagBitsVALVE
//         Type:
//             Name: VkVideoEncodeRgbChromaOffsetFlagsVALVE
//         Feature:
//             Name: videoEncodeRgbConversion
//             Struct: VkPhysicalDeviceVideoEncodeRgbConversionFeaturesVALVE
// Extension: VK_EXT_image_view_min_lod
// Number: 392
// Type: device
// Author: EXT
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_IMAGE_VIEW_MIN_LOD_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_IMAGE_VIEW_MIN_LOD_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_image_view_min_lod&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMAGE_VIEW_MIN_LOD_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Type:
//             Name: VkPhysicalDeviceImageViewMinLodFeaturesEXT
//         Type:
//             Name: VkImageViewMinLodCreateInfoEXT
//         Feature:
//             Name: minLod
//             Struct: VkPhysicalDeviceImageViewMinLodFeaturesEXT
// Extension: VK_EXT_multi_draw
// Number: 393
// Type: device
// Author: EXT
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_MULTI_DRAW_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_MULTI_DRAW_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_multi_draw&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Type:
//             Name: VkPhysicalDeviceMultiDrawFeaturesEXT
//         Type:
//             Name: VkPhysicalDeviceMultiDrawPropertiesEXT
//         Command:
//             Name: vkCmdDrawMultiEXT
//         Command:
//             Name: vkCmdDrawMultiIndexedEXT
//         Type:
//             Name: VkMultiDrawInfoEXT
//         Type:
//             Name: VkMultiDrawIndexedInfoEXT
//         Feature:
//             Name: multiDraw
//             Struct: VkPhysicalDeviceMultiDrawFeaturesEXT
// Extension: VK_EXT_image_2d_view_of_3d
// Number: 394
// Type: device
// Author: EXT
// Depends: (VK_KHR_maintenance1+VK_KHR_get_physical_device_properties2),VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_IMAGE_2D_VIEW_OF_3D_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_IMAGE_2D_VIEW_OF_3D_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_image_2d_view_of_3d&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceImage2DViewOf3DFeaturesEXT
//         Enum:
//             Name: VK_IMAGE_CREATE_2D_VIEW_COMPATIBLE_BIT_EXT
//             Negative: false
//             Bitpos: 17
//             Extends: VkImageCreateFlagBits
//             Comment:
//                 Image is created with a layout where individual slices are capable of being used as 2D images
//         Feature:
//             Name: image2DViewOf3D
//             Struct: VkPhysicalDeviceImage2DViewOf3DFeaturesEXT
// Extension: VK_KHR_portability_enumeration
// Number: 395
// Type: instance
// Author: KHR
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_PORTABILITY_ENUMERATION_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_PORTABILITY_ENUMERATION_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_portability_enumeration&quot;
//         Enum:
//             Name: VK_INSTANCE_CREATE_ENUMERATE_PORTABILITY_BIT_KHR
//             Negative: false
//             Bitpos: 0
//             Extends: VkInstanceCreateFlagBits
// Extension: VK_EXT_shader_tile_image
// Number: 396
// Type: device
// Author: EXT
// Depends: VK_VERSION_1_3
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_SHADER_TILE_IMAGE_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_SHADER_TILE_IMAGE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_shader_tile_image&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_PROPERTIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Type:
//             Name: VkPhysicalDeviceShaderTileImageFeaturesEXT
//         Type:
//             Name: VkPhysicalDeviceShaderTileImagePropertiesEXT
//         Feature:
//             Name: shaderTileImageColorReadAccess
//             Struct: VkPhysicalDeviceShaderTileImageFeaturesEXT
// Extension: VK_EXT_opacity_micromap
// Number: 397
// Type: device
// Author: EXT
// Depends: VK_KHR_acceleration_structure+(VK_KHR_synchronization2,VK_VERSION_1_3)
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_OPACITY_MICROMAP_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_EXT_OPACITY_MICROMAP_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_opacity_micromap&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_MICROMAP_BUILD_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_MICROMAP_VERSION_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_COPY_MICROMAP_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_COPY_MICROMAP_TO_MEMORY_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Enum:
//             Name: VK_STRUCTURE_TYPE_COPY_MEMORY_TO_MICROMAP_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 4
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 5
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_PROPERTIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 6
//         Enum:
//             Name: VK_STRUCTURE_TYPE_MICROMAP_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 7
//         Enum:
//             Name: VK_STRUCTURE_TYPE_MICROMAP_BUILD_SIZES_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 8
//         Enum:
//             Name: VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_OPACITY_MICROMAP_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 9
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_MICROMAP_BUILD_BIT_EXT
//             Negative: false
//             Bitpos: 30
//             Extends: VkPipelineStageFlagBits2
//         Enum:
//             Name: VK_ACCESS_2_MICROMAP_READ_BIT_EXT
//             Negative: false
//             Bitpos: 44
//             Extends: VkAccessFlagBits2
//         Enum:
//             Name: VK_ACCESS_2_MICROMAP_WRITE_BIT_EXT
//             Negative: false
//             Bitpos: 45
//             Extends: VkAccessFlagBits2
//         Enum:
//             Name: VK_QUERY_TYPE_MICROMAP_SERIALIZATION_SIZE_EXT
//             Negative: false
//             Extends: VkQueryType
//             Offset: 0
//         Enum:
//             Name: VK_QUERY_TYPE_MICROMAP_COMPACTED_SIZE_EXT
//             Negative: false
//             Extends: VkQueryType
//             Offset: 1
//         Enum:
//             Name: VK_OBJECT_TYPE_MICROMAP_EXT
//             Negative: false
//             Extends: VkObjectType
//             Offset: 0
//         Enum:
//             Name: VK_BUFFER_USAGE_MICROMAP_BUILD_INPUT_READ_ONLY_BIT_EXT
//             Negative: false
//             Bitpos: 23
//             Extends: VkBufferUsageFlagBits
//         Enum:
//             Name: VK_BUFFER_USAGE_MICROMAP_STORAGE_BIT_EXT
//             Negative: false
//             Bitpos: 24
//             Extends: VkBufferUsageFlagBits
//         Enum:
//             Name: VK_PIPELINE_CREATE_RAY_TRACING_OPACITY_MICROMAP_BIT_EXT
//             Negative: false
//             Bitpos: 24
//             Extends: VkPipelineCreateFlagBits
//         Enum:
//             Name: VK_GEOMETRY_INSTANCE_FORCE_OPACITY_MICROMAP_2_STATE_BIT_EXT
//             Negative: false
//             Bitpos: 4
//             Extends: VkGeometryInstanceFlagBitsKHR
//         Enum:
//             Name: VK_GEOMETRY_INSTANCE_FORCE_OPACITY_MICROMAP_2_STATE_EXT
//             Negative: false
//             Extends: VkGeometryInstanceFlagBitsKHR
//             Alias: VK_GEOMETRY_INSTANCE_FORCE_OPACITY_MICROMAP_2_STATE_BIT_EXT
//         Enum:
//             Name: VK_GEOMETRY_INSTANCE_DISABLE_OPACITY_MICROMAPS_BIT_EXT
//             Negative: false
//             Bitpos: 5
//             Extends: VkGeometryInstanceFlagBitsKHR
//         Enum:
//             Name: VK_GEOMETRY_INSTANCE_DISABLE_OPACITY_MICROMAPS_EXT
//             Negative: false
//             Extends: VkGeometryInstanceFlagBitsKHR
//             Alias: VK_GEOMETRY_INSTANCE_DISABLE_OPACITY_MICROMAPS_BIT_EXT
//         Enum:
//             Name: VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_UPDATE_BIT_EXT
//             Negative: false
//             Bitpos: 6
//             Extends: VkBuildAccelerationStructureFlagBitsKHR
//         Enum:
//             Name: VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_UPDATE_EXT
//             Negative: false
//             Extends: VkBuildAccelerationStructureFlagBitsKHR
//             Alias: VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_UPDATE_BIT_EXT
//         Enum:
//             Name: VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DISABLE_OPACITY_MICROMAPS_BIT_EXT
//             Negative: false
//             Bitpos: 7
//             Extends: VkBuildAccelerationStructureFlagBitsKHR
//         Enum:
//             Name: VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DISABLE_OPACITY_MICROMAPS_EXT
//             Negative: false
//             Extends: VkBuildAccelerationStructureFlagBitsKHR
//             Alias: VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DISABLE_OPACITY_MICROMAPS_BIT_EXT
//         Enum:
//             Name: VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_DATA_UPDATE_BIT_EXT
//             Negative: false
//             Bitpos: 8
//             Extends: VkBuildAccelerationStructureFlagBitsKHR
//         Enum:
//             Name: VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_DATA_UPDATE_EXT
//             Negative: false
//             Extends: VkBuildAccelerationStructureFlagBitsKHR
//             Alias: VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_DATA_UPDATE_BIT_EXT
//         Type:
//             Name: VkMicromapTypeEXT
//         Type:
//             Name: VkMicromapBuildInfoEXT
//         Type:
//             Name: VkMicromapUsageEXT
//         Type:
//             Name: VkMicromapCreateInfoEXT
//         Type:
//             Name: VkMicromapEXT
//         Type:
//             Name: VkBuildMicromapFlagBitsEXT
//         Type:
//             Name: VkBuildMicromapFlagsEXT
//         Type:
//             Name: VkCopyMicromapModeEXT
//         Type:
//             Name: VkPhysicalDeviceOpacityMicromapFeaturesEXT
//         Type:
//             Name: VkPhysicalDeviceOpacityMicromapPropertiesEXT
//         Type:
//             Name: VkMicromapVersionInfoEXT
//         Type:
//             Name: VkCopyMicromapToMemoryInfoEXT
//         Type:
//             Name: VkCopyMemoryToMicromapInfoEXT
//         Type:
//             Name: VkCopyMicromapInfoEXT
//         Type:
//             Name: VkMicromapCreateFlagBitsEXT
//         Type:
//             Name: VkMicromapCreateFlagsEXT
//         Type:
//             Name: VkBuildMicromapModeEXT
//         Type:
//             Name: VkMicromapBuildSizesInfoEXT
//         Type:
//             Name: VkOpacityMicromapFormatEXT
//         Type:
//             Name: VkAccelerationStructureTrianglesOpacityMicromapEXT
//         Type:
//             Name: VkMicromapTriangleEXT
//         Type:
//             Name: VkOpacityMicromapSpecialIndexEXT
//         Command:
//             Name: vkCreateMicromapEXT
//         Command:
//             Name: vkDestroyMicromapEXT
//         Command:
//             Name: vkCmdBuildMicromapsEXT
//         Command:
//             Name: vkBuildMicromapsEXT
//         Command:
//             Name: vkCopyMicromapEXT
//         Command:
//             Name: vkCopyMicromapToMemoryEXT
//         Command:
//             Name: vkCopyMemoryToMicromapEXT
//         Command:
//             Name: vkWriteMicromapsPropertiesEXT
//         Command:
//             Name: vkCmdCopyMicromapEXT
//         Command:
//             Name: vkCmdCopyMicromapToMemoryEXT
//         Command:
//             Name: vkCmdCopyMemoryToMicromapEXT
//         Command:
//             Name: vkCmdWriteMicromapsPropertiesEXT
//         Command:
//             Name: vkGetDeviceMicromapCompatibilityEXT
//         Command:
//             Name: vkGetMicromapBuildSizesEXT
//         Feature:
//             Name: micromap
//             Struct: VkPhysicalDeviceOpacityMicromapFeaturesEXT
// Extension: VK_NV_displacement_micromap
// Number: 398
// Type: device
// Author: NV
// Depends: VK_EXT_opacity_micromap
// Platform: provisional
// Supported: supported
// Deprecated by: VK_NV_cluster_acceleration_structure
// Unlocks:
//         Enum:
//             Name: VK_NV_DISPLACEMENT_MICROMAP_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_NV_DISPLACEMENT_MICROMAP_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_displacement_micromap&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISPLACEMENT_MICROMAP_FEATURES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISPLACEMENT_MICROMAP_PROPERTIES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_DISPLACEMENT_MICROMAP_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_PIPELINE_CREATE_RAY_TRACING_DISPLACEMENT_MICROMAP_BIT_NV
//             Negative: false
//             Bitpos: 28
//             Extends: VkPipelineCreateFlagBits
//         Enum:
//             Name: VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DISPLACEMENT_MICROMAP_UPDATE_BIT_NV
//             Negative: false
//             Bitpos: 9
//             Extends: VkBuildAccelerationStructureFlagBitsKHR
//         Enum:
//             Name: VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DISPLACEMENT_MICROMAP_UPDATE_NV
//             Negative: false
//             Extends: VkBuildAccelerationStructureFlagBitsKHR
//             Alias: VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DISPLACEMENT_MICROMAP_UPDATE_BIT_NV
//         Enum:
//             Name: VK_MICROMAP_TYPE_DISPLACEMENT_MICROMAP_NV
//             Negative: false
//             Extends: VkMicromapTypeEXT
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceDisplacementMicromapFeaturesNV
//         Type:
//             Name: VkPhysicalDeviceDisplacementMicromapPropertiesNV
//         Type:
//             Name: VkAccelerationStructureTrianglesDisplacementMicromapNV
//         Type:
//             Name: VkDisplacementMicromapFormatNV
//         Feature:
//             Name: displacementMicromap
//             Struct: VkPhysicalDeviceDisplacementMicromapFeaturesNV
// Extension: VK_JUICE_extension_399
// Number: 399
// Type: invalid
// Author: JUICE
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_JUICE_EXTENSION_399_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_JUICE_EXTENSION_399_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_JUICE_extension_399&quot;
// Extension: VK_JUICE_extension_400
// Number: 400
// Type: invalid
// Author: JUICE
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_JUICE_EXTENSION_400_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_JUICE_EXTENSION_400_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_JUICE_extension_400&quot;
// Extension: VK_EXT_load_store_op_none
// Number: 401
// Type: device
// Author: EXT
// Supported: supported
// Promoted to: VK_KHR_load_store_op_none
// Unlocks:
//         Enum:
//             Name: VK_EXT_LOAD_STORE_OP_NONE_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_LOAD_STORE_OP_NONE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_load_store_op_none&quot;
//         Enum:
//             Name: VK_ATTACHMENT_LOAD_OP_NONE_EXT
//             Negative: false
//             Extends: VkAttachmentLoadOp
//             Alias: VK_ATTACHMENT_LOAD_OP_NONE
//         Enum:
//             Name: VK_ATTACHMENT_STORE_OP_NONE_EXT
//             Negative: false
//             Extends: VkAttachmentStoreOp
//             Alias: VK_ATTACHMENT_STORE_OP_NONE
// Extension: VK_FB_extension_402
// Number: 402
// Type: invalid
// Author: FB
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_FB_EXTENSION_402_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_FB_EXTENSION_402_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_FB_extension_402&quot;
// Extension: VK_FB_extension_403
// Number: 403
// Type: invalid
// Author: FB
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_FB_EXTENSION_403_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_FB_EXTENSION_403_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_FB_extension_403&quot;
// Extension: VK_FB_extension_404
// Number: 404
// Type: invalid
// Author: FB
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_FB_EXTENSION_404_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_FB_EXTENSION_404_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_FB_extension_404&quot;
// Extension: VK_HUAWEI_cluster_culling_shader
// Number: 405
// Type: device
// Author: HUAWEI
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_HUAWEI_CLUSTER_CULLING_SHADER_SPEC_VERSION
//             Negative: false
//             Value: 3
//         Enum:
//             Name: VK_HUAWEI_CLUSTER_CULLING_SHADER_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_HUAWEI_cluster_culling_shader&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_FEATURES_HUAWEI
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_PROPERTIES_HUAWEI
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_VRS_FEATURES_HUAWEI
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_CLUSTER_CULLING_SHADER_BIT_HUAWEI
//             Negative: false
//             Bitpos: 41
//             Extends: VkPipelineStageFlagBits2
//         Enum:
//             Name: VK_SHADER_STAGE_CLUSTER_CULLING_BIT_HUAWEI
//             Negative: false
//             Bitpos: 19
//             Extends: VkShaderStageFlagBits
//         Enum:
//             Name: VK_QUERY_PIPELINE_STATISTIC_CLUSTER_CULLING_SHADER_INVOCATIONS_BIT_HUAWEI
//             Negative: false
//             Bitpos: 13
//             Extends: VkQueryPipelineStatisticFlagBits
//         Command:
//             Name: vkCmdDrawClusterHUAWEI
//         Command:
//             Name: vkCmdDrawClusterIndirectHUAWEI
//         Type:
//             Name: VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI
//         Type:
//             Name: VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI
//         Type:
//             Name: VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI
//         Feature:
//             Name: clustercullingShader
//             Struct: VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI
// Extension: VK_HUAWEI_extension_406
// Number: 406
// Type: invalid
// Author: HUAWEI
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_HUAWEI_EXTENSION_406_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_HUAWEI_EXTENSION_406_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_HUAWEI_extension_406&quot;
// Extension: VK_GGP_extension_407
// Number: 407
// Type: invalid
// Author: GGP
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_GGP_EXTENSION_407_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_GGP_EXTENSION_407_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_GGP_extension_407&quot;
// Extension: VK_GGP_extension_408
// Number: 408
// Type: invalid
// Author: GGP
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_GGP_EXTENSION_408_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_GGP_EXTENSION_408_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_GGP_extension_408&quot;
// Extension: VK_GGP_extension_409
// Number: 409
// Type: invalid
// Author: GGP
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_GGP_EXTENSION_409_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_GGP_EXTENSION_409_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_GGP_extension_409&quot;
// Extension: VK_GGP_extension_410
// Number: 410
// Type: invalid
// Author: GGP
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_GGP_EXTENSION_410_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_GGP_EXTENSION_410_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_GGP_extension_410&quot;
// Extension: VK_GGP_extension_411
// Number: 411
// Type: invalid
// Author: GGP
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_GGP_EXTENSION_411_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_GGP_EXTENSION_411_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_GGP_extension_411&quot;
// Extension: VK_EXT_border_color_swizzle
// Number: 412
// Type: device
// Author: EXT
// Depends: VK_EXT_custom_border_color
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_BORDER_COLOR_SWIZZLE_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_BORDER_COLOR_SWIZZLE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_border_color_swizzle&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Type:
//             Name: VkPhysicalDeviceBorderColorSwizzleFeaturesEXT
//         Type:
//             Name: VkSamplerBorderColorComponentMappingCreateInfoEXT
//         Feature:
//             Name: borderColorSwizzle
//             Struct: VkPhysicalDeviceBorderColorSwizzleFeaturesEXT
// Extension: VK_EXT_pageable_device_local_memory
// Number: 413
// Type: device
// Author: EXT
// Depends: VK_EXT_memory_priority
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_PAGEABLE_DEVICE_LOCAL_MEMORY_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_PAGEABLE_DEVICE_LOCAL_MEMORY_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_pageable_device_local_memory&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT
//         Command:
//             Name: vkSetDeviceMemoryPriorityEXT
//         Feature:
//             Name: pageableDeviceLocalMemory
//             Struct: VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT
// Extension: VK_KHR_maintenance4
// Number: 414
// Type: device
// Author: KHR
// Depends: VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_3
// Unlocks:
//         Enum:
//             Name: VK_KHR_MAINTENANCE_4_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_KHR_MAINTENANCE_4_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_maintenance4&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS
//         Enum:
//             Name: VK_IMAGE_ASPECT_NONE_KHR
//             Negative: false
//             Extends: VkImageAspectFlagBits
//             Alias: VK_IMAGE_ASPECT_NONE
//         Type:
//             Name: VkPhysicalDeviceMaintenance4FeaturesKHR
//         Type:
//             Name: VkPhysicalDeviceMaintenance4PropertiesKHR
//         Type:
//             Name: VkDeviceBufferMemoryRequirementsKHR
//         Type:
//             Name: VkDeviceImageMemoryRequirementsKHR
//         Command:
//             Name: vkGetDeviceBufferMemoryRequirementsKHR
//         Command:
//             Name: vkGetDeviceImageMemoryRequirementsKHR
//         Command:
//             Name: vkGetDeviceImageSparseMemoryRequirementsKHR
//         Feature:
//             Name: maintenance4
//             Struct: VkPhysicalDeviceMaintenance4FeaturesKHR
// Extension: VK_HUAWEI_extension_415
// Number: 415
// Type: invalid
// Author: HUAWEI
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_HUAWEI_EXTENSION_415_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_HUAWEI_EXTENSION_415_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_HUAWEI_extension_415&quot;
// Extension: VK_ARM_shader_core_properties
// Number: 416
// Type: device
// Author: ARM
// Depends: VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_ARM_SHADER_CORE_PROPERTIES_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_ARM_SHADER_CORE_PROPERTIES_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_ARM_shader_core_properties&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceShaderCorePropertiesARM
// Extension: VK_KHR_shader_subgroup_rotate
// Number: 417
// Type: device
// Author: KHR
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_4
// Unlocks:
//         Enum:
//             Name: VK_KHR_SHADER_SUBGROUP_ROTATE_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_KHR_SHADER_SUBGROUP_ROTATE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_shader_subgroup_rotate&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_ROTATE_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_ROTATE_FEATURES
//         Enum:
//             Name: VK_SUBGROUP_FEATURE_ROTATE_BIT_KHR
//             Negative: false
//             Extends: VkSubgroupFeatureFlagBits
//             Alias: VK_SUBGROUP_FEATURE_ROTATE_BIT
//         Enum:
//             Name: VK_SUBGROUP_FEATURE_ROTATE_CLUSTERED_BIT_KHR
//             Negative: false
//             Extends: VkSubgroupFeatureFlagBits
//             Alias: VK_SUBGROUP_FEATURE_ROTATE_CLUSTERED_BIT
//         Type:
//             Name: VkPhysicalDeviceShaderSubgroupRotateFeaturesKHR
//         Feature:
//             Name: shaderSubgroupRotate
//             Struct: VkPhysicalDeviceShaderSubgroupRotateFeaturesKHR
// Extension: VK_ARM_scheduling_controls
// Number: 418
// Type: device
// Author: ARM
// Depends: VK_ARM_shader_core_builtins
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_ARM_SCHEDULING_CONTROLS_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_ARM_SCHEDULING_CONTROLS_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_ARM_scheduling_controls&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DEVICE_QUEUE_SHADER_CORE_CONTROL_CREATE_INFO_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_FEATURES_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_PROPERTIES_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Type:
//             Name: VkDeviceQueueShaderCoreControlCreateInfoARM
//         Type:
//             Name: VkPhysicalDeviceSchedulingControlsFeaturesARM
//         Type:
//             Name: VkPhysicalDeviceSchedulingControlsPropertiesARM
//         Type:
//             Name: VkPhysicalDeviceSchedulingControlsFlagsARM
//         Type:
//             Name: VkPhysicalDeviceSchedulingControlsFlagBitsARM
//         Feature:
//             Name: schedulingControls
//             Struct: VkPhysicalDeviceSchedulingControlsFeaturesARM
// Extension: VK_EXT_image_sliced_view_of_3d
// Number: 419
// Type: device
// Author: EXT
// Depends: (VK_KHR_maintenance1+VK_KHR_get_physical_device_properties2),VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_IMAGE_SLICED_VIEW_OF_3D_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_IMAGE_SLICED_VIEW_OF_3D_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_image_sliced_view_of_3d&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_SLICED_VIEW_OF_3D_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMAGE_VIEW_SLICED_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_REMAINING_3D_SLICES_EXT
//             Negative: false
//         Type:
//             Name: VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT
//         Type:
//             Name: VkImageViewSlicedCreateInfoEXT
//         Feature:
//             Name: imageSlicedViewOf3D
//             Struct: VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT
// Extension: VK_EXT_extension_420
// Number: 420
// Type: device
// Author: EXT
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_420_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_420_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_420&quot;
//         Enum:
//             Name: VK_SWAPCHAIN_CREATE_RESERVED_4_BIT_EXT
//             Negative: false
//             Bitpos: 4
//             Extends: VkSwapchainCreateFlagBitsKHR
// Extension: VK_VALVE_descriptor_set_host_mapping
// Number: 421
// Type: device
// Author: VALVE
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_VALVE_DESCRIPTOR_SET_HOST_MAPPING_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_VALVE_DESCRIPTOR_SET_HOST_MAPPING_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_VALVE_descriptor_set_host_mapping&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DESCRIPTOR_SET_BINDING_REFERENCE_VALVE
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_HOST_MAPPING_INFO_VALVE
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Type:
//             Name: VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE
//         Type:
//             Name: VkDescriptorSetBindingReferenceVALVE
//         Type:
//             Name: VkDescriptorSetLayoutHostMappingInfoVALVE
//         Command:
//             Name: vkGetDescriptorSetLayoutHostMappingInfoVALVE
//         Command:
//             Name: vkGetDescriptorSetHostMappingVALVE
//         Feature:
//             Name: descriptorSetHostMapping
//             Struct: VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE
// Extension: VK_EXT_depth_clamp_zero_one
// Number: 422
// Type: device
// Author: EXT
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_KHR_depth_clamp_zero_one
// Unlocks:
//         Enum:
//             Name: VK_EXT_DEPTH_CLAMP_ZERO_ONE_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_DEPTH_CLAMP_ZERO_ONE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_depth_clamp_zero_one&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_KHR
//         Type:
//             Name: VkPhysicalDeviceDepthClampZeroOneFeaturesEXT
//         Feature:
//             Name: depthClampZeroOne
//             Struct: VkPhysicalDeviceDepthClampZeroOneFeaturesEXT
// Extension: VK_EXT_non_seamless_cube_map
// Number: 423
// Type: device
// Author: EXT
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_NON_SEAMLESS_CUBE_MAP_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_NON_SEAMLESS_CUBE_MAP_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_non_seamless_cube_map&quot;
//         Enum:
//             Name: VK_SAMPLER_CREATE_NON_SEAMLESS_CUBE_MAP_BIT_EXT
//             Negative: false
//             Bitpos: 2
//             Extends: VkSamplerCreateFlagBits
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT
//         Feature:
//             Name: nonSeamlessCubeMap
//             Struct: VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT
// Extension: VK_ARM_extension_424
// Number: 424
// Type: invalid
// Author: ARM
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_ARM_EXTENSION_424_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_ARM_EXTENSION_424_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_ARM_extension_424&quot;
// Extension: VK_ARM_render_pass_striped
// Number: 425
// Type: device
// Author: ARM
// Depends: ((VK_KHR_get_physical_device_properties2,VK_VERSION_1_1)+VK_KHR_synchronization2),VK_VERSION_1_3
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_ARM_RENDER_PASS_STRIPED_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_ARM_RENDER_PASS_STRIPED_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_ARM_render_pass_striped&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_FEATURES_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_PROPERTIES_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_BEGIN_INFO_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_INFO_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Enum:
//             Name: VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_SUBMIT_INFO_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 4
//         Type:
//             Name: VkPhysicalDeviceRenderPassStripedFeaturesARM
//         Type:
//             Name: VkPhysicalDeviceRenderPassStripedPropertiesARM
//         Type:
//             Name: VkRenderPassStripeBeginInfoARM
//         Type:
//             Name: VkRenderPassStripeInfoARM
//         Type:
//             Name: VkRenderPassStripeSubmitInfoARM
//         Feature:
//             Name: renderPassStriped
//             Struct: VkPhysicalDeviceRenderPassStripedFeaturesARM
// Extension: VK_QCOM_fragment_density_map_offset
// Number: 426
// Type: device
// Author: QCOM
// Depends: (VK_KHR_get_physical_device_properties2,VK_VERSION_1_1)+VK_EXT_fragment_density_map
// Supported: supported
// Promoted to: VK_EXT_fragment_density_map_offset
// Unlocks:
//         Enum:
//             Name: VK_QCOM_FRAGMENT_DENSITY_MAP_OFFSET_SPEC_VERSION
//             Negative: false
//             Value: 3
//         Enum:
//             Name: VK_QCOM_FRAGMENT_DENSITY_MAP_OFFSET_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_QCOM_fragment_density_map_offset&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_QCOM
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_EXT
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_QCOM
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_EXT
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SUBPASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_QCOM
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_EXT
//         Enum:
//             Name: VK_IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_QCOM
//             Negative: false
//             Extends: VkImageCreateFlagBits
//             Alias: VK_IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_EXT
//         Type:
//             Name: VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM
//         Type:
//             Name: VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM
//         Type:
//             Name: VkSubpassFragmentDensityMapOffsetEndInfoQCOM
//         Feature:
//             Name: fragmentDensityMapOffset
//             Struct: VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM
// Extension: VK_NV_copy_memory_indirect
// Number: 427
// Type: device
// Author: NV
// Depends: ((VK_KHR_get_physical_device_properties2,VK_VERSION_1_1)+VK_KHR_buffer_device_address),VK_VERSION_1_2
// Supported: supported
// Promoted to: VK_KHR_copy_memory_indirect
// Unlocks:
//         Enum:
//             Name: VK_NV_COPY_MEMORY_INDIRECT_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_NV_COPY_MEMORY_INDIRECT_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_copy_memory_indirect&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_FEATURES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_PROPERTIES_NV
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_PROPERTIES_KHR
//         Type:
//             Name: VkCopyMemoryIndirectCommandNV
//         Type:
//             Name: VkCopyMemoryToImageIndirectCommandNV
//         Type:
//             Name: VkPhysicalDeviceCopyMemoryIndirectFeaturesNV
//         Type:
//             Name: VkPhysicalDeviceCopyMemoryIndirectPropertiesNV
//         Command:
//             Name: vkCmdCopyMemoryIndirectNV
//         Command:
//             Name: vkCmdCopyMemoryToImageIndirectNV
//         Feature:
//             Name: indirectCopy
//             Struct: VkPhysicalDeviceCopyMemoryIndirectFeaturesNV
// Extension: VK_NV_memory_decompression
// Number: 428
// Type: device
// Author: NV
// Depends: ((VK_KHR_get_physical_device_properties2,VK_VERSION_1_1)+VK_KHR_buffer_device_address),VK_VERSION_1_2
// Supported: supported
// Promoted to: VK_EXT_memory_decompression
// Unlocks:
//         Enum:
//             Name: VK_NV_MEMORY_DECOMPRESSION_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_NV_MEMORY_DECOMPRESSION_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_memory_decompression&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_FEATURES_NV
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_FEATURES_EXT
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_PROPERTIES_NV
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_PROPERTIES_EXT
//         Type:
//             Name: VkMemoryDecompressionMethodFlagBitsNV
//         Type:
//             Name: VkMemoryDecompressionMethodFlagsNV
//         Type:
//             Name: VkDecompressMemoryRegionNV
//         Type:
//             Name: VkPhysicalDeviceMemoryDecompressionFeaturesNV
//         Type:
//             Name: VkPhysicalDeviceMemoryDecompressionPropertiesNV
//         Command:
//             Name: vkCmdDecompressMemoryNV
//         Command:
//             Name: vkCmdDecompressMemoryIndirectCountNV
//         Feature:
//             Name: memoryDecompression
//             Struct: VkPhysicalDeviceMemoryDecompressionFeaturesNV
// Extension: VK_NV_device_generated_commands_compute
// Number: 429
// Type: device
// Author: NV
// Depends: VK_NV_device_generated_commands
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NV_DEVICE_GENERATED_COMMANDS_COMPUTE_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_NV_DEVICE_GENERATED_COMMANDS_COMPUTE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_device_generated_commands_compute&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_COMPUTE_FEATURES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_INDIRECT_BUFFER_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PIPELINE_INDIRECT_DEVICE_ADDRESS_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_INDIRECT_COMMANDS_TOKEN_TYPE_PIPELINE_NV
//             Negative: false
//             Extends: VkIndirectCommandsTokenTypeNV
//             Offset: 3
//         Enum:
//             Name: VK_INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_NV
//             Negative: false
//             Extends: VkIndirectCommandsTokenTypeNV
//             Offset: 4
//         Enum:
//             Name: VK_DESCRIPTOR_SET_LAYOUT_CREATE_INDIRECT_BINDABLE_BIT_NV
//             Negative: false
//             Bitpos: 7
//             Extends: VkDescriptorSetLayoutCreateFlagBits
//         Type:
//             Name: VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV
//         Type:
//             Name: VkComputePipelineIndirectBufferInfoNV
//         Type:
//             Name: VkPipelineIndirectDeviceAddressInfoNV
//         Type:
//             Name: VkBindPipelineIndirectCommandNV
//         Command:
//             Name: vkGetPipelineIndirectMemoryRequirementsNV
//         Command:
//             Name: vkCmdUpdatePipelineIndirectBufferNV
//         Command:
//             Name: vkGetPipelineIndirectDeviceAddressNV
//         Feature:
//             Name: deviceGeneratedCompute
//             Struct: VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV
// Extension: VK_NV_ray_tracing_linear_swept_spheres
// Number: 430
// Type: device
// Author: NV
// Depends: VK_KHR_ray_tracing_pipeline
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NV_RAY_TRACING_LINEAR_SWEPT_SPHERES_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_NV_RAY_TRACING_LINEAR_SWEPT_SPHERES_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_ray_tracing_linear_swept_spheres&quot;
//         Enum:
//             Name: VK_GEOMETRY_TYPE_SPHERES_NV
//             Negative: false
//             Extends: VkGeometryTypeKHR
//             Offset: 4
//         Enum:
//             Name: VK_GEOMETRY_TYPE_LINEAR_SWEPT_SPHERES_NV
//             Negative: false
//             Extends: VkGeometryTypeKHR
//             Offset: 5
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_LINEAR_SWEPT_SPHERES_FEATURES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 8
//         Enum:
//             Name: VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_LINEAR_SWEPT_SPHERES_DATA_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 9
//         Enum:
//             Name: VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_SPHERES_DATA_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 10
//         Enum:
//             Name: VK_PIPELINE_CREATE_2_RAY_TRACING_ALLOW_SPHERES_AND_LINEAR_SWEPT_SPHERES_BIT_NV
//             Negative: false
//             Bitpos: 33
//             Extends: VkPipelineCreateFlagBits2
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_ACCELERATION_STRUCTURE_RADIUS_BUFFER_BIT_NV
//             Negative: false
//             Bitpos: 51
//             Extends: VkFormatFeatureFlagBits2
//         Type:
//             Name: VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV
//         Type:
//             Name: VkAccelerationStructureGeometryLinearSweptSpheresDataNV
//         Type:
//             Name: VkAccelerationStructureGeometrySpheresDataNV
//         Type:
//             Name: VkRayTracingLssIndexingModeNV
//         Type:
//             Name: VkRayTracingLssPrimitiveEndCapsModeNV
//         Feature:
//             Name: spheres,linearSweptSpheres
//             Struct: VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV
// Extension: VK_NV_linear_color_attachment
// Number: 431
// Type: device
// Author: NVIDIA
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NV_LINEAR_COLOR_ATTACHMENT_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_NV_LINEAR_COLOR_ATTACHMENT_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_linear_color_attachment&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINEAR_COLOR_ATTACHMENT_FEATURES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceLinearColorAttachmentFeaturesNV
//         Feature:
//             Name: linearColorAttachment
//             Struct: VkPhysicalDeviceLinearColorAttachmentFeaturesNV
//     Depends: VK_KHR_format_feature_flags2,VK_VERSION_1_3
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_LINEAR_COLOR_ATTACHMENT_BIT_NV
//             Negative: false
//             Bitpos: 38
//             Extends: VkFormatFeatureFlagBits2
//             Comment:
//                 Format support linear image as render target, it cannot be mixed with non linear attachment
// Extension: VK_NV_extension_432
// Number: 432
// Type: invalid
// Author: NV
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_NV_EXTENSION_432_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_NV_EXTENSION_432_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_extension_432&quot;
// Extension: VK_NV_extension_433
// Number: 433
// Type: invalid
// Author: NV
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_NV_EXTENSION_433_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_NV_EXTENSION_433_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_extension_433&quot;
// Extension: VK_GOOGLE_surfaceless_query
// Number: 434
// Type: instance
// Author: GOOGLE
// Depends: VK_KHR_surface
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_GOOGLE_SURFACELESS_QUERY_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_GOOGLE_SURFACELESS_QUERY_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_GOOGLE_surfaceless_query&quot;
// Extension: VK_KHR_shader_maximal_reconvergence
// Number: 435
// Type: device
// Author: KHR
// Depends: VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_SHADER_MAXIMAL_RECONVERGENCE_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_SHADER_MAXIMAL_RECONVERGENCE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_shader_maximal_reconvergence&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MAXIMAL_RECONVERGENCE_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR
//         Feature:
//             Name: shaderMaximalReconvergence
//             Struct: VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR
// Extension: VK_EXT_application_parameters
// Number: 436
// Type: instance
// Author: EXT
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_APPLICATION_PARAMETERS_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_APPLICATION_PARAMETERS_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_application_parameters&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_APPLICATION_PARAMETERS_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkApplicationParametersEXT
// Extension: VK_EXT_extension_437
// Number: 437
// Type: invalid
// Author: EXT
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_437_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_437_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_437&quot;
// Extension: VK_EXT_image_compression_control_swapchain
// Number: 438
// Type: device
// Author: EXT
// Depends: VK_EXT_image_compression_control
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_image_compression_control_swapchain&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT
//         Feature:
//             Name: imageCompressionControlSwapchain
//             Struct: VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT
// Extension: VK_SEC_extension_439
// Number: 439
// Type: invalid
// Author: SEC
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_SEC_EXTENSION_439_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_SEC_EXTENSION_439_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_SEC_extension_439&quot;
// Extension: VK_QCOM_extension_440
// Number: 440
// Type: invalid
// Author: QCOM
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_QCOM_EXTENSION_440_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_QCOM_EXTENSION_440_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_QCOM_extension_440&quot;
//         Enum:
//             Name: VK_QUEUE_RESERVED_7_BIT_QCOM
//             Negative: false
//             Bitpos: 7
//             Extends: VkQueueFlagBits
//         Enum:
//             Name: VK_DEVICE_QUEUE_CREATE_RESERVED_1_BIT_QCOM
//             Negative: false
//             Bitpos: 1
//             Extends: VkDeviceQueueCreateFlagBits
// Extension: VK_QCOM_image_processing
// Number: 441
// Type: device
// Author: QCOM
// Depends: VK_KHR_format_feature_flags2,VK_VERSION_1_3
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_QCOM_IMAGE_PROCESSING_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_QCOM_IMAGE_PROCESSING_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_QCOM_image_processing&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_FEATURES_QCOM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_PROPERTIES_QCOM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMAGE_VIEW_SAMPLE_WEIGHT_CREATE_INFO_QCOM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM
//             Negative: false
//             Bitpos: 4
//             Extends: VkSamplerCreateFlagBits
//         Enum:
//             Name: VK_IMAGE_USAGE_SAMPLE_WEIGHT_BIT_QCOM
//             Negative: false
//             Bitpos: 20
//             Extends: VkImageUsageFlagBits
//         Enum:
//             Name: VK_IMAGE_USAGE_SAMPLE_BLOCK_MATCH_BIT_QCOM
//             Negative: false
//             Bitpos: 21
//             Extends: VkImageUsageFlagBits
//         Enum:
//             Name: VK_DESCRIPTOR_TYPE_SAMPLE_WEIGHT_IMAGE_QCOM
//             Negative: false
//             Extends: VkDescriptorType
//             Offset: 0
//         Enum:
//             Name: VK_DESCRIPTOR_TYPE_BLOCK_MATCH_IMAGE_QCOM
//             Negative: false
//             Extends: VkDescriptorType
//             Offset: 1
//         Type:
//             Name: VkImageViewSampleWeightCreateInfoQCOM
//         Type:
//             Name: VkPhysicalDeviceImageProcessingFeaturesQCOM
//         Type:
//             Name: VkPhysicalDeviceImageProcessingPropertiesQCOM
//         Feature:
//             Name: textureSampleWeighted
//             Struct: VkPhysicalDeviceImageProcessingFeaturesQCOM
//         Feature:
//             Name: textureBlockMatch
//             Struct: VkPhysicalDeviceImageProcessingFeaturesQCOM
//         Feature:
//             Name: textureBoxFilter
//             Struct: VkPhysicalDeviceImageProcessingFeaturesQCOM
//     Depends: VK_KHR_format_feature_flags2,VK_VERSION_1_3
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_WEIGHT_IMAGE_BIT_QCOM
//             Negative: false
//             Bitpos: 34
//             Extends: VkFormatFeatureFlagBits2
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_WEIGHT_SAMPLED_IMAGE_BIT_QCOM
//             Negative: false
//             Bitpos: 35
//             Extends: VkFormatFeatureFlagBits2
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM
//             Negative: false
//             Bitpos: 36
//             Extends: VkFormatFeatureFlagBits2
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_BOX_FILTER_SAMPLED_BIT_QCOM
//             Negative: false
//             Bitpos: 37
//             Extends: VkFormatFeatureFlagBits2
// Extension: VK_COREAVI_extension_442
// Number: 442
// Type: invalid
// Author: COREAVI
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_COREAVI_EXTENSION_442_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_COREAVI_EXTENSION_442_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_COREAVI_extension_442&quot;
// Extension: VK_COREAVI_extension_443
// Number: 443
// Type: invalid
// Author: COREAVI
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_COREAVI_EXTENSION_443_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_COREAVI_EXTENSION_443_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_COREAVI_extension_443&quot;
// Extension: VK_COREAVI_extension_444
// Number: 444
// Type: invalid
// Author: COREAVI
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_COREAVI_EXTENSION_444_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_COREAVI_EXTENSION_444_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_COREAVI_extension_444&quot;
//         Enum:
//             Name: VK_COMMAND_POOL_RESET_RESERVED_1_BIT_COREAVI
//             Negative: false
//             Bitpos: 1
//             Extends: VkCommandPoolResetFlagBits
// Extension: VK_COREAVI_extension_445
// Number: 445
// Type: invalid
// Author: COREAVI
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_COREAVI_EXTENSION_445_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_COREAVI_EXTENSION_445_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_COREAVI_extension_445&quot;
// Extension: VK_COREAVI_extension_446
// Number: 446
// Type: invalid
// Author: COREAVI
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_COREAVI_EXTENSION_446_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_COREAVI_EXTENSION_446_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_COREAVI_extension_446&quot;
//         Enum:
//             Name: VK_IMAGE_USAGE_RESERVED_24_BIT_COREAVI
//             Negative: false
//             Bitpos: 24
//             Extends: VkImageUsageFlagBits
// Extension: VK_COREAVI_extension_447
// Number: 447
// Type: invalid
// Author: COREAVI
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_COREAVI_EXTENSION_447_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_COREAVI_EXTENSION_447_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_COREAVI_extension_447&quot;
// Extension: VK_SEC_extension_448
// Number: 448
// Type: invalid
// Author: SEC
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_SEC_EXTENSION_448_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_SEC_EXTENSION_448_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_SEC_extension_448&quot;
// Extension: VK_SEC_extension_449
// Number: 449
// Type: invalid
// Author: SEC
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_SEC_EXTENSION_449_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_SEC_EXTENSION_449_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_SEC_extension_449&quot;
// Extension: VK_SEC_extension_450
// Number: 450
// Type: invalid
// Author: SEC
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_SEC_EXTENSION_450_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_SEC_EXTENSION_450_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_SEC_extension_450&quot;
// Extension: VK_SEC_extension_451
// Number: 451
// Type: invalid
// Author: SEC
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_SEC_EXTENSION_451_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_SEC_EXTENSION_451_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_SEC_extension_451&quot;
// Extension: VK_EXT_nested_command_buffer
// Number: 452
// Type: device
// Author: EXT
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_NESTED_COMMAND_BUFFER_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_NESTED_COMMAND_BUFFER_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_nested_command_buffer&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_PROPERTIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_SUBPASS_CONTENTS_INLINE_AND_SECONDARY_COMMAND_BUFFERS_EXT
//             Negative: false
//             Extends: VkSubpassContents
//             Alias: VK_SUBPASS_CONTENTS_INLINE_AND_SECONDARY_COMMAND_BUFFERS_KHR
//         Enum:
//             Name: VK_RENDERING_CONTENTS_INLINE_BIT_EXT
//             Negative: false
//             Extends: VkRenderingFlagBits
//             Alias: VK_RENDERING_CONTENTS_INLINE_BIT_KHR
//         Type:
//             Name: VkPhysicalDeviceNestedCommandBufferFeaturesEXT
//         Type:
//             Name: VkPhysicalDeviceNestedCommandBufferPropertiesEXT
//         Feature:
//             Name: nestedCommandBuffer
//             Struct: VkPhysicalDeviceNestedCommandBufferFeaturesEXT
// Extension: VK_OHOS_external_memory
// Number: 453
// Type: device
// Author: HUAWEI
// Depends: ((VK_KHR_sampler_ycbcr_conversion+VK_KHR_external_memory+VK_KHR_dedicated_allocation),VK_VERSION_1_1)+VK_EXT_queue_family_foreign
// Platform: ohos
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_OHOS_EXTERNAL_MEMORY_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_OHOS_EXTERNAL_MEMORY_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_OHOS_external_memory&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_NATIVE_BUFFER_USAGE_OHOS
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_NATIVE_BUFFER_PROPERTIES_OHOS
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_NATIVE_BUFFER_FORMAT_PROPERTIES_OHOS
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMPORT_NATIVE_BUFFER_INFO_OHOS
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Enum:
//             Name: VK_STRUCTURE_TYPE_MEMORY_GET_NATIVE_BUFFER_INFO_OHOS
//             Negative: false
//             Extends: VkStructureType
//             Offset: 4
//         Enum:
//             Name: VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_OHOS
//             Negative: false
//             Extends: VkStructureType
//             Offset: 5
//         Type:
//             Name: VkNativeBufferUsageOHOS
//         Type:
//             Name: VkNativeBufferPropertiesOHOS
//         Type:
//             Name: VkNativeBufferFormatPropertiesOHOS
//         Type:
//             Name: VkImportNativeBufferInfoOHOS
//         Type:
//             Name: VkMemoryGetNativeBufferInfoOHOS
//         Type:
//             Name: VkExternalFormatOHOS
//         Type:
//             Name: OH_NativeBuffer
//         Enum:
//             Name: VK_EXTERNAL_MEMORY_HANDLE_TYPE_OH_NATIVE_BUFFER_BIT_OHOS
//             Negative: false
//             Bitpos: 15
//             Extends: VkExternalMemoryHandleTypeFlagBits
//         Command:
//             Name: vkGetNativeBufferPropertiesOHOS
//         Command:
//             Name: vkGetMemoryNativeBufferOHOS
// Extension: VK_EXT_external_memory_acquire_unmodified
// Number: 454
// Type: device
// Author: EXT
// Depends: VK_KHR_external_memory,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_external_memory_acquire_unmodified&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkExternalMemoryAcquireUnmodifiedEXT
// Extension: VK_GOOGLE_extension_455
// Number: 455
// Type: invalid
// Author: GOOGLE
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_GOOGLE_EXTENSION_455_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_GOOGLE_EXTENSION_455_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_GOOGLE_extension_455&quot;
// Extension: VK_EXT_extended_dynamic_state3
// Number: 456
// Type: device
// Author: NV
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENDED_DYNAMIC_STATE_3_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_EXT_EXTENDED_DYNAMIC_STATE_3_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extended_dynamic_state3&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_PROPERTIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_DYNAMIC_STATE_DEPTH_CLAMP_ENABLE_EXT
//             Negative: false
//             Extends: VkDynamicState
//             Offset: 3
//         Enum:
//             Name: VK_DYNAMIC_STATE_POLYGON_MODE_EXT
//             Negative: false
//             Extends: VkDynamicState
//             Offset: 4
//         Enum:
//             Name: VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT
//             Negative: false
//             Extends: VkDynamicState
//             Offset: 5
//         Enum:
//             Name: VK_DYNAMIC_STATE_SAMPLE_MASK_EXT
//             Negative: false
//             Extends: VkDynamicState
//             Offset: 6
//         Enum:
//             Name: VK_DYNAMIC_STATE_ALPHA_TO_COVERAGE_ENABLE_EXT
//             Negative: false
//             Extends: VkDynamicState
//             Offset: 7
//         Enum:
//             Name: VK_DYNAMIC_STATE_ALPHA_TO_ONE_ENABLE_EXT
//             Negative: false
//             Extends: VkDynamicState
//             Offset: 8
//         Enum:
//             Name: VK_DYNAMIC_STATE_LOGIC_OP_ENABLE_EXT
//             Negative: false
//             Extends: VkDynamicState
//             Offset: 9
//         Enum:
//             Name: VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT
//             Negative: false
//             Extends: VkDynamicState
//             Offset: 10
//         Enum:
//             Name: VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT
//             Negative: false
//             Extends: VkDynamicState
//             Offset: 11
//         Enum:
//             Name: VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT
//             Negative: false
//             Extends: VkDynamicState
//             Offset: 12
//         Type:
//             Name: VkPhysicalDeviceExtendedDynamicState3FeaturesEXT
//         Type:
//             Name: VkPhysicalDeviceExtendedDynamicState3PropertiesEXT
//         Type:
//             Name: VkColorBlendEquationEXT
//         Type:
//             Name: VkColorBlendAdvancedEXT
//         Command:
//             Name: vkCmdSetDepthClampEnableEXT
//         Command:
//             Name: vkCmdSetPolygonModeEXT
//         Command:
//             Name: vkCmdSetRasterizationSamplesEXT
//         Command:
//             Name: vkCmdSetSampleMaskEXT
//         Command:
//             Name: vkCmdSetAlphaToCoverageEnableEXT
//         Command:
//             Name: vkCmdSetAlphaToOneEnableEXT
//         Command:
//             Name: vkCmdSetLogicOpEnableEXT
//         Command:
//             Name: vkCmdSetColorBlendEnableEXT
//         Command:
//             Name: vkCmdSetColorBlendEquationEXT
//         Command:
//             Name: vkCmdSetColorWriteMaskEXT
//     Depends: VK_KHR_maintenance2,VK_VERSION_1_1
//         Enum:
//             Name: VK_DYNAMIC_STATE_TESSELLATION_DOMAIN_ORIGIN_EXT
//             Negative: false
//             Extends: VkDynamicState
//             Offset: 2
//         Command:
//             Name: vkCmdSetTessellationDomainOriginEXT
//     Depends: VK_EXT_transform_feedback
//         Enum:
//             Name: VK_DYNAMIC_STATE_RASTERIZATION_STREAM_EXT
//             Negative: false
//             Extends: VkDynamicState
//             Offset: 13
//         Command:
//             Name: vkCmdSetRasterizationStreamEXT
//     Depends: VK_EXT_conservative_rasterization
//         Enum:
//             Name: VK_DYNAMIC_STATE_CONSERVATIVE_RASTERIZATION_MODE_EXT
//             Negative: false
//             Extends: VkDynamicState
//             Offset: 14
//         Enum:
//             Name: VK_DYNAMIC_STATE_EXTRA_PRIMITIVE_OVERESTIMATION_SIZE_EXT
//             Negative: false
//             Extends: VkDynamicState
//             Offset: 15
//         Command:
//             Name: vkCmdSetConservativeRasterizationModeEXT
//         Command:
//             Name: vkCmdSetExtraPrimitiveOverestimationSizeEXT
//     Depends: VK_EXT_depth_clip_enable
//         Enum:
//             Name: VK_DYNAMIC_STATE_DEPTH_CLIP_ENABLE_EXT
//             Negative: false
//             Extends: VkDynamicState
//             Offset: 16
//         Command:
//             Name: vkCmdSetDepthClipEnableEXT
//     Depends: VK_EXT_sample_locations
//         Enum:
//             Name: VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT
//             Negative: false
//             Extends: VkDynamicState
//             Offset: 17
//         Command:
//             Name: vkCmdSetSampleLocationsEnableEXT
//     Depends: VK_EXT_blend_operation_advanced
//         Enum:
//             Name: VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT
//             Negative: false
//             Extends: VkDynamicState
//             Offset: 18
//         Command:
//             Name: vkCmdSetColorBlendAdvancedEXT
//     Depends: VK_EXT_provoking_vertex
//         Enum:
//             Name: VK_DYNAMIC_STATE_PROVOKING_VERTEX_MODE_EXT
//             Negative: false
//             Extends: VkDynamicState
//             Offset: 19
//         Command:
//             Name: vkCmdSetProvokingVertexModeEXT
//     Depends: VK_EXT_line_rasterization
//         Enum:
//             Name: VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT
//             Negative: false
//             Extends: VkDynamicState
//             Offset: 20
//         Enum:
//             Name: VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT
//             Negative: false
//             Extends: VkDynamicState
//             Offset: 21
//         Command:
//             Name: vkCmdSetLineRasterizationModeEXT
//         Command:
//             Name: vkCmdSetLineStippleEnableEXT
//     Depends: VK_EXT_depth_clip_control
//         Enum:
//             Name: VK_DYNAMIC_STATE_DEPTH_CLIP_NEGATIVE_ONE_TO_ONE_EXT
//             Negative: false
//             Extends: VkDynamicState
//             Offset: 22
//         Command:
//             Name: vkCmdSetDepthClipNegativeOneToOneEXT
//     Depends: VK_NV_clip_space_w_scaling
//         Enum:
//             Name: VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_ENABLE_NV
//             Negative: false
//             Extends: VkDynamicState
//             Offset: 23
//         Command:
//             Name: vkCmdSetViewportWScalingEnableNV
//     Depends: VK_NV_viewport_swizzle
//         Enum:
//             Name: VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV
//             Negative: false
//             Extends: VkDynamicState
//             Offset: 24
//         Command:
//             Name: vkCmdSetViewportSwizzleNV
//     Depends: VK_NV_fragment_coverage_to_color
//         Enum:
//             Name: VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV
//             Negative: false
//             Extends: VkDynamicState
//             Offset: 25
//         Enum:
//             Name: VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_LOCATION_NV
//             Negative: false
//             Extends: VkDynamicState
//             Offset: 26
//         Command:
//             Name: vkCmdSetCoverageToColorEnableNV
//         Command:
//             Name: vkCmdSetCoverageToColorLocationNV
//     Depends: VK_NV_framebuffer_mixed_samples
//         Enum:
//             Name: VK_DYNAMIC_STATE_COVERAGE_MODULATION_MODE_NV
//             Negative: false
//             Extends: VkDynamicState
//             Offset: 27
//         Enum:
//             Name: VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_ENABLE_NV
//             Negative: false
//             Extends: VkDynamicState
//             Offset: 28
//         Enum:
//             Name: VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_NV
//             Negative: false
//             Extends: VkDynamicState
//             Offset: 29
//         Command:
//             Name: vkCmdSetCoverageModulationModeNV
//         Command:
//             Name: vkCmdSetCoverageModulationTableEnableNV
//         Command:
//             Name: vkCmdSetCoverageModulationTableNV
//     Depends: VK_NV_shading_rate_image
//         Enum:
//             Name: VK_DYNAMIC_STATE_SHADING_RATE_IMAGE_ENABLE_NV
//             Negative: false
//             Extends: VkDynamicState
//             Offset: 30
//         Command:
//             Name: vkCmdSetShadingRateImageEnableNV
//     Depends: VK_NV_representative_fragment_test
//         Enum:
//             Name: VK_DYNAMIC_STATE_REPRESENTATIVE_FRAGMENT_TEST_ENABLE_NV
//             Negative: false
//             Extends: VkDynamicState
//             Offset: 31
//         Command:
//             Name: vkCmdSetRepresentativeFragmentTestEnableNV
//     Depends: VK_NV_coverage_reduction_mode
//         Enum:
//             Name: VK_DYNAMIC_STATE_COVERAGE_REDUCTION_MODE_NV
//             Negative: false
//             Extends: VkDynamicState
//             Offset: 32
//         Command:
//             Name: vkCmdSetCoverageReductionModeNV
//     Depends: VkPhysicalDeviceExtendedDynamicState3FeaturesEXT::extendedDynamicState3TessellationDomainOrigin
//         Feature:
//             Name: tessellationShader
//             Struct: VkPhysicalDeviceFeatures
//     Depends: VkPhysicalDeviceExtendedDynamicState3FeaturesEXT::extendedDynamicState3DepthClampEnable
//         Feature:
//             Name: depthClamp
//             Struct: VkPhysicalDeviceFeatures
//     Depends: VkPhysicalDeviceExtendedDynamicState3FeaturesEXT::extendedDynamicState3PolygonMode
//         Feature:
//             Name: fillModeNonSolid
//             Struct: VkPhysicalDeviceFeatures
//     Depends: VkPhysicalDeviceExtendedDynamicState3FeaturesEXT::extendedDynamicState3AlphaToOneEnable
//         Feature:
//             Name: alphaToOne
//             Struct: VkPhysicalDeviceFeatures
//     Depends: VkPhysicalDeviceExtendedDynamicState3FeaturesEXT::extendedDynamicState3LogicOpEnable
//         Feature:
//             Name: logicOp
//             Struct: VkPhysicalDeviceFeatures
//     Depends: VK_EXT_transform_feedback+VkPhysicalDeviceExtendedDynamicState3FeaturesEXT::extendedDynamicState3RasterizationStream
//         Feature:
//             Name: geometryStreams
//             Struct: VkPhysicalDeviceTransformFeedbackFeaturesEXT
// Extension: VK_EXT_extension_457
// Number: 457
// Type: invalid
// Author: RASTERGRID
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_457_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_457_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_457&quot;
// Extension: VK_EXT_extension_458
// Number: 458
// Type: invalid
// Author: RASTERGRID
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_458_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_458_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_458&quot;
// Extension: VK_EXT_subpass_merge_feedback
// Number: 459
// Type: device
// Author: EXT
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_SUBPASS_MERGE_FEEDBACK_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_EXT_SUBPASS_MERGE_FEEDBACK_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_subpass_merge_feedback&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_CONTROL_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_FEEDBACK_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_RENDER_PASS_SUBPASS_FEEDBACK_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Type:
//             Name: VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT
//         Type:
//             Name: VkRenderPassCreationControlEXT
//         Type:
//             Name: VkRenderPassCreationFeedbackInfoEXT
//         Type:
//             Name: VkRenderPassCreationFeedbackCreateInfoEXT
//         Type:
//             Name: VkRenderPassSubpassFeedbackInfoEXT
//         Type:
//             Name: VkRenderPassSubpassFeedbackCreateInfoEXT
//         Type:
//             Name: VkSubpassMergeStatusEXT
//         Feature:
//             Name: subpassMergeFeedback
//             Struct: VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT
// Extension: VK_LUNARG_direct_driver_loading
// Number: 460
// Type: instance
// Author: LUNARG
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_LUNARG_DIRECT_DRIVER_LOADING_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_LUNARG_DIRECT_DRIVER_LOADING_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_LUNARG_direct_driver_loading&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_INFO_LUNARG
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_LIST_LUNARG
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Type:
//             Name: VkDirectDriverLoadingFlagsLUNARG
//         Type:
//             Name: VkDirectDriverLoadingModeLUNARG
//         Type:
//             Name: VkDirectDriverLoadingInfoLUNARG
//         Type:
//             Name: VkDirectDriverLoadingListLUNARG
//         Type:
//             Name: PFN_vkGetInstanceProcAddrLUNARG
// Extension: VK_ARM_tensors
// Number: 461
// Type: device
// Author: ARM
// Depends: VK_VERSION_1_3
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_ARM_TENSORS_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_ARM_TENSORS_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_ARM_tensors&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_TENSOR_CREATE_INFO_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_TENSOR_VIEW_CREATE_INFO_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_BIND_TENSOR_MEMORY_INFO_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_TENSOR_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TENSOR_PROPERTIES_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 4
//         Enum:
//             Name: VK_STRUCTURE_TYPE_TENSOR_FORMAT_PROPERTIES_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 5
//         Enum:
//             Name: VK_STRUCTURE_TYPE_TENSOR_DESCRIPTION_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 6
//         Enum:
//             Name: VK_STRUCTURE_TYPE_TENSOR_MEMORY_REQUIREMENTS_INFO_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 7
//         Enum:
//             Name: VK_STRUCTURE_TYPE_TENSOR_MEMORY_BARRIER_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 8
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TENSOR_FEATURES_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 9
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DEVICE_TENSOR_MEMORY_REQUIREMENTS_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 10
//         Enum:
//             Name: VK_STRUCTURE_TYPE_COPY_TENSOR_INFO_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 11
//         Enum:
//             Name: VK_STRUCTURE_TYPE_TENSOR_COPY_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 12
//         Enum:
//             Name: VK_STRUCTURE_TYPE_TENSOR_DEPENDENCY_INFO_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 13
//         Enum:
//             Name: VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_TENSOR_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 14
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_TENSOR_INFO_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 15
//         Enum:
//             Name: VK_STRUCTURE_TYPE_EXTERNAL_TENSOR_PROPERTIES_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 16
//         Enum:
//             Name: VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_TENSOR_CREATE_INFO_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 17
//         Enum:
//             Name: VK_OBJECT_TYPE_TENSOR_ARM
//             Negative: false
//             Extends: VkObjectType
//             Offset: 0
//         Enum:
//             Name: VK_OBJECT_TYPE_TENSOR_VIEW_ARM
//             Negative: false
//             Extends: VkObjectType
//             Offset: 1
//         Enum:
//             Name: VK_DESCRIPTOR_TYPE_TENSOR_ARM
//             Negative: false
//             Extends: VkDescriptorType
//             Offset: 0
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_TENSOR_SHADER_BIT_ARM
//             Negative: false
//             Bitpos: 39
//             Extends: VkFormatFeatureFlagBits2
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_TENSOR_IMAGE_ALIASING_BIT_ARM
//             Negative: false
//             Bitpos: 43
//             Extends: VkFormatFeatureFlagBits2
//         Enum:
//             Name: VK_IMAGE_USAGE_TENSOR_ALIASING_BIT_ARM
//             Negative: false
//             Bitpos: 23
//             Extends: VkImageUsageFlagBits
//         Enum:
//             Name: VK_IMAGE_LAYOUT_TENSOR_ALIASING_ARM
//             Negative: false
//             Extends: VkImageLayout
//             Offset: 0
//         Enum:
//             Name: VK_FORMAT_R8_BOOL_ARM
//             Negative: false
//             Extends: VkFormat
//             Offset: 0
//         Type:
//             Name: VkTensorARM
//         Type:
//             Name: VkTensorViewARM
//         Type:
//             Name: VkTensorCreateFlagsARM
//         Type:
//             Name: VkTensorCreateFlagBitsARM
//         Type:
//             Name: VkTensorViewCreateFlagsARM
//         Type:
//             Name: VkTensorViewCreateFlagBitsARM
//         Type:
//             Name: VkTensorUsageFlagsARM
//         Type:
//             Name: VkTensorUsageFlagBitsARM
//         Type:
//             Name: VkTensorDescriptionARM
//         Type:
//             Name: VkTensorTilingARM
//         Type:
//             Name: VkTensorCreateInfoARM
//         Type:
//             Name: VkTensorViewCreateInfoARM
//         Type:
//             Name: VkTensorMemoryRequirementsInfoARM
//         Type:
//             Name: VkBindTensorMemoryInfoARM
//         Type:
//             Name: VkWriteDescriptorSetTensorARM
//         Type:
//             Name: VkTensorFormatPropertiesARM
//         Type:
//             Name: VkPhysicalDeviceTensorPropertiesARM
//         Type:
//             Name: VkTensorMemoryBarrierARM
//         Type:
//             Name: VkTensorDependencyInfoARM
//         Type:
//             Name: VkPhysicalDeviceTensorFeaturesARM
//         Type:
//             Name: VkDeviceTensorMemoryRequirementsARM
//         Type:
//             Name: VkCopyTensorInfoARM
//         Type:
//             Name: VkTensorCopyARM
//         Type:
//             Name: VkMemoryDedicatedAllocateInfoTensorARM
//         Type:
//             Name: VkPhysicalDeviceExternalTensorInfoARM
//         Type:
//             Name: VkExternalTensorPropertiesARM
//         Type:
//             Name: VkExternalMemoryTensorCreateInfoARM
//         Command:
//             Name: vkCreateTensorARM
//         Command:
//             Name: vkDestroyTensorARM
//         Command:
//             Name: vkCreateTensorViewARM
//         Command:
//             Name: vkDestroyTensorViewARM
//         Command:
//             Name: vkGetTensorMemoryRequirementsARM
//         Command:
//             Name: vkBindTensorMemoryARM
//         Command:
//             Name: vkGetDeviceTensorMemoryRequirementsARM
//         Command:
//             Name: vkCmdCopyTensorARM
//         Command:
//             Name: vkGetPhysicalDeviceExternalTensorPropertiesARM
//         Feature:
//             Name: tensors
//             Struct: VkPhysicalDeviceTensorFeaturesARM
//     Depends: VK_EXT_descriptor_buffer
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_TENSOR_FEATURES_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 18
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_TENSOR_PROPERTIES_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 19
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DESCRIPTOR_GET_TENSOR_INFO_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 20
//         Enum:
//             Name: VK_STRUCTURE_TYPE_TENSOR_CAPTURE_DESCRIPTOR_DATA_INFO_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 21
//         Enum:
//             Name: VK_STRUCTURE_TYPE_TENSOR_VIEW_CAPTURE_DESCRIPTOR_DATA_INFO_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 22
//         Enum:
//             Name: VK_TENSOR_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_ARM
//             Negative: false
//             Bitpos: 2
//             Extends: VkTensorCreateFlagBitsARM
//         Enum:
//             Name: VK_TENSOR_VIEW_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_ARM
//             Negative: false
//             Bitpos: 0
//             Extends: VkTensorViewCreateFlagBitsARM
//         Type:
//             Name: VkPhysicalDeviceDescriptorBufferTensorFeaturesARM
//         Type:
//             Name: VkPhysicalDeviceDescriptorBufferTensorPropertiesARM
//         Type:
//             Name: VkDescriptorGetTensorInfoARM
//         Type:
//             Name: VkTensorCaptureDescriptorDataInfoARM
//         Type:
//             Name: VkTensorViewCaptureDescriptorDataInfoARM
//         Command:
//             Name: vkGetTensorOpaqueCaptureDescriptorDataARM
//         Command:
//             Name: vkGetTensorViewOpaqueCaptureDescriptorDataARM
//     Depends: VK_EXT_frame_boundary
//         Enum:
//             Name: VK_STRUCTURE_TYPE_FRAME_BOUNDARY_TENSORS_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 23
//         Type:
//             Name: VkFrameBoundaryTensorsARM
// Extension: VK_EXT_extension_462
// Number: 462
// Type: invalid
// Author: EXT
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_462_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_462_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_462&quot;
// Extension: VK_EXT_shader_module_identifier
// Number: 463
// Type: device
// Author: EXT
// Depends: ((VK_KHR_get_physical_device_properties2,VK_VERSION_1_1)+VK_EXT_pipeline_creation_cache_control),VK_VERSION_1_3
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_SHADER_MODULE_IDENTIFIER_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_SHADER_MODULE_IDENTIFIER_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_shader_module_identifier&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_PROPERTIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_MODULE_IDENTIFIER_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SHADER_MODULE_IDENTIFIER_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Enum:
//             Name: VK_MAX_SHADER_MODULE_IDENTIFIER_SIZE_EXT
//             Negative: false
//         Type:
//             Name: VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT
//         Type:
//             Name: VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT
//         Type:
//             Name: VkPipelineShaderStageModuleIdentifierCreateInfoEXT
//         Type:
//             Name: VkShaderModuleIdentifierEXT
//         Command:
//             Name: vkGetShaderModuleIdentifierEXT
//         Command:
//             Name: vkGetShaderModuleCreateInfoIdentifierEXT
//         Feature:
//             Name: shaderModuleIdentifier
//             Struct: VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT
// Extension: VK_EXT_rasterization_order_attachment_access
// Number: 464
// Type: device
// Author: ARM
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_rasterization_order_attachment_access&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Extnumber: 343
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT
//         Type:
//             Name: VkPipelineColorBlendStateCreateFlagBits
//         Type:
//             Name: VkPipelineDepthStencilStateCreateFlagBits
//         Enum:
//             Name: VK_PIPELINE_COLOR_BLEND_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_BIT_EXT
//             Negative: false
//             Bitpos: 0
//             Extends: VkPipelineColorBlendStateCreateFlagBits
//         Enum:
//             Name: VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_EXT
//             Negative: false
//             Bitpos: 0
//             Extends: VkPipelineDepthStencilStateCreateFlagBits
//         Enum:
//             Name: VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_EXT
//             Negative: false
//             Bitpos: 1
//             Extends: VkPipelineDepthStencilStateCreateFlagBits
//         Enum:
//             Name: VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_COLOR_ACCESS_BIT_EXT
//             Negative: false
//             Bitpos: 4
//             Extends: VkSubpassDescriptionFlagBits
//         Enum:
//             Name: VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_EXT
//             Negative: false
//             Bitpos: 5
//             Extends: VkSubpassDescriptionFlagBits
//         Enum:
//             Name: VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_EXT
//             Negative: false
//             Bitpos: 6
//             Extends: VkSubpassDescriptionFlagBits
// Extension: VK_NV_optical_flow
// Number: 465
// Type: device
// Author: NV
// Depends: ((VK_KHR_get_physical_device_properties2,VK_VERSION_1_1)+VK_KHR_format_feature_flags2+VK_KHR_synchronization2),VK_VERSION_1_3
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NV_OPTICAL_FLOW_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_NV_OPTICAL_FLOW_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_optical_flow&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_FEATURES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_PROPERTIES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_PROPERTIES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Enum:
//             Name: VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 4
//         Enum:
//             Name: VK_STRUCTURE_TYPE_OPTICAL_FLOW_EXECUTE_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 5
//         Enum:
//             Name: VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_PRIVATE_DATA_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 10
//         Comment:
//             NV internal use only
//         Enum:
//             Name: VK_FORMAT_R16G16_SFIXED5_NV
//             Negative: false
//             Extends: VkFormat
//             Offset: 0
//         Enum:
//             Name: VK_FORMAT_R16G16_S10_5_NV
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_R16G16_SFIXED5_NV
//         Enum:
//             Name: VK_OBJECT_TYPE_OPTICAL_FLOW_SESSION_NV
//             Negative: false
//             Extends: VkObjectType
//             Offset: 0
//         Enum:
//             Name: VK_QUEUE_OPTICAL_FLOW_BIT_NV
//             Negative: false
//             Bitpos: 8
//             Extends: VkQueueFlagBits
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_OPTICAL_FLOW_BIT_NV
//             Negative: false
//             Bitpos: 29
//             Extends: VkPipelineStageFlagBits2
//         Enum:
//             Name: VK_ACCESS_2_OPTICAL_FLOW_READ_BIT_NV
//             Negative: false
//             Bitpos: 42
//             Extends: VkAccessFlagBits2
//         Enum:
//             Name: VK_ACCESS_2_OPTICAL_FLOW_WRITE_BIT_NV
//             Negative: false
//             Bitpos: 43
//             Extends: VkAccessFlagBits2
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_OPTICAL_FLOW_IMAGE_BIT_NV
//             Negative: false
//             Bitpos: 40
//             Extends: VkFormatFeatureFlagBits2
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_OPTICAL_FLOW_VECTOR_BIT_NV
//             Negative: false
//             Bitpos: 41
//             Extends: VkFormatFeatureFlagBits2
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_OPTICAL_FLOW_COST_BIT_NV
//             Negative: false
//             Bitpos: 42
//             Extends: VkFormatFeatureFlagBits2
//         Type:
//             Name: VkPhysicalDeviceOpticalFlowFeaturesNV
//         Type:
//             Name: VkPhysicalDeviceOpticalFlowPropertiesNV
//         Type:
//             Name: VkOpticalFlowUsageFlagBitsNV
//         Type:
//             Name: VkOpticalFlowUsageFlagsNV
//         Type:
//             Name: VkOpticalFlowImageFormatInfoNV
//         Type:
//             Name: VkOpticalFlowImageFormatPropertiesNV
//         Type:
//             Name: VkOpticalFlowGridSizeFlagBitsNV
//         Type:
//             Name: VkOpticalFlowGridSizeFlagsNV
//         Type:
//             Name: VkOpticalFlowPerformanceLevelNV
//         Type:
//             Name: VkOpticalFlowSessionBindingPointNV
//         Type:
//             Name: VkOpticalFlowSessionCreateFlagBitsNV
//         Type:
//             Name: VkOpticalFlowSessionCreateFlagsNV
//         Type:
//             Name: VkOpticalFlowExecuteFlagBitsNV
//         Type:
//             Name: VkOpticalFlowExecuteFlagsNV
//         Type:
//             Name: VkOpticalFlowSessionNV
//         Type:
//             Name: VkOpticalFlowSessionCreateInfoNV
//         Type:
//             Name: VkOpticalFlowSessionCreatePrivateDataInfoNV
//         Comment:
//             NV internal use only
//         Type:
//             Name: VkOpticalFlowExecuteInfoNV
//         Command:
//             Name: vkGetPhysicalDeviceOpticalFlowImageFormatsNV
//         Command:
//             Name: vkCreateOpticalFlowSessionNV
//         Command:
//             Name: vkDestroyOpticalFlowSessionNV
//         Command:
//             Name: vkBindOpticalFlowSessionImageNV
//         Command:
//             Name: vkCmdOpticalFlowExecuteNV
//         Feature:
//             Name: opticalFlow
//             Struct: VkPhysicalDeviceOpticalFlowFeaturesNV
// Extension: VK_EXT_legacy_dithering
// Number: 466
// Type: device
// Author: EXT
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_LEGACY_DITHERING_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_EXT_LEGACY_DITHERING_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_legacy_dithering&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_SUBPASS_DESCRIPTION_ENABLE_LEGACY_DITHERING_BIT_EXT
//             Negative: false
//             Bitpos: 7
//             Extends: VkSubpassDescriptionFlagBits
//         Type:
//             Name: VkPhysicalDeviceLegacyDitheringFeaturesEXT
//         Feature:
//             Name: legacyDithering
//             Struct: VkPhysicalDeviceLegacyDitheringFeaturesEXT
//     Depends: (VK_KHR_dynamic_rendering,VK_VERSION_1_3)+(VK_KHR_maintenance5,VK_VERSION_1_4)
//         Enum:
//             Name: VK_RENDERING_ENABLE_LEGACY_DITHERING_BIT_EXT
//             Negative: false
//             Bitpos: 3
//             Extends: VkRenderingFlagBits
//         Enum:
//             Name: VK_PIPELINE_CREATE_2_ENABLE_LEGACY_DITHERING_BIT_EXT
//             Negative: false
//             Bitpos: 34
//             Extends: VkPipelineCreateFlagBits2
// Extension: VK_EXT_pipeline_protected_access
// Number: 467
// Type: device
// Author: EXT
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_4
// Unlocks:
//         Enum:
//             Name: VK_EXT_PIPELINE_PROTECTED_ACCESS_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_PIPELINE_PROTECTED_ACCESS_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_pipeline_protected_access&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES
//         Enum:
//             Name: VK_PIPELINE_CREATE_NO_PROTECTED_ACCESS_BIT_EXT
//             Negative: false
//             Extends: VkPipelineCreateFlagBits
//             Alias: VK_PIPELINE_CREATE_NO_PROTECTED_ACCESS_BIT
//         Enum:
//             Name: VK_PIPELINE_CREATE_PROTECTED_ACCESS_ONLY_BIT_EXT
//             Negative: false
//             Extends: VkPipelineCreateFlagBits
//             Alias: VK_PIPELINE_CREATE_PROTECTED_ACCESS_ONLY_BIT
//         Type:
//             Name: VkPhysicalDevicePipelineProtectedAccessFeaturesEXT
//         Feature:
//             Name: pipelineProtectedAccess
//             Struct: VkPhysicalDevicePipelineProtectedAccessFeaturesEXT
// Extension: VK_EXT_extension_468
// Number: 468
// Type: invalid
// Author: EXT
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_468_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_468_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_468&quot;
// Extension: VK_ANDROID_external_format_resolve
// Number: 469
// Type: device
// Author: ANDROID
// Depends: VK_ANDROID_external_memory_android_hardware_buffer
// Platform: android
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_ANDROID_EXTERNAL_FORMAT_RESOLVE_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_ANDROID_EXTERNAL_FORMAT_RESOLVE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_ANDROID_external_format_resolve&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FORMAT_RESOLVE_FEATURES_ANDROID
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FORMAT_RESOLVE_PROPERTIES_ANDROID
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_RESOLVE_PROPERTIES_ANDROID
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Type:
//             Name: VkPhysicalDeviceExternalFormatResolveFeaturesANDROID
//         Type:
//             Name: VkPhysicalDeviceExternalFormatResolvePropertiesANDROID
//         Type:
//             Name: VkAndroidHardwareBufferFormatResolvePropertiesANDROID
//         Feature:
//             Name: externalFormatResolve
//             Struct: VkPhysicalDeviceExternalFormatResolveFeaturesANDROID
//     Depends: VK_KHR_dynamic_rendering,VK_VERSION_1_3
//         Enum:
//             Name: VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_BIT_ANDROID
//             Negative: false
//             Bitpos: 4
//             Extends: VkResolveModeFlagBits
//         Enum:
//             Name: VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID
//             Negative: false
//             Extends: VkResolveModeFlagBits
//             Alias: VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_BIT_ANDROID
// Extension: VK_AMD_extension_470
// Number: 470
// Type: invalid
// Author: AMD
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_AMD_EXTENSION_470_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_AMD_EXTENSION_470_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_extension_470&quot;
// Extension: VK_KHR_maintenance5
// Number: 471
// Type: device
// Author: KHR
// Depends: (VK_VERSION_1_1+VK_KHR_dynamic_rendering),VK_VERSION_1_3
// Supported: supported
// Promoted to: VK_VERSION_1_4
// Unlocks:
//         Enum:
//             Name: VK_KHR_MAINTENANCE_5_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_MAINTENANCE_5_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_maintenance5&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_PROPERTIES
//         Enum:
//             Name: VK_STRUCTURE_TYPE_RENDERING_AREA_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_RENDERING_AREA_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DEVICE_IMAGE_SUBRESOURCE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_DEVICE_IMAGE_SUBRESOURCE_INFO
//         Type:
//             Name: VkPhysicalDeviceMaintenance5FeaturesKHR
//         Type:
//             Name: VkPhysicalDeviceMaintenance5PropertiesKHR
//         Enum:
//             Name: VK_FORMAT_A1B5G5R5_UNORM_PACK16_KHR
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_A1B5G5R5_UNORM_PACK16
//         Enum:
//             Name: VK_FORMAT_A8_UNORM_KHR
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_A8_UNORM
//         Command:
//             Name: vkCmdBindIndexBuffer2KHR
//         Command:
//             Name: vkGetRenderingAreaGranularityKHR
//         Type:
//             Name: VkRenderingAreaInfoKHR
//         Command:
//             Name: vkGetDeviceImageSubresourceLayoutKHR
//         Command:
//             Name: vkGetImageSubresourceLayout2KHR
//         Type:
//             Name: VkDeviceImageSubresourceInfoKHR
//         Type:
//             Name: VkImageSubresource2KHR
//         Type:
//             Name: VkSubresourceLayout2KHR
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2
//         Feature:
//             Name: maintenance5
//             Struct: VkPhysicalDeviceMaintenance5FeaturesKHR
//         Enum:
//             Name: VK_PIPELINE_CREATE_2_DISABLE_OPTIMIZATION_BIT_KHR
//             Negative: false
//             Extends: VkPipelineCreateFlagBits2
//             Alias: VK_PIPELINE_CREATE_2_DISABLE_OPTIMIZATION_BIT
//         Enum:
//             Name: VK_PIPELINE_CREATE_2_ALLOW_DERIVATIVES_BIT_KHR
//             Negative: false
//             Extends: VkPipelineCreateFlagBits2
//             Alias: VK_PIPELINE_CREATE_2_ALLOW_DERIVATIVES_BIT
//         Enum:
//             Name: VK_PIPELINE_CREATE_2_DERIVATIVE_BIT_KHR
//             Negative: false
//             Extends: VkPipelineCreateFlagBits2
//             Alias: VK_PIPELINE_CREATE_2_DERIVATIVE_BIT
//         Enum:
//             Name: VK_PIPELINE_CREATE_2_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHR
//             Negative: false
//             Extends: VkPipelineCreateFlagBits2
//             Alias: VK_PIPELINE_CREATE_2_VIEW_INDEX_FROM_DEVICE_INDEX_BIT
//         Enum:
//             Name: VK_PIPELINE_CREATE_2_DISPATCH_BASE_BIT_KHR
//             Negative: false
//             Extends: VkPipelineCreateFlagBits2
//             Alias: VK_PIPELINE_CREATE_2_DISPATCH_BASE_BIT
//         Enum:
//             Name: VK_BUFFER_USAGE_2_TRANSFER_SRC_BIT_KHR
//             Negative: false
//             Extends: VkBufferUsageFlagBits2
//             Alias: VK_BUFFER_USAGE_2_TRANSFER_SRC_BIT
//         Enum:
//             Name: VK_BUFFER_USAGE_2_TRANSFER_DST_BIT_KHR
//             Negative: false
//             Extends: VkBufferUsageFlagBits2
//             Alias: VK_BUFFER_USAGE_2_TRANSFER_DST_BIT
//         Enum:
//             Name: VK_BUFFER_USAGE_2_UNIFORM_TEXEL_BUFFER_BIT_KHR
//             Negative: false
//             Extends: VkBufferUsageFlagBits2
//             Alias: VK_BUFFER_USAGE_2_UNIFORM_TEXEL_BUFFER_BIT
//         Enum:
//             Name: VK_BUFFER_USAGE_2_STORAGE_TEXEL_BUFFER_BIT_KHR
//             Negative: false
//             Extends: VkBufferUsageFlagBits2
//             Alias: VK_BUFFER_USAGE_2_STORAGE_TEXEL_BUFFER_BIT
//         Enum:
//             Name: VK_BUFFER_USAGE_2_UNIFORM_BUFFER_BIT_KHR
//             Negative: false
//             Extends: VkBufferUsageFlagBits2
//             Alias: VK_BUFFER_USAGE_2_UNIFORM_BUFFER_BIT
//         Enum:
//             Name: VK_BUFFER_USAGE_2_STORAGE_BUFFER_BIT_KHR
//             Negative: false
//             Extends: VkBufferUsageFlagBits2
//             Alias: VK_BUFFER_USAGE_2_STORAGE_BUFFER_BIT
//         Enum:
//             Name: VK_BUFFER_USAGE_2_INDEX_BUFFER_BIT_KHR
//             Negative: false
//             Extends: VkBufferUsageFlagBits2
//             Alias: VK_BUFFER_USAGE_2_INDEX_BUFFER_BIT
//         Enum:
//             Name: VK_BUFFER_USAGE_2_VERTEX_BUFFER_BIT_KHR
//             Negative: false
//             Extends: VkBufferUsageFlagBits2
//             Alias: VK_BUFFER_USAGE_2_VERTEX_BUFFER_BIT
//         Enum:
//             Name: VK_BUFFER_USAGE_2_INDIRECT_BUFFER_BIT_KHR
//             Negative: false
//             Extends: VkBufferUsageFlagBits2
//             Alias: VK_BUFFER_USAGE_2_INDIRECT_BUFFER_BIT
//         Type:
//             Name: VkPipelineCreateFlags2KHR
//         Type:
//             Name: VkPipelineCreateFlagBits2KHR
//         Type:
//             Name: VkPipelineCreateFlags2CreateInfoKHR
//         Type:
//             Name: VkBufferUsageFlags2KHR
//         Type:
//             Name: VkBufferUsageFlagBits2KHR
//         Type:
//             Name: VkBufferUsageFlags2CreateInfoKHR
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO
//     Depends: VK_NV_ray_tracing
//         Enum:
//             Name: VK_PIPELINE_CREATE_2_DEFER_COMPILE_BIT_NV
//             Negative: false
//             Bitpos: 5
//             Extends: VkPipelineCreateFlagBits2
//     Depends: VK_KHR_pipeline_executable_properties
//         Enum:
//             Name: VK_PIPELINE_CREATE_2_CAPTURE_STATISTICS_BIT_KHR
//             Negative: false
//             Bitpos: 6
//             Extends: VkPipelineCreateFlagBits2
//         Enum:
//             Name: VK_PIPELINE_CREATE_2_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR
//             Negative: false
//             Bitpos: 7
//             Extends: VkPipelineCreateFlagBits2
//     Depends: VK_VERSION_1_3,VK_EXT_pipeline_creation_cache_control
//         Enum:
//             Name: VK_PIPELINE_CREATE_2_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT_KHR
//             Negative: false
//             Extends: VkPipelineCreateFlagBits2
//             Alias: VK_PIPELINE_CREATE_2_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT
//         Enum:
//             Name: VK_PIPELINE_CREATE_2_EARLY_RETURN_ON_FAILURE_BIT_KHR
//             Negative: false
//             Extends: VkPipelineCreateFlagBits2
//             Alias: VK_PIPELINE_CREATE_2_EARLY_RETURN_ON_FAILURE_BIT
//     Depends: VK_EXT_graphics_pipeline_library
//         Enum:
//             Name: VK_PIPELINE_CREATE_2_LINK_TIME_OPTIMIZATION_BIT_EXT
//             Negative: false
//             Bitpos: 10
//             Extends: VkPipelineCreateFlagBits2
//         Enum:
//             Name: VK_PIPELINE_CREATE_2_RETAIN_LINK_TIME_OPTIMIZATION_INFO_BIT_EXT
//             Negative: false
//             Bitpos: 23
//             Extends: VkPipelineCreateFlagBits2
//     Depends: VK_KHR_pipeline_library
//         Enum:
//             Name: VK_PIPELINE_CREATE_2_LIBRARY_BIT_KHR
//             Negative: false
//             Bitpos: 11
//             Extends: VkPipelineCreateFlagBits2
//     Depends: VK_KHR_ray_tracing_pipeline
//         Enum:
//             Name: VK_PIPELINE_CREATE_2_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR
//             Negative: false
//             Bitpos: 12
//             Extends: VkPipelineCreateFlagBits2
//         Enum:
//             Name: VK_PIPELINE_CREATE_2_RAY_TRACING_SKIP_AABBS_BIT_KHR
//             Negative: false
//             Bitpos: 13
//             Extends: VkPipelineCreateFlagBits2
//         Enum:
//             Name: VK_PIPELINE_CREATE_2_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR
//             Negative: false
//             Bitpos: 14
//             Extends: VkPipelineCreateFlagBits2
//         Enum:
//             Name: VK_PIPELINE_CREATE_2_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR
//             Negative: false
//             Bitpos: 15
//             Extends: VkPipelineCreateFlagBits2
//         Enum:
//             Name: VK_PIPELINE_CREATE_2_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR
//             Negative: false
//             Bitpos: 16
//             Extends: VkPipelineCreateFlagBits2
//         Enum:
//             Name: VK_PIPELINE_CREATE_2_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR
//             Negative: false
//             Bitpos: 17
//             Extends: VkPipelineCreateFlagBits2
//         Enum:
//             Name: VK_PIPELINE_CREATE_2_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR
//             Negative: false
//             Bitpos: 19
//             Extends: VkPipelineCreateFlagBits2
//     Depends: VK_NV_device_generated_commands
//         Enum:
//             Name: VK_PIPELINE_CREATE_2_INDIRECT_BINDABLE_BIT_NV
//             Negative: false
//             Bitpos: 18
//             Extends: VkPipelineCreateFlagBits2
//     Depends: VK_NV_ray_tracing_motion_blur
//         Enum:
//             Name: VK_PIPELINE_CREATE_2_RAY_TRACING_ALLOW_MOTION_BIT_NV
//             Negative: false
//             Bitpos: 20
//             Extends: VkPipelineCreateFlagBits2
//     Depends: (VK_KHR_dynamic_rendering,VK_VERSION_1_3)+VK_KHR_fragment_shading_rate
//         Enum:
//             Name: VK_PIPELINE_CREATE_2_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR
//             Negative: false
//             Bitpos: 21
//             Extends: VkPipelineCreateFlagBits2
//     Depends: (VK_KHR_dynamic_rendering,VK_VERSION_1_3)+VK_EXT_fragment_density_map
//         Enum:
//             Name: VK_PIPELINE_CREATE_2_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT
//             Negative: false
//             Bitpos: 22
//             Extends: VkPipelineCreateFlagBits2
//     Depends: VK_EXT_opacity_micromap
//         Enum:
//             Name: VK_PIPELINE_CREATE_2_RAY_TRACING_OPACITY_MICROMAP_BIT_EXT
//             Negative: false
//             Bitpos: 24
//             Extends: VkPipelineCreateFlagBits2
//     Depends: VK_EXT_attachment_feedback_loop_layout
//         Enum:
//             Name: VK_PIPELINE_CREATE_2_COLOR_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT
//             Negative: false
//             Bitpos: 25
//             Extends: VkPipelineCreateFlagBits2
//         Enum:
//             Name: VK_PIPELINE_CREATE_2_DEPTH_STENCIL_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT
//             Negative: false
//             Bitpos: 26
//             Extends: VkPipelineCreateFlagBits2
//     Depends: VK_VERSION_1_4,VK_EXT_pipeline_protected_access
//         Enum:
//             Name: VK_PIPELINE_CREATE_2_NO_PROTECTED_ACCESS_BIT_EXT
//             Negative: false
//             Extends: VkPipelineCreateFlagBits2
//             Alias: VK_PIPELINE_CREATE_2_NO_PROTECTED_ACCESS_BIT
//         Enum:
//             Name: VK_PIPELINE_CREATE_2_PROTECTED_ACCESS_ONLY_BIT_EXT
//             Negative: false
//             Extends: VkPipelineCreateFlagBits2
//             Alias: VK_PIPELINE_CREATE_2_PROTECTED_ACCESS_ONLY_BIT
//     Depends: VK_NV_displacement_micromap
//         Enum:
//             Name: VK_PIPELINE_CREATE_2_RAY_TRACING_DISPLACEMENT_MICROMAP_BIT_NV
//             Negative: false
//             Bitpos: 28
//             Extends: VkPipelineCreateFlagBits2
//     Depends: VK_EXT_descriptor_buffer
//         Enum:
//             Name: VK_PIPELINE_CREATE_2_DESCRIPTOR_BUFFER_BIT_EXT
//             Negative: false
//             Bitpos: 29
//             Extends: VkPipelineCreateFlagBits2
//     Depends: VK_EXT_conditional_rendering
//         Enum:
//             Name: VK_BUFFER_USAGE_2_CONDITIONAL_RENDERING_BIT_EXT
//             Negative: false
//             Bitpos: 9
//             Extends: VkBufferUsageFlagBits2
//     Depends: VK_KHR_ray_tracing_pipeline
//         Enum:
//             Name: VK_BUFFER_USAGE_2_SHADER_BINDING_TABLE_BIT_KHR
//             Negative: false
//             Bitpos: 10
//             Extends: VkBufferUsageFlagBits2
//     Depends: VK_NV_ray_tracing
//         Enum:
//             Name: VK_BUFFER_USAGE_2_RAY_TRACING_BIT_NV
//             Negative: false
//             Extends: VkBufferUsageFlagBits2
//             Alias: VK_BUFFER_USAGE_2_SHADER_BINDING_TABLE_BIT_KHR
//     Depends: VK_EXT_transform_feedback
//         Enum:
//             Name: VK_BUFFER_USAGE_2_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT
//             Negative: false
//             Bitpos: 11
//             Extends: VkBufferUsageFlagBits2
//         Enum:
//             Name: VK_BUFFER_USAGE_2_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT
//             Negative: false
//             Bitpos: 12
//             Extends: VkBufferUsageFlagBits2
//     Depends: VK_KHR_video_decode_queue
//         Enum:
//             Name: VK_BUFFER_USAGE_2_VIDEO_DECODE_SRC_BIT_KHR
//             Negative: false
//             Bitpos: 13
//             Extends: VkBufferUsageFlagBits2
//         Enum:
//             Name: VK_BUFFER_USAGE_2_VIDEO_DECODE_DST_BIT_KHR
//             Negative: false
//             Bitpos: 14
//             Extends: VkBufferUsageFlagBits2
//     Depends: VK_KHR_video_encode_queue
//         Enum:
//             Name: VK_BUFFER_USAGE_2_VIDEO_ENCODE_DST_BIT_KHR
//             Negative: false
//             Bitpos: 15
//             Extends: VkBufferUsageFlagBits2
//         Enum:
//             Name: VK_BUFFER_USAGE_2_VIDEO_ENCODE_SRC_BIT_KHR
//             Negative: false
//             Bitpos: 16
//             Extends: VkBufferUsageFlagBits2
//     Depends: VK_VERSION_1_2,VK_KHR_buffer_device_address,VK_EXT_buffer_device_address
//         Enum:
//             Name: VK_BUFFER_USAGE_2_SHADER_DEVICE_ADDRESS_BIT_KHR
//             Negative: false
//             Extends: VkBufferUsageFlagBits2
//             Alias: VK_BUFFER_USAGE_2_SHADER_DEVICE_ADDRESS_BIT
//     Depends: VK_KHR_acceleration_structure
//         Enum:
//             Name: VK_BUFFER_USAGE_2_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR
//             Negative: false
//             Bitpos: 19
//             Extends: VkBufferUsageFlagBits2
//         Enum:
//             Name: VK_BUFFER_USAGE_2_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR
//             Negative: false
//             Bitpos: 20
//             Extends: VkBufferUsageFlagBits2
//     Depends: VK_EXT_descriptor_buffer
//         Enum:
//             Name: VK_BUFFER_USAGE_2_SAMPLER_DESCRIPTOR_BUFFER_BIT_EXT
//             Negative: false
//             Bitpos: 21
//             Extends: VkBufferUsageFlagBits2
//         Enum:
//             Name: VK_BUFFER_USAGE_2_RESOURCE_DESCRIPTOR_BUFFER_BIT_EXT
//             Negative: false
//             Bitpos: 22
//             Extends: VkBufferUsageFlagBits2
//         Enum:
//             Name: VK_BUFFER_USAGE_2_PUSH_DESCRIPTORS_DESCRIPTOR_BUFFER_BIT_EXT
//             Negative: false
//             Bitpos: 26
//             Extends: VkBufferUsageFlagBits2
//     Depends: VK_EXT_opacity_micromap
//         Enum:
//             Name: VK_BUFFER_USAGE_2_MICROMAP_BUILD_INPUT_READ_ONLY_BIT_EXT
//             Negative: false
//             Bitpos: 23
//             Extends: VkBufferUsageFlagBits2
//         Enum:
//             Name: VK_BUFFER_USAGE_2_MICROMAP_STORAGE_BIT_EXT
//             Negative: false
//             Bitpos: 24
//             Extends: VkBufferUsageFlagBits2
//     Depends: VK_ARM_pipeline_opacity_micromap
//         Enum:
//             Name: VK_PIPELINE_CREATE_2_DISALLOW_OPACITY_MICROMAP_BIT_ARM
//             Negative: false
//             Bitpos: 37
//             Extends: VkPipelineCreateFlagBits2
// Extension: VK_AMD_extension_472
// Number: 472
// Type: invalid
// Author: AMD
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_AMD_EXTENSION_472_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_AMD_EXTENSION_472_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_extension_472&quot;
// Extension: VK_AMD_extension_473
// Number: 473
// Type: invalid
// Author: AMD
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_AMD_EXTENSION_473_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_AMD_EXTENSION_473_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_extension_473&quot;
// Extension: VK_AMD_extension_474
// Number: 474
// Type: invalid
// Author: AMD
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_AMD_EXTENSION_474_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_AMD_EXTENSION_474_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_extension_474&quot;
// Extension: VK_AMD_extension_475
// Number: 475
// Type: invalid
// Author: AMD
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_AMD_EXTENSION_475_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_AMD_EXTENSION_475_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_extension_475&quot;
// Extension: VK_AMD_extension_476
// Number: 476
// Type: invalid
// Author: AMD
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_AMD_EXTENSION_476_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_AMD_EXTENSION_476_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_extension_476&quot;
// Extension: VK_AMD_anti_lag
// Number: 477
// Type: device
// Author: AMD
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_AMD_ANTI_LAG_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_AMD_ANTI_LAG_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_anti_lag&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ANTI_LAG_FEATURES_AMD
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_ANTI_LAG_DATA_AMD
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_ANTI_LAG_PRESENTATION_INFO_AMD
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Type:
//             Name: VkPhysicalDeviceAntiLagFeaturesAMD
//         Type:
//             Name: VkAntiLagDataAMD
//         Type:
//             Name: VkAntiLagPresentationInfoAMD
//         Type:
//             Name: VkAntiLagModeAMD
//         Type:
//             Name: VkAntiLagStageAMD
//         Command:
//             Name: vkAntiLagUpdateAMD
//         Feature:
//             Name: antiLag
//             Struct: VkPhysicalDeviceAntiLagFeaturesAMD
// Extension: VK_AMD_extension_478
// Number: 478
// Type: invalid
// Author: AMD
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_AMD_EXTENSION_478_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_AMD_EXTENSION_478_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_extension_478&quot;
// Extension: VK_AMDX_dense_geometry_format
// Number: 479
// Type: device
// Author: AMD
// Depends: VK_KHR_acceleration_structure+(VK_KHR_maintenance5,VK_VERSION_1_4)
// Platform: provisional
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_AMDX_DENSE_GEOMETRY_FORMAT_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_AMDX_DENSE_GEOMETRY_FORMAT_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMDX_dense_geometry_format&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DENSE_GEOMETRY_FORMAT_FEATURES_AMDX
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DENSE_GEOMETRY_FORMAT_TRIANGLES_DATA_AMDX
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_GEOMETRY_TYPE_DENSE_GEOMETRY_FORMAT_TRIANGLES_AMDX
//             Negative: false
//             Extends: VkGeometryTypeKHR
//             Offset: 0
//         Enum:
//             Name: VK_BUFFER_USAGE_2_COMPRESSED_DATA_DGF1_BIT_AMDX
//             Negative: false
//             Bitpos: 33
//             Extends: VkBufferUsageFlagBits2
//         Type:
//             Name: VkPhysicalDeviceDenseGeometryFormatFeaturesAMDX
//         Type:
//             Name: VkAccelerationStructureDenseGeometryFormatTrianglesDataAMDX
//         Type:
//             Name: VkCompressedTriangleFormatAMDX
//         Enum:
//             Name: VK_COMPRESSED_TRIANGLE_FORMAT_DGF1_BYTE_ALIGNMENT_AMDX
//             Negative: false
//         Enum:
//             Name: VK_COMPRESSED_TRIANGLE_FORMAT_DGF1_BYTE_STRIDE_AMDX
//             Negative: false
//         Feature:
//             Name: denseGeometryFormat
//             Struct: VkPhysicalDeviceDenseGeometryFormatFeaturesAMDX
// Extension: VK_KHR_present_id2
// Number: 480
// Type: device
// Author: KHR
// Depends: VK_KHR_get_surface_capabilities2+VK_KHR_surface+VK_KHR_swapchain
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_PRESENT_ID_2_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_PRESENT_ID_2_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_present_id2&quot;
//         Enum:
//             Name: VK_SWAPCHAIN_CREATE_PRESENT_ID_2_BIT_KHR
//             Negative: false
//             Bitpos: 6
//             Extends: VkSwapchainCreateFlagBitsKHR
//             Comment:
//                 Allow use of VK_KHR_present_id2 with this swapchain
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_ID_2_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PRESENT_ID_2_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_2_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Type:
//             Name: VkSurfaceCapabilitiesPresentId2KHR
//         Type:
//             Name: VkPresentId2KHR
//         Type:
//             Name: VkPhysicalDevicePresentId2FeaturesKHR
//         Feature:
//             Name: presentId2
//             Struct: VkPhysicalDevicePresentId2FeaturesKHR
// Extension: VK_KHR_present_wait2
// Number: 481
// Type: device
// Author: KHR
// Depends: VK_KHR_get_surface_capabilities2+VK_KHR_surface+VK_KHR_swapchain+VK_KHR_present_id2
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_PRESENT_WAIT_2_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_PRESENT_WAIT_2_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_present_wait2&quot;
//         Enum:
//             Name: VK_SWAPCHAIN_CREATE_PRESENT_WAIT_2_BIT_KHR
//             Negative: false
//             Bitpos: 7
//             Extends: VkSwapchainCreateFlagBitsKHR
//             Comment:
//                 Allow use of VK_KHR_present_wait2 with this swapchain
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_WAIT_2_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_2_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PRESENT_WAIT_2_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Type:
//             Name: VkSurfaceCapabilitiesPresentWait2KHR
//         Type:
//             Name: VkPhysicalDevicePresentWait2FeaturesKHR
//         Type:
//             Name: VkPresentWait2InfoKHR
//         Command:
//             Name: vkWaitForPresent2KHR
//         Feature:
//             Name: presentWait2
//             Struct: VkPhysicalDevicePresentWait2FeaturesKHR
// Extension: VK_KHR_ray_tracing_position_fetch
// Number: 482
// Type: device
// Author: KHR
// Depends: VK_KHR_acceleration_structure
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_RAY_TRACING_POSITION_FETCH_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_RAY_TRACING_POSITION_FETCH_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_ray_tracing_position_fetch&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_POSITION_FETCH_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DATA_ACCESS_BIT_KHR
//             Negative: false
//             Bitpos: 11
//             Extends: VkBuildAccelerationStructureFlagBitsKHR
//         Enum:
//             Name: VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DATA_ACCESS_KHR
//             Negative: false
//             Extends: VkBuildAccelerationStructureFlagBitsKHR
//             Alias: VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DATA_ACCESS_BIT_KHR
//         Type:
//             Name: VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR
//         Feature:
//             Name: rayTracingPositionFetch
//             Struct: VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR
// Extension: VK_EXT_shader_object
// Number: 483
// Type: device
// Author: EXT
// Depends: ((VK_KHR_get_physical_device_properties2,VK_VERSION_1_1)+VK_KHR_dynamic_rendering),VK_VERSION_1_3
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_SHADER_OBJECT_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_SHADER_OBJECT_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_shader_object&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_PROPERTIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SHADER_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VERTEX_INPUT_BINDING_DESCRIPTION_2_EXT
//             Negative: false
//             Extends: VkStructureType
//             Extnumber: 353
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VERTEX_INPUT_ATTRIBUTE_DESCRIPTION_2_EXT
//             Negative: false
//             Extends: VkStructureType
//             Extnumber: 353
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SHADER_REQUIRED_SUBGROUP_SIZE_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO
//         Enum:
//             Name: VK_OBJECT_TYPE_SHADER_EXT
//             Negative: false
//             Extends: VkObjectType
//             Offset: 0
//         Enum:
//             Name: VK_INCOMPATIBLE_SHADER_BINARY_EXT
//             Negative: false
//             Extends: VkResult
//             Offset: 0
//         Enum:
//             Name: VK_ERROR_INCOMPATIBLE_SHADER_BINARY_EXT
//             Negative: false
//             Extends: VkResult
//             Alias: VK_INCOMPATIBLE_SHADER_BINARY_EXT
//         Type:
//             Name: VkShaderEXT
//         Type:
//             Name: VkShaderCreateFlagBitsEXT
//         Type:
//             Name: VkShaderCreateFlagsEXT
//         Type:
//             Name: VkShaderCodeTypeEXT
//         Type:
//             Name: VkPhysicalDeviceShaderObjectFeaturesEXT
//         Type:
//             Name: VkPhysicalDeviceShaderObjectPropertiesEXT
//         Type:
//             Name: VkShaderCreateInfoEXT
//         Type:
//             Name: VkShaderRequiredSubgroupSizeCreateInfoEXT
//         Type:
//             Name: VkVertexInputBindingDescription2EXT
//         Type:
//             Name: VkVertexInputAttributeDescription2EXT
//         Type:
//             Name: VkColorBlendEquationEXT
//         Type:
//             Name: VkColorBlendAdvancedEXT
//         Command:
//             Name: vkCreateShadersEXT
//         Command:
//             Name: vkDestroyShaderEXT
//         Command:
//             Name: vkGetShaderBinaryDataEXT
//         Command:
//             Name: vkCmdBindShadersEXT
//         Command:
//             Name: vkCmdSetCullModeEXT
//         Command:
//             Name: vkCmdSetFrontFaceEXT
//         Command:
//             Name: vkCmdSetPrimitiveTopologyEXT
//         Command:
//             Name: vkCmdSetViewportWithCountEXT
//         Command:
//             Name: vkCmdSetScissorWithCountEXT
//         Command:
//             Name: vkCmdBindVertexBuffers2EXT
//         Command:
//             Name: vkCmdSetDepthTestEnableEXT
//         Command:
//             Name: vkCmdSetDepthWriteEnableEXT
//         Command:
//             Name: vkCmdSetDepthCompareOpEXT
//         Command:
//             Name: vkCmdSetDepthBoundsTestEnableEXT
//         Command:
//             Name: vkCmdSetStencilTestEnableEXT
//         Command:
//             Name: vkCmdSetStencilOpEXT
//         Command:
//             Name: vkCmdSetVertexInputEXT
//         Command:
//             Name: vkCmdSetPatchControlPointsEXT
//         Command:
//             Name: vkCmdSetRasterizerDiscardEnableEXT
//         Command:
//             Name: vkCmdSetDepthBiasEnableEXT
//         Command:
//             Name: vkCmdSetLogicOpEXT
//         Command:
//             Name: vkCmdSetPrimitiveRestartEnableEXT
//         Command:
//             Name: vkCmdSetTessellationDomainOriginEXT
//         Command:
//             Name: vkCmdSetDepthClampEnableEXT
//         Command:
//             Name: vkCmdSetPolygonModeEXT
//         Command:
//             Name: vkCmdSetRasterizationSamplesEXT
//         Command:
//             Name: vkCmdSetSampleMaskEXT
//         Command:
//             Name: vkCmdSetAlphaToCoverageEnableEXT
//         Command:
//             Name: vkCmdSetAlphaToOneEnableEXT
//         Command:
//             Name: vkCmdSetLogicOpEnableEXT
//         Command:
//             Name: vkCmdSetColorBlendEnableEXT
//         Command:
//             Name: vkCmdSetColorBlendEquationEXT
//         Command:
//             Name: vkCmdSetColorWriteMaskEXT
//         Feature:
//             Name: shaderObject
//             Struct: VkPhysicalDeviceShaderObjectFeaturesEXT
//     Depends: VK_EXT_transform_feedback
//         Command:
//             Name: vkCmdSetRasterizationStreamEXT
//     Depends: VK_EXT_conservative_rasterization
//         Command:
//             Name: vkCmdSetConservativeRasterizationModeEXT
//         Command:
//             Name: vkCmdSetExtraPrimitiveOverestimationSizeEXT
//     Depends: VK_EXT_depth_clip_enable
//         Command:
//             Name: vkCmdSetDepthClipEnableEXT
//     Depends: VK_EXT_sample_locations
//         Command:
//             Name: vkCmdSetSampleLocationsEnableEXT
//     Depends: VK_EXT_blend_operation_advanced
//         Command:
//             Name: vkCmdSetColorBlendAdvancedEXT
//     Depends: VK_EXT_provoking_vertex
//         Command:
//             Name: vkCmdSetProvokingVertexModeEXT
//     Depends: VK_EXT_line_rasterization
//         Command:
//             Name: vkCmdSetLineRasterizationModeEXT
//         Command:
//             Name: vkCmdSetLineStippleEnableEXT
//     Depends: VK_EXT_depth_clip_control
//         Command:
//             Name: vkCmdSetDepthClipNegativeOneToOneEXT
//     Depends: VK_EXT_subgroup_size_control,VK_VERSION_1_3
//         Enum:
//             Name: VK_SHADER_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT
//             Negative: false
//             Bitpos: 1
//             Extends: VkShaderCreateFlagBitsEXT
//         Enum:
//             Name: VK_SHADER_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT
//             Negative: false
//             Bitpos: 2
//             Extends: VkShaderCreateFlagBitsEXT
//     Depends: VK_EXT_mesh_shader,VK_NV_mesh_shader
//         Enum:
//             Name: VK_SHADER_CREATE_NO_TASK_SHADER_BIT_EXT
//             Negative: false
//             Bitpos: 3
//             Extends: VkShaderCreateFlagBitsEXT
//     Depends: VK_KHR_device_group,VK_VERSION_1_1
//         Enum:
//             Name: VK_SHADER_CREATE_DISPATCH_BASE_BIT_EXT
//             Negative: false
//             Bitpos: 4
//             Extends: VkShaderCreateFlagBitsEXT
//     Depends: VK_KHR_fragment_shading_rate
//         Enum:
//             Name: VK_SHADER_CREATE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_EXT
//             Negative: false
//             Bitpos: 5
//             Extends: VkShaderCreateFlagBitsEXT
//     Depends: VK_EXT_fragment_density_map
//         Enum:
//             Name: VK_SHADER_CREATE_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT
//             Negative: false
//             Bitpos: 6
//             Extends: VkShaderCreateFlagBitsEXT
//     Depends: VK_NV_clip_space_w_scaling
//         Command:
//             Name: vkCmdSetViewportWScalingEnableNV
//     Depends: VK_NV_viewport_swizzle
//         Command:
//             Name: vkCmdSetViewportSwizzleNV
//     Depends: VK_NV_fragment_coverage_to_color
//         Command:
//             Name: vkCmdSetCoverageToColorEnableNV
//         Command:
//             Name: vkCmdSetCoverageToColorLocationNV
//     Depends: VK_NV_framebuffer_mixed_samples
//         Command:
//             Name: vkCmdSetCoverageModulationModeNV
//         Command:
//             Name: vkCmdSetCoverageModulationTableEnableNV
//         Command:
//             Name: vkCmdSetCoverageModulationTableNV
//     Depends: VK_NV_shading_rate_image
//         Command:
//             Name: vkCmdSetShadingRateImageEnableNV
//     Depends: VK_NV_representative_fragment_test
//         Command:
//             Name: vkCmdSetRepresentativeFragmentTestEnableNV
//     Depends: VK_NV_coverage_reduction_mode
//         Command:
//             Name: vkCmdSetCoverageReductionModeNV
//     Depends: VK_EXT_depth_clamp_control
//         Command:
//             Name: vkCmdSetDepthClampRangeEXT
// Extension: VK_KHR_pipeline_binary
// Number: 484
// Type: device
// Author: KHR
// Depends: VK_KHR_maintenance5,VK_VERSION_1_4
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_PIPELINE_BINARY_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_PIPELINE_BINARY_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_pipeline_binary&quot;
//         Enum:
//             Name: VK_MAX_PIPELINE_BINARY_KEY_SIZE_KHR
//             Negative: false
//         Type:
//             Name: VkPhysicalDevicePipelineBinaryFeaturesKHR
//         Type:
//             Name: VkPhysicalDevicePipelineBinaryPropertiesKHR
//         Type:
//             Name: VkDevicePipelineBinaryInternalCacheControlKHR
//         Type:
//             Name: VkPipelineBinaryKHR
//         Type:
//             Name: VkPipelineBinaryKeyKHR
//         Type:
//             Name: VkPipelineBinaryDataKHR
//         Type:
//             Name: VkPipelineBinaryKeysAndDataKHR
//         Type:
//             Name: VkPipelineBinaryCreateInfoKHR
//         Type:
//             Name: VkPipelineBinaryInfoKHR
//         Type:
//             Name: VkReleaseCapturedPipelineDataInfoKHR
//         Type:
//             Name: VkPipelineBinaryDataInfoKHR
//         Type:
//             Name: VkPipelineCreateInfoKHR
//         Type:
//             Name: VkPipelineBinaryHandlesInfoKHR
//         Command:
//             Name: vkCreatePipelineBinariesKHR
//         Command:
//             Name: vkDestroyPipelineBinaryKHR
//         Command:
//             Name: vkGetPipelineKeyKHR
//         Command:
//             Name: vkGetPipelineBinaryDataKHR
//         Command:
//             Name: vkReleaseCapturedPipelineDataKHR
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PIPELINE_BINARY_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PIPELINE_BINARY_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PIPELINE_BINARY_KEY_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 4
//         Enum:
//             Name: VK_STRUCTURE_TYPE_RELEASE_CAPTURED_PIPELINE_DATA_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 5
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PIPELINE_BINARY_DATA_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 6
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PIPELINE_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 7
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DEVICE_PIPELINE_BINARY_INTERNAL_CACHE_CONTROL_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 8
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PIPELINE_BINARY_HANDLES_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 9
//         Enum:
//             Name: VK_OBJECT_TYPE_PIPELINE_BINARY_KHR
//             Negative: false
//             Extends: VkObjectType
//             Offset: 0
//         Enum:
//             Name: VK_PIPELINE_BINARY_MISSING_KHR
//             Negative: false
//             Extends: VkResult
//             Offset: 0
//         Enum:
//             Name: VK_ERROR_NOT_ENOUGH_SPACE_KHR
//             Negative: true
//             Extends: VkResult
//             Offset: 0
//         Enum:
//             Name: VK_PIPELINE_CREATE_2_CAPTURE_DATA_BIT_KHR
//             Negative: false
//             Bitpos: 31
//             Extends: VkPipelineCreateFlagBits2
//         Feature:
//             Name: pipelineBinaries
//             Struct: VkPhysicalDevicePipelineBinaryFeaturesKHR
// Extension: VK_QCOM_tile_properties
// Number: 485
// Type: device
// Author: QCOM
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_QCOM_TILE_PROPERTIES_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_QCOM_TILE_PROPERTIES_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_QCOM_tile_properties&quot;
//         Command:
//             Name: vkGetFramebufferTilePropertiesQCOM
//         Command:
//             Name: vkGetDynamicRenderingTilePropertiesQCOM
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_PROPERTIES_FEATURES_QCOM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_TILE_PROPERTIES_QCOM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Type:
//             Name: VkPhysicalDeviceTilePropertiesFeaturesQCOM
//         Type:
//             Name: VkTilePropertiesQCOM
//         Feature:
//             Name: tileProperties
//             Struct: VkPhysicalDeviceTilePropertiesFeaturesQCOM
//     Depends: VK_KHR_dynamic_rendering,VK_VERSION_1_3
//         Type:
//             Name: VkRenderingInfoKHR
// Extension: VK_SEC_amigo_profiling
// Number: 486
// Type: device
// Author: SEC
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_SEC_AMIGO_PROFILING_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_SEC_AMIGO_PROFILING_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_SEC_amigo_profiling&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_AMIGO_PROFILING_FEATURES_SEC
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_AMIGO_PROFILING_SUBMIT_INFO_SEC
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Type:
//             Name: VkPhysicalDeviceAmigoProfilingFeaturesSEC
//         Type:
//             Name: VkAmigoProfilingSubmitInfoSEC
//         Feature:
//             Name: amigoProfiling
//             Struct: VkPhysicalDeviceAmigoProfilingFeaturesSEC
// Extension: VK_KHR_surface_maintenance1
// Number: 487
// Type: instance
// Author: KHR
// Depends: VK_KHR_surface,VK_KHR_get_surface_capabilities2
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_SURFACE_MAINTENANCE_1_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_SURFACE_MAINTENANCE_1_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_surface_maintenance1&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_KHR
//             Negative: false
//             Extends: VkStructureType
//             Extnumber: 275
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SURFACE_PRESENT_SCALING_CAPABILITIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Extnumber: 275
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_COMPATIBILITY_KHR
//             Negative: false
//             Extends: VkStructureType
//             Extnumber: 275
//             Offset: 2
//         Type:
//             Name: VkSurfacePresentModeKHR
//         Type:
//             Name: VkPresentScalingFlagBitsKHR
//         Type:
//             Name: VkPresentScalingFlagsKHR
//         Type:
//             Name: VkPresentGravityFlagBitsKHR
//         Type:
//             Name: VkPresentGravityFlagsKHR
//         Type:
//             Name: VkSurfacePresentScalingCapabilitiesKHR
//         Type:
//             Name: VkSurfacePresentModeCompatibilityKHR
// Extension: VK_KHR_swapchain_maintenance1
// Number: 488
// Type: device
// Author: KHR
// Depends: VK_KHR_swapchain,VK_KHR_surface_maintenance1,VK_KHR_get_physical_device_properties2
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_SWAPCHAIN_MAINTENANCE_1_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_SWAPCHAIN_MAINTENANCE_1_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_swapchain_maintenance1&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Extnumber: 276
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Extnumber: 276
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODES_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Extnumber: 276
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Extnumber: 276
//             Offset: 3
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_SCALING_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Extnumber: 276
//             Offset: 4
//         Enum:
//             Name: VK_STRUCTURE_TYPE_RELEASE_SWAPCHAIN_IMAGES_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Extnumber: 276
//             Offset: 5
//         Enum:
//             Name: VK_SWAPCHAIN_CREATE_DEFERRED_MEMORY_ALLOCATION_BIT_KHR
//             Negative: false
//             Bitpos: 3
//             Extends: VkSwapchainCreateFlagBitsKHR
//         Type:
//             Name: VkPhysicalDeviceSwapchainMaintenance1FeaturesKHR
//         Type:
//             Name: VkSwapchainPresentFenceInfoKHR
//         Type:
//             Name: VkSwapchainPresentModesCreateInfoKHR
//         Type:
//             Name: VkSwapchainPresentModeInfoKHR
//         Type:
//             Name: VkSwapchainPresentScalingCreateInfoKHR
//         Type:
//             Name: VkReleaseSwapchainImagesInfoKHR
//         Command:
//             Name: vkReleaseSwapchainImagesKHR
//         Feature:
//             Name: swapchainMaintenance1
//             Struct: VkPhysicalDeviceSwapchainMaintenance1FeaturesKHR
// Extension: VK_QCOM_multiview_per_view_viewports
// Number: 489
// Type: device
// Author: QCOM
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_QCOM_MULTIVIEW_PER_VIEW_VIEWPORTS_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_QCOM_MULTIVIEW_PER_VIEW_VIEWPORTS_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_QCOM_multiview_per_view_viewports&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_VIEWPORTS_FEATURES_QCOM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM
//         Feature:
//             Name: multiviewPerViewViewports
//             Struct: VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM
// Extension: VK_NV_external_sci_sync2
// Number: 490
// Type: device
// Author: NV
// Depends: VK_VERSION_1_1
// Platform: sci
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NV_EXTERNAL_SCI_SYNC_2_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_NV_EXTERNAL_SCI_SYNC_2_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_external_sci_sync2&quot;
//         Enum:
//             Name: VK_OBJECT_TYPE_SEMAPHORE_SCI_SYNC_POOL_NV
//             Negative: false
//             Extends: VkObjectType
//             Offset: 0
//             Comment:
//                 VkSemaphoreSciSyncPoolNV
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SEMAPHORE_SCI_SYNC_POOL_CREATE_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SEMAPHORE_SCI_SYNC_CREATE_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SCI_SYNC_2_FEATURES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Type:
//             Name: VkSemaphoreSciSyncPoolNV
//         Type:
//             Name: VkPhysicalDeviceExternalSciSync2FeaturesNV
//         Type:
//             Name: VkSemaphoreSciSyncPoolCreateInfoNV
//         Type:
//             Name: VkSemaphoreSciSyncCreateInfoNV
//         Command:
//             Name: vkCreateSemaphoreSciSyncPoolNV
//         Command:
//             Name: vkDestroySemaphoreSciSyncPoolNV
//         Feature:
//             Name: sciSyncFence,sciSyncSemaphore2
//             Struct: VkPhysicalDeviceExternalSciSync2FeaturesNV
//         Feature:
//             Name: sciSyncImport,sciSyncExport
//             Struct: VkPhysicalDeviceExternalSciSync2FeaturesNV
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMPORT_FENCE_SCI_SYNC_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Extnumber: 374
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_EXPORT_FENCE_SCI_SYNC_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Extnumber: 374
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_FENCE_GET_SCI_SYNC_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Extnumber: 374
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SCI_SYNC_ATTRIBUTES_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Extnumber: 374
//             Offset: 3
//         Enum:
//             Name: VK_EXTERNAL_FENCE_HANDLE_TYPE_SCI_SYNC_OBJ_BIT_NV
//             Negative: false
//             Bitpos: 4
//             Extends: VkExternalFenceHandleTypeFlagBits
//         Enum:
//             Name: VK_EXTERNAL_FENCE_HANDLE_TYPE_SCI_SYNC_FENCE_BIT_NV
//             Negative: false
//             Bitpos: 5
//             Extends: VkExternalFenceHandleTypeFlagBits
//         Type:
//             Name: VkSciSyncClientTypeNV
//         Type:
//             Name: VkSciSyncPrimitiveTypeNV
//         Type:
//             Name: VkExportFenceSciSyncInfoNV
//         Type:
//             Name: VkImportFenceSciSyncInfoNV
//         Type:
//             Name: VkFenceGetSciSyncInfoNV
//         Type:
//             Name: VkSciSyncAttributesInfoNV
//         Command:
//             Name: vkGetFenceSciSyncFenceNV
//         Command:
//             Name: vkGetFenceSciSyncObjNV
//         Command:
//             Name: vkImportFenceSciSyncFenceNV
//         Command:
//             Name: vkImportFenceSciSyncObjNV
//         Command:
//             Name: vkGetPhysicalDeviceSciSyncAttributesNV
//     Depends: VKSC_VERSION_1_0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DEVICE_SEMAPHORE_SCI_SYNC_POOL_RESERVATION_CREATE_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Type:
//             Name: VkDeviceSemaphoreSciSyncPoolReservationCreateInfoNV
// Extension: VK_NV_ray_tracing_invocation_reorder
// Number: 491
// Type: device
// Author: NV
// Depends: VK_KHR_ray_tracing_pipeline
// Supported: supported
// Promoted to: VK_EXT_ray_tracing_invocation_reorder
// Unlocks:
//         Enum:
//             Name: VK_NV_RAY_TRACING_INVOCATION_REORDER_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_NV_RAY_TRACING_INVOCATION_REORDER_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_ray_tracing_invocation_reorder&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_FEATURES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_PROPERTIES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Type:
//             Name: VkRayTracingInvocationReorderModeNV
//         Enum:
//             Name: VK_RAY_TRACING_INVOCATION_REORDER_MODE_NONE_NV
//             Negative: false
//             Extends: VkRayTracingInvocationReorderModeEXT
//             Alias: VK_RAY_TRACING_INVOCATION_REORDER_MODE_NONE_EXT
//         Enum:
//             Name: VK_RAY_TRACING_INVOCATION_REORDER_MODE_REORDER_NV
//             Negative: false
//             Extends: VkRayTracingInvocationReorderModeEXT
//             Alias: VK_RAY_TRACING_INVOCATION_REORDER_MODE_REORDER_EXT
//         Type:
//             Name: VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV
//         Type:
//             Name: VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV
//         Feature:
//             Name: rayTracingInvocationReorder
//             Struct: VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV
// Extension: VK_NV_cooperative_vector
// Number: 492
// Type: device
// Author: NV
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NV_COOPERATIVE_VECTOR_SPEC_VERSION
//             Negative: false
//             Value: 4
//         Enum:
//             Name: VK_NV_COOPERATIVE_VECTOR_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_cooperative_vector&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_VECTOR_FEATURES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_VECTOR_PROPERTIES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_COOPERATIVE_VECTOR_PROPERTIES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_CONVERT_COOPERATIVE_VECTOR_MATRIX_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 4
//         Enum:
//             Name: VK_COMPONENT_TYPE_SINT8_PACKED_NV
//             Negative: false
//             Extends: VkComponentTypeKHR
//             Offset: 0
//         Enum:
//             Name: VK_COMPONENT_TYPE_UINT8_PACKED_NV
//             Negative: false
//             Extends: VkComponentTypeKHR
//             Offset: 1
//         Enum:
//             Name: VK_COMPONENT_TYPE_FLOAT_E4M3_NV
//             Negative: false
//             Extends: VkComponentTypeKHR
//             Alias: VK_COMPONENT_TYPE_FLOAT8_E4M3_EXT
//         Enum:
//             Name: VK_COMPONENT_TYPE_FLOAT_E5M2_NV
//             Negative: false
//             Extends: VkComponentTypeKHR
//             Alias: VK_COMPONENT_TYPE_FLOAT8_E5M2_EXT
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_CONVERT_COOPERATIVE_VECTOR_MATRIX_BIT_NV
//             Negative: false
//             Bitpos: 44
//             Extends: VkPipelineStageFlagBits2
//         Type:
//             Name: VkPhysicalDeviceCooperativeVectorPropertiesNV
//         Type:
//             Name: VkPhysicalDeviceCooperativeVectorFeaturesNV
//         Type:
//             Name: VkCooperativeVectorPropertiesNV
//         Type:
//             Name: VkConvertCooperativeVectorMatrixInfoNV
//         Type:
//             Name: VkCooperativeVectorMatrixLayoutNV
//         Type:
//             Name: VkComponentTypeKHR
//         Type:
//             Name: VkDeviceOrHostAddressKHR
//         Type:
//             Name: VkDeviceOrHostAddressConstKHR
//         Command:
//             Name: vkGetPhysicalDeviceCooperativeVectorPropertiesNV
//         Command:
//             Name: vkConvertCooperativeVectorMatrixNV
//         Command:
//             Name: vkCmdConvertCooperativeVectorMatrixNV
//         Feature:
//             Name: cooperativeVector
//             Struct: VkPhysicalDeviceCooperativeVectorFeaturesNV
// Extension: VK_NV_extended_sparse_address_space
// Number: 493
// Type: device
// Author: NV
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NV_EXTENDED_SPARSE_ADDRESS_SPACE_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_NV_EXTENDED_SPARSE_ADDRESS_SPACE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_extended_sparse_address_space&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_FEATURES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_PROPERTIES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Type:
//             Name: VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV
//         Type:
//             Name: VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV
//         Feature:
//             Name: extendedSparseAddressSpace
//             Struct: VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV
// Extension: VK_NV_extension_494
// Number: 494
// Type: invalid
// Author: NV
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_NV_EXTENSION_494_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_NV_EXTENSION_494_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_extension_494&quot;
// Extension: VK_EXT_mutable_descriptor_type
// Number: 495
// Type: device
// Author: EXT
// Depends: VK_KHR_maintenance3,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_MUTABLE_DESCRIPTOR_TYPE_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_MUTABLE_DESCRIPTOR_TYPE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_mutable_descriptor_type&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Extnumber: 352
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Extnumber: 352
//             Offset: 2
//         Enum:
//             Name: VK_DESCRIPTOR_TYPE_MUTABLE_EXT
//             Negative: false
//             Extends: VkDescriptorType
//             Extnumber: 352
//             Offset: 0
//         Enum:
//             Name: VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_EXT
//             Negative: false
//             Bitpos: 2
//             Extends: VkDescriptorPoolCreateFlagBits
//         Enum:
//             Name: VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_EXT
//             Negative: false
//             Bitpos: 2
//             Extends: VkDescriptorSetLayoutCreateFlagBits
//         Type:
//             Name: VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT
//         Type:
//             Name: VkMutableDescriptorTypeListEXT
//         Type:
//             Name: VkMutableDescriptorTypeCreateInfoEXT
//         Feature:
//             Name: mutableDescriptorType
//             Struct: VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT
// Extension: VK_EXT_legacy_vertex_attributes
// Number: 496
// Type: device
// Author: EXT
// Depends: VK_EXT_vertex_input_dynamic_state
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_LEGACY_VERTEX_ATTRIBUTES_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_LEGACY_VERTEX_ATTRIBUTES_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_legacy_vertex_attributes&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_PROPERTIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Type:
//             Name: VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT
//         Type:
//             Name: VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT
//         Feature:
//             Name: legacyVertexAttributes
//             Struct: VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT
// Extension: VK_EXT_layer_settings
// Number: 497
// Type: instance
// Author: EXT
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_LAYER_SETTINGS_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_EXT_LAYER_SETTINGS_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_layer_settings&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_LAYER_SETTINGS_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkLayerSettingsCreateInfoEXT
//         Type:
//             Name: VkLayerSettingEXT
//         Type:
//             Name: VkLayerSettingTypeEXT
// Extension: VK_ARM_shader_core_builtins
// Number: 498
// Type: device
// Author: ARM
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_ARM_SHADER_CORE_BUILTINS_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_ARM_SHADER_CORE_BUILTINS_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_ARM_shader_core_builtins&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_FEATURES_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_PROPERTIES_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Type:
//             Name: VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM
//         Type:
//             Name: VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM
//         Feature:
//             Name: shaderCoreBuiltins
//             Struct: VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM
// Extension: VK_EXT_pipeline_library_group_handles
// Number: 499
// Type: device
// Author: EXT
// Depends: VK_KHR_ray_tracing_pipeline+VK_KHR_pipeline_library
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_PIPELINE_LIBRARY_GROUP_HANDLES_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_PIPELINE_LIBRARY_GROUP_HANDLES_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_pipeline_library_group_handles&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_LIBRARY_GROUP_HANDLES_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT
//         Feature:
//             Name: pipelineLibraryGroupHandles
//             Struct: VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT
// Extension: VK_EXT_dynamic_rendering_unused_attachments
// Number: 500
// Type: device
// Author: EXT
// Depends: ((VK_KHR_get_physical_device_properties2,VK_VERSION_1_1)+VK_KHR_dynamic_rendering),VK_VERSION_1_3
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_dynamic_rendering_unused_attachments&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT
//         Feature:
//             Name: dynamicRenderingUnusedAttachments
//             Struct: VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT
// Extension: VK_EXT_extension_501
// Number: 501
// Type: device
// Author: SEC
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_501_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_501_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_501&quot;
// Extension: VK_EXT_extension_502
// Number: 502
// Type: device
// Author: HUAWEI
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_502_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_502_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_502&quot;
// Extension: VK_EXT_extension_503
// Number: 503
// Type: device
// Author: HUAWEI
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_503_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_503_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_503&quot;
// Extension: VK_NV_extension_504
// Number: 504
// Type: instance
// Author: NV
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_NV_EXTENSION_504_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_NV_EXTENSION_504_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_extension_504&quot;
// Extension: VK_EXT_extension_505
// Number: 505
// Type: device
// Author: EXT
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_505_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_505_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_505&quot;
//         Enum:
//             Name: VK_DEVICE_QUEUE_CREATE_RESERVED_2_BIT_EXT
//             Negative: false
//             Bitpos: 2
//             Extends: VkDeviceQueueCreateFlagBits
// Extension: VK_NV_low_latency2
// Number: 506
// Type: device
// Author: NV
// Depends: (VK_VERSION_1_2,VK_KHR_timeline_semaphore)+(VK_KHR_present_id,VK_KHR_present_id2)
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NV_LOW_LATENCY_2_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_NV_LOW_LATENCY_2_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_low_latency2&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_LATENCY_SLEEP_MODE_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_LATENCY_SLEEP_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SET_LATENCY_MARKER_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_GET_LATENCY_MARKER_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Enum:
//             Name: VK_STRUCTURE_TYPE_LATENCY_TIMINGS_FRAME_REPORT_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 4
//         Enum:
//             Name: VK_STRUCTURE_TYPE_LATENCY_SUBMISSION_PRESENT_ID_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 5
//         Enum:
//             Name: VK_STRUCTURE_TYPE_OUT_OF_BAND_QUEUE_TYPE_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 6
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SWAPCHAIN_LATENCY_CREATE_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 7
//         Enum:
//             Name: VK_STRUCTURE_TYPE_LATENCY_SURFACE_CAPABILITIES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 8
//         Type:
//             Name: VkLatencySleepModeInfoNV
//         Type:
//             Name: VkLatencySleepInfoNV
//         Type:
//             Name: VkSetLatencyMarkerInfoNV
//         Type:
//             Name: VkGetLatencyMarkerInfoNV
//         Type:
//             Name: VkLatencyTimingsFrameReportNV
//         Type:
//             Name: VkLatencyMarkerNV
//         Type:
//             Name: VkLatencySubmissionPresentIdNV
//         Type:
//             Name: VkSwapchainLatencyCreateInfoNV
//         Type:
//             Name: VkOutOfBandQueueTypeInfoNV
//         Type:
//             Name: VkOutOfBandQueueTypeNV
//         Type:
//             Name: VkLatencySurfaceCapabilitiesNV
//         Command:
//             Name: vkSetLatencySleepModeNV
//         Command:
//             Name: vkLatencySleepNV
//         Command:
//             Name: vkSetLatencyMarkerNV
//         Command:
//             Name: vkGetLatencyTimingsNV
//         Command:
//             Name: vkQueueNotifyOutOfBandNV
// Extension: VK_KHR_cooperative_matrix
// Number: 507
// Type: device
// Author: KHR
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_COOPERATIVE_MATRIX_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_KHR_COOPERATIVE_MATRIX_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_cooperative_matrix&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Type:
//             Name: VkCooperativeMatrixPropertiesKHR
//         Type:
//             Name: VkScopeKHR
//         Type:
//             Name: VkComponentTypeKHR
//         Type:
//             Name: VkPhysicalDeviceCooperativeMatrixFeaturesKHR
//         Type:
//             Name: VkPhysicalDeviceCooperativeMatrixPropertiesKHR
//         Command:
//             Name: vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR
//         Feature:
//             Name: cooperativeMatrix
//             Struct: VkPhysicalDeviceCooperativeMatrixFeaturesKHR
// Extension: VK_ARM_data_graph
// Number: 508
// Type: device
// Author: ARM
// Depends: VK_VERSION_1_3+VK_KHR_maintenance5+VK_KHR_deferred_host_operations
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_ARM_DATA_GRAPH_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_ARM_DATA_GRAPH_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_ARM_data_graph&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_CREATE_INFO_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_CREATE_INFO_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_RESOURCE_INFO_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_CONSTANT_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_MEMORY_REQUIREMENTS_INFO_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 4
//         Enum:
//             Name: VK_STRUCTURE_TYPE_BIND_DATA_GRAPH_PIPELINE_SESSION_MEMORY_INFO_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 5
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DATA_GRAPH_FEATURES_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 6
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SHADER_MODULE_CREATE_INFO_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 7
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_PROPERTY_QUERY_RESULT_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 8
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_INFO_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 9
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_COMPILER_CONTROL_CREATE_INFO_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 10
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_REQUIREMENTS_INFO_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 11
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_REQUIREMENT_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 12
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_IDENTIFIER_CREATE_INFO_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 13
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_DISPATCH_INFO_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 14
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DATA_GRAPH_PROCESSING_ENGINE_CREATE_INFO_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 16
//         Enum:
//             Name: VK_STRUCTURE_TYPE_QUEUE_FAMILY_DATA_GRAPH_PROCESSING_ENGINE_PROPERTIES_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 17
//         Enum:
//             Name: VK_STRUCTURE_TYPE_QUEUE_FAMILY_DATA_GRAPH_PROPERTIES_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 18
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_QUEUE_FAMILY_DATA_GRAPH_PROCESSING_ENGINE_INFO_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 19
//         Enum:
//             Name: VK_OBJECT_TYPE_DATA_GRAPH_PIPELINE_SESSION_ARM
//             Negative: false
//             Extends: VkObjectType
//             Offset: 0
//         Enum:
//             Name: VK_PIPELINE_BIND_POINT_DATA_GRAPH_ARM
//             Negative: false
//             Extends: VkPipelineBindPoint
//             Offset: 0
//         Enum:
//             Name: VK_QUEUE_DATA_GRAPH_BIT_ARM
//             Negative: false
//             Bitpos: 10
//             Extends: VkQueueFlagBits
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_DATA_GRAPH_BIT_ARM
//             Negative: false
//             Bitpos: 42
//             Extends: VkPipelineStageFlagBits2
//         Enum:
//             Name: VK_ACCESS_2_DATA_GRAPH_READ_BIT_ARM
//             Negative: false
//             Bitpos: 47
//             Extends: VkAccessFlagBits2
//         Enum:
//             Name: VK_ACCESS_2_DATA_GRAPH_WRITE_BIT_ARM
//             Negative: false
//             Bitpos: 48
//             Extends: VkAccessFlagBits2
//         Enum:
//             Name: VK_TENSOR_USAGE_DATA_GRAPH_BIT_ARM
//             Negative: false
//             Bitpos: 5
//             Extends: VkTensorUsageFlagBitsARM
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_TENSOR_DATA_GRAPH_BIT_ARM
//             Negative: false
//             Bitpos: 48
//             Extends: VkFormatFeatureFlagBits2
//         Enum:
//             Name: VK_BUFFER_USAGE_2_DATA_GRAPH_FOREIGN_DESCRIPTOR_BIT_ARM
//             Negative: false
//             Bitpos: 29
//             Extends: VkBufferUsageFlagBits2
//         Enum:
//             Name: VK_MAX_PHYSICAL_DEVICE_DATA_GRAPH_OPERATION_SET_NAME_SIZE_ARM
//             Negative: false
//         Type:
//             Name: VkPhysicalDeviceDataGraphFeaturesARM
//         Type:
//             Name: VkDataGraphPipelineSessionARM
//         Type:
//             Name: VkDataGraphPipelineSessionBindPointARM
//         Type:
//             Name: VkDataGraphPipelineSessionBindPointTypeARM
//         Type:
//             Name: VkDataGraphPipelineConstantARM
//         Type:
//             Name: VkDataGraphPipelineResourceInfoARM
//         Type:
//             Name: VkDataGraphPipelineCompilerControlCreateInfoARM
//         Type:
//             Name: VkDataGraphPipelineCreateInfoARM
//         Type:
//             Name: VkDataGraphPipelineShaderModuleCreateInfoARM
//         Type:
//             Name: VkDataGraphPipelineSessionCreateInfoARM
//         Type:
//             Name: VkDataGraphPipelineSessionCreateFlagsARM
//         Type:
//             Name: VkDataGraphPipelineSessionCreateFlagBitsARM
//         Type:
//             Name: VkDataGraphPipelineSessionBindPointRequirementsInfoARM
//         Type:
//             Name: VkDataGraphPipelineSessionBindPointRequirementARM
//         Type:
//             Name: VkDataGraphPipelineSessionMemoryRequirementsInfoARM
//         Type:
//             Name: VkBindDataGraphPipelineSessionMemoryInfoARM
//         Type:
//             Name: VkDataGraphPipelineInfoARM
//         Type:
//             Name: VkDataGraphPipelinePropertyQueryResultARM
//         Type:
//             Name: VkDataGraphPipelinePropertyARM
//         Type:
//             Name: VkDataGraphPipelineIdentifierCreateInfoARM
//         Type:
//             Name: VkDataGraphPipelineDispatchFlagsARM
//         Type:
//             Name: VkDataGraphPipelineDispatchFlagBitsARM
//         Type:
//             Name: VkDataGraphPipelineDispatchInfoARM
//         Type:
//             Name: VkPhysicalDeviceDataGraphProcessingEngineTypeARM
//         Type:
//             Name: VkPhysicalDeviceDataGraphOperationTypeARM
//         Type:
//             Name: VkPhysicalDeviceDataGraphProcessingEngineARM
//         Type:
//             Name: VkQueueFamilyDataGraphPropertiesARM
//         Type:
//             Name: VkDataGraphProcessingEngineCreateInfoARM
//         Type:
//             Name: VkPhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARM
//         Type:
//             Name: VkQueueFamilyDataGraphProcessingEnginePropertiesARM
//         Type:
//             Name: VkPhysicalDeviceDataGraphOperationSupportARM
//         Command:
//             Name: vkCreateDataGraphPipelinesARM
//         Command:
//             Name: vkCreateDataGraphPipelineSessionARM
//         Command:
//             Name: vkGetDataGraphPipelineSessionBindPointRequirementsARM
//         Command:
//             Name: vkGetDataGraphPipelineSessionMemoryRequirementsARM
//         Command:
//             Name: vkBindDataGraphPipelineSessionMemoryARM
//         Command:
//             Name: vkDestroyDataGraphPipelineSessionARM
//         Command:
//             Name: vkCmdDispatchDataGraphARM
//         Command:
//             Name: vkGetDataGraphPipelineAvailablePropertiesARM
//         Command:
//             Name: vkGetDataGraphPipelinePropertiesARM
//         Command:
//             Name: vkGetPhysicalDeviceQueueFamilyDataGraphPropertiesARM
//         Command:
//             Name: vkGetPhysicalDeviceQueueFamilyDataGraphProcessingEnginePropertiesARM
//         Feature:
//             Name: dataGraph
//             Struct: VkPhysicalDeviceDataGraphFeaturesARM
//     Depends: VK_ARM_tensors
//         Type:
//             Name: VkDataGraphPipelineConstantTensorSemiStructuredSparsityInfoARM
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_CONSTANT_TENSOR_SEMI_STRUCTURED_SPARSITY_INFO_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 15
// Extension: VK_EXT_extension_509
// Number: 509
// Type: device
// Author: EXT
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_509_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_509_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_509&quot;
// Extension: VK_MESA_extension_510
// Number: 510
// Type: device
// Author: MESA
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_MESA_EXTENSION_510_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_MESA_EXTENSION_510_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_MESA_extension_510&quot;
// Extension: VK_QCOM_multiview_per_view_render_areas
// Number: 511
// Type: device
// Author: QCOM
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_QCOM_MULTIVIEW_PER_VIEW_RENDER_AREAS_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_QCOM_MULTIVIEW_PER_VIEW_RENDER_AREAS_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_QCOM_multiview_per_view_render_areas&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_RENDER_AREAS_FEATURES_QCOM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_RENDER_AREAS_RENDER_PASS_BEGIN_INFO_QCOM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Type:
//             Name: VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM
//         Type:
//             Name: VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM
//         Feature:
//             Name: multiviewPerViewRenderAreas
//             Struct: VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM
// Extension: VK_KHR_compute_shader_derivatives
// Number: 512
// Type: device
// Author: KHR
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_COMPUTE_SHADER_DERIVATIVES_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_COMPUTE_SHADER_DERIVATIVES_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_compute_shader_derivatives&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Extnumber: 202
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR
//         Type:
//             Name: VkPhysicalDeviceComputeShaderDerivativesPropertiesKHR
//         Feature:
//             Name: computeDerivativeGroupLinear
//             Struct: VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR
// Extension: VK_KHR_video_decode_av1
// Number: 513
// Type: device
// Author: KHR
// Depends: VK_KHR_video_decode_queue
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_VIDEO_DECODE_AV1_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_VIDEO_DECODE_AV1_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_video_decode_av1&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_CAPABILITIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_PICTURE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_PROFILE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_SESSION_PARAMETERS_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 4
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_DPB_SLOT_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 5
//         Enum:
//             Name: VK_VIDEO_CODEC_OPERATION_DECODE_AV1_BIT_KHR
//             Negative: false
//             Bitpos: 2
//             Extends: VkVideoCodecOperationFlagBitsKHR
//         Enum:
//             Name: VK_MAX_VIDEO_AV1_REFERENCES_PER_FRAME_KHR
//             Negative: false
//         Type:
//             Name: VkVideoDecodeAV1ProfileInfoKHR
//         Type:
//             Name: VkVideoDecodeAV1CapabilitiesKHR
//         Type:
//             Name: VkVideoDecodeAV1SessionParametersCreateInfoKHR
//         Type:
//             Name: VkVideoDecodeAV1PictureInfoKHR
//         Type:
//             Name: VkVideoDecodeAV1DpbSlotInfoKHR
// Extension: VK_KHR_video_encode_av1
// Number: 514
// Type: device
// Author: KHR
// Depends: VK_KHR_video_encode_queue
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_VIDEO_ENCODE_AV1_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_VIDEO_ENCODE_AV1_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_video_encode_av1&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_CAPABILITIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_SESSION_PARAMETERS_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_PICTURE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_DPB_SLOT_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_AV1_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 4
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_PROFILE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 5
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_RATE_CONTROL_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 6
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_RATE_CONTROL_LAYER_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 7
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_QUALITY_LEVEL_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 8
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_SESSION_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 9
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_GOP_REMAINING_FRAME_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 10
//         Enum:
//             Name: VK_VIDEO_CODEC_OPERATION_ENCODE_AV1_BIT_KHR
//             Negative: false
//             Bitpos: 18
//             Extends: VkVideoCodecOperationFlagBitsKHR
//         Enum:
//             Name: VK_MAX_VIDEO_AV1_REFERENCES_PER_FRAME_KHR
//             Negative: false
//         Type:
//             Name: VkPhysicalDeviceVideoEncodeAV1FeaturesKHR
//         Type:
//             Name: VkVideoEncodeAV1PredictionModeKHR
//         Type:
//             Name: VkVideoEncodeAV1RateControlGroupKHR
//         Type:
//             Name: VkVideoEncodeAV1CapabilityFlagBitsKHR
//         Type:
//             Name: VkVideoEncodeAV1CapabilityFlagsKHR
//         Type:
//             Name: VkVideoEncodeAV1StdFlagBitsKHR
//         Type:
//             Name: VkVideoEncodeAV1StdFlagsKHR
//         Type:
//             Name: VkVideoEncodeAV1SuperblockSizeFlagBitsKHR
//         Type:
//             Name: VkVideoEncodeAV1SuperblockSizeFlagsKHR
//         Type:
//             Name: VkVideoEncodeAV1CapabilitiesKHR
//         Type:
//             Name: VkVideoEncodeAV1QualityLevelPropertiesKHR
//         Type:
//             Name: VkVideoEncodeAV1SessionCreateInfoKHR
//         Type:
//             Name: VkVideoEncodeAV1SessionParametersCreateInfoKHR
//         Type:
//             Name: VkVideoEncodeAV1PictureInfoKHR
//         Type:
//             Name: VkVideoEncodeAV1DpbSlotInfoKHR
//         Type:
//             Name: VkVideoEncodeAV1ProfileInfoKHR
//         Type:
//             Name: VkVideoEncodeAV1QIndexKHR
//         Type:
//             Name: VkVideoEncodeAV1FrameSizeKHR
//         Type:
//             Name: VkVideoEncodeAV1GopRemainingFrameInfoKHR
//         Type:
//             Name: VkVideoEncodeAV1RateControlInfoKHR
//         Type:
//             Name: VkVideoEncodeAV1RateControlFlagBitsKHR
//         Type:
//             Name: VkVideoEncodeAV1RateControlFlagsKHR
//         Type:
//             Name: VkVideoEncodeAV1RateControlLayerInfoKHR
//         Feature:
//             Name: videoEncodeAV1
//             Struct: VkPhysicalDeviceVideoEncodeAV1FeaturesKHR
// Extension: VK_KHR_video_decode_vp9
// Number: 515
// Type: device
// Author: KHR
// Depends: VK_KHR_video_decode_queue
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_VIDEO_DECODE_VP9_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_VIDEO_DECODE_VP9_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_video_decode_vp9&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_DECODE_VP9_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_DECODE_VP9_CAPABILITIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_DECODE_VP9_PICTURE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_DECODE_VP9_PROFILE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Enum:
//             Name: VK_VIDEO_CODEC_OPERATION_DECODE_VP9_BIT_KHR
//             Negative: false
//             Bitpos: 3
//             Extends: VkVideoCodecOperationFlagBitsKHR
//         Enum:
//             Name: VK_MAX_VIDEO_VP9_REFERENCES_PER_FRAME_KHR
//             Negative: false
//         Type:
//             Name: VkPhysicalDeviceVideoDecodeVP9FeaturesKHR
//         Type:
//             Name: VkVideoDecodeVP9ProfileInfoKHR
//         Type:
//             Name: VkVideoDecodeVP9CapabilitiesKHR
//         Type:
//             Name: VkVideoDecodeVP9PictureInfoKHR
//         Feature:
//             Name: videoDecodeVP9
//             Struct: VkPhysicalDeviceVideoDecodeVP9FeaturesKHR
// Extension: VK_KHR_video_maintenance1
// Number: 516
// Type: device
// Author: KHR
// Depends: VK_KHR_video_queue
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_VIDEO_MAINTENANCE_1_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_VIDEO_MAINTENANCE_1_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_video_maintenance1&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_1_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_INLINE_QUERY_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_IMAGE_CREATE_VIDEO_PROFILE_INDEPENDENT_BIT_KHR
//             Negative: false
//             Bitpos: 20
//             Extends: VkImageCreateFlagBits
//         Enum:
//             Name: VK_BUFFER_CREATE_VIDEO_PROFILE_INDEPENDENT_BIT_KHR
//             Negative: false
//             Bitpos: 6
//             Extends: VkBufferCreateFlagBits
//         Enum:
//             Name: VK_VIDEO_SESSION_CREATE_INLINE_QUERIES_BIT_KHR
//             Negative: false
//             Bitpos: 2
//             Extends: VkVideoSessionCreateFlagBitsKHR
//         Type:
//             Name: VkPhysicalDeviceVideoMaintenance1FeaturesKHR
//         Type:
//             Name: VkVideoInlineQueryInfoKHR
//         Feature:
//             Name: videoMaintenance1
//             Struct: VkPhysicalDeviceVideoMaintenance1FeaturesKHR
// Extension: VK_NV_per_stage_descriptor_set
// Number: 517
// Type: device
// Author: NV
// Depends: VK_KHR_maintenance6,VK_VERSION_1_4
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NV_PER_STAGE_DESCRIPTOR_SET_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_NV_PER_STAGE_DESCRIPTOR_SET_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_per_stage_descriptor_set&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PER_STAGE_DESCRIPTOR_SET_FEATURES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_DESCRIPTOR_SET_LAYOUT_CREATE_PER_STAGE_BIT_NV
//             Negative: false
//             Bitpos: 6
//             Extends: VkDescriptorSetLayoutCreateFlagBits
//         Type:
//             Name: VkPhysicalDevicePerStageDescriptorSetFeaturesNV
//         Feature:
//             Name: perStageDescriptorSet
//             Struct: VkPhysicalDevicePerStageDescriptorSetFeaturesNV
// Extension: VK_MESA_extension_518
// Number: 518
// Type: device
// Author: MESA
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_MESA_EXTENSION_518_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_MESA_EXTENSION_518_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_MESA_extension_518&quot;
// Extension: VK_QCOM_image_processing2
// Number: 519
// Type: device
// Author: QCOM
// Depends: VK_QCOM_image_processing
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_QCOM_IMAGE_PROCESSING_2_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_QCOM_IMAGE_PROCESSING_2_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_QCOM_image_processing2&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_FEATURES_QCOM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_PROPERTIES_QCOM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SAMPLER_BLOCK_MATCH_WINDOW_CREATE_INFO_QCOM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Type:
//             Name: VkPhysicalDeviceImageProcessing2FeaturesQCOM
//         Type:
//             Name: VkPhysicalDeviceImageProcessing2PropertiesQCOM
//         Type:
//             Name: VkSamplerBlockMatchWindowCreateInfoQCOM
//         Type:
//             Name: VkBlockMatchWindowCompareModeQCOM
//         Feature:
//             Name: textureBlockMatch2
//             Struct: VkPhysicalDeviceImageProcessing2FeaturesQCOM
// Extension: VK_QCOM_filter_cubic_weights
// Number: 520
// Type: device
// Author: QCOM
// Depends: VK_EXT_filter_cubic
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_QCOM_FILTER_CUBIC_WEIGHTS_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_QCOM_FILTER_CUBIC_WEIGHTS_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_QCOM_filter_cubic_weights&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SAMPLER_CUBIC_WEIGHTS_CREATE_INFO_QCOM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_WEIGHTS_FEATURES_QCOM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_BLIT_IMAGE_CUBIC_WEIGHTS_INFO_QCOM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Type:
//             Name: VkPhysicalDeviceCubicWeightsFeaturesQCOM
//         Type:
//             Name: VkSamplerCubicWeightsCreateInfoQCOM
//         Type:
//             Name: VkBlitImageCubicWeightsInfoQCOM
//         Type:
//             Name: VkCubicFilterWeightsQCOM
//         Feature:
//             Name: selectableCubicWeights
//             Struct: VkPhysicalDeviceCubicWeightsFeaturesQCOM
// Extension: VK_QCOM_ycbcr_degamma
// Number: 521
// Type: device
// Author: QCOM
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_QCOM_YCBCR_DEGAMMA_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_QCOM_YCBCR_DEGAMMA_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_QCOM_ycbcr_degamma&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_DEGAMMA_FEATURES_QCOM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_YCBCR_DEGAMMA_CREATE_INFO_QCOM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Type:
//             Name: VkPhysicalDeviceYcbcrDegammaFeaturesQCOM
//         Type:
//             Name: VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM
//         Feature:
//             Name: ycbcrDegamma
//             Struct: VkPhysicalDeviceYcbcrDegammaFeaturesQCOM
// Extension: VK_QCOM_filter_cubic_clamp
// Number: 522
// Type: device
// Author: QCOM
// Depends: (VK_EXT_filter_cubic)+(VK_VERSION_1_2,VK_EXT_sampler_filter_minmax)
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_QCOM_FILTER_CUBIC_CLAMP_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_QCOM_FILTER_CUBIC_CLAMP_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_QCOM_filter_cubic_clamp&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_CLAMP_FEATURES_QCOM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_RANGECLAMP_QCOM
//             Negative: false
//             Extends: VkSamplerReductionMode
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceCubicClampFeaturesQCOM
//         Feature:
//             Name: cubicRangeClamp
//             Struct: VkPhysicalDeviceCubicClampFeaturesQCOM
// Extension: VK_EXT_extension_523
// Number: 523
// Type: invalid
// Author: EXT
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_523_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_523_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_523&quot;
// Extension: VK_EXT_extension_524
// Number: 524
// Type: invalid
// Author: EXT
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_524_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_524_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_524&quot;
// Extension: VK_EXT_attachment_feedback_loop_dynamic_state
// Number: 525
// Type: device
// Author: EXT
// Depends: (VK_KHR_get_physical_device_properties2,VK_VERSION_1_1)+VK_EXT_attachment_feedback_loop_layout
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_attachment_feedback_loop_dynamic_state&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT
//             Negative: false
//             Extends: VkDynamicState
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT
//         Command:
//             Name: vkCmdSetAttachmentFeedbackLoopEnableEXT
//         Feature:
//             Name: attachmentFeedbackLoopDynamicState
//             Struct: VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT
// Extension: VK_KHR_vertex_attribute_divisor
// Number: 526
// Type: device
// Author: KHR
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_4
// Unlocks:
//         Enum:
//             Name: VK_KHR_VERTEX_ATTRIBUTE_DIVISOR_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_VERTEX_ATTRIBUTE_DIVISOR_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_vertex_attribute_divisor&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES
//         Type:
//             Name: VkPhysicalDeviceVertexAttributeDivisorPropertiesKHR
//         Type:
//             Name: VkVertexInputBindingDivisorDescriptionKHR
//         Type:
//             Name: VkPipelineVertexInputDivisorStateCreateInfoKHR
//         Type:
//             Name: VkPhysicalDeviceVertexAttributeDivisorFeaturesKHR
//         Feature:
//             Name: vertexAttributeInstanceRateDivisor
//             Struct: VkPhysicalDeviceVertexAttributeDivisorFeaturesKHR
// Extension: VK_KHR_load_store_op_none
// Number: 527
// Type: device
// Author: KHR
// Supported: supported
// Promoted to: VK_VERSION_1_4
// Unlocks:
//         Enum:
//             Name: VK_KHR_LOAD_STORE_OP_NONE_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_LOAD_STORE_OP_NONE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_load_store_op_none&quot;
//         Enum:
//             Name: VK_ATTACHMENT_LOAD_OP_NONE_KHR
//             Negative: false
//             Extends: VkAttachmentLoadOp
//             Alias: VK_ATTACHMENT_LOAD_OP_NONE
//         Enum:
//             Name: VK_ATTACHMENT_STORE_OP_NONE_KHR
//             Negative: false
//             Extends: VkAttachmentStoreOp
//             Alias: VK_ATTACHMENT_STORE_OP_NONE
// Extension: VK_KHR_unified_image_layouts
// Number: 528
// Type: device
// Author: KHR
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_UNIFIED_IMAGE_LAYOUTS_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_UNIFIED_IMAGE_LAYOUTS_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_unified_image_layouts&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFIED_IMAGE_LAYOUTS_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceUnifiedImageLayoutsFeaturesKHR
//         Feature:
//             Name: unifiedImageLayouts
//             Struct: VkPhysicalDeviceUnifiedImageLayoutsFeaturesKHR
//     Depends: VK_EXT_attachment_feedback_loop_layout+(VK_VERSION_1_3,VK_KHR_dynamic_rendering)
//         Enum:
//             Name: VK_STRUCTURE_TYPE_ATTACHMENT_FEEDBACK_LOOP_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Type:
//             Name: VkAttachmentFeedbackLoopInfoEXT
// Extension: VK_KHR_shader_float_controls2
// Number: 529
// Type: device
// Author: KHR
// Depends: VK_VERSION_1_1+VK_KHR_shader_float_controls
// Supported: supported
// Promoted to: VK_VERSION_1_4
// Unlocks:
//         Enum:
//             Name: VK_KHR_SHADER_FLOAT_CONTROLS_2_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_SHADER_FLOAT_CONTROLS_2_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_shader_float_controls2&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT_CONTROLS_2_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT_CONTROLS_2_FEATURES
//         Type:
//             Name: VkPhysicalDeviceShaderFloatControls2FeaturesKHR
//         Feature:
//             Name: shaderFloatControls2
//             Struct: VkPhysicalDeviceShaderFloatControls2FeaturesKHR
// Extension: VK_QNX_external_memory_screen_buffer
// Number: 530
// Type: device
// Author: QNX
// Depends: ((VK_KHR_sampler_ycbcr_conversion+VK_KHR_external_memory+VK_KHR_dedicated_allocation),VK_VERSION_1_1)+VK_EXT_queue_family_foreign
// Platform: screen
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_QNX_EXTERNAL_MEMORY_SCREEN_BUFFER_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_QNX_EXTERNAL_MEMORY_SCREEN_BUFFER_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_QNX_external_memory_screen_buffer&quot;
//         Enum:
//             Name: VK_EXTERNAL_MEMORY_HANDLE_TYPE_SCREEN_BUFFER_BIT_QNX
//             Negative: false
//             Bitpos: 14
//             Extends: VkExternalMemoryHandleTypeFlagBits
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SCREEN_BUFFER_PROPERTIES_QNX
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SCREEN_BUFFER_FORMAT_PROPERTIES_QNX
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMPORT_SCREEN_BUFFER_INFO_QNX
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_QNX
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_SCREEN_BUFFER_FEATURES_QNX
//             Negative: false
//             Extends: VkStructureType
//             Offset: 4
//         Type:
//             Name: VkScreenBufferPropertiesQNX
//         Type:
//             Name: VkScreenBufferFormatPropertiesQNX
//         Type:
//             Name: VkImportScreenBufferInfoQNX
//         Type:
//             Name: VkExternalFormatQNX
//         Type:
//             Name: VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX
//         Command:
//             Name: vkGetScreenBufferPropertiesQNX
//         Feature:
//             Name: screenBufferImport
//             Struct: VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX
// Extension: VK_MSFT_layered_driver
// Number: 531
// Type: device
// Author: MSFT
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_MSFT_LAYERED_DRIVER_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_MSFT_LAYERED_DRIVER_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_MSFT_layered_driver&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_DRIVER_PROPERTIES_MSFT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkLayeredDriverUnderlyingApiMSFT
//         Type:
//             Name: VkPhysicalDeviceLayeredDriverPropertiesMSFT
// Extension: VK_KHR_extension_532
// Number: 532
// Type: invalid
// Author: KHR
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_KHR_EXTENSION_532_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_KHR_EXTENSION_532_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_extension_532&quot;
// Extension: VK_EXT_extension_533
// Number: 533
// Type: invalid
// Author: EXT
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_533_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_533_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_533&quot;
// Extension: VK_KHR_index_type_uint8
// Number: 534
// Type: device
// Author: KHR
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_4
// Unlocks:
//         Enum:
//             Name: VK_KHR_INDEX_TYPE_UINT8_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_INDEX_TYPE_UINT8_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_index_type_uint8&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES
//         Enum:
//             Name: VK_INDEX_TYPE_UINT8_KHR
//             Negative: false
//             Extends: VkIndexType
//             Alias: VK_INDEX_TYPE_UINT8
//         Type:
//             Name: VkPhysicalDeviceIndexTypeUint8FeaturesKHR
//         Feature:
//             Name: indexTypeUint8
//             Struct: VkPhysicalDeviceIndexTypeUint8FeaturesKHR
// Extension: VK_KHR_line_rasterization
// Number: 535
// Type: device
// Author: KHR
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_4
// Unlocks:
//         Enum:
//             Name: VK_KHR_LINE_RASTERIZATION_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_LINE_RASTERIZATION_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_line_rasterization&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES
//         Enum:
//             Name: VK_DYNAMIC_STATE_LINE_STIPPLE_KHR
//             Negative: false
//             Extends: VkDynamicState
//             Alias: VK_DYNAMIC_STATE_LINE_STIPPLE
//         Enum:
//             Name: VK_LINE_RASTERIZATION_MODE_DEFAULT_KHR
//             Negative: false
//             Extends: VkLineRasterizationMode
//             Alias: VK_LINE_RASTERIZATION_MODE_DEFAULT
//         Enum:
//             Name: VK_LINE_RASTERIZATION_MODE_RECTANGULAR_KHR
//             Negative: false
//             Extends: VkLineRasterizationMode
//             Alias: VK_LINE_RASTERIZATION_MODE_RECTANGULAR
//         Enum:
//             Name: VK_LINE_RASTERIZATION_MODE_BRESENHAM_KHR
//             Negative: false
//             Extends: VkLineRasterizationMode
//             Alias: VK_LINE_RASTERIZATION_MODE_BRESENHAM
//         Enum:
//             Name: VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_KHR
//             Negative: false
//             Extends: VkLineRasterizationMode
//             Alias: VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH
//         Type:
//             Name: VkPhysicalDeviceLineRasterizationFeaturesKHR
//         Type:
//             Name: VkPhysicalDeviceLineRasterizationPropertiesKHR
//         Type:
//             Name: VkPipelineRasterizationLineStateCreateInfoKHR
//         Type:
//             Name: VkLineRasterizationModeKHR
//         Command:
//             Name: vkCmdSetLineStippleKHR
//         Feature:
//             Name: rectangularLines,bresenhamLines,smoothLines,stippledRectangularLines,stippledBresenhamLines,stippledSmoothLines
//             Struct: VkPhysicalDeviceLineRasterizationFeaturesKHR
// Extension: VK_QCOM_extension_536
// Number: 536
// Type: device
// Author: QCOM
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_QCOM_EXTENSION_536_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_QCOM_EXTENSION_536_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_QCOM_extension_536&quot;
// Extension: VK_EXT_extension_537
// Number: 537
// Type: invalid
// Author: EXT
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_537_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_537_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_537&quot;
//         Enum:
//             Name: VK_QUEUE_RESERVED_12_BIT_EXT
//             Negative: false
//             Bitpos: 12
//             Extends: VkQueueFlagBits
//         Enum:
//             Name: VK_BUFFER_USAGE_2_RESERVED_34_BIT_EXT
//             Negative: false
//             Bitpos: 34
//             Extends: VkBufferUsageFlagBits2
//         Enum:
//             Name: VK_IMAGE_USAGE_RESERVED_28_BIT_EXT
//             Negative: false
//             Bitpos: 28
//             Extends: VkImageUsageFlagBits
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_RESERVED_60_BIT_EXT
//             Negative: false
//             Bitpos: 60
//             Extends: VkFormatFeatureFlagBits2
// Extension: VK_EXT_extension_538
// Number: 538
// Type: invalid
// Author: EXT
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_538_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_538_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_538&quot;
// Extension: VK_EXT_extension_539
// Number: 539
// Type: invalid
// Author: EXT
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_539_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_539_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_539&quot;
// Extension: VK_EXT_extension_540
// Number: 540
// Type: invalid
// Author: EXT
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_540_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_540_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_540&quot;
// Extension: VK_EXT_extension_541
// Number: 541
// Type: invalid
// Author: EXT
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_541_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_541_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_541&quot;
// Extension: VK_EXT_extension_542
// Number: 542
// Type: invalid
// Author: EXT
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_542_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_542_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_542&quot;
// Extension: VK_EXT_extension_543
// Number: 543
// Type: invalid
// Author: EXT
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_543_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_543_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_543&quot;
// Extension: VK_KHR_calibrated_timestamps
// Number: 544
// Type: device
// Author: KHR
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_CALIBRATED_TIMESTAMPS_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_CALIBRATED_TIMESTAMPS_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_calibrated_timestamps&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Extnumber: 185
//             Offset: 0
//         Type:
//             Name: VkTimeDomainKHR
//         Type:
//             Name: VkCalibratedTimestampInfoKHR
//         Command:
//             Name: vkGetPhysicalDeviceCalibrateableTimeDomainsKHR
//         Command:
//             Name: vkGetCalibratedTimestampsKHR
// Extension: VK_KHR_shader_expect_assume
// Number: 545
// Type: device
// Author: KHR
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_4
// Unlocks:
//         Enum:
//             Name: VK_KHR_SHADER_EXPECT_ASSUME_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_SHADER_EXPECT_ASSUME_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_shader_expect_assume&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EXPECT_ASSUME_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EXPECT_ASSUME_FEATURES
//         Type:
//             Name: VkPhysicalDeviceShaderExpectAssumeFeaturesKHR
//         Feature:
//             Name: shaderExpectAssume
//             Struct: VkPhysicalDeviceShaderExpectAssumeFeaturesKHR
// Extension: VK_KHR_maintenance6
// Number: 546
// Type: device
// Author: KHR
// Depends: VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_4
// Unlocks:
//         Enum:
//             Name: VK_KHR_MAINTENANCE_6_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_MAINTENANCE_6_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_maintenance6&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_FEATURES
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_PROPERTIES
//         Enum:
//             Name: VK_STRUCTURE_TYPE_BIND_MEMORY_STATUS_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_BIND_MEMORY_STATUS
//         Enum:
//             Name: VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_SETS_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_SETS_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PUSH_CONSTANTS_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PUSH_CONSTANTS_INFO
//         Type:
//             Name: VkPhysicalDeviceMaintenance6FeaturesKHR
//         Type:
//             Name: VkPhysicalDeviceMaintenance6PropertiesKHR
//         Type:
//             Name: VkBindMemoryStatusKHR
//         Type:
//             Name: VkBindDescriptorSetsInfoKHR
//         Type:
//             Name: VkPushConstantsInfoKHR
//         Command:
//             Name: vkCmdBindDescriptorSets2KHR
//         Command:
//             Name: vkCmdPushConstants2KHR
//         Feature:
//             Name: maintenance6
//             Struct: VkPhysicalDeviceMaintenance6FeaturesKHR
//     Depends: VK_KHR_push_descriptor
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_WITH_TEMPLATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_WITH_TEMPLATE_INFO
//         Type:
//             Name: VkPushDescriptorSetInfoKHR
//         Type:
//             Name: VkPushDescriptorSetWithTemplateInfoKHR
//         Command:
//             Name: vkCmdPushDescriptorSet2KHR
//         Command:
//             Name: vkCmdPushDescriptorSetWithTemplate2KHR
//     Depends: VK_EXT_descriptor_buffer
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SET_DESCRIPTOR_BUFFER_OFFSETS_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 7
//         Enum:
//             Name: VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_BUFFER_EMBEDDED_SAMPLERS_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 8
//         Type:
//             Name: VkSetDescriptorBufferOffsetsInfoEXT
//         Type:
//             Name: VkBindDescriptorBufferEmbeddedSamplersInfoEXT
//         Command:
//             Name: vkCmdSetDescriptorBufferOffsets2EXT
//         Command:
//             Name: vkCmdBindDescriptorBufferEmbeddedSamplers2EXT
// Extension: VK_NV_descriptor_pool_overallocation
// Number: 547
// Type: device
// Author: NV
// Depends: VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NV_DESCRIPTOR_POOL_OVERALLOCATION_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_NV_DESCRIPTOR_POOL_OVERALLOCATION_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_descriptor_pool_overallocation&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_POOL_OVERALLOCATION_FEATURES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_DESCRIPTOR_POOL_CREATE_ALLOW_OVERALLOCATION_SETS_BIT_NV
//             Negative: false
//             Bitpos: 3
//             Extends: VkDescriptorPoolCreateFlagBits
//         Enum:
//             Name: VK_DESCRIPTOR_POOL_CREATE_ALLOW_OVERALLOCATION_POOLS_BIT_NV
//             Negative: false
//             Bitpos: 4
//             Extends: VkDescriptorPoolCreateFlagBits
//         Type:
//             Name: VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV
//         Feature:
//             Name: descriptorPoolOverallocation
//             Struct: VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV
// Extension: VK_QCOM_tile_memory_heap
// Number: 548
// Type: device
// Author: QCOM
// Depends: (VK_KHR_get_memory_requirements2+VK_KHR_get_physical_device_properties2),VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_QCOM_TILE_MEMORY_HEAP_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_QCOM_TILE_MEMORY_HEAP_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_QCOM_tile_memory_heap&quot;
//         Enum:
//             Name: VK_MEMORY_HEAP_TILE_MEMORY_BIT_QCOM
//             Negative: false
//             Bitpos: 3
//             Extends: VkMemoryHeapFlagBits
//         Enum:
//             Name: VK_BUFFER_USAGE_TILE_MEMORY_BIT_QCOM
//             Negative: false
//             Bitpos: 27
//             Extends: VkBufferUsageFlagBits
//         Enum:
//             Name: VK_BUFFER_USAGE_2_TILE_MEMORY_BIT_QCOM
//             Negative: false
//             Bitpos: 27
//             Extends: VkBufferUsageFlagBits2
//         Enum:
//             Name: VK_IMAGE_USAGE_TILE_MEMORY_BIT_QCOM
//             Negative: false
//             Bitpos: 27
//             Extends: VkImageUsageFlagBits
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_MEMORY_HEAP_FEATURES_QCOM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_MEMORY_HEAP_PROPERTIES_QCOM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_TILE_MEMORY_REQUIREMENTS_QCOM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_TILE_MEMORY_BIND_INFO_QCOM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Type:
//             Name: VkPhysicalDeviceTileMemoryHeapFeaturesQCOM
//         Type:
//             Name: VkPhysicalDeviceTileMemoryHeapPropertiesQCOM
//         Type:
//             Name: VkTileMemoryRequirementsQCOM
//         Type:
//             Name: VkTileMemoryBindInfoQCOM
//         Command:
//             Name: vkCmdBindTileMemoryQCOM
//         Feature:
//             Name: tileMemoryHeap
//             Struct: VkPhysicalDeviceTileMemoryHeapFeaturesQCOM
//     Depends: VK_QCOM_tile_properties
//         Enum:
//             Name: VK_STRUCTURE_TYPE_TILE_MEMORY_SIZE_INFO_QCOM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 4
//         Type:
//             Name: VkTileMemorySizeInfoQCOM
// Extension: VK_NV_extension_549
// Number: 549
// Type: invalid
// Author: NV
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_NV_EXTENSION_549_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_NV_EXTENSION_549_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_extension_549&quot;
// Extension: VK_KHR_copy_memory_indirect
// Number: 550
// Type: device
// Author: KHR
// Depends: (VK_KHR_get_physical_device_properties2+VK_KHR_buffer_device_address),VK_VERSION_1_2
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_COPY_MEMORY_INDIRECT_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_COPY_MEMORY_INDIRECT_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_copy_memory_indirect&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Extnumber: 427
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_COPY_MEMORY_INDIRECT_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_COPY_MEMORY_TO_IMAGE_INDIRECT_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_COPY_INDIRECT_BIT_KHR
//             Negative: false
//             Bitpos: 46
//             Extends: VkPipelineStageFlagBits2
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_COPY_IMAGE_INDIRECT_DST_BIT_KHR
//             Negative: false
//             Bitpos: 59
//             Extends: VkFormatFeatureFlagBits2
//         Type:
//             Name: VkStridedDeviceAddressRangeKHR
//         Type:
//             Name: VkAddressCopyFlagBitsKHR
//         Type:
//             Name: VkAddressCopyFlagsKHR
//         Type:
//             Name: VkCopyMemoryIndirectCommandKHR
//         Type:
//             Name: VkCopyMemoryIndirectInfoKHR
//         Type:
//             Name: VkCopyMemoryToImageIndirectCommandKHR
//         Type:
//             Name: VkCopyMemoryToImageIndirectInfoKHR
//         Type:
//             Name: VkPhysicalDeviceCopyMemoryIndirectFeaturesKHR
//         Type:
//             Name: VkPhysicalDeviceCopyMemoryIndirectPropertiesKHR
//         Command:
//             Name: vkCmdCopyMemoryIndirectKHR
//         Command:
//             Name: vkCmdCopyMemoryToImageIndirectKHR
//         Feature:
//             Name: indirectMemoryCopy
//             Struct: VkPhysicalDeviceCopyMemoryIndirectFeaturesKHR
// Extension: VK_EXT_memory_decompression
// Number: 551
// Type: device
// Author: EXT
// Depends: VK_KHR_get_physical_device_properties2+VK_KHR_buffer_device_address
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_MEMORY_DECOMPRESSION_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_MEMORY_DECOMPRESSION_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_memory_decompression&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Extnumber: 428
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_PROPERTIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Extnumber: 428
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DECOMPRESS_MEMORY_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_MEMORY_DECOMPRESSION_BIT_EXT
//             Negative: false
//             Bitpos: 45
//             Extends: VkPipelineStageFlagBits2
//         Enum:
//             Name: VK_ACCESS_2_MEMORY_DECOMPRESSION_READ_BIT_EXT
//             Negative: false
//             Bitpos: 55
//             Extends: VkAccessFlagBits2
//         Enum:
//             Name: VK_ACCESS_2_MEMORY_DECOMPRESSION_WRITE_BIT_EXT
//             Negative: false
//             Bitpos: 56
//             Extends: VkAccessFlagBits2
//         Enum:
//             Name: VK_BUFFER_USAGE_2_MEMORY_DECOMPRESSION_BIT_EXT
//             Negative: false
//             Bitpos: 32
//             Extends: VkBufferUsageFlagBits2
//         Type:
//             Name: VkMemoryDecompressionMethodFlagBitsEXT
//         Type:
//             Name: VkMemoryDecompressionMethodFlagsEXT
//         Type:
//             Name: VkDecompressMemoryInfoEXT
//         Type:
//             Name: VkDecompressMemoryRegionEXT
//         Type:
//             Name: VkPhysicalDeviceMemoryDecompressionFeaturesEXT
//         Type:
//             Name: VkPhysicalDeviceMemoryDecompressionPropertiesEXT
//         Command:
//             Name: vkCmdDecompressMemoryEXT
//         Command:
//             Name: vkCmdDecompressMemoryIndirectCountEXT
//         Feature:
//             Name: memoryDecompression
//             Struct: VkPhysicalDeviceMemoryDecompressionFeaturesEXT
// Extension: VK_NV_display_stereo
// Number: 552
// Type: instance
// Author: NV
// Depends: VK_KHR_display+VK_KHR_get_display_properties2
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NV_DISPLAY_STEREO_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_NV_DISPLAY_STEREO_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_display_stereo&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DISPLAY_SURFACE_STEREO_CREATE_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DISPLAY_MODE_STEREO_PROPERTIES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Type:
//             Name: VkDisplaySurfaceStereoCreateInfoNV
//         Type:
//             Name: VkDisplaySurfaceStereoTypeNV
//         Type:
//             Name: VkDisplayModeStereoPropertiesNV
// Extension: VK_KHR_video_encode_intra_refresh
// Number: 553
// Type: device
// Author: KHR
// Depends: VK_KHR_video_encode_queue
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_VIDEO_ENCODE_INTRA_REFRESH_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_VIDEO_ENCODE_INTRA_REFRESH_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_video_encode_intra_refresh&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_INTRA_REFRESH_CAPABILITIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_INTRA_REFRESH_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_INTRA_REFRESH_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_REFERENCE_INTRA_REFRESH_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_INTRA_REFRESH_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 4
//         Enum:
//             Name: VK_VIDEO_ENCODE_INTRA_REFRESH_BIT_KHR
//             Negative: false
//             Bitpos: 2
//             Extends: VkVideoEncodeFlagBitsKHR
//         Type:
//             Name: VkVideoEncodeIntraRefreshModeFlagsKHR
//         Type:
//             Name: VkVideoEncodeIntraRefreshModeFlagBitsKHR
//         Type:
//             Name: VkVideoEncodeIntraRefreshCapabilitiesKHR
//         Type:
//             Name: VkVideoEncodeSessionIntraRefreshCreateInfoKHR
//         Type:
//             Name: VkVideoEncodeIntraRefreshInfoKHR
//         Type:
//             Name: VkVideoReferenceIntraRefreshInfoKHR
//         Type:
//             Name: VkPhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR
//         Feature:
//             Name: videoEncodeIntraRefresh
//             Struct: VkPhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR
//     Depends: VK_KHR_video_encode_h264
//         Enum:
//             Name: VK_VIDEO_ENCODE_H264_CAPABILITY_B_PICTURE_INTRA_REFRESH_BIT_KHR
//             Negative: false
//             Bitpos: 10
//             Extends: VkVideoEncodeH264CapabilityFlagBitsKHR
//     Depends: VK_KHR_video_encode_h265
//         Enum:
//             Name: VK_VIDEO_ENCODE_H265_CAPABILITY_B_PICTURE_INTRA_REFRESH_BIT_KHR
//             Negative: false
//             Bitpos: 11
//             Extends: VkVideoEncodeH265CapabilityFlagBitsKHR
//     Depends: VK_KHR_video_encode_av1
//         Enum:
//             Name: VK_VIDEO_ENCODE_AV1_CAPABILITY_COMPOUND_PREDICTION_INTRA_REFRESH_BIT_KHR
//             Negative: false
//             Bitpos: 5
//             Extends: VkVideoEncodeAV1CapabilityFlagBitsKHR
// Extension: VK_KHR_video_encode_quantization_map
// Number: 554
// Type: device
// Author: KHR
// Depends: VK_KHR_video_encode_queue+(VK_KHR_format_feature_flags2,VK_VERSION_1_3)
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_VIDEO_ENCODE_QUANTIZATION_MAP_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_KHR_VIDEO_ENCODE_QUANTIZATION_MAP_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_video_encode_quantization_map&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_CAPABILITIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_FORMAT_QUANTIZATION_MAP_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_SESSION_PARAMETERS_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 5
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUANTIZATION_MAP_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 9
//         Enum:
//             Name: VK_VIDEO_ENCODE_CAPABILITY_QUANTIZATION_DELTA_MAP_BIT_KHR
//             Negative: false
//             Bitpos: 2
//             Extends: VkVideoEncodeCapabilityFlagBitsKHR
//         Enum:
//             Name: VK_VIDEO_ENCODE_CAPABILITY_EMPHASIS_MAP_BIT_KHR
//             Negative: false
//             Bitpos: 3
//             Extends: VkVideoEncodeCapabilityFlagBitsKHR
//         Enum:
//             Name: VK_VIDEO_SESSION_CREATE_ALLOW_ENCODE_QUANTIZATION_DELTA_MAP_BIT_KHR
//             Negative: false
//             Bitpos: 3
//             Extends: VkVideoSessionCreateFlagBitsKHR
//         Enum:
//             Name: VK_VIDEO_SESSION_CREATE_ALLOW_ENCODE_EMPHASIS_MAP_BIT_KHR
//             Negative: false
//             Bitpos: 4
//             Extends: VkVideoSessionCreateFlagBitsKHR
//         Enum:
//             Name: VK_VIDEO_SESSION_PARAMETERS_CREATE_QUANTIZATION_MAP_COMPATIBLE_BIT_KHR
//             Negative: false
//             Bitpos: 0
//             Extends: VkVideoSessionParametersCreateFlagBitsKHR
//         Enum:
//             Name: VK_VIDEO_ENCODE_WITH_QUANTIZATION_DELTA_MAP_BIT_KHR
//             Negative: false
//             Bitpos: 0
//             Extends: VkVideoEncodeFlagBitsKHR
//         Enum:
//             Name: VK_VIDEO_ENCODE_WITH_EMPHASIS_MAP_BIT_KHR
//             Negative: false
//             Bitpos: 1
//             Extends: VkVideoEncodeFlagBitsKHR
//         Enum:
//             Name: VK_IMAGE_USAGE_VIDEO_ENCODE_QUANTIZATION_DELTA_MAP_BIT_KHR
//             Negative: false
//             Bitpos: 25
//             Extends: VkImageUsageFlagBits
//         Enum:
//             Name: VK_IMAGE_USAGE_VIDEO_ENCODE_EMPHASIS_MAP_BIT_KHR
//             Negative: false
//             Bitpos: 26
//             Extends: VkImageUsageFlagBits
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_VIDEO_ENCODE_QUANTIZATION_DELTA_MAP_BIT_KHR
//             Negative: false
//             Bitpos: 49
//             Extends: VkFormatFeatureFlagBits2
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_VIDEO_ENCODE_EMPHASIS_MAP_BIT_KHR
//             Negative: false
//             Bitpos: 50
//             Extends: VkFormatFeatureFlagBits2
//         Enum:
//             Name: VK_IMAGE_LAYOUT_VIDEO_ENCODE_QUANTIZATION_MAP_KHR
//             Negative: false
//             Extends: VkImageLayout
//             Offset: 0
//         Type:
//             Name: VkVideoEncodeFlagBitsKHR
//         Type:
//             Name: VkVideoSessionParametersCreateFlagBitsKHR
//         Type:
//             Name: VkVideoEncodeQuantizationMapCapabilitiesKHR
//         Type:
//             Name: VkVideoFormatQuantizationMapPropertiesKHR
//         Type:
//             Name: VkVideoEncodeQuantizationMapInfoKHR
//         Type:
//             Name: VkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR
//         Type:
//             Name: VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR
//         Feature:
//             Name: videoEncodeQuantizationMap
//             Struct: VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR
//     Depends: VK_KHR_video_encode_h264
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_QUANTIZATION_MAP_CAPABILITIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Enum:
//             Name: VK_VIDEO_ENCODE_H264_CAPABILITY_MB_QP_DIFF_WRAPAROUND_BIT_KHR
//             Negative: false
//             Bitpos: 9
//             Extends: VkVideoEncodeH264CapabilityFlagBitsKHR
//         Type:
//             Name: VkVideoEncodeH264QuantizationMapCapabilitiesKHR
//     Depends: VK_KHR_video_encode_h265
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_QUANTIZATION_MAP_CAPABILITIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 4
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_FORMAT_H265_QUANTIZATION_MAP_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 6
//         Enum:
//             Name: VK_VIDEO_ENCODE_H265_CAPABILITY_CU_QP_DIFF_WRAPAROUND_BIT_KHR
//             Negative: false
//             Bitpos: 10
//             Extends: VkVideoEncodeH265CapabilityFlagBitsKHR
//         Type:
//             Name: VkVideoEncodeH265QuantizationMapCapabilitiesKHR
//         Type:
//             Name: VkVideoFormatH265QuantizationMapPropertiesKHR
//     Depends: VK_KHR_video_encode_av1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_QUANTIZATION_MAP_CAPABILITIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 7
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_FORMAT_AV1_QUANTIZATION_MAP_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 8
//         Type:
//             Name: VkVideoEncodeAV1QuantizationMapCapabilitiesKHR
//         Type:
//             Name: VkVideoFormatAV1QuantizationMapPropertiesKHR
// Extension: VK_IMG_extension_555
// Number: 555
// Type: invalid
// Author: IMG
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_IMG_EXTENSION_555_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_IMG_EXTENSION_555_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_IMG_extension_555&quot;
// Extension: VK_NV_raw_access_chains
// Number: 556
// Type: device
// Author: NV
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NV_RAW_ACCESS_CHAINS_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_NV_RAW_ACCESS_CHAINS_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_raw_access_chains&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAW_ACCESS_CHAINS_FEATURES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceRawAccessChainsFeaturesNV
//         Feature:
//             Name: shaderRawAccessChains
//             Struct: VkPhysicalDeviceRawAccessChainsFeaturesNV
// Extension: VK_NV_external_compute_queue
// Number: 557
// Type: device
// Author: NV
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NV_EXTERNAL_COMPUTE_QUEUE_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_NV_EXTERNAL_COMPUTE_QUEUE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_external_compute_queue&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_EXTERNAL_COMPUTE_QUEUE_DEVICE_CREATE_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_EXTERNAL_COMPUTE_QUEUE_CREATE_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_EXTERNAL_COMPUTE_QUEUE_DATA_PARAMS_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_COMPUTE_QUEUE_PROPERTIES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Enum:
//             Name: VK_OBJECT_TYPE_EXTERNAL_COMPUTE_QUEUE_NV
//             Negative: false
//             Extends: VkObjectType
//             Offset: 0
//         Type:
//             Name: VkExternalComputeQueueNV
//         Type:
//             Name: VkExternalComputeQueueDeviceCreateInfoNV
//         Type:
//             Name: VkExternalComputeQueueCreateInfoNV
//         Type:
//             Name: VkExternalComputeQueueDataParamsNV
//         Type:
//             Name: VkPhysicalDeviceExternalComputeQueuePropertiesNV
//         Command:
//             Name: vkCreateExternalComputeQueueNV
//         Command:
//             Name: vkDestroyExternalComputeQueueNV
//         Command:
//             Name: vkGetExternalComputeQueueDataNV
// Extension: VK_KHR_extension_558
// Number: 558
// Type: device
// Author: KHR
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_KHR_EXTENSION_558_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_KHR_EXTENSION_558_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_extension_558&quot;
// Extension: VK_KHR_shader_relaxed_extended_instruction
// Number: 559
// Type: device
// Author: KHR
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_SHADER_RELAXED_EXTENDED_INSTRUCTION_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_SHADER_RELAXED_EXTENDED_INSTRUCTION_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_shader_relaxed_extended_instruction&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_RELAXED_EXTENDED_INSTRUCTION_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR
//         Feature:
//             Name: shaderRelaxedExtendedInstruction
//             Struct: VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR
// Extension: VK_NV_command_buffer_inheritance
// Number: 560
// Type: device
// Author: NV
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NV_COMMAND_BUFFER_INHERITANCE_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_NV_COMMAND_BUFFER_INHERITANCE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_command_buffer_inheritance&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMMAND_BUFFER_INHERITANCE_FEATURES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceCommandBufferInheritanceFeaturesNV
//         Feature:
//             Name: commandBufferInheritance
//             Struct: VkPhysicalDeviceCommandBufferInheritanceFeaturesNV
// Extension: VK_EXT_extension_561
// Number: 561
// Type: invalid
// Author: EXT
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_561_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_561_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_561&quot;
// Extension: VK_KHR_extension_562
// Number: 562
// Type: invalid
// Author: KHR
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_KHR_EXTENSION_562_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_KHR_EXTENSION_562_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_extension_562&quot;
// Extension: VK_KHR_maintenance7
// Number: 563
// Type: device
// Author: KHR
// Depends: VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_MAINTENANCE_7_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_MAINTENANCE_7_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_maintenance7&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_7_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_7_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_PROPERTIES_LIST_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_VULKAN_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 4
//         Enum:
//             Name: VK_SUBPASS_CONTENTS_INLINE_AND_SECONDARY_COMMAND_BUFFERS_KHR
//             Negative: false
//             Extends: VkSubpassContents
//             Extnumber: 452
//             Offset: 0
//         Enum:
//             Name: VK_RENDERING_CONTENTS_INLINE_BIT_KHR
//             Negative: false
//             Bitpos: 4
//             Extends: VkRenderingFlagBits
//             Comment:
//                 Promoted from extension 452
//         Type:
//             Name: VkPhysicalDeviceMaintenance7FeaturesKHR
//         Type:
//             Name: VkPhysicalDeviceMaintenance7PropertiesKHR
//         Type:
//             Name: VkPhysicalDeviceLayeredApiPropertiesListKHR
//         Type:
//             Name: VkPhysicalDeviceLayeredApiPropertiesKHR
//         Type:
//             Name: VkPhysicalDeviceLayeredApiKHR
//         Type:
//             Name: VkPhysicalDeviceLayeredApiVulkanPropertiesKHR
//         Feature:
//             Name: maintenance7
//             Struct: VkPhysicalDeviceMaintenance7FeaturesKHR
// Extension: VK_NV_shader_atomic_float16_vector
// Number: 564
// Type: device
// Author: NV
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NV_SHADER_ATOMIC_FLOAT16_VECTOR_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_NV_SHADER_ATOMIC_FLOAT16_VECTOR_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_shader_atomic_float16_vector&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT16_VECTOR_FEATURES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV
//         Feature:
//             Name: shaderFloat16VectorAtomics
//             Struct: VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV
// Extension: VK_EXT_shader_replicated_composites
// Number: 565
// Type: device
// Author: EXT
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_SHADER_REPLICATED_COMPOSITES_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_SHADER_REPLICATED_COMPOSITES_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_shader_replicated_composites&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_REPLICATED_COMPOSITES_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT
//         Feature:
//             Name: shaderReplicatedComposites
//             Struct: VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT
// Extension: VK_ARM_extension_566
// Number: 566
// Type: invalid
// Author: ARM
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_ARM_EXTENSION_566_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_ARM_EXTENSION_566_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_ARM_extension_566&quot;
// Extension: VK_ARM_extension_567
// Number: 567
// Type: invalid
// Author: ARM
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_ARM_EXTENSION_567_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_ARM_EXTENSION_567_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_ARM_extension_567&quot;
// Extension: VK_EXT_shader_float8
// Number: 568
// Type: device
// Author: EXT
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_SHADER_FLOAT8_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_SHADER_FLOAT8_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_shader_float8&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT8_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceShaderFloat8FeaturesEXT
//         Feature:
//             Name: shaderFloat8
//             Struct: VkPhysicalDeviceShaderFloat8FeaturesEXT
//     Depends: VK_KHR_cooperative_matrix
//         Enum:
//             Name: VK_COMPONENT_TYPE_FLOAT8_E4M3_EXT
//             Negative: false
//             Extends: VkComponentTypeKHR
//             Extnumber: 492
//             Offset: 2
//         Enum:
//             Name: VK_COMPONENT_TYPE_FLOAT8_E5M2_EXT
//             Negative: false
//             Extends: VkComponentTypeKHR
//             Extnumber: 492
//             Offset: 3
// Extension: VK_NV_ray_tracing_validation
// Number: 569
// Type: device
// Author: NV
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NV_RAY_TRACING_VALIDATION_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_NV_RAY_TRACING_VALIDATION_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_ray_tracing_validation&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_VALIDATION_FEATURES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceRayTracingValidationFeaturesNV
//         Feature:
//             Name: rayTracingValidation
//             Struct: VkPhysicalDeviceRayTracingValidationFeaturesNV
// Extension: VK_NV_cluster_acceleration_structure
// Number: 570
// Type: device
// Author: NV
// Depends: VK_KHR_acceleration_structure
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NV_CLUSTER_ACCELERATION_STRUCTURE_SPEC_VERSION
//             Negative: false
//             Value: 4
//         Enum:
//             Name: VK_NV_CLUSTER_ACCELERATION_STRUCTURE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_cluster_acceleration_structure&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_ACCELERATION_STRUCTURE_FEATURES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_ACCELERATION_STRUCTURE_PROPERTIES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_CLUSTERS_BOTTOM_LEVEL_INPUT_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_TRIANGLE_CLUSTER_INPUT_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Enum:
//             Name: VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_MOVE_OBJECTS_INPUT_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 4
//         Enum:
//             Name: VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_INPUT_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 5
//         Enum:
//             Name: VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_COMMANDS_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 6
//         Enum:
//             Name: VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CLUSTER_ACCELERATION_STRUCTURE_CREATE_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 7
//         Enum:
//             Name: VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_CLUSTER_OPACITY_MICROMAPS_BIT_NV
//             Negative: false
//             Bitpos: 12
//             Extends: VkBuildAccelerationStructureFlagBitsKHR
//         Type:
//             Name: VkPhysicalDeviceClusterAccelerationStructureFeaturesNV
//         Type:
//             Name: VkPhysicalDeviceClusterAccelerationStructurePropertiesNV
//         Type:
//             Name: VkClusterAccelerationStructureClustersBottomLevelInputNV
//         Type:
//             Name: VkClusterAccelerationStructureTriangleClusterInputNV
//         Type:
//             Name: VkClusterAccelerationStructureMoveObjectsInputNV
//         Type:
//             Name: VkClusterAccelerationStructureOpInputNV
//         Type:
//             Name: VkClusterAccelerationStructureInputInfoNV
//         Type:
//             Name: VkClusterAccelerationStructureCommandsInfoNV
//         Type:
//             Name: VkStridedDeviceAddressNV
//         Type:
//             Name: VkClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV
//         Type:
//             Name: VkClusterAccelerationStructureClusterFlagsNV
//         Type:
//             Name: VkClusterAccelerationStructureClusterFlagBitsNV
//         Type:
//             Name: VkClusterAccelerationStructureGeometryFlagsNV
//         Type:
//             Name: VkClusterAccelerationStructureGeometryFlagBitsNV
//         Type:
//             Name: VkClusterAccelerationStructureAddressResolutionFlagsNV
//         Type:
//             Name: VkClusterAccelerationStructureAddressResolutionFlagBitsNV
//         Type:
//             Name: VkClusterAccelerationStructureMoveObjectsInfoNV
//         Type:
//             Name: VkClusterAccelerationStructureBuildClustersBottomLevelInfoNV
//         Type:
//             Name: VkClusterAccelerationStructureBuildTriangleClusterInfoNV
//         Type:
//             Name: VkClusterAccelerationStructureBuildTriangleClusterTemplateInfoNV
//         Type:
//             Name: VkClusterAccelerationStructureInstantiateClusterInfoNV
//         Type:
//             Name: VkClusterAccelerationStructureIndexFormatFlagBitsNV
//         Type:
//             Name: VkClusterAccelerationStructureIndexFormatFlagsNV
//         Type:
//             Name: VkClusterAccelerationStructureTypeNV
//         Type:
//             Name: VkClusterAccelerationStructureOpTypeNV
//         Type:
//             Name: VkClusterAccelerationStructureOpModeNV
//         Type:
//             Name: VkClusterAccelerationStructureGetTemplateIndicesInfoNV
//         Command:
//             Name: vkGetClusterAccelerationStructureBuildSizesNV
//         Command:
//             Name: vkCmdBuildClusterAccelerationStructureIndirectNV
//         Feature:
//             Name: clusterAccelerationStructure
//             Struct: VkPhysicalDeviceClusterAccelerationStructureFeaturesNV
//     Depends: VK_EXT_opacity_micromap
//         Enum:
//             Name: VK_OPACITY_MICROMAP_SPECIAL_INDEX_CLUSTER_GEOMETRY_DISABLE_OPACITY_MICROMAP_NV
//             Negative: false
//             Value: -5
//             Extends: VkOpacityMicromapSpecialIndexEXT
//     Depends: VK_KHR_ray_tracing_pipeline
//         Type:
//             Name: VkRayTracingPipelineClusterAccelerationStructureCreateInfoNV
// Extension: VK_NV_partitioned_acceleration_structure
// Number: 571
// Type: device
// Author: NV
// Depends: VK_KHR_acceleration_structure
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NV_PARTITIONED_ACCELERATION_STRUCTURE_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_NV_PARTITIONED_ACCELERATION_STRUCTURE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_partitioned_acceleration_structure&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PARTITIONED_ACCELERATION_STRUCTURE_FEATURES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PARTITIONED_ACCELERATION_STRUCTURE_PROPERTIES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_PARTITIONED_ACCELERATION_STRUCTURE_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCES_INPUT_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Enum:
//             Name: VK_STRUCTURE_TYPE_BUILD_PARTITIONED_ACCELERATION_STRUCTURE_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 4
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PARTITIONED_ACCELERATION_STRUCTURE_FLAGS_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 5
//         Enum:
//             Name: VK_DESCRIPTOR_TYPE_PARTITIONED_ACCELERATION_STRUCTURE_NV
//             Negative: false
//             Extends: VkDescriptorType
//             Offset: 0
//         Enum:
//             Name: VK_PARTITIONED_ACCELERATION_STRUCTURE_PARTITION_INDEX_GLOBAL_NV
//             Negative: false
//         Type:
//             Name: VkPhysicalDevicePartitionedAccelerationStructureFeaturesNV
//         Type:
//             Name: VkPhysicalDevicePartitionedAccelerationStructurePropertiesNV
//         Type:
//             Name: VkPartitionedAccelerationStructureFlagsNV
//         Type:
//             Name: VkPartitionedAccelerationStructureOpTypeNV
//         Type:
//             Name: VkBuildPartitionedAccelerationStructureIndirectCommandNV
//         Type:
//             Name: VkPartitionedAccelerationStructureInstanceFlagsNV
//         Type:
//             Name: VkPartitionedAccelerationStructureInstanceFlagBitsNV
//         Type:
//             Name: VkPartitionedAccelerationStructureWriteInstanceDataNV
//         Type:
//             Name: VkPartitionedAccelerationStructureUpdateInstanceDataNV
//         Type:
//             Name: VkPartitionedAccelerationStructureWritePartitionTranslationDataNV
//         Type:
//             Name: VkWriteDescriptorSetPartitionedAccelerationStructureNV
//         Type:
//             Name: VkPartitionedAccelerationStructureInstancesInputNV
//         Type:
//             Name: VkBuildPartitionedAccelerationStructureInfoNV
//         Command:
//             Name: vkGetPartitionedAccelerationStructuresBuildSizesNV
//         Command:
//             Name: vkCmdBuildPartitionedAccelerationStructuresNV
//         Feature:
//             Name: partitionedAccelerationStructure
//             Struct: VkPhysicalDevicePartitionedAccelerationStructureFeaturesNV
// Extension: VK_NV_extension_572
// Number: 572
// Type: invalid
// Author: NV
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_NV_EXTENSION_572_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_NV_EXTENSION_572_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_extension_572&quot;
// Extension: VK_EXT_device_generated_commands
// Number: 573
// Type: device
// Author: EXT
// Depends: ((VK_KHR_buffer_device_address,VK_VERSION_1_2)+VK_KHR_maintenance5),VK_VERSION_1_3
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_DEVICE_GENERATED_COMMANDS_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_DEVICE_GENERATED_COMMANDS_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_device_generated_commands&quot;
//         Enum:
//             Name: VK_SHADER_CREATE_INDIRECT_BINDABLE_BIT_EXT
//             Negative: false
//             Bitpos: 7
//             Extends: VkShaderCreateFlagBitsEXT
//         Enum:
//             Name: VK_BUFFER_USAGE_2_PREPROCESS_BUFFER_BIT_EXT
//             Negative: false
//             Bitpos: 31
//             Extends: VkBufferUsageFlagBits2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Enum:
//             Name: VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 4
//         Enum:
//             Name: VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 6
//         Enum:
//             Name: VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 7
//         Enum:
//             Name: VK_STRUCTURE_TYPE_WRITE_INDIRECT_EXECUTION_SET_PIPELINE_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 8
//         Enum:
//             Name: VK_STRUCTURE_TYPE_WRITE_INDIRECT_EXECUTION_SET_SHADER_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 9
//         Enum:
//             Name: VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_PIPELINE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 10
//         Enum:
//             Name: VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_SHADER_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 11
//         Enum:
//             Name: VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_SHADER_LAYOUT_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 12
//         Enum:
//             Name: VK_STRUCTURE_TYPE_GENERATED_COMMANDS_PIPELINE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 13
//         Enum:
//             Name: VK_STRUCTURE_TYPE_GENERATED_COMMANDS_SHADER_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 14
//         Enum:
//             Name: VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_EXT
//             Negative: false
//             Extends: VkObjectType
//             Offset: 0
//         Enum:
//             Name: VK_OBJECT_TYPE_INDIRECT_EXECUTION_SET_EXT
//             Negative: false
//             Extends: VkObjectType
//             Offset: 1
//         Enum:
//             Name: VK_PIPELINE_CREATE_2_INDIRECT_BINDABLE_BIT_EXT
//             Negative: false
//             Bitpos: 38
//             Extends: VkPipelineCreateFlagBits2
//         Enum:
//             Name: VK_PIPELINE_STAGE_COMMAND_PREPROCESS_BIT_EXT
//             Negative: false
//             Bitpos: 17
//             Extends: VkPipelineStageFlagBits
//         Enum:
//             Name: VK_ACCESS_COMMAND_PREPROCESS_READ_BIT_EXT
//             Negative: false
//             Bitpos: 17
//             Extends: VkAccessFlagBits
//         Enum:
//             Name: VK_ACCESS_COMMAND_PREPROCESS_WRITE_BIT_EXT
//             Negative: false
//             Bitpos: 18
//             Extends: VkAccessFlagBits
//         Type:
//             Name: VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT
//         Type:
//             Name: VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT
//         Type:
//             Name: VkGeneratedCommandsMemoryRequirementsInfoEXT
//         Type:
//             Name: VkIndirectExecutionSetCreateInfoEXT
//         Type:
//             Name: VkIndirectExecutionSetInfoEXT
//         Type:
//             Name: VkIndirectExecutionSetPipelineInfoEXT
//         Type:
//             Name: VkIndirectExecutionSetShaderInfoEXT
//         Type:
//             Name: VkGeneratedCommandsInfoEXT
//         Type:
//             Name: VkWriteIndirectExecutionSetPipelineEXT
//         Type:
//             Name: VkIndirectCommandsLayoutCreateInfoEXT
//         Type:
//             Name: VkIndirectCommandsLayoutTokenEXT
//         Type:
//             Name: VkDrawIndirectCountIndirectCommandEXT
//         Type:
//             Name: VkIndirectCommandsVertexBufferTokenEXT
//         Type:
//             Name: VkBindVertexBufferIndirectCommandEXT
//         Type:
//             Name: VkIndirectCommandsIndexBufferTokenEXT
//         Type:
//             Name: VkBindIndexBufferIndirectCommandEXT
//         Type:
//             Name: VkIndirectCommandsPushConstantTokenEXT
//         Type:
//             Name: VkIndirectCommandsExecutionSetTokenEXT
//         Type:
//             Name: VkIndirectCommandsTokenDataEXT
//         Type:
//             Name: VkIndirectCommandsLayoutEXT
//         Type:
//             Name: VkIndirectExecutionSetEXT
//         Type:
//             Name: VkIndirectCommandsTokenTypeEXT
//         Type:
//             Name: VkIndirectExecutionSetInfoTypeEXT
//         Type:
//             Name: VkIndirectCommandsLayoutUsageFlagsEXT
//         Type:
//             Name: VkIndirectCommandsLayoutUsageFlagBitsEXT
//         Type:
//             Name: VkIndirectCommandsInputModeFlagsEXT
//         Type:
//             Name: VkIndirectCommandsInputModeFlagBitsEXT
//         Type:
//             Name: VkIndirectExecutionSetShaderLayoutInfoEXT
//         Type:
//             Name: VkGeneratedCommandsPipelineInfoEXT
//         Type:
//             Name: VkGeneratedCommandsShaderInfoEXT
//         Command:
//             Name: vkGetGeneratedCommandsMemoryRequirementsEXT
//         Command:
//             Name: vkCmdPreprocessGeneratedCommandsEXT
//         Command:
//             Name: vkCmdExecuteGeneratedCommandsEXT
//         Command:
//             Name: vkCreateIndirectCommandsLayoutEXT
//         Command:
//             Name: vkDestroyIndirectCommandsLayoutEXT
//         Command:
//             Name: vkCreateIndirectExecutionSetEXT
//         Command:
//             Name: vkDestroyIndirectExecutionSetEXT
//         Command:
//             Name: vkUpdateIndirectExecutionSetPipelineEXT
//         Command:
//             Name: vkUpdateIndirectExecutionSetShaderEXT
//         Feature:
//             Name: deviceGeneratedCommands
//             Struct: VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT
//     Depends: VK_EXT_shader_object
//         Type:
//             Name: VkWriteIndirectExecutionSetShaderEXT
// Extension: VK_KHR_extension_574
// Number: 574
// Type: invalid
// Author: KHR
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_KHR_EXTENSION_574_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_KHR_EXTENSION_574_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_extension_574&quot;
// Extension: VK_KHR_maintenance8
// Number: 575
// Type: device
// Author: KHR
// Depends: VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_MAINTENANCE_8_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_MAINTENANCE_8_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_maintenance8&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_8_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_PIPELINE_CACHE_CREATE_INTERNALLY_SYNCHRONIZED_MERGE_BIT_KHR
//             Negative: false
//             Bitpos: 3
//             Extends: VkPipelineCacheCreateFlagBits
//         Enum:
//             Name: VK_STRUCTURE_TYPE_MEMORY_BARRIER_ACCESS_FLAGS_3_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_DEPENDENCY_QUEUE_FAMILY_OWNERSHIP_TRANSFER_USE_ALL_STAGES_BIT_KHR
//             Negative: false
//             Bitpos: 5
//             Extends: VkDependencyFlagBits
//         Type:
//             Name: VkMemoryBarrierAccessFlags3KHR
//         Type:
//             Name: VkAccessFlagBits3KHR
//         Type:
//             Name: VkAccessFlags3KHR
//         Type:
//             Name: VkPipelineCacheCreateFlagBits
//         Type:
//             Name: VkPhysicalDeviceMaintenance8FeaturesKHR
//         Feature:
//             Name: maintenance8
//             Struct: VkPhysicalDeviceMaintenance8FeaturesKHR
// Extension: VK_MESA_image_alignment_control
// Number: 576
// Type: device
// Author: MESA
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_MESA_IMAGE_ALIGNMENT_CONTROL_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_MESA_IMAGE_ALIGNMENT_CONTROL_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_MESA_image_alignment_control&quot;
//         Type:
//             Name: VkPhysicalDeviceImageAlignmentControlFeaturesMESA
//         Type:
//             Name: VkPhysicalDeviceImageAlignmentControlPropertiesMESA
//         Type:
//             Name: VkImageAlignmentControlCreateInfoMESA
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_FEATURES_MESA
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_PROPERTIES_MESA
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMAGE_ALIGNMENT_CONTROL_CREATE_INFO_MESA
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Feature:
//             Name: imageAlignmentControl
//             Struct: VkPhysicalDeviceImageAlignmentControlFeaturesMESA
// Extension: VK_HUAWEI_extension_577
// Number: 577
// Type: invalid
// Author: HUAWEI
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_HUAWEI_EXTENSION_577_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_HUAWEI_EXTENSION_577_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_HUAWEI_extension_577&quot;
//         Enum:
//             Name: VK_PIPELINE_CREATE_2_RESERVED_35_BIT_KHR
//             Negative: false
//             Bitpos: 35
//             Extends: VkPipelineCreateFlagBits2
// Extension: VK_EXT_extension_578
// Number: 578
// Type: invalid
// Author: EXT
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_578_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_578_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_578&quot;
// Extension: VK_EXT_extension_579
// Number: 579
// Type: invalid
// Author: EXT
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_579_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_579_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_579&quot;
//         Enum:
//             Name: VK_SHADER_CREATE_RESERVED_8_BIT_EXT
//             Negative: false
//             Bitpos: 8
//             Extends: VkShaderCreateFlagBitsEXT
//         Enum:
//             Name: VK_SHADER_CREATE_RESERVED_9_BIT_EXT
//             Negative: false
//             Bitpos: 9
//             Extends: VkShaderCreateFlagBitsEXT
// Extension: VK_KHR_shader_fma
// Number: 580
// Type: device
// Author: KHR
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_SHADER_FMA_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_SHADER_FMA_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_shader_fma&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FMA_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceShaderFmaFeaturesKHR
//         Feature:
//             Name: shaderFmaFloat32
//             Struct: VkPhysicalDeviceShaderFmaFeaturesKHR
// Extension: VK_NV_extension_581
// Number: 581
// Type: invalid
// Author: NV
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_NV_EXTENSION_581_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_NV_EXTENSION_581_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_extension_581&quot;
// Extension: VK_EXT_ray_tracing_invocation_reorder
// Number: 582
// Type: device
// Author: EXT
// Depends: VK_KHR_ray_tracing_pipeline
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_RAY_TRACING_INVOCATION_REORDER_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_RAY_TRACING_INVOCATION_REORDER_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_ray_tracing_invocation_reorder&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_PROPERTIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Type:
//             Name: VkRayTracingInvocationReorderModeEXT
//         Type:
//             Name: VkPhysicalDeviceRayTracingInvocationReorderPropertiesEXT
//         Type:
//             Name: VkPhysicalDeviceRayTracingInvocationReorderFeaturesEXT
//         Feature:
//             Name: rayTracingInvocationReorder
//             Struct: VkPhysicalDeviceRayTracingInvocationReorderFeaturesEXT
// Extension: VK_EXT_depth_clamp_control
// Number: 583
// Type: device
// Author: EXT
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Comment:
//     codespell:ignore blok
// Unlocks:
//         Enum:
//             Name: VK_EXT_DEPTH_CLAMP_CONTROL_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_DEPTH_CLAMP_CONTROL_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_depth_clamp_control&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_CONTROL_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLAMP_CONTROL_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_DYNAMIC_STATE_DEPTH_CLAMP_RANGE_EXT
//             Negative: false
//             Extends: VkDynamicState
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceDepthClampControlFeaturesEXT
//         Type:
//             Name: VkPipelineViewportDepthClampControlCreateInfoEXT
//         Type:
//             Name: VkDepthClampModeEXT
//         Type:
//             Name: VkDepthClampRangeEXT
//         Command:
//             Name: vkCmdSetDepthClampRangeEXT
//         Feature:
//             Name: depthClampControl
//             Struct: VkPhysicalDeviceDepthClampControlFeaturesEXT
// Extension: VK_EXT_extension_584
// Number: 584
// Type: invalid
// Author: EXT
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_584_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_584_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_584&quot;
// Extension: VK_KHR_maintenance9
// Number: 585
// Type: device
// Author: KHR
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_MAINTENANCE_9_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_MAINTENANCE_9_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_maintenance9&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_9_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_9_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_QUEUE_FAMILY_OWNERSHIP_TRANSFER_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_DEPENDENCY_ASYMMETRIC_EVENT_BIT_KHR
//             Negative: false
//             Bitpos: 6
//             Extends: VkDependencyFlagBits
//         Enum:
//             Name: VK_QUERY_POOL_CREATE_RESET_BIT_KHR
//             Negative: false
//             Bitpos: 0
//             Extends: VkQueryPoolCreateFlagBits
//         Type:
//             Name: VkPhysicalDeviceMaintenance9FeaturesKHR
//         Type:
//             Name: VkPhysicalDeviceMaintenance9PropertiesKHR
//         Type:
//             Name: VkQueueFamilyOwnershipTransferPropertiesKHR
//         Type:
//             Name: VkDefaultVertexAttributeValueKHR
//         Feature:
//             Name: maintenance9
//             Struct: VkPhysicalDeviceMaintenance9FeaturesKHR
// Extension: VK_IMG_extension_586
// Number: 586
// Type: invalid
// Author: IMG
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_IMG_EXTENSION_586_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_IMG_EXTENSION_586_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_IMG_extension_586&quot;
//         Enum:
//             Name: VK_DEPENDENCY_EXTENSION_586_BIT_IMG
//             Negative: false
//             Bitpos: 4
//             Extends: VkDependencyFlagBits
// Extension: VK_KHR_video_maintenance2
// Number: 587
// Type: device
// Author: KHR
// Depends: VK_KHR_video_queue
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_VIDEO_MAINTENANCE_2_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_VIDEO_MAINTENANCE_2_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_video_maintenance2&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_2_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceVideoMaintenance2FeaturesKHR
//         Feature:
//             Name: videoMaintenance2
//             Struct: VkPhysicalDeviceVideoMaintenance2FeaturesKHR
//     Depends: VK_KHR_video_decode_queue
//         Enum:
//             Name: VK_VIDEO_SESSION_CREATE_INLINE_SESSION_PARAMETERS_BIT_KHR
//             Negative: false
//             Bitpos: 5
//             Extends: VkVideoSessionCreateFlagBitsKHR
//     Depends: VK_KHR_video_decode_h264
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_INLINE_SESSION_PARAMETERS_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Type:
//             Name: VkVideoDecodeH264InlineSessionParametersInfoKHR
//     Depends: VK_KHR_video_decode_h265
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_INLINE_SESSION_PARAMETERS_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Type:
//             Name: VkVideoDecodeH265InlineSessionParametersInfoKHR
//     Depends: VK_KHR_video_decode_av1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_INLINE_SESSION_PARAMETERS_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Type:
//             Name: VkVideoDecodeAV1InlineSessionParametersInfoKHR
// Extension: VK_OHOS_surface
// Number: 588
// Type: instance
// Author: HUAWEI
// Depends: VK_KHR_surface
// Platform: ohos
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_OHOS_SURFACE_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_OHOS_SURFACE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_OHOS_surface&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SURFACE_CREATE_INFO_OHOS
//             Negative: false
//             Value: 1000685000
//             Extends: VkStructureType
//         Type:
//             Name: VkSurfaceCreateFlagsOHOS
//         Type:
//             Name: VkSurfaceCreateInfoOHOS
//         Type:
//             Name: OHNativeWindow
//         Command:
//             Name: vkCreateSurfaceOHOS
// Extension: VK_HUAWEI_extension_686
// Number: 686
// Type: invalid
// Author: HUAWEI
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_HUAWEI_EXTENSION_686_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_HUAWEI_EXTENSION_686_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_HUAWEI_extension_686&quot;
// Extension: VK_OHOS_native_buffer
// Number: 589
// Type: device
// Author: HUAWEI
// Platform: ohos
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_OHOS_NATIVE_BUFFER_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_OHOS_NATIVE_BUFFER_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_OHOS_native_buffer&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_NATIVE_BUFFER_OHOS
//             Negative: false
//             Extends: VkStructureType
//             Extnumber: 454
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SWAPCHAIN_IMAGE_CREATE_INFO_OHOS
//             Negative: false
//             Extends: VkStructureType
//             Extnumber: 454
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENTATION_PROPERTIES_OHOS
//             Negative: false
//             Extends: VkStructureType
//             Extnumber: 454
//             Offset: 3
//         Type:
//             Name: VkSwapchainImageUsageFlagBitsOHOS
//         Type:
//             Name: VkNativeBufferOHOS
//         Type:
//             Name: VkSwapchainImageCreateInfoOHOS
//         Type:
//             Name: VkPhysicalDevicePresentationPropertiesOHOS
//         Type:
//             Name: OHBufferHandle
//         Type:
//             Name: VkSwapchainImageUsageFlagsOHOS
//         Command:
//             Name: vkGetSwapchainGrallocUsageOHOS
//         Command:
//             Name: vkAcquireImageOHOS
//         Command:
//             Name: vkQueueSignalReleaseImageOHOS
// Extension: VK_HUAWEI_extension_590
// Number: 590
// Type: invalid
// Author: HUAWEI
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_HUAWEI_EXTENSION_590_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_HUAWEI_EXTENSION_590_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_HUAWEI_extension_590&quot;
// Extension: VK_HUAWEI_hdr_vivid
// Number: 591
// Type: device
// Author: HUAWEI
// Depends: (VK_KHR_get_physical_device_properties2,VK_VERSION_1_1)+VK_KHR_swapchain+VK_EXT_hdr_metadata
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_HUAWEI_HDR_VIVID_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_HUAWEI_HDR_VIVID_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_HUAWEI_hdr_vivid&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HDR_VIVID_FEATURES_HUAWEI
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_HDR_VIVID_DYNAMIC_METADATA_HUAWEI
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Type:
//             Name: VkPhysicalDeviceHdrVividFeaturesHUAWEI
//         Type:
//             Name: VkHdrVividDynamicMetadataHUAWEI
//         Feature:
//             Name: hdrVivid
//             Struct: VkPhysicalDeviceHdrVividFeaturesHUAWEI
// Extension: VK_NV_extension_592
// Number: 592
// Type: invalid
// Author: NV
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_NV_EXTENSION_592_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_NV_EXTENSION_592_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_extension_592&quot;
// Extension: VK_NV_extension_593
// Number: 593
// Type: invalid
// Author: NV
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_NV_EXTENSION_593_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_NV_EXTENSION_593_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_extension_593&quot;
// Extension: VK_NV_cooperative_matrix2
// Number: 594
// Type: device
// Author: NV
// Depends: VK_KHR_cooperative_matrix
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NV_COOPERATIVE_MATRIX_2_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_NV_COOPERATIVE_MATRIX_2_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_cooperative_matrix2&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_2_FEATURES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_FLEXIBLE_DIMENSIONS_PROPERTIES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_2_PROPERTIES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Type:
//             Name: VkCooperativeMatrixFlexibleDimensionsPropertiesNV
//         Type:
//             Name: VkPhysicalDeviceCooperativeMatrix2FeaturesNV
//         Type:
//             Name: VkPhysicalDeviceCooperativeMatrix2PropertiesNV
//         Command:
//             Name: vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV
//         Feature:
//             Name: cooperativeMatrixWorkgroupScope,cooperativeMatrixFlexibleDimensions,cooperativeMatrixReductions,cooperativeMatrixConversions,cooperativeMatrixPerElementOperations,cooperativeMatrixTensorAddressing,cooperativeMatrixBlockLoads
//             Struct: VkPhysicalDeviceCooperativeMatrix2FeaturesNV
// Extension: VK_NV_extension_595
// Number: 595
// Type: invalid
// Author: NV
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_NV_EXTENSION_595_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_NV_EXTENSION_595_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_extension_595&quot;
//         Enum:
//             Name: VK_SHADER_STAGE_RESERVED_15_BIT_NV
//             Negative: false
//             Bitpos: 15
//             Extends: VkShaderStageFlagBits
// Extension: VK_KHR_extension_596
// Number: 596
// Type: invalid
// Author: KHR
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_KHR_EXTENSION_596_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_KHR_EXTENSION_596_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_extension_596&quot;
// Extension: VK_ARM_pipeline_opacity_micromap
// Number: 597
// Type: device
// Author: ARM
// Depends: VK_EXT_opacity_micromap
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_ARM_PIPELINE_OPACITY_MICROMAP_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_ARM_PIPELINE_OPACITY_MICROMAP_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_ARM_pipeline_opacity_micromap&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_OPACITY_MICROMAP_FEATURES_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDevicePipelineOpacityMicromapFeaturesARM
//         Feature:
//             Name: pipelineOpacityMicromap
//             Struct: VkPhysicalDevicePipelineOpacityMicromapFeaturesARM
//         Enum:
//             Name: VK_PIPELINE_CREATE_2_DISALLOW_OPACITY_MICROMAP_BIT_ARM
//             Negative: false
//             Bitpos: 37
//             Extends: VkPipelineCreateFlagBits2
// Extension: VK_KHR_extension_598
// Number: 598
// Type: device
// Author: KHR
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_KHR_EXTENSION_598_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_KHR_EXTENSION_598_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_extension_598&quot;
// Extension: VK_KHR_extension_599
// Number: 599
// Type: device
// Author: KHR
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_KHR_EXTENSION_599_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_KHR_EXTENSION_599_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_extension_599&quot;
//         Enum:
//             Name: VK_VIDEO_ENCODE_FEEDBACK_RESERVED_3_BIT_KHR
//             Negative: false
//             Bitpos: 3
//             Extends: VkVideoEncodeFeedbackFlagBitsKHR
//         Enum:
//             Name: VK_VIDEO_ENCODE_FEEDBACK_RESERVED_4_BIT_KHR
//             Negative: false
//             Bitpos: 4
//             Extends: VkVideoEncodeFeedbackFlagBitsKHR
//         Enum:
//             Name: VK_VIDEO_ENCODE_FEEDBACK_RESERVED_5_BIT_KHR
//             Negative: false
//             Bitpos: 5
//             Extends: VkVideoEncodeFeedbackFlagBitsKHR
//         Enum:
//             Name: VK_VIDEO_ENCODE_FEEDBACK_RESERVED_6_BIT_KHR
//             Negative: false
//             Bitpos: 6
//             Extends: VkVideoEncodeFeedbackFlagBitsKHR
//         Enum:
//             Name: VK_VIDEO_ENCODE_FEEDBACK_RESERVED_7_BIT_KHR
//             Negative: false
//             Bitpos: 7
//             Extends: VkVideoEncodeFeedbackFlagBitsKHR
//         Enum:
//             Name: VK_VIDEO_ENCODE_FEEDBACK_RESERVED_8_BIT_KHR
//             Negative: false
//             Bitpos: 8
//             Extends: VkVideoEncodeFeedbackFlagBitsKHR
//         Enum:
//             Name: VK_VIDEO_ENCODE_FEEDBACK_RESERVED_9_BIT_KHR
//             Negative: false
//             Bitpos: 9
//             Extends: VkVideoEncodeFeedbackFlagBitsKHR
// Extension: VK_IMG_extension_600
// Number: 600
// Type: invalid
// Author: IMG
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_IMG_EXTENSION_600_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_IMG_EXTENSION_600_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_IMG_extension_600&quot;
// Extension: VK_IMG_extension_601
// Number: 601
// Type: invalid
// Author: IMG
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_IMG_EXTENSION_601_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_IMG_EXTENSION_601_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_IMG_extension_601&quot;
// Extension: VK_EXT_extension_602
// Number: 602
// Type: invalid
// Author: KHR
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_602_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_602_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_602&quot;
// Extension: VK_EXT_external_memory_metal
// Number: 603
// Type: device
// Author: EXT
// Depends: VK_KHR_external_memory,VK_VERSION_1_1
// Platform: metal
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTERNAL_MEMORY_METAL_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_EXTERNAL_MEMORY_METAL_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_external_memory_metal&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMPORT_MEMORY_METAL_HANDLE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_MEMORY_METAL_HANDLE_PROPERTIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_MEMORY_GET_METAL_HANDLE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLBUFFER_BIT_EXT
//             Negative: false
//             Bitpos: 16
//             Extends: VkExternalMemoryHandleTypeFlagBits
//         Enum:
//             Name: VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLTEXTURE_BIT_EXT
//             Negative: false
//             Bitpos: 17
//             Extends: VkExternalMemoryHandleTypeFlagBits
//         Enum:
//             Name: VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLHEAP_BIT_EXT
//             Negative: false
//             Bitpos: 18
//             Extends: VkExternalMemoryHandleTypeFlagBits
//         Type:
//             Name: VkImportMemoryMetalHandleInfoEXT
//         Type:
//             Name: VkMemoryMetalHandlePropertiesEXT
//         Type:
//             Name: VkMemoryGetMetalHandleInfoEXT
//         Command:
//             Name: vkGetMemoryMetalHandleEXT
//         Command:
//             Name: vkGetMemoryMetalHandlePropertiesEXT
// Extension: VK_EXT_extension_604
// Number: 604
// Type: invalid
// Author: EXT
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_604_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_604_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_604&quot;
//         Enum:
//             Name: VK_WAYLAND_SURFACE_CREATE_DISABLE_COLOR_MANAGEMENT
//             Negative: false
//             Bitpos: 0
//             Extends: VkWaylandSurfaceCreateFlagBitsKHR
// Extension: VK_KHR_depth_clamp_zero_one
// Number: 605
// Type: device
// Author: KHR
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_DEPTH_CLAMP_ZERO_ONE_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_DEPTH_CLAMP_ZERO_ONE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_depth_clamp_zero_one&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Extnumber: 422
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceDepthClampZeroOneFeaturesKHR
//         Feature:
//             Name: depthClampZeroOne
//             Struct: VkPhysicalDeviceDepthClampZeroOneFeaturesKHR
// Extension: VK_ARM_performance_counters_by_region
// Number: 606
// Type: device
// Author: ARM
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_ARM_PERFORMANCE_COUNTERS_BY_REGION_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_ARM_PERFORMANCE_COUNTERS_BY_REGION_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_ARM_performance_counters_by_region&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_COUNTERS_BY_REGION_FEATURES_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_COUNTERS_BY_REGION_PROPERTIES_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_DESCRIPTION_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Enum:
//             Name: VK_STRUCTURE_TYPE_RENDER_PASS_PERFORMANCE_COUNTERS_BY_REGION_BEGIN_INFO_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 4
//         Type:
//             Name: VkPhysicalDevicePerformanceCountersByRegionFeaturesARM
//         Type:
//             Name: VkPhysicalDevicePerformanceCountersByRegionPropertiesARM
//         Type:
//             Name: VkPerformanceCounterARM
//         Type:
//             Name: VkPerformanceCounterDescriptionARM
//         Type:
//             Name: VkRenderPassPerformanceCountersByRegionBeginInfoARM
//         Type:
//             Name: VkPerformanceCounterDescriptionFlagsARM
//         Command:
//             Name: vkEnumeratePhysicalDeviceQueueFamilyPerformanceCountersByRegionARM
//         Feature:
//             Name: performanceCountersByRegion
//             Struct: VkPhysicalDevicePerformanceCountersByRegionFeaturesARM
// Extension: VK_KHR_extension_607
// Number: 607
// Type: invalid
// Author: ARM
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_KHR_EXTENSION_607_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_KHR_EXTENSION_607_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_extension_607&quot;
// Extension: VK_KHR_extension_608
// Number: 608
// Type: invalid
// Author: ARM
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_KHR_EXTENSION_608_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_KHR_EXTENSION_608_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_extension_608&quot;
// Extension: VK_EXT_vertex_attribute_robustness
// Number: 609
// Type: device
// Author: EXT
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_KHR_maintenance9
// Unlocks:
//         Enum:
//             Name: VK_EXT_VERTEX_ATTRIBUTE_ROBUSTNESS_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_VERTEX_ATTRIBUTE_ROBUSTNESS_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_vertex_attribute_robustness&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_ROBUSTNESS_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT
//         Feature:
//             Name: vertexAttributeRobustness
//             Struct: VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT
// Extension: VK_ARM_format_pack
// Number: 610
// Type: device
// Author: ARM
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_ARM_FORMAT_PACK_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_ARM_FORMAT_PACK_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_ARM_format_pack&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FORMAT_PACK_FEATURES_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceFormatPackFeaturesARM
//         Feature:
//             Name: formatPack
//             Struct: VkPhysicalDeviceFormatPackFeaturesARM
//         Enum:
//             Name: VK_FORMAT_R10X6_UINT_PACK16_ARM
//             Negative: false
//             Extends: VkFormat
//             Offset: 0
//         Enum:
//             Name: VK_FORMAT_R10X6G10X6_UINT_2PACK16_ARM
//             Negative: false
//             Extends: VkFormat
//             Offset: 1
//         Enum:
//             Name: VK_FORMAT_R10X6G10X6B10X6A10X6_UINT_4PACK16_ARM
//             Negative: false
//             Extends: VkFormat
//             Offset: 2
//         Enum:
//             Name: VK_FORMAT_R12X4_UINT_PACK16_ARM
//             Negative: false
//             Extends: VkFormat
//             Offset: 3
//         Enum:
//             Name: VK_FORMAT_R12X4G12X4_UINT_2PACK16_ARM
//             Negative: false
//             Extends: VkFormat
//             Offset: 4
//         Enum:
//             Name: VK_FORMAT_R12X4G12X4B12X4A12X4_UINT_4PACK16_ARM
//             Negative: false
//             Extends: VkFormat
//             Offset: 5
//         Enum:
//             Name: VK_FORMAT_R14X2_UINT_PACK16_ARM
//             Negative: false
//             Extends: VkFormat
//             Offset: 6
//         Enum:
//             Name: VK_FORMAT_R14X2G14X2_UINT_2PACK16_ARM
//             Negative: false
//             Extends: VkFormat
//             Offset: 7
//         Enum:
//             Name: VK_FORMAT_R14X2G14X2B14X2A14X2_UINT_4PACK16_ARM
//             Negative: false
//             Extends: VkFormat
//             Offset: 8
//         Enum:
//             Name: VK_FORMAT_R14X2_UNORM_PACK16_ARM
//             Negative: false
//             Extends: VkFormat
//             Offset: 9
//         Enum:
//             Name: VK_FORMAT_R14X2G14X2_UNORM_2PACK16_ARM
//             Negative: false
//             Extends: VkFormat
//             Offset: 10
//         Enum:
//             Name: VK_FORMAT_R14X2G14X2B14X2A14X2_UNORM_4PACK16_ARM
//             Negative: false
//             Extends: VkFormat
//             Offset: 11
//         Enum:
//             Name: VK_FORMAT_G14X2_B14X2R14X2_2PLANE_420_UNORM_3PACK16_ARM
//             Negative: false
//             Extends: VkFormat
//             Offset: 12
//         Enum:
//             Name: VK_FORMAT_G14X2_B14X2R14X2_2PLANE_422_UNORM_3PACK16_ARM
//             Negative: false
//             Extends: VkFormat
//             Offset: 13
// Extension: VK_NV_extension_611
// Number: 611
// Type: invalid
// Author: NV
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_NV_EXTENSION_611_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_NV_EXTENSION_611_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_extension_611&quot;
// Extension: VK_VALVE_fragment_density_map_layered
// Number: 612
// Type: device
// Author: VALVE
// Depends: (VK_KHR_maintenance5,VK_VERSION_1_4)+VK_EXT_fragment_density_map
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_VALVE_FRAGMENT_DENSITY_MAP_LAYERED_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_VALVE_FRAGMENT_DENSITY_MAP_LAYERED_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_VALVE_fragment_density_map_layered&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_LAYERED_FEATURES_VALVE
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_LAYERED_PROPERTIES_VALVE
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_DENSITY_MAP_LAYERED_CREATE_INFO_VALVE
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_RENDER_PASS_CREATE_PER_LAYER_FRAGMENT_DENSITY_BIT_VALVE
//             Negative: false
//             Bitpos: 2
//             Extends: VkRenderPassCreateFlagBits
//         Enum:
//             Name: VK_RENDERING_PER_LAYER_FRAGMENT_DENSITY_BIT_VALVE
//             Negative: false
//             Bitpos: 5
//             Extends: VkRenderingFlagBits
//         Enum:
//             Name: VK_PIPELINE_CREATE_2_PER_LAYER_FRAGMENT_DENSITY_BIT_VALVE
//             Negative: false
//             Bitpos: 40
//             Extends: VkPipelineCreateFlagBits2
//         Type:
//             Name: VkPhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE
//         Type:
//             Name: VkPhysicalDeviceFragmentDensityMapLayeredPropertiesVALVE
//         Type:
//             Name: VkPipelineFragmentDensityMapLayeredCreateInfoVALVE
//         Feature:
//             Name: fragmentDensityMapLayered
//             Struct: VkPhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE
// Extension: VK_KHR_robustness2
// Number: 613
// Type: device
// Author: KHR
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_ROBUSTNESS_2_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_ROBUSTNESS_2_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_robustness2&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Extnumber: 287
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Extnumber: 287
//             Offset: 1
//         Type:
//             Name: VkPhysicalDeviceRobustness2FeaturesKHR
//         Type:
//             Name: VkPhysicalDeviceRobustness2PropertiesKHR
//         Feature:
//             Name: robustBufferAccess2,robustImageAccess2,nullDescriptor
//             Struct: VkPhysicalDeviceRobustness2FeaturesKHR
// Extension: VK_NV_present_metering
// Number: 614
// Type: device
// Author: NV
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Platform: provisional
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NV_PRESENT_METERING_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_NV_PRESENT_METERING_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_present_metering&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SET_PRESENT_CONFIG_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_METERING_FEATURES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Type:
//             Name: VkSetPresentConfigNV
//         Type:
//             Name: VkPhysicalDevicePresentMeteringFeaturesNV
//         Feature:
//             Name: presentMetering
//             Struct: VkPhysicalDevicePresentMeteringFeaturesNV
// Extension: VK_QCOM_extension_615
// Number: 615
// Type: invalid
// Author: QCOM
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_QCOM_EXTENSION_615_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_QCOM_EXTENSION_615_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_QCOM_extension_615&quot;
// Extension: VK_EXT_extension_616
// Number: 616
// Type: invalid
// Author: EXT
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_616_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_616_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_616&quot;
//         Enum:
//             Name: VK_INSTANCE_CREATE_RESERVED_616_BIT_EXT
//             Negative: false
//             Bitpos: 1
//             Extends: VkInstanceCreateFlagBits
// Extension: VK_EXT_extension_617
// Number: 617
// Type: invalid
// Author: EXT
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_617_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_617_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_617&quot;
//         Enum:
//             Name: VK_SWAPCHAIN_CREATE_RESERVED_8_BIT_EXT
//             Negative: false
//             Bitpos: 8
//             Extends: VkSwapchainCreateFlagBitsKHR
// Extension: VK_EXT_extension_618
// Number: 618
// Type: invalid
// Author: EXT
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_618_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_618_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_618&quot;
// Extension: VK_EXT_fragment_density_map_offset
// Number: 620
// Type: device
// Author: EXT
// Depends: (VK_KHR_get_physical_device_properties2,VK_VERSION_1_1)+VK_EXT_fragment_density_map+(VK_KHR_create_renderpass2,VK_VERSION_1_2)+(VK_VERSION_1_3,VK_KHR_dynamic_rendering)
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_FRAGMENT_DENSITY_MAP_OFFSET_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_FRAGMENT_DENSITY_MAP_OFFSET_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_fragment_density_map_offset&quot;
//         Type:
//             Name: VkRenderingEndInfoEXT
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Extnumber: 426
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Extnumber: 426
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Extnumber: 426
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_RENDERING_END_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_RENDERING_END_INFO_KHR
//         Enum:
//             Name: VK_IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_EXT
//             Negative: false
//             Bitpos: 15
//             Extends: VkImageCreateFlagBits
//         Type:
//             Name: VkPhysicalDeviceFragmentDensityMapOffsetFeaturesEXT
//         Type:
//             Name: VkPhysicalDeviceFragmentDensityMapOffsetPropertiesEXT
//         Type:
//             Name: VkRenderPassFragmentDensityMapOffsetEndInfoEXT
//         Command:
//             Name: vkCmdEndRendering2EXT
//         Feature:
//             Name: fragmentDensityMapOffset
//             Struct: VkPhysicalDeviceFragmentDensityMapOffsetFeaturesEXT
// Extension: VK_EXT_zero_initialize_device_memory
// Number: 621
// Type: device
// Author: EXT
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_ZERO_INITIALIZE_DEVICE_MEMORY_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_ZERO_INITIALIZE_DEVICE_MEMORY_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_zero_initialize_device_memory&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_DEVICE_MEMORY_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_MEMORY_ALLOCATE_ZERO_INITIALIZE_BIT_EXT
//             Negative: false
//             Bitpos: 3
//             Extends: VkMemoryAllocateFlagBits
//         Enum:
//             Name: VK_IMAGE_LAYOUT_ZERO_INITIALIZED_EXT
//             Negative: false
//             Extends: VkImageLayout
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT
//         Feature:
//             Name: zeroInitializeDeviceMemory
//             Struct: VkPhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT
// Extension: VK_KHR_present_mode_fifo_latest_ready
// Number: 622
// Type: device
// Author: KHR
// Depends: VK_KHR_swapchain
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_PRESENT_MODE_FIFO_LATEST_READY_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_PRESENT_MODE_FIFO_LATEST_READY_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_present_mode_fifo_latest_ready&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_MODE_FIFO_LATEST_READY_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Extnumber: 362
//             Offset: 0
//         Enum:
//             Name: VK_PRESENT_MODE_FIFO_LATEST_READY_KHR
//             Negative: false
//             Extends: VkPresentModeKHR
//             Extnumber: 362
//             Offset: 0
//         Type:
//             Name: VkPhysicalDevicePresentModeFifoLatestReadyFeaturesKHR
//         Feature:
//             Name: presentModeFifoLatestReady
//             Struct: VkPhysicalDevicePresentModeFifoLatestReadyFeaturesKHR
// Extension: VK_EXT_extension_623
// Number: 623
// Type: invalid
// Author: EXT
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_623_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_623_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_623&quot;
// Extension: VK_KHR_extension_624
// Number: 624
// Type: invalid
// Author: KHR
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_KHR_EXTENSION_624_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_KHR_EXTENSION_624_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_extension_624&quot;
//         Enum:
//             Name: VK_BUILD_ACCELERATION_STRUCTURE_RESERVED_10_BIT_KHR
//             Negative: false
//             Bitpos: 10
//             Extends: VkBuildAccelerationStructureFlagBitsKHR
//     Depends: VK_KHR_maintenance5,VK_VERSION_1_4
//         Enum:
//             Name: VK_PIPELINE_CREATE_2_RESERVED_41_BIT_KHR
//             Negative: false
//             Bitpos: 41
//             Extends: VkPipelineCreateFlagBits2
//     Depends: VK_EXT_shader_object
//         Enum:
//             Name: VK_SHADER_CREATE_RESERVED_12_BIT_EXT
//             Negative: false
//             Bitpos: 12
//             Extends: VkShaderCreateFlagBitsEXT
// Extension: VK_KHR_extension_625
// Number: 625
// Type: invalid
// Author: KHR
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_KHR_EXTENSION_625_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_KHR_EXTENSION_625_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_extension_625&quot;
// Extension: VK_EXT_extension_626
// Number: 626
// Type: invalid
// Author: EXT
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_626_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_626_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_626&quot;
// Extension: VK_NV_extension_627
// Number: 627
// Type: invalid
// Author: NV
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_NV_EXTENSION_627_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_NV_EXTENSION_627_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_extension_627&quot;
// Extension: VK_EXT_shader_64bit_indexing
// Number: 628
// Type: device
// Author: EXT
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_SHADER_64BIT_INDEXING_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_SHADER_64BIT_INDEXING_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_shader_64bit_indexing&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_64_BIT_INDEXING_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceShader64BitIndexingFeaturesEXT
//         Enum:
//             Name: VK_PIPELINE_CREATE_2_64_BIT_INDEXING_BIT_EXT
//             Negative: false
//             Bitpos: 43
//             Extends: VkPipelineCreateFlagBits2
//         Enum:
//             Name: VK_SHADER_CREATE_64_BIT_INDEXING_BIT_EXT
//             Negative: false
//             Bitpos: 15
//             Extends: VkShaderCreateFlagBitsEXT
//         Feature:
//             Name: shader64BitIndexing
//             Struct: VkPhysicalDeviceShader64BitIndexingFeaturesEXT
// Extension: VK_EXT_custom_resolve
// Number: 629
// Type: device
// Author: EXT
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_CUSTOM_RESOLVE_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_CUSTOM_RESOLVE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_custom_resolve&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_RESOLVE_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_SUBPASS_DESCRIPTION_FRAGMENT_REGION_BIT_EXT
//             Negative: false
//             Bitpos: 2
//             Extends: VkSubpassDescriptionFlagBits
//         Enum:
//             Name: VK_SUBPASS_DESCRIPTION_CUSTOM_RESOLVE_BIT_EXT
//             Negative: false
//             Bitpos: 3
//             Extends: VkSubpassDescriptionFlagBits
//         Type:
//             Name: VkPhysicalDeviceCustomResolveFeaturesEXT
//         Feature:
//             Name: customResolve
//             Struct: VkPhysicalDeviceCustomResolveFeaturesEXT
//     Depends: VK_KHR_dynamic_rendering,VK_VERSION_1_3
//         Enum:
//             Name: VK_RENDERING_FRAGMENT_REGION_BIT_EXT
//             Negative: false
//             Bitpos: 6
//             Extends: VkRenderingFlagBits
//         Enum:
//             Name: VK_RENDERING_CUSTOM_RESOLVE_BIT_EXT
//             Negative: false
//             Bitpos: 7
//             Extends: VkRenderingFlagBits
//         Enum:
//             Name: VK_RESOLVE_MODE_CUSTOM_BIT_EXT
//             Negative: false
//             Bitpos: 5
//             Extends: VkResolveModeFlagBits
//         Enum:
//             Name: VK_STRUCTURE_TYPE_BEGIN_CUSTOM_RESOLVE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_CUSTOM_RESOLVE_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Type:
//             Name: VkBeginCustomResolveInfoEXT
//         Type:
//             Name: VkCustomResolveCreateInfoEXT
//         Command:
//             Name: vkCmdBeginCustomResolveEXT
// Extension: VK_QCOM_data_graph_model
// Number: 630
// Type: device
// Author: QCOM
// Depends: VK_ARM_data_graph
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_QCOM_DATA_GRAPH_MODEL_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_QCOM_DATA_GRAPH_MODEL_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_QCOM_data_graph_model&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DATA_GRAPH_MODEL_FEATURES_QCOM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_BUILTIN_MODEL_CREATE_INFO_QCOM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_PHYSICAL_DEVICE_DATA_GRAPH_PROCESSING_ENGINE_TYPE_NEURAL_QCOM
//             Negative: false
//             Extends: VkPhysicalDeviceDataGraphProcessingEngineTypeARM
//             Offset: 0
//         Enum:
//             Name: VK_PHYSICAL_DEVICE_DATA_GRAPH_PROCESSING_ENGINE_TYPE_COMPUTE_QCOM
//             Negative: false
//             Extends: VkPhysicalDeviceDataGraphProcessingEngineTypeARM
//             Offset: 1
//         Enum:
//             Name: VK_PHYSICAL_DEVICE_DATA_GRAPH_OPERATION_TYPE_NEURAL_MODEL_QCOM
//             Negative: false
//             Extends: VkPhysicalDeviceDataGraphOperationTypeARM
//             Offset: 0
//         Enum:
//             Name: VK_PHYSICAL_DEVICE_DATA_GRAPH_OPERATION_TYPE_BUILTIN_MODEL_QCOM
//             Negative: false
//             Extends: VkPhysicalDeviceDataGraphOperationTypeARM
//             Offset: 1
//         Enum:
//             Name: VK_PIPELINE_CACHE_HEADER_VERSION_DATA_GRAPH_QCOM
//             Negative: false
//             Extends: VkPipelineCacheHeaderVersion
//             Offset: 0
//         Enum:
//             Name: VK_DATA_GRAPH_MODEL_TOOLCHAIN_VERSION_LENGTH_QCOM
//             Negative: false
//         Type:
//             Name: VkDataGraphModelCacheTypeQCOM
//         Type:
//             Name: VkPipelineCacheHeaderVersionDataGraphQCOM
//         Type:
//             Name: VkDataGraphPipelineBuiltinModelCreateInfoQCOM
//         Type:
//             Name: VkPhysicalDeviceDataGraphModelFeaturesQCOM
//         Feature:
//             Name: dataGraphModel
//             Struct: VkPhysicalDeviceDataGraphModelFeaturesQCOM
// Extension: VK_KHR_maintenance10
// Number: 631
// Type: device
// Author: KHR
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_MAINTENANCE_10_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_MAINTENANCE_10_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_maintenance10&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_10_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_10_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_FLAGS_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_RENDERING_END_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Extnumber: 620
//             Offset: 3
//         Enum:
//             Name: VK_STRUCTURE_TYPE_RESOLVE_IMAGE_MODE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 4
//         Type:
//             Name: VkPhysicalDeviceMaintenance10FeaturesKHR
//         Type:
//             Name: VkPhysicalDeviceMaintenance10PropertiesKHR
//         Type:
//             Name: VkRenderingEndInfoKHR
//         Command:
//             Name: vkCmdEndRendering2KHR
//         Type:
//             Name: VkRenderingAttachmentFlagsInfoKHR
//         Type:
//             Name: VkRenderingAttachmentFlagsKHR
//         Type:
//             Name: VkRenderingAttachmentFlagBitsKHR
//         Type:
//             Name: VkResolveImageModeInfoKHR
//         Type:
//             Name: VkResolveImageFlagsKHR
//         Type:
//             Name: VkResolveImageFlagBitsKHR
//         Feature:
//             Name: maintenance10
//             Struct: VkPhysicalDeviceMaintenance10FeaturesKHR
//         Enum:
//             Name: VK_ATTACHMENT_DESCRIPTION_RESOLVE_SKIP_TRANSFER_FUNCTION_BIT_KHR
//             Negative: false
//             Bitpos: 1
//             Extends: VkAttachmentDescriptionFlagBits
//         Enum:
//             Name: VK_ATTACHMENT_DESCRIPTION_RESOLVE_ENABLE_TRANSFER_FUNCTION_BIT_KHR
//             Negative: false
//             Bitpos: 2
//             Extends: VkAttachmentDescriptionFlagBits
//     Depends: (VK_VERSION_1_4,VK_KHR_dynamic_rendering_local_read)+(VK_VERSION_1_3,VK_KHR_dynamic_rendering)
//         Enum:
//             Name: VK_RENDERING_LOCAL_READ_CONCURRENT_ACCESS_CONTROL_BIT_KHR
//             Negative: false
//             Bitpos: 8
//             Extends: VkRenderingFlagBits
//         Enum:
//             Name: VK_RENDERING_ATTACHMENT_INPUT_ATTACHMENT_FEEDBACK_BIT_KHR
//             Negative: false
//             Bitpos: 0
//             Extends: VkRenderingAttachmentFlagBitsKHR
//     Depends: VK_KHR_format_feature_flags2,VK_VERSION_1_3
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_DEPTH_COPY_ON_COMPUTE_QUEUE_BIT_KHR
//             Negative: false
//             Bitpos: 52
//             Extends: VkFormatFeatureFlagBits2
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_DEPTH_COPY_ON_TRANSFER_QUEUE_BIT_KHR
//             Negative: false
//             Bitpos: 53
//             Extends: VkFormatFeatureFlagBits2
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_STENCIL_COPY_ON_COMPUTE_QUEUE_BIT_KHR
//             Negative: false
//             Bitpos: 54
//             Extends: VkFormatFeatureFlagBits2
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_STENCIL_COPY_ON_TRANSFER_QUEUE_BIT_KHR
//             Negative: false
//             Bitpos: 55
//             Extends: VkFormatFeatureFlagBits2
//     Depends: VK_VERSION_1_3,VK_KHR_dynamic_rendering
//         Enum:
//             Name: VK_RENDERING_ATTACHMENT_RESOLVE_SKIP_TRANSFER_FUNCTION_BIT_KHR
//             Negative: false
//             Bitpos: 1
//             Extends: VkRenderingAttachmentFlagBitsKHR
//         Enum:
//             Name: VK_RENDERING_ATTACHMENT_RESOLVE_ENABLE_TRANSFER_FUNCTION_BIT_KHR
//             Negative: false
//             Bitpos: 2
//             Extends: VkRenderingAttachmentFlagBitsKHR
//     Depends: VK_VERSION_1_3,VK_KHR_copy_commands2
//         Enum:
//             Name: VK_RESOLVE_IMAGE_SKIP_TRANSFER_FUNCTION_BIT_KHR
//             Negative: false
//             Bitpos: 0
//             Extends: VkResolveImageFlagBitsKHR
//         Enum:
//             Name: VK_RESOLVE_IMAGE_ENABLE_TRANSFER_FUNCTION_BIT_KHR
//             Negative: false
//             Bitpos: 1
//             Extends: VkResolveImageFlagBitsKHR
// Extension: VK_ARM_extension_632
// Number: 632
// Type: invalid
// Author: ARM
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_ARM_EXTENSION_632_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_ARM_EXTENSION_632_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_ARM_extension_632&quot;
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_RESERVED_56_BIT_ARM
//             Negative: false
//             Bitpos: 56
//             Extends: VkFormatFeatureFlagBits2
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_RESERVED_57_BIT_ARM
//             Negative: false
//             Bitpos: 57
//             Extends: VkFormatFeatureFlagBits2
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_RESERVED_58_BIT_ARM
//             Negative: false
//             Bitpos: 58
//             Extends: VkFormatFeatureFlagBits2
// Extension: VK_MTK_extension_633
// Number: 633
// Type: invalid
// Author: MTK
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_MTK_EXTENSION_633_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_MTK_EXTENSION_633_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_MTK_extension_633&quot;
// Extension: VK_NV_extension_634
// Number: 634
// Type: invalid
// Author: NV
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_NV_EXTENSION_634_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_NV_EXTENSION_634_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_extension_634&quot;
// Extension: VK_MTK_extension_635
// Number: 635
// Type: invalid
// Author: MTK
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_MTK_EXTENSION_635_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_MTK_EXTENSION_635_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_MTK_extension_635&quot;
// Extension: VK_EXT_extension_636
// Number: 636
// Type: invalid
// Author: EXT
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_636_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_636_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_636&quot;
// Extension: VK_EXT_extension_637
// Number: 637
// Type: invalid
// Author: EXT
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_637_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_637_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_637&quot;
// Extension: VK_SEC_pipeline_cache_incremental_mode
// Number: 638
// Type: device
// Author: SEC
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_SEC_PIPELINE_CACHE_INCREMENTAL_MODE_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_SEC_PIPELINE_CACHE_INCREMENTAL_MODE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_SEC_pipeline_cache_incremental_mode&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CACHE_INCREMENTAL_MODE_FEATURES_SEC
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDevicePipelineCacheIncrementalModeFeaturesSEC
//         Feature:
//             Name: pipelineCacheIncrementalMode
//             Struct: VkPhysicalDevicePipelineCacheIncrementalModeFeaturesSEC
// Extension: VK_EXT_extension_639
// Number: 639
// Type: invalid
// Author: EXT
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_639_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_639_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_639&quot;
// Extension: VK_NV_extension_640
// Number: 640
// Type: invalid
// Author: NV
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_NV_EXTENSION_640_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_NV_EXTENSION_640_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_extension_640&quot;
// Extension: VK_EXT_extension_641
// Number: 641
// Type: invalid
// Author: EXT
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_641_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_641_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_641&quot;
//         Enum:
//             Name: VK_PIPELINE_CREATE_2_RESERVED_45_BIT_EXT
//             Negative: false
//             Bitpos: 45
//             Extends: VkPipelineCreateFlagBits2
// Extension: VK_EXT_extension_642
// Number: 642
// Type: invalid
// Author: EXT
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_642_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_642_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_642&quot;
// Extension: VK_EXT_shader_uniform_buffer_unsized_array
// Number: 643
// Type: device
// Author: EXT
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_SHADER_UNIFORM_BUFFER_UNSIZED_ARRAY_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_SHADER_UNIFORM_BUFFER_UNSIZED_ARRAY_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_shader_uniform_buffer_unsized_array&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_UNIFORM_BUFFER_UNSIZED_ARRAY_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceShaderUniformBufferUnsizedArrayFeaturesEXT
//         Feature:
//             Name: shaderUniformBufferUnsizedArray
//             Struct: VkPhysicalDeviceShaderUniformBufferUnsizedArrayFeaturesEXT
// Extension: VK_EXT_extension_644
// Number: 644
// Type: invalid
// Author: EXT
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_644_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_644_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_644&quot;
// Extension: VK_EXT_extension_645
// Number: 645
// Type: invalid
// Author: EXT
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_645_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_645_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_645&quot;
// Extension: VK_NV_compute_occupancy_priority
// Number: 646
// Type: device
// Author: NV
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NV_COMPUTE_OCCUPANCY_PRIORITY_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_NV_COMPUTE_OCCUPANCY_PRIORITY_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_compute_occupancy_priority&quot;
//         Enum:
//             Name: VK_COMPUTE_OCCUPANCY_PRIORITY_LOW_NV
//             Negative: false
//         Enum:
//             Name: VK_COMPUTE_OCCUPANCY_PRIORITY_NORMAL_NV
//             Negative: false
//         Enum:
//             Name: VK_COMPUTE_OCCUPANCY_PRIORITY_HIGH_NV
//             Negative: false
//         Enum:
//             Name: VK_STRUCTURE_TYPE_COMPUTE_OCCUPANCY_PRIORITY_PARAMETERS_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_OCCUPANCY_PRIORITY_FEATURES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Type:
//             Name: VkComputeOccupancyPriorityParametersNV
//         Type:
//             Name: VkPhysicalDeviceComputeOccupancyPriorityFeaturesNV
//         Feature:
//             Name: computeOccupancyPriority
//             Struct: VkPhysicalDeviceComputeOccupancyPriorityFeaturesNV
//         Command:
//             Name: vkCmdSetComputeOccupancyPriorityNV
// Extension: VK_KHR_extension_647
// Number: 647
// Type: device
// Author: KHR
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_KHR_EXTENSION_647_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_KHR_EXTENSION_647_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_extension_647&quot;
//         Enum:
//             Name: VK_QUEUE_RESERVED_13_BIT_EXT
//             Negative: false
//             Bitpos: 13
//             Extends: VkQueueFlagBits
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_RESERVED_47_BIT_KHR
//             Negative: false
//             Bitpos: 47
//             Extends: VkPipelineStageFlagBits2
//         Enum:
//             Name: VK_ACCESS_2_RESERVED_60_BIT_KHR
//             Negative: false
//             Bitpos: 60
//             Extends: VkAccessFlagBits2
//         Enum:
//             Name: VK_ACCESS_2_RESERVED_61_BIT_KHR
//             Negative: false
//             Bitpos: 61
//             Extends: VkAccessFlagBits2
//         Enum:
//             Name: VK_BUFFER_USAGE_2_RESERVED_35_BIT_KHR
//             Negative: false
//             Bitpos: 35
//             Extends: VkBufferUsageFlagBits2
//         Enum:
//             Name: VK_BUFFER_USAGE_2_RESERVED_36_BIT_KHR
//             Negative: false
//             Bitpos: 36
//             Extends: VkBufferUsageFlagBits2
//         Enum:
//             Name: VK_IMAGE_USAGE_RESERVED_29_BIT_KHR
//             Negative: false
//             Bitpos: 29
//             Extends: VkImageUsageFlagBits
//         Enum:
//             Name: VK_IMAGE_USAGE_RESERVED_30_BIT_KHR
//             Negative: false
//             Bitpos: 30
//             Extends: VkImageUsageFlagBits
// Extension: VK_KHR_extension_648
// Number: 648
// Type: device
// Author: KHR
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_KHR_EXTENSION_648_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_KHR_EXTENSION_648_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_extension_648&quot;
// Extension: VK_AMD_extension_649
// Number: 649
// Type: device
// Author: AMD
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_AMD_EXTENSION_649_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_AMD_EXTENSION_649_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_extension_649&quot;
//         Enum:
//             Name: VK_PIPELINE_CREATE_2_RESERVED_47_BIT_AMD
//             Negative: false
//             Bitpos: 47
//             Extends: VkPipelineCreateFlagBits2
// Extension: VK_AMD_extension_650
// Number: 650
// Type: device
// Author: AMD
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_AMD_EXTENSION_650_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_AMD_EXTENSION_650_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_extension_650&quot;
// Extension: VK_AMD_extension_651
// Number: 651
// Type: device
// Author: AMD
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_AMD_EXTENSION_651_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_AMD_EXTENSION_651_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_extension_651&quot;
// Extension: VK_AMD_extension_652
// Number: 652
// Type: device
// Author: AMD
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_AMD_EXTENSION_652_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_AMD_EXTENSION_652_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_extension_652&quot;
// Extension: VK_AMD_extension_653
// Number: 653
// Type: device
// Author: AMD
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_AMD_EXTENSION_653_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_AMD_EXTENSION_653_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_extension_653&quot;
// Extension: VK_VALVE_extension_654
// Number: 654
// Type: device
// Author: VALVE
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_VALVE_EXTENSION_654_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_VALVE_EXTENSION_654_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_VALVE_extension_654&quot;
// Extension: VK_ARM_extension_655
// Number: 655
// Type: device
// Author: Arm
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_ARM_EXTENSION_655_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_ARM_EXTENSION_655_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_ARM_extension_655&quot;
// Extension: VK_ARM_extension_656
// Number: 656
// Type: device
// Author: Arm
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_ARM_EXTENSION_656_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_ARM_EXTENSION_656_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_ARM_extension_656&quot;
// Extension: VK_ARM_extension_657
// Number: 657
// Type: device
// Author: Arm
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_ARM_EXTENSION_657_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_ARM_EXTENSION_657_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_ARM_extension_657&quot;
// Extension: VK_KHR_extension_658
// Number: 658
// Type: device
// Author: KHR
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_KHR_EXTENSION_658_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_KHR_EXTENSION_658_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_extension_658&quot;
//         Enum:
//             Name: VK_IMAGE_CREATE_RESERVED_22_BIT_KHR
//             Negative: false
//             Bitpos: 22
//             Extends: VkImageCreateFlagBits
//     Depends: VK_EXT_shader_object
//         Enum:
//             Name: VK_SHADER_CREATE_RESERVED_18_BIT_KHR
//             Negative: false
//             Bitpos: 18
//             Extends: VkShaderCreateFlagBitsEXT
// Extension: VK_ARM_extension_659
// Number: 659
// Type: invalid
// Author: Arm
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_ARM_EXTENSION_659_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_ARM_EXTENSION_659_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_ARM_extension_659&quot;
//         Enum:
//             Name: VK_QUEUE_RESERVED_11_BIT_ARM
//             Negative: false
//             Bitpos: 11
//             Extends: VkQueueFlagBits
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_RESERVED_43_BIT_ARM
//             Negative: false
//             Bitpos: 43
//             Extends: VkPipelineStageFlagBits2
//         Enum:
//             Name: VK_ACCESS_2_RESERVED_49_BIT_ARM
//             Negative: false
//             Bitpos: 49
//             Extends: VkAccessFlagBits2
//         Enum:
//             Name: VK_ACCESS_2_RESERVED_50_BIT_ARM
//             Negative: false
//             Bitpos: 50
//             Extends: VkAccessFlagBits2
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_RESERVED_47_BIT_ARM
//             Negative: false
//             Bitpos: 47
//             Extends: VkFormatFeatureFlagBits2
// Extension: VK_EXT_extension_660
// Number: 660
// Type: invalid
// Author: EXT
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_660_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_660_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_660&quot;
// Extension: VK_KHR_extension_661
// Number: 661
// Type: device
// Author: KHR
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_KHR_EXTENSION_661_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_KHR_EXTENSION_661_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_extension_661&quot;
// Extension: VK_VALVE_extension_662
// Number: 662
// Type: device
// Author: VALVE
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_VALVE_EXTENSION_662_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_VALVE_EXTENSION_662_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_VALVE_extension_662&quot;
// Extension: VK_EXT_extension_663
// Number: 663
// Type: invalid
// Author: EXT
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_663_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_663_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_663&quot;
// Extension: VK_EXT_extension_664
// Number: 664
// Type: invalid
// Author: HUAWEI
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_664_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_664_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_664&quot;
//         Enum:
//             Name: VK_COMMAND_BUFFER_USAGE_RESERVED_3_BIT_HUAWEI
//             Negative: false
//             Bitpos: 3
//             Extends: VkCommandBufferUsageFlagBits
//         Enum:
//             Name: VK_SHADER_STAGE_RESERVED_16_BIT_HUAWEI
//             Negative: false
//             Bitpos: 16
//             Extends: VkShaderStageFlagBits
//         Enum:
//             Name: VK_IMAGE_USAGE_RESERVED_16_BIT_HUAWEI
//             Negative: false
//             Bitpos: 16
//             Extends: VkImageUsageFlagBits
//         Enum:
//             Name: VK_IMAGE_USAGE_RESERVED_27_BIT_HUAWEI
//             Negative: false
//             Bitpos: 17
//             Extends: VkImageUsageFlagBits
//         Enum:
//             Name: VK_PIPELINE_CREATE_2_RESERVED_48_BIT_HUAWEI
//             Negative: false
//             Bitpos: 48
//             Extends: VkPipelineCreateFlagBits2
//         Enum:
//             Name: VK_BUFFER_USAGE_2_RESERVED_37_BIT_HUAWEI
//             Negative: false
//             Bitpos: 37
//             Extends: VkBufferUsageFlagBits2
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_RESERVED_48_BIT_HUAWEI
//             Negative: false
//             Bitpos: 48
//             Extends: VkPipelineStageFlagBits2
//         Enum:
//             Name: VK_IMAGE_ASPECT_RESERVED_11_BIT_HUAWEI
//             Negative: false
//             Bitpos: 11
//             Extends: VkImageAspectFlagBits
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_RESERVED_61_BIT_HUAWEI
//             Negative: false
//             Bitpos: 61
//             Extends: VkFormatFeatureFlagBits2
// Extension: VK_SEC_extension_665
// Number: 665
// Type: invalid
// Author: SEC
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_SEC_EXTENSION_665_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_SEC_EXTENSION_665_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_SEC_extension_665&quot;
// Extension: VK_GOOGLE_extension_666
// Number: 666
// Type: invalid
// Author: GOOGLE
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_GOOGLE_EXTENSION_666_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_GOOGLE_EXTENSION_666_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_GOOGLE_extension_666&quot;
// Extension: VK_HUAWEI_extension_667
// Number: 667
// Type: invalid
// Author: HUAWEI
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_HUAWEI_EXTENSION_667_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_HUAWEI_EXTENSION_667_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_HUAWEI_extension_667&quot;
//         Enum:
//             Name: VK_COMMAND_BUFFER_USAGE_RESERVED_4_BIT_HUAWEI
//             Negative: false
//             Bitpos: 4
//             Extends: VkCommandBufferUsageFlagBits
// Extension: VK_NV_extension_668
// Number: 668
// Type: invalid
// Author: NV
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_NV_EXTENSION_668_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_NV_EXTENSION_668_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_extension_668&quot;

// Unknown types
pub const VkPrivateDataSlotCreateFlagBits = if (@hasDecl(@import("root"), "VkPrivateDataSlotCreateFlagBits")) @import("root").VkPrivateDataSlotCreateFlagBits else @compileError("Unknown type: {VkPrivateDataSlotCreateFlagBits}");
pub const ANativeWindow = if (@hasDecl(@import("root"), "ANativeWindow")) @import("root").ANativeWindow else @compileError("Unknown type: {ANativeWindow}");
pub const wl_display = if (@hasDecl(@import("root"), "wl_display")) @import("root").wl_display else @compileError("Unknown type: {wl_display}");
pub const wl_surface = if (@hasDecl(@import("root"), "wl_surface")) @import("root").wl_surface else @compileError("Unknown type: {wl_surface}");
pub const HINSTANCE = if (@hasDecl(@import("root"), "HINSTANCE")) @import("root").HINSTANCE else @compileError("Unknown type: {HINSTANCE}");
pub const HWND = if (@hasDecl(@import("root"), "HWND")) @import("root").HWND else @compileError("Unknown type: {HWND}");
pub const Display = if (@hasDecl(@import("root"), "Display")) @import("root").Display else @compileError("Unknown type: {Display}");
pub const Window = if (@hasDecl(@import("root"), "Window")) @import("root").Window else @compileError("Unknown type: {Window}");
pub const xcb_connection_t = if (@hasDecl(@import("root"), "xcb_connection_t")) @import("root").xcb_connection_t else @compileError("Unknown type: {xcb_connection_t}");
pub const xcb_window_t = if (@hasDecl(@import("root"), "xcb_window_t")) @import("root").xcb_window_t else @compileError("Unknown type: {xcb_window_t}");
pub const IDirectFB = if (@hasDecl(@import("root"), "IDirectFB")) @import("root").IDirectFB else @compileError("Unknown type: {IDirectFB}");
pub const IDirectFBSurface = if (@hasDecl(@import("root"), "IDirectFBSurface")) @import("root").IDirectFBSurface else @compileError("Unknown type: {IDirectFBSurface}");
pub const zx_handle_t = if (@hasDecl(@import("root"), "zx_handle_t")) @import("root").zx_handle_t else @compileError("Unknown type: {zx_handle_t}");
pub const GgpStreamDescriptor = if (@hasDecl(@import("root"), "GgpStreamDescriptor")) @import("root").GgpStreamDescriptor else @compileError("Unknown type: {GgpStreamDescriptor}");
pub const _screen_context = if (@hasDecl(@import("root"), "_screen_context")) @import("root")._screen_context else @compileError("Unknown type: {_screen_context}");
pub const _screen_window = if (@hasDecl(@import("root"), "_screen_window")) @import("root")._screen_window else @compileError("Unknown type: {_screen_window}");
pub const HANDLE = if (@hasDecl(@import("root"), "HANDLE")) @import("root").HANDLE else @compileError("Unknown type: {HANDLE}");
pub const SECURITY_ATTRIBUTES = if (@hasDecl(@import("root"), "SECURITY_ATTRIBUTES")) @import("root").SECURITY_ATTRIBUTES else @compileError("Unknown type: {SECURITY_ATTRIBUTES}");
pub const DWORD = if (@hasDecl(@import("root"), "DWORD")) @import("root").DWORD else @compileError("Unknown type: {DWORD}");
pub const NvSciBufAttrList = if (@hasDecl(@import("root"), "NvSciBufAttrList")) @import("root").NvSciBufAttrList else @compileError("Unknown type: {NvSciBufAttrList}");
pub const NvSciBufObj = if (@hasDecl(@import("root"), "NvSciBufObj")) @import("root").NvSciBufObj else @compileError("Unknown type: {NvSciBufObj}");
pub const LPCWSTR = if (@hasDecl(@import("root"), "LPCWSTR")) @import("root").LPCWSTR else @compileError("Unknown type: {LPCWSTR}");
pub const int = if (@hasDecl(@import("root"), "int")) @import("root").int else @compileError("Unknown type: {int}");
pub const NvSciSyncAttrList = if (@hasDecl(@import("root"), "NvSciSyncAttrList")) @import("root").NvSciSyncAttrList else @compileError("Unknown type: {NvSciSyncAttrList}");
pub const NvSciSyncObj = if (@hasDecl(@import("root"), "NvSciSyncObj")) @import("root").NvSciSyncObj else @compileError("Unknown type: {NvSciSyncObj}");
pub const NvSciSyncFence = if (@hasDecl(@import("root"), "NvSciSyncFence")) @import("root").NvSciSyncFence else @compileError("Unknown type: {NvSciSyncFence}");
pub const CAMetalLayer = if (@hasDecl(@import("root"), "CAMetalLayer")) @import("root").CAMetalLayer else @compileError("Unknown type: {CAMetalLayer}");
pub const AHardwareBuffer = if (@hasDecl(@import("root"), "AHardwareBuffer")) @import("root").AHardwareBuffer else @compileError("Unknown type: {AHardwareBuffer}");
pub const VkBuildAccelerationStructureFlagsNV = if (@hasDecl(@import("root"), "VkBuildAccelerationStructureFlagsNV")) @import("root").VkBuildAccelerationStructureFlagsNV else @compileError("Unknown type: {VkBuildAccelerationStructureFlagsNV}");
pub const GgpFrameToken = if (@hasDecl(@import("root"), "GgpFrameToken")) @import("root").GgpFrameToken else @compileError("Unknown type: {GgpFrameToken}");
pub const HMONITOR = if (@hasDecl(@import("root"), "HMONITOR")) @import("root").HMONITOR else @compileError("Unknown type: {HMONITOR}");
pub const uint16_t = if (@hasDecl(@import("root"), "uint16_t")) @import("root").uint16_t else @compileError("Unknown type: {uint16_t}");
pub const StdVideoH264ProfileIdc = if (@hasDecl(@import("root"), "StdVideoH264ProfileIdc")) @import("root").StdVideoH264ProfileIdc else @compileError("Unknown type: {StdVideoH264ProfileIdc}");
pub const StdVideoH264LevelIdc = if (@hasDecl(@import("root"), "StdVideoH264LevelIdc")) @import("root").StdVideoH264LevelIdc else @compileError("Unknown type: {StdVideoH264LevelIdc}");
pub const StdVideoH264SequenceParameterSet = if (@hasDecl(@import("root"), "StdVideoH264SequenceParameterSet")) @import("root").StdVideoH264SequenceParameterSet else @compileError("Unknown type: {StdVideoH264SequenceParameterSet}");
pub const StdVideoH264PictureParameterSet = if (@hasDecl(@import("root"), "StdVideoH264PictureParameterSet")) @import("root").StdVideoH264PictureParameterSet else @compileError("Unknown type: {StdVideoH264PictureParameterSet}");
pub const StdVideoDecodeH264PictureInfo = if (@hasDecl(@import("root"), "StdVideoDecodeH264PictureInfo")) @import("root").StdVideoDecodeH264PictureInfo else @compileError("Unknown type: {StdVideoDecodeH264PictureInfo}");
pub const StdVideoDecodeH264ReferenceInfo = if (@hasDecl(@import("root"), "StdVideoDecodeH264ReferenceInfo")) @import("root").StdVideoDecodeH264ReferenceInfo else @compileError("Unknown type: {StdVideoDecodeH264ReferenceInfo}");
pub const StdVideoH265ProfileIdc = if (@hasDecl(@import("root"), "StdVideoH265ProfileIdc")) @import("root").StdVideoH265ProfileIdc else @compileError("Unknown type: {StdVideoH265ProfileIdc}");
pub const StdVideoH265LevelIdc = if (@hasDecl(@import("root"), "StdVideoH265LevelIdc")) @import("root").StdVideoH265LevelIdc else @compileError("Unknown type: {StdVideoH265LevelIdc}");
pub const StdVideoH265VideoParameterSet = if (@hasDecl(@import("root"), "StdVideoH265VideoParameterSet")) @import("root").StdVideoH265VideoParameterSet else @compileError("Unknown type: {StdVideoH265VideoParameterSet}");
pub const StdVideoH265SequenceParameterSet = if (@hasDecl(@import("root"), "StdVideoH265SequenceParameterSet")) @import("root").StdVideoH265SequenceParameterSet else @compileError("Unknown type: {StdVideoH265SequenceParameterSet}");
pub const StdVideoH265PictureParameterSet = if (@hasDecl(@import("root"), "StdVideoH265PictureParameterSet")) @import("root").StdVideoH265PictureParameterSet else @compileError("Unknown type: {StdVideoH265PictureParameterSet}");
pub const StdVideoDecodeH265PictureInfo = if (@hasDecl(@import("root"), "StdVideoDecodeH265PictureInfo")) @import("root").StdVideoDecodeH265PictureInfo else @compileError("Unknown type: {StdVideoDecodeH265PictureInfo}");
pub const StdVideoDecodeH265ReferenceInfo = if (@hasDecl(@import("root"), "StdVideoDecodeH265ReferenceInfo")) @import("root").StdVideoDecodeH265ReferenceInfo else @compileError("Unknown type: {StdVideoDecodeH265ReferenceInfo}");
pub const StdVideoVP9Profile = if (@hasDecl(@import("root"), "StdVideoVP9Profile")) @import("root").StdVideoVP9Profile else @compileError("Unknown type: {StdVideoVP9Profile}");
pub const StdVideoVP9Level = if (@hasDecl(@import("root"), "StdVideoVP9Level")) @import("root").StdVideoVP9Level else @compileError("Unknown type: {StdVideoVP9Level}");
pub const StdVideoDecodeVP9PictureInfo = if (@hasDecl(@import("root"), "StdVideoDecodeVP9PictureInfo")) @import("root").StdVideoDecodeVP9PictureInfo else @compileError("Unknown type: {StdVideoDecodeVP9PictureInfo}");
pub const StdVideoAV1Profile = if (@hasDecl(@import("root"), "StdVideoAV1Profile")) @import("root").StdVideoAV1Profile else @compileError("Unknown type: {StdVideoAV1Profile}");
pub const StdVideoAV1Level = if (@hasDecl(@import("root"), "StdVideoAV1Level")) @import("root").StdVideoAV1Level else @compileError("Unknown type: {StdVideoAV1Level}");
pub const StdVideoAV1SequenceHeader = if (@hasDecl(@import("root"), "StdVideoAV1SequenceHeader")) @import("root").StdVideoAV1SequenceHeader else @compileError("Unknown type: {StdVideoAV1SequenceHeader}");
pub const StdVideoDecodeAV1PictureInfo = if (@hasDecl(@import("root"), "StdVideoDecodeAV1PictureInfo")) @import("root").StdVideoDecodeAV1PictureInfo else @compileError("Unknown type: {StdVideoDecodeAV1PictureInfo}");
pub const StdVideoDecodeAV1ReferenceInfo = if (@hasDecl(@import("root"), "StdVideoDecodeAV1ReferenceInfo")) @import("root").StdVideoDecodeAV1ReferenceInfo else @compileError("Unknown type: {StdVideoDecodeAV1ReferenceInfo}");
pub const StdVideoEncodeH264ReferenceInfo = if (@hasDecl(@import("root"), "StdVideoEncodeH264ReferenceInfo")) @import("root").StdVideoEncodeH264ReferenceInfo else @compileError("Unknown type: {StdVideoEncodeH264ReferenceInfo}");
pub const StdVideoEncodeH264PictureInfo = if (@hasDecl(@import("root"), "StdVideoEncodeH264PictureInfo")) @import("root").StdVideoEncodeH264PictureInfo else @compileError("Unknown type: {StdVideoEncodeH264PictureInfo}");
pub const StdVideoEncodeH264SliceHeader = if (@hasDecl(@import("root"), "StdVideoEncodeH264SliceHeader")) @import("root").StdVideoEncodeH264SliceHeader else @compileError("Unknown type: {StdVideoEncodeH264SliceHeader}");
pub const StdVideoEncodeH265PictureInfo = if (@hasDecl(@import("root"), "StdVideoEncodeH265PictureInfo")) @import("root").StdVideoEncodeH265PictureInfo else @compileError("Unknown type: {StdVideoEncodeH265PictureInfo}");
pub const StdVideoEncodeH265SliceSegmentHeader = if (@hasDecl(@import("root"), "StdVideoEncodeH265SliceSegmentHeader")) @import("root").StdVideoEncodeH265SliceSegmentHeader else @compileError("Unknown type: {StdVideoEncodeH265SliceSegmentHeader}");
pub const StdVideoEncodeH265ReferenceInfo = if (@hasDecl(@import("root"), "StdVideoEncodeH265ReferenceInfo")) @import("root").StdVideoEncodeH265ReferenceInfo else @compileError("Unknown type: {StdVideoEncodeH265ReferenceInfo}");
pub const StdVideoEncodeAV1DecoderModelInfo = if (@hasDecl(@import("root"), "StdVideoEncodeAV1DecoderModelInfo")) @import("root").StdVideoEncodeAV1DecoderModelInfo else @compileError("Unknown type: {StdVideoEncodeAV1DecoderModelInfo}");
pub const StdVideoEncodeAV1OperatingPointInfo = if (@hasDecl(@import("root"), "StdVideoEncodeAV1OperatingPointInfo")) @import("root").StdVideoEncodeAV1OperatingPointInfo else @compileError("Unknown type: {StdVideoEncodeAV1OperatingPointInfo}");
pub const StdVideoEncodeAV1ReferenceInfo = if (@hasDecl(@import("root"), "StdVideoEncodeAV1ReferenceInfo")) @import("root").StdVideoEncodeAV1ReferenceInfo else @compileError("Unknown type: {StdVideoEncodeAV1ReferenceInfo}");
pub const StdVideoEncodeAV1PictureInfo = if (@hasDecl(@import("root"), "StdVideoEncodeAV1PictureInfo")) @import("root").StdVideoEncodeAV1PictureInfo else @compileError("Unknown type: {StdVideoEncodeAV1PictureInfo}");
pub const MTLDevice_id = if (@hasDecl(@import("root"), "MTLDevice_id")) @import("root").MTLDevice_id else @compileError("Unknown type: {MTLDevice_id}");
pub const MTLCommandQueue_id = if (@hasDecl(@import("root"), "MTLCommandQueue_id")) @import("root").MTLCommandQueue_id else @compileError("Unknown type: {MTLCommandQueue_id}");
pub const MTLBuffer_id = if (@hasDecl(@import("root"), "MTLBuffer_id")) @import("root").MTLBuffer_id else @compileError("Unknown type: {MTLBuffer_id}");
pub const MTLTexture_id = if (@hasDecl(@import("root"), "MTLTexture_id")) @import("root").MTLTexture_id else @compileError("Unknown type: {MTLTexture_id}");
pub const IOSurfaceRef = if (@hasDecl(@import("root"), "IOSurfaceRef")) @import("root").IOSurfaceRef else @compileError("Unknown type: {IOSurfaceRef}");
pub const MTLSharedEvent_id = if (@hasDecl(@import("root"), "MTLSharedEvent_id")) @import("root").MTLSharedEvent_id else @compileError("Unknown type: {MTLSharedEvent_id}");
pub const VkMemoryDecompressionMethodFlagsNV = if (@hasDecl(@import("root"), "VkMemoryDecompressionMethodFlagsNV")) @import("root").VkMemoryDecompressionMethodFlagsNV else @compileError("Unknown type: {VkMemoryDecompressionMethodFlagsNV}");
pub const _screen_buffer = if (@hasDecl(@import("root"), "_screen_buffer")) @import("root")._screen_buffer else @compileError("Unknown type: {_screen_buffer}");
pub const OHNativeWindow = if (@hasDecl(@import("root"), "OHNativeWindow")) @import("root").OHNativeWindow else @compileError("Unknown type: {OHNativeWindow}");
pub const VkPipelineCreateFlags2KHR = if (@hasDecl(@import("root"), "VkPipelineCreateFlags2KHR")) @import("root").VkPipelineCreateFlags2KHR else @compileError("Unknown type: {VkPipelineCreateFlags2KHR}");
pub const OHBufferHandle = if (@hasDecl(@import("root"), "OHBufferHandle")) @import("root").OHBufferHandle else @compileError("Unknown type: {OHBufferHandle}");
pub const OH_NativeBuffer = if (@hasDecl(@import("root"), "OH_NativeBuffer")) @import("root").OH_NativeBuffer else @compileError("Unknown type: {OH_NativeBuffer}");
pub const VisualID = if (@hasDecl(@import("root"), "VisualID")) @import("root").VisualID else @compileError("Unknown type: {VisualID}");
pub const xcb_visualid_t = if (@hasDecl(@import("root"), "xcb_visualid_t")) @import("root").xcb_visualid_t else @compileError("Unknown type: {xcb_visualid_t}");
pub const RROutput = if (@hasDecl(@import("root"), "RROutput")) @import("root").RROutput else @compileError("Unknown type: {RROutput}");
