// This file is auto generated by gen/gen_vk.zig

// Constants
pub const VK_MAX_PHYSICAL_DEVICE_NAME_SIZE: u32 = 256;
pub const VK_UUID_SIZE: u32 = 16;
pub const VK_LUID_SIZE: u32 = 8;
pub const VK_MAX_EXTENSION_NAME_SIZE: u32 = 256;
pub const VK_MAX_DESCRIPTION_SIZE: u32 = 256;
pub const VK_MAX_MEMORY_TYPES: u32 = 32;
pub const VK_MAX_MEMORY_HEAPS: u32 = 16;
pub const VK_LOD_CLAMP_NONE: f32 = 1000;
pub const VK_REMAINING_MIP_LEVELS: u32 = 4294967295;
pub const VK_REMAINING_ARRAY_LAYERS: u32 = 4294967295;
pub const VK_REMAINING_3D_SLICES_EXT: u32 = 4294967295;
pub const VK_WHOLE_SIZE: u64 = 18446744073709551615;
pub const VK_ATTACHMENT_UNUSED: u32 = 4294967295;
pub const VK_TRUE: u32 = 1;
pub const VK_FALSE: u32 = 0;
pub const VK_QUEUE_FAMILY_IGNORED: u32 = 4294967295;
pub const VK_QUEUE_FAMILY_EXTERNAL: u32 = 4294967294;
pub const VK_QUEUE_FAMILY_FOREIGN_EXT: u32 = 4294967293;
pub const VK_SUBPASS_EXTERNAL: u32 = 4294967295;
pub const VK_MAX_DEVICE_GROUP_SIZE: u32 = 32;
pub const VK_MAX_DRIVER_NAME_SIZE: u32 = 256;
pub const VK_MAX_DRIVER_INFO_SIZE: u32 = 256;
pub const VK_SHADER_UNUSED_KHR: u32 = 4294967295;
pub const VK_MAX_GLOBAL_PRIORITY_SIZE: u32 = 16;
pub const VK_MAX_SHADER_MODULE_IDENTIFIER_SIZE_EXT: u32 = 32;
pub const VK_MAX_PIPELINE_BINARY_KEY_SIZE_KHR: u32 = 32;
pub const VK_MAX_VIDEO_AV1_REFERENCES_PER_FRAME_KHR: u32 = 7;
pub const VK_MAX_VIDEO_VP9_REFERENCES_PER_FRAME_KHR: u32 = 3;
pub const VK_SHADER_INDEX_UNUSED_AMDX: u32 = 4294967295;
pub const VK_PARTITIONED_ACCELERATION_STRUCTURE_PARTITION_INDEX_GLOBAL_NV: u32 = 4294967295;
pub const VK_COMPRESSED_TRIANGLE_FORMAT_DGF1_BYTE_ALIGNMENT_AMDX: u32 = 128;
pub const VK_COMPRESSED_TRIANGLE_FORMAT_DGF1_BYTE_STRIDE_AMDX: u32 = 128;
pub const VK_MAX_PHYSICAL_DEVICE_DATA_GRAPH_OPERATION_SET_NAME_SIZE_ARM: u32 = 128;
pub const VK_DATA_GRAPH_MODEL_TOOLCHAIN_VERSION_LENGTH_QCOM: u32 = 3;
pub const VK_COMPUTE_OCCUPANCY_PRIORITY_LOW_NV: f32 = 0.25;
pub const VK_COMPUTE_OCCUPANCY_PRIORITY_NORMAL_NV: f32 = 0.5;
pub const VK_COMPUTE_OCCUPANCY_PRIORITY_HIGH_NV: f32 = 0.75;
// Versions
pub const ApiVersion = packed struct(u32) {
    patch: u12 = 0,
    minor: u10 = 0,
    major: u7 = 0,
    variant: u3 = 0,

    pub fn less(v1: ApiVersion, v2: ApiVersion) bool {
        const v1_u32: u32 = @bitCast(v1);
        const v2_u32: u32 = @bitCast(v2);
        const result = v1_u32 < v2_u32;
        return result;
    }
};
pub const VK_API_VERSION_1_0: ApiVersion = .{
    .variant = 0,
    .major = 1,
    .minor = 0,
    .patch = 0,
};
pub const VK_API_VERSION_1_1: ApiVersion = .{
    .variant = 0,
    .major = 1,
    .minor = 1,
    .patch = 0,
};
pub const VK_API_VERSION_1_2: ApiVersion = .{
    .variant = 0,
    .major = 1,
    .minor = 2,
    .patch = 0,
};
pub const VK_API_VERSION_1_3: ApiVersion = .{
    .variant = 0,
    .major = 1,
    .minor = 3,
    .patch = 0,
};
pub const VK_API_VERSION_1_4: ApiVersion = .{
    .variant = 0,
    .major = 1,
    .minor = 4,
    .patch = 0,
};

// Handles
// Type enum: VK_OBJECT_TYPE_INSTANCE
pub const VkInstance = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_PHYSICAL_DEVICE
// Parent: VkInstance
pub const VkPhysicalDevice = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_DEVICE
// Parent: VkPhysicalDevice
pub const VkDevice = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_QUEUE
// Parent: VkDevice
pub const VkQueue = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_COMMAND_BUFFER
// Parent: VkCommandPool
pub const VkCommandBuffer = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_DEVICE_MEMORY
// Parent: VkDevice
pub const VkDeviceMemory = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_COMMAND_POOL
// Parent: VkDevice
pub const VkCommandPool = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_BUFFER
// Parent: VkDevice
pub const VkBuffer = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_BUFFER_VIEW
// Parent: VkDevice
pub const VkBufferView = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_IMAGE
// Parent: VkDevice
pub const VkImage = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_IMAGE_VIEW
// Parent: VkDevice
pub const VkImageView = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_SHADER_MODULE
// Parent: VkDevice
pub const VkShaderModule = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_PIPELINE
// Parent: VkDevice
pub const VkPipeline = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_PIPELINE_LAYOUT
// Parent: VkDevice
pub const VkPipelineLayout = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_SAMPLER
// Parent: VkDevice
pub const VkSampler = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_DESCRIPTOR_SET
// Parent: VkDescriptorPool
pub const VkDescriptorSet = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT
// Parent: VkDevice
pub const VkDescriptorSetLayout = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_DESCRIPTOR_POOL
// Parent: VkDevice
pub const VkDescriptorPool = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_FENCE
// Parent: VkDevice
pub const VkFence = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_SEMAPHORE
// Parent: VkDevice
pub const VkSemaphore = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_EVENT
// Parent: VkDevice
pub const VkEvent = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_QUERY_POOL
// Parent: VkDevice
pub const VkQueryPool = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_FRAMEBUFFER
// Parent: VkDevice
pub const VkFramebuffer = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_RENDER_PASS
// Parent: VkDevice
pub const VkRenderPass = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_PIPELINE_CACHE
// Parent: VkDevice
pub const VkPipelineCache = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_PIPELINE_BINARY_KHR
// Parent: VkDevice
pub const VkPipelineBinaryKHR = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NV
// Parent: VkDevice
pub const VkIndirectCommandsLayoutNV = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_EXT
// Parent: VkDevice
pub const VkIndirectCommandsLayoutEXT = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_INDIRECT_EXECUTION_SET_EXT
// Parent: VkDevice
pub const VkIndirectExecutionSetEXT = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE
// Parent: VkDevice
pub const VkDescriptorUpdateTemplate = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION
// Parent: VkDevice
pub const VkSamplerYcbcrConversion = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_VALIDATION_CACHE_EXT
// Parent: VkDevice
pub const VkValidationCacheEXT = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_KHR
// Parent: VkDevice
pub const VkAccelerationStructureKHR = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV
// Parent: VkDevice
pub const VkAccelerationStructureNV = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_PERFORMANCE_CONFIGURATION_INTEL
// Parent: VkDevice
pub const VkPerformanceConfigurationINTEL = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_BUFFER_COLLECTION_FUCHSIA
// Parent: VkDevice
pub const VkBufferCollectionFUCHSIA = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_DEFERRED_OPERATION_KHR
// Parent: VkDevice
pub const VkDeferredOperationKHR = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_PRIVATE_DATA_SLOT
// Parent: VkDevice
pub const VkPrivateDataSlot = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_CU_MODULE_NVX
// Parent: VkDevice
pub const VkCuModuleNVX = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_CU_FUNCTION_NVX
// Parent: VkDevice
pub const VkCuFunctionNVX = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_OPTICAL_FLOW_SESSION_NV
// Parent: VkDevice
pub const VkOpticalFlowSessionNV = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_MICROMAP_EXT
// Parent: VkDevice
pub const VkMicromapEXT = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_SHADER_EXT
// Parent: VkDevice
pub const VkShaderEXT = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_TENSOR_ARM
// Parent: VkDevice
pub const VkTensorARM = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_TENSOR_VIEW_ARM
// Parent: VkDevice
pub const VkTensorViewARM = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_DATA_GRAPH_PIPELINE_SESSION_ARM
// Parent: VkDevice
pub const VkDataGraphPipelineSessionARM = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_DISPLAY_KHR
// Parent: VkPhysicalDevice
pub const VkDisplayKHR = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_DISPLAY_MODE_KHR
// Parent: VkDisplayKHR
pub const VkDisplayModeKHR = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_SURFACE_KHR
// Parent: VkInstance
pub const VkSurfaceKHR = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_SWAPCHAIN_KHR
// Parent: VkDevice
pub const VkSwapchainKHR = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT
// Parent: VkInstance
pub const VkDebugReportCallbackEXT = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_DEBUG_UTILS_MESSENGER_EXT
// Parent: VkInstance
pub const VkDebugUtilsMessengerEXT = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_VIDEO_SESSION_KHR
// Parent: VkDevice
pub const VkVideoSessionKHR = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_VIDEO_SESSION_PARAMETERS_KHR
// Parent: VkVideoSessionKHR
pub const VkVideoSessionParametersKHR = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_SEMAPHORE_SCI_SYNC_POOL_NV
// Parent: VkDevice
pub const VkSemaphoreSciSyncPoolNV = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_CUDA_MODULE_NV
// Parent: VkDevice
pub const VkCudaModuleNV = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_CUDA_FUNCTION_NV
// Parent: VkDevice
pub const VkCudaFunctionNV = enum(u64) { none = 0, _ };
// Type enum: VK_OBJECT_TYPE_EXTERNAL_COMPUTE_QUEUE_NV
// Parent: VkDevice
pub const VkExternalComputeQueueNV = enum(u64) { none = 0, _ };

// Empty bitmasks
pub const VkFramebufferCreateFlags = packed struct(u32) {
    // Extension: VK_GRAPHICS_VERSION_1_2
    // bit: 0
    VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT: bool = false,
    _: u31 = 0,
};
pub const VkQueryPoolCreateFlags = packed struct(u32) {
    // Extension: VK_KHR_maintenance9
    // bit: 0
    VK_QUERY_POOL_CREATE_RESET_BIT_KHR: bool = false,
    _: u31 = 0,
};
pub const VkRenderPassCreateFlags = packed struct(u32) {
    _0: u1 = 0,
    // Extension: VK_QCOM_render_pass_transform
    // bit: 1
    VK_RENDER_PASS_CREATE_TRANSFORM_BIT_QCOM: bool = false,
    // Extension: VK_VALVE_fragment_density_map_layered
    // bit: 2
    VK_RENDER_PASS_CREATE_PER_LAYER_FRAGMENT_DENSITY_BIT_VALVE: bool = false,
    _: u29 = 0,
};
pub const VkSamplerCreateFlags = packed struct(u32) {
    // Extension: VK_EXT_fragment_density_map
    // bit: 0
    VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT: bool = false,
    // Extension: VK_EXT_fragment_density_map
    // bit: 1
    VK_SAMPLER_CREATE_SUBSAMPLED_COARSE_RECONSTRUCTION_BIT_EXT: bool = false,
    // Extension: VK_EXT_non_seamless_cube_map
    // bit: 2
    VK_SAMPLER_CREATE_NON_SEAMLESS_CUBE_MAP_BIT_EXT: bool = false,
    // Extension: VK_EXT_descriptor_buffer
    // bit: 3
    VK_SAMPLER_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT: bool = false,
    // Extension: VK_QCOM_image_processing
    // bit: 4
    VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM: bool = false,
    _: u27 = 0,
};
pub const VkPipelineLayoutCreateFlags = packed struct(u32) {
    _0: u1 = 0,
    // Extension: VK_EXT_graphics_pipeline_library
    // bit: 1
    VK_PIPELINE_LAYOUT_CREATE_INDEPENDENT_SETS_BIT_EXT: bool = false,
    _: u30 = 0,
};
pub const VkPipelineCacheCreateFlags = packed struct(u32) {
    // Extension: VK_COMPUTE_VERSION_1_3
    // bit: 0
    VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT: bool = false,
    // Extension: VKSC_VERSION_1_0
    // bit: 1
    VK_PIPELINE_CACHE_CREATE_READ_ONLY_BIT: bool = false,
    // Extension: VKSC_VERSION_1_0
    // bit: 2
    VK_PIPELINE_CACHE_CREATE_USE_APPLICATION_STORAGE_BIT: bool = false,
    // Extension: VK_KHR_maintenance8
    // bit: 3
    VK_PIPELINE_CACHE_CREATE_INTERNALLY_SYNCHRONIZED_MERGE_BIT_KHR: bool = false,
    _: u28 = 0,
};
pub const VkPipelineDepthStencilStateCreateFlags = packed struct(u32) {
    // Extension: VK_EXT_rasterization_order_attachment_access
    // bit: 0
    VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_EXT: bool = false,
    // Extension: VK_EXT_rasterization_order_attachment_access
    // bit: 1
    VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_EXT: bool = false,
    _: u30 = 0,
};
pub const VkPipelineDynamicStateCreateFlags = packed struct(u32) {
    _: u32 = 0,
};
pub const VkPipelineColorBlendStateCreateFlags = packed struct(u32) {
    // Extension: VK_EXT_rasterization_order_attachment_access
    // bit: 0
    VK_PIPELINE_COLOR_BLEND_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_BIT_EXT: bool = false,
    _: u31 = 0,
};
pub const VkPipelineMultisampleStateCreateFlags = packed struct(u32) {
    _: u32 = 0,
};
pub const VkPipelineRasterizationStateCreateFlags = packed struct(u32) {
    _: u32 = 0,
};
pub const VkPipelineViewportStateCreateFlags = packed struct(u32) {
    _: u32 = 0,
};
pub const VkPipelineTessellationStateCreateFlags = packed struct(u32) {
    _: u32 = 0,
};
pub const VkPipelineInputAssemblyStateCreateFlags = packed struct(u32) {
    _: u32 = 0,
};
pub const VkPipelineVertexInputStateCreateFlags = packed struct(u32) {
    _: u32 = 0,
};
pub const VkPipelineShaderStageCreateFlags = packed struct(u32) {
    // Extension: VK_COMPUTE_VERSION_1_3
    // bit: 0
    VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT: bool = false,
    // Extension: VK_COMPUTE_VERSION_1_3
    // bit: 1
    VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT: bool = false,
    _: u30 = 0,
};
pub const VkDescriptorSetLayoutCreateFlags = packed struct(u32) {
    // Extension: VK_COMPUTE_VERSION_1_4
    // bit: 0
    VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT: bool = false,
    // Extension: VK_COMPUTE_VERSION_1_2
    // bit: 1
    VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT: bool = false,
    // Extension: VK_EXT_mutable_descriptor_type
    // bit: 2
    VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_EXT: bool = false,
    _2: u1 = 0,
    // Extension: VK_EXT_descriptor_buffer
    // bit: 4
    VK_DESCRIPTOR_SET_LAYOUT_CREATE_DESCRIPTOR_BUFFER_BIT_EXT: bool = false,
    // Extension: VK_EXT_descriptor_buffer
    // bit: 5
    VK_DESCRIPTOR_SET_LAYOUT_CREATE_EMBEDDED_IMMUTABLE_SAMPLERS_BIT_EXT: bool = false,
    // Extension: VK_NV_per_stage_descriptor_set
    // bit: 6
    VK_DESCRIPTOR_SET_LAYOUT_CREATE_PER_STAGE_BIT_NV: bool = false,
    // Extension: VK_NV_device_generated_commands_compute
    // bit: 7
    VK_DESCRIPTOR_SET_LAYOUT_CREATE_INDIRECT_BINDABLE_BIT_NV: bool = false,
    _: u24 = 0,
};
pub const VkBufferViewCreateFlags = packed struct(u32) {
    _: u32 = 0,
};
pub const VkInstanceCreateFlags = packed struct(u32) {
    // Extension: VK_KHR_portability_enumeration
    // bit: 0
    VK_INSTANCE_CREATE_ENUMERATE_PORTABILITY_BIT_KHR: bool = false,
    _: u31 = 0,
};
pub const VkDeviceCreateFlags = packed struct(u32) {
    _: u32 = 0,
};
pub const VkDeviceQueueCreateFlags = packed struct(u32) {
    // Extension: VK_BASE_VERSION_1_1
    // bit: 0
    VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT: bool = false,
    _: u31 = 0,
};
pub const VkQueueFlags = packed struct(u32) {
    // Comment: Queue supports graphics operations
    // bit: 0
    VK_QUEUE_GRAPHICS_BIT: bool = false,
    // Comment: Queue supports compute operations
    // bit: 1
    VK_QUEUE_COMPUTE_BIT: bool = false,
    // Comment: Queue supports transfer operations
    // bit: 2
    VK_QUEUE_TRANSFER_BIT: bool = false,
    // Comment: Queue supports sparse resource memory management operations
    // bit: 3
    VK_QUEUE_SPARSE_BINDING_BIT: bool = false,
    // Extension: VK_BASE_VERSION_1_1
    // bit: 4
    VK_QUEUE_PROTECTED_BIT: bool = false,
    // Extension: VK_KHR_video_decode_queue
    // bit: 5
    VK_QUEUE_VIDEO_DECODE_BIT_KHR: bool = false,
    // Extension: VK_KHR_video_encode_queue
    // bit: 6
    VK_QUEUE_VIDEO_ENCODE_BIT_KHR: bool = false,
    _6: u1 = 0,
    // Extension: VK_NV_optical_flow
    // bit: 8
    VK_QUEUE_OPTICAL_FLOW_BIT_NV: bool = false,
    _8: u1 = 0,
    // Extension: VK_ARM_data_graph
    // bit: 10
    VK_QUEUE_DATA_GRAPH_BIT_ARM: bool = false,
    _: u21 = 0,
};
pub const VkMemoryPropertyFlags = packed struct(u32) {
    // Comment: If otherwise stated, then allocate memory on device
    // bit: 0
    VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT: bool = false,
    // Comment: Memory is mappable by host
    // bit: 1
    VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT: bool = false,
    // Comment: Memory will have i/o coherency. If not set, application may need to use vkFlushMappedMemoryRanges and vkInvalidateMappedMemoryRanges to flush/invalidate host cache
    // bit: 2
    VK_MEMORY_PROPERTY_HOST_COHERENT_BIT: bool = false,
    // Comment: Memory will be cached by the host
    // bit: 3
    VK_MEMORY_PROPERTY_HOST_CACHED_BIT: bool = false,
    // Comment: Memory may be allocated by the driver when it is required
    // bit: 4
    VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT: bool = false,
    // Extension: VK_BASE_VERSION_1_1
    // bit: 5
    VK_MEMORY_PROPERTY_PROTECTED_BIT: bool = false,
    // Extension: VK_AMD_device_coherent_memory
    // bit: 6
    VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD: bool = false,
    // Extension: VK_AMD_device_coherent_memory
    // bit: 7
    VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD: bool = false,
    // Extension: VK_NV_external_memory_rdma
    // bit: 8
    VK_MEMORY_PROPERTY_RDMA_CAPABLE_BIT_NV: bool = false,
    _: u23 = 0,
};
pub const VkMemoryHeapFlags = packed struct(u32) {
    // Comment: If set, heap represents device memory
    // bit: 0
    VK_MEMORY_HEAP_DEVICE_LOCAL_BIT: bool = false,
    // Extension: VK_BASE_VERSION_1_1
    // bit: 1
    VK_MEMORY_HEAP_MULTI_INSTANCE_BIT: bool = false,
    // Extension: VKSC_VERSION_1_0
    // bit: 2
    VK_MEMORY_HEAP_SEU_SAFE_BIT: bool = false,
    // Extension: VK_QCOM_tile_memory_heap
    // bit: 3
    VK_MEMORY_HEAP_TILE_MEMORY_BIT_QCOM: bool = false,
    _: u28 = 0,
};
pub const VkAccessFlags = packed struct(u32) {
    // Comment: Controls coherency of indirect command reads
    // bit: 0
    VK_ACCESS_INDIRECT_COMMAND_READ_BIT: bool = false,
    // Comment: Controls coherency of index reads
    // bit: 1
    VK_ACCESS_INDEX_READ_BIT: bool = false,
    // Comment: Controls coherency of vertex attribute reads
    // bit: 2
    VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT: bool = false,
    // Comment: Controls coherency of uniform buffer reads
    // bit: 3
    VK_ACCESS_UNIFORM_READ_BIT: bool = false,
    // Comment: Controls coherency of input attachment reads
    // bit: 4
    VK_ACCESS_INPUT_ATTACHMENT_READ_BIT: bool = false,
    // Comment: Controls coherency of shader reads
    // bit: 5
    VK_ACCESS_SHADER_READ_BIT: bool = false,
    // Comment: Controls coherency of shader writes
    // bit: 6
    VK_ACCESS_SHADER_WRITE_BIT: bool = false,
    // Comment: Controls coherency of color attachment reads
    // bit: 7
    VK_ACCESS_COLOR_ATTACHMENT_READ_BIT: bool = false,
    // Comment: Controls coherency of color attachment writes
    // bit: 8
    VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT: bool = false,
    // Comment: Controls coherency of depth/stencil attachment reads
    // bit: 9
    VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT: bool = false,
    // Comment: Controls coherency of depth/stencil attachment writes
    // bit: 10
    VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT: bool = false,
    // Comment: Controls coherency of transfer reads
    // bit: 11
    VK_ACCESS_TRANSFER_READ_BIT: bool = false,
    // Comment: Controls coherency of transfer writes
    // bit: 12
    VK_ACCESS_TRANSFER_WRITE_BIT: bool = false,
    // Comment: Controls coherency of host reads
    // bit: 13
    VK_ACCESS_HOST_READ_BIT: bool = false,
    // Comment: Controls coherency of host writes
    // bit: 14
    VK_ACCESS_HOST_WRITE_BIT: bool = false,
    // Comment: Controls coherency of memory reads
    // bit: 15
    VK_ACCESS_MEMORY_READ_BIT: bool = false,
    // Comment: Controls coherency of memory writes
    // bit: 16
    VK_ACCESS_MEMORY_WRITE_BIT: bool = false,
    // Extension: VK_EXT_device_generated_commands
    // bit: 17
    VK_ACCESS_COMMAND_PREPROCESS_READ_BIT_EXT: bool = false,
    // Extension: VK_EXT_device_generated_commands
    // bit: 18
    VK_ACCESS_COMMAND_PREPROCESS_WRITE_BIT_EXT: bool = false,
    // Extension: VK_EXT_blend_operation_advanced
    // bit: 19
    VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT: bool = false,
    // Extension: VK_EXT_conditional_rendering
    // bit: 20
    VK_ACCESS_CONDITIONAL_RENDERING_READ_BIT_EXT: bool = false,
    // Extension: VK_KHR_acceleration_structure
    // bit: 21
    VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR: bool = false,
    // Extension: VK_KHR_acceleration_structure
    // bit: 22
    VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_KHR: bool = false,
    // Extension: VK_KHR_fragment_shading_rate
    // bit: 23
    VK_ACCESS_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR: bool = false,
    // Extension: VK_EXT_fragment_density_map
    // bit: 24
    VK_ACCESS_FRAGMENT_DENSITY_MAP_READ_BIT_EXT: bool = false,
    // Extension: VK_EXT_transform_feedback
    // bit: 25
    VK_ACCESS_TRANSFORM_FEEDBACK_WRITE_BIT_EXT: bool = false,
    // Extension: VK_EXT_transform_feedback
    // bit: 26
    VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT: bool = false,
    // Extension: VK_EXT_transform_feedback
    // bit: 27
    VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT: bool = false,
    _: u4 = 0,
};
pub const VkBufferUsageFlags = packed struct(u32) {
    // Comment: Can be used as a source of transfer operations
    // bit: 0
    VK_BUFFER_USAGE_TRANSFER_SRC_BIT: bool = false,
    // Comment: Can be used as a destination of transfer operations
    // bit: 1
    VK_BUFFER_USAGE_TRANSFER_DST_BIT: bool = false,
    // Comment: Can be used as TBO
    // bit: 2
    VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT: bool = false,
    // Comment: Can be used as IBO
    // bit: 3
    VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT: bool = false,
    // Comment: Can be used as UBO
    // bit: 4
    VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT: bool = false,
    // Comment: Can be used as SSBO
    // bit: 5
    VK_BUFFER_USAGE_STORAGE_BUFFER_BIT: bool = false,
    // Comment: Can be used as source of fixed-function index fetch (index buffer)
    // bit: 6
    VK_BUFFER_USAGE_INDEX_BUFFER_BIT: bool = false,
    // Comment: Can be used as source of fixed-function vertex fetch (VBO)
    // bit: 7
    VK_BUFFER_USAGE_VERTEX_BUFFER_BIT: bool = false,
    // Comment: Can be the source of indirect parameters (e.g. indirect buffer, parameter buffer)
    // bit: 8
    VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT: bool = false,
    // Extension: VK_EXT_conditional_rendering
    // bit: 9
    VK_BUFFER_USAGE_CONDITIONAL_RENDERING_BIT_EXT: bool = false,
    // Extension: VK_KHR_ray_tracing_pipeline
    // bit: 10
    VK_BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR: bool = false,
    // Extension: VK_EXT_transform_feedback
    // bit: 11
    VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT: bool = false,
    // Extension: VK_EXT_transform_feedback
    // bit: 12
    VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT: bool = false,
    // Extension: VK_KHR_video_decode_queue
    // bit: 13
    VK_BUFFER_USAGE_VIDEO_DECODE_SRC_BIT_KHR: bool = false,
    // Extension: VK_KHR_video_decode_queue
    // bit: 14
    VK_BUFFER_USAGE_VIDEO_DECODE_DST_BIT_KHR: bool = false,
    // Extension: VK_KHR_video_encode_queue
    // bit: 15
    VK_BUFFER_USAGE_VIDEO_ENCODE_DST_BIT_KHR: bool = false,
    // Extension: VK_KHR_video_encode_queue
    // bit: 16
    VK_BUFFER_USAGE_VIDEO_ENCODE_SRC_BIT_KHR: bool = false,
    // Extension: VK_BASE_VERSION_1_2
    // bit: 17
    VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT: bool = false,
    _17: u1 = 0,
    // Extension: VK_KHR_acceleration_structure
    // bit: 19
    VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR: bool = false,
    // Extension: VK_KHR_acceleration_structure
    // bit: 20
    VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR: bool = false,
    // Extension: VK_EXT_descriptor_buffer
    // bit: 21
    VK_BUFFER_USAGE_SAMPLER_DESCRIPTOR_BUFFER_BIT_EXT: bool = false,
    // Extension: VK_EXT_descriptor_buffer
    // bit: 22
    VK_BUFFER_USAGE_RESOURCE_DESCRIPTOR_BUFFER_BIT_EXT: bool = false,
    // Extension: VK_EXT_opacity_micromap
    // bit: 23
    VK_BUFFER_USAGE_MICROMAP_BUILD_INPUT_READ_ONLY_BIT_EXT: bool = false,
    // Extension: VK_EXT_opacity_micromap
    // bit: 24
    VK_BUFFER_USAGE_MICROMAP_STORAGE_BIT_EXT: bool = false,
    // Extension: VK_AMDX_shader_enqueue
    // bit: 25
    VK_BUFFER_USAGE_EXECUTION_GRAPH_SCRATCH_BIT_AMDX: bool = false,
    // Extension: VK_EXT_descriptor_buffer
    // bit: 26
    VK_BUFFER_USAGE_PUSH_DESCRIPTORS_DESCRIPTOR_BUFFER_BIT_EXT: bool = false,
    // Extension: VK_QCOM_tile_memory_heap
    // bit: 27
    VK_BUFFER_USAGE_TILE_MEMORY_BIT_QCOM: bool = false,
    _: u4 = 0,
};
pub const VkBufferCreateFlags = packed struct(u32) {
    // Comment: Buffer should support sparse backing
    // bit: 0
    VK_BUFFER_CREATE_SPARSE_BINDING_BIT: bool = false,
    // Comment: Buffer should support sparse backing with partial residency
    // bit: 1
    VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT: bool = false,
    // Comment: Buffer should support constant data access to physical memory ranges mapped into multiple locations of sparse buffers
    // bit: 2
    VK_BUFFER_CREATE_SPARSE_ALIASED_BIT: bool = false,
    // Extension: VK_BASE_VERSION_1_1
    // bit: 3
    VK_BUFFER_CREATE_PROTECTED_BIT: bool = false,
    // Extension: VK_BASE_VERSION_1_2
    // bit: 4
    VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT: bool = false,
    // Extension: VK_EXT_descriptor_buffer
    // bit: 5
    VK_BUFFER_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT: bool = false,
    // Extension: VK_KHR_video_maintenance1
    // bit: 6
    VK_BUFFER_CREATE_VIDEO_PROFILE_INDEPENDENT_BIT_KHR: bool = false,
    _: u25 = 0,
};
pub const VkShaderStageFlags = packed struct(u32) {
    // bit: 0
    VK_SHADER_STAGE_VERTEX_BIT: bool = false,
    // bit: 1
    VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT: bool = false,
    // bit: 2
    VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT: bool = false,
    // bit: 3
    VK_SHADER_STAGE_GEOMETRY_BIT: bool = false,
    // bit: 4
    VK_SHADER_STAGE_FRAGMENT_BIT: bool = false,
    // bit: 5
    VK_SHADER_STAGE_COMPUTE_BIT: bool = false,
    // Extension: VK_EXT_mesh_shader
    // bit: 6
    VK_SHADER_STAGE_TASK_BIT_EXT: bool = false,
    // Extension: VK_EXT_mesh_shader
    // bit: 7
    VK_SHADER_STAGE_MESH_BIT_EXT: bool = false,
    // Extension: VK_KHR_ray_tracing_pipeline
    // bit: 8
    VK_SHADER_STAGE_RAYGEN_BIT_KHR: bool = false,
    // Extension: VK_KHR_ray_tracing_pipeline
    // bit: 9
    VK_SHADER_STAGE_ANY_HIT_BIT_KHR: bool = false,
    // Extension: VK_KHR_ray_tracing_pipeline
    // bit: 10
    VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR: bool = false,
    // Extension: VK_KHR_ray_tracing_pipeline
    // bit: 11
    VK_SHADER_STAGE_MISS_BIT_KHR: bool = false,
    // Extension: VK_KHR_ray_tracing_pipeline
    // bit: 12
    VK_SHADER_STAGE_INTERSECTION_BIT_KHR: bool = false,
    // Extension: VK_KHR_ray_tracing_pipeline
    // bit: 13
    VK_SHADER_STAGE_CALLABLE_BIT_KHR: bool = false,
    // Extension: VK_HUAWEI_subpass_shading
    // bit: 14
    VK_SHADER_STAGE_SUBPASS_SHADING_BIT_HUAWEI: bool = false,
    _14: u4 = 0,
    // Extension: VK_HUAWEI_cluster_culling_shader
    // bit: 19
    VK_SHADER_STAGE_CLUSTER_CULLING_BIT_HUAWEI: bool = false,
    _: u12 = 0,
    pub const VK_SHADER_STAGE_ALL_GRAPHICS: @This() = @bitCast(@as(u32, 0x1f));
    pub const VK_SHADER_STAGE_ALL: @This() = @bitCast(@as(u32, 0x7fffffff));
};
pub const VkImageUsageFlags = packed struct(u32) {
    // Comment: Can be used as a source of transfer operations
    // bit: 0
    VK_IMAGE_USAGE_TRANSFER_SRC_BIT: bool = false,
    // Comment: Can be used as a destination of transfer operations
    // bit: 1
    VK_IMAGE_USAGE_TRANSFER_DST_BIT: bool = false,
    // Comment: Can be sampled from (SAMPLED_IMAGE and COMBINED_IMAGE_SAMPLER descriptor types)
    // bit: 2
    VK_IMAGE_USAGE_SAMPLED_BIT: bool = false,
    // Comment: Can be used as storage image (STORAGE_IMAGE descriptor type)
    // bit: 3
    VK_IMAGE_USAGE_STORAGE_BIT: bool = false,
    // Comment: Can be used as framebuffer color attachment
    // bit: 4
    VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT: bool = false,
    // Comment: Can be used as framebuffer depth/stencil attachment
    // bit: 5
    VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT: bool = false,
    // Comment: Image data not needed outside of rendering
    // bit: 6
    VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT: bool = false,
    // Comment: Can be used as framebuffer input attachment
    // bit: 7
    VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT: bool = false,
    // Extension: VK_KHR_fragment_shading_rate
    // bit: 8
    VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR: bool = false,
    // Extension: VK_EXT_fragment_density_map
    // bit: 9
    VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT: bool = false,
    // Extension: VK_KHR_video_decode_queue
    // bit: 10
    VK_IMAGE_USAGE_VIDEO_DECODE_DST_BIT_KHR: bool = false,
    // Extension: VK_KHR_video_decode_queue
    // bit: 11
    VK_IMAGE_USAGE_VIDEO_DECODE_SRC_BIT_KHR: bool = false,
    // Extension: VK_KHR_video_decode_queue
    // bit: 12
    VK_IMAGE_USAGE_VIDEO_DECODE_DPB_BIT_KHR: bool = false,
    // Extension: VK_KHR_video_encode_queue
    // bit: 13
    VK_IMAGE_USAGE_VIDEO_ENCODE_DST_BIT_KHR: bool = false,
    // Extension: VK_KHR_video_encode_queue
    // bit: 14
    VK_IMAGE_USAGE_VIDEO_ENCODE_SRC_BIT_KHR: bool = false,
    // Extension: VK_KHR_video_encode_queue
    // bit: 15
    VK_IMAGE_USAGE_VIDEO_ENCODE_DPB_BIT_KHR: bool = false,
    _15: u2 = 0,
    // Extension: VK_HUAWEI_invocation_mask
    // bit: 18
    VK_IMAGE_USAGE_INVOCATION_MASK_BIT_HUAWEI: bool = false,
    // Extension: VK_EXT_attachment_feedback_loop_layout
    // bit: 19
    VK_IMAGE_USAGE_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT: bool = false,
    // Extension: VK_QCOM_image_processing
    // bit: 20
    VK_IMAGE_USAGE_SAMPLE_WEIGHT_BIT_QCOM: bool = false,
    // Extension: VK_QCOM_image_processing
    // bit: 21
    VK_IMAGE_USAGE_SAMPLE_BLOCK_MATCH_BIT_QCOM: bool = false,
    // Extension: VK_BASE_VERSION_1_4
    // bit: 22
    VK_IMAGE_USAGE_HOST_TRANSFER_BIT: bool = false,
    // Extension: VK_ARM_tensors
    // bit: 23
    VK_IMAGE_USAGE_TENSOR_ALIASING_BIT_ARM: bool = false,
    _23: u1 = 0,
    // Extension: VK_KHR_video_encode_quantization_map
    // bit: 25
    VK_IMAGE_USAGE_VIDEO_ENCODE_QUANTIZATION_DELTA_MAP_BIT_KHR: bool = false,
    // Extension: VK_KHR_video_encode_quantization_map
    // bit: 26
    VK_IMAGE_USAGE_VIDEO_ENCODE_EMPHASIS_MAP_BIT_KHR: bool = false,
    // Extension: VK_QCOM_tile_memory_heap
    // bit: 27
    VK_IMAGE_USAGE_TILE_MEMORY_BIT_QCOM: bool = false,
    _: u4 = 0,
};
pub const VkImageCreateFlags = packed struct(u32) {
    // Comment: Image should support sparse backing
    // bit: 0
    VK_IMAGE_CREATE_SPARSE_BINDING_BIT: bool = false,
    // Comment: Image should support sparse backing with partial residency
    // bit: 1
    VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT: bool = false,
    // Comment: Image should support constant data access to physical memory ranges mapped into multiple locations of sparse images
    // bit: 2
    VK_IMAGE_CREATE_SPARSE_ALIASED_BIT: bool = false,
    // Comment: Allows image views to have different format than the base image
    // bit: 3
    VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT: bool = false,
    // Comment: Allows creating image views with cube type from the created image
    // bit: 4
    VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT: bool = false,
    // Extension: VK_BASE_VERSION_1_1
    // bit: 5
    VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT: bool = false,
    // Extension: VK_BASE_VERSION_1_1
    // bit: 6
    VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT: bool = false,
    // Extension: VK_BASE_VERSION_1_1
    // bit: 7
    VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT: bool = false,
    // Extension: VK_BASE_VERSION_1_1
    // bit: 8
    VK_IMAGE_CREATE_EXTENDED_USAGE_BIT: bool = false,
    // Extension: VK_BASE_VERSION_1_1
    // bit: 9
    VK_IMAGE_CREATE_DISJOINT_BIT: bool = false,
    // Extension: VK_BASE_VERSION_1_1
    // bit: 10
    VK_IMAGE_CREATE_ALIAS_BIT: bool = false,
    // Extension: VK_BASE_VERSION_1_1
    // bit: 11
    VK_IMAGE_CREATE_PROTECTED_BIT: bool = false,
    // Extension: VK_EXT_sample_locations
    // bit: 12
    VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT: bool = false,
    // Extension: VK_NV_corner_sampled_image
    // bit: 13
    VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV: bool = false,
    // Extension: VK_EXT_fragment_density_map
    // bit: 14
    VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT: bool = false,
    // Extension: VK_EXT_fragment_density_map_offset
    // bit: 15
    VK_IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_EXT: bool = false,
    // Extension: VK_EXT_descriptor_buffer
    // bit: 16
    VK_IMAGE_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT: bool = false,
    // Extension: VK_EXT_image_2d_view_of_3d
    // bit: 17
    VK_IMAGE_CREATE_2D_VIEW_COMPATIBLE_BIT_EXT: bool = false,
    // Extension: VK_EXT_multisampled_render_to_single_sampled
    // bit: 18
    VK_IMAGE_CREATE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_BIT_EXT: bool = false,
    _18: u1 = 0,
    // Extension: VK_KHR_video_maintenance1
    // bit: 20
    VK_IMAGE_CREATE_VIDEO_PROFILE_INDEPENDENT_BIT_KHR: bool = false,
    _: u11 = 0,
};
pub const VkImageViewCreateFlags = packed struct(u32) {
    // Extension: VK_EXT_fragment_density_map
    // bit: 0
    VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT: bool = false,
    // Extension: VK_EXT_fragment_density_map2
    // bit: 1
    VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DEFERRED_BIT_EXT: bool = false,
    // Extension: VK_EXT_descriptor_buffer
    // bit: 2
    VK_IMAGE_VIEW_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT: bool = false,
    _: u29 = 0,
};
pub const VkPipelineCreateFlags = packed struct(u32) {
    // bit: 0
    VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT: bool = false,
    // bit: 1
    VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT: bool = false,
    // bit: 2
    VK_PIPELINE_CREATE_DERIVATIVE_BIT: bool = false,
    // Extension: VK_GRAPHICS_VERSION_1_1
    // bit: 3
    VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT: bool = false,
    // Extension: VK_COMPUTE_VERSION_1_1
    // bit: 4
    VK_PIPELINE_CREATE_DISPATCH_BASE_BIT: bool = false,
    // Extension: VK_NV_ray_tracing
    // bit: 5
    VK_PIPELINE_CREATE_DEFER_COMPILE_BIT_NV: bool = false,
    // Extension: VK_KHR_pipeline_executable_properties
    // bit: 6
    VK_PIPELINE_CREATE_CAPTURE_STATISTICS_BIT_KHR: bool = false,
    // Extension: VK_KHR_pipeline_executable_properties
    // bit: 7
    VK_PIPELINE_CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR: bool = false,
    // Extension: VK_COMPUTE_VERSION_1_3
    // bit: 8
    VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT: bool = false,
    // Extension: VK_COMPUTE_VERSION_1_3
    // bit: 9
    VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT: bool = false,
    // Extension: VK_EXT_graphics_pipeline_library
    // bit: 10
    VK_PIPELINE_CREATE_LINK_TIME_OPTIMIZATION_BIT_EXT: bool = false,
    // Extension: VK_KHR_pipeline_library
    // bit: 11
    VK_PIPELINE_CREATE_LIBRARY_BIT_KHR: bool = false,
    // Extension: VK_KHR_ray_tracing_pipeline
    // bit: 12
    VK_PIPELINE_CREATE_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR: bool = false,
    // Extension: VK_KHR_ray_tracing_pipeline
    // bit: 13
    VK_PIPELINE_CREATE_RAY_TRACING_SKIP_AABBS_BIT_KHR: bool = false,
    // Extension: VK_KHR_ray_tracing_pipeline
    // bit: 14
    VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR: bool = false,
    // Extension: VK_KHR_ray_tracing_pipeline
    // bit: 15
    VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR: bool = false,
    // Extension: VK_KHR_ray_tracing_pipeline
    // bit: 16
    VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR: bool = false,
    // Extension: VK_KHR_ray_tracing_pipeline
    // bit: 17
    VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR: bool = false,
    // Extension: VK_NV_device_generated_commands
    // bit: 18
    VK_PIPELINE_CREATE_INDIRECT_BINDABLE_BIT_NV: bool = false,
    // Extension: VK_KHR_ray_tracing_pipeline
    // bit: 19
    VK_PIPELINE_CREATE_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR: bool = false,
    // Extension: VK_NV_ray_tracing_motion_blur
    // bit: 20
    VK_PIPELINE_CREATE_RAY_TRACING_ALLOW_MOTION_BIT_NV: bool = false,
    // Extension: VK_KHR_fragment_shading_rate
    // bit: 21
    VK_PIPELINE_CREATE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR: bool = false,
    // Extension: VK_EXT_fragment_density_map
    // bit: 22
    VK_PIPELINE_CREATE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT: bool = false,
    // Extension: VK_EXT_graphics_pipeline_library
    // bit: 23
    VK_PIPELINE_CREATE_RETAIN_LINK_TIME_OPTIMIZATION_INFO_BIT_EXT: bool = false,
    // Extension: VK_EXT_opacity_micromap
    // bit: 24
    VK_PIPELINE_CREATE_RAY_TRACING_OPACITY_MICROMAP_BIT_EXT: bool = false,
    // Extension: VK_EXT_attachment_feedback_loop_layout
    // bit: 25
    VK_PIPELINE_CREATE_COLOR_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT: bool = false,
    // Extension: VK_EXT_attachment_feedback_loop_layout
    // bit: 26
    VK_PIPELINE_CREATE_DEPTH_STENCIL_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT: bool = false,
    // Extension: VK_COMPUTE_VERSION_1_4
    // bit: 27
    VK_PIPELINE_CREATE_NO_PROTECTED_ACCESS_BIT: bool = false,
    // Extension: VK_NV_displacement_micromap
    // bit: 28
    VK_PIPELINE_CREATE_RAY_TRACING_DISPLACEMENT_MICROMAP_BIT_NV: bool = false,
    // Extension: VK_EXT_descriptor_buffer
    // bit: 29
    VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT: bool = false,
    // Extension: VK_COMPUTE_VERSION_1_4
    // bit: 30
    VK_PIPELINE_CREATE_PROTECTED_ACCESS_ONLY_BIT: bool = false,
    _: u1 = 0,
};
pub const VkColorComponentFlags = packed struct(u32) {
    // bit: 0
    VK_COLOR_COMPONENT_R_BIT: bool = false,
    // bit: 1
    VK_COLOR_COMPONENT_G_BIT: bool = false,
    // bit: 2
    VK_COLOR_COMPONENT_B_BIT: bool = false,
    // bit: 3
    VK_COLOR_COMPONENT_A_BIT: bool = false,
    _: u28 = 0,
};
pub const VkFenceCreateFlags = packed struct(u32) {
    // bit: 0
    VK_FENCE_CREATE_SIGNALED_BIT: bool = false,
    _: u31 = 0,
};
pub const VkSemaphoreCreateFlags = packed struct(u32) {
    _: u32 = 0,
};
pub const VkFormatFeatureFlags = packed struct(u32) {
    // Comment: Format can be used for sampled images (SAMPLED_IMAGE and COMBINED_IMAGE_SAMPLER descriptor types)
    // bit: 0
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT: bool = false,
    // Comment: Format can be used for storage images (STORAGE_IMAGE descriptor type)
    // bit: 1
    VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT: bool = false,
    // Comment: Format supports atomic operations in case it is used for storage images
    // bit: 2
    VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT: bool = false,
    // Comment: Format can be used for uniform texel buffers (TBOs)
    // bit: 3
    VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT: bool = false,
    // Comment: Format can be used for storage texel buffers (IBOs)
    // bit: 4
    VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT: bool = false,
    // Comment: Format supports atomic operations in case it is used for storage texel buffers
    // bit: 5
    VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT: bool = false,
    // Comment: Format can be used for vertex buffers (VBOs)
    // bit: 6
    VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT: bool = false,
    // Comment: Format can be used for color attachment images
    // bit: 7
    VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT: bool = false,
    // Comment: Format supports blending in case it is used for color attachment images
    // bit: 8
    VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT: bool = false,
    // Comment: Format can be used for depth/stencil attachment images
    // bit: 9
    VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT: bool = false,
    // Comment: Format can be used as the source image of blits with vkCmdBlitImage
    // bit: 10
    VK_FORMAT_FEATURE_BLIT_SRC_BIT: bool = false,
    // Comment: Format can be used as the destination image of blits with vkCmdBlitImage
    // bit: 11
    VK_FORMAT_FEATURE_BLIT_DST_BIT: bool = false,
    // Comment: Format can be filtered with VK_FILTER_LINEAR when being sampled
    // bit: 12
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT: bool = false,
    // Extension: VK_EXT_filter_cubic
    // bit: 13
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT: bool = false,
    // Extension: VK_BASE_VERSION_1_1
    // bit: 14
    VK_FORMAT_FEATURE_TRANSFER_SRC_BIT: bool = false,
    // Extension: VK_BASE_VERSION_1_1
    // bit: 15
    VK_FORMAT_FEATURE_TRANSFER_DST_BIT: bool = false,
    // Extension: VK_COMPUTE_VERSION_1_2
    // bit: 16
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT: bool = false,
    // Extension: VK_COMPUTE_VERSION_1_1
    // bit: 17
    VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT: bool = false,
    // Extension: VK_COMPUTE_VERSION_1_1
    // bit: 18
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT: bool = false,
    // Extension: VK_COMPUTE_VERSION_1_1
    // bit: 19
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT: bool = false,
    // Extension: VK_COMPUTE_VERSION_1_1
    // bit: 20
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT: bool = false,
    // Extension: VK_COMPUTE_VERSION_1_1
    // bit: 21
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT: bool = false,
    // Extension: VK_COMPUTE_VERSION_1_1
    // bit: 22
    VK_FORMAT_FEATURE_DISJOINT_BIT: bool = false,
    // Extension: VK_COMPUTE_VERSION_1_1
    // bit: 23
    VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT: bool = false,
    // Extension: VK_EXT_fragment_density_map
    // bit: 24
    VK_FORMAT_FEATURE_FRAGMENT_DENSITY_MAP_BIT_EXT: bool = false,
    // Extension: VK_KHR_video_decode_queue
    // bit: 25
    VK_FORMAT_FEATURE_VIDEO_DECODE_OUTPUT_BIT_KHR: bool = false,
    // Extension: VK_KHR_video_decode_queue
    // bit: 26
    VK_FORMAT_FEATURE_VIDEO_DECODE_DPB_BIT_KHR: bool = false,
    // Extension: VK_KHR_video_encode_queue
    // bit: 27
    VK_FORMAT_FEATURE_VIDEO_ENCODE_INPUT_BIT_KHR: bool = false,
    // Extension: VK_KHR_video_encode_queue
    // bit: 28
    VK_FORMAT_FEATURE_VIDEO_ENCODE_DPB_BIT_KHR: bool = false,
    // Extension: VK_KHR_acceleration_structure
    // bit: 29
    VK_FORMAT_FEATURE_ACCELERATION_STRUCTURE_VERTEX_BUFFER_BIT_KHR: bool = false,
    // Extension: VK_KHR_fragment_shading_rate
    // bit: 30
    VK_FORMAT_FEATURE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR: bool = false,
    _: u1 = 0,
};
pub const VkQueryControlFlags = packed struct(u32) {
    // Comment: Require precise results to be collected by the query
    // bit: 0
    VK_QUERY_CONTROL_PRECISE_BIT: bool = false,
    _: u31 = 0,
};
pub const VkQueryResultFlags = packed struct(u32) {
    // Comment: Results of the queries are written to the destination buffer as 64-bit values
    // bit: 0
    VK_QUERY_RESULT_64_BIT: bool = false,
    // Comment: Results of the queries are waited on before proceeding with the result copy
    // bit: 1
    VK_QUERY_RESULT_WAIT_BIT: bool = false,
    // Comment: Besides the results of the query, the availability of the results is also written
    // bit: 2
    VK_QUERY_RESULT_WITH_AVAILABILITY_BIT: bool = false,
    // Comment: Copy the partial results of the query even if the final results are not available
    // bit: 3
    VK_QUERY_RESULT_PARTIAL_BIT: bool = false,
    // Extension: VK_KHR_video_queue
    // bit: 4
    VK_QUERY_RESULT_WITH_STATUS_BIT_KHR: bool = false,
    _: u27 = 0,
};
pub const VkShaderModuleCreateFlags = packed struct(u32) {
    _: u32 = 0,
};
pub const VkEventCreateFlags = packed struct(u32) {
    // Extension: VK_COMPUTE_VERSION_1_3
    // bit: 0
    VK_EVENT_CREATE_DEVICE_ONLY_BIT: bool = false,
    _: u31 = 0,
};
pub const VkCommandPoolCreateFlags = packed struct(u32) {
    // Comment: Command buffers have a short lifetime
    // bit: 0
    VK_COMMAND_POOL_CREATE_TRANSIENT_BIT: bool = false,
    // Comment: Command buffers may release their memory individually
    // bit: 1
    VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT: bool = false,
    // Extension: VK_BASE_VERSION_1_1
    // bit: 2
    VK_COMMAND_POOL_CREATE_PROTECTED_BIT: bool = false,
    _: u29 = 0,
};
pub const VkCommandPoolResetFlags = packed struct(u32) {
    // Comment: Release resources owned by the pool
    // bit: 0
    VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT: bool = false,
    _: u31 = 0,
};
pub const VkCommandBufferResetFlags = packed struct(u32) {
    // Comment: Release resources owned by the buffer
    // bit: 0
    VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT: bool = false,
    _: u31 = 0,
};
pub const VkCommandBufferUsageFlags = packed struct(u32) {
    // bit: 0
    VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT: bool = false,
    // bit: 1
    VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT: bool = false,
    // Comment: Command buffer may be submitted/executed more than once simultaneously
    // bit: 2
    VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT: bool = false,
    _: u29 = 0,
};
pub const VkQueryPipelineStatisticFlags = packed struct(u32) {
    // Comment: Optional
    // bit: 0
    VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT: bool = false,
    // Comment: Optional
    // bit: 1
    VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT: bool = false,
    // Comment: Optional
    // bit: 2
    VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT: bool = false,
    // Comment: Optional
    // bit: 3
    VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT: bool = false,
    // Comment: Optional
    // bit: 4
    VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT: bool = false,
    // Comment: Optional
    // bit: 5
    VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT: bool = false,
    // Comment: Optional
    // bit: 6
    VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT: bool = false,
    // Comment: Optional
    // bit: 7
    VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT: bool = false,
    // Comment: Optional
    // bit: 8
    VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT: bool = false,
    // Comment: Optional
    // bit: 9
    VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT: bool = false,
    // Comment: Optional
    // bit: 10
    VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT: bool = false,
    // Extension: VK_EXT_mesh_shader
    // bit: 11
    VK_QUERY_PIPELINE_STATISTIC_TASK_SHADER_INVOCATIONS_BIT_EXT: bool = false,
    // Extension: VK_EXT_mesh_shader
    // bit: 12
    VK_QUERY_PIPELINE_STATISTIC_MESH_SHADER_INVOCATIONS_BIT_EXT: bool = false,
    // Extension: VK_HUAWEI_cluster_culling_shader
    // bit: 13
    VK_QUERY_PIPELINE_STATISTIC_CLUSTER_CULLING_SHADER_INVOCATIONS_BIT_HUAWEI: bool = false,
    _: u18 = 0,
};
pub const VkMemoryMapFlags = packed struct(u32) {
    // Extension: VK_EXT_map_memory_placed
    // bit: 0
    VK_MEMORY_MAP_PLACED_BIT_EXT: bool = false,
    _: u31 = 0,
};
pub const VkMemoryUnmapFlags = packed struct(u32) {
    // Extension: VK_EXT_map_memory_placed
    // bit: 0
    VK_MEMORY_UNMAP_RESERVE_BIT_EXT: bool = false,
    _: u31 = 0,
};
pub const VkImageAspectFlags = packed struct(u32) {
    // bit: 0
    VK_IMAGE_ASPECT_COLOR_BIT: bool = false,
    // bit: 1
    VK_IMAGE_ASPECT_DEPTH_BIT: bool = false,
    // bit: 2
    VK_IMAGE_ASPECT_STENCIL_BIT: bool = false,
    // bit: 3
    VK_IMAGE_ASPECT_METADATA_BIT: bool = false,
    // Extension: VK_BASE_VERSION_1_1
    // bit: 4
    VK_IMAGE_ASPECT_PLANE_0_BIT: bool = false,
    // Extension: VK_BASE_VERSION_1_1
    // bit: 5
    VK_IMAGE_ASPECT_PLANE_1_BIT: bool = false,
    // Extension: VK_BASE_VERSION_1_1
    // bit: 6
    VK_IMAGE_ASPECT_PLANE_2_BIT: bool = false,
    // Extension: VK_EXT_image_drm_format_modifier
    // bit: 7
    VK_IMAGE_ASPECT_MEMORY_PLANE_0_BIT_EXT: bool = false,
    // Extension: VK_EXT_image_drm_format_modifier
    // bit: 8
    VK_IMAGE_ASPECT_MEMORY_PLANE_1_BIT_EXT: bool = false,
    // Extension: VK_EXT_image_drm_format_modifier
    // bit: 9
    VK_IMAGE_ASPECT_MEMORY_PLANE_2_BIT_EXT: bool = false,
    // Extension: VK_EXT_image_drm_format_modifier
    // bit: 10
    VK_IMAGE_ASPECT_MEMORY_PLANE_3_BIT_EXT: bool = false,
    _: u21 = 0,
};
pub const VkSparseMemoryBindFlags = packed struct(u32) {
    // Comment: Operation binds resource metadata to memory
    // bit: 0
    VK_SPARSE_MEMORY_BIND_METADATA_BIT: bool = false,
    _: u31 = 0,
};
pub const VkSparseImageFormatFlags = packed struct(u32) {
    // Comment: Image uses a single mip tail region for all array layers
    // bit: 0
    VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT: bool = false,
    // Comment: Image requires mip level dimensions to be an integer multiple of the sparse image block dimensions for non-tail mip levels.
    // bit: 1
    VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT: bool = false,
    // Comment: Image uses a non-standard sparse image block dimensions
    // bit: 2
    VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT: bool = false,
    _: u29 = 0,
};
pub const VkSubpassDescriptionFlags = packed struct(u32) {
    // Extension: VK_NVX_multiview_per_view_attributes
    // bit: 0
    VK_SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX: bool = false,
    // Extension: VK_NVX_multiview_per_view_attributes
    // bit: 1
    VK_SUBPASS_DESCRIPTION_PER_VIEW_POSITION_X_ONLY_BIT_NVX: bool = false,
    // Extension: VK_EXT_custom_resolve
    // bit: 2
    VK_SUBPASS_DESCRIPTION_FRAGMENT_REGION_BIT_EXT: bool = false,
    // Extension: VK_EXT_custom_resolve
    // bit: 3
    VK_SUBPASS_DESCRIPTION_CUSTOM_RESOLVE_BIT_EXT: bool = false,
    // Extension: VK_EXT_rasterization_order_attachment_access
    // bit: 4
    VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_COLOR_ACCESS_BIT_EXT: bool = false,
    // Extension: VK_EXT_rasterization_order_attachment_access
    // bit: 5
    VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_EXT: bool = false,
    // Extension: VK_EXT_rasterization_order_attachment_access
    // bit: 6
    VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_EXT: bool = false,
    // Extension: VK_EXT_legacy_dithering
    // bit: 7
    VK_SUBPASS_DESCRIPTION_ENABLE_LEGACY_DITHERING_BIT_EXT: bool = false,
    // Extension: VK_QCOM_tile_shading
    // bit: 8
    VK_SUBPASS_DESCRIPTION_TILE_SHADING_APRON_BIT_QCOM: bool = false,
    _: u23 = 0,
};
pub const VkPipelineStageFlags = packed struct(u32) {
    // Comment: Before subsequent commands are processed
    // bit: 0
    VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT: bool = false,
    // Comment: Draw/DispatchIndirect command fetch
    // bit: 1
    VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT: bool = false,
    // Comment: Vertex/index fetch
    // bit: 2
    VK_PIPELINE_STAGE_VERTEX_INPUT_BIT: bool = false,
    // Comment: Vertex shading
    // bit: 3
    VK_PIPELINE_STAGE_VERTEX_SHADER_BIT: bool = false,
    // Comment: Tessellation control shading
    // bit: 4
    VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT: bool = false,
    // Comment: Tessellation evaluation shading
    // bit: 5
    VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT: bool = false,
    // Comment: Geometry shading
    // bit: 6
    VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT: bool = false,
    // Comment: Fragment shading
    // bit: 7
    VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT: bool = false,
    // Comment: Early fragment (depth and stencil) tests
    // bit: 8
    VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT: bool = false,
    // Comment: Late fragment (depth and stencil) tests
    // bit: 9
    VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT: bool = false,
    // Comment: Color attachment writes
    // bit: 10
    VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT: bool = false,
    // Comment: Compute shading
    // bit: 11
    VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT: bool = false,
    // Comment: Transfer/copy operations
    // bit: 12
    VK_PIPELINE_STAGE_TRANSFER_BIT: bool = false,
    // Comment: After previous commands have completed
    // bit: 13
    VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT: bool = false,
    // Comment: Indicates host (CPU) is a source/sink of the dependency
    // bit: 14
    VK_PIPELINE_STAGE_HOST_BIT: bool = false,
    // Comment: All stages of the graphics pipeline
    // bit: 15
    VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT: bool = false,
    // Comment: All stages supported on the queue
    // bit: 16
    VK_PIPELINE_STAGE_ALL_COMMANDS_BIT: bool = false,
    // Extension: VK_EXT_device_generated_commands
    // bit: 17
    VK_PIPELINE_STAGE_COMMAND_PREPROCESS_BIT_EXT: bool = false,
    // Extension: VK_EXT_conditional_rendering
    // bit: 18
    VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT: bool = false,
    // Extension: VK_EXT_mesh_shader
    // bit: 19
    VK_PIPELINE_STAGE_TASK_SHADER_BIT_EXT: bool = false,
    // Extension: VK_EXT_mesh_shader
    // bit: 20
    VK_PIPELINE_STAGE_MESH_SHADER_BIT_EXT: bool = false,
    // Extension: VK_KHR_ray_tracing_pipeline
    // bit: 21
    VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_KHR: bool = false,
    // Extension: VK_KHR_fragment_shading_rate
    // bit: 22
    VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR: bool = false,
    // Extension: VK_EXT_fragment_density_map
    // bit: 23
    VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT: bool = false,
    // Extension: VK_EXT_transform_feedback
    // bit: 24
    VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT: bool = false,
    // Extension: VK_KHR_acceleration_structure
    // bit: 25
    VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR: bool = false,
    _: u6 = 0,
};
pub const VkSampleCountFlags = packed struct(u32) {
    // Comment: Sample count 1 supported
    // bit: 0
    VK_SAMPLE_COUNT_1_BIT: bool = false,
    // Comment: Sample count 2 supported
    // bit: 1
    VK_SAMPLE_COUNT_2_BIT: bool = false,
    // Comment: Sample count 4 supported
    // bit: 2
    VK_SAMPLE_COUNT_4_BIT: bool = false,
    // Comment: Sample count 8 supported
    // bit: 3
    VK_SAMPLE_COUNT_8_BIT: bool = false,
    // Comment: Sample count 16 supported
    // bit: 4
    VK_SAMPLE_COUNT_16_BIT: bool = false,
    // Comment: Sample count 32 supported
    // bit: 5
    VK_SAMPLE_COUNT_32_BIT: bool = false,
    // Comment: Sample count 64 supported
    // bit: 6
    VK_SAMPLE_COUNT_64_BIT: bool = false,
    _: u25 = 0,
};
pub const VkAttachmentDescriptionFlags = packed struct(u32) {
    // Comment: The attachment may alias physical memory of another attachment in the same render pass
    // bit: 0
    VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT: bool = false,
    // Extension: VK_KHR_maintenance10
    // bit: 1
    VK_ATTACHMENT_DESCRIPTION_RESOLVE_SKIP_TRANSFER_FUNCTION_BIT_KHR: bool = false,
    // Extension: VK_KHR_maintenance10
    // bit: 2
    VK_ATTACHMENT_DESCRIPTION_RESOLVE_ENABLE_TRANSFER_FUNCTION_BIT_KHR: bool = false,
    _: u29 = 0,
};
pub const VkStencilFaceFlags = packed struct(u32) {
    // Comment: Front face
    // bit: 0
    VK_STENCIL_FACE_FRONT_BIT: bool = false,
    // Comment: Back face
    // bit: 1
    VK_STENCIL_FACE_BACK_BIT: bool = false,
    _: u30 = 0,
    pub const VK_STENCIL_FACE_FRONT_AND_BACK: @This() = @bitCast(@as(u32, 0x3));
};
pub const VkCullModeFlags = packed struct(u32) {
    // bit: 0
    VK_CULL_MODE_FRONT_BIT: bool = false,
    // bit: 1
    VK_CULL_MODE_BACK_BIT: bool = false,
    _: u30 = 0,
    pub const VK_CULL_MODE_NONE: @This() = @bitCast(@as(u32, 0x0));
    pub const VK_CULL_MODE_FRONT_AND_BACK: @This() = @bitCast(@as(u32, 0x3));
};
pub const VkDescriptorPoolCreateFlags = packed struct(u32) {
    // Comment: Descriptor sets may be freed individually
    // bit: 0
    VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT: bool = false,
    // Extension: VK_COMPUTE_VERSION_1_2
    // bit: 1
    VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT: bool = false,
    // Extension: VK_EXT_mutable_descriptor_type
    // bit: 2
    VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_EXT: bool = false,
    // Extension: VK_NV_descriptor_pool_overallocation
    // bit: 3
    VK_DESCRIPTOR_POOL_CREATE_ALLOW_OVERALLOCATION_SETS_BIT_NV: bool = false,
    // Extension: VK_NV_descriptor_pool_overallocation
    // bit: 4
    VK_DESCRIPTOR_POOL_CREATE_ALLOW_OVERALLOCATION_POOLS_BIT_NV: bool = false,
    _: u27 = 0,
};
pub const VkDescriptorPoolResetFlags = packed struct(u32) {
    _: u32 = 0,
};
pub const VkDependencyFlags = packed struct(u32) {
    // Comment: Dependency is per pixel region 
    // bit: 0
    VK_DEPENDENCY_BY_REGION_BIT: bool = false,
    // Extension: VK_GRAPHICS_VERSION_1_1
    // bit: 1
    VK_DEPENDENCY_VIEW_LOCAL_BIT: bool = false,
    // Extension: VK_BASE_VERSION_1_1
    // bit: 2
    VK_DEPENDENCY_DEVICE_GROUP_BIT: bool = false,
    // Extension: VK_EXT_attachment_feedback_loop_layout
    // bit: 3
    VK_DEPENDENCY_FEEDBACK_LOOP_BIT_EXT: bool = false,
    _3: u1 = 0,
    // Extension: VK_KHR_maintenance8
    // bit: 5
    VK_DEPENDENCY_QUEUE_FAMILY_OWNERSHIP_TRANSFER_USE_ALL_STAGES_BIT_KHR: bool = false,
    // Extension: VK_KHR_maintenance9
    // bit: 6
    VK_DEPENDENCY_ASYMMETRIC_EVENT_BIT_KHR: bool = false,
    _: u25 = 0,
};
pub const VkSubgroupFeatureFlags = packed struct(u32) {
    // Comment: Basic subgroup operations
    // bit: 0
    VK_SUBGROUP_FEATURE_BASIC_BIT: bool = false,
    // Comment: Vote subgroup operations
    // bit: 1
    VK_SUBGROUP_FEATURE_VOTE_BIT: bool = false,
    // Comment: Arithmetic subgroup operations
    // bit: 2
    VK_SUBGROUP_FEATURE_ARITHMETIC_BIT: bool = false,
    // Comment: Ballot subgroup operations
    // bit: 3
    VK_SUBGROUP_FEATURE_BALLOT_BIT: bool = false,
    // Comment: Shuffle subgroup operations
    // bit: 4
    VK_SUBGROUP_FEATURE_SHUFFLE_BIT: bool = false,
    // Comment: Shuffle relative subgroup operations
    // bit: 5
    VK_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT: bool = false,
    // Comment: Clustered subgroup operations
    // bit: 6
    VK_SUBGROUP_FEATURE_CLUSTERED_BIT: bool = false,
    // Comment: Quad subgroup operations
    // bit: 7
    VK_SUBGROUP_FEATURE_QUAD_BIT: bool = false,
    // Extension: VK_NV_shader_subgroup_partitioned
    // bit: 8
    VK_SUBGROUP_FEATURE_PARTITIONED_BIT_NV: bool = false,
    // Extension: VK_COMPUTE_VERSION_1_4
    // bit: 9
    VK_SUBGROUP_FEATURE_ROTATE_BIT: bool = false,
    // Extension: VK_COMPUTE_VERSION_1_4
    // bit: 10
    VK_SUBGROUP_FEATURE_ROTATE_CLUSTERED_BIT: bool = false,
    _: u21 = 0,
};
pub const VkIndirectCommandsLayoutUsageFlagsNV = packed struct(u32) {
    // bit: 0
    VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EXPLICIT_PREPROCESS_BIT_NV: bool = false,
    // bit: 1
    VK_INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT_NV: bool = false,
    // bit: 2
    VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_NV: bool = false,
    _: u29 = 0,
};
pub const VkIndirectStateFlagsNV = packed struct(u32) {
    // bit: 0
    VK_INDIRECT_STATE_FLAG_FRONTFACE_BIT_NV: bool = false,
    _: u31 = 0,
};
pub const VkGeometryFlagsKHR = packed struct(u32) {
    // bit: 0
    VK_GEOMETRY_OPAQUE_BIT_KHR: bool = false,
    // bit: 1
    VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_KHR: bool = false,
    _: u30 = 0,
};
pub const VkGeometryInstanceFlagsKHR = packed struct(u32) {
    // bit: 0
    VK_GEOMETRY_INSTANCE_TRIANGLE_FACING_CULL_DISABLE_BIT_KHR: bool = false,
    // bit: 1
    VK_GEOMETRY_INSTANCE_TRIANGLE_FLIP_FACING_BIT_KHR: bool = false,
    // bit: 2
    VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_KHR: bool = false,
    // bit: 3
    VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_KHR: bool = false,
    // Extension: VK_EXT_opacity_micromap
    // bit: 4
    VK_GEOMETRY_INSTANCE_FORCE_OPACITY_MICROMAP_2_STATE_BIT_EXT: bool = false,
    // Extension: VK_EXT_opacity_micromap
    // bit: 5
    VK_GEOMETRY_INSTANCE_DISABLE_OPACITY_MICROMAPS_BIT_EXT: bool = false,
    _: u26 = 0,
};
pub const VkClusterAccelerationStructureGeometryFlagsNV = packed struct(u32) {
    // bit: 0
    VK_CLUSTER_ACCELERATION_STRUCTURE_GEOMETRY_CULL_DISABLE_BIT_NV: bool = false,
    // bit: 1
    VK_CLUSTER_ACCELERATION_STRUCTURE_GEOMETRY_NO_DUPLICATE_ANYHIT_INVOCATION_BIT_NV: bool = false,
    // bit: 2
    VK_CLUSTER_ACCELERATION_STRUCTURE_GEOMETRY_OPAQUE_BIT_NV: bool = false,
    _: u29 = 0,
};
pub const VkClusterAccelerationStructureClusterFlagsNV = packed struct(u32) {
    // bit: 0
    VK_CLUSTER_ACCELERATION_STRUCTURE_CLUSTER_ALLOW_DISABLE_OPACITY_MICROMAPS_NV: bool = false,
    _: u31 = 0,
};
pub const VkClusterAccelerationStructureAddressResolutionFlagsNV = packed struct(u32) {
    // bit: 0
    VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_DST_IMPLICIT_DATA_BIT_NV: bool = false,
    // bit: 1
    VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_SCRATCH_DATA_BIT_NV: bool = false,
    // bit: 2
    VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_DST_ADDRESS_ARRAY_BIT_NV: bool = false,
    // bit: 3
    VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_DST_SIZES_ARRAY_BIT_NV: bool = false,
    // bit: 4
    VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_SRC_INFOS_ARRAY_BIT_NV: bool = false,
    // bit: 5
    VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_SRC_INFOS_COUNT_BIT_NV: bool = false,
    _: u26 = 0,
    pub const VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_NONE_NV: @This() = @bitCast(@as(u32, 0x0));
};
pub const VkBuildAccelerationStructureFlagsKHR = packed struct(u32) {
    // bit: 0
    VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_KHR: bool = false,
    // bit: 1
    VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_KHR: bool = false,
    // bit: 2
    VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_KHR: bool = false,
    // bit: 3
    VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_KHR: bool = false,
    // bit: 4
    VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_KHR: bool = false,
    // Extension: VK_NV_ray_tracing_motion_blur
    // bit: 5
    VK_BUILD_ACCELERATION_STRUCTURE_MOTION_BIT_NV: bool = false,
    // Extension: VK_EXT_opacity_micromap
    // bit: 6
    VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_UPDATE_BIT_EXT: bool = false,
    // Extension: VK_EXT_opacity_micromap
    // bit: 7
    VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DISABLE_OPACITY_MICROMAPS_BIT_EXT: bool = false,
    // Extension: VK_EXT_opacity_micromap
    // bit: 8
    VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_DATA_UPDATE_BIT_EXT: bool = false,
    // Extension: VK_NV_displacement_micromap
    // bit: 9
    VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DISPLACEMENT_MICROMAP_UPDATE_BIT_NV: bool = false,
    _9: u1 = 0,
    // Extension: VK_KHR_ray_tracing_position_fetch
    // bit: 11
    VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DATA_ACCESS_BIT_KHR: bool = false,
    // Extension: VK_NV_cluster_acceleration_structure
    // bit: 12
    VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_CLUSTER_OPACITY_MICROMAPS_BIT_NV: bool = false,
    _: u19 = 0,
};
pub const VkPrivateDataSlotCreateFlags = packed struct(u32) {
    _: u32 = 0,
};
pub const VkAccelerationStructureCreateFlagsKHR = packed struct(u32) {
    // bit: 0
    VK_ACCELERATION_STRUCTURE_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR: bool = false,
    _0: u1 = 0,
    // Extension: VK_NV_ray_tracing_motion_blur
    // bit: 2
    VK_ACCELERATION_STRUCTURE_CREATE_MOTION_BIT_NV: bool = false,
    // Extension: VK_EXT_descriptor_buffer
    // bit: 3
    VK_ACCELERATION_STRUCTURE_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT: bool = false,
    _: u28 = 0,
};
pub const VkDescriptorUpdateTemplateCreateFlags = packed struct(u32) {
    _: u32 = 0,
};
pub const VkPipelineCreationFeedbackFlags = packed struct(u32) {
    // bit: 0
    VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT: bool = false,
    // bit: 1
    VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT: bool = false,
    // bit: 2
    VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT: bool = false,
    _: u29 = 0,
};
pub const VkPerformanceCounterDescriptionFlagsKHR = packed struct(u32) {
    // bit: 0
    VK_PERFORMANCE_COUNTER_DESCRIPTION_PERFORMANCE_IMPACTING_BIT_KHR: bool = false,
    // bit: 1
    VK_PERFORMANCE_COUNTER_DESCRIPTION_CONCURRENTLY_IMPACTED_BIT_KHR: bool = false,
    _: u30 = 0,
};
pub const VkAcquireProfilingLockFlagsKHR = packed struct(u32) {
    _: u32 = 0,
};
pub const VkSemaphoreWaitFlags = packed struct(u32) {
    // bit: 0
    VK_SEMAPHORE_WAIT_ANY_BIT: bool = false,
    _: u31 = 0,
};
pub const VkPipelineCompilerControlFlagsAMD = packed struct(u32) {
    _: u32 = 0,
};
pub const VkShaderCorePropertiesFlagsAMD = packed struct(u32) {
    _: u32 = 0,
};
pub const VkDeviceDiagnosticsConfigFlagsNV = packed struct(u32) {
    // bit: 0
    VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_SHADER_DEBUG_INFO_BIT_NV: bool = false,
    // bit: 1
    VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_RESOURCE_TRACKING_BIT_NV: bool = false,
    // bit: 2
    VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_AUTOMATIC_CHECKPOINTS_BIT_NV: bool = false,
    // bit: 3
    VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_SHADER_ERROR_REPORTING_BIT_NV: bool = false,
    _: u28 = 0,
};
pub const VkRefreshObjectFlagsKHR = packed struct(u32) {
    _: u32 = 0,
};
pub const VkAccessFlags2 = packed struct(u64) {
    // bit: 0
    VK_ACCESS_2_INDIRECT_COMMAND_READ_BIT: bool = false,
    // bit: 1
    VK_ACCESS_2_INDEX_READ_BIT: bool = false,
    // bit: 2
    VK_ACCESS_2_VERTEX_ATTRIBUTE_READ_BIT: bool = false,
    // bit: 3
    VK_ACCESS_2_UNIFORM_READ_BIT: bool = false,
    // bit: 4
    VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT: bool = false,
    // bit: 5
    VK_ACCESS_2_SHADER_READ_BIT: bool = false,
    // bit: 6
    VK_ACCESS_2_SHADER_WRITE_BIT: bool = false,
    // bit: 7
    VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT: bool = false,
    // bit: 8
    VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT: bool = false,
    // bit: 9
    VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT: bool = false,
    // bit: 10
    VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT: bool = false,
    // bit: 11
    VK_ACCESS_2_TRANSFER_READ_BIT: bool = false,
    // bit: 12
    VK_ACCESS_2_TRANSFER_WRITE_BIT: bool = false,
    // bit: 13
    VK_ACCESS_2_HOST_READ_BIT: bool = false,
    // bit: 14
    VK_ACCESS_2_HOST_WRITE_BIT: bool = false,
    // bit: 15
    VK_ACCESS_2_MEMORY_READ_BIT: bool = false,
    // bit: 16
    VK_ACCESS_2_MEMORY_WRITE_BIT: bool = false,
    // Extension: VK_KHR_synchronization2
    // bit: 17
    VK_ACCESS_2_COMMAND_PREPROCESS_READ_BIT_EXT: bool = false,
    // Extension: VK_KHR_synchronization2
    // bit: 18
    VK_ACCESS_2_COMMAND_PREPROCESS_WRITE_BIT_EXT: bool = false,
    // Extension: VK_KHR_synchronization2
    // bit: 19
    VK_ACCESS_2_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT: bool = false,
    // Extension: VK_KHR_synchronization2
    // bit: 20
    VK_ACCESS_2_CONDITIONAL_RENDERING_READ_BIT_EXT: bool = false,
    // Extension: VK_KHR_synchronization2
    // bit: 21
    VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_KHR: bool = false,
    // Extension: VK_KHR_synchronization2
    // bit: 22
    VK_ACCESS_2_ACCELERATION_STRUCTURE_WRITE_BIT_KHR: bool = false,
    // Extension: VK_KHR_synchronization2
    // bit: 23
    VK_ACCESS_2_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR: bool = false,
    // Extension: VK_KHR_synchronization2
    // bit: 24
    VK_ACCESS_2_FRAGMENT_DENSITY_MAP_READ_BIT_EXT: bool = false,
    // Extension: VK_KHR_synchronization2
    // bit: 25
    VK_ACCESS_2_TRANSFORM_FEEDBACK_WRITE_BIT_EXT: bool = false,
    // Extension: VK_KHR_synchronization2
    // bit: 26
    VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT: bool = false,
    // Extension: VK_KHR_synchronization2
    // bit: 27
    VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT: bool = false,
    _27: u4 = 0,
    // bit: 32
    VK_ACCESS_2_SHADER_SAMPLED_READ_BIT: bool = false,
    // bit: 33
    VK_ACCESS_2_SHADER_STORAGE_READ_BIT: bool = false,
    // bit: 34
    VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT: bool = false,
    // Extension: VK_KHR_video_decode_queue
    // bit: 35
    VK_ACCESS_2_VIDEO_DECODE_READ_BIT_KHR: bool = false,
    // Extension: VK_KHR_video_decode_queue
    // bit: 36
    VK_ACCESS_2_VIDEO_DECODE_WRITE_BIT_KHR: bool = false,
    // Extension: VK_KHR_video_encode_queue
    // bit: 37
    VK_ACCESS_2_VIDEO_ENCODE_READ_BIT_KHR: bool = false,
    // Extension: VK_KHR_video_encode_queue
    // bit: 38
    VK_ACCESS_2_VIDEO_ENCODE_WRITE_BIT_KHR: bool = false,
    // Extension: VK_HUAWEI_invocation_mask
    // bit: 39
    VK_ACCESS_2_INVOCATION_MASK_READ_BIT_HUAWEI: bool = false,
    // Extension: VK_KHR_ray_tracing_maintenance1
    // bit: 40
    VK_ACCESS_2_SHADER_BINDING_TABLE_READ_BIT_KHR: bool = false,
    // Extension: VK_EXT_descriptor_buffer
    // bit: 41
    VK_ACCESS_2_DESCRIPTOR_BUFFER_READ_BIT_EXT: bool = false,
    // Extension: VK_NV_optical_flow
    // bit: 42
    VK_ACCESS_2_OPTICAL_FLOW_READ_BIT_NV: bool = false,
    // Extension: VK_NV_optical_flow
    // bit: 43
    VK_ACCESS_2_OPTICAL_FLOW_WRITE_BIT_NV: bool = false,
    // Extension: VK_EXT_opacity_micromap
    // bit: 44
    VK_ACCESS_2_MICROMAP_READ_BIT_EXT: bool = false,
    // Extension: VK_EXT_opacity_micromap
    // bit: 45
    VK_ACCESS_2_MICROMAP_WRITE_BIT_EXT: bool = false,
    _45: u1 = 0,
    // Extension: VK_ARM_data_graph
    // bit: 47
    VK_ACCESS_2_DATA_GRAPH_READ_BIT_ARM: bool = false,
    // Extension: VK_ARM_data_graph
    // bit: 48
    VK_ACCESS_2_DATA_GRAPH_WRITE_BIT_ARM: bool = false,
    _48: u2 = 0,
    // Extension: VK_QCOM_tile_shading
    // bit: 51
    VK_ACCESS_2_SHADER_TILE_ATTACHMENT_READ_BIT_QCOM: bool = false,
    // Extension: VK_QCOM_tile_shading
    // bit: 52
    VK_ACCESS_2_SHADER_TILE_ATTACHMENT_WRITE_BIT_QCOM: bool = false,
    _52: u2 = 0,
    // Extension: VK_EXT_memory_decompression
    // bit: 55
    VK_ACCESS_2_MEMORY_DECOMPRESSION_READ_BIT_EXT: bool = false,
    // Extension: VK_EXT_memory_decompression
    // bit: 56
    VK_ACCESS_2_MEMORY_DECOMPRESSION_WRITE_BIT_EXT: bool = false,
    _: u7 = 0,
    pub const VK_ACCESS_2_NONE: @This() = @bitCast(@as(u64, 0x0));
};
pub const VkPipelineStageFlags2 = packed struct(u64) {
    // bit: 0
    VK_PIPELINE_STAGE_2_TOP_OF_PIPE_BIT: bool = false,
    // bit: 1
    VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT: bool = false,
    // bit: 2
    VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT: bool = false,
    // bit: 3
    VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT: bool = false,
    // bit: 4
    VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT: bool = false,
    // bit: 5
    VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT: bool = false,
    // bit: 6
    VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT: bool = false,
    // bit: 7
    VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT: bool = false,
    // bit: 8
    VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT: bool = false,
    // bit: 9
    VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT: bool = false,
    // bit: 10
    VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT: bool = false,
    // bit: 11
    VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT: bool = false,
    // bit: 12
    VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT: bool = false,
    // bit: 13
    VK_PIPELINE_STAGE_2_BOTTOM_OF_PIPE_BIT: bool = false,
    // bit: 14
    VK_PIPELINE_STAGE_2_HOST_BIT: bool = false,
    // bit: 15
    VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT: bool = false,
    // bit: 16
    VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT: bool = false,
    // Extension: VK_KHR_synchronization2
    // bit: 17
    VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_EXT: bool = false,
    // Extension: VK_KHR_synchronization2
    // bit: 18
    VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT: bool = false,
    // Extension: VK_KHR_synchronization2
    // bit: 19
    VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_EXT: bool = false,
    // Extension: VK_KHR_synchronization2
    // bit: 20
    VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_EXT: bool = false,
    // Extension: VK_KHR_synchronization2
    // bit: 21
    VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR: bool = false,
    // Extension: VK_KHR_synchronization2
    // bit: 22
    VK_PIPELINE_STAGE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR: bool = false,
    // Extension: VK_KHR_synchronization2
    // bit: 23
    VK_PIPELINE_STAGE_2_FRAGMENT_DENSITY_PROCESS_BIT_EXT: bool = false,
    // Extension: VK_KHR_synchronization2
    // bit: 24
    VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT: bool = false,
    // Extension: VK_KHR_synchronization2
    // bit: 25
    VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR: bool = false,
    // Extension: VK_KHR_video_decode_queue
    // bit: 26
    VK_PIPELINE_STAGE_2_VIDEO_DECODE_BIT_KHR: bool = false,
    // Extension: VK_KHR_video_encode_queue
    // bit: 27
    VK_PIPELINE_STAGE_2_VIDEO_ENCODE_BIT_KHR: bool = false,
    // Extension: VK_KHR_ray_tracing_maintenance1
    // bit: 28
    VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_COPY_BIT_KHR: bool = false,
    // Extension: VK_NV_optical_flow
    // bit: 29
    VK_PIPELINE_STAGE_2_OPTICAL_FLOW_BIT_NV: bool = false,
    // Extension: VK_EXT_opacity_micromap
    // bit: 30
    VK_PIPELINE_STAGE_2_MICROMAP_BUILD_BIT_EXT: bool = false,
    _30: u1 = 0,
    // bit: 32
    VK_PIPELINE_STAGE_2_COPY_BIT: bool = false,
    // bit: 33
    VK_PIPELINE_STAGE_2_RESOLVE_BIT: bool = false,
    // bit: 34
    VK_PIPELINE_STAGE_2_BLIT_BIT: bool = false,
    // bit: 35
    VK_PIPELINE_STAGE_2_CLEAR_BIT: bool = false,
    // bit: 36
    VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT: bool = false,
    // bit: 37
    VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT: bool = false,
    // bit: 38
    VK_PIPELINE_STAGE_2_PRE_RASTERIZATION_SHADERS_BIT: bool = false,
    // Extension: VK_HUAWEI_subpass_shading
    // bit: 39
    VK_PIPELINE_STAGE_2_SUBPASS_SHADER_BIT_HUAWEI: bool = false,
    // Extension: VK_HUAWEI_invocation_mask
    // bit: 40
    VK_PIPELINE_STAGE_2_INVOCATION_MASK_BIT_HUAWEI: bool = false,
    // Extension: VK_HUAWEI_cluster_culling_shader
    // bit: 41
    VK_PIPELINE_STAGE_2_CLUSTER_CULLING_SHADER_BIT_HUAWEI: bool = false,
    // Extension: VK_ARM_data_graph
    // bit: 42
    VK_PIPELINE_STAGE_2_DATA_GRAPH_BIT_ARM: bool = false,
    _42: u1 = 0,
    // Extension: VK_NV_cooperative_vector
    // bit: 44
    VK_PIPELINE_STAGE_2_CONVERT_COOPERATIVE_VECTOR_MATRIX_BIT_NV: bool = false,
    // Extension: VK_EXT_memory_decompression
    // bit: 45
    VK_PIPELINE_STAGE_2_MEMORY_DECOMPRESSION_BIT_EXT: bool = false,
    // Extension: VK_KHR_copy_memory_indirect
    // bit: 46
    VK_PIPELINE_STAGE_2_COPY_INDIRECT_BIT_KHR: bool = false,
    _: u17 = 0,
    pub const VK_PIPELINE_STAGE_2_NONE: @This() = @bitCast(@as(u64, 0x0));
};
pub const VkAccelerationStructureMotionInfoFlagsNV = packed struct(u32) {
    _: u32 = 0,
};
pub const VkAccelerationStructureMotionInstanceFlagsNV = packed struct(u32) {
    _: u32 = 0,
};
pub const VkFormatFeatureFlags2 = packed struct(u64) {
    // bit: 0
    VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_BIT: bool = false,
    // bit: 1
    VK_FORMAT_FEATURE_2_STORAGE_IMAGE_BIT: bool = false,
    // bit: 2
    VK_FORMAT_FEATURE_2_STORAGE_IMAGE_ATOMIC_BIT: bool = false,
    // bit: 3
    VK_FORMAT_FEATURE_2_UNIFORM_TEXEL_BUFFER_BIT: bool = false,
    // bit: 4
    VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_BIT: bool = false,
    // bit: 5
    VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_ATOMIC_BIT: bool = false,
    // bit: 6
    VK_FORMAT_FEATURE_2_VERTEX_BUFFER_BIT: bool = false,
    // bit: 7
    VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BIT: bool = false,
    // bit: 8
    VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BLEND_BIT: bool = false,
    // bit: 9
    VK_FORMAT_FEATURE_2_DEPTH_STENCIL_ATTACHMENT_BIT: bool = false,
    // bit: 10
    VK_FORMAT_FEATURE_2_BLIT_SRC_BIT: bool = false,
    // bit: 11
    VK_FORMAT_FEATURE_2_BLIT_DST_BIT: bool = false,
    // bit: 12
    VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_LINEAR_BIT: bool = false,
    // Extension: VK_BASE_VERSION_1_3
    // bit: 13
    VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_CUBIC_BIT: bool = false,
    // bit: 14
    VK_FORMAT_FEATURE_2_TRANSFER_SRC_BIT: bool = false,
    // bit: 15
    VK_FORMAT_FEATURE_2_TRANSFER_DST_BIT: bool = false,
    // bit: 16
    VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_MINMAX_BIT: bool = false,
    // bit: 17
    VK_FORMAT_FEATURE_2_MIDPOINT_CHROMA_SAMPLES_BIT: bool = false,
    // bit: 18
    VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT: bool = false,
    // bit: 19
    VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT: bool = false,
    // bit: 20
    VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT: bool = false,
    // bit: 21
    VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT: bool = false,
    // bit: 22
    VK_FORMAT_FEATURE_2_DISJOINT_BIT: bool = false,
    // bit: 23
    VK_FORMAT_FEATURE_2_COSITED_CHROMA_SAMPLES_BIT: bool = false,
    // Extension: VK_EXT_fragment_density_map
    // bit: 24
    VK_FORMAT_FEATURE_2_FRAGMENT_DENSITY_MAP_BIT_EXT: bool = false,
    // Extension: VK_KHR_video_decode_queue
    // bit: 25
    VK_FORMAT_FEATURE_2_VIDEO_DECODE_OUTPUT_BIT_KHR: bool = false,
    // Extension: VK_KHR_video_decode_queue
    // bit: 26
    VK_FORMAT_FEATURE_2_VIDEO_DECODE_DPB_BIT_KHR: bool = false,
    // Extension: VK_KHR_video_encode_queue
    // bit: 27
    VK_FORMAT_FEATURE_2_VIDEO_ENCODE_INPUT_BIT_KHR: bool = false,
    // Extension: VK_KHR_video_encode_queue
    // bit: 28
    VK_FORMAT_FEATURE_2_VIDEO_ENCODE_DPB_BIT_KHR: bool = false,
    // Extension: VK_KHR_acceleration_structure
    // bit: 29
    VK_FORMAT_FEATURE_2_ACCELERATION_STRUCTURE_VERTEX_BUFFER_BIT_KHR: bool = false,
    // Extension: VK_KHR_fragment_shading_rate
    // bit: 30
    VK_FORMAT_FEATURE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR: bool = false,
    // bit: 31
    VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT: bool = false,
    // bit: 32
    VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT: bool = false,
    // bit: 33
    VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT: bool = false,
    // Extension: VK_QCOM_image_processing
    // bit: 34
    VK_FORMAT_FEATURE_2_WEIGHT_IMAGE_BIT_QCOM: bool = false,
    // Extension: VK_QCOM_image_processing
    // bit: 35
    VK_FORMAT_FEATURE_2_WEIGHT_SAMPLED_IMAGE_BIT_QCOM: bool = false,
    // Extension: VK_QCOM_image_processing
    // bit: 36
    VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM: bool = false,
    // Extension: VK_QCOM_image_processing
    // bit: 37
    VK_FORMAT_FEATURE_2_BOX_FILTER_SAMPLED_BIT_QCOM: bool = false,
    // Extension: VK_NV_linear_color_attachment
    // bit: 38
    VK_FORMAT_FEATURE_2_LINEAR_COLOR_ATTACHMENT_BIT_NV: bool = false,
    // Extension: VK_ARM_tensors
    // bit: 39
    VK_FORMAT_FEATURE_2_TENSOR_SHADER_BIT_ARM: bool = false,
    // Extension: VK_NV_optical_flow
    // bit: 40
    VK_FORMAT_FEATURE_2_OPTICAL_FLOW_IMAGE_BIT_NV: bool = false,
    // Extension: VK_NV_optical_flow
    // bit: 41
    VK_FORMAT_FEATURE_2_OPTICAL_FLOW_VECTOR_BIT_NV: bool = false,
    // Extension: VK_NV_optical_flow
    // bit: 42
    VK_FORMAT_FEATURE_2_OPTICAL_FLOW_COST_BIT_NV: bool = false,
    // Extension: VK_ARM_tensors
    // bit: 43
    VK_FORMAT_FEATURE_2_TENSOR_IMAGE_ALIASING_BIT_ARM: bool = false,
    _43: u2 = 0,
    // Extension: VK_BASE_VERSION_1_4
    // bit: 46
    VK_FORMAT_FEATURE_2_HOST_IMAGE_TRANSFER_BIT: bool = false,
    _46: u1 = 0,
    // Extension: VK_ARM_data_graph
    // bit: 48
    VK_FORMAT_FEATURE_2_TENSOR_DATA_GRAPH_BIT_ARM: bool = false,
    // Extension: VK_KHR_video_encode_quantization_map
    // bit: 49
    VK_FORMAT_FEATURE_2_VIDEO_ENCODE_QUANTIZATION_DELTA_MAP_BIT_KHR: bool = false,
    // Extension: VK_KHR_video_encode_quantization_map
    // bit: 50
    VK_FORMAT_FEATURE_2_VIDEO_ENCODE_EMPHASIS_MAP_BIT_KHR: bool = false,
    // Extension: VK_NV_ray_tracing_linear_swept_spheres
    // bit: 51
    VK_FORMAT_FEATURE_2_ACCELERATION_STRUCTURE_RADIUS_BUFFER_BIT_NV: bool = false,
    // Extension: VK_KHR_maintenance10
    // bit: 52
    VK_FORMAT_FEATURE_2_DEPTH_COPY_ON_COMPUTE_QUEUE_BIT_KHR: bool = false,
    // Extension: VK_KHR_maintenance10
    // bit: 53
    VK_FORMAT_FEATURE_2_DEPTH_COPY_ON_TRANSFER_QUEUE_BIT_KHR: bool = false,
    // Extension: VK_KHR_maintenance10
    // bit: 54
    VK_FORMAT_FEATURE_2_STENCIL_COPY_ON_COMPUTE_QUEUE_BIT_KHR: bool = false,
    // Extension: VK_KHR_maintenance10
    // bit: 55
    VK_FORMAT_FEATURE_2_STENCIL_COPY_ON_TRANSFER_QUEUE_BIT_KHR: bool = false,
    _55: u3 = 0,
    // Extension: VK_KHR_copy_memory_indirect
    // bit: 59
    VK_FORMAT_FEATURE_2_COPY_IMAGE_INDIRECT_DST_BIT_KHR: bool = false,
    _: u4 = 0,
};
pub const VkRenderingFlags = packed struct(u32) {
    // bit: 0
    VK_RENDERING_CONTENTS_SECONDARY_COMMAND_BUFFERS_BIT: bool = false,
    // bit: 1
    VK_RENDERING_SUSPENDING_BIT: bool = false,
    // bit: 2
    VK_RENDERING_RESUMING_BIT: bool = false,
    // Extension: VK_EXT_legacy_dithering
    // bit: 3
    VK_RENDERING_ENABLE_LEGACY_DITHERING_BIT_EXT: bool = false,
    // Extension: VK_KHR_maintenance7
    // bit: 4
    VK_RENDERING_CONTENTS_INLINE_BIT_KHR: bool = false,
    // Extension: VK_VALVE_fragment_density_map_layered
    // bit: 5
    VK_RENDERING_PER_LAYER_FRAGMENT_DENSITY_BIT_VALVE: bool = false,
    // Extension: VK_EXT_custom_resolve
    // bit: 6
    VK_RENDERING_FRAGMENT_REGION_BIT_EXT: bool = false,
    // Extension: VK_EXT_custom_resolve
    // bit: 7
    VK_RENDERING_CUSTOM_RESOLVE_BIT_EXT: bool = false,
    // Extension: VK_KHR_maintenance10
    // bit: 8
    VK_RENDERING_LOCAL_READ_CONCURRENT_ACCESS_CONTROL_BIT_KHR: bool = false,
    _: u23 = 0,
};
pub const VkMemoryDecompressionMethodFlagsEXT = packed struct(u64) {
    // bit: 0
    VK_MEMORY_DECOMPRESSION_METHOD_GDEFLATE_1_0_BIT_EXT: bool = false,
    _: u63 = 0,
};
pub const VkBuildMicromapFlagsEXT = packed struct(u32) {
    // bit: 0
    VK_BUILD_MICROMAP_PREFER_FAST_TRACE_BIT_EXT: bool = false,
    // bit: 1
    VK_BUILD_MICROMAP_PREFER_FAST_BUILD_BIT_EXT: bool = false,
    // bit: 2
    VK_BUILD_MICROMAP_ALLOW_COMPACTION_BIT_EXT: bool = false,
    _: u29 = 0,
};
pub const VkMicromapCreateFlagsEXT = packed struct(u32) {
    // bit: 0
    VK_MICROMAP_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT: bool = false,
    _: u31 = 0,
};
pub const VkIndirectCommandsLayoutUsageFlagsEXT = packed struct(u32) {
    // bit: 0
    VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EXPLICIT_PREPROCESS_BIT_EXT: bool = false,
    // bit: 1
    VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_EXT: bool = false,
    _: u30 = 0,
};
pub const VkIndirectCommandsInputModeFlagsEXT = packed struct(u32) {
    // bit: 0
    VK_INDIRECT_COMMANDS_INPUT_MODE_VULKAN_INDEX_BUFFER_EXT: bool = false,
    // bit: 1
    VK_INDIRECT_COMMANDS_INPUT_MODE_DXGI_INDEX_BUFFER_EXT: bool = false,
    _: u30 = 0,
};
pub const VkDirectDriverLoadingFlagsLUNARG = packed struct(u32) {
    _: u32 = 0,
};
pub const VkPipelineCreateFlags2 = packed struct(u64) {
    // bit: 0
    VK_PIPELINE_CREATE_2_DISABLE_OPTIMIZATION_BIT: bool = false,
    // bit: 1
    VK_PIPELINE_CREATE_2_ALLOW_DERIVATIVES_BIT: bool = false,
    // bit: 2
    VK_PIPELINE_CREATE_2_DERIVATIVE_BIT: bool = false,
    // bit: 3
    VK_PIPELINE_CREATE_2_VIEW_INDEX_FROM_DEVICE_INDEX_BIT: bool = false,
    // bit: 4
    VK_PIPELINE_CREATE_2_DISPATCH_BASE_BIT: bool = false,
    // Extension: VK_KHR_maintenance5
    // bit: 5
    VK_PIPELINE_CREATE_2_DEFER_COMPILE_BIT_NV: bool = false,
    // Extension: VK_KHR_maintenance5
    // bit: 6
    VK_PIPELINE_CREATE_2_CAPTURE_STATISTICS_BIT_KHR: bool = false,
    // Extension: VK_KHR_maintenance5
    // bit: 7
    VK_PIPELINE_CREATE_2_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR: bool = false,
    // bit: 8
    VK_PIPELINE_CREATE_2_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT: bool = false,
    // bit: 9
    VK_PIPELINE_CREATE_2_EARLY_RETURN_ON_FAILURE_BIT: bool = false,
    // Extension: VK_KHR_maintenance5
    // bit: 10
    VK_PIPELINE_CREATE_2_LINK_TIME_OPTIMIZATION_BIT_EXT: bool = false,
    // Extension: VK_KHR_maintenance5
    // bit: 11
    VK_PIPELINE_CREATE_2_LIBRARY_BIT_KHR: bool = false,
    // Extension: VK_KHR_maintenance5
    // bit: 12
    VK_PIPELINE_CREATE_2_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR: bool = false,
    // Extension: VK_KHR_maintenance5
    // bit: 13
    VK_PIPELINE_CREATE_2_RAY_TRACING_SKIP_AABBS_BIT_KHR: bool = false,
    // Extension: VK_KHR_maintenance5
    // bit: 14
    VK_PIPELINE_CREATE_2_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR: bool = false,
    // Extension: VK_KHR_maintenance5
    // bit: 15
    VK_PIPELINE_CREATE_2_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR: bool = false,
    // Extension: VK_KHR_maintenance5
    // bit: 16
    VK_PIPELINE_CREATE_2_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR: bool = false,
    // Extension: VK_KHR_maintenance5
    // bit: 17
    VK_PIPELINE_CREATE_2_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR: bool = false,
    // Extension: VK_KHR_maintenance5
    // bit: 18
    VK_PIPELINE_CREATE_2_INDIRECT_BINDABLE_BIT_NV: bool = false,
    // Extension: VK_KHR_maintenance5
    // bit: 19
    VK_PIPELINE_CREATE_2_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR: bool = false,
    // Extension: VK_KHR_maintenance5
    // bit: 20
    VK_PIPELINE_CREATE_2_RAY_TRACING_ALLOW_MOTION_BIT_NV: bool = false,
    // Extension: VK_KHR_maintenance5
    // bit: 21
    VK_PIPELINE_CREATE_2_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR: bool = false,
    // Extension: VK_KHR_maintenance5
    // bit: 22
    VK_PIPELINE_CREATE_2_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT: bool = false,
    // Extension: VK_KHR_maintenance5
    // bit: 23
    VK_PIPELINE_CREATE_2_RETAIN_LINK_TIME_OPTIMIZATION_INFO_BIT_EXT: bool = false,
    // Extension: VK_KHR_maintenance5
    // bit: 24
    VK_PIPELINE_CREATE_2_RAY_TRACING_OPACITY_MICROMAP_BIT_EXT: bool = false,
    // Extension: VK_KHR_maintenance5
    // bit: 25
    VK_PIPELINE_CREATE_2_COLOR_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT: bool = false,
    // Extension: VK_KHR_maintenance5
    // bit: 26
    VK_PIPELINE_CREATE_2_DEPTH_STENCIL_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT: bool = false,
    // bit: 27
    VK_PIPELINE_CREATE_2_NO_PROTECTED_ACCESS_BIT: bool = false,
    // Extension: VK_KHR_maintenance5
    // bit: 28
    VK_PIPELINE_CREATE_2_RAY_TRACING_DISPLACEMENT_MICROMAP_BIT_NV: bool = false,
    // Extension: VK_KHR_maintenance5
    // bit: 29
    VK_PIPELINE_CREATE_2_DESCRIPTOR_BUFFER_BIT_EXT: bool = false,
    // bit: 30
    VK_PIPELINE_CREATE_2_PROTECTED_ACCESS_ONLY_BIT: bool = false,
    // Extension: VK_KHR_pipeline_binary
    // bit: 31
    VK_PIPELINE_CREATE_2_CAPTURE_DATA_BIT_KHR: bool = false,
    // Extension: VK_AMDX_shader_enqueue
    // bit: 32
    VK_PIPELINE_CREATE_2_EXECUTION_GRAPH_BIT_AMDX: bool = false,
    // Extension: VK_NV_ray_tracing_linear_swept_spheres
    // bit: 33
    VK_PIPELINE_CREATE_2_RAY_TRACING_ALLOW_SPHERES_AND_LINEAR_SWEPT_SPHERES_BIT_NV: bool = false,
    // Extension: VK_EXT_legacy_dithering
    // bit: 34
    VK_PIPELINE_CREATE_2_ENABLE_LEGACY_DITHERING_BIT_EXT: bool = false,
    _34: u2 = 0,
    // Extension: VK_KHR_maintenance5
    // Extension: VK_ARM_pipeline_opacity_micromap
    // bit: 37
    VK_PIPELINE_CREATE_2_DISALLOW_OPACITY_MICROMAP_BIT_ARM: bool = false,
    // Extension: VK_EXT_device_generated_commands
    // bit: 38
    VK_PIPELINE_CREATE_2_INDIRECT_BINDABLE_BIT_EXT: bool = false,
    _38: u1 = 0,
    // Extension: VK_VALVE_fragment_density_map_layered
    // bit: 40
    VK_PIPELINE_CREATE_2_PER_LAYER_FRAGMENT_DENSITY_BIT_VALVE: bool = false,
    _40: u2 = 0,
    // Extension: VK_EXT_shader_64bit_indexing
    // bit: 43
    VK_PIPELINE_CREATE_2_64_BIT_INDEXING_BIT_EXT: bool = false,
    _: u20 = 0,
};
pub const VkBufferUsageFlags2 = packed struct(u64) {
    // bit: 0
    VK_BUFFER_USAGE_2_TRANSFER_SRC_BIT: bool = false,
    // bit: 1
    VK_BUFFER_USAGE_2_TRANSFER_DST_BIT: bool = false,
    // bit: 2
    VK_BUFFER_USAGE_2_UNIFORM_TEXEL_BUFFER_BIT: bool = false,
    // bit: 3
    VK_BUFFER_USAGE_2_STORAGE_TEXEL_BUFFER_BIT: bool = false,
    // bit: 4
    VK_BUFFER_USAGE_2_UNIFORM_BUFFER_BIT: bool = false,
    // bit: 5
    VK_BUFFER_USAGE_2_STORAGE_BUFFER_BIT: bool = false,
    // bit: 6
    VK_BUFFER_USAGE_2_INDEX_BUFFER_BIT: bool = false,
    // bit: 7
    VK_BUFFER_USAGE_2_VERTEX_BUFFER_BIT: bool = false,
    // bit: 8
    VK_BUFFER_USAGE_2_INDIRECT_BUFFER_BIT: bool = false,
    // Extension: VK_KHR_maintenance5
    // bit: 9
    VK_BUFFER_USAGE_2_CONDITIONAL_RENDERING_BIT_EXT: bool = false,
    // Extension: VK_KHR_maintenance5
    // bit: 10
    VK_BUFFER_USAGE_2_SHADER_BINDING_TABLE_BIT_KHR: bool = false,
    // Extension: VK_KHR_maintenance5
    // bit: 11
    VK_BUFFER_USAGE_2_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT: bool = false,
    // Extension: VK_KHR_maintenance5
    // bit: 12
    VK_BUFFER_USAGE_2_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT: bool = false,
    // Extension: VK_KHR_maintenance5
    // bit: 13
    VK_BUFFER_USAGE_2_VIDEO_DECODE_SRC_BIT_KHR: bool = false,
    // Extension: VK_KHR_maintenance5
    // bit: 14
    VK_BUFFER_USAGE_2_VIDEO_DECODE_DST_BIT_KHR: bool = false,
    // Extension: VK_KHR_maintenance5
    // bit: 15
    VK_BUFFER_USAGE_2_VIDEO_ENCODE_DST_BIT_KHR: bool = false,
    // Extension: VK_KHR_maintenance5
    // bit: 16
    VK_BUFFER_USAGE_2_VIDEO_ENCODE_SRC_BIT_KHR: bool = false,
    // Extension: VK_BASE_VERSION_1_4
    // bit: 17
    VK_BUFFER_USAGE_2_SHADER_DEVICE_ADDRESS_BIT: bool = false,
    _17: u1 = 0,
    // Extension: VK_KHR_maintenance5
    // bit: 19
    VK_BUFFER_USAGE_2_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR: bool = false,
    // Extension: VK_KHR_maintenance5
    // bit: 20
    VK_BUFFER_USAGE_2_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR: bool = false,
    // Extension: VK_KHR_maintenance5
    // bit: 21
    VK_BUFFER_USAGE_2_SAMPLER_DESCRIPTOR_BUFFER_BIT_EXT: bool = false,
    // Extension: VK_KHR_maintenance5
    // bit: 22
    VK_BUFFER_USAGE_2_RESOURCE_DESCRIPTOR_BUFFER_BIT_EXT: bool = false,
    // Extension: VK_KHR_maintenance5
    // bit: 23
    VK_BUFFER_USAGE_2_MICROMAP_BUILD_INPUT_READ_ONLY_BIT_EXT: bool = false,
    // Extension: VK_KHR_maintenance5
    // bit: 24
    VK_BUFFER_USAGE_2_MICROMAP_STORAGE_BIT_EXT: bool = false,
    // Extension: VK_AMDX_shader_enqueue
    // bit: 25
    VK_BUFFER_USAGE_2_EXECUTION_GRAPH_SCRATCH_BIT_AMDX: bool = false,
    // Extension: VK_KHR_maintenance5
    // bit: 26
    VK_BUFFER_USAGE_2_PUSH_DESCRIPTORS_DESCRIPTOR_BUFFER_BIT_EXT: bool = false,
    // Extension: VK_QCOM_tile_memory_heap
    // bit: 27
    VK_BUFFER_USAGE_2_TILE_MEMORY_BIT_QCOM: bool = false,
    _27: u1 = 0,
    // Extension: VK_ARM_data_graph
    // bit: 29
    VK_BUFFER_USAGE_2_DATA_GRAPH_FOREIGN_DESCRIPTOR_BIT_ARM: bool = false,
    _29: u1 = 0,
    // Extension: VK_EXT_device_generated_commands
    // bit: 31
    VK_BUFFER_USAGE_2_PREPROCESS_BUFFER_BIT_EXT: bool = false,
    // Extension: VK_EXT_memory_decompression
    // bit: 32
    VK_BUFFER_USAGE_2_MEMORY_DECOMPRESSION_BIT_EXT: bool = false,
    // Extension: VK_AMDX_dense_geometry_format
    // bit: 33
    VK_BUFFER_USAGE_2_COMPRESSED_DATA_DGF1_BIT_AMDX: bool = false,
    _: u30 = 0,
};
pub const VkAddressCopyFlagsKHR = packed struct(u32) {
    // bit: 0
    VK_ADDRESS_COPY_DEVICE_LOCAL_BIT_KHR: bool = false,
    // bit: 1
    VK_ADDRESS_COPY_SPARSE_BIT_KHR: bool = false,
    // bit: 2
    VK_ADDRESS_COPY_PROTECTED_BIT_KHR: bool = false,
    _: u29 = 0,
};
pub const VkTensorCreateFlagsARM = packed struct(u64) {
    // bit: 0
    VK_TENSOR_CREATE_MUTABLE_FORMAT_BIT_ARM: bool = false,
    // bit: 1
    VK_TENSOR_CREATE_PROTECTED_BIT_ARM: bool = false,
    // Extension: VK_ARM_tensors
    // bit: 2
    VK_TENSOR_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_ARM: bool = false,
    _: u61 = 0,
};
pub const VkTensorUsageFlagsARM = packed struct(u64) {
    _0: u1 = 0,
    // Comment: Tensor written/read through shader descriptor
    // bit: 1
    VK_TENSOR_USAGE_SHADER_BIT_ARM: bool = false,
    // Comment: Tensor can be src of a transfer operation
    // bit: 2
    VK_TENSOR_USAGE_TRANSFER_SRC_BIT_ARM: bool = false,
    // Comment: Tensor can be dst of a transfer operation
    // bit: 3
    VK_TENSOR_USAGE_TRANSFER_DST_BIT_ARM: bool = false,
    // Comment: Tensor can be aliased with an image
    // bit: 4
    VK_TENSOR_USAGE_IMAGE_ALIASING_BIT_ARM: bool = false,
    // Extension: VK_ARM_data_graph
    // bit: 5
    VK_TENSOR_USAGE_DATA_GRAPH_BIT_ARM: bool = false,
    _: u58 = 0,
};
pub const VkTensorViewCreateFlagsARM = packed struct(u64) {
    // Extension: VK_ARM_tensors
    // bit: 0
    VK_TENSOR_VIEW_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_ARM: bool = false,
    _: u63 = 0,
};
pub const VkDataGraphPipelineSessionCreateFlagsARM = packed struct(u64) {
    // bit: 0
    VK_DATA_GRAPH_PIPELINE_SESSION_CREATE_PROTECTED_BIT_ARM: bool = false,
    _: u63 = 0,
};
pub const VkDataGraphPipelineDispatchFlagsARM = packed struct(u64) {
    _: u64 = 0,
};
pub const VkVideoEncodeRgbModelConversionFlagsVALVE = packed struct(u32) {
    // bit: 0
    VK_VIDEO_ENCODE_RGB_MODEL_CONVERSION_RGB_IDENTITY_BIT_VALVE: bool = false,
    // bit: 1
    VK_VIDEO_ENCODE_RGB_MODEL_CONVERSION_YCBCR_IDENTITY_BIT_VALVE: bool = false,
    // bit: 2
    VK_VIDEO_ENCODE_RGB_MODEL_CONVERSION_YCBCR_709_BIT_VALVE: bool = false,
    // bit: 3
    VK_VIDEO_ENCODE_RGB_MODEL_CONVERSION_YCBCR_601_BIT_VALVE: bool = false,
    // bit: 4
    VK_VIDEO_ENCODE_RGB_MODEL_CONVERSION_YCBCR_2020_BIT_VALVE: bool = false,
    _: u27 = 0,
};
pub const VkVideoEncodeRgbRangeCompressionFlagsVALVE = packed struct(u32) {
    // bit: 0
    VK_VIDEO_ENCODE_RGB_RANGE_COMPRESSION_FULL_RANGE_BIT_VALVE: bool = false,
    // bit: 1
    VK_VIDEO_ENCODE_RGB_RANGE_COMPRESSION_NARROW_RANGE_BIT_VALVE: bool = false,
    _: u30 = 0,
};
pub const VkVideoEncodeRgbChromaOffsetFlagsVALVE = packed struct(u32) {
    // bit: 0
    VK_VIDEO_ENCODE_RGB_CHROMA_OFFSET_COSITED_EVEN_BIT_VALVE: bool = false,
    // bit: 1
    VK_VIDEO_ENCODE_RGB_CHROMA_OFFSET_MIDPOINT_BIT_VALVE: bool = false,
    _: u30 = 0,
};
pub const VkCompositeAlphaFlagsKHR = packed struct(u32) {
    // bit: 0
    VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR: bool = false,
    // bit: 1
    VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR: bool = false,
    // bit: 2
    VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR: bool = false,
    // bit: 3
    VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR: bool = false,
    _: u28 = 0,
};
pub const VkDisplayPlaneAlphaFlagsKHR = packed struct(u32) {
    // bit: 0
    VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR: bool = false,
    // bit: 1
    VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR: bool = false,
    // bit: 2
    VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR: bool = false,
    // bit: 3
    VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR: bool = false,
    _: u28 = 0,
};
pub const VkSurfaceTransformFlagsKHR = packed struct(u32) {
    // bit: 0
    VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR: bool = false,
    // bit: 1
    VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR: bool = false,
    // bit: 2
    VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR: bool = false,
    // bit: 3
    VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR: bool = false,
    // bit: 4
    VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR: bool = false,
    // bit: 5
    VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR: bool = false,
    // bit: 6
    VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR: bool = false,
    // bit: 7
    VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR: bool = false,
    // bit: 8
    VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR: bool = false,
    _: u23 = 0,
};
pub const VkSwapchainCreateFlagsKHR = packed struct(u32) {
    // Extension: VK_KHR_swapchain
    // Extension: VK_KHR_device_group
    // bit: 0
    VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR: bool = false,
    // Extension: VK_KHR_swapchain
    // bit: 1
    VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR: bool = false,
    // Extension: VK_KHR_swapchain_mutable_format
    // bit: 2
    VK_SWAPCHAIN_CREATE_MUTABLE_FORMAT_BIT_KHR: bool = false,
    // Extension: VK_KHR_swapchain_maintenance1
    // bit: 3
    VK_SWAPCHAIN_CREATE_DEFERRED_MEMORY_ALLOCATION_BIT_KHR: bool = false,
    _3: u2 = 0,
    // Extension: VK_KHR_present_id2
    // bit: 6
    VK_SWAPCHAIN_CREATE_PRESENT_ID_2_BIT_KHR: bool = false,
    // Extension: VK_KHR_present_wait2
    // bit: 7
    VK_SWAPCHAIN_CREATE_PRESENT_WAIT_2_BIT_KHR: bool = false,
    _7: u1 = 0,
    // Extension: VK_EXT_present_timing
    // bit: 9
    VK_SWAPCHAIN_CREATE_PRESENT_TIMING_BIT_EXT: bool = false,
    _: u22 = 0,
};
pub const VkDisplayModeCreateFlagsKHR = packed struct(u32) {
    _: u32 = 0,
};
pub const VkDisplaySurfaceCreateFlagsKHR = packed struct(u32) {
    _: u32 = 0,
};
pub const VkAndroidSurfaceCreateFlagsKHR = packed struct(u32) {
    _: u32 = 0,
};
pub const VkViSurfaceCreateFlagsNN = packed struct(u32) {
    _: u32 = 0,
};
pub const VkWaylandSurfaceCreateFlagsKHR = packed struct(u32) {
    _: u32 = 0,
};
pub const VkWin32SurfaceCreateFlagsKHR = packed struct(u32) {
    _: u32 = 0,
};
pub const VkXlibSurfaceCreateFlagsKHR = packed struct(u32) {
    _: u32 = 0,
};
pub const VkXcbSurfaceCreateFlagsKHR = packed struct(u32) {
    _: u32 = 0,
};
pub const VkDirectFBSurfaceCreateFlagsEXT = packed struct(u32) {
    _: u32 = 0,
};
pub const VkIOSSurfaceCreateFlagsMVK = packed struct(u32) {
    _: u32 = 0,
};
pub const VkMacOSSurfaceCreateFlagsMVK = packed struct(u32) {
    _: u32 = 0,
};
pub const VkMetalSurfaceCreateFlagsEXT = packed struct(u32) {
    _: u32 = 0,
};
pub const VkImagePipeSurfaceCreateFlagsFUCHSIA = packed struct(u32) {
    _: u32 = 0,
};
pub const VkStreamDescriptorSurfaceCreateFlagsGGP = packed struct(u32) {
    _: u32 = 0,
};
pub const VkHeadlessSurfaceCreateFlagsEXT = packed struct(u32) {
    _: u32 = 0,
};
pub const VkScreenSurfaceCreateFlagsQNX = packed struct(u32) {
    _: u32 = 0,
};
pub const VkPeerMemoryFeatureFlags = packed struct(u32) {
    // Comment: Can read with vkCmdCopy commands
    // bit: 0
    VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT: bool = false,
    // Comment: Can write with vkCmdCopy commands
    // bit: 1
    VK_PEER_MEMORY_FEATURE_COPY_DST_BIT: bool = false,
    // Comment: Can read with any access type/command
    // bit: 2
    VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT: bool = false,
    // Comment: Can write with and access type/command
    // bit: 3
    VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT: bool = false,
    _: u28 = 0,
};
pub const VkMemoryAllocateFlags = packed struct(u32) {
    // Comment: Force allocation on specific devices
    // bit: 0
    VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT: bool = false,
    // Extension: VK_BASE_VERSION_1_2
    // bit: 1
    VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT: bool = false,
    // Extension: VK_BASE_VERSION_1_2
    // bit: 2
    VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT: bool = false,
    // Extension: VK_EXT_zero_initialize_device_memory
    // bit: 3
    VK_MEMORY_ALLOCATE_ZERO_INITIALIZE_BIT_EXT: bool = false,
    _: u28 = 0,
};
pub const VkDeviceGroupPresentModeFlagsKHR = packed struct(u32) {
    // Comment: Present from local memory
    // bit: 0
    VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR: bool = false,
    // Comment: Present from remote memory
    // bit: 1
    VK_DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHR: bool = false,
    // Comment: Present sum of local and/or remote memory
    // bit: 2
    VK_DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHR: bool = false,
    // Comment: Each physical device presents from local memory
    // bit: 3
    VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHR: bool = false,
    _: u28 = 0,
};
pub const VkDebugReportFlagsEXT = packed struct(u32) {
    // bit: 0
    VK_DEBUG_REPORT_INFORMATION_BIT_EXT: bool = false,
    // bit: 1
    VK_DEBUG_REPORT_WARNING_BIT_EXT: bool = false,
    // bit: 2
    VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT: bool = false,
    // bit: 3
    VK_DEBUG_REPORT_ERROR_BIT_EXT: bool = false,
    // bit: 4
    VK_DEBUG_REPORT_DEBUG_BIT_EXT: bool = false,
    _: u27 = 0,
};
pub const VkCommandPoolTrimFlags = packed struct(u32) {
    _: u32 = 0,
};
pub const VkExternalMemoryHandleTypeFlagsNV = packed struct(u32) {
    // bit: 0
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV: bool = false,
    // bit: 1
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_NV: bool = false,
    // bit: 2
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_BIT_NV: bool = false,
    // bit: 3
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_KMT_BIT_NV: bool = false,
    _: u28 = 0,
};
pub const VkClusterAccelerationStructureIndexFormatFlagsNV = packed struct(u32) {
    // bit: 0
    VK_CLUSTER_ACCELERATION_STRUCTURE_INDEX_FORMAT_8BIT_NV: bool = false,
    // bit: 1
    VK_CLUSTER_ACCELERATION_STRUCTURE_INDEX_FORMAT_16BIT_NV: bool = false,
    // bit: 2
    VK_CLUSTER_ACCELERATION_STRUCTURE_INDEX_FORMAT_32BIT_NV: bool = false,
    _: u29 = 0,
};
pub const VkExternalMemoryFeatureFlagsNV = packed struct(u32) {
    // bit: 0
    VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV: bool = false,
    // bit: 1
    VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_NV: bool = false,
    // bit: 2
    VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_NV: bool = false,
    _: u29 = 0,
};
pub const VkExternalMemoryHandleTypeFlags = packed struct(u32) {
    // bit: 0
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT: bool = false,
    // bit: 1
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT: bool = false,
    // bit: 2
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT: bool = false,
    // bit: 3
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT: bool = false,
    // bit: 4
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT: bool = false,
    // bit: 5
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT: bool = false,
    // bit: 6
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT: bool = false,
    // Extension: VK_EXT_external_memory_host
    // bit: 7
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT: bool = false,
    // Extension: VK_EXT_external_memory_host
    // bit: 8
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT: bool = false,
    // Extension: VK_EXT_external_memory_dma_buf
    // bit: 9
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT: bool = false,
    // Extension: VK_ANDROID_external_memory_android_hardware_buffer
    // bit: 10
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID: bool = false,
    // Extension: VK_FUCHSIA_external_memory
    // bit: 11
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_ZIRCON_VMO_BIT_FUCHSIA: bool = false,
    // Extension: VK_NV_external_memory_rdma
    // bit: 12
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_RDMA_ADDRESS_BIT_NV: bool = false,
    // Extension: VK_NV_external_memory_sci_buf
    // bit: 13
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_SCI_BUF_BIT_NV: bool = false,
    // Extension: VK_QNX_external_memory_screen_buffer
    // bit: 14
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_SCREEN_BUFFER_BIT_QNX: bool = false,
    // Extension: VK_OHOS_external_memory
    // bit: 15
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_OH_NATIVE_BUFFER_BIT_OHOS: bool = false,
    // Extension: VK_EXT_external_memory_metal
    // bit: 16
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLBUFFER_BIT_EXT: bool = false,
    // Extension: VK_EXT_external_memory_metal
    // bit: 17
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLTEXTURE_BIT_EXT: bool = false,
    // Extension: VK_EXT_external_memory_metal
    // bit: 18
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLHEAP_BIT_EXT: bool = false,
    _: u13 = 0,
};
pub const VkExternalMemoryFeatureFlags = packed struct(u32) {
    // bit: 0
    VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT: bool = false,
    // bit: 1
    VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT: bool = false,
    // bit: 2
    VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT: bool = false,
    _: u29 = 0,
};
pub const VkExternalSemaphoreHandleTypeFlags = packed struct(u32) {
    // bit: 0
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT: bool = false,
    // bit: 1
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT: bool = false,
    // bit: 2
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT: bool = false,
    // bit: 3
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT: bool = false,
    // bit: 4
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT: bool = false,
    // Extension: VK_NV_external_sci_sync
    // bit: 5
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SCI_SYNC_OBJ_BIT_NV: bool = false,
    _5: u1 = 0,
    // Extension: VK_FUCHSIA_external_semaphore
    // bit: 7
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_ZIRCON_EVENT_BIT_FUCHSIA: bool = false,
    _: u24 = 0,
};
pub const VkExternalSemaphoreFeatureFlags = packed struct(u32) {
    // bit: 0
    VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT: bool = false,
    // bit: 1
    VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT: bool = false,
    _: u30 = 0,
};
pub const VkSemaphoreImportFlags = packed struct(u32) {
    // bit: 0
    VK_SEMAPHORE_IMPORT_TEMPORARY_BIT: bool = false,
    _: u31 = 0,
};
pub const VkExternalFenceHandleTypeFlags = packed struct(u32) {
    // bit: 0
    VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT: bool = false,
    // bit: 1
    VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT: bool = false,
    // bit: 2
    VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT: bool = false,
    // bit: 3
    VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT: bool = false,
    // Extension: VK_NV_external_sci_sync
    // Extension: VK_NV_external_sci_sync2
    // bit: 4
    VK_EXTERNAL_FENCE_HANDLE_TYPE_SCI_SYNC_OBJ_BIT_NV: bool = false,
    // Extension: VK_NV_external_sci_sync
    // Extension: VK_NV_external_sci_sync2
    // bit: 5
    VK_EXTERNAL_FENCE_HANDLE_TYPE_SCI_SYNC_FENCE_BIT_NV: bool = false,
    _: u26 = 0,
};
pub const VkExternalFenceFeatureFlags = packed struct(u32) {
    // bit: 0
    VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT: bool = false,
    // bit: 1
    VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT: bool = false,
    _: u30 = 0,
};
pub const VkFenceImportFlags = packed struct(u32) {
    // bit: 0
    VK_FENCE_IMPORT_TEMPORARY_BIT: bool = false,
    _: u31 = 0,
};
pub const VkSurfaceCounterFlagsEXT = packed struct(u32) {
    // bit: 0
    VK_SURFACE_COUNTER_VBLANK_BIT_EXT: bool = false,
    _: u31 = 0,
};
pub const VkPipelineViewportSwizzleStateCreateFlagsNV = packed struct(u32) {
    _: u32 = 0,
};
pub const VkPipelineDiscardRectangleStateCreateFlagsEXT = packed struct(u32) {
    _: u32 = 0,
};
pub const VkPipelineCoverageToColorStateCreateFlagsNV = packed struct(u32) {
    _: u32 = 0,
};
pub const VkPipelineCoverageModulationStateCreateFlagsNV = packed struct(u32) {
    _: u32 = 0,
};
pub const VkPipelineCoverageReductionStateCreateFlagsNV = packed struct(u32) {
    _: u32 = 0,
};
pub const VkValidationCacheCreateFlagsEXT = packed struct(u32) {
    _: u32 = 0,
};
pub const VkDebugUtilsMessageSeverityFlagsEXT = packed struct(u32) {
    // bit: 0
    VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT: bool = false,
    _0: u3 = 0,
    // bit: 4
    VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT: bool = false,
    _4: u3 = 0,
    // bit: 8
    VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT: bool = false,
    _8: u3 = 0,
    // bit: 12
    VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT: bool = false,
    _: u19 = 0,
};
pub const VkDebugUtilsMessageTypeFlagsEXT = packed struct(u32) {
    // bit: 0
    VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT: bool = false,
    // bit: 1
    VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT: bool = false,
    // bit: 2
    VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT: bool = false,
    // Extension: VK_EXT_device_address_binding_report
    // bit: 3
    VK_DEBUG_UTILS_MESSAGE_TYPE_DEVICE_ADDRESS_BINDING_BIT_EXT: bool = false,
    _: u28 = 0,
};
pub const VkDebugUtilsMessengerCreateFlagsEXT = packed struct(u32) {
    _: u32 = 0,
};
pub const VkDebugUtilsMessengerCallbackDataFlagsEXT = packed struct(u32) {
    _: u32 = 0,
};
pub const VkDeviceMemoryReportFlagsEXT = packed struct(u32) {
    _: u32 = 0,
};
pub const VkPipelineRasterizationConservativeStateCreateFlagsEXT = packed struct(u32) {
    _: u32 = 0,
};
pub const VkDescriptorBindingFlags = packed struct(u32) {
    // bit: 0
    VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT: bool = false,
    // bit: 1
    VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT: bool = false,
    // bit: 2
    VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT: bool = false,
    // bit: 3
    VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT: bool = false,
    _: u28 = 0,
};
pub const VkConditionalRenderingFlagsEXT = packed struct(u32) {
    // bit: 0
    VK_CONDITIONAL_RENDERING_INVERTED_BIT_EXT: bool = false,
    _: u31 = 0,
};
pub const VkResolveModeFlags = packed struct(u32) {
    // bit: 0
    VK_RESOLVE_MODE_SAMPLE_ZERO_BIT: bool = false,
    // bit: 1
    VK_RESOLVE_MODE_AVERAGE_BIT: bool = false,
    // bit: 2
    VK_RESOLVE_MODE_MIN_BIT: bool = false,
    // bit: 3
    VK_RESOLVE_MODE_MAX_BIT: bool = false,
    // Extension: VK_ANDROID_external_format_resolve
    // bit: 4
    VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_BIT_ANDROID: bool = false,
    // Extension: VK_EXT_custom_resolve
    // bit: 5
    VK_RESOLVE_MODE_CUSTOM_BIT_EXT: bool = false,
    _: u26 = 0,
    pub const VK_RESOLVE_MODE_NONE: @This() = @bitCast(@as(u32, 0x0));
};
pub const VkPipelineRasterizationStateStreamCreateFlagsEXT = packed struct(u32) {
    _: u32 = 0,
};
pub const VkPipelineRasterizationDepthClipStateCreateFlagsEXT = packed struct(u32) {
    _: u32 = 0,
};
pub const VkSwapchainImageUsageFlagsANDROID = packed struct(u32) {
    // bit: 0
    VK_SWAPCHAIN_IMAGE_USAGE_SHARED_BIT_ANDROID: bool = false,
    _: u31 = 0,
};
pub const VkToolPurposeFlags = packed struct(u32) {
    // bit: 0
    VK_TOOL_PURPOSE_VALIDATION_BIT: bool = false,
    // bit: 1
    VK_TOOL_PURPOSE_PROFILING_BIT: bool = false,
    // bit: 2
    VK_TOOL_PURPOSE_TRACING_BIT: bool = false,
    // bit: 3
    VK_TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT: bool = false,
    // bit: 4
    VK_TOOL_PURPOSE_MODIFYING_FEATURES_BIT: bool = false,
    // Extension: VK_EXT_tooling_info
    // Extension: VK_EXT_tooling_info
    // bit: 5
    VK_TOOL_PURPOSE_DEBUG_REPORTING_BIT_EXT: bool = false,
    // Extension: VK_EXT_tooling_info
    // Extension: VK_EXT_tooling_info
    // bit: 6
    VK_TOOL_PURPOSE_DEBUG_MARKERS_BIT_EXT: bool = false,
    _: u25 = 0,
};
pub const VkSubmitFlags = packed struct(u32) {
    // bit: 0
    VK_SUBMIT_PROTECTED_BIT: bool = false,
    _: u31 = 0,
};
pub const VkImageFormatConstraintsFlagsFUCHSIA = packed struct(u32) {
    _: u32 = 0,
};
pub const VkHostImageCopyFlags = packed struct(u32) {
    // bit: 0
    VK_HOST_IMAGE_COPY_MEMCPY_BIT: bool = false,
    _: u31 = 0,
};
pub const VkPartitionedAccelerationStructureInstanceFlagsNV = packed struct(u32) {
    // bit: 0
    VK_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCE_FLAG_TRIANGLE_FACING_CULL_DISABLE_BIT_NV: bool = false,
    // bit: 1
    VK_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCE_FLAG_TRIANGLE_FLIP_FACING_BIT_NV: bool = false,
    // bit: 2
    VK_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCE_FLAG_FORCE_OPAQUE_BIT_NV: bool = false,
    // bit: 3
    VK_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCE_FLAG_FORCE_NO_OPAQUE_BIT_NV: bool = false,
    // bit: 4
    VK_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCE_FLAG_ENABLE_EXPLICIT_BOUNDING_BOX_NV: bool = false,
    _: u27 = 0,
};
pub const VkImageConstraintsInfoFlagsFUCHSIA = packed struct(u32) {
    // bit: 0
    VK_IMAGE_CONSTRAINTS_INFO_CPU_READ_RARELY_FUCHSIA: bool = false,
    // bit: 1
    VK_IMAGE_CONSTRAINTS_INFO_CPU_READ_OFTEN_FUCHSIA: bool = false,
    // bit: 2
    VK_IMAGE_CONSTRAINTS_INFO_CPU_WRITE_RARELY_FUCHSIA: bool = false,
    // bit: 3
    VK_IMAGE_CONSTRAINTS_INFO_CPU_WRITE_OFTEN_FUCHSIA: bool = false,
    // bit: 4
    VK_IMAGE_CONSTRAINTS_INFO_PROTECTED_OPTIONAL_FUCHSIA: bool = false,
    _: u27 = 0,
};
pub const VkGraphicsPipelineLibraryFlagsEXT = packed struct(u32) {
    // bit: 0
    VK_GRAPHICS_PIPELINE_LIBRARY_VERTEX_INPUT_INTERFACE_BIT_EXT: bool = false,
    // bit: 1
    VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT: bool = false,
    // bit: 2
    VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT: bool = false,
    // bit: 3
    VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_OUTPUT_INTERFACE_BIT_EXT: bool = false,
    _: u28 = 0,
};
pub const VkImageCompressionFlagsEXT = packed struct(u32) {
    // bit: 0
    VK_IMAGE_COMPRESSION_FIXED_RATE_DEFAULT_EXT: bool = false,
    // bit: 1
    VK_IMAGE_COMPRESSION_FIXED_RATE_EXPLICIT_EXT: bool = false,
    // bit: 2
    VK_IMAGE_COMPRESSION_DISABLED_EXT: bool = false,
    _: u29 = 0,
    pub const VK_IMAGE_COMPRESSION_DEFAULT_EXT: @This() = @bitCast(@as(u32, 0x0));
};
pub const VkImageCompressionFixedRateFlagsEXT = packed struct(u32) {
    // bit: 0
    VK_IMAGE_COMPRESSION_FIXED_RATE_1BPC_BIT_EXT: bool = false,
    // bit: 1
    VK_IMAGE_COMPRESSION_FIXED_RATE_2BPC_BIT_EXT: bool = false,
    // bit: 2
    VK_IMAGE_COMPRESSION_FIXED_RATE_3BPC_BIT_EXT: bool = false,
    // bit: 3
    VK_IMAGE_COMPRESSION_FIXED_RATE_4BPC_BIT_EXT: bool = false,
    // bit: 4
    VK_IMAGE_COMPRESSION_FIXED_RATE_5BPC_BIT_EXT: bool = false,
    // bit: 5
    VK_IMAGE_COMPRESSION_FIXED_RATE_6BPC_BIT_EXT: bool = false,
    // bit: 6
    VK_IMAGE_COMPRESSION_FIXED_RATE_7BPC_BIT_EXT: bool = false,
    // bit: 7
    VK_IMAGE_COMPRESSION_FIXED_RATE_8BPC_BIT_EXT: bool = false,
    // bit: 8
    VK_IMAGE_COMPRESSION_FIXED_RATE_9BPC_BIT_EXT: bool = false,
    // bit: 9
    VK_IMAGE_COMPRESSION_FIXED_RATE_10BPC_BIT_EXT: bool = false,
    // bit: 10
    VK_IMAGE_COMPRESSION_FIXED_RATE_11BPC_BIT_EXT: bool = false,
    // bit: 11
    VK_IMAGE_COMPRESSION_FIXED_RATE_12BPC_BIT_EXT: bool = false,
    // bit: 12
    VK_IMAGE_COMPRESSION_FIXED_RATE_13BPC_BIT_EXT: bool = false,
    // bit: 13
    VK_IMAGE_COMPRESSION_FIXED_RATE_14BPC_BIT_EXT: bool = false,
    // bit: 14
    VK_IMAGE_COMPRESSION_FIXED_RATE_15BPC_BIT_EXT: bool = false,
    // bit: 15
    VK_IMAGE_COMPRESSION_FIXED_RATE_16BPC_BIT_EXT: bool = false,
    // bit: 16
    VK_IMAGE_COMPRESSION_FIXED_RATE_17BPC_BIT_EXT: bool = false,
    // bit: 17
    VK_IMAGE_COMPRESSION_FIXED_RATE_18BPC_BIT_EXT: bool = false,
    // bit: 18
    VK_IMAGE_COMPRESSION_FIXED_RATE_19BPC_BIT_EXT: bool = false,
    // bit: 19
    VK_IMAGE_COMPRESSION_FIXED_RATE_20BPC_BIT_EXT: bool = false,
    // bit: 20
    VK_IMAGE_COMPRESSION_FIXED_RATE_21BPC_BIT_EXT: bool = false,
    // bit: 21
    VK_IMAGE_COMPRESSION_FIXED_RATE_22BPC_BIT_EXT: bool = false,
    // bit: 22
    VK_IMAGE_COMPRESSION_FIXED_RATE_23BPC_BIT_EXT: bool = false,
    // bit: 23
    VK_IMAGE_COMPRESSION_FIXED_RATE_24BPC_BIT_EXT: bool = false,
    _: u8 = 0,
    pub const VK_IMAGE_COMPRESSION_FIXED_RATE_NONE_EXT: @This() = @bitCast(@as(u32, 0x0));
};
pub const VkExportMetalObjectTypeFlagsEXT = packed struct(u32) {
    // bit: 0
    VK_EXPORT_METAL_OBJECT_TYPE_METAL_DEVICE_BIT_EXT: bool = false,
    // bit: 1
    VK_EXPORT_METAL_OBJECT_TYPE_METAL_COMMAND_QUEUE_BIT_EXT: bool = false,
    // bit: 2
    VK_EXPORT_METAL_OBJECT_TYPE_METAL_BUFFER_BIT_EXT: bool = false,
    // bit: 3
    VK_EXPORT_METAL_OBJECT_TYPE_METAL_TEXTURE_BIT_EXT: bool = false,
    // bit: 4
    VK_EXPORT_METAL_OBJECT_TYPE_METAL_IOSURFACE_BIT_EXT: bool = false,
    // bit: 5
    VK_EXPORT_METAL_OBJECT_TYPE_METAL_SHARED_EVENT_BIT_EXT: bool = false,
    _: u26 = 0,
};
pub const VkRenderingAttachmentFlagsKHR = packed struct(u32) {
    // Extension: VK_KHR_maintenance10
    // bit: 0
    VK_RENDERING_ATTACHMENT_INPUT_ATTACHMENT_FEEDBACK_BIT_KHR: bool = false,
    // Extension: VK_KHR_maintenance10
    // bit: 1
    VK_RENDERING_ATTACHMENT_RESOLVE_SKIP_TRANSFER_FUNCTION_BIT_KHR: bool = false,
    // Extension: VK_KHR_maintenance10
    // bit: 2
    VK_RENDERING_ATTACHMENT_RESOLVE_ENABLE_TRANSFER_FUNCTION_BIT_KHR: bool = false,
    _: u29 = 0,
};
pub const VkResolveImageFlagsKHR = packed struct(u32) {
    // Extension: VK_KHR_maintenance10
    // bit: 0
    VK_RESOLVE_IMAGE_SKIP_TRANSFER_FUNCTION_BIT_KHR: bool = false,
    // Extension: VK_KHR_maintenance10
    // bit: 1
    VK_RESOLVE_IMAGE_ENABLE_TRANSFER_FUNCTION_BIT_KHR: bool = false,
    _: u30 = 0,
};
pub const VkDeviceAddressBindingFlagsEXT = packed struct(u32) {
    // bit: 0
    VK_DEVICE_ADDRESS_BINDING_INTERNAL_OBJECT_BIT_EXT: bool = false,
    _: u31 = 0,
};
pub const VkOpticalFlowGridSizeFlagsNV = packed struct(u32) {
    // bit: 0
    VK_OPTICAL_FLOW_GRID_SIZE_1X1_BIT_NV: bool = false,
    // bit: 1
    VK_OPTICAL_FLOW_GRID_SIZE_2X2_BIT_NV: bool = false,
    // bit: 2
    VK_OPTICAL_FLOW_GRID_SIZE_4X4_BIT_NV: bool = false,
    // bit: 3
    VK_OPTICAL_FLOW_GRID_SIZE_8X8_BIT_NV: bool = false,
    _: u28 = 0,
    pub const VK_OPTICAL_FLOW_GRID_SIZE_UNKNOWN_NV: @This() = @bitCast(@as(u32, 0x0));
};
pub const VkOpticalFlowUsageFlagsNV = packed struct(u32) {
    // bit: 0
    VK_OPTICAL_FLOW_USAGE_INPUT_BIT_NV: bool = false,
    // bit: 1
    VK_OPTICAL_FLOW_USAGE_OUTPUT_BIT_NV: bool = false,
    // bit: 2
    VK_OPTICAL_FLOW_USAGE_HINT_BIT_NV: bool = false,
    // bit: 3
    VK_OPTICAL_FLOW_USAGE_COST_BIT_NV: bool = false,
    // bit: 4
    VK_OPTICAL_FLOW_USAGE_GLOBAL_FLOW_BIT_NV: bool = false,
    _: u27 = 0,
    pub const VK_OPTICAL_FLOW_USAGE_UNKNOWN_NV: @This() = @bitCast(@as(u32, 0x0));
};
pub const VkOpticalFlowSessionCreateFlagsNV = packed struct(u32) {
    // bit: 0
    VK_OPTICAL_FLOW_SESSION_CREATE_ENABLE_HINT_BIT_NV: bool = false,
    // bit: 1
    VK_OPTICAL_FLOW_SESSION_CREATE_ENABLE_COST_BIT_NV: bool = false,
    // bit: 2
    VK_OPTICAL_FLOW_SESSION_CREATE_ENABLE_GLOBAL_FLOW_BIT_NV: bool = false,
    // bit: 3
    VK_OPTICAL_FLOW_SESSION_CREATE_ALLOW_REGIONS_BIT_NV: bool = false,
    // bit: 4
    VK_OPTICAL_FLOW_SESSION_CREATE_BOTH_DIRECTIONS_BIT_NV: bool = false,
    _: u27 = 0,
};
pub const VkOpticalFlowExecuteFlagsNV = packed struct(u32) {
    // bit: 0
    VK_OPTICAL_FLOW_EXECUTE_DISABLE_TEMPORAL_HINTS_BIT_NV: bool = false,
    _: u31 = 0,
};
pub const VkFrameBoundaryFlagsEXT = packed struct(u32) {
    // bit: 0
    VK_FRAME_BOUNDARY_FRAME_END_BIT_EXT: bool = false,
    _: u31 = 0,
};
pub const VkPresentScalingFlagsKHR = packed struct(u32) {
    // bit: 0
    VK_PRESENT_SCALING_ONE_TO_ONE_BIT_KHR: bool = false,
    // bit: 1
    VK_PRESENT_SCALING_ASPECT_RATIO_STRETCH_BIT_KHR: bool = false,
    // bit: 2
    VK_PRESENT_SCALING_STRETCH_BIT_KHR: bool = false,
    _: u29 = 0,
};
pub const VkPresentGravityFlagsKHR = packed struct(u32) {
    // bit: 0
    VK_PRESENT_GRAVITY_MIN_BIT_KHR: bool = false,
    // bit: 1
    VK_PRESENT_GRAVITY_MAX_BIT_KHR: bool = false,
    // bit: 2
    VK_PRESENT_GRAVITY_CENTERED_BIT_KHR: bool = false,
    _: u29 = 0,
};
pub const VkShaderCreateFlagsEXT = packed struct(u32) {
    // bit: 0
    VK_SHADER_CREATE_LINK_STAGE_BIT_EXT: bool = false,
    // Extension: VK_EXT_shader_object
    // bit: 1
    VK_SHADER_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT: bool = false,
    // Extension: VK_EXT_shader_object
    // bit: 2
    VK_SHADER_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT: bool = false,
    // Extension: VK_EXT_shader_object
    // bit: 3
    VK_SHADER_CREATE_NO_TASK_SHADER_BIT_EXT: bool = false,
    // Extension: VK_EXT_shader_object
    // bit: 4
    VK_SHADER_CREATE_DISPATCH_BASE_BIT_EXT: bool = false,
    // Extension: VK_EXT_shader_object
    // bit: 5
    VK_SHADER_CREATE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_EXT: bool = false,
    // Extension: VK_EXT_shader_object
    // bit: 6
    VK_SHADER_CREATE_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT: bool = false,
    // Extension: VK_EXT_device_generated_commands
    // bit: 7
    VK_SHADER_CREATE_INDIRECT_BINDABLE_BIT_EXT: bool = false,
    _7: u7 = 0,
    // Extension: VK_EXT_shader_64bit_indexing
    // bit: 15
    VK_SHADER_CREATE_64_BIT_INDEXING_BIT_EXT: bool = false,
    _: u16 = 0,
};
pub const VkTileShadingRenderPassFlagsQCOM = packed struct(u32) {
    // bit: 0
    VK_TILE_SHADING_RENDER_PASS_ENABLE_BIT_QCOM: bool = false,
    // bit: 1
    VK_TILE_SHADING_RENDER_PASS_PER_TILE_EXECUTION_BIT_QCOM: bool = false,
    _: u30 = 0,
};
pub const VkPhysicalDeviceSchedulingControlsFlagsARM = packed struct(u64) {
    // bit: 0
    VK_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_SHADER_CORE_COUNT_ARM: bool = false,
    _: u63 = 0,
};
pub const VkSurfaceCreateFlagsOHOS = packed struct(u32) {
    _: u32 = 0,
};
pub const VkPresentStageFlagsEXT = packed struct(u32) {
    // bit: 0
    VK_PRESENT_STAGE_QUEUE_OPERATIONS_END_BIT_EXT: bool = false,
    // bit: 1
    VK_PRESENT_STAGE_REQUEST_DEQUEUED_BIT_EXT: bool = false,
    // bit: 2
    VK_PRESENT_STAGE_IMAGE_FIRST_PIXEL_OUT_BIT_EXT: bool = false,
    // bit: 3
    VK_PRESENT_STAGE_IMAGE_FIRST_PIXEL_VISIBLE_BIT_EXT: bool = false,
    _: u28 = 0,
};
pub const VkPastPresentationTimingFlagsEXT = packed struct(u32) {
    // bit: 0
    VK_PAST_PRESENTATION_TIMING_ALLOW_PARTIAL_RESULTS_BIT_EXT: bool = false,
    // bit: 1
    VK_PAST_PRESENTATION_TIMING_ALLOW_OUT_OF_ORDER_RESULTS_BIT_EXT: bool = false,
    _: u30 = 0,
};
pub const VkPresentTimingInfoFlagsEXT = packed struct(u32) {
    // bit: 0
    VK_PRESENT_TIMING_INFO_PRESENT_AT_RELATIVE_TIME_BIT_EXT: bool = false,
    // bit: 1
    VK_PRESENT_TIMING_INFO_PRESENT_AT_NEAREST_REFRESH_CYCLE_BIT_EXT: bool = false,
    _: u30 = 0,
};
pub const VkSwapchainImageUsageFlagsOHOS = packed struct(u32) {
    // bit: 0
    VK_SWAPCHAIN_IMAGE_USAGE_SHARED_BIT_OHOS: bool = false,
    _: u31 = 0,
};
pub const VkPerformanceCounterDescriptionFlagsARM = packed struct(u32) {
    _: u32 = 0,
};
pub const VkVideoCodecOperationFlagsKHR = packed struct(u32) {
    // Extension: VK_KHR_video_decode_h264
    // bit: 0
    VK_VIDEO_CODEC_OPERATION_DECODE_H264_BIT_KHR: bool = false,
    // Extension: VK_KHR_video_decode_h265
    // bit: 1
    VK_VIDEO_CODEC_OPERATION_DECODE_H265_BIT_KHR: bool = false,
    // Extension: VK_KHR_video_decode_av1
    // bit: 2
    VK_VIDEO_CODEC_OPERATION_DECODE_AV1_BIT_KHR: bool = false,
    // Extension: VK_KHR_video_decode_vp9
    // bit: 3
    VK_VIDEO_CODEC_OPERATION_DECODE_VP9_BIT_KHR: bool = false,
    _3: u12 = 0,
    // Extension: VK_KHR_video_encode_h264
    // bit: 16
    VK_VIDEO_CODEC_OPERATION_ENCODE_H264_BIT_KHR: bool = false,
    // Extension: VK_KHR_video_encode_h265
    // bit: 17
    VK_VIDEO_CODEC_OPERATION_ENCODE_H265_BIT_KHR: bool = false,
    // Extension: VK_KHR_video_encode_av1
    // bit: 18
    VK_VIDEO_CODEC_OPERATION_ENCODE_AV1_BIT_KHR: bool = false,
    _: u13 = 0,
    pub const VK_VIDEO_CODEC_OPERATION_NONE_KHR: @This() = @bitCast(@as(u32, 0x0));
};
pub const VkVideoCapabilityFlagsKHR = packed struct(u32) {
    // bit: 0
    VK_VIDEO_CAPABILITY_PROTECTED_CONTENT_BIT_KHR: bool = false,
    // bit: 1
    VK_VIDEO_CAPABILITY_SEPARATE_REFERENCE_IMAGES_BIT_KHR: bool = false,
    _: u30 = 0,
};
pub const VkVideoSessionCreateFlagsKHR = packed struct(u32) {
    // bit: 0
    VK_VIDEO_SESSION_CREATE_PROTECTED_CONTENT_BIT_KHR: bool = false,
    // Extension: VK_KHR_video_encode_queue
    // bit: 1
    VK_VIDEO_SESSION_CREATE_ALLOW_ENCODE_PARAMETER_OPTIMIZATIONS_BIT_KHR: bool = false,
    // Extension: VK_KHR_video_maintenance1
    // bit: 2
    VK_VIDEO_SESSION_CREATE_INLINE_QUERIES_BIT_KHR: bool = false,
    // Extension: VK_KHR_video_encode_quantization_map
    // bit: 3
    VK_VIDEO_SESSION_CREATE_ALLOW_ENCODE_QUANTIZATION_DELTA_MAP_BIT_KHR: bool = false,
    // Extension: VK_KHR_video_encode_quantization_map
    // bit: 4
    VK_VIDEO_SESSION_CREATE_ALLOW_ENCODE_EMPHASIS_MAP_BIT_KHR: bool = false,
    // Extension: VK_KHR_video_maintenance2
    // bit: 5
    VK_VIDEO_SESSION_CREATE_INLINE_SESSION_PARAMETERS_BIT_KHR: bool = false,
    _: u26 = 0,
};
pub const VkVideoSessionParametersCreateFlagsKHR = packed struct(u32) {
    // Extension: VK_KHR_video_encode_quantization_map
    // bit: 0
    VK_VIDEO_SESSION_PARAMETERS_CREATE_QUANTIZATION_MAP_COMPATIBLE_BIT_KHR: bool = false,
    _: u31 = 0,
};
pub const VkVideoBeginCodingFlagsKHR = packed struct(u32) {
    _: u32 = 0,
};
pub const VkVideoEndCodingFlagsKHR = packed struct(u32) {
    _: u32 = 0,
};
pub const VkVideoCodingControlFlagsKHR = packed struct(u32) {
    // bit: 0
    VK_VIDEO_CODING_CONTROL_RESET_BIT_KHR: bool = false,
    // Extension: VK_KHR_video_encode_queue
    // bit: 1
    VK_VIDEO_CODING_CONTROL_ENCODE_RATE_CONTROL_BIT_KHR: bool = false,
    // Extension: VK_KHR_video_encode_queue
    // bit: 2
    VK_VIDEO_CODING_CONTROL_ENCODE_QUALITY_LEVEL_BIT_KHR: bool = false,
    _: u29 = 0,
};
pub const VkVideoDecodeUsageFlagsKHR = packed struct(u32) {
    // bit: 0
    VK_VIDEO_DECODE_USAGE_TRANSCODING_BIT_KHR: bool = false,
    // bit: 1
    VK_VIDEO_DECODE_USAGE_OFFLINE_BIT_KHR: bool = false,
    // bit: 2
    VK_VIDEO_DECODE_USAGE_STREAMING_BIT_KHR: bool = false,
    _: u29 = 0,
    pub const VK_VIDEO_DECODE_USAGE_DEFAULT_KHR: @This() = @bitCast(@as(u32, 0x0));
};
pub const VkVideoDecodeCapabilityFlagsKHR = packed struct(u32) {
    // bit: 0
    VK_VIDEO_DECODE_CAPABILITY_DPB_AND_OUTPUT_COINCIDE_BIT_KHR: bool = false,
    // bit: 1
    VK_VIDEO_DECODE_CAPABILITY_DPB_AND_OUTPUT_DISTINCT_BIT_KHR: bool = false,
    _: u30 = 0,
};
pub const VkVideoDecodeFlagsKHR = packed struct(u32) {
    _: u32 = 0,
};
pub const VkVideoDecodeH264PictureLayoutFlagsKHR = packed struct(u32) {
    // bit: 0
    VK_VIDEO_DECODE_H264_PICTURE_LAYOUT_INTERLACED_INTERLEAVED_LINES_BIT_KHR: bool = false,
    // bit: 1
    VK_VIDEO_DECODE_H264_PICTURE_LAYOUT_INTERLACED_SEPARATE_PLANES_BIT_KHR: bool = false,
    _: u30 = 0,
    pub const VK_VIDEO_DECODE_H264_PICTURE_LAYOUT_PROGRESSIVE_KHR: @This() = @bitCast(@as(u32, 0x0));
};
pub const VkVideoEncodeFlagsKHR = packed struct(u32) {
    // Extension: VK_KHR_video_encode_quantization_map
    // bit: 0
    VK_VIDEO_ENCODE_WITH_QUANTIZATION_DELTA_MAP_BIT_KHR: bool = false,
    // Extension: VK_KHR_video_encode_quantization_map
    // bit: 1
    VK_VIDEO_ENCODE_WITH_EMPHASIS_MAP_BIT_KHR: bool = false,
    // Extension: VK_KHR_video_encode_intra_refresh
    // bit: 2
    VK_VIDEO_ENCODE_INTRA_REFRESH_BIT_KHR: bool = false,
    _: u29 = 0,
};
pub const VkVideoEncodeUsageFlagsKHR = packed struct(u32) {
    // bit: 0
    VK_VIDEO_ENCODE_USAGE_TRANSCODING_BIT_KHR: bool = false,
    // bit: 1
    VK_VIDEO_ENCODE_USAGE_STREAMING_BIT_KHR: bool = false,
    // bit: 2
    VK_VIDEO_ENCODE_USAGE_RECORDING_BIT_KHR: bool = false,
    // bit: 3
    VK_VIDEO_ENCODE_USAGE_CONFERENCING_BIT_KHR: bool = false,
    _: u28 = 0,
    pub const VK_VIDEO_ENCODE_USAGE_DEFAULT_KHR: @This() = @bitCast(@as(u32, 0x0));
};
pub const VkVideoEncodeContentFlagsKHR = packed struct(u32) {
    // bit: 0
    VK_VIDEO_ENCODE_CONTENT_CAMERA_BIT_KHR: bool = false,
    // bit: 1
    VK_VIDEO_ENCODE_CONTENT_DESKTOP_BIT_KHR: bool = false,
    // bit: 2
    VK_VIDEO_ENCODE_CONTENT_RENDERED_BIT_KHR: bool = false,
    _: u29 = 0,
    pub const VK_VIDEO_ENCODE_CONTENT_DEFAULT_KHR: @This() = @bitCast(@as(u32, 0x0));
};
pub const VkVideoEncodeCapabilityFlagsKHR = packed struct(u32) {
    // bit: 0
    VK_VIDEO_ENCODE_CAPABILITY_PRECEDING_EXTERNALLY_ENCODED_BYTES_BIT_KHR: bool = false,
    // bit: 1
    VK_VIDEO_ENCODE_CAPABILITY_INSUFFICIENT_BITSTREAM_BUFFER_RANGE_DETECTION_BIT_KHR: bool = false,
    // Extension: VK_KHR_video_encode_quantization_map
    // bit: 2
    VK_VIDEO_ENCODE_CAPABILITY_QUANTIZATION_DELTA_MAP_BIT_KHR: bool = false,
    // Extension: VK_KHR_video_encode_quantization_map
    // bit: 3
    VK_VIDEO_ENCODE_CAPABILITY_EMPHASIS_MAP_BIT_KHR: bool = false,
    _: u28 = 0,
};
pub const VkVideoEncodeFeedbackFlagsKHR = packed struct(u32) {
    // bit: 0
    VK_VIDEO_ENCODE_FEEDBACK_BITSTREAM_BUFFER_OFFSET_BIT_KHR: bool = false,
    // bit: 1
    VK_VIDEO_ENCODE_FEEDBACK_BITSTREAM_BYTES_WRITTEN_BIT_KHR: bool = false,
    // bit: 2
    VK_VIDEO_ENCODE_FEEDBACK_BITSTREAM_HAS_OVERRIDES_BIT_KHR: bool = false,
    _: u29 = 0,
};
pub const VkVideoEncodeRateControlFlagsKHR = packed struct(u32) {
    _: u32 = 0,
};
pub const VkVideoEncodeRateControlModeFlagsKHR = packed struct(u32) {
    // bit: 0
    VK_VIDEO_ENCODE_RATE_CONTROL_MODE_DISABLED_BIT_KHR: bool = false,
    // bit: 1
    VK_VIDEO_ENCODE_RATE_CONTROL_MODE_CBR_BIT_KHR: bool = false,
    // bit: 2
    VK_VIDEO_ENCODE_RATE_CONTROL_MODE_VBR_BIT_KHR: bool = false,
    _: u29 = 0,
    pub const VK_VIDEO_ENCODE_RATE_CONTROL_MODE_DEFAULT_KHR: @This() = @bitCast(@as(u32, 0x0));
};
pub const VkVideoEncodeIntraRefreshModeFlagsKHR = packed struct(u32) {
    // bit: 0
    VK_VIDEO_ENCODE_INTRA_REFRESH_MODE_PER_PICTURE_PARTITION_BIT_KHR: bool = false,
    // bit: 1
    VK_VIDEO_ENCODE_INTRA_REFRESH_MODE_BLOCK_BASED_BIT_KHR: bool = false,
    // bit: 2
    VK_VIDEO_ENCODE_INTRA_REFRESH_MODE_BLOCK_ROW_BASED_BIT_KHR: bool = false,
    // bit: 3
    VK_VIDEO_ENCODE_INTRA_REFRESH_MODE_BLOCK_COLUMN_BASED_BIT_KHR: bool = false,
    _: u28 = 0,
    pub const VK_VIDEO_ENCODE_INTRA_REFRESH_MODE_NONE_KHR: @This() = @bitCast(@as(u32, 0x0));
};
pub const VkVideoChromaSubsamplingFlagsKHR = packed struct(u32) {
    // bit: 0
    VK_VIDEO_CHROMA_SUBSAMPLING_MONOCHROME_BIT_KHR: bool = false,
    // bit: 1
    VK_VIDEO_CHROMA_SUBSAMPLING_420_BIT_KHR: bool = false,
    // bit: 2
    VK_VIDEO_CHROMA_SUBSAMPLING_422_BIT_KHR: bool = false,
    // bit: 3
    VK_VIDEO_CHROMA_SUBSAMPLING_444_BIT_KHR: bool = false,
    _: u28 = 0,
    pub const VK_VIDEO_CHROMA_SUBSAMPLING_INVALID_KHR: @This() = @bitCast(@as(u32, 0x0));
};
pub const VkVideoComponentBitDepthFlagsKHR = packed struct(u32) {
    // bit: 0
    VK_VIDEO_COMPONENT_BIT_DEPTH_8_BIT_KHR: bool = false,
    _0: u1 = 0,
    // bit: 2
    VK_VIDEO_COMPONENT_BIT_DEPTH_10_BIT_KHR: bool = false,
    _2: u1 = 0,
    // bit: 4
    VK_VIDEO_COMPONENT_BIT_DEPTH_12_BIT_KHR: bool = false,
    _: u27 = 0,
    pub const VK_VIDEO_COMPONENT_BIT_DEPTH_INVALID_KHR: @This() = @bitCast(@as(u32, 0x0));
};
pub const VkVideoEncodeH264CapabilityFlagsKHR = packed struct(u32) {
    // bit: 0
    VK_VIDEO_ENCODE_H264_CAPABILITY_HRD_COMPLIANCE_BIT_KHR: bool = false,
    // bit: 1
    VK_VIDEO_ENCODE_H264_CAPABILITY_PREDICTION_WEIGHT_TABLE_GENERATED_BIT_KHR: bool = false,
    // bit: 2
    VK_VIDEO_ENCODE_H264_CAPABILITY_ROW_UNALIGNED_SLICE_BIT_KHR: bool = false,
    // bit: 3
    VK_VIDEO_ENCODE_H264_CAPABILITY_DIFFERENT_SLICE_TYPE_BIT_KHR: bool = false,
    // bit: 4
    VK_VIDEO_ENCODE_H264_CAPABILITY_B_FRAME_IN_L0_LIST_BIT_KHR: bool = false,
    // bit: 5
    VK_VIDEO_ENCODE_H264_CAPABILITY_B_FRAME_IN_L1_LIST_BIT_KHR: bool = false,
    // bit: 6
    VK_VIDEO_ENCODE_H264_CAPABILITY_PER_PICTURE_TYPE_MIN_MAX_QP_BIT_KHR: bool = false,
    // bit: 7
    VK_VIDEO_ENCODE_H264_CAPABILITY_PER_SLICE_CONSTANT_QP_BIT_KHR: bool = false,
    // bit: 8
    VK_VIDEO_ENCODE_H264_CAPABILITY_GENERATE_PREFIX_NALU_BIT_KHR: bool = false,
    // Extension: VK_KHR_video_encode_quantization_map
    // bit: 9
    VK_VIDEO_ENCODE_H264_CAPABILITY_MB_QP_DIFF_WRAPAROUND_BIT_KHR: bool = false,
    // Extension: VK_KHR_video_encode_intra_refresh
    // bit: 10
    VK_VIDEO_ENCODE_H264_CAPABILITY_B_PICTURE_INTRA_REFRESH_BIT_KHR: bool = false,
    _: u21 = 0,
};
pub const VkVideoEncodeH264StdFlagsKHR = packed struct(u32) {
    // bit: 0
    VK_VIDEO_ENCODE_H264_STD_SEPARATE_COLOR_PLANE_FLAG_SET_BIT_KHR: bool = false,
    // bit: 1
    VK_VIDEO_ENCODE_H264_STD_QPPRIME_Y_ZERO_TRANSFORM_BYPASS_FLAG_SET_BIT_KHR: bool = false,
    // bit: 2
    VK_VIDEO_ENCODE_H264_STD_SCALING_MATRIX_PRESENT_FLAG_SET_BIT_KHR: bool = false,
    // bit: 3
    VK_VIDEO_ENCODE_H264_STD_CHROMA_QP_INDEX_OFFSET_BIT_KHR: bool = false,
    // bit: 4
    VK_VIDEO_ENCODE_H264_STD_SECOND_CHROMA_QP_INDEX_OFFSET_BIT_KHR: bool = false,
    // bit: 5
    VK_VIDEO_ENCODE_H264_STD_PIC_INIT_QP_MINUS26_BIT_KHR: bool = false,
    // bit: 6
    VK_VIDEO_ENCODE_H264_STD_WEIGHTED_PRED_FLAG_SET_BIT_KHR: bool = false,
    // bit: 7
    VK_VIDEO_ENCODE_H264_STD_WEIGHTED_BIPRED_IDC_EXPLICIT_BIT_KHR: bool = false,
    // bit: 8
    VK_VIDEO_ENCODE_H264_STD_WEIGHTED_BIPRED_IDC_IMPLICIT_BIT_KHR: bool = false,
    // bit: 9
    VK_VIDEO_ENCODE_H264_STD_TRANSFORM_8X8_MODE_FLAG_SET_BIT_KHR: bool = false,
    // bit: 10
    VK_VIDEO_ENCODE_H264_STD_DIRECT_SPATIAL_MV_PRED_FLAG_UNSET_BIT_KHR: bool = false,
    // bit: 11
    VK_VIDEO_ENCODE_H264_STD_ENTROPY_CODING_MODE_FLAG_UNSET_BIT_KHR: bool = false,
    // bit: 12
    VK_VIDEO_ENCODE_H264_STD_ENTROPY_CODING_MODE_FLAG_SET_BIT_KHR: bool = false,
    // bit: 13
    VK_VIDEO_ENCODE_H264_STD_DIRECT_8X8_INFERENCE_FLAG_UNSET_BIT_KHR: bool = false,
    // bit: 14
    VK_VIDEO_ENCODE_H264_STD_CONSTRAINED_INTRA_PRED_FLAG_SET_BIT_KHR: bool = false,
    // bit: 15
    VK_VIDEO_ENCODE_H264_STD_DEBLOCKING_FILTER_DISABLED_BIT_KHR: bool = false,
    // bit: 16
    VK_VIDEO_ENCODE_H264_STD_DEBLOCKING_FILTER_ENABLED_BIT_KHR: bool = false,
    // bit: 17
    VK_VIDEO_ENCODE_H264_STD_DEBLOCKING_FILTER_PARTIAL_BIT_KHR: bool = false,
    _17: u1 = 0,
    // bit: 19
    VK_VIDEO_ENCODE_H264_STD_SLICE_QP_DELTA_BIT_KHR: bool = false,
    // bit: 20
    VK_VIDEO_ENCODE_H264_STD_DIFFERENT_SLICE_QP_DELTA_BIT_KHR: bool = false,
    _: u11 = 0,
};
pub const VkVideoEncodeH264RateControlFlagsKHR = packed struct(u32) {
    // bit: 0
    VK_VIDEO_ENCODE_H264_RATE_CONTROL_ATTEMPT_HRD_COMPLIANCE_BIT_KHR: bool = false,
    // bit: 1
    VK_VIDEO_ENCODE_H264_RATE_CONTROL_REGULAR_GOP_BIT_KHR: bool = false,
    // bit: 2
    VK_VIDEO_ENCODE_H264_RATE_CONTROL_REFERENCE_PATTERN_FLAT_BIT_KHR: bool = false,
    // bit: 3
    VK_VIDEO_ENCODE_H264_RATE_CONTROL_REFERENCE_PATTERN_DYADIC_BIT_KHR: bool = false,
    // bit: 4
    VK_VIDEO_ENCODE_H264_RATE_CONTROL_TEMPORAL_LAYER_PATTERN_DYADIC_BIT_KHR: bool = false,
    _: u27 = 0,
};
pub const VkVideoEncodeH265CapabilityFlagsKHR = packed struct(u32) {
    // bit: 0
    VK_VIDEO_ENCODE_H265_CAPABILITY_HRD_COMPLIANCE_BIT_KHR: bool = false,
    // bit: 1
    VK_VIDEO_ENCODE_H265_CAPABILITY_PREDICTION_WEIGHT_TABLE_GENERATED_BIT_KHR: bool = false,
    // bit: 2
    VK_VIDEO_ENCODE_H265_CAPABILITY_ROW_UNALIGNED_SLICE_SEGMENT_BIT_KHR: bool = false,
    // bit: 3
    VK_VIDEO_ENCODE_H265_CAPABILITY_DIFFERENT_SLICE_SEGMENT_TYPE_BIT_KHR: bool = false,
    // bit: 4
    VK_VIDEO_ENCODE_H265_CAPABILITY_B_FRAME_IN_L0_LIST_BIT_KHR: bool = false,
    // bit: 5
    VK_VIDEO_ENCODE_H265_CAPABILITY_B_FRAME_IN_L1_LIST_BIT_KHR: bool = false,
    // bit: 6
    VK_VIDEO_ENCODE_H265_CAPABILITY_PER_PICTURE_TYPE_MIN_MAX_QP_BIT_KHR: bool = false,
    // bit: 7
    VK_VIDEO_ENCODE_H265_CAPABILITY_PER_SLICE_SEGMENT_CONSTANT_QP_BIT_KHR: bool = false,
    // bit: 8
    VK_VIDEO_ENCODE_H265_CAPABILITY_MULTIPLE_TILES_PER_SLICE_SEGMENT_BIT_KHR: bool = false,
    // bit: 9
    VK_VIDEO_ENCODE_H265_CAPABILITY_MULTIPLE_SLICE_SEGMENTS_PER_TILE_BIT_KHR: bool = false,
    // Extension: VK_KHR_video_encode_quantization_map
    // bit: 10
    VK_VIDEO_ENCODE_H265_CAPABILITY_CU_QP_DIFF_WRAPAROUND_BIT_KHR: bool = false,
    // Extension: VK_KHR_video_encode_intra_refresh
    // bit: 11
    VK_VIDEO_ENCODE_H265_CAPABILITY_B_PICTURE_INTRA_REFRESH_BIT_KHR: bool = false,
    _: u20 = 0,
};
pub const VkVideoEncodeH265StdFlagsKHR = packed struct(u32) {
    // bit: 0
    VK_VIDEO_ENCODE_H265_STD_SEPARATE_COLOR_PLANE_FLAG_SET_BIT_KHR: bool = false,
    // bit: 1
    VK_VIDEO_ENCODE_H265_STD_SAMPLE_ADAPTIVE_OFFSET_ENABLED_FLAG_SET_BIT_KHR: bool = false,
    // bit: 2
    VK_VIDEO_ENCODE_H265_STD_SCALING_LIST_DATA_PRESENT_FLAG_SET_BIT_KHR: bool = false,
    // bit: 3
    VK_VIDEO_ENCODE_H265_STD_PCM_ENABLED_FLAG_SET_BIT_KHR: bool = false,
    // bit: 4
    VK_VIDEO_ENCODE_H265_STD_SPS_TEMPORAL_MVP_ENABLED_FLAG_SET_BIT_KHR: bool = false,
    // bit: 5
    VK_VIDEO_ENCODE_H265_STD_INIT_QP_MINUS26_BIT_KHR: bool = false,
    // bit: 6
    VK_VIDEO_ENCODE_H265_STD_WEIGHTED_PRED_FLAG_SET_BIT_KHR: bool = false,
    // bit: 7
    VK_VIDEO_ENCODE_H265_STD_WEIGHTED_BIPRED_FLAG_SET_BIT_KHR: bool = false,
    // bit: 8
    VK_VIDEO_ENCODE_H265_STD_LOG2_PARALLEL_MERGE_LEVEL_MINUS2_BIT_KHR: bool = false,
    // bit: 9
    VK_VIDEO_ENCODE_H265_STD_SIGN_DATA_HIDING_ENABLED_FLAG_SET_BIT_KHR: bool = false,
    // bit: 10
    VK_VIDEO_ENCODE_H265_STD_TRANSFORM_SKIP_ENABLED_FLAG_SET_BIT_KHR: bool = false,
    // bit: 11
    VK_VIDEO_ENCODE_H265_STD_TRANSFORM_SKIP_ENABLED_FLAG_UNSET_BIT_KHR: bool = false,
    // bit: 12
    VK_VIDEO_ENCODE_H265_STD_PPS_SLICE_CHROMA_QP_OFFSETS_PRESENT_FLAG_SET_BIT_KHR: bool = false,
    // bit: 13
    VK_VIDEO_ENCODE_H265_STD_TRANSQUANT_BYPASS_ENABLED_FLAG_SET_BIT_KHR: bool = false,
    // bit: 14
    VK_VIDEO_ENCODE_H265_STD_CONSTRAINED_INTRA_PRED_FLAG_SET_BIT_KHR: bool = false,
    // bit: 15
    VK_VIDEO_ENCODE_H265_STD_ENTROPY_CODING_SYNC_ENABLED_FLAG_SET_BIT_KHR: bool = false,
    // bit: 16
    VK_VIDEO_ENCODE_H265_STD_DEBLOCKING_FILTER_OVERRIDE_ENABLED_FLAG_SET_BIT_KHR: bool = false,
    // bit: 17
    VK_VIDEO_ENCODE_H265_STD_DEPENDENT_SLICE_SEGMENTS_ENABLED_FLAG_SET_BIT_KHR: bool = false,
    // bit: 18
    VK_VIDEO_ENCODE_H265_STD_DEPENDENT_SLICE_SEGMENT_FLAG_SET_BIT_KHR: bool = false,
    // bit: 19
    VK_VIDEO_ENCODE_H265_STD_SLICE_QP_DELTA_BIT_KHR: bool = false,
    // bit: 20
    VK_VIDEO_ENCODE_H265_STD_DIFFERENT_SLICE_QP_DELTA_BIT_KHR: bool = false,
    _: u11 = 0,
};
pub const VkVideoEncodeH265RateControlFlagsKHR = packed struct(u32) {
    // bit: 0
    VK_VIDEO_ENCODE_H265_RATE_CONTROL_ATTEMPT_HRD_COMPLIANCE_BIT_KHR: bool = false,
    // bit: 1
    VK_VIDEO_ENCODE_H265_RATE_CONTROL_REGULAR_GOP_BIT_KHR: bool = false,
    // bit: 2
    VK_VIDEO_ENCODE_H265_RATE_CONTROL_REFERENCE_PATTERN_FLAT_BIT_KHR: bool = false,
    // bit: 3
    VK_VIDEO_ENCODE_H265_RATE_CONTROL_REFERENCE_PATTERN_DYADIC_BIT_KHR: bool = false,
    // bit: 4
    VK_VIDEO_ENCODE_H265_RATE_CONTROL_TEMPORAL_SUB_LAYER_PATTERN_DYADIC_BIT_KHR: bool = false,
    _: u27 = 0,
};
pub const VkVideoEncodeH265CtbSizeFlagsKHR = packed struct(u32) {
    // bit: 0
    VK_VIDEO_ENCODE_H265_CTB_SIZE_16_BIT_KHR: bool = false,
    // bit: 1
    VK_VIDEO_ENCODE_H265_CTB_SIZE_32_BIT_KHR: bool = false,
    // bit: 2
    VK_VIDEO_ENCODE_H265_CTB_SIZE_64_BIT_KHR: bool = false,
    _: u29 = 0,
};
pub const VkVideoEncodeH265TransformBlockSizeFlagsKHR = packed struct(u32) {
    // bit: 0
    VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_4_BIT_KHR: bool = false,
    // bit: 1
    VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_8_BIT_KHR: bool = false,
    // bit: 2
    VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_16_BIT_KHR: bool = false,
    // bit: 3
    VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_32_BIT_KHR: bool = false,
    _: u28 = 0,
};
pub const VkVideoEncodeAV1CapabilityFlagsKHR = packed struct(u32) {
    // bit: 0
    VK_VIDEO_ENCODE_AV1_CAPABILITY_PER_RATE_CONTROL_GROUP_MIN_MAX_Q_INDEX_BIT_KHR: bool = false,
    // bit: 1
    VK_VIDEO_ENCODE_AV1_CAPABILITY_GENERATE_OBU_EXTENSION_HEADER_BIT_KHR: bool = false,
    // bit: 2
    VK_VIDEO_ENCODE_AV1_CAPABILITY_PRIMARY_REFERENCE_CDF_ONLY_BIT_KHR: bool = false,
    // bit: 3
    VK_VIDEO_ENCODE_AV1_CAPABILITY_FRAME_SIZE_OVERRIDE_BIT_KHR: bool = false,
    // bit: 4
    VK_VIDEO_ENCODE_AV1_CAPABILITY_MOTION_VECTOR_SCALING_BIT_KHR: bool = false,
    // Extension: VK_KHR_video_encode_intra_refresh
    // bit: 5
    VK_VIDEO_ENCODE_AV1_CAPABILITY_COMPOUND_PREDICTION_INTRA_REFRESH_BIT_KHR: bool = false,
    _: u26 = 0,
};
pub const VkVideoEncodeAV1StdFlagsKHR = packed struct(u32) {
    // bit: 0
    VK_VIDEO_ENCODE_AV1_STD_UNIFORM_TILE_SPACING_FLAG_SET_BIT_KHR: bool = false,
    // bit: 1
    VK_VIDEO_ENCODE_AV1_STD_SKIP_MODE_PRESENT_UNSET_BIT_KHR: bool = false,
    // bit: 2
    VK_VIDEO_ENCODE_AV1_STD_PRIMARY_REF_FRAME_BIT_KHR: bool = false,
    // bit: 3
    VK_VIDEO_ENCODE_AV1_STD_DELTA_Q_BIT_KHR: bool = false,
    _: u28 = 0,
};
pub const VkVideoEncodeAV1RateControlFlagsKHR = packed struct(u32) {
    // bit: 0
    VK_VIDEO_ENCODE_AV1_RATE_CONTROL_REGULAR_GOP_BIT_KHR: bool = false,
    // bit: 1
    VK_VIDEO_ENCODE_AV1_RATE_CONTROL_TEMPORAL_LAYER_PATTERN_DYADIC_BIT_KHR: bool = false,
    // bit: 2
    VK_VIDEO_ENCODE_AV1_RATE_CONTROL_REFERENCE_PATTERN_FLAT_BIT_KHR: bool = false,
    // bit: 3
    VK_VIDEO_ENCODE_AV1_RATE_CONTROL_REFERENCE_PATTERN_DYADIC_BIT_KHR: bool = false,
    _: u28 = 0,
};
pub const VkVideoEncodeAV1SuperblockSizeFlagsKHR = packed struct(u32) {
    // bit: 0
    VK_VIDEO_ENCODE_AV1_SUPERBLOCK_SIZE_64_BIT_KHR: bool = false,
    // bit: 1
    VK_VIDEO_ENCODE_AV1_SUPERBLOCK_SIZE_128_BIT_KHR: bool = false,
    _: u30 = 0,
};
pub const VkAccessFlags3KHR = packed struct(u64) {
    _: u64 = 0,
    pub const VK_ACCESS_3_NONE_KHR: @This() = @bitCast(@as(u64, 0x0));
};

// Enums
pub const VkImageLayout = enum(i32) {
    // Comment: Implicit layout an image is when its contents are undefined due to various reasons (e.g. right after creation)
    VK_IMAGE_LAYOUT_UNDEFINED = 0,
    // Comment: General layout when image can be used for any kind of access
    VK_IMAGE_LAYOUT_GENERAL = 1,
    // Comment: Optimal layout when image is only used for color attachment read/write
    VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL = 2,
    // Comment: Optimal layout when image is only used for depth/stencil attachment read/write
    VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL = 3,
    // Comment: Optimal layout when image is used for read only depth/stencil attachment and shader access
    VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL = 4,
    // Comment: Optimal layout when image is used for read only shader access
    VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL = 5,
    // Comment: Optimal layout when image is used only as source of transfer operations
    VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL = 6,
    // Comment: Optimal layout when image is used only as destination of transfer operations
    VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL = 7,
    // Comment: Initial layout used when the data is populated by the CPU
    VK_IMAGE_LAYOUT_PREINITIALIZED = 8,
    // Extension: VK_KHR_swapchain
    VK_IMAGE_LAYOUT_PRESENT_SRC_KHR = 1000001002,
    // Extension: VK_KHR_video_decode_queue
    VK_IMAGE_LAYOUT_VIDEO_DECODE_DST_KHR = 1000024000,
    // Extension: VK_KHR_video_decode_queue
    VK_IMAGE_LAYOUT_VIDEO_DECODE_SRC_KHR = 1000024001,
    // Extension: VK_KHR_video_decode_queue
    VK_IMAGE_LAYOUT_VIDEO_DECODE_DPB_KHR = 1000024002,
    // Extension: VK_KHR_shared_presentable_image
    VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR = 1000111000,
    // Extension: VK_GRAPHICS_VERSION_1_1
    VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL = 1000117000,
    // Extension: VK_GRAPHICS_VERSION_1_1
    VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL = 1000117001,
    // Extension: VK_KHR_fragment_shading_rate
    VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR = 1000164003,
    // Extension: VK_EXT_fragment_density_map
    VK_IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT = 1000218000,
    // Extension: VK_GRAPHICS_VERSION_1_4
    VK_IMAGE_LAYOUT_RENDERING_LOCAL_READ = 1000232000,
    // Extension: VK_GRAPHICS_VERSION_1_2
    VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL = 1000241000,
    // Extension: VK_GRAPHICS_VERSION_1_2
    VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL = 1000241001,
    // Extension: VK_GRAPHICS_VERSION_1_2
    VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL = 1000241002,
    // Extension: VK_GRAPHICS_VERSION_1_2
    VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL = 1000241003,
    // Extension: VK_KHR_video_encode_queue
    VK_IMAGE_LAYOUT_VIDEO_ENCODE_DST_KHR = 1000299000,
    // Extension: VK_KHR_video_encode_queue
    VK_IMAGE_LAYOUT_VIDEO_ENCODE_SRC_KHR = 1000299001,
    // Extension: VK_KHR_video_encode_queue
    VK_IMAGE_LAYOUT_VIDEO_ENCODE_DPB_KHR = 1000299002,
    // Extension: VK_BASE_VERSION_1_3
    VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL = 1000314000,
    // Extension: VK_BASE_VERSION_1_3
    VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL = 1000314001,
    // Extension: VK_EXT_attachment_feedback_loop_layout
    VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT = 1000339000,
    // Extension: VK_ARM_tensors
    VK_IMAGE_LAYOUT_TENSOR_ALIASING_ARM = 1000460000,
    // Extension: VK_KHR_video_encode_quantization_map
    VK_IMAGE_LAYOUT_VIDEO_ENCODE_QUANTIZATION_MAP_KHR = 1000553000,
    // Extension: VK_EXT_zero_initialize_device_memory
    VK_IMAGE_LAYOUT_ZERO_INITIALIZED_EXT = 1000620000,
    _,
};
pub const VkAttachmentLoadOp = enum(i32) {
    VK_ATTACHMENT_LOAD_OP_LOAD = 0,
    VK_ATTACHMENT_LOAD_OP_CLEAR = 1,
    VK_ATTACHMENT_LOAD_OP_DONT_CARE = 2,
    // Extension: VK_GRAPHICS_VERSION_1_4
    VK_ATTACHMENT_LOAD_OP_NONE = 1000400000,
    _,
};
pub const VkAttachmentStoreOp = enum(i32) {
    VK_ATTACHMENT_STORE_OP_STORE = 0,
    VK_ATTACHMENT_STORE_OP_DONT_CARE = 1,
    // Extension: VK_GRAPHICS_VERSION_1_3
    VK_ATTACHMENT_STORE_OP_NONE = 1000301000,
    _,
};
pub const VkImageType = enum(i32) {
    VK_IMAGE_TYPE_1D = 0,
    VK_IMAGE_TYPE_2D = 1,
    VK_IMAGE_TYPE_3D = 2,
    _,
};
pub const VkImageTiling = enum(i32) {
    VK_IMAGE_TILING_OPTIMAL = 0,
    VK_IMAGE_TILING_LINEAR = 1,
    // Extension: VK_EXT_image_drm_format_modifier
    VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT = 1000158000,
    _,
};
pub const VkImageViewType = enum(i32) {
    VK_IMAGE_VIEW_TYPE_1D = 0,
    VK_IMAGE_VIEW_TYPE_2D = 1,
    VK_IMAGE_VIEW_TYPE_3D = 2,
    VK_IMAGE_VIEW_TYPE_CUBE = 3,
    VK_IMAGE_VIEW_TYPE_1D_ARRAY = 4,
    VK_IMAGE_VIEW_TYPE_2D_ARRAY = 5,
    VK_IMAGE_VIEW_TYPE_CUBE_ARRAY = 6,
    _,
};
pub const VkCommandBufferLevel = enum(i32) {
    VK_COMMAND_BUFFER_LEVEL_PRIMARY = 0,
    VK_COMMAND_BUFFER_LEVEL_SECONDARY = 1,
    _,
};
pub const VkComponentSwizzle = enum(i32) {
    VK_COMPONENT_SWIZZLE_IDENTITY = 0,
    VK_COMPONENT_SWIZZLE_ZERO = 1,
    VK_COMPONENT_SWIZZLE_ONE = 2,
    VK_COMPONENT_SWIZZLE_R = 3,
    VK_COMPONENT_SWIZZLE_G = 4,
    VK_COMPONENT_SWIZZLE_B = 5,
    VK_COMPONENT_SWIZZLE_A = 6,
    _,
};
pub const VkDescriptorType = enum(i32) {
    VK_DESCRIPTOR_TYPE_SAMPLER = 0,
    VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER = 1,
    VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE = 2,
    VK_DESCRIPTOR_TYPE_STORAGE_IMAGE = 3,
    VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER = 4,
    VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER = 5,
    VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER = 6,
    VK_DESCRIPTOR_TYPE_STORAGE_BUFFER = 7,
    VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC = 8,
    VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC = 9,
    VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT = 10,
    // Extension: VK_COMPUTE_VERSION_1_3
    VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK = 1000138000,
    // Extension: VK_KHR_acceleration_structure
    VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR = 1000150000,
    // Extension: VK_NV_ray_tracing
    VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV = 1000165000,
    // Extension: VK_EXT_mutable_descriptor_type
    VK_DESCRIPTOR_TYPE_MUTABLE_EXT = 1000351000,
    // Extension: VK_QCOM_image_processing
    VK_DESCRIPTOR_TYPE_SAMPLE_WEIGHT_IMAGE_QCOM = 1000440000,
    // Extension: VK_QCOM_image_processing
    VK_DESCRIPTOR_TYPE_BLOCK_MATCH_IMAGE_QCOM = 1000440001,
    // Extension: VK_ARM_tensors
    VK_DESCRIPTOR_TYPE_TENSOR_ARM = 1000460000,
    // Extension: VK_NV_partitioned_acceleration_structure
    VK_DESCRIPTOR_TYPE_PARTITIONED_ACCELERATION_STRUCTURE_NV = 1000570000,
    _,
};
pub const VkQueryType = enum(i32) {
    VK_QUERY_TYPE_OCCLUSION = 0,
    // Comment: Optional
    VK_QUERY_TYPE_PIPELINE_STATISTICS = 1,
    VK_QUERY_TYPE_TIMESTAMP = 2,
    // Extension: VK_KHR_video_queue
    VK_QUERY_TYPE_RESULT_STATUS_ONLY_KHR = 1000023000,
    // Extension: VK_EXT_transform_feedback
    VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT = 1000028004,
    // Extension: VK_KHR_performance_query
    VK_QUERY_TYPE_PERFORMANCE_QUERY_KHR = 1000116000,
    // Extension: VK_KHR_acceleration_structure
    VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_KHR = 1000150000,
    // Extension: VK_KHR_acceleration_structure
    VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_SIZE_KHR = 1000150001,
    // Extension: VK_NV_ray_tracing
    VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_NV = 1000165000,
    // Extension: VK_INTEL_performance_query
    VK_QUERY_TYPE_PERFORMANCE_QUERY_INTEL = 1000210000,
    // Extension: VK_KHR_video_encode_queue
    VK_QUERY_TYPE_VIDEO_ENCODE_FEEDBACK_KHR = 1000299000,
    // Extension: VK_EXT_mesh_shader
    VK_QUERY_TYPE_MESH_PRIMITIVES_GENERATED_EXT = 1000328000,
    // Extension: VK_EXT_primitives_generated_query
    VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT = 1000382000,
    // Extension: VK_KHR_ray_tracing_maintenance1
    VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_BOTTOM_LEVEL_POINTERS_KHR = 1000386000,
    // Extension: VK_KHR_ray_tracing_maintenance1
    VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SIZE_KHR = 1000386001,
    // Extension: VK_EXT_opacity_micromap
    VK_QUERY_TYPE_MICROMAP_SERIALIZATION_SIZE_EXT = 1000396000,
    // Extension: VK_EXT_opacity_micromap
    VK_QUERY_TYPE_MICROMAP_COMPACTED_SIZE_EXT = 1000396001,
    _,
};
pub const VkBorderColor = enum(i32) {
    VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK = 0,
    VK_BORDER_COLOR_INT_TRANSPARENT_BLACK = 1,
    VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK = 2,
    VK_BORDER_COLOR_INT_OPAQUE_BLACK = 3,
    VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE = 4,
    VK_BORDER_COLOR_INT_OPAQUE_WHITE = 5,
    // Extension: VK_EXT_custom_border_color
    VK_BORDER_COLOR_FLOAT_CUSTOM_EXT = 1000287003,
    // Extension: VK_EXT_custom_border_color
    VK_BORDER_COLOR_INT_CUSTOM_EXT = 1000287004,
    _,
};
pub const VkPipelineBindPoint = enum(i32) {
    VK_PIPELINE_BIND_POINT_GRAPHICS = 0,
    VK_PIPELINE_BIND_POINT_COMPUTE = 1,
    // Extension: VK_AMDX_shader_enqueue
    VK_PIPELINE_BIND_POINT_EXECUTION_GRAPH_AMDX = 1000134000,
    // Extension: VK_KHR_ray_tracing_pipeline
    VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR = 1000165000,
    // Extension: VK_HUAWEI_subpass_shading
    VK_PIPELINE_BIND_POINT_SUBPASS_SHADING_HUAWEI = 1000369003,
    // Extension: VK_ARM_data_graph
    VK_PIPELINE_BIND_POINT_DATA_GRAPH_ARM = 1000507000,
    _,
};
pub const VkPipelineCacheHeaderVersion = enum(i32) {
    VK_PIPELINE_CACHE_HEADER_VERSION_ONE = 1,
    // Extension: VKSC_VERSION_1_0
    VK_PIPELINE_CACHE_HEADER_VERSION_SAFETY_CRITICAL_ONE = 1000298001,
    // Extension: VK_QCOM_data_graph_model
    VK_PIPELINE_CACHE_HEADER_VERSION_DATA_GRAPH_QCOM = 1000629000,
    _,
};
pub const VkPrimitiveTopology = enum(i32) {
    VK_PRIMITIVE_TOPOLOGY_POINT_LIST = 0,
    VK_PRIMITIVE_TOPOLOGY_LINE_LIST = 1,
    VK_PRIMITIVE_TOPOLOGY_LINE_STRIP = 2,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST = 3,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP = 4,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN = 5,
    VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY = 6,
    VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY = 7,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY = 8,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY = 9,
    VK_PRIMITIVE_TOPOLOGY_PATCH_LIST = 10,
    _,
};
pub const VkSharingMode = enum(i32) {
    VK_SHARING_MODE_EXCLUSIVE = 0,
    VK_SHARING_MODE_CONCURRENT = 1,
    _,
};
pub const VkIndexType = enum(i32) {
    VK_INDEX_TYPE_UINT16 = 0,
    VK_INDEX_TYPE_UINT32 = 1,
    // Extension: VK_KHR_acceleration_structure
    VK_INDEX_TYPE_NONE_KHR = 1000165000,
    // Extension: VK_BASE_VERSION_1_4
    VK_INDEX_TYPE_UINT8 = 1000265000,
    _,
};
pub const VkFilter = enum(i32) {
    VK_FILTER_NEAREST = 0,
    VK_FILTER_LINEAR = 1,
    // Extension: VK_EXT_filter_cubic
    VK_FILTER_CUBIC_EXT = 1000015000,
    _,
};
pub const VkSamplerMipmapMode = enum(i32) {
    // Comment: Choose nearest mip level
    VK_SAMPLER_MIPMAP_MODE_NEAREST = 0,
    // Comment: Linear filter between mip levels
    VK_SAMPLER_MIPMAP_MODE_LINEAR = 1,
    _,
};
pub const VkSamplerAddressMode = enum(i32) {
    VK_SAMPLER_ADDRESS_MODE_REPEAT = 0,
    VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT = 1,
    VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE = 2,
    VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER = 3,
    // Extension: VK_BASE_VERSION_1_2
    // Extension: VK_KHR_sampler_mirror_clamp_to_edge
    VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE = 4,
    _,
};
pub const VkCompareOp = enum(i32) {
    VK_COMPARE_OP_NEVER = 0,
    VK_COMPARE_OP_LESS = 1,
    VK_COMPARE_OP_EQUAL = 2,
    VK_COMPARE_OP_LESS_OR_EQUAL = 3,
    VK_COMPARE_OP_GREATER = 4,
    VK_COMPARE_OP_NOT_EQUAL = 5,
    VK_COMPARE_OP_GREATER_OR_EQUAL = 6,
    VK_COMPARE_OP_ALWAYS = 7,
    _,
};
pub const VkPolygonMode = enum(i32) {
    VK_POLYGON_MODE_FILL = 0,
    VK_POLYGON_MODE_LINE = 1,
    VK_POLYGON_MODE_POINT = 2,
    // Extension: VK_NV_fill_rectangle
    VK_POLYGON_MODE_FILL_RECTANGLE_NV = 1000153000,
    _,
};
pub const VkFrontFace = enum(i32) {
    VK_FRONT_FACE_COUNTER_CLOCKWISE = 0,
    VK_FRONT_FACE_CLOCKWISE = 1,
    _,
};
pub const VkBlendFactor = enum(i32) {
    VK_BLEND_FACTOR_ZERO = 0,
    VK_BLEND_FACTOR_ONE = 1,
    VK_BLEND_FACTOR_SRC_COLOR = 2,
    VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR = 3,
    VK_BLEND_FACTOR_DST_COLOR = 4,
    VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR = 5,
    VK_BLEND_FACTOR_SRC_ALPHA = 6,
    VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA = 7,
    VK_BLEND_FACTOR_DST_ALPHA = 8,
    VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA = 9,
    VK_BLEND_FACTOR_CONSTANT_COLOR = 10,
    VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR = 11,
    VK_BLEND_FACTOR_CONSTANT_ALPHA = 12,
    VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA = 13,
    VK_BLEND_FACTOR_SRC_ALPHA_SATURATE = 14,
    VK_BLEND_FACTOR_SRC1_COLOR = 15,
    VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR = 16,
    VK_BLEND_FACTOR_SRC1_ALPHA = 17,
    VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA = 18,
    _,
};
pub const VkBlendOp = enum(i32) {
    VK_BLEND_OP_ADD = 0,
    VK_BLEND_OP_SUBTRACT = 1,
    VK_BLEND_OP_REVERSE_SUBTRACT = 2,
    VK_BLEND_OP_MIN = 3,
    VK_BLEND_OP_MAX = 4,
    // Extension: VK_EXT_blend_operation_advanced
    VK_BLEND_OP_ZERO_EXT = 1000148000,
    // Extension: VK_EXT_blend_operation_advanced
    VK_BLEND_OP_SRC_EXT = 1000148001,
    // Extension: VK_EXT_blend_operation_advanced
    VK_BLEND_OP_DST_EXT = 1000148002,
    // Extension: VK_EXT_blend_operation_advanced
    VK_BLEND_OP_SRC_OVER_EXT = 1000148003,
    // Extension: VK_EXT_blend_operation_advanced
    VK_BLEND_OP_DST_OVER_EXT = 1000148004,
    // Extension: VK_EXT_blend_operation_advanced
    VK_BLEND_OP_SRC_IN_EXT = 1000148005,
    // Extension: VK_EXT_blend_operation_advanced
    VK_BLEND_OP_DST_IN_EXT = 1000148006,
    // Extension: VK_EXT_blend_operation_advanced
    VK_BLEND_OP_SRC_OUT_EXT = 1000148007,
    // Extension: VK_EXT_blend_operation_advanced
    VK_BLEND_OP_DST_OUT_EXT = 1000148008,
    // Extension: VK_EXT_blend_operation_advanced
    VK_BLEND_OP_SRC_ATOP_EXT = 1000148009,
    // Extension: VK_EXT_blend_operation_advanced
    VK_BLEND_OP_DST_ATOP_EXT = 1000148010,
    // Extension: VK_EXT_blend_operation_advanced
    VK_BLEND_OP_XOR_EXT = 1000148011,
    // Extension: VK_EXT_blend_operation_advanced
    VK_BLEND_OP_MULTIPLY_EXT = 1000148012,
    // Extension: VK_EXT_blend_operation_advanced
    VK_BLEND_OP_SCREEN_EXT = 1000148013,
    // Extension: VK_EXT_blend_operation_advanced
    VK_BLEND_OP_OVERLAY_EXT = 1000148014,
    // Extension: VK_EXT_blend_operation_advanced
    VK_BLEND_OP_DARKEN_EXT = 1000148015,
    // Extension: VK_EXT_blend_operation_advanced
    VK_BLEND_OP_LIGHTEN_EXT = 1000148016,
    // Extension: VK_EXT_blend_operation_advanced
    VK_BLEND_OP_COLORDODGE_EXT = 1000148017,
    // Extension: VK_EXT_blend_operation_advanced
    VK_BLEND_OP_COLORBURN_EXT = 1000148018,
    // Extension: VK_EXT_blend_operation_advanced
    VK_BLEND_OP_HARDLIGHT_EXT = 1000148019,
    // Extension: VK_EXT_blend_operation_advanced
    VK_BLEND_OP_SOFTLIGHT_EXT = 1000148020,
    // Extension: VK_EXT_blend_operation_advanced
    VK_BLEND_OP_DIFFERENCE_EXT = 1000148021,
    // Extension: VK_EXT_blend_operation_advanced
    VK_BLEND_OP_EXCLUSION_EXT = 1000148022,
    // Extension: VK_EXT_blend_operation_advanced
    VK_BLEND_OP_INVERT_EXT = 1000148023,
    // Extension: VK_EXT_blend_operation_advanced
    VK_BLEND_OP_INVERT_RGB_EXT = 1000148024,
    // Extension: VK_EXT_blend_operation_advanced
    VK_BLEND_OP_LINEARDODGE_EXT = 1000148025,
    // Extension: VK_EXT_blend_operation_advanced
    VK_BLEND_OP_LINEARBURN_EXT = 1000148026,
    // Extension: VK_EXT_blend_operation_advanced
    VK_BLEND_OP_VIVIDLIGHT_EXT = 1000148027,
    // Extension: VK_EXT_blend_operation_advanced
    VK_BLEND_OP_LINEARLIGHT_EXT = 1000148028,
    // Extension: VK_EXT_blend_operation_advanced
    VK_BLEND_OP_PINLIGHT_EXT = 1000148029,
    // Extension: VK_EXT_blend_operation_advanced
    VK_BLEND_OP_HARDMIX_EXT = 1000148030,
    // Extension: VK_EXT_blend_operation_advanced
    VK_BLEND_OP_HSL_HUE_EXT = 1000148031,
    // Extension: VK_EXT_blend_operation_advanced
    VK_BLEND_OP_HSL_SATURATION_EXT = 1000148032,
    // Extension: VK_EXT_blend_operation_advanced
    VK_BLEND_OP_HSL_COLOR_EXT = 1000148033,
    // Extension: VK_EXT_blend_operation_advanced
    VK_BLEND_OP_HSL_LUMINOSITY_EXT = 1000148034,
    // Extension: VK_EXT_blend_operation_advanced
    VK_BLEND_OP_PLUS_EXT = 1000148035,
    // Extension: VK_EXT_blend_operation_advanced
    VK_BLEND_OP_PLUS_CLAMPED_EXT = 1000148036,
    // Extension: VK_EXT_blend_operation_advanced
    VK_BLEND_OP_PLUS_CLAMPED_ALPHA_EXT = 1000148037,
    // Extension: VK_EXT_blend_operation_advanced
    VK_BLEND_OP_PLUS_DARKER_EXT = 1000148038,
    // Extension: VK_EXT_blend_operation_advanced
    VK_BLEND_OP_MINUS_EXT = 1000148039,
    // Extension: VK_EXT_blend_operation_advanced
    VK_BLEND_OP_MINUS_CLAMPED_EXT = 1000148040,
    // Extension: VK_EXT_blend_operation_advanced
    VK_BLEND_OP_CONTRAST_EXT = 1000148041,
    // Extension: VK_EXT_blend_operation_advanced
    VK_BLEND_OP_INVERT_OVG_EXT = 1000148042,
    // Extension: VK_EXT_blend_operation_advanced
    VK_BLEND_OP_RED_EXT = 1000148043,
    // Extension: VK_EXT_blend_operation_advanced
    VK_BLEND_OP_GREEN_EXT = 1000148044,
    // Extension: VK_EXT_blend_operation_advanced
    VK_BLEND_OP_BLUE_EXT = 1000148045,
    _,
};
pub const VkStencilOp = enum(i32) {
    VK_STENCIL_OP_KEEP = 0,
    VK_STENCIL_OP_ZERO = 1,
    VK_STENCIL_OP_REPLACE = 2,
    VK_STENCIL_OP_INCREMENT_AND_CLAMP = 3,
    VK_STENCIL_OP_DECREMENT_AND_CLAMP = 4,
    VK_STENCIL_OP_INVERT = 5,
    VK_STENCIL_OP_INCREMENT_AND_WRAP = 6,
    VK_STENCIL_OP_DECREMENT_AND_WRAP = 7,
    _,
};
pub const VkLogicOp = enum(i32) {
    VK_LOGIC_OP_CLEAR = 0,
    VK_LOGIC_OP_AND = 1,
    VK_LOGIC_OP_AND_REVERSE = 2,
    VK_LOGIC_OP_COPY = 3,
    VK_LOGIC_OP_AND_INVERTED = 4,
    VK_LOGIC_OP_NO_OP = 5,
    VK_LOGIC_OP_XOR = 6,
    VK_LOGIC_OP_OR = 7,
    VK_LOGIC_OP_NOR = 8,
    VK_LOGIC_OP_EQUIVALENT = 9,
    VK_LOGIC_OP_INVERT = 10,
    VK_LOGIC_OP_OR_REVERSE = 11,
    VK_LOGIC_OP_COPY_INVERTED = 12,
    VK_LOGIC_OP_OR_INVERTED = 13,
    VK_LOGIC_OP_NAND = 14,
    VK_LOGIC_OP_SET = 15,
    _,
};
pub const VkInternalAllocationType = enum(i32) {
    VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE = 0,
    _,
};
pub const VkSystemAllocationScope = enum(i32) {
    VK_SYSTEM_ALLOCATION_SCOPE_COMMAND = 0,
    VK_SYSTEM_ALLOCATION_SCOPE_OBJECT = 1,
    VK_SYSTEM_ALLOCATION_SCOPE_CACHE = 2,
    VK_SYSTEM_ALLOCATION_SCOPE_DEVICE = 3,
    VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE = 4,
    _,
};
pub const VkPhysicalDeviceType = enum(i32) {
    VK_PHYSICAL_DEVICE_TYPE_OTHER = 0,
    VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU = 1,
    VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU = 2,
    VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU = 3,
    VK_PHYSICAL_DEVICE_TYPE_CPU = 4,
    _,
};
pub const VkVertexInputRate = enum(i32) {
    VK_VERTEX_INPUT_RATE_VERTEX = 0,
    VK_VERTEX_INPUT_RATE_INSTANCE = 1,
    _,
};
pub const VkFormat = enum(i32) {
    VK_FORMAT_UNDEFINED = 0,
    VK_FORMAT_R4G4_UNORM_PACK8 = 1,
    VK_FORMAT_R4G4B4A4_UNORM_PACK16 = 2,
    VK_FORMAT_B4G4R4A4_UNORM_PACK16 = 3,
    VK_FORMAT_R5G6B5_UNORM_PACK16 = 4,
    VK_FORMAT_B5G6R5_UNORM_PACK16 = 5,
    VK_FORMAT_R5G5B5A1_UNORM_PACK16 = 6,
    VK_FORMAT_B5G5R5A1_UNORM_PACK16 = 7,
    VK_FORMAT_A1R5G5B5_UNORM_PACK16 = 8,
    VK_FORMAT_R8_UNORM = 9,
    VK_FORMAT_R8_SNORM = 10,
    VK_FORMAT_R8_USCALED = 11,
    VK_FORMAT_R8_SSCALED = 12,
    VK_FORMAT_R8_UINT = 13,
    VK_FORMAT_R8_SINT = 14,
    VK_FORMAT_R8_SRGB = 15,
    VK_FORMAT_R8G8_UNORM = 16,
    VK_FORMAT_R8G8_SNORM = 17,
    VK_FORMAT_R8G8_USCALED = 18,
    VK_FORMAT_R8G8_SSCALED = 19,
    VK_FORMAT_R8G8_UINT = 20,
    VK_FORMAT_R8G8_SINT = 21,
    VK_FORMAT_R8G8_SRGB = 22,
    VK_FORMAT_R8G8B8_UNORM = 23,
    VK_FORMAT_R8G8B8_SNORM = 24,
    VK_FORMAT_R8G8B8_USCALED = 25,
    VK_FORMAT_R8G8B8_SSCALED = 26,
    VK_FORMAT_R8G8B8_UINT = 27,
    VK_FORMAT_R8G8B8_SINT = 28,
    VK_FORMAT_R8G8B8_SRGB = 29,
    VK_FORMAT_B8G8R8_UNORM = 30,
    VK_FORMAT_B8G8R8_SNORM = 31,
    VK_FORMAT_B8G8R8_USCALED = 32,
    VK_FORMAT_B8G8R8_SSCALED = 33,
    VK_FORMAT_B8G8R8_UINT = 34,
    VK_FORMAT_B8G8R8_SINT = 35,
    VK_FORMAT_B8G8R8_SRGB = 36,
    VK_FORMAT_R8G8B8A8_UNORM = 37,
    VK_FORMAT_R8G8B8A8_SNORM = 38,
    VK_FORMAT_R8G8B8A8_USCALED = 39,
    VK_FORMAT_R8G8B8A8_SSCALED = 40,
    VK_FORMAT_R8G8B8A8_UINT = 41,
    VK_FORMAT_R8G8B8A8_SINT = 42,
    VK_FORMAT_R8G8B8A8_SRGB = 43,
    VK_FORMAT_B8G8R8A8_UNORM = 44,
    VK_FORMAT_B8G8R8A8_SNORM = 45,
    VK_FORMAT_B8G8R8A8_USCALED = 46,
    VK_FORMAT_B8G8R8A8_SSCALED = 47,
    VK_FORMAT_B8G8R8A8_UINT = 48,
    VK_FORMAT_B8G8R8A8_SINT = 49,
    VK_FORMAT_B8G8R8A8_SRGB = 50,
    VK_FORMAT_A8B8G8R8_UNORM_PACK32 = 51,
    VK_FORMAT_A8B8G8R8_SNORM_PACK32 = 52,
    VK_FORMAT_A8B8G8R8_USCALED_PACK32 = 53,
    VK_FORMAT_A8B8G8R8_SSCALED_PACK32 = 54,
    VK_FORMAT_A8B8G8R8_UINT_PACK32 = 55,
    VK_FORMAT_A8B8G8R8_SINT_PACK32 = 56,
    VK_FORMAT_A8B8G8R8_SRGB_PACK32 = 57,
    VK_FORMAT_A2R10G10B10_UNORM_PACK32 = 58,
    VK_FORMAT_A2R10G10B10_SNORM_PACK32 = 59,
    VK_FORMAT_A2R10G10B10_USCALED_PACK32 = 60,
    VK_FORMAT_A2R10G10B10_SSCALED_PACK32 = 61,
    VK_FORMAT_A2R10G10B10_UINT_PACK32 = 62,
    VK_FORMAT_A2R10G10B10_SINT_PACK32 = 63,
    VK_FORMAT_A2B10G10R10_UNORM_PACK32 = 64,
    VK_FORMAT_A2B10G10R10_SNORM_PACK32 = 65,
    VK_FORMAT_A2B10G10R10_USCALED_PACK32 = 66,
    VK_FORMAT_A2B10G10R10_SSCALED_PACK32 = 67,
    VK_FORMAT_A2B10G10R10_UINT_PACK32 = 68,
    VK_FORMAT_A2B10G10R10_SINT_PACK32 = 69,
    VK_FORMAT_R16_UNORM = 70,
    VK_FORMAT_R16_SNORM = 71,
    VK_FORMAT_R16_USCALED = 72,
    VK_FORMAT_R16_SSCALED = 73,
    VK_FORMAT_R16_UINT = 74,
    VK_FORMAT_R16_SINT = 75,
    VK_FORMAT_R16_SFLOAT = 76,
    VK_FORMAT_R16G16_UNORM = 77,
    VK_FORMAT_R16G16_SNORM = 78,
    VK_FORMAT_R16G16_USCALED = 79,
    VK_FORMAT_R16G16_SSCALED = 80,
    VK_FORMAT_R16G16_UINT = 81,
    VK_FORMAT_R16G16_SINT = 82,
    VK_FORMAT_R16G16_SFLOAT = 83,
    VK_FORMAT_R16G16B16_UNORM = 84,
    VK_FORMAT_R16G16B16_SNORM = 85,
    VK_FORMAT_R16G16B16_USCALED = 86,
    VK_FORMAT_R16G16B16_SSCALED = 87,
    VK_FORMAT_R16G16B16_UINT = 88,
    VK_FORMAT_R16G16B16_SINT = 89,
    VK_FORMAT_R16G16B16_SFLOAT = 90,
    VK_FORMAT_R16G16B16A16_UNORM = 91,
    VK_FORMAT_R16G16B16A16_SNORM = 92,
    VK_FORMAT_R16G16B16A16_USCALED = 93,
    VK_FORMAT_R16G16B16A16_SSCALED = 94,
    VK_FORMAT_R16G16B16A16_UINT = 95,
    VK_FORMAT_R16G16B16A16_SINT = 96,
    VK_FORMAT_R16G16B16A16_SFLOAT = 97,
    VK_FORMAT_R32_UINT = 98,
    VK_FORMAT_R32_SINT = 99,
    VK_FORMAT_R32_SFLOAT = 100,
    VK_FORMAT_R32G32_UINT = 101,
    VK_FORMAT_R32G32_SINT = 102,
    VK_FORMAT_R32G32_SFLOAT = 103,
    VK_FORMAT_R32G32B32_UINT = 104,
    VK_FORMAT_R32G32B32_SINT = 105,
    VK_FORMAT_R32G32B32_SFLOAT = 106,
    VK_FORMAT_R32G32B32A32_UINT = 107,
    VK_FORMAT_R32G32B32A32_SINT = 108,
    VK_FORMAT_R32G32B32A32_SFLOAT = 109,
    VK_FORMAT_R64_UINT = 110,
    VK_FORMAT_R64_SINT = 111,
    VK_FORMAT_R64_SFLOAT = 112,
    VK_FORMAT_R64G64_UINT = 113,
    VK_FORMAT_R64G64_SINT = 114,
    VK_FORMAT_R64G64_SFLOAT = 115,
    VK_FORMAT_R64G64B64_UINT = 116,
    VK_FORMAT_R64G64B64_SINT = 117,
    VK_FORMAT_R64G64B64_SFLOAT = 118,
    VK_FORMAT_R64G64B64A64_UINT = 119,
    VK_FORMAT_R64G64B64A64_SINT = 120,
    VK_FORMAT_R64G64B64A64_SFLOAT = 121,
    VK_FORMAT_B10G11R11_UFLOAT_PACK32 = 122,
    VK_FORMAT_E5B9G9R9_UFLOAT_PACK32 = 123,
    VK_FORMAT_D16_UNORM = 124,
    VK_FORMAT_X8_D24_UNORM_PACK32 = 125,
    VK_FORMAT_D32_SFLOAT = 126,
    VK_FORMAT_S8_UINT = 127,
    VK_FORMAT_D16_UNORM_S8_UINT = 128,
    VK_FORMAT_D24_UNORM_S8_UINT = 129,
    VK_FORMAT_D32_SFLOAT_S8_UINT = 130,
    VK_FORMAT_BC1_RGB_UNORM_BLOCK = 131,
    VK_FORMAT_BC1_RGB_SRGB_BLOCK = 132,
    VK_FORMAT_BC1_RGBA_UNORM_BLOCK = 133,
    VK_FORMAT_BC1_RGBA_SRGB_BLOCK = 134,
    VK_FORMAT_BC2_UNORM_BLOCK = 135,
    VK_FORMAT_BC2_SRGB_BLOCK = 136,
    VK_FORMAT_BC3_UNORM_BLOCK = 137,
    VK_FORMAT_BC3_SRGB_BLOCK = 138,
    VK_FORMAT_BC4_UNORM_BLOCK = 139,
    VK_FORMAT_BC4_SNORM_BLOCK = 140,
    VK_FORMAT_BC5_UNORM_BLOCK = 141,
    VK_FORMAT_BC5_SNORM_BLOCK = 142,
    VK_FORMAT_BC6H_UFLOAT_BLOCK = 143,
    VK_FORMAT_BC6H_SFLOAT_BLOCK = 144,
    VK_FORMAT_BC7_UNORM_BLOCK = 145,
    VK_FORMAT_BC7_SRGB_BLOCK = 146,
    VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK = 147,
    VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK = 148,
    VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK = 149,
    VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK = 150,
    VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK = 151,
    VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK = 152,
    VK_FORMAT_EAC_R11_UNORM_BLOCK = 153,
    VK_FORMAT_EAC_R11_SNORM_BLOCK = 154,
    VK_FORMAT_EAC_R11G11_UNORM_BLOCK = 155,
    VK_FORMAT_EAC_R11G11_SNORM_BLOCK = 156,
    VK_FORMAT_ASTC_4x4_UNORM_BLOCK = 157,
    VK_FORMAT_ASTC_4x4_SRGB_BLOCK = 158,
    VK_FORMAT_ASTC_5x4_UNORM_BLOCK = 159,
    VK_FORMAT_ASTC_5x4_SRGB_BLOCK = 160,
    VK_FORMAT_ASTC_5x5_UNORM_BLOCK = 161,
    VK_FORMAT_ASTC_5x5_SRGB_BLOCK = 162,
    VK_FORMAT_ASTC_6x5_UNORM_BLOCK = 163,
    VK_FORMAT_ASTC_6x5_SRGB_BLOCK = 164,
    VK_FORMAT_ASTC_6x6_UNORM_BLOCK = 165,
    VK_FORMAT_ASTC_6x6_SRGB_BLOCK = 166,
    VK_FORMAT_ASTC_8x5_UNORM_BLOCK = 167,
    VK_FORMAT_ASTC_8x5_SRGB_BLOCK = 168,
    VK_FORMAT_ASTC_8x6_UNORM_BLOCK = 169,
    VK_FORMAT_ASTC_8x6_SRGB_BLOCK = 170,
    VK_FORMAT_ASTC_8x8_UNORM_BLOCK = 171,
    VK_FORMAT_ASTC_8x8_SRGB_BLOCK = 172,
    VK_FORMAT_ASTC_10x5_UNORM_BLOCK = 173,
    VK_FORMAT_ASTC_10x5_SRGB_BLOCK = 174,
    VK_FORMAT_ASTC_10x6_UNORM_BLOCK = 175,
    VK_FORMAT_ASTC_10x6_SRGB_BLOCK = 176,
    VK_FORMAT_ASTC_10x8_UNORM_BLOCK = 177,
    VK_FORMAT_ASTC_10x8_SRGB_BLOCK = 178,
    VK_FORMAT_ASTC_10x10_UNORM_BLOCK = 179,
    VK_FORMAT_ASTC_10x10_SRGB_BLOCK = 180,
    VK_FORMAT_ASTC_12x10_UNORM_BLOCK = 181,
    VK_FORMAT_ASTC_12x10_SRGB_BLOCK = 182,
    VK_FORMAT_ASTC_12x12_UNORM_BLOCK = 183,
    VK_FORMAT_ASTC_12x12_SRGB_BLOCK = 184,
    // Extension: VK_IMG_format_pvrtc
    VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG = 1000054000,
    // Extension: VK_IMG_format_pvrtc
    VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG = 1000054001,
    // Extension: VK_IMG_format_pvrtc
    VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG = 1000054002,
    // Extension: VK_IMG_format_pvrtc
    VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG = 1000054003,
    // Extension: VK_IMG_format_pvrtc
    VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG = 1000054004,
    // Extension: VK_IMG_format_pvrtc
    VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG = 1000054005,
    // Extension: VK_IMG_format_pvrtc
    VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG = 1000054006,
    // Extension: VK_IMG_format_pvrtc
    VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG = 1000054007,
    // Extension: VK_BASE_VERSION_1_3
    VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK = 1000066000,
    // Extension: VK_BASE_VERSION_1_3
    VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK = 1000066001,
    // Extension: VK_BASE_VERSION_1_3
    VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK = 1000066002,
    // Extension: VK_BASE_VERSION_1_3
    VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK = 1000066003,
    // Extension: VK_BASE_VERSION_1_3
    VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK = 1000066004,
    // Extension: VK_BASE_VERSION_1_3
    VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK = 1000066005,
    // Extension: VK_BASE_VERSION_1_3
    VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK = 1000066006,
    // Extension: VK_BASE_VERSION_1_3
    VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK = 1000066007,
    // Extension: VK_BASE_VERSION_1_3
    VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK = 1000066008,
    // Extension: VK_BASE_VERSION_1_3
    VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK = 1000066009,
    // Extension: VK_BASE_VERSION_1_3
    VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK = 1000066010,
    // Extension: VK_BASE_VERSION_1_3
    VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK = 1000066011,
    // Extension: VK_BASE_VERSION_1_3
    VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK = 1000066012,
    // Extension: VK_BASE_VERSION_1_3
    VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK = 1000066013,
    // Extension: VK_BASE_VERSION_1_1
    VK_FORMAT_G8B8G8R8_422_UNORM = 1000156000,
    // Extension: VK_BASE_VERSION_1_1
    VK_FORMAT_B8G8R8G8_422_UNORM = 1000156001,
    // Extension: VK_BASE_VERSION_1_1
    VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM = 1000156002,
    // Extension: VK_BASE_VERSION_1_1
    VK_FORMAT_G8_B8R8_2PLANE_420_UNORM = 1000156003,
    // Extension: VK_BASE_VERSION_1_1
    VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM = 1000156004,
    // Extension: VK_BASE_VERSION_1_1
    VK_FORMAT_G8_B8R8_2PLANE_422_UNORM = 1000156005,
    // Extension: VK_BASE_VERSION_1_1
    VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM = 1000156006,
    // Extension: VK_BASE_VERSION_1_1
    VK_FORMAT_R10X6_UNORM_PACK16 = 1000156007,
    // Extension: VK_BASE_VERSION_1_1
    VK_FORMAT_R10X6G10X6_UNORM_2PACK16 = 1000156008,
    // Extension: VK_BASE_VERSION_1_1
    VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16 = 1000156009,
    // Extension: VK_BASE_VERSION_1_1
    VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16 = 1000156010,
    // Extension: VK_BASE_VERSION_1_1
    VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16 = 1000156011,
    // Extension: VK_BASE_VERSION_1_1
    VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16 = 1000156012,
    // Extension: VK_BASE_VERSION_1_1
    VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16 = 1000156013,
    // Extension: VK_BASE_VERSION_1_1
    VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16 = 1000156014,
    // Extension: VK_BASE_VERSION_1_1
    VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16 = 1000156015,
    // Extension: VK_BASE_VERSION_1_1
    VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16 = 1000156016,
    // Extension: VK_BASE_VERSION_1_1
    VK_FORMAT_R12X4_UNORM_PACK16 = 1000156017,
    // Extension: VK_BASE_VERSION_1_1
    VK_FORMAT_R12X4G12X4_UNORM_2PACK16 = 1000156018,
    // Extension: VK_BASE_VERSION_1_1
    VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16 = 1000156019,
    // Extension: VK_BASE_VERSION_1_1
    VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16 = 1000156020,
    // Extension: VK_BASE_VERSION_1_1
    VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16 = 1000156021,
    // Extension: VK_BASE_VERSION_1_1
    VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16 = 1000156022,
    // Extension: VK_BASE_VERSION_1_1
    VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16 = 1000156023,
    // Extension: VK_BASE_VERSION_1_1
    VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16 = 1000156024,
    // Extension: VK_BASE_VERSION_1_1
    VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16 = 1000156025,
    // Extension: VK_BASE_VERSION_1_1
    VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16 = 1000156026,
    // Extension: VK_BASE_VERSION_1_1
    VK_FORMAT_G16B16G16R16_422_UNORM = 1000156027,
    // Extension: VK_BASE_VERSION_1_1
    VK_FORMAT_B16G16R16G16_422_UNORM = 1000156028,
    // Extension: VK_BASE_VERSION_1_1
    VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM = 1000156029,
    // Extension: VK_BASE_VERSION_1_1
    VK_FORMAT_G16_B16R16_2PLANE_420_UNORM = 1000156030,
    // Extension: VK_BASE_VERSION_1_1
    VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM = 1000156031,
    // Extension: VK_BASE_VERSION_1_1
    VK_FORMAT_G16_B16R16_2PLANE_422_UNORM = 1000156032,
    // Extension: VK_BASE_VERSION_1_1
    VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM = 1000156033,
    // Extension: VK_BASE_VERSION_1_3
    VK_FORMAT_G8_B8R8_2PLANE_444_UNORM = 1000330000,
    // Extension: VK_BASE_VERSION_1_3
    VK_FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16 = 1000330001,
    // Extension: VK_BASE_VERSION_1_3
    VK_FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16 = 1000330002,
    // Extension: VK_BASE_VERSION_1_3
    VK_FORMAT_G16_B16R16_2PLANE_444_UNORM = 1000330003,
    // Extension: VK_BASE_VERSION_1_3
    VK_FORMAT_A4R4G4B4_UNORM_PACK16 = 1000340000,
    // Extension: VK_BASE_VERSION_1_3
    VK_FORMAT_A4B4G4R4_UNORM_PACK16 = 1000340001,
    // Extension: VK_ARM_tensors
    VK_FORMAT_R8_BOOL_ARM = 1000460000,
    // Extension: VK_NV_optical_flow
    VK_FORMAT_R16G16_SFIXED5_NV = 1000464000,
    // Extension: VK_BASE_VERSION_1_4
    VK_FORMAT_A1B5G5R5_UNORM_PACK16 = 1000470000,
    // Extension: VK_BASE_VERSION_1_4
    VK_FORMAT_A8_UNORM = 1000470001,
    // Extension: VK_ARM_format_pack
    VK_FORMAT_R10X6_UINT_PACK16_ARM = 1000609000,
    // Extension: VK_ARM_format_pack
    VK_FORMAT_R10X6G10X6_UINT_2PACK16_ARM = 1000609001,
    // Extension: VK_ARM_format_pack
    VK_FORMAT_R10X6G10X6B10X6A10X6_UINT_4PACK16_ARM = 1000609002,
    // Extension: VK_ARM_format_pack
    VK_FORMAT_R12X4_UINT_PACK16_ARM = 1000609003,
    // Extension: VK_ARM_format_pack
    VK_FORMAT_R12X4G12X4_UINT_2PACK16_ARM = 1000609004,
    // Extension: VK_ARM_format_pack
    VK_FORMAT_R12X4G12X4B12X4A12X4_UINT_4PACK16_ARM = 1000609005,
    // Extension: VK_ARM_format_pack
    VK_FORMAT_R14X2_UINT_PACK16_ARM = 1000609006,
    // Extension: VK_ARM_format_pack
    VK_FORMAT_R14X2G14X2_UINT_2PACK16_ARM = 1000609007,
    // Extension: VK_ARM_format_pack
    VK_FORMAT_R14X2G14X2B14X2A14X2_UINT_4PACK16_ARM = 1000609008,
    // Extension: VK_ARM_format_pack
    VK_FORMAT_R14X2_UNORM_PACK16_ARM = 1000609009,
    // Extension: VK_ARM_format_pack
    VK_FORMAT_R14X2G14X2_UNORM_2PACK16_ARM = 1000609010,
    // Extension: VK_ARM_format_pack
    VK_FORMAT_R14X2G14X2B14X2A14X2_UNORM_4PACK16_ARM = 1000609011,
    // Extension: VK_ARM_format_pack
    VK_FORMAT_G14X2_B14X2R14X2_2PLANE_420_UNORM_3PACK16_ARM = 1000609012,
    // Extension: VK_ARM_format_pack
    VK_FORMAT_G14X2_B14X2R14X2_2PLANE_422_UNORM_3PACK16_ARM = 1000609013,
    _,
};
pub const VkStructureType = enum(i32) {
    VK_STRUCTURE_TYPE_APPLICATION_INFO = 0,
    VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO = 1,
    VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO = 2,
    VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO = 3,
    VK_STRUCTURE_TYPE_SUBMIT_INFO = 4,
    VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO = 5,
    VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE = 6,
    VK_STRUCTURE_TYPE_BIND_SPARSE_INFO = 7,
    VK_STRUCTURE_TYPE_FENCE_CREATE_INFO = 8,
    VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO = 9,
    VK_STRUCTURE_TYPE_EVENT_CREATE_INFO = 10,
    VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO = 11,
    VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO = 12,
    VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO = 13,
    VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO = 14,
    VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO = 15,
    VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO = 16,
    VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO = 17,
    VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO = 18,
    VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO = 19,
    VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO = 20,
    VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO = 21,
    VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO = 22,
    VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO = 23,
    VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO = 24,
    VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO = 25,
    VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO = 26,
    VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO = 27,
    VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO = 28,
    VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO = 29,
    VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO = 30,
    VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO = 31,
    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO = 32,
    VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO = 33,
    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO = 34,
    VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET = 35,
    VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET = 36,
    VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO = 37,
    VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO = 38,
    VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO = 39,
    VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO = 40,
    VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO = 41,
    VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO = 42,
    VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO = 43,
    VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER = 44,
    VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER = 45,
    VK_STRUCTURE_TYPE_MEMORY_BARRIER = 46,
    // Comment: Reserved for internal use by the loader, layers, and ICDs
    VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO = 47,
    // Comment: Reserved for internal use by the loader, layers, and ICDs
    VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO = 48,
    // Extension: VK_BASE_VERSION_1_2
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES = 49,
    // Extension: VK_BASE_VERSION_1_2
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES = 50,
    // Extension: VK_BASE_VERSION_1_2
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES = 51,
    // Extension: VK_BASE_VERSION_1_2
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES = 52,
    // Extension: VK_BASE_VERSION_1_3
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES = 53,
    // Extension: VK_BASE_VERSION_1_3
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES = 54,
    // Extension: VK_BASE_VERSION_1_4
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_FEATURES = 55,
    // Extension: VK_BASE_VERSION_1_4
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_PROPERTIES = 56,
    // Extension: VK_KHR_swapchain
    VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR = 1000001000,
    // Extension: VK_KHR_swapchain
    VK_STRUCTURE_TYPE_PRESENT_INFO_KHR = 1000001001,
    // Extension: VK_KHR_display
    VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR = 1000002000,
    // Extension: VK_KHR_display
    VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR = 1000002001,
    // Extension: VK_KHR_display_swapchain
    VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR = 1000003000,
    // Extension: VK_KHR_xlib_surface
    VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR = 1000004000,
    // Extension: VK_KHR_xcb_surface
    VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR = 1000005000,
    // Extension: VK_KHR_wayland_surface
    VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR = 1000006000,
    // Extension: VK_KHR_android_surface
    VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR = 1000008000,
    // Extension: VK_KHR_win32_surface
    VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR = 1000009000,
    // Extension: VK_EXT_debug_report
    VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT = 1000011000,
    // Extension: VK_AMD_rasterization_order
    VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD = 1000018000,
    // Extension: VK_EXT_debug_marker
    VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT = 1000022000,
    // Extension: VK_EXT_debug_marker
    VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT = 1000022001,
    // Extension: VK_EXT_debug_marker
    VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT = 1000022002,
    // Extension: VK_KHR_video_queue
    VK_STRUCTURE_TYPE_VIDEO_PROFILE_INFO_KHR = 1000023000,
    // Extension: VK_KHR_video_queue
    VK_STRUCTURE_TYPE_VIDEO_CAPABILITIES_KHR = 1000023001,
    // Extension: VK_KHR_video_queue
    VK_STRUCTURE_TYPE_VIDEO_PICTURE_RESOURCE_INFO_KHR = 1000023002,
    // Extension: VK_KHR_video_queue
    VK_STRUCTURE_TYPE_VIDEO_SESSION_MEMORY_REQUIREMENTS_KHR = 1000023003,
    // Extension: VK_KHR_video_queue
    VK_STRUCTURE_TYPE_BIND_VIDEO_SESSION_MEMORY_INFO_KHR = 1000023004,
    // Extension: VK_KHR_video_queue
    VK_STRUCTURE_TYPE_VIDEO_SESSION_CREATE_INFO_KHR = 1000023005,
    // Extension: VK_KHR_video_queue
    VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_CREATE_INFO_KHR = 1000023006,
    // Extension: VK_KHR_video_queue
    VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_UPDATE_INFO_KHR = 1000023007,
    // Extension: VK_KHR_video_queue
    VK_STRUCTURE_TYPE_VIDEO_BEGIN_CODING_INFO_KHR = 1000023008,
    // Extension: VK_KHR_video_queue
    VK_STRUCTURE_TYPE_VIDEO_END_CODING_INFO_KHR = 1000023009,
    // Extension: VK_KHR_video_queue
    VK_STRUCTURE_TYPE_VIDEO_CODING_CONTROL_INFO_KHR = 1000023010,
    // Extension: VK_KHR_video_queue
    VK_STRUCTURE_TYPE_VIDEO_REFERENCE_SLOT_INFO_KHR = 1000023011,
    // Extension: VK_KHR_video_queue
    VK_STRUCTURE_TYPE_QUEUE_FAMILY_VIDEO_PROPERTIES_KHR = 1000023012,
    // Extension: VK_KHR_video_queue
    VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR = 1000023013,
    // Extension: VK_KHR_video_queue
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_FORMAT_INFO_KHR = 1000023014,
    // Extension: VK_KHR_video_queue
    VK_STRUCTURE_TYPE_VIDEO_FORMAT_PROPERTIES_KHR = 1000023015,
    // Extension: VK_KHR_video_queue
    VK_STRUCTURE_TYPE_QUEUE_FAMILY_QUERY_RESULT_STATUS_PROPERTIES_KHR = 1000023016,
    // Extension: VK_KHR_video_decode_queue
    VK_STRUCTURE_TYPE_VIDEO_DECODE_INFO_KHR = 1000024000,
    // Extension: VK_KHR_video_decode_queue
    VK_STRUCTURE_TYPE_VIDEO_DECODE_CAPABILITIES_KHR = 1000024001,
    // Extension: VK_KHR_video_decode_queue
    VK_STRUCTURE_TYPE_VIDEO_DECODE_USAGE_INFO_KHR = 1000024002,
    // Extension: VK_NV_dedicated_allocation
    VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV = 1000026000,
    // Extension: VK_NV_dedicated_allocation
    VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV = 1000026001,
    // Extension: VK_NV_dedicated_allocation
    VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV = 1000026002,
    // Extension: VK_EXT_transform_feedback
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT = 1000028000,
    // Extension: VK_EXT_transform_feedback
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT = 1000028001,
    // Extension: VK_EXT_transform_feedback
    VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT = 1000028002,
    // Extension: VK_NVX_binary_import
    VK_STRUCTURE_TYPE_CU_MODULE_CREATE_INFO_NVX = 1000029000,
    // Extension: VK_NVX_binary_import
    VK_STRUCTURE_TYPE_CU_FUNCTION_CREATE_INFO_NVX = 1000029001,
    // Extension: VK_NVX_binary_import
    VK_STRUCTURE_TYPE_CU_LAUNCH_INFO_NVX = 1000029002,
    // Extension: VK_NVX_binary_import
    VK_STRUCTURE_TYPE_CU_MODULE_TEXTURING_MODE_CREATE_INFO_NVX = 1000029004,
    // Extension: VK_NVX_image_view_handle
    VK_STRUCTURE_TYPE_IMAGE_VIEW_HANDLE_INFO_NVX = 1000030000,
    // Extension: VK_NVX_image_view_handle
    VK_STRUCTURE_TYPE_IMAGE_VIEW_ADDRESS_PROPERTIES_NVX = 1000030001,
    // Extension: VK_KHR_video_encode_h264
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_CAPABILITIES_KHR = 1000038000,
    // Extension: VK_KHR_video_encode_h264
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR = 1000038001,
    // Extension: VK_KHR_video_encode_h264
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR = 1000038002,
    // Extension: VK_KHR_video_encode_h264
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PICTURE_INFO_KHR = 1000038003,
    // Extension: VK_KHR_video_encode_h264
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_DPB_SLOT_INFO_KHR = 1000038004,
    // Extension: VK_KHR_video_encode_h264
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_NALU_SLICE_INFO_KHR = 1000038005,
    // Extension: VK_KHR_video_encode_h264
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_GOP_REMAINING_FRAME_INFO_KHR = 1000038006,
    // Extension: VK_KHR_video_encode_h264
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PROFILE_INFO_KHR = 1000038007,
    // Extension: VK_KHR_video_encode_h264
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_INFO_KHR = 1000038008,
    // Extension: VK_KHR_video_encode_h264
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_LAYER_INFO_KHR = 1000038009,
    // Extension: VK_KHR_video_encode_h264
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_CREATE_INFO_KHR = 1000038010,
    // Extension: VK_KHR_video_encode_h264
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_QUALITY_LEVEL_PROPERTIES_KHR = 1000038011,
    // Extension: VK_KHR_video_encode_h264
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_GET_INFO_KHR = 1000038012,
    // Extension: VK_KHR_video_encode_h264
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_FEEDBACK_INFO_KHR = 1000038013,
    // Extension: VK_KHR_video_encode_h265
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_CAPABILITIES_KHR = 1000039000,
    // Extension: VK_KHR_video_encode_h265
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR = 1000039001,
    // Extension: VK_KHR_video_encode_h265
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR = 1000039002,
    // Extension: VK_KHR_video_encode_h265
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PICTURE_INFO_KHR = 1000039003,
    // Extension: VK_KHR_video_encode_h265
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_DPB_SLOT_INFO_KHR = 1000039004,
    // Extension: VK_KHR_video_encode_h265
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_NALU_SLICE_SEGMENT_INFO_KHR = 1000039005,
    // Extension: VK_KHR_video_encode_h265
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_GOP_REMAINING_FRAME_INFO_KHR = 1000039006,
    // Extension: VK_KHR_video_encode_h265
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PROFILE_INFO_KHR = 1000039007,
    // Extension: VK_KHR_video_encode_h265
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_INFO_KHR = 1000039009,
    // Extension: VK_KHR_video_encode_h265
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_LAYER_INFO_KHR = 1000039010,
    // Extension: VK_KHR_video_encode_h265
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_CREATE_INFO_KHR = 1000039011,
    // Extension: VK_KHR_video_encode_h265
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_QUALITY_LEVEL_PROPERTIES_KHR = 1000039012,
    // Extension: VK_KHR_video_encode_h265
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_GET_INFO_KHR = 1000039013,
    // Extension: VK_KHR_video_encode_h265
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_FEEDBACK_INFO_KHR = 1000039014,
    // Extension: VK_KHR_video_decode_h264
    VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_CAPABILITIES_KHR = 1000040000,
    // Extension: VK_KHR_video_decode_h264
    VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PICTURE_INFO_KHR = 1000040001,
    // Extension: VK_KHR_video_decode_h264
    VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PROFILE_INFO_KHR = 1000040003,
    // Extension: VK_KHR_video_decode_h264
    VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR = 1000040004,
    // Extension: VK_KHR_video_decode_h264
    VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR = 1000040005,
    // Extension: VK_KHR_video_decode_h264
    VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_DPB_SLOT_INFO_KHR = 1000040006,
    // Extension: VK_AMD_texture_gather_bias_lod
    VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD = 1000041000,
    // Extension: VK_GRAPHICS_VERSION_1_3
    VK_STRUCTURE_TYPE_RENDERING_INFO = 1000044000,
    // Extension: VK_GRAPHICS_VERSION_1_3
    VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO = 1000044001,
    // Extension: VK_GRAPHICS_VERSION_1_3
    VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO = 1000044002,
    // Extension: VK_GRAPHICS_VERSION_1_3
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES = 1000044003,
    // Extension: VK_GRAPHICS_VERSION_1_3
    VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO = 1000044004,
    // Extension: VK_KHR_fragment_shading_rate
    VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR = 1000044006,
    // Extension: VK_EXT_fragment_density_map
    VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT = 1000044007,
    // Extension: VK_AMD_mixed_attachment_samples
    VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD = 1000044008,
    // Extension: VK_NVX_multiview_per_view_attributes
    VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_NVX = 1000044009,
    // Extension: VK_GGP_stream_descriptor_surface
    VK_STRUCTURE_TYPE_STREAM_DESCRIPTOR_SURFACE_CREATE_INFO_GGP = 1000049000,
    // Extension: VK_NV_corner_sampled_image
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV = 1000050000,
    // Extension: VK_NV_private_vendor_info
    VK_STRUCTURE_TYPE_PRIVATE_VENDOR_INFO_PLACEHOLDER_OFFSET_0_NV = 1000051000,
    // Extension: VK_GRAPHICS_VERSION_1_1
    VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO = 1000053000,
    // Extension: VK_GRAPHICS_VERSION_1_1
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES = 1000053001,
    // Extension: VK_GRAPHICS_VERSION_1_1
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES = 1000053002,
    // Extension: VK_NV_external_memory
    VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV = 1000056000,
    // Extension: VK_NV_external_memory
    VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV = 1000056001,
    // Extension: VK_NV_external_memory_win32
    VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV = 1000057000,
    // Extension: VK_NV_external_memory_win32
    VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV = 1000057001,
    // Extension: VK_NV_win32_keyed_mutex
    VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV = 1000058000,
    // Extension: VK_BASE_VERSION_1_1
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2 = 1000059000,
    // Extension: VK_BASE_VERSION_1_1
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2 = 1000059001,
    // Extension: VK_BASE_VERSION_1_1
    VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2 = 1000059002,
    // Extension: VK_BASE_VERSION_1_1
    VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2 = 1000059003,
    // Extension: VK_BASE_VERSION_1_1
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2 = 1000059004,
    // Extension: VK_BASE_VERSION_1_1
    VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2 = 1000059005,
    // Extension: VK_BASE_VERSION_1_1
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2 = 1000059006,
    // Extension: VK_BASE_VERSION_1_1
    VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2 = 1000059007,
    // Extension: VK_BASE_VERSION_1_1
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2 = 1000059008,
    // Extension: VK_BASE_VERSION_1_1
    VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO = 1000060000,
    // Extension: VK_GRAPHICS_VERSION_1_1
    VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO = 1000060003,
    // Extension: VK_BASE_VERSION_1_1
    VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO = 1000060004,
    // Extension: VK_BASE_VERSION_1_1
    VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO = 1000060005,
    // Extension: VK_BASE_VERSION_1_1
    VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO = 1000060006,
    // Extension: VK_KHR_device_group
    // Extension: VK_KHR_swapchain
    VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR = 1000060007,
    // Extension: VK_KHR_device_group
    // Extension: VK_KHR_swapchain
    VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR = 1000060008,
    // Extension: VK_KHR_swapchain
    // Extension: VK_KHR_device_group
    VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR = 1000060009,
    // Extension: VK_KHR_device_group
    // Extension: VK_KHR_swapchain
    VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR = 1000060010,
    // Extension: VK_KHR_device_group
    // Extension: VK_KHR_swapchain
    VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR = 1000060011,
    // Extension: VK_KHR_swapchain
    // Extension: VK_KHR_device_group
    VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR = 1000060012,
    // Extension: VK_BASE_VERSION_1_1
    VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO = 1000060013,
    // Extension: VK_BASE_VERSION_1_1
    VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO = 1000060014,
    // Extension: VK_EXT_validation_flags
    VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT = 1000061000,
    // Extension: VK_NN_vi_surface
    VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN = 1000062000,
    // Extension: VK_GRAPHICS_VERSION_1_1
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES = 1000063000,
    // Extension: VK_BASE_VERSION_1_3
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES = 1000066000,
    // Extension: VK_EXT_astc_decode_mode
    VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT = 1000067000,
    // Extension: VK_EXT_astc_decode_mode
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT = 1000067001,
    // Extension: VK_COMPUTE_VERSION_1_4
    VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO = 1000068000,
    // Extension: VK_COMPUTE_VERSION_1_4
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES = 1000068001,
    // Extension: VK_COMPUTE_VERSION_1_4
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES = 1000068002,
    // Extension: VK_BASE_VERSION_1_1
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES = 1000070000,
    // Extension: VK_BASE_VERSION_1_1
    VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO = 1000070001,
    // Extension: VK_BASE_VERSION_1_1
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO = 1000071000,
    // Extension: VK_BASE_VERSION_1_1
    VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES = 1000071001,
    // Extension: VK_BASE_VERSION_1_1
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO = 1000071002,
    // Extension: VK_BASE_VERSION_1_1
    VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES = 1000071003,
    // Extension: VK_BASE_VERSION_1_1
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES = 1000071004,
    // Extension: VK_BASE_VERSION_1_1
    VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO = 1000072000,
    // Extension: VK_BASE_VERSION_1_1
    VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO = 1000072001,
    // Extension: VK_BASE_VERSION_1_1
    VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO = 1000072002,
    // Extension: VK_KHR_external_memory_win32
    VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR = 1000073000,
    // Extension: VK_KHR_external_memory_win32
    VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR = 1000073001,
    // Extension: VK_KHR_external_memory_win32
    VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR = 1000073002,
    // Extension: VK_KHR_external_memory_win32
    VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR = 1000073003,
    // Extension: VK_KHR_external_memory_fd
    VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR = 1000074000,
    // Extension: VK_KHR_external_memory_fd
    VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR = 1000074001,
    // Extension: VK_KHR_external_memory_fd
    VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR = 1000074002,
    // Extension: VK_KHR_win32_keyed_mutex
    VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR = 1000075000,
    // Extension: VK_BASE_VERSION_1_1
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO = 1000076000,
    // Extension: VK_BASE_VERSION_1_1
    VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES = 1000076001,
    // Extension: VK_BASE_VERSION_1_1
    VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO = 1000077000,
    // Extension: VK_KHR_external_semaphore_win32
    VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR = 1000078000,
    // Extension: VK_KHR_external_semaphore_win32
    VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR = 1000078001,
    // Extension: VK_KHR_external_semaphore_win32
    VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR = 1000078002,
    // Extension: VK_KHR_external_semaphore_win32
    VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR = 1000078003,
    // Extension: VK_KHR_external_semaphore_fd
    VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR = 1000079000,
    // Extension: VK_KHR_external_semaphore_fd
    VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR = 1000079001,
    // Extension: VK_COMPUTE_VERSION_1_4
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES = 1000080000,
    // Extension: VK_EXT_conditional_rendering
    VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT = 1000081000,
    // Extension: VK_EXT_conditional_rendering
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT = 1000081001,
    // Extension: VK_EXT_conditional_rendering
    VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT = 1000081002,
    // Extension: VK_COMPUTE_VERSION_1_2
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES = 1000082000,
    // Extension: VK_COMPUTE_VERSION_1_1
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES = 1000083000,
    // Extension: VK_KHR_incremental_present
    VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR = 1000084000,
    // Extension: VK_COMPUTE_VERSION_1_1
    VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO = 1000085000,
    // Extension: VK_NV_clip_space_w_scaling
    VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV = 1000087000,
    // Extension: VK_EXT_display_surface_counter
    VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT = 1000090000,
    // Extension: VK_EXT_display_control
    VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT = 1000091000,
    // Extension: VK_EXT_display_control
    VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT = 1000091001,
    // Extension: VK_EXT_display_control
    VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT = 1000091002,
    // Extension: VK_EXT_display_control
    VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT = 1000091003,
    // Extension: VK_GOOGLE_display_timing
    VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE = 1000092000,
    // Extension: VK_COMPUTE_VERSION_1_1
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES = 1000094000,
    // Extension: VK_NVX_multiview_per_view_attributes
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX = 1000097000,
    // Extension: VK_NV_viewport_swizzle
    VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV = 1000098000,
    // Extension: VK_EXT_discard_rectangles
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT = 1000099000,
    // Extension: VK_EXT_discard_rectangles
    VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT = 1000099001,
    // Extension: VK_EXT_conservative_rasterization
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT = 1000101000,
    // Extension: VK_EXT_conservative_rasterization
    VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT = 1000101001,
    // Extension: VK_EXT_depth_clip_enable
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT = 1000102000,
    // Extension: VK_EXT_depth_clip_enable
    VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT = 1000102001,
    // Extension: VK_EXT_hdr_metadata
    VK_STRUCTURE_TYPE_HDR_METADATA_EXT = 1000105000,
    // Extension: VK_GRAPHICS_VERSION_1_2
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES = 1000108000,
    // Extension: VK_GRAPHICS_VERSION_1_2
    VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO = 1000108001,
    // Extension: VK_GRAPHICS_VERSION_1_2
    VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO = 1000108002,
    // Extension: VK_GRAPHICS_VERSION_1_2
    VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO = 1000108003,
    // Extension: VK_GRAPHICS_VERSION_1_2
    VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2 = 1000109000,
    // Extension: VK_GRAPHICS_VERSION_1_2
    VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2 = 1000109001,
    // Extension: VK_GRAPHICS_VERSION_1_2
    VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2 = 1000109002,
    // Extension: VK_GRAPHICS_VERSION_1_2
    VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2 = 1000109003,
    // Extension: VK_GRAPHICS_VERSION_1_2
    VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2 = 1000109004,
    // Extension: VK_GRAPHICS_VERSION_1_2
    VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO = 1000109005,
    // Extension: VK_GRAPHICS_VERSION_1_2
    VK_STRUCTURE_TYPE_SUBPASS_END_INFO = 1000109006,
    // Extension: VK_IMG_relaxed_line_rasterization
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RELAXED_LINE_RASTERIZATION_FEATURES_IMG = 1000110000,
    // Extension: VK_KHR_shared_presentable_image
    VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR = 1000111000,
    // Extension: VK_BASE_VERSION_1_1
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO = 1000112000,
    // Extension: VK_BASE_VERSION_1_1
    VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES = 1000112001,
    // Extension: VK_BASE_VERSION_1_1
    VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO = 1000113000,
    // Extension: VK_KHR_external_fence_win32
    VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR = 1000114000,
    // Extension: VK_KHR_external_fence_win32
    VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR = 1000114001,
    // Extension: VK_KHR_external_fence_win32
    VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR = 1000114002,
    // Extension: VK_KHR_external_fence_fd
    VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR = 1000115000,
    // Extension: VK_KHR_external_fence_fd
    VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR = 1000115001,
    // Extension: VK_KHR_performance_query
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR = 1000116000,
    // Extension: VK_KHR_performance_query
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR = 1000116001,
    // Extension: VK_KHR_performance_query
    VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR = 1000116002,
    // Extension: VK_KHR_performance_query
    VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR = 1000116003,
    // Extension: VK_KHR_performance_query
    VK_STRUCTURE_TYPE_ACQUIRE_PROFILING_LOCK_INFO_KHR = 1000116004,
    // Extension: VK_KHR_performance_query
    VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_KHR = 1000116005,
    // Extension: VK_KHR_performance_query
    VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_DESCRIPTION_KHR = 1000116006,
    // Extension: VK_KHR_performance_query
    VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_RESERVATION_INFO_KHR = 1000116007,
    // Extension: VK_GRAPHICS_VERSION_1_1
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES = 1000117000,
    // Extension: VK_GRAPHICS_VERSION_1_1
    VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO = 1000117001,
    // Extension: VK_BASE_VERSION_1_1
    VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO = 1000117002,
    // Extension: VK_GRAPHICS_VERSION_1_1
    VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO = 1000117003,
    // Extension: VK_KHR_get_surface_capabilities2
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR = 1000119000,
    // Extension: VK_KHR_get_surface_capabilities2
    VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR = 1000119001,
    // Extension: VK_KHR_get_surface_capabilities2
    VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR = 1000119002,
    // Extension: VK_COMPUTE_VERSION_1_1
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES = 1000120000,
    // Extension: VK_KHR_get_display_properties2
    VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR = 1000121000,
    // Extension: VK_KHR_get_display_properties2
    VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR = 1000121001,
    // Extension: VK_KHR_get_display_properties2
    VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR = 1000121002,
    // Extension: VK_KHR_get_display_properties2
    VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR = 1000121003,
    // Extension: VK_KHR_get_display_properties2
    VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR = 1000121004,
    // Extension: VK_MVK_ios_surface
    VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK = 1000122000,
    // Extension: VK_MVK_macos_surface
    VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK = 1000123000,
    // Extension: VK_BASE_VERSION_1_1
    VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS = 1000127000,
    // Extension: VK_BASE_VERSION_1_1
    VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO = 1000127001,
    // Extension: VK_EXT_debug_utils
    VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT = 1000128000,
    // Extension: VK_EXT_debug_utils
    VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT = 1000128001,
    // Extension: VK_EXT_debug_utils
    VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT = 1000128002,
    // Extension: VK_EXT_debug_utils
    VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT = 1000128003,
    // Extension: VK_EXT_debug_utils
    VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT = 1000128004,
    // Extension: VK_ANDROID_external_memory_android_hardware_buffer
    VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID = 1000129000,
    // Extension: VK_ANDROID_external_memory_android_hardware_buffer
    VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID = 1000129001,
    // Extension: VK_ANDROID_external_memory_android_hardware_buffer
    VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID = 1000129002,
    // Extension: VK_ANDROID_external_memory_android_hardware_buffer
    VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID = 1000129003,
    // Extension: VK_ANDROID_external_memory_android_hardware_buffer
    VK_STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID = 1000129004,
    // Extension: VK_ANDROID_external_memory_android_hardware_buffer
    VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID = 1000129005,
    // Extension: VK_ANDROID_external_memory_android_hardware_buffer
    VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_2_ANDROID = 1000129006,
    // Extension: VK_COMPUTE_VERSION_1_2
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES = 1000130000,
    // Extension: VK_COMPUTE_VERSION_1_2
    VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO = 1000130001,
    // Extension: VK_AMDX_shader_enqueue
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ENQUEUE_FEATURES_AMDX = 1000134000,
    // Extension: VK_AMDX_shader_enqueue
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ENQUEUE_PROPERTIES_AMDX = 1000134001,
    // Extension: VK_AMDX_shader_enqueue
    VK_STRUCTURE_TYPE_EXECUTION_GRAPH_PIPELINE_SCRATCH_SIZE_AMDX = 1000134002,
    // Extension: VK_AMDX_shader_enqueue
    VK_STRUCTURE_TYPE_EXECUTION_GRAPH_PIPELINE_CREATE_INFO_AMDX = 1000134003,
    // Extension: VK_AMDX_shader_enqueue
    VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_NODE_CREATE_INFO_AMDX = 1000134004,
    // Extension: VK_COMPUTE_VERSION_1_3
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES = 1000138000,
    // Extension: VK_COMPUTE_VERSION_1_3
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES = 1000138001,
    // Extension: VK_COMPUTE_VERSION_1_3
    VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK = 1000138002,
    // Extension: VK_COMPUTE_VERSION_1_3
    VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO = 1000138003,
    // Extension: VK_KHR_shader_bfloat16
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_BFLOAT16_FEATURES_KHR = 1000141000,
    // Extension: VK_EXT_sample_locations
    VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT = 1000143000,
    // Extension: VK_EXT_sample_locations
    VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT = 1000143001,
    // Extension: VK_EXT_sample_locations
    VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT = 1000143002,
    // Extension: VK_EXT_sample_locations
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT = 1000143003,
    // Extension: VK_EXT_sample_locations
    VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT = 1000143004,
    // Extension: VK_BASE_VERSION_1_1
    VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO = 1000145000,
    // Extension: VK_BASE_VERSION_1_1
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES = 1000145001,
    // Extension: VK_BASE_VERSION_1_1
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES = 1000145002,
    // Extension: VK_BASE_VERSION_1_1
    VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2 = 1000145003,
    // Extension: VK_BASE_VERSION_1_1
    VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2 = 1000146000,
    // Extension: VK_BASE_VERSION_1_1
    VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2 = 1000146001,
    // Extension: VK_BASE_VERSION_1_1
    VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2 = 1000146002,
    // Extension: VK_BASE_VERSION_1_1
    VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2 = 1000146003,
    // Extension: VK_BASE_VERSION_1_1
    VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2 = 1000146004,
    // Extension: VK_BASE_VERSION_1_2
    VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO = 1000147000,
    // Extension: VK_EXT_blend_operation_advanced
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT = 1000148000,
    // Extension: VK_EXT_blend_operation_advanced
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT = 1000148001,
    // Extension: VK_EXT_blend_operation_advanced
    VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT = 1000148002,
    // Extension: VK_NV_fragment_coverage_to_color
    VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV = 1000149000,
    // Extension: VK_KHR_acceleration_structure
    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR = 1000150000,
    // Extension: VK_KHR_acceleration_structure
    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR = 1000150002,
    // Extension: VK_KHR_acceleration_structure
    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_AABBS_DATA_KHR = 1000150003,
    // Extension: VK_KHR_acceleration_structure
    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR = 1000150004,
    // Extension: VK_KHR_acceleration_structure
    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR = 1000150005,
    // Extension: VK_KHR_acceleration_structure
    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR = 1000150006,
    // Extension: VK_KHR_acceleration_structure
    VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR = 1000150007,
    // Extension: VK_KHR_acceleration_structure
    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_VERSION_INFO_KHR = 1000150009,
    // Extension: VK_KHR_acceleration_structure
    VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_INFO_KHR = 1000150010,
    // Extension: VK_KHR_acceleration_structure
    VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR = 1000150011,
    // Extension: VK_KHR_acceleration_structure
    VK_STRUCTURE_TYPE_COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR = 1000150012,
    // Extension: VK_KHR_acceleration_structure
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR = 1000150013,
    // Extension: VK_KHR_acceleration_structure
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR = 1000150014,
    // Extension: VK_KHR_ray_tracing_pipeline
    VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_KHR = 1000150015,
    // Extension: VK_KHR_ray_tracing_pipeline
    VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR = 1000150016,
    // Extension: VK_KHR_acceleration_structure
    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR = 1000150017,
    // Extension: VK_KHR_ray_tracing_pipeline
    VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_INTERFACE_CREATE_INFO_KHR = 1000150018,
    // Extension: VK_KHR_acceleration_structure
    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR = 1000150020,
    // Extension: VK_NV_framebuffer_mixed_samples
    VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV = 1000152000,
    // Extension: VK_NV_shader_sm_builtins
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV = 1000154000,
    // Extension: VK_NV_shader_sm_builtins
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV = 1000154001,
    // Extension: VK_COMPUTE_VERSION_1_1
    VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO = 1000156000,
    // Extension: VK_COMPUTE_VERSION_1_1
    VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO = 1000156001,
    // Extension: VK_COMPUTE_VERSION_1_1
    VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO = 1000156002,
    // Extension: VK_COMPUTE_VERSION_1_1
    VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO = 1000156003,
    // Extension: VK_COMPUTE_VERSION_1_1
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES = 1000156004,
    // Extension: VK_COMPUTE_VERSION_1_1
    VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES = 1000156005,
    // Extension: VK_BASE_VERSION_1_1
    VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO = 1000157000,
    // Extension: VK_BASE_VERSION_1_1
    VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO = 1000157001,
    // Extension: VK_EXT_image_drm_format_modifier
    VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT = 1000158000,
    // Extension: VK_EXT_image_drm_format_modifier
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT = 1000158002,
    // Extension: VK_EXT_image_drm_format_modifier
    VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT = 1000158003,
    // Extension: VK_EXT_image_drm_format_modifier
    VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT = 1000158004,
    // Extension: VK_EXT_image_drm_format_modifier
    VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT = 1000158005,
    // Extension: VK_EXT_image_drm_format_modifier
    VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT = 1000158006,
    // Extension: VK_EXT_validation_cache
    VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT = 1000160000,
    // Extension: VK_EXT_validation_cache
    VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT = 1000160001,
    // Extension: VK_COMPUTE_VERSION_1_2
    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO = 1000161000,
    // Extension: VK_COMPUTE_VERSION_1_2
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES = 1000161001,
    // Extension: VK_COMPUTE_VERSION_1_2
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES = 1000161002,
    // Extension: VK_COMPUTE_VERSION_1_2
    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO = 1000161003,
    // Extension: VK_COMPUTE_VERSION_1_2
    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT = 1000161004,
    // Extension: VK_KHR_portability_subset
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_FEATURES_KHR = 1000163000,
    // Extension: VK_KHR_portability_subset
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_PROPERTIES_KHR = 1000163001,
    // Extension: VK_NV_shading_rate_image
    VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV = 1000164000,
    // Extension: VK_NV_shading_rate_image
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV = 1000164001,
    // Extension: VK_NV_shading_rate_image
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV = 1000164002,
    // Extension: VK_NV_shading_rate_image
    VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV = 1000164005,
    // Extension: VK_NV_ray_tracing
    VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV = 1000165000,
    // Extension: VK_NV_ray_tracing
    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV = 1000165001,
    // Extension: VK_NV_ray_tracing
    VK_STRUCTURE_TYPE_GEOMETRY_NV = 1000165003,
    // Extension: VK_NV_ray_tracing
    VK_STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV = 1000165004,
    // Extension: VK_NV_ray_tracing
    VK_STRUCTURE_TYPE_GEOMETRY_AABB_NV = 1000165005,
    // Extension: VK_NV_ray_tracing
    VK_STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV = 1000165006,
    // Extension: VK_NV_ray_tracing
    VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV = 1000165007,
    // Extension: VK_NV_ray_tracing
    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV = 1000165008,
    // Extension: VK_NV_ray_tracing
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV = 1000165009,
    // Extension: VK_NV_ray_tracing
    VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV = 1000165011,
    // Extension: VK_NV_ray_tracing
    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV = 1000165012,
    // Extension: VK_NV_representative_fragment_test
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV = 1000166000,
    // Extension: VK_NV_representative_fragment_test
    VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV = 1000166001,
    // Extension: VK_COMPUTE_VERSION_1_1
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES = 1000168000,
    // Extension: VK_COMPUTE_VERSION_1_1
    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT = 1000168001,
    // Extension: VK_EXT_filter_cubic
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT = 1000170000,
    // Extension: VK_EXT_filter_cubic
    VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT = 1000170001,
    // Extension: VK_BASE_VERSION_1_4
    VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO = 1000174000,
    // Extension: VK_COMPUTE_VERSION_1_2
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES = 1000175000,
    // Extension: VK_COMPUTE_VERSION_1_2
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES = 1000177000,
    // Extension: VK_EXT_external_memory_host
    VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT = 1000178000,
    // Extension: VK_EXT_external_memory_host
    VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT = 1000178001,
    // Extension: VK_EXT_external_memory_host
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT = 1000178002,
    // Extension: VK_COMPUTE_VERSION_1_2
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES = 1000180000,
    // Extension: VK_KHR_shader_clock
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR = 1000181000,
    // Extension: VK_AMD_pipeline_compiler_control
    VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD = 1000183000,
    // Extension: VK_KHR_calibrated_timestamps
    VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_KHR = 1000184000,
    // Extension: VK_AMD_shader_core_properties
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD = 1000185000,
    // Extension: VK_KHR_video_decode_h265
    VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_CAPABILITIES_KHR = 1000187000,
    // Extension: VK_KHR_video_decode_h265
    VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR = 1000187001,
    // Extension: VK_KHR_video_decode_h265
    VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR = 1000187002,
    // Extension: VK_KHR_video_decode_h265
    VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PROFILE_INFO_KHR = 1000187003,
    // Extension: VK_KHR_video_decode_h265
    VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PICTURE_INFO_KHR = 1000187004,
    // Extension: VK_KHR_video_decode_h265
    VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_DPB_SLOT_INFO_KHR = 1000187005,
    // Extension: VK_AMD_memory_overallocation_behavior
    VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD = 1000189000,
    // Extension: VK_EXT_vertex_attribute_divisor
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT = 1000190000,
    // Extension: VK_GRAPHICS_VERSION_1_4
    VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO = 1000190001,
    // Extension: VK_GRAPHICS_VERSION_1_4
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES = 1000190002,
    // Extension: VK_GGP_frame_token
    VK_STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP = 1000191000,
    // Extension: VK_COMPUTE_VERSION_1_3
    VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO = 1000192000,
    // Extension: VK_BASE_VERSION_1_2
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES = 1000196000,
    // Extension: VK_COMPUTE_VERSION_1_2
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES = 1000197000,
    // Extension: VK_GRAPHICS_VERSION_1_2
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES = 1000199000,
    // Extension: VK_GRAPHICS_VERSION_1_2
    VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE = 1000199001,
    // Extension: VK_KHR_compute_shader_derivatives
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_KHR = 1000201000,
    // Extension: VK_NV_mesh_shader
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV = 1000202000,
    // Extension: VK_NV_mesh_shader
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV = 1000202001,
    // Extension: VK_KHR_fragment_shader_barycentric
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR = 1000203000,
    // Extension: VK_NV_shader_image_footprint
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV = 1000204000,
    // Extension: VK_NV_scissor_exclusive
    VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV = 1000205000,
    // Extension: VK_NV_scissor_exclusive
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV = 1000205002,
    // Extension: VK_NV_device_diagnostic_checkpoints
    VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV = 1000206000,
    // Extension: VK_NV_device_diagnostic_checkpoints
    VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV = 1000206001,
    // Extension: VK_BASE_VERSION_1_2
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES = 1000207000,
    // Extension: VK_BASE_VERSION_1_2
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES = 1000207001,
    // Extension: VK_BASE_VERSION_1_2
    VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO = 1000207002,
    // Extension: VK_BASE_VERSION_1_2
    VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO = 1000207003,
    // Extension: VK_BASE_VERSION_1_2
    VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO = 1000207004,
    // Extension: VK_BASE_VERSION_1_2
    VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO = 1000207005,
    // Extension: VK_EXT_present_timing
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_TIMING_FEATURES_EXT = 1000208000,
    // Extension: VK_EXT_present_timing
    VK_STRUCTURE_TYPE_SWAPCHAIN_TIMING_PROPERTIES_EXT = 1000208001,
    // Extension: VK_EXT_present_timing
    VK_STRUCTURE_TYPE_SWAPCHAIN_TIME_DOMAIN_PROPERTIES_EXT = 1000208002,
    // Extension: VK_EXT_present_timing
    VK_STRUCTURE_TYPE_PRESENT_TIMINGS_INFO_EXT = 1000208003,
    // Extension: VK_EXT_present_timing
    VK_STRUCTURE_TYPE_PRESENT_TIMING_INFO_EXT = 1000208004,
    // Extension: VK_EXT_present_timing
    VK_STRUCTURE_TYPE_PAST_PRESENTATION_TIMING_INFO_EXT = 1000208005,
    // Extension: VK_EXT_present_timing
    VK_STRUCTURE_TYPE_PAST_PRESENTATION_TIMING_PROPERTIES_EXT = 1000208006,
    // Extension: VK_EXT_present_timing
    VK_STRUCTURE_TYPE_PAST_PRESENTATION_TIMING_EXT = 1000208007,
    // Extension: VK_EXT_present_timing
    VK_STRUCTURE_TYPE_PRESENT_TIMING_SURFACE_CAPABILITIES_EXT = 1000208008,
    // Extension: VK_EXT_present_timing
    VK_STRUCTURE_TYPE_SWAPCHAIN_CALIBRATED_TIMESTAMP_INFO_EXT = 1000208009,
    // Extension: VK_INTEL_shader_integer_functions2
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL = 1000209000,
    // Extension: VK_INTEL_performance_query
    VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL = 1000210000,
    // Extension: VK_INTEL_performance_query
    VK_STRUCTURE_TYPE_INITIALIZE_PERFORMANCE_API_INFO_INTEL = 1000210001,
    // Extension: VK_INTEL_performance_query
    VK_STRUCTURE_TYPE_PERFORMANCE_MARKER_INFO_INTEL = 1000210002,
    // Extension: VK_INTEL_performance_query
    VK_STRUCTURE_TYPE_PERFORMANCE_STREAM_MARKER_INFO_INTEL = 1000210003,
    // Extension: VK_INTEL_performance_query
    VK_STRUCTURE_TYPE_PERFORMANCE_OVERRIDE_INFO_INTEL = 1000210004,
    // Extension: VK_INTEL_performance_query
    VK_STRUCTURE_TYPE_PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL = 1000210005,
    // Extension: VK_BASE_VERSION_1_2
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES = 1000211000,
    // Extension: VK_EXT_pci_bus_info
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT = 1000212000,
    // Extension: VK_AMD_display_native_hdr
    VK_STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD = 1000213000,
    // Extension: VK_AMD_display_native_hdr
    VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD = 1000213001,
    // Extension: VK_FUCHSIA_imagepipe_surface
    VK_STRUCTURE_TYPE_IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA = 1000214000,
    // Extension: VK_COMPUTE_VERSION_1_3
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES = 1000215000,
    // Extension: VK_EXT_metal_surface
    VK_STRUCTURE_TYPE_METAL_SURFACE_CREATE_INFO_EXT = 1000217000,
    // Extension: VK_EXT_fragment_density_map
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT = 1000218000,
    // Extension: VK_EXT_fragment_density_map
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT = 1000218001,
    // Extension: VK_EXT_fragment_density_map
    VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT = 1000218002,
    // Extension: VK_COMPUTE_VERSION_1_2
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES = 1000221000,
    // Extension: VK_COMPUTE_VERSION_1_3
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES = 1000225000,
    // Extension: VK_COMPUTE_VERSION_1_3
    VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO = 1000225001,
    // Extension: VK_COMPUTE_VERSION_1_3
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES = 1000225002,
    // Extension: VK_KHR_fragment_shading_rate
    VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR = 1000226000,
    // Extension: VK_KHR_fragment_shading_rate
    VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR = 1000226001,
    // Extension: VK_KHR_fragment_shading_rate
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR = 1000226002,
    // Extension: VK_KHR_fragment_shading_rate
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR = 1000226003,
    // Extension: VK_KHR_fragment_shading_rate
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR = 1000226004,
    // Extension: VK_AMD_shader_core_properties2
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD = 1000227000,
    // Extension: VK_AMD_device_coherent_memory
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD = 1000229000,
    // Extension: VK_GRAPHICS_VERSION_1_4
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_LOCAL_READ_FEATURES = 1000232000,
    // Extension: VK_GRAPHICS_VERSION_1_4
    VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_LOCATION_INFO = 1000232001,
    // Extension: VK_GRAPHICS_VERSION_1_4
    VK_STRUCTURE_TYPE_RENDERING_INPUT_ATTACHMENT_INDEX_INFO = 1000232002,
    // Extension: VK_EXT_shader_image_atomic_int64
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT = 1000234000,
    // Extension: VK_KHR_shader_quad_control
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_QUAD_CONTROL_FEATURES_KHR = 1000235000,
    // Extension: VK_EXT_memory_budget
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT = 1000237000,
    // Extension: VK_EXT_memory_priority
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT = 1000238000,
    // Extension: VK_EXT_memory_priority
    VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT = 1000238001,
    // Extension: VK_KHR_surface_protected_capabilities
    VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR = 1000239000,
    // Extension: VK_NV_dedicated_allocation_image_aliasing
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV = 1000240000,
    // Extension: VK_GRAPHICS_VERSION_1_2
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES = 1000241000,
    // Extension: VK_GRAPHICS_VERSION_1_2
    VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT = 1000241001,
    // Extension: VK_GRAPHICS_VERSION_1_2
    VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT = 1000241002,
    // Extension: VK_EXT_buffer_device_address
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT = 1000244000,
    // Extension: VK_BASE_VERSION_1_2
    VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO = 1000244001,
    // Extension: VK_EXT_buffer_device_address
    VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT = 1000244002,
    // Extension: VK_BASE_VERSION_1_3
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES = 1000245000,
    // Extension: VK_GRAPHICS_VERSION_1_2
    VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO = 1000246000,
    // Extension: VK_EXT_validation_features
    VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT = 1000247000,
    // Extension: VK_KHR_present_wait
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR = 1000248000,
    // Extension: VK_NV_cooperative_matrix
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV = 1000249000,
    // Extension: VK_NV_cooperative_matrix
    VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_NV = 1000249001,
    // Extension: VK_NV_cooperative_matrix
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV = 1000249002,
    // Extension: VK_NV_coverage_reduction_mode
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV = 1000250000,
    // Extension: VK_NV_coverage_reduction_mode
    VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV = 1000250001,
    // Extension: VK_NV_coverage_reduction_mode
    VK_STRUCTURE_TYPE_FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV = 1000250002,
    // Extension: VK_EXT_fragment_shader_interlock
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT = 1000251000,
    // Extension: VK_EXT_ycbcr_image_arrays
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT = 1000252000,
    // Extension: VK_COMPUTE_VERSION_1_2
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES = 1000253000,
    // Extension: VK_EXT_provoking_vertex
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT = 1000254000,
    // Extension: VK_EXT_provoking_vertex
    VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT = 1000254001,
    // Extension: VK_EXT_provoking_vertex
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT = 1000254002,
    // Extension: VK_EXT_full_screen_exclusive
    VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT = 1000255000,
    // Extension: VK_EXT_full_screen_exclusive
    VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT = 1000255001,
    // Extension: VK_EXT_full_screen_exclusive
    VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT = 1000255002,
    // Extension: VK_EXT_headless_surface
    VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT = 1000256000,
    // Extension: VK_BASE_VERSION_1_2
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES = 1000257000,
    // Extension: VK_BASE_VERSION_1_2
    VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO = 1000257002,
    // Extension: VK_BASE_VERSION_1_2
    VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO = 1000257003,
    // Extension: VK_BASE_VERSION_1_2
    VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO = 1000257004,
    // Extension: VK_GRAPHICS_VERSION_1_4
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES = 1000259000,
    // Extension: VK_GRAPHICS_VERSION_1_4
    VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO = 1000259001,
    // Extension: VK_GRAPHICS_VERSION_1_4
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES = 1000259002,
    // Extension: VK_EXT_shader_atomic_float
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT = 1000260000,
    // Extension: VK_BASE_VERSION_1_2
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES = 1000261000,
    // Extension: VK_BASE_VERSION_1_4
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES = 1000265000,
    // Extension: VK_EXT_extended_dynamic_state
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT = 1000267000,
    // Extension: VK_KHR_pipeline_executable_properties
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR = 1000269000,
    // Extension: VK_KHR_pipeline_executable_properties
    VK_STRUCTURE_TYPE_PIPELINE_INFO_KHR = 1000269001,
    // Extension: VK_KHR_pipeline_executable_properties
    VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_PROPERTIES_KHR = 1000269002,
    // Extension: VK_KHR_pipeline_executable_properties
    VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INFO_KHR = 1000269003,
    // Extension: VK_KHR_pipeline_executable_properties
    VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_STATISTIC_KHR = 1000269004,
    // Extension: VK_KHR_pipeline_executable_properties
    VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR = 1000269005,
    // Extension: VK_BASE_VERSION_1_4
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES = 1000270000,
    // Extension: VK_BASE_VERSION_1_4
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_PROPERTIES = 1000270001,
    // Extension: VK_BASE_VERSION_1_4
    VK_STRUCTURE_TYPE_MEMORY_TO_IMAGE_COPY = 1000270002,
    // Extension: VK_BASE_VERSION_1_4
    VK_STRUCTURE_TYPE_IMAGE_TO_MEMORY_COPY = 1000270003,
    // Extension: VK_BASE_VERSION_1_4
    VK_STRUCTURE_TYPE_COPY_IMAGE_TO_MEMORY_INFO = 1000270004,
    // Extension: VK_BASE_VERSION_1_4
    VK_STRUCTURE_TYPE_COPY_MEMORY_TO_IMAGE_INFO = 1000270005,
    // Extension: VK_BASE_VERSION_1_4
    VK_STRUCTURE_TYPE_HOST_IMAGE_LAYOUT_TRANSITION_INFO = 1000270006,
    // Extension: VK_BASE_VERSION_1_4
    VK_STRUCTURE_TYPE_COPY_IMAGE_TO_IMAGE_INFO = 1000270007,
    // Extension: VK_BASE_VERSION_1_4
    VK_STRUCTURE_TYPE_SUBRESOURCE_HOST_MEMCPY_SIZE = 1000270008,
    // Extension: VK_BASE_VERSION_1_4
    VK_STRUCTURE_TYPE_HOST_IMAGE_COPY_DEVICE_PERFORMANCE_QUERY = 1000270009,
    // Extension: VK_BASE_VERSION_1_4
    VK_STRUCTURE_TYPE_MEMORY_MAP_INFO = 1000271000,
    // Extension: VK_BASE_VERSION_1_4
    VK_STRUCTURE_TYPE_MEMORY_UNMAP_INFO = 1000271001,
    // Extension: VK_EXT_map_memory_placed
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_FEATURES_EXT = 1000272000,
    // Extension: VK_EXT_map_memory_placed
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_PROPERTIES_EXT = 1000272001,
    // Extension: VK_EXT_map_memory_placed
    VK_STRUCTURE_TYPE_MEMORY_MAP_PLACED_INFO_EXT = 1000272002,
    // Extension: VK_EXT_shader_atomic_float2
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT = 1000273000,
    // Extension: VK_KHR_surface_maintenance1
    VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_KHR = 1000274000,
    // Extension: VK_KHR_surface_maintenance1
    VK_STRUCTURE_TYPE_SURFACE_PRESENT_SCALING_CAPABILITIES_KHR = 1000274001,
    // Extension: VK_KHR_surface_maintenance1
    VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_COMPATIBILITY_KHR = 1000274002,
    // Extension: VK_KHR_swapchain_maintenance1
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_KHR = 1000275000,
    // Extension: VK_KHR_swapchain_maintenance1
    VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_KHR = 1000275001,
    // Extension: VK_KHR_swapchain_maintenance1
    VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODES_CREATE_INFO_KHR = 1000275002,
    // Extension: VK_KHR_swapchain_maintenance1
    VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODE_INFO_KHR = 1000275003,
    // Extension: VK_KHR_swapchain_maintenance1
    VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_SCALING_CREATE_INFO_KHR = 1000275004,
    // Extension: VK_KHR_swapchain_maintenance1
    VK_STRUCTURE_TYPE_RELEASE_SWAPCHAIN_IMAGES_INFO_KHR = 1000275005,
    // Extension: VK_COMPUTE_VERSION_1_3
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES = 1000276000,
    // Extension: VK_NV_device_generated_commands
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV = 1000277000,
    // Extension: VK_NV_device_generated_commands
    VK_STRUCTURE_TYPE_GRAPHICS_SHADER_GROUP_CREATE_INFO_NV = 1000277001,
    // Extension: VK_NV_device_generated_commands
    VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV = 1000277002,
    // Extension: VK_NV_device_generated_commands
    VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_NV = 1000277003,
    // Extension: VK_NV_device_generated_commands
    VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NV = 1000277004,
    // Extension: VK_NV_device_generated_commands
    VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_NV = 1000277005,
    // Extension: VK_NV_device_generated_commands
    VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_NV = 1000277006,
    // Extension: VK_NV_device_generated_commands
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV = 1000277007,
    // Extension: VK_NV_inherited_viewport_scissor
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV = 1000278000,
    // Extension: VK_NV_inherited_viewport_scissor
    VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_VIEWPORT_SCISSOR_INFO_NV = 1000278001,
    // Extension: VK_COMPUTE_VERSION_1_3
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES = 1000280000,
    // Extension: VK_COMPUTE_VERSION_1_3
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES = 1000280001,
    // Extension: VK_EXT_texel_buffer_alignment
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT = 1000281000,
    // Extension: VK_COMPUTE_VERSION_1_3
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES = 1000281001,
    // Extension: VK_QCOM_render_pass_transform
    VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM = 1000282000,
    // Extension: VK_QCOM_render_pass_transform
    VK_STRUCTURE_TYPE_RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM = 1000282001,
    // Extension: VK_EXT_depth_bias_control
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_BIAS_CONTROL_FEATURES_EXT = 1000283000,
    // Extension: VK_EXT_depth_bias_control
    VK_STRUCTURE_TYPE_DEPTH_BIAS_INFO_EXT = 1000283001,
    // Extension: VK_EXT_depth_bias_control
    VK_STRUCTURE_TYPE_DEPTH_BIAS_REPRESENTATION_INFO_EXT = 1000283002,
    // Extension: VK_EXT_device_memory_report
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT = 1000284000,
    // Extension: VK_EXT_device_memory_report
    VK_STRUCTURE_TYPE_DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT = 1000284001,
    // Extension: VK_EXT_device_memory_report
    VK_STRUCTURE_TYPE_DEVICE_MEMORY_REPORT_CALLBACK_DATA_EXT = 1000284002,
    // Extension: VK_KHR_robustness2
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_KHR = 1000286000,
    // Extension: VK_KHR_robustness2
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_KHR = 1000286001,
    // Extension: VK_EXT_custom_border_color
    VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT = 1000287000,
    // Extension: VK_EXT_custom_border_color
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT = 1000287001,
    // Extension: VK_EXT_custom_border_color
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT = 1000287002,
    // Extension: VK_KHR_pipeline_library
    VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR = 1000290000,
    // Extension: VK_NV_present_barrier
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_BARRIER_FEATURES_NV = 1000292000,
    // Extension: VK_NV_present_barrier
    VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_BARRIER_NV = 1000292001,
    // Extension: VK_NV_present_barrier
    VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_BARRIER_CREATE_INFO_NV = 1000292002,
    // Extension: VK_KHR_present_id
    VK_STRUCTURE_TYPE_PRESENT_ID_KHR = 1000294000,
    // Extension: VK_KHR_present_id
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR = 1000294001,
    // Extension: VK_BASE_VERSION_1_3
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES = 1000295000,
    // Extension: VK_BASE_VERSION_1_3
    VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO = 1000295001,
    // Extension: VK_BASE_VERSION_1_3
    VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO = 1000295002,
    // Extension: VK_COMPUTE_VERSION_1_3
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES = 1000297000,
    // Extension: VKSC_VERSION_1_0
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_SC_1_0_FEATURES = 1000298000,
    // Extension: VKSC_VERSION_1_0
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_SC_1_0_PROPERTIES = 1000298001,
    // Extension: VKSC_VERSION_1_0
    VK_STRUCTURE_TYPE_DEVICE_OBJECT_RESERVATION_CREATE_INFO = 1000298002,
    // Extension: VKSC_VERSION_1_0
    VK_STRUCTURE_TYPE_COMMAND_POOL_MEMORY_RESERVATION_CREATE_INFO = 1000298003,
    // Extension: VKSC_VERSION_1_0
    VK_STRUCTURE_TYPE_COMMAND_POOL_MEMORY_CONSUMPTION = 1000298004,
    // Extension: VKSC_VERSION_1_0
    VK_STRUCTURE_TYPE_PIPELINE_POOL_SIZE = 1000298005,
    // Extension: VKSC_VERSION_1_0
    VK_STRUCTURE_TYPE_FAULT_DATA = 1000298007,
    // Extension: VKSC_VERSION_1_0
    VK_STRUCTURE_TYPE_FAULT_CALLBACK_INFO = 1000298008,
    // Extension: VKSC_VERSION_1_0
    VK_STRUCTURE_TYPE_PIPELINE_OFFLINE_CREATE_INFO = 1000298010,
    // Extension: VK_KHR_video_encode_queue
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_INFO_KHR = 1000299000,
    // Extension: VK_KHR_video_encode_queue
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_INFO_KHR = 1000299001,
    // Extension: VK_KHR_video_encode_queue
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_LAYER_INFO_KHR = 1000299002,
    // Extension: VK_KHR_video_encode_queue
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_CAPABILITIES_KHR = 1000299003,
    // Extension: VK_KHR_video_encode_queue
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_USAGE_INFO_KHR = 1000299004,
    // Extension: VK_KHR_video_encode_queue
    VK_STRUCTURE_TYPE_QUERY_POOL_VIDEO_ENCODE_FEEDBACK_CREATE_INFO_KHR = 1000299005,
    // Extension: VK_KHR_video_encode_queue
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR = 1000299006,
    // Extension: VK_KHR_video_encode_queue
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_PROPERTIES_KHR = 1000299007,
    // Extension: VK_KHR_video_encode_queue
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR = 1000299008,
    // Extension: VK_KHR_video_encode_queue
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_GET_INFO_KHR = 1000299009,
    // Extension: VK_KHR_video_encode_queue
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_FEEDBACK_INFO_KHR = 1000299010,
    // Extension: VK_NV_device_diagnostics_config
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV = 1000300000,
    // Extension: VK_NV_device_diagnostics_config
    VK_STRUCTURE_TYPE_DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV = 1000300001,
    // Extension: VK_NV_cuda_kernel_launch
    VK_STRUCTURE_TYPE_CUDA_MODULE_CREATE_INFO_NV = 1000307000,
    // Extension: VK_NV_cuda_kernel_launch
    VK_STRUCTURE_TYPE_CUDA_FUNCTION_CREATE_INFO_NV = 1000307001,
    // Extension: VK_NV_cuda_kernel_launch
    VK_STRUCTURE_TYPE_CUDA_LAUNCH_INFO_NV = 1000307002,
    // Extension: VK_NV_cuda_kernel_launch
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUDA_KERNEL_LAUNCH_FEATURES_NV = 1000307003,
    // Extension: VK_NV_cuda_kernel_launch
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUDA_KERNEL_LAUNCH_PROPERTIES_NV = 1000307004,
    // Extension: VK_KHR_object_refresh
    VK_STRUCTURE_TYPE_REFRESH_OBJECT_LIST_KHR = 1000308000,
    // Extension: VK_QCOM_tile_shading
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_SHADING_FEATURES_QCOM = 1000309000,
    // Extension: VK_QCOM_tile_shading
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_SHADING_PROPERTIES_QCOM = 1000309001,
    // Extension: VK_QCOM_tile_shading
    VK_STRUCTURE_TYPE_RENDER_PASS_TILE_SHADING_CREATE_INFO_QCOM = 1000309002,
    // Extension: VK_QCOM_tile_shading
    VK_STRUCTURE_TYPE_PER_TILE_BEGIN_INFO_QCOM = 1000309003,
    // Extension: VK_QCOM_tile_shading
    VK_STRUCTURE_TYPE_PER_TILE_END_INFO_QCOM = 1000309004,
    // Extension: VK_QCOM_tile_shading
    VK_STRUCTURE_TYPE_DISPATCH_TILE_INFO_QCOM = 1000309005,
    // Extension: VK_NV_low_latency
    VK_STRUCTURE_TYPE_QUERY_LOW_LATENCY_SUPPORT_NV = 1000310000,
    // Extension: VK_EXT_metal_objects
    VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT = 1000311000,
    // Extension: VK_EXT_metal_objects
    VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECTS_INFO_EXT = 1000311001,
    // Extension: VK_EXT_metal_objects
    VK_STRUCTURE_TYPE_EXPORT_METAL_DEVICE_INFO_EXT = 1000311002,
    // Extension: VK_EXT_metal_objects
    VK_STRUCTURE_TYPE_EXPORT_METAL_COMMAND_QUEUE_INFO_EXT = 1000311003,
    // Extension: VK_EXT_metal_objects
    VK_STRUCTURE_TYPE_EXPORT_METAL_BUFFER_INFO_EXT = 1000311004,
    // Extension: VK_EXT_metal_objects
    VK_STRUCTURE_TYPE_IMPORT_METAL_BUFFER_INFO_EXT = 1000311005,
    // Extension: VK_EXT_metal_objects
    VK_STRUCTURE_TYPE_EXPORT_METAL_TEXTURE_INFO_EXT = 1000311006,
    // Extension: VK_EXT_metal_objects
    VK_STRUCTURE_TYPE_IMPORT_METAL_TEXTURE_INFO_EXT = 1000311007,
    // Extension: VK_EXT_metal_objects
    VK_STRUCTURE_TYPE_EXPORT_METAL_IO_SURFACE_INFO_EXT = 1000311008,
    // Extension: VK_EXT_metal_objects
    VK_STRUCTURE_TYPE_IMPORT_METAL_IO_SURFACE_INFO_EXT = 1000311009,
    // Extension: VK_EXT_metal_objects
    VK_STRUCTURE_TYPE_EXPORT_METAL_SHARED_EVENT_INFO_EXT = 1000311010,
    // Extension: VK_EXT_metal_objects
    VK_STRUCTURE_TYPE_IMPORT_METAL_SHARED_EVENT_INFO_EXT = 1000311011,
    // Extension: VK_BASE_VERSION_1_3
    VK_STRUCTURE_TYPE_MEMORY_BARRIER_2 = 1000314000,
    // Extension: VK_BASE_VERSION_1_3
    VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2 = 1000314001,
    // Extension: VK_BASE_VERSION_1_3
    VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2 = 1000314002,
    // Extension: VK_BASE_VERSION_1_3
    VK_STRUCTURE_TYPE_DEPENDENCY_INFO = 1000314003,
    // Extension: VK_BASE_VERSION_1_3
    VK_STRUCTURE_TYPE_SUBMIT_INFO_2 = 1000314004,
    // Extension: VK_BASE_VERSION_1_3
    VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO = 1000314005,
    // Extension: VK_BASE_VERSION_1_3
    VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO = 1000314006,
    // Extension: VK_BASE_VERSION_1_3
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES = 1000314007,
    // Extension: VK_NV_device_diagnostic_checkpoints
    VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV = 1000314008,
    // Extension: VK_NV_device_diagnostic_checkpoints
    VK_STRUCTURE_TYPE_CHECKPOINT_DATA_2_NV = 1000314009,
    // Extension: VK_EXT_descriptor_buffer
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_PROPERTIES_EXT = 1000316000,
    // Extension: VK_EXT_descriptor_buffer
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_DENSITY_MAP_PROPERTIES_EXT = 1000316001,
    // Extension: VK_EXT_descriptor_buffer
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_FEATURES_EXT = 1000316002,
    // Extension: VK_EXT_descriptor_buffer
    VK_STRUCTURE_TYPE_DESCRIPTOR_ADDRESS_INFO_EXT = 1000316003,
    // Extension: VK_EXT_descriptor_buffer
    VK_STRUCTURE_TYPE_DESCRIPTOR_GET_INFO_EXT = 1000316004,
    // Extension: VK_EXT_descriptor_buffer
    VK_STRUCTURE_TYPE_BUFFER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT = 1000316005,
    // Extension: VK_EXT_descriptor_buffer
    VK_STRUCTURE_TYPE_IMAGE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT = 1000316006,
    // Extension: VK_EXT_descriptor_buffer
    VK_STRUCTURE_TYPE_IMAGE_VIEW_CAPTURE_DESCRIPTOR_DATA_INFO_EXT = 1000316007,
    // Extension: VK_EXT_descriptor_buffer
    VK_STRUCTURE_TYPE_SAMPLER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT = 1000316008,
    // Extension: VK_EXT_descriptor_buffer
    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT = 1000316009,
    // Extension: VK_EXT_descriptor_buffer
    VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT = 1000316010,
    // Extension: VK_EXT_descriptor_buffer
    VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_INFO_EXT = 1000316011,
    // Extension: VK_EXT_descriptor_buffer
    VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_PUSH_DESCRIPTOR_BUFFER_HANDLE_EXT = 1000316012,
    // Extension: VK_EXT_graphics_pipeline_library
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT = 1000320000,
    // Extension: VK_EXT_graphics_pipeline_library
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_PROPERTIES_EXT = 1000320001,
    // Extension: VK_EXT_graphics_pipeline_library
    VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_LIBRARY_CREATE_INFO_EXT = 1000320002,
    // Extension: VK_AMD_shader_early_and_late_fragment_tests
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_FEATURES_AMD = 1000321000,
    // Extension: VK_KHR_fragment_shader_barycentric
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_PROPERTIES_KHR = 1000322000,
    // Extension: VK_KHR_shader_subgroup_uniform_control_flow
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR = 1000323000,
    // Extension: VK_COMPUTE_VERSION_1_3
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES = 1000325000,
    // Extension: VK_NV_fragment_shading_rate_enums
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV = 1000326000,
    // Extension: VK_NV_fragment_shading_rate_enums
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV = 1000326001,
    // Extension: VK_NV_fragment_shading_rate_enums
    VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV = 1000326002,
    // Extension: VK_NV_ray_tracing_motion_blur
    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_MOTION_TRIANGLES_DATA_NV = 1000327000,
    // Extension: VK_NV_ray_tracing_motion_blur
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV = 1000327001,
    // Extension: VK_NV_ray_tracing_motion_blur
    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MOTION_INFO_NV = 1000327002,
    // Extension: VK_EXT_mesh_shader
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT = 1000328000,
    // Extension: VK_EXT_mesh_shader
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_EXT = 1000328001,
    // Extension: VK_EXT_ycbcr_2plane_444_formats
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT = 1000330000,
    // Extension: VK_EXT_fragment_density_map2
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT = 1000332000,
    // Extension: VK_EXT_fragment_density_map2
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT = 1000332001,
    // Extension: VK_QCOM_rotated_copy_commands
    VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM = 1000333000,
    // Extension: VK_COMPUTE_VERSION_1_3
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES = 1000335000,
    // Extension: VK_KHR_workgroup_memory_explicit_layout
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR = 1000336000,
    // Extension: VK_BASE_VERSION_1_3
    VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2 = 1000337000,
    // Extension: VK_BASE_VERSION_1_3
    VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2 = 1000337001,
    // Extension: VK_BASE_VERSION_1_3
    VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2 = 1000337002,
    // Extension: VK_BASE_VERSION_1_3
    VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2 = 1000337003,
    // Extension: VK_GRAPHICS_VERSION_1_3
    VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2 = 1000337004,
    // Extension: VK_GRAPHICS_VERSION_1_3
    VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2 = 1000337005,
    // Extension: VK_BASE_VERSION_1_3
    VK_STRUCTURE_TYPE_BUFFER_COPY_2 = 1000337006,
    // Extension: VK_BASE_VERSION_1_3
    VK_STRUCTURE_TYPE_IMAGE_COPY_2 = 1000337007,
    // Extension: VK_GRAPHICS_VERSION_1_3
    VK_STRUCTURE_TYPE_IMAGE_BLIT_2 = 1000337008,
    // Extension: VK_BASE_VERSION_1_3
    VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2 = 1000337009,
    // Extension: VK_GRAPHICS_VERSION_1_3
    VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2 = 1000337010,
    // Extension: VK_EXT_image_compression_control
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT = 1000338000,
    // Extension: VK_EXT_image_compression_control
    VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT = 1000338001,
    // Extension: VK_BASE_VERSION_1_4
    VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2 = 1000338002,
    // Extension: VK_BASE_VERSION_1_4
    VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2 = 1000338003,
    // Extension: VK_EXT_image_compression_control
    VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT = 1000338004,
    // Extension: VK_EXT_attachment_feedback_loop_layout
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT = 1000339000,
    // Extension: VK_EXT_4444_formats
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT = 1000340000,
    // Extension: VK_EXT_device_fault
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FAULT_FEATURES_EXT = 1000341000,
    // Extension: VK_EXT_device_fault
    VK_STRUCTURE_TYPE_DEVICE_FAULT_COUNTS_EXT = 1000341001,
    // Extension: VK_EXT_device_fault
    VK_STRUCTURE_TYPE_DEVICE_FAULT_INFO_EXT = 1000341002,
    // Extension: VK_EXT_rasterization_order_attachment_access
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT = 1000342000,
    // Extension: VK_EXT_rgba10x6_formats
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT = 1000344000,
    // Extension: VK_EXT_directfb_surface
    VK_STRUCTURE_TYPE_DIRECTFB_SURFACE_CREATE_INFO_EXT = 1000346000,
    // Extension: VK_KHR_ray_tracing_pipeline
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR = 1000347000,
    // Extension: VK_KHR_ray_tracing_pipeline
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR = 1000347001,
    // Extension: VK_KHR_ray_query
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR = 1000348013,
    // Extension: VK_EXT_mutable_descriptor_type
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT = 1000351000,
    // Extension: VK_EXT_mutable_descriptor_type
    VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT = 1000351002,
    // Extension: VK_EXT_vertex_input_dynamic_state
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT = 1000352000,
    // Extension: VK_EXT_shader_object
    // Extension: VK_EXT_vertex_input_dynamic_state
    VK_STRUCTURE_TYPE_VERTEX_INPUT_BINDING_DESCRIPTION_2_EXT = 1000352001,
    // Extension: VK_EXT_shader_object
    // Extension: VK_EXT_vertex_input_dynamic_state
    VK_STRUCTURE_TYPE_VERTEX_INPUT_ATTRIBUTE_DESCRIPTION_2_EXT = 1000352002,
    // Extension: VK_EXT_physical_device_drm
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRM_PROPERTIES_EXT = 1000353000,
    // Extension: VK_EXT_device_address_binding_report
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ADDRESS_BINDING_REPORT_FEATURES_EXT = 1000354000,
    // Extension: VK_EXT_device_address_binding_report
    VK_STRUCTURE_TYPE_DEVICE_ADDRESS_BINDING_CALLBACK_DATA_EXT = 1000354001,
    // Extension: VK_EXT_depth_clip_control
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT = 1000355000,
    // Extension: VK_EXT_depth_clip_control
    VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLIP_CONTROL_CREATE_INFO_EXT = 1000355001,
    // Extension: VK_EXT_primitive_topology_list_restart
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT = 1000356000,
    // Extension: VK_BASE_VERSION_1_3
    VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3 = 1000360000,
    // Extension: VK_KHR_present_mode_fifo_latest_ready
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_MODE_FIFO_LATEST_READY_FEATURES_KHR = 1000361000,
    // Extension: VK_FUCHSIA_external_memory
    VK_STRUCTURE_TYPE_IMPORT_MEMORY_ZIRCON_HANDLE_INFO_FUCHSIA = 1000364000,
    // Extension: VK_FUCHSIA_external_memory
    VK_STRUCTURE_TYPE_MEMORY_ZIRCON_HANDLE_PROPERTIES_FUCHSIA = 1000364001,
    // Extension: VK_FUCHSIA_external_memory
    VK_STRUCTURE_TYPE_MEMORY_GET_ZIRCON_HANDLE_INFO_FUCHSIA = 1000364002,
    // Extension: VK_FUCHSIA_external_semaphore
    VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_ZIRCON_HANDLE_INFO_FUCHSIA = 1000365000,
    // Extension: VK_FUCHSIA_external_semaphore
    VK_STRUCTURE_TYPE_SEMAPHORE_GET_ZIRCON_HANDLE_INFO_FUCHSIA = 1000365001,
    // Extension: VK_FUCHSIA_buffer_collection
    VK_STRUCTURE_TYPE_BUFFER_COLLECTION_CREATE_INFO_FUCHSIA = 1000366000,
    // Extension: VK_FUCHSIA_buffer_collection
    VK_STRUCTURE_TYPE_IMPORT_MEMORY_BUFFER_COLLECTION_FUCHSIA = 1000366001,
    // Extension: VK_FUCHSIA_buffer_collection
    VK_STRUCTURE_TYPE_BUFFER_COLLECTION_IMAGE_CREATE_INFO_FUCHSIA = 1000366002,
    // Extension: VK_FUCHSIA_buffer_collection
    VK_STRUCTURE_TYPE_BUFFER_COLLECTION_PROPERTIES_FUCHSIA = 1000366003,
    // Extension: VK_FUCHSIA_buffer_collection
    VK_STRUCTURE_TYPE_BUFFER_CONSTRAINTS_INFO_FUCHSIA = 1000366004,
    // Extension: VK_FUCHSIA_buffer_collection
    VK_STRUCTURE_TYPE_BUFFER_COLLECTION_BUFFER_CREATE_INFO_FUCHSIA = 1000366005,
    // Extension: VK_FUCHSIA_buffer_collection
    VK_STRUCTURE_TYPE_IMAGE_CONSTRAINTS_INFO_FUCHSIA = 1000366006,
    // Extension: VK_FUCHSIA_buffer_collection
    VK_STRUCTURE_TYPE_IMAGE_FORMAT_CONSTRAINTS_INFO_FUCHSIA = 1000366007,
    // Extension: VK_FUCHSIA_buffer_collection
    VK_STRUCTURE_TYPE_SYSMEM_COLOR_SPACE_FUCHSIA = 1000366008,
    // Extension: VK_FUCHSIA_buffer_collection
    VK_STRUCTURE_TYPE_BUFFER_COLLECTION_CONSTRAINTS_INFO_FUCHSIA = 1000366009,
    // Extension: VK_HUAWEI_subpass_shading
    VK_STRUCTURE_TYPE_SUBPASS_SHADING_PIPELINE_CREATE_INFO_HUAWEI = 1000369000,
    // Extension: VK_HUAWEI_subpass_shading
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI = 1000369001,
    // Extension: VK_HUAWEI_subpass_shading
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_PROPERTIES_HUAWEI = 1000369002,
    // Extension: VK_HUAWEI_invocation_mask
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI = 1000370000,
    // Extension: VK_NV_external_memory_rdma
    VK_STRUCTURE_TYPE_MEMORY_GET_REMOTE_ADDRESS_INFO_NV = 1000371000,
    // Extension: VK_NV_external_memory_rdma
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_RDMA_FEATURES_NV = 1000371001,
    // Extension: VK_EXT_pipeline_properties
    VK_STRUCTURE_TYPE_PIPELINE_PROPERTIES_IDENTIFIER_EXT = 1000372000,
    // Extension: VK_EXT_pipeline_properties
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROPERTIES_FEATURES_EXT = 1000372001,
    // Extension: VK_NV_external_sci_sync2
    // Extension: VK_NV_external_sci_sync
    VK_STRUCTURE_TYPE_IMPORT_FENCE_SCI_SYNC_INFO_NV = 1000373000,
    // Extension: VK_NV_external_sci_sync2
    // Extension: VK_NV_external_sci_sync
    VK_STRUCTURE_TYPE_EXPORT_FENCE_SCI_SYNC_INFO_NV = 1000373001,
    // Extension: VK_NV_external_sci_sync2
    // Extension: VK_NV_external_sci_sync
    VK_STRUCTURE_TYPE_FENCE_GET_SCI_SYNC_INFO_NV = 1000373002,
    // Extension: VK_NV_external_sci_sync2
    // Extension: VK_NV_external_sci_sync
    VK_STRUCTURE_TYPE_SCI_SYNC_ATTRIBUTES_INFO_NV = 1000373003,
    // Extension: VK_NV_external_sci_sync
    VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_SCI_SYNC_INFO_NV = 1000373004,
    // Extension: VK_NV_external_sci_sync
    VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_SCI_SYNC_INFO_NV = 1000373005,
    // Extension: VK_NV_external_sci_sync
    VK_STRUCTURE_TYPE_SEMAPHORE_GET_SCI_SYNC_INFO_NV = 1000373006,
    // Extension: VK_NV_external_sci_sync
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SCI_SYNC_FEATURES_NV = 1000373007,
    // Extension: VK_NV_external_memory_sci_buf
    VK_STRUCTURE_TYPE_IMPORT_MEMORY_SCI_BUF_INFO_NV = 1000374000,
    // Extension: VK_NV_external_memory_sci_buf
    VK_STRUCTURE_TYPE_EXPORT_MEMORY_SCI_BUF_INFO_NV = 1000374001,
    // Extension: VK_NV_external_memory_sci_buf
    VK_STRUCTURE_TYPE_MEMORY_GET_SCI_BUF_INFO_NV = 1000374002,
    // Extension: VK_NV_external_memory_sci_buf
    VK_STRUCTURE_TYPE_MEMORY_SCI_BUF_PROPERTIES_NV = 1000374003,
    // Extension: VK_NV_external_memory_sci_buf
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_SCI_BUF_FEATURES_NV = 1000374004,
    // Extension: VK_EXT_frame_boundary
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAME_BOUNDARY_FEATURES_EXT = 1000375000,
    // Extension: VK_EXT_frame_boundary
    VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT = 1000375001,
    // Extension: VK_EXT_multisampled_render_to_single_sampled
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT = 1000376000,
    // Extension: VK_EXT_multisampled_render_to_single_sampled
    VK_STRUCTURE_TYPE_SUBPASS_RESOLVE_PERFORMANCE_QUERY_EXT = 1000376001,
    // Extension: VK_EXT_multisampled_render_to_single_sampled
    VK_STRUCTURE_TYPE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_INFO_EXT = 1000376002,
    // Extension: VK_EXT_extended_dynamic_state2
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT = 1000377000,
    // Extension: VK_QNX_screen_surface
    VK_STRUCTURE_TYPE_SCREEN_SURFACE_CREATE_INFO_QNX = 1000378000,
    // Extension: VK_EXT_color_write_enable
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT = 1000381000,
    // Extension: VK_EXT_color_write_enable
    VK_STRUCTURE_TYPE_PIPELINE_COLOR_WRITE_CREATE_INFO_EXT = 1000381001,
    // Extension: VK_EXT_primitives_generated_query
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT = 1000382000,
    // Extension: VK_KHR_ray_tracing_maintenance1
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR = 1000386000,
    // Extension: VK_KHR_shader_untyped_pointers
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_UNTYPED_POINTERS_FEATURES_KHR = 1000387000,
    // Extension: VK_BASE_VERSION_1_4
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES = 1000388000,
    // Extension: VK_BASE_VERSION_1_4
    VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES = 1000388001,
    // Extension: VK_VALVE_video_encode_rgb_conversion
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_RGB_CONVERSION_FEATURES_VALVE = 1000390000,
    // Extension: VK_VALVE_video_encode_rgb_conversion
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_RGB_CONVERSION_CAPABILITIES_VALVE = 1000390001,
    // Extension: VK_VALVE_video_encode_rgb_conversion
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_PROFILE_RGB_CONVERSION_INFO_VALVE = 1000390002,
    // Extension: VK_VALVE_video_encode_rgb_conversion
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_RGB_CONVERSION_CREATE_INFO_VALVE = 1000390003,
    // Extension: VK_EXT_image_view_min_lod
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT = 1000391000,
    // Extension: VK_EXT_image_view_min_lod
    VK_STRUCTURE_TYPE_IMAGE_VIEW_MIN_LOD_CREATE_INFO_EXT = 1000391001,
    // Extension: VK_EXT_multi_draw
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT = 1000392000,
    // Extension: VK_EXT_multi_draw
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT = 1000392001,
    // Extension: VK_EXT_image_2d_view_of_3d
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT = 1000393000,
    // Extension: VK_EXT_shader_tile_image
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_FEATURES_EXT = 1000395000,
    // Extension: VK_EXT_shader_tile_image
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_PROPERTIES_EXT = 1000395001,
    // Extension: VK_EXT_opacity_micromap
    VK_STRUCTURE_TYPE_MICROMAP_BUILD_INFO_EXT = 1000396000,
    // Extension: VK_EXT_opacity_micromap
    VK_STRUCTURE_TYPE_MICROMAP_VERSION_INFO_EXT = 1000396001,
    // Extension: VK_EXT_opacity_micromap
    VK_STRUCTURE_TYPE_COPY_MICROMAP_INFO_EXT = 1000396002,
    // Extension: VK_EXT_opacity_micromap
    VK_STRUCTURE_TYPE_COPY_MICROMAP_TO_MEMORY_INFO_EXT = 1000396003,
    // Extension: VK_EXT_opacity_micromap
    VK_STRUCTURE_TYPE_COPY_MEMORY_TO_MICROMAP_INFO_EXT = 1000396004,
    // Extension: VK_EXT_opacity_micromap
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_FEATURES_EXT = 1000396005,
    // Extension: VK_EXT_opacity_micromap
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_PROPERTIES_EXT = 1000396006,
    // Extension: VK_EXT_opacity_micromap
    VK_STRUCTURE_TYPE_MICROMAP_CREATE_INFO_EXT = 1000396007,
    // Extension: VK_EXT_opacity_micromap
    VK_STRUCTURE_TYPE_MICROMAP_BUILD_SIZES_INFO_EXT = 1000396008,
    // Extension: VK_EXT_opacity_micromap
    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_OPACITY_MICROMAP_EXT = 1000396009,
    // Extension: VK_NV_displacement_micromap
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISPLACEMENT_MICROMAP_FEATURES_NV = 1000397000,
    // Extension: VK_NV_displacement_micromap
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISPLACEMENT_MICROMAP_PROPERTIES_NV = 1000397001,
    // Extension: VK_NV_displacement_micromap
    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_DISPLACEMENT_MICROMAP_NV = 1000397002,
    // Extension: VK_HUAWEI_cluster_culling_shader
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_FEATURES_HUAWEI = 1000404000,
    // Extension: VK_HUAWEI_cluster_culling_shader
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_PROPERTIES_HUAWEI = 1000404001,
    // Extension: VK_HUAWEI_cluster_culling_shader
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_VRS_FEATURES_HUAWEI = 1000404002,
    // Extension: VK_EXT_border_color_swizzle
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT = 1000411000,
    // Extension: VK_EXT_border_color_swizzle
    VK_STRUCTURE_TYPE_SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT = 1000411001,
    // Extension: VK_EXT_pageable_device_local_memory
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT = 1000412000,
    // Extension: VK_BASE_VERSION_1_3
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES = 1000413000,
    // Extension: VK_BASE_VERSION_1_3
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES = 1000413001,
    // Extension: VK_BASE_VERSION_1_3
    VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS = 1000413002,
    // Extension: VK_BASE_VERSION_1_3
    VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS = 1000413003,
    // Extension: VK_ARM_shader_core_properties
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_ARM = 1000415000,
    // Extension: VK_COMPUTE_VERSION_1_4
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_ROTATE_FEATURES = 1000416000,
    // Extension: VK_ARM_scheduling_controls
    VK_STRUCTURE_TYPE_DEVICE_QUEUE_SHADER_CORE_CONTROL_CREATE_INFO_ARM = 1000417000,
    // Extension: VK_ARM_scheduling_controls
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_FEATURES_ARM = 1000417001,
    // Extension: VK_ARM_scheduling_controls
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_PROPERTIES_ARM = 1000417002,
    // Extension: VK_EXT_image_sliced_view_of_3d
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_SLICED_VIEW_OF_3D_FEATURES_EXT = 1000418000,
    // Extension: VK_EXT_image_sliced_view_of_3d
    VK_STRUCTURE_TYPE_IMAGE_VIEW_SLICED_CREATE_INFO_EXT = 1000418001,
    // Extension: VK_VALVE_descriptor_set_host_mapping
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE = 1000420000,
    // Extension: VK_VALVE_descriptor_set_host_mapping
    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_BINDING_REFERENCE_VALVE = 1000420001,
    // Extension: VK_VALVE_descriptor_set_host_mapping
    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_HOST_MAPPING_INFO_VALVE = 1000420002,
    // Extension: VK_KHR_depth_clamp_zero_one
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_KHR = 1000421000,
    // Extension: VK_EXT_non_seamless_cube_map
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT = 1000422000,
    // Extension: VK_ARM_render_pass_striped
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_FEATURES_ARM = 1000424000,
    // Extension: VK_ARM_render_pass_striped
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_PROPERTIES_ARM = 1000424001,
    // Extension: VK_ARM_render_pass_striped
    VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_BEGIN_INFO_ARM = 1000424002,
    // Extension: VK_ARM_render_pass_striped
    VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_INFO_ARM = 1000424003,
    // Extension: VK_ARM_render_pass_striped
    VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_SUBMIT_INFO_ARM = 1000424004,
    // Extension: VK_EXT_fragment_density_map_offset
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_EXT = 1000425000,
    // Extension: VK_EXT_fragment_density_map_offset
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_EXT = 1000425001,
    // Extension: VK_EXT_fragment_density_map_offset
    VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_EXT = 1000425002,
    // Extension: VK_NV_copy_memory_indirect
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_FEATURES_NV = 1000426000,
    // Extension: VK_KHR_copy_memory_indirect
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_PROPERTIES_KHR = 1000426001,
    // Extension: VK_EXT_memory_decompression
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_FEATURES_EXT = 1000427000,
    // Extension: VK_EXT_memory_decompression
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_PROPERTIES_EXT = 1000427001,
    // Extension: VK_NV_device_generated_commands_compute
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_COMPUTE_FEATURES_NV = 1000428000,
    // Extension: VK_NV_device_generated_commands_compute
    VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_INDIRECT_BUFFER_INFO_NV = 1000428001,
    // Extension: VK_NV_device_generated_commands_compute
    VK_STRUCTURE_TYPE_PIPELINE_INDIRECT_DEVICE_ADDRESS_INFO_NV = 1000428002,
    // Extension: VK_NV_ray_tracing_linear_swept_spheres
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_LINEAR_SWEPT_SPHERES_FEATURES_NV = 1000429008,
    // Extension: VK_NV_ray_tracing_linear_swept_spheres
    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_LINEAR_SWEPT_SPHERES_DATA_NV = 1000429009,
    // Extension: VK_NV_ray_tracing_linear_swept_spheres
    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_SPHERES_DATA_NV = 1000429010,
    // Extension: VK_NV_linear_color_attachment
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINEAR_COLOR_ATTACHMENT_FEATURES_NV = 1000430000,
    // Extension: VK_KHR_shader_maximal_reconvergence
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MAXIMAL_RECONVERGENCE_FEATURES_KHR = 1000434000,
    // Extension: VK_EXT_application_parameters
    VK_STRUCTURE_TYPE_APPLICATION_PARAMETERS_EXT = 1000435000,
    // Extension: VK_EXT_image_compression_control_swapchain
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT = 1000437000,
    // Extension: VK_QCOM_image_processing
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_FEATURES_QCOM = 1000440000,
    // Extension: VK_QCOM_image_processing
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_PROPERTIES_QCOM = 1000440001,
    // Extension: VK_QCOM_image_processing
    VK_STRUCTURE_TYPE_IMAGE_VIEW_SAMPLE_WEIGHT_CREATE_INFO_QCOM = 1000440002,
    // Extension: VK_EXT_nested_command_buffer
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_FEATURES_EXT = 1000451000,
    // Extension: VK_EXT_nested_command_buffer
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_PROPERTIES_EXT = 1000451001,
    // Extension: VK_OHOS_external_memory
    VK_STRUCTURE_TYPE_NATIVE_BUFFER_USAGE_OHOS = 1000452000,
    // Extension: VK_OHOS_external_memory
    VK_STRUCTURE_TYPE_NATIVE_BUFFER_PROPERTIES_OHOS = 1000452001,
    // Extension: VK_OHOS_external_memory
    VK_STRUCTURE_TYPE_NATIVE_BUFFER_FORMAT_PROPERTIES_OHOS = 1000452002,
    // Extension: VK_OHOS_external_memory
    VK_STRUCTURE_TYPE_IMPORT_NATIVE_BUFFER_INFO_OHOS = 1000452003,
    // Extension: VK_OHOS_external_memory
    VK_STRUCTURE_TYPE_MEMORY_GET_NATIVE_BUFFER_INFO_OHOS = 1000452004,
    // Extension: VK_OHOS_external_memory
    VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_OHOS = 1000452005,
    // Extension: VK_EXT_external_memory_acquire_unmodified
    VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT = 1000453000,
    // Extension: VK_OHOS_native_buffer
    VK_STRUCTURE_TYPE_NATIVE_BUFFER_OHOS = 1000453001,
    // Extension: VK_OHOS_native_buffer
    VK_STRUCTURE_TYPE_SWAPCHAIN_IMAGE_CREATE_INFO_OHOS = 1000453002,
    // Extension: VK_OHOS_native_buffer
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENTATION_PROPERTIES_OHOS = 1000453003,
    // Extension: VK_EXT_extended_dynamic_state3
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_FEATURES_EXT = 1000455000,
    // Extension: VK_EXT_extended_dynamic_state3
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_PROPERTIES_EXT = 1000455001,
    // Extension: VK_EXT_subpass_merge_feedback
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT = 1000458000,
    // Extension: VK_EXT_subpass_merge_feedback
    VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_CONTROL_EXT = 1000458001,
    // Extension: VK_EXT_subpass_merge_feedback
    VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_FEEDBACK_CREATE_INFO_EXT = 1000458002,
    // Extension: VK_EXT_subpass_merge_feedback
    VK_STRUCTURE_TYPE_RENDER_PASS_SUBPASS_FEEDBACK_CREATE_INFO_EXT = 1000458003,
    // Extension: VK_LUNARG_direct_driver_loading
    VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_INFO_LUNARG = 1000459000,
    // Extension: VK_LUNARG_direct_driver_loading
    VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_LIST_LUNARG = 1000459001,
    // Extension: VK_ARM_tensors
    VK_STRUCTURE_TYPE_TENSOR_CREATE_INFO_ARM = 1000460000,
    // Extension: VK_ARM_tensors
    VK_STRUCTURE_TYPE_TENSOR_VIEW_CREATE_INFO_ARM = 1000460001,
    // Extension: VK_ARM_tensors
    VK_STRUCTURE_TYPE_BIND_TENSOR_MEMORY_INFO_ARM = 1000460002,
    // Extension: VK_ARM_tensors
    VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_TENSOR_ARM = 1000460003,
    // Extension: VK_ARM_tensors
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TENSOR_PROPERTIES_ARM = 1000460004,
    // Extension: VK_ARM_tensors
    VK_STRUCTURE_TYPE_TENSOR_FORMAT_PROPERTIES_ARM = 1000460005,
    // Extension: VK_ARM_tensors
    VK_STRUCTURE_TYPE_TENSOR_DESCRIPTION_ARM = 1000460006,
    // Extension: VK_ARM_tensors
    VK_STRUCTURE_TYPE_TENSOR_MEMORY_REQUIREMENTS_INFO_ARM = 1000460007,
    // Extension: VK_ARM_tensors
    VK_STRUCTURE_TYPE_TENSOR_MEMORY_BARRIER_ARM = 1000460008,
    // Extension: VK_ARM_tensors
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TENSOR_FEATURES_ARM = 1000460009,
    // Extension: VK_ARM_tensors
    VK_STRUCTURE_TYPE_DEVICE_TENSOR_MEMORY_REQUIREMENTS_ARM = 1000460010,
    // Extension: VK_ARM_tensors
    VK_STRUCTURE_TYPE_COPY_TENSOR_INFO_ARM = 1000460011,
    // Extension: VK_ARM_tensors
    VK_STRUCTURE_TYPE_TENSOR_COPY_ARM = 1000460012,
    // Extension: VK_ARM_tensors
    VK_STRUCTURE_TYPE_TENSOR_DEPENDENCY_INFO_ARM = 1000460013,
    // Extension: VK_ARM_tensors
    VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_TENSOR_ARM = 1000460014,
    // Extension: VK_ARM_tensors
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_TENSOR_INFO_ARM = 1000460015,
    // Extension: VK_ARM_tensors
    VK_STRUCTURE_TYPE_EXTERNAL_TENSOR_PROPERTIES_ARM = 1000460016,
    // Extension: VK_ARM_tensors
    VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_TENSOR_CREATE_INFO_ARM = 1000460017,
    // Extension: VK_ARM_tensors
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_TENSOR_FEATURES_ARM = 1000460018,
    // Extension: VK_ARM_tensors
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_TENSOR_PROPERTIES_ARM = 1000460019,
    // Extension: VK_ARM_tensors
    VK_STRUCTURE_TYPE_DESCRIPTOR_GET_TENSOR_INFO_ARM = 1000460020,
    // Extension: VK_ARM_tensors
    VK_STRUCTURE_TYPE_TENSOR_CAPTURE_DESCRIPTOR_DATA_INFO_ARM = 1000460021,
    // Extension: VK_ARM_tensors
    VK_STRUCTURE_TYPE_TENSOR_VIEW_CAPTURE_DESCRIPTOR_DATA_INFO_ARM = 1000460022,
    // Extension: VK_ARM_tensors
    VK_STRUCTURE_TYPE_FRAME_BOUNDARY_TENSORS_ARM = 1000460023,
    // Extension: VK_EXT_shader_module_identifier
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT = 1000462000,
    // Extension: VK_EXT_shader_module_identifier
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_PROPERTIES_EXT = 1000462001,
    // Extension: VK_EXT_shader_module_identifier
    VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_MODULE_IDENTIFIER_CREATE_INFO_EXT = 1000462002,
    // Extension: VK_EXT_shader_module_identifier
    VK_STRUCTURE_TYPE_SHADER_MODULE_IDENTIFIER_EXT = 1000462003,
    // Extension: VK_NV_optical_flow
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_FEATURES_NV = 1000464000,
    // Extension: VK_NV_optical_flow
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_PROPERTIES_NV = 1000464001,
    // Extension: VK_NV_optical_flow
    VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV = 1000464002,
    // Extension: VK_NV_optical_flow
    VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_PROPERTIES_NV = 1000464003,
    // Extension: VK_NV_optical_flow
    VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_INFO_NV = 1000464004,
    // Extension: VK_NV_optical_flow
    VK_STRUCTURE_TYPE_OPTICAL_FLOW_EXECUTE_INFO_NV = 1000464005,
    // Extension: VK_NV_optical_flow
    VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_PRIVATE_DATA_INFO_NV = 1000464010,
    // Extension: VK_EXT_legacy_dithering
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT = 1000465000,
    // Extension: VK_COMPUTE_VERSION_1_4
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES = 1000466000,
    // Extension: VK_ANDROID_external_format_resolve
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FORMAT_RESOLVE_FEATURES_ANDROID = 1000468000,
    // Extension: VK_ANDROID_external_format_resolve
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FORMAT_RESOLVE_PROPERTIES_ANDROID = 1000468001,
    // Extension: VK_ANDROID_external_format_resolve
    VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_RESOLVE_PROPERTIES_ANDROID = 1000468002,
    // Extension: VK_BASE_VERSION_1_4
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES = 1000470000,
    // Extension: VK_BASE_VERSION_1_4
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_PROPERTIES = 1000470001,
    // Extension: VK_GRAPHICS_VERSION_1_4
    VK_STRUCTURE_TYPE_RENDERING_AREA_INFO = 1000470003,
    // Extension: VK_BASE_VERSION_1_4
    VK_STRUCTURE_TYPE_DEVICE_IMAGE_SUBRESOURCE_INFO = 1000470004,
    // Extension: VK_COMPUTE_VERSION_1_4
    VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO = 1000470005,
    // Extension: VK_BASE_VERSION_1_4
    VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO = 1000470006,
    // Extension: VK_AMD_anti_lag
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ANTI_LAG_FEATURES_AMD = 1000476000,
    // Extension: VK_AMD_anti_lag
    VK_STRUCTURE_TYPE_ANTI_LAG_DATA_AMD = 1000476001,
    // Extension: VK_AMD_anti_lag
    VK_STRUCTURE_TYPE_ANTI_LAG_PRESENTATION_INFO_AMD = 1000476002,
    // Extension: VK_AMDX_dense_geometry_format
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DENSE_GEOMETRY_FORMAT_FEATURES_AMDX = 1000478000,
    // Extension: VK_AMDX_dense_geometry_format
    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DENSE_GEOMETRY_FORMAT_TRIANGLES_DATA_AMDX = 1000478001,
    // Extension: VK_KHR_present_id2
    VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_ID_2_KHR = 1000479000,
    // Extension: VK_KHR_present_id2
    VK_STRUCTURE_TYPE_PRESENT_ID_2_KHR = 1000479001,
    // Extension: VK_KHR_present_id2
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_2_FEATURES_KHR = 1000479002,
    // Extension: VK_KHR_present_wait2
    VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_WAIT_2_KHR = 1000480000,
    // Extension: VK_KHR_present_wait2
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_2_FEATURES_KHR = 1000480001,
    // Extension: VK_KHR_present_wait2
    VK_STRUCTURE_TYPE_PRESENT_WAIT_2_INFO_KHR = 1000480002,
    // Extension: VK_KHR_ray_tracing_position_fetch
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_POSITION_FETCH_FEATURES_KHR = 1000481000,
    // Extension: VK_EXT_shader_object
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_FEATURES_EXT = 1000482000,
    // Extension: VK_EXT_shader_object
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_PROPERTIES_EXT = 1000482001,
    // Extension: VK_EXT_shader_object
    VK_STRUCTURE_TYPE_SHADER_CREATE_INFO_EXT = 1000482002,
    // Extension: VK_KHR_pipeline_binary
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_FEATURES_KHR = 1000483000,
    // Extension: VK_KHR_pipeline_binary
    VK_STRUCTURE_TYPE_PIPELINE_BINARY_CREATE_INFO_KHR = 1000483001,
    // Extension: VK_KHR_pipeline_binary
    VK_STRUCTURE_TYPE_PIPELINE_BINARY_INFO_KHR = 1000483002,
    // Extension: VK_KHR_pipeline_binary
    VK_STRUCTURE_TYPE_PIPELINE_BINARY_KEY_KHR = 1000483003,
    // Extension: VK_KHR_pipeline_binary
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_PROPERTIES_KHR = 1000483004,
    // Extension: VK_KHR_pipeline_binary
    VK_STRUCTURE_TYPE_RELEASE_CAPTURED_PIPELINE_DATA_INFO_KHR = 1000483005,
    // Extension: VK_KHR_pipeline_binary
    VK_STRUCTURE_TYPE_PIPELINE_BINARY_DATA_INFO_KHR = 1000483006,
    // Extension: VK_KHR_pipeline_binary
    VK_STRUCTURE_TYPE_PIPELINE_CREATE_INFO_KHR = 1000483007,
    // Extension: VK_KHR_pipeline_binary
    VK_STRUCTURE_TYPE_DEVICE_PIPELINE_BINARY_INTERNAL_CACHE_CONTROL_KHR = 1000483008,
    // Extension: VK_KHR_pipeline_binary
    VK_STRUCTURE_TYPE_PIPELINE_BINARY_HANDLES_INFO_KHR = 1000483009,
    // Extension: VK_QCOM_tile_properties
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_PROPERTIES_FEATURES_QCOM = 1000484000,
    // Extension: VK_QCOM_tile_properties
    VK_STRUCTURE_TYPE_TILE_PROPERTIES_QCOM = 1000484001,
    // Extension: VK_SEC_amigo_profiling
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_AMIGO_PROFILING_FEATURES_SEC = 1000485000,
    // Extension: VK_SEC_amigo_profiling
    VK_STRUCTURE_TYPE_AMIGO_PROFILING_SUBMIT_INFO_SEC = 1000485001,
    // Extension: VK_QCOM_multiview_per_view_viewports
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_VIEWPORTS_FEATURES_QCOM = 1000488000,
    // Extension: VK_NV_external_sci_sync2
    VK_STRUCTURE_TYPE_SEMAPHORE_SCI_SYNC_POOL_CREATE_INFO_NV = 1000489000,
    // Extension: VK_NV_external_sci_sync2
    VK_STRUCTURE_TYPE_SEMAPHORE_SCI_SYNC_CREATE_INFO_NV = 1000489001,
    // Extension: VK_NV_external_sci_sync2
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SCI_SYNC_2_FEATURES_NV = 1000489002,
    // Extension: VK_NV_external_sci_sync2
    VK_STRUCTURE_TYPE_DEVICE_SEMAPHORE_SCI_SYNC_POOL_RESERVATION_CREATE_INFO_NV = 1000489003,
    // Extension: VK_NV_ray_tracing_invocation_reorder
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_FEATURES_NV = 1000490000,
    // Extension: VK_NV_ray_tracing_invocation_reorder
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_PROPERTIES_NV = 1000490001,
    // Extension: VK_NV_cooperative_vector
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_VECTOR_FEATURES_NV = 1000491000,
    // Extension: VK_NV_cooperative_vector
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_VECTOR_PROPERTIES_NV = 1000491001,
    // Extension: VK_NV_cooperative_vector
    VK_STRUCTURE_TYPE_COOPERATIVE_VECTOR_PROPERTIES_NV = 1000491002,
    // Extension: VK_NV_cooperative_vector
    VK_STRUCTURE_TYPE_CONVERT_COOPERATIVE_VECTOR_MATRIX_INFO_NV = 1000491004,
    // Extension: VK_NV_extended_sparse_address_space
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_FEATURES_NV = 1000492000,
    // Extension: VK_NV_extended_sparse_address_space
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_PROPERTIES_NV = 1000492001,
    // Extension: VK_EXT_legacy_vertex_attributes
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_FEATURES_EXT = 1000495000,
    // Extension: VK_EXT_legacy_vertex_attributes
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_PROPERTIES_EXT = 1000495001,
    // Extension: VK_EXT_layer_settings
    VK_STRUCTURE_TYPE_LAYER_SETTINGS_CREATE_INFO_EXT = 1000496000,
    // Extension: VK_ARM_shader_core_builtins
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_FEATURES_ARM = 1000497000,
    // Extension: VK_ARM_shader_core_builtins
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_PROPERTIES_ARM = 1000497001,
    // Extension: VK_EXT_pipeline_library_group_handles
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_LIBRARY_GROUP_HANDLES_FEATURES_EXT = 1000498000,
    // Extension: VK_EXT_dynamic_rendering_unused_attachments
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_FEATURES_EXT = 1000499000,
    // Extension: VK_NV_low_latency2
    VK_STRUCTURE_TYPE_LATENCY_SLEEP_MODE_INFO_NV = 1000505000,
    // Extension: VK_NV_low_latency2
    VK_STRUCTURE_TYPE_LATENCY_SLEEP_INFO_NV = 1000505001,
    // Extension: VK_NV_low_latency2
    VK_STRUCTURE_TYPE_SET_LATENCY_MARKER_INFO_NV = 1000505002,
    // Extension: VK_NV_low_latency2
    VK_STRUCTURE_TYPE_GET_LATENCY_MARKER_INFO_NV = 1000505003,
    // Extension: VK_NV_low_latency2
    VK_STRUCTURE_TYPE_LATENCY_TIMINGS_FRAME_REPORT_NV = 1000505004,
    // Extension: VK_NV_low_latency2
    VK_STRUCTURE_TYPE_LATENCY_SUBMISSION_PRESENT_ID_NV = 1000505005,
    // Extension: VK_NV_low_latency2
    VK_STRUCTURE_TYPE_OUT_OF_BAND_QUEUE_TYPE_INFO_NV = 1000505006,
    // Extension: VK_NV_low_latency2
    VK_STRUCTURE_TYPE_SWAPCHAIN_LATENCY_CREATE_INFO_NV = 1000505007,
    // Extension: VK_NV_low_latency2
    VK_STRUCTURE_TYPE_LATENCY_SURFACE_CAPABILITIES_NV = 1000505008,
    // Extension: VK_KHR_cooperative_matrix
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_KHR = 1000506000,
    // Extension: VK_KHR_cooperative_matrix
    VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_KHR = 1000506001,
    // Extension: VK_KHR_cooperative_matrix
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_KHR = 1000506002,
    // Extension: VK_ARM_data_graph
    VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_CREATE_INFO_ARM = 1000507000,
    // Extension: VK_ARM_data_graph
    VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_CREATE_INFO_ARM = 1000507001,
    // Extension: VK_ARM_data_graph
    VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_RESOURCE_INFO_ARM = 1000507002,
    // Extension: VK_ARM_data_graph
    VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_CONSTANT_ARM = 1000507003,
    // Extension: VK_ARM_data_graph
    VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_MEMORY_REQUIREMENTS_INFO_ARM = 1000507004,
    // Extension: VK_ARM_data_graph
    VK_STRUCTURE_TYPE_BIND_DATA_GRAPH_PIPELINE_SESSION_MEMORY_INFO_ARM = 1000507005,
    // Extension: VK_ARM_data_graph
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DATA_GRAPH_FEATURES_ARM = 1000507006,
    // Extension: VK_ARM_data_graph
    VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SHADER_MODULE_CREATE_INFO_ARM = 1000507007,
    // Extension: VK_ARM_data_graph
    VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_PROPERTY_QUERY_RESULT_ARM = 1000507008,
    // Extension: VK_ARM_data_graph
    VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_INFO_ARM = 1000507009,
    // Extension: VK_ARM_data_graph
    VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_COMPILER_CONTROL_CREATE_INFO_ARM = 1000507010,
    // Extension: VK_ARM_data_graph
    VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_REQUIREMENTS_INFO_ARM = 1000507011,
    // Extension: VK_ARM_data_graph
    VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_REQUIREMENT_ARM = 1000507012,
    // Extension: VK_ARM_data_graph
    VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_IDENTIFIER_CREATE_INFO_ARM = 1000507013,
    // Extension: VK_ARM_data_graph
    VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_DISPATCH_INFO_ARM = 1000507014,
    // Extension: VK_ARM_data_graph
    VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_CONSTANT_TENSOR_SEMI_STRUCTURED_SPARSITY_INFO_ARM = 1000507015,
    // Extension: VK_ARM_data_graph
    VK_STRUCTURE_TYPE_DATA_GRAPH_PROCESSING_ENGINE_CREATE_INFO_ARM = 1000507016,
    // Extension: VK_ARM_data_graph
    VK_STRUCTURE_TYPE_QUEUE_FAMILY_DATA_GRAPH_PROCESSING_ENGINE_PROPERTIES_ARM = 1000507017,
    // Extension: VK_ARM_data_graph
    VK_STRUCTURE_TYPE_QUEUE_FAMILY_DATA_GRAPH_PROPERTIES_ARM = 1000507018,
    // Extension: VK_ARM_data_graph
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_QUEUE_FAMILY_DATA_GRAPH_PROCESSING_ENGINE_INFO_ARM = 1000507019,
    // Extension: VK_QCOM_multiview_per_view_render_areas
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_RENDER_AREAS_FEATURES_QCOM = 1000510000,
    // Extension: VK_QCOM_multiview_per_view_render_areas
    VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_RENDER_AREAS_RENDER_PASS_BEGIN_INFO_QCOM = 1000510001,
    // Extension: VK_KHR_compute_shader_derivatives
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_PROPERTIES_KHR = 1000511000,
    // Extension: VK_KHR_video_decode_av1
    VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_CAPABILITIES_KHR = 1000512000,
    // Extension: VK_KHR_video_decode_av1
    VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_PICTURE_INFO_KHR = 1000512001,
    // Extension: VK_KHR_video_decode_av1
    VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_PROFILE_INFO_KHR = 1000512003,
    // Extension: VK_KHR_video_decode_av1
    VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_SESSION_PARAMETERS_CREATE_INFO_KHR = 1000512004,
    // Extension: VK_KHR_video_decode_av1
    VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_DPB_SLOT_INFO_KHR = 1000512005,
    // Extension: VK_KHR_video_encode_av1
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_CAPABILITIES_KHR = 1000513000,
    // Extension: VK_KHR_video_encode_av1
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_SESSION_PARAMETERS_CREATE_INFO_KHR = 1000513001,
    // Extension: VK_KHR_video_encode_av1
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_PICTURE_INFO_KHR = 1000513002,
    // Extension: VK_KHR_video_encode_av1
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_DPB_SLOT_INFO_KHR = 1000513003,
    // Extension: VK_KHR_video_encode_av1
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_AV1_FEATURES_KHR = 1000513004,
    // Extension: VK_KHR_video_encode_av1
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_PROFILE_INFO_KHR = 1000513005,
    // Extension: VK_KHR_video_encode_av1
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_RATE_CONTROL_INFO_KHR = 1000513006,
    // Extension: VK_KHR_video_encode_av1
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_RATE_CONTROL_LAYER_INFO_KHR = 1000513007,
    // Extension: VK_KHR_video_encode_av1
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_QUALITY_LEVEL_PROPERTIES_KHR = 1000513008,
    // Extension: VK_KHR_video_encode_av1
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_SESSION_CREATE_INFO_KHR = 1000513009,
    // Extension: VK_KHR_video_encode_av1
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_GOP_REMAINING_FRAME_INFO_KHR = 1000513010,
    // Extension: VK_KHR_video_decode_vp9
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_DECODE_VP9_FEATURES_KHR = 1000514000,
    // Extension: VK_KHR_video_decode_vp9
    VK_STRUCTURE_TYPE_VIDEO_DECODE_VP9_CAPABILITIES_KHR = 1000514001,
    // Extension: VK_KHR_video_decode_vp9
    VK_STRUCTURE_TYPE_VIDEO_DECODE_VP9_PICTURE_INFO_KHR = 1000514002,
    // Extension: VK_KHR_video_decode_vp9
    VK_STRUCTURE_TYPE_VIDEO_DECODE_VP9_PROFILE_INFO_KHR = 1000514003,
    // Extension: VK_KHR_video_maintenance1
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_1_FEATURES_KHR = 1000515000,
    // Extension: VK_KHR_video_maintenance1
    VK_STRUCTURE_TYPE_VIDEO_INLINE_QUERY_INFO_KHR = 1000515001,
    // Extension: VK_NV_per_stage_descriptor_set
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PER_STAGE_DESCRIPTOR_SET_FEATURES_NV = 1000516000,
    // Extension: VK_QCOM_image_processing2
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_FEATURES_QCOM = 1000518000,
    // Extension: VK_QCOM_image_processing2
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_PROPERTIES_QCOM = 1000518001,
    // Extension: VK_QCOM_image_processing2
    VK_STRUCTURE_TYPE_SAMPLER_BLOCK_MATCH_WINDOW_CREATE_INFO_QCOM = 1000518002,
    // Extension: VK_QCOM_filter_cubic_weights
    VK_STRUCTURE_TYPE_SAMPLER_CUBIC_WEIGHTS_CREATE_INFO_QCOM = 1000519000,
    // Extension: VK_QCOM_filter_cubic_weights
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_WEIGHTS_FEATURES_QCOM = 1000519001,
    // Extension: VK_QCOM_filter_cubic_weights
    VK_STRUCTURE_TYPE_BLIT_IMAGE_CUBIC_WEIGHTS_INFO_QCOM = 1000519002,
    // Extension: VK_QCOM_ycbcr_degamma
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_DEGAMMA_FEATURES_QCOM = 1000520000,
    // Extension: VK_QCOM_ycbcr_degamma
    VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_YCBCR_DEGAMMA_CREATE_INFO_QCOM = 1000520001,
    // Extension: VK_QCOM_filter_cubic_clamp
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_CLAMP_FEATURES_QCOM = 1000521000,
    // Extension: VK_EXT_attachment_feedback_loop_dynamic_state
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_FEATURES_EXT = 1000524000,
    // Extension: VK_GRAPHICS_VERSION_1_4
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES = 1000525000,
    // Extension: VK_KHR_unified_image_layouts
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFIED_IMAGE_LAYOUTS_FEATURES_KHR = 1000527000,
    // Extension: VK_KHR_unified_image_layouts
    VK_STRUCTURE_TYPE_ATTACHMENT_FEEDBACK_LOOP_INFO_EXT = 1000527001,
    // Extension: VK_COMPUTE_VERSION_1_4
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT_CONTROLS_2_FEATURES = 1000528000,
    // Extension: VK_QNX_external_memory_screen_buffer
    VK_STRUCTURE_TYPE_SCREEN_BUFFER_PROPERTIES_QNX = 1000529000,
    // Extension: VK_QNX_external_memory_screen_buffer
    VK_STRUCTURE_TYPE_SCREEN_BUFFER_FORMAT_PROPERTIES_QNX = 1000529001,
    // Extension: VK_QNX_external_memory_screen_buffer
    VK_STRUCTURE_TYPE_IMPORT_SCREEN_BUFFER_INFO_QNX = 1000529002,
    // Extension: VK_QNX_external_memory_screen_buffer
    VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_QNX = 1000529003,
    // Extension: VK_QNX_external_memory_screen_buffer
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_SCREEN_BUFFER_FEATURES_QNX = 1000529004,
    // Extension: VK_MSFT_layered_driver
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_DRIVER_PROPERTIES_MSFT = 1000530000,
    // Extension: VK_COMPUTE_VERSION_1_4
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EXPECT_ASSUME_FEATURES = 1000544000,
    // Extension: VK_BASE_VERSION_1_4
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_FEATURES = 1000545000,
    // Extension: VK_BASE_VERSION_1_4
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_PROPERTIES = 1000545001,
    // Extension: VK_BASE_VERSION_1_4
    VK_STRUCTURE_TYPE_BIND_MEMORY_STATUS = 1000545002,
    // Extension: VK_COMPUTE_VERSION_1_4
    VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_SETS_INFO = 1000545003,
    // Extension: VK_COMPUTE_VERSION_1_4
    VK_STRUCTURE_TYPE_PUSH_CONSTANTS_INFO = 1000545004,
    // Extension: VK_COMPUTE_VERSION_1_4
    VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_INFO = 1000545005,
    // Extension: VK_COMPUTE_VERSION_1_4
    VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_WITH_TEMPLATE_INFO = 1000545006,
    // Extension: VK_KHR_maintenance6
    VK_STRUCTURE_TYPE_SET_DESCRIPTOR_BUFFER_OFFSETS_INFO_EXT = 1000545007,
    // Extension: VK_KHR_maintenance6
    VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_BUFFER_EMBEDDED_SAMPLERS_INFO_EXT = 1000545008,
    // Extension: VK_NV_descriptor_pool_overallocation
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_POOL_OVERALLOCATION_FEATURES_NV = 1000546000,
    // Extension: VK_QCOM_tile_memory_heap
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_MEMORY_HEAP_FEATURES_QCOM = 1000547000,
    // Extension: VK_QCOM_tile_memory_heap
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_MEMORY_HEAP_PROPERTIES_QCOM = 1000547001,
    // Extension: VK_QCOM_tile_memory_heap
    VK_STRUCTURE_TYPE_TILE_MEMORY_REQUIREMENTS_QCOM = 1000547002,
    // Extension: VK_QCOM_tile_memory_heap
    VK_STRUCTURE_TYPE_TILE_MEMORY_BIND_INFO_QCOM = 1000547003,
    // Extension: VK_QCOM_tile_memory_heap
    VK_STRUCTURE_TYPE_TILE_MEMORY_SIZE_INFO_QCOM = 1000547004,
    // Extension: VK_KHR_copy_memory_indirect
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_FEATURES_KHR = 1000549000,
    // Extension: VK_KHR_copy_memory_indirect
    VK_STRUCTURE_TYPE_COPY_MEMORY_INDIRECT_INFO_KHR = 1000549002,
    // Extension: VK_KHR_copy_memory_indirect
    VK_STRUCTURE_TYPE_COPY_MEMORY_TO_IMAGE_INDIRECT_INFO_KHR = 1000549003,
    // Extension: VK_EXT_memory_decompression
    VK_STRUCTURE_TYPE_DECOMPRESS_MEMORY_INFO_EXT = 1000550002,
    // Extension: VK_NV_display_stereo
    VK_STRUCTURE_TYPE_DISPLAY_SURFACE_STEREO_CREATE_INFO_NV = 1000551000,
    // Extension: VK_NV_display_stereo
    VK_STRUCTURE_TYPE_DISPLAY_MODE_STEREO_PROPERTIES_NV = 1000551001,
    // Extension: VK_KHR_video_encode_intra_refresh
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_INTRA_REFRESH_CAPABILITIES_KHR = 1000552000,
    // Extension: VK_KHR_video_encode_intra_refresh
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_INTRA_REFRESH_CREATE_INFO_KHR = 1000552001,
    // Extension: VK_KHR_video_encode_intra_refresh
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_INTRA_REFRESH_INFO_KHR = 1000552002,
    // Extension: VK_KHR_video_encode_intra_refresh
    VK_STRUCTURE_TYPE_VIDEO_REFERENCE_INTRA_REFRESH_INFO_KHR = 1000552003,
    // Extension: VK_KHR_video_encode_intra_refresh
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_INTRA_REFRESH_FEATURES_KHR = 1000552004,
    // Extension: VK_KHR_video_encode_quantization_map
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_CAPABILITIES_KHR = 1000553000,
    // Extension: VK_KHR_video_encode_quantization_map
    VK_STRUCTURE_TYPE_VIDEO_FORMAT_QUANTIZATION_MAP_PROPERTIES_KHR = 1000553001,
    // Extension: VK_KHR_video_encode_quantization_map
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_INFO_KHR = 1000553002,
    // Extension: VK_KHR_video_encode_quantization_map
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_QUANTIZATION_MAP_CAPABILITIES_KHR = 1000553003,
    // Extension: VK_KHR_video_encode_quantization_map
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_QUANTIZATION_MAP_CAPABILITIES_KHR = 1000553004,
    // Extension: VK_KHR_video_encode_quantization_map
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_SESSION_PARAMETERS_CREATE_INFO_KHR = 1000553005,
    // Extension: VK_KHR_video_encode_quantization_map
    VK_STRUCTURE_TYPE_VIDEO_FORMAT_H265_QUANTIZATION_MAP_PROPERTIES_KHR = 1000553006,
    // Extension: VK_KHR_video_encode_quantization_map
    VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_QUANTIZATION_MAP_CAPABILITIES_KHR = 1000553007,
    // Extension: VK_KHR_video_encode_quantization_map
    VK_STRUCTURE_TYPE_VIDEO_FORMAT_AV1_QUANTIZATION_MAP_PROPERTIES_KHR = 1000553008,
    // Extension: VK_KHR_video_encode_quantization_map
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUANTIZATION_MAP_FEATURES_KHR = 1000553009,
    // Extension: VK_NV_raw_access_chains
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAW_ACCESS_CHAINS_FEATURES_NV = 1000555000,
    // Extension: VK_NV_external_compute_queue
    VK_STRUCTURE_TYPE_EXTERNAL_COMPUTE_QUEUE_DEVICE_CREATE_INFO_NV = 1000556000,
    // Extension: VK_NV_external_compute_queue
    VK_STRUCTURE_TYPE_EXTERNAL_COMPUTE_QUEUE_CREATE_INFO_NV = 1000556001,
    // Extension: VK_NV_external_compute_queue
    VK_STRUCTURE_TYPE_EXTERNAL_COMPUTE_QUEUE_DATA_PARAMS_NV = 1000556002,
    // Extension: VK_NV_external_compute_queue
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_COMPUTE_QUEUE_PROPERTIES_NV = 1000556003,
    // Extension: VK_KHR_shader_relaxed_extended_instruction
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_RELAXED_EXTENDED_INSTRUCTION_FEATURES_KHR = 1000558000,
    // Extension: VK_NV_command_buffer_inheritance
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMMAND_BUFFER_INHERITANCE_FEATURES_NV = 1000559000,
    // Extension: VK_KHR_maintenance7
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_7_FEATURES_KHR = 1000562000,
    // Extension: VK_KHR_maintenance7
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_7_PROPERTIES_KHR = 1000562001,
    // Extension: VK_KHR_maintenance7
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_PROPERTIES_LIST_KHR = 1000562002,
    // Extension: VK_KHR_maintenance7
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_PROPERTIES_KHR = 1000562003,
    // Extension: VK_KHR_maintenance7
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_VULKAN_PROPERTIES_KHR = 1000562004,
    // Extension: VK_NV_shader_atomic_float16_vector
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT16_VECTOR_FEATURES_NV = 1000563000,
    // Extension: VK_EXT_shader_replicated_composites
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_REPLICATED_COMPOSITES_FEATURES_EXT = 1000564000,
    // Extension: VK_EXT_shader_float8
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT8_FEATURES_EXT = 1000567000,
    // Extension: VK_NV_ray_tracing_validation
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_VALIDATION_FEATURES_NV = 1000568000,
    // Extension: VK_NV_cluster_acceleration_structure
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_ACCELERATION_STRUCTURE_FEATURES_NV = 1000569000,
    // Extension: VK_NV_cluster_acceleration_structure
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_ACCELERATION_STRUCTURE_PROPERTIES_NV = 1000569001,
    // Extension: VK_NV_cluster_acceleration_structure
    VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_CLUSTERS_BOTTOM_LEVEL_INPUT_NV = 1000569002,
    // Extension: VK_NV_cluster_acceleration_structure
    VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_TRIANGLE_CLUSTER_INPUT_NV = 1000569003,
    // Extension: VK_NV_cluster_acceleration_structure
    VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_MOVE_OBJECTS_INPUT_NV = 1000569004,
    // Extension: VK_NV_cluster_acceleration_structure
    VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_INPUT_INFO_NV = 1000569005,
    // Extension: VK_NV_cluster_acceleration_structure
    VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_COMMANDS_INFO_NV = 1000569006,
    // Extension: VK_NV_cluster_acceleration_structure
    VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CLUSTER_ACCELERATION_STRUCTURE_CREATE_INFO_NV = 1000569007,
    // Extension: VK_NV_partitioned_acceleration_structure
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PARTITIONED_ACCELERATION_STRUCTURE_FEATURES_NV = 1000570000,
    // Extension: VK_NV_partitioned_acceleration_structure
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PARTITIONED_ACCELERATION_STRUCTURE_PROPERTIES_NV = 1000570001,
    // Extension: VK_NV_partitioned_acceleration_structure
    VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_PARTITIONED_ACCELERATION_STRUCTURE_NV = 1000570002,
    // Extension: VK_NV_partitioned_acceleration_structure
    VK_STRUCTURE_TYPE_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCES_INPUT_NV = 1000570003,
    // Extension: VK_NV_partitioned_acceleration_structure
    VK_STRUCTURE_TYPE_BUILD_PARTITIONED_ACCELERATION_STRUCTURE_INFO_NV = 1000570004,
    // Extension: VK_NV_partitioned_acceleration_structure
    VK_STRUCTURE_TYPE_PARTITIONED_ACCELERATION_STRUCTURE_FLAGS_NV = 1000570005,
    // Extension: VK_EXT_device_generated_commands
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_EXT = 1000572000,
    // Extension: VK_EXT_device_generated_commands
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_EXT = 1000572001,
    // Extension: VK_EXT_device_generated_commands
    VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_EXT = 1000572002,
    // Extension: VK_EXT_device_generated_commands
    VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_CREATE_INFO_EXT = 1000572003,
    // Extension: VK_EXT_device_generated_commands
    VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_EXT = 1000572004,
    // Extension: VK_EXT_device_generated_commands
    VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_EXT = 1000572006,
    // Extension: VK_EXT_device_generated_commands
    VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_EXT = 1000572007,
    // Extension: VK_EXT_device_generated_commands
    VK_STRUCTURE_TYPE_WRITE_INDIRECT_EXECUTION_SET_PIPELINE_EXT = 1000572008,
    // Extension: VK_EXT_device_generated_commands
    VK_STRUCTURE_TYPE_WRITE_INDIRECT_EXECUTION_SET_SHADER_EXT = 1000572009,
    // Extension: VK_EXT_device_generated_commands
    VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_PIPELINE_INFO_EXT = 1000572010,
    // Extension: VK_EXT_device_generated_commands
    VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_SHADER_INFO_EXT = 1000572011,
    // Extension: VK_EXT_device_generated_commands
    VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_SHADER_LAYOUT_INFO_EXT = 1000572012,
    // Extension: VK_EXT_device_generated_commands
    VK_STRUCTURE_TYPE_GENERATED_COMMANDS_PIPELINE_INFO_EXT = 1000572013,
    // Extension: VK_EXT_device_generated_commands
    VK_STRUCTURE_TYPE_GENERATED_COMMANDS_SHADER_INFO_EXT = 1000572014,
    // Extension: VK_KHR_maintenance8
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_8_FEATURES_KHR = 1000574000,
    // Extension: VK_KHR_maintenance8
    VK_STRUCTURE_TYPE_MEMORY_BARRIER_ACCESS_FLAGS_3_KHR = 1000574002,
    // Extension: VK_MESA_image_alignment_control
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_FEATURES_MESA = 1000575000,
    // Extension: VK_MESA_image_alignment_control
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_PROPERTIES_MESA = 1000575001,
    // Extension: VK_MESA_image_alignment_control
    VK_STRUCTURE_TYPE_IMAGE_ALIGNMENT_CONTROL_CREATE_INFO_MESA = 1000575002,
    // Extension: VK_KHR_shader_fma
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FMA_FEATURES_KHR = 1000579000,
    // Extension: VK_EXT_ray_tracing_invocation_reorder
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_FEATURES_EXT = 1000581000,
    // Extension: VK_EXT_ray_tracing_invocation_reorder
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_PROPERTIES_EXT = 1000581001,
    // Extension: VK_EXT_depth_clamp_control
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_CONTROL_FEATURES_EXT = 1000582000,
    // Extension: VK_EXT_depth_clamp_control
    VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLAMP_CONTROL_CREATE_INFO_EXT = 1000582001,
    // Extension: VK_KHR_maintenance9
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_9_FEATURES_KHR = 1000584000,
    // Extension: VK_KHR_maintenance9
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_9_PROPERTIES_KHR = 1000584001,
    // Extension: VK_KHR_maintenance9
    VK_STRUCTURE_TYPE_QUEUE_FAMILY_OWNERSHIP_TRANSFER_PROPERTIES_KHR = 1000584002,
    // Extension: VK_KHR_video_maintenance2
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_2_FEATURES_KHR = 1000586000,
    // Extension: VK_KHR_video_maintenance2
    VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_INLINE_SESSION_PARAMETERS_INFO_KHR = 1000586001,
    // Extension: VK_KHR_video_maintenance2
    VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_INLINE_SESSION_PARAMETERS_INFO_KHR = 1000586002,
    // Extension: VK_KHR_video_maintenance2
    VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_INLINE_SESSION_PARAMETERS_INFO_KHR = 1000586003,
    // Extension: VK_HUAWEI_hdr_vivid
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HDR_VIVID_FEATURES_HUAWEI = 1000590000,
    // Extension: VK_HUAWEI_hdr_vivid
    VK_STRUCTURE_TYPE_HDR_VIVID_DYNAMIC_METADATA_HUAWEI = 1000590001,
    // Extension: VK_NV_cooperative_matrix2
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_2_FEATURES_NV = 1000593000,
    // Extension: VK_NV_cooperative_matrix2
    VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_FLEXIBLE_DIMENSIONS_PROPERTIES_NV = 1000593001,
    // Extension: VK_NV_cooperative_matrix2
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_2_PROPERTIES_NV = 1000593002,
    // Extension: VK_ARM_pipeline_opacity_micromap
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_OPACITY_MICROMAP_FEATURES_ARM = 1000596000,
    // Extension: VK_EXT_external_memory_metal
    VK_STRUCTURE_TYPE_IMPORT_MEMORY_METAL_HANDLE_INFO_EXT = 1000602000,
    // Extension: VK_EXT_external_memory_metal
    VK_STRUCTURE_TYPE_MEMORY_METAL_HANDLE_PROPERTIES_EXT = 1000602001,
    // Extension: VK_EXT_external_memory_metal
    VK_STRUCTURE_TYPE_MEMORY_GET_METAL_HANDLE_INFO_EXT = 1000602002,
    // Extension: VK_ARM_performance_counters_by_region
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_COUNTERS_BY_REGION_FEATURES_ARM = 1000605000,
    // Extension: VK_ARM_performance_counters_by_region
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_COUNTERS_BY_REGION_PROPERTIES_ARM = 1000605001,
    // Extension: VK_ARM_performance_counters_by_region
    VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_ARM = 1000605002,
    // Extension: VK_ARM_performance_counters_by_region
    VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_DESCRIPTION_ARM = 1000605003,
    // Extension: VK_ARM_performance_counters_by_region
    VK_STRUCTURE_TYPE_RENDER_PASS_PERFORMANCE_COUNTERS_BY_REGION_BEGIN_INFO_ARM = 1000605004,
    // Extension: VK_EXT_vertex_attribute_robustness
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_ROBUSTNESS_FEATURES_EXT = 1000608000,
    // Extension: VK_ARM_format_pack
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FORMAT_PACK_FEATURES_ARM = 1000609000,
    // Extension: VK_VALVE_fragment_density_map_layered
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_LAYERED_FEATURES_VALVE = 1000611000,
    // Extension: VK_VALVE_fragment_density_map_layered
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_LAYERED_PROPERTIES_VALVE = 1000611001,
    // Extension: VK_VALVE_fragment_density_map_layered
    VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_DENSITY_MAP_LAYERED_CREATE_INFO_VALVE = 1000611002,
    // Extension: VK_NV_present_metering
    VK_STRUCTURE_TYPE_SET_PRESENT_CONFIG_NV = 1000613000,
    // Extension: VK_NV_present_metering
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_METERING_FEATURES_NV = 1000613001,
    // Extension: VK_KHR_maintenance10
    VK_STRUCTURE_TYPE_RENDERING_END_INFO_KHR = 1000619003,
    // Extension: VK_EXT_zero_initialize_device_memory
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_DEVICE_MEMORY_FEATURES_EXT = 1000620000,
    // Extension: VK_EXT_shader_64bit_indexing
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_64_BIT_INDEXING_FEATURES_EXT = 1000627000,
    // Extension: VK_EXT_custom_resolve
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_RESOLVE_FEATURES_EXT = 1000628000,
    // Extension: VK_EXT_custom_resolve
    VK_STRUCTURE_TYPE_BEGIN_CUSTOM_RESOLVE_INFO_EXT = 1000628001,
    // Extension: VK_EXT_custom_resolve
    VK_STRUCTURE_TYPE_CUSTOM_RESOLVE_CREATE_INFO_EXT = 1000628002,
    // Extension: VK_QCOM_data_graph_model
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DATA_GRAPH_MODEL_FEATURES_QCOM = 1000629000,
    // Extension: VK_QCOM_data_graph_model
    VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_BUILTIN_MODEL_CREATE_INFO_QCOM = 1000629001,
    // Extension: VK_KHR_maintenance10
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_10_FEATURES_KHR = 1000630000,
    // Extension: VK_KHR_maintenance10
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_10_PROPERTIES_KHR = 1000630001,
    // Extension: VK_KHR_maintenance10
    VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_FLAGS_INFO_KHR = 1000630002,
    // Extension: VK_KHR_maintenance10
    VK_STRUCTURE_TYPE_RESOLVE_IMAGE_MODE_INFO_KHR = 1000630004,
    // Extension: VK_SEC_pipeline_cache_incremental_mode
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CACHE_INCREMENTAL_MODE_FEATURES_SEC = 1000637000,
    // Extension: VK_EXT_shader_uniform_buffer_unsized_array
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_UNIFORM_BUFFER_UNSIZED_ARRAY_FEATURES_EXT = 1000642000,
    // Extension: VK_NV_compute_occupancy_priority
    VK_STRUCTURE_TYPE_COMPUTE_OCCUPANCY_PRIORITY_PARAMETERS_NV = 1000645000,
    // Extension: VK_NV_compute_occupancy_priority
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_OCCUPANCY_PRIORITY_FEATURES_NV = 1000645001,
    // Extension: VK_OHOS_surface
    VK_STRUCTURE_TYPE_SURFACE_CREATE_INFO_OHOS = 1000685000,
    _,
};
pub const VkSubpassContents = enum(i32) {
    VK_SUBPASS_CONTENTS_INLINE = 0,
    VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS = 1,
    // Extension: VK_KHR_maintenance7
    VK_SUBPASS_CONTENTS_INLINE_AND_SECONDARY_COMMAND_BUFFERS_KHR = 1000451000,
    _,
};
pub const VkResult = enum(i32) {
    // Extension: VK_KHR_pipeline_binary
    VK_ERROR_NOT_ENOUGH_SPACE_KHR = -1000483000,
    // Extension: VK_EXT_image_compression_control
    VK_ERROR_COMPRESSION_EXHAUSTED_EXT = -1000338000,
    // Extension: VK_KHR_video_encode_queue
    VK_ERROR_INVALID_VIDEO_STD_PARAMETERS_KHR = -1000299000,
    // Extension: VKSC_VERSION_1_0
    VK_ERROR_NO_PIPELINE_MATCH = -1000298001,
    // Extension: VKSC_VERSION_1_0
    VK_ERROR_INVALID_PIPELINE_CACHE_DATA = -1000298000,
    // Extension: VK_BASE_VERSION_1_2
    VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS = -1000257000,
    // Extension: VK_EXT_full_screen_exclusive
    VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT = -1000255000,
    // Extension: VK_EXT_present_timing
    VK_ERROR_PRESENT_TIMING_QUEUE_FULL_EXT = -1000208000,
    // Extension: VK_BASE_VERSION_1_4
    VK_ERROR_NOT_PERMITTED = -1000174001,
    // Extension: VK_COMPUTE_VERSION_1_2
    VK_ERROR_FRAGMENTATION = -1000161000,
    // Extension: VK_EXT_image_drm_format_modifier
    VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT = -1000158000,
    // Extension: VK_BASE_VERSION_1_1
    VK_ERROR_INVALID_EXTERNAL_HANDLE = -1000072003,
    // Extension: VK_BASE_VERSION_1_1
    VK_ERROR_OUT_OF_POOL_MEMORY = -1000069000,
    // Extension: VK_KHR_video_queue
    VK_ERROR_VIDEO_STD_VERSION_NOT_SUPPORTED_KHR = -1000023005,
    // Extension: VK_KHR_video_queue
    VK_ERROR_VIDEO_PROFILE_CODEC_NOT_SUPPORTED_KHR = -1000023004,
    // Extension: VK_KHR_video_queue
    VK_ERROR_VIDEO_PROFILE_FORMAT_NOT_SUPPORTED_KHR = -1000023003,
    // Extension: VK_KHR_video_queue
    VK_ERROR_VIDEO_PROFILE_OPERATION_NOT_SUPPORTED_KHR = -1000023002,
    // Extension: VK_KHR_video_queue
    VK_ERROR_VIDEO_PICTURE_LAYOUT_NOT_SUPPORTED_KHR = -1000023001,
    // Extension: VK_KHR_video_queue
    VK_ERROR_IMAGE_USAGE_NOT_SUPPORTED_KHR = -1000023000,
    // Extension: VK_NV_glsl_shader
    VK_ERROR_INVALID_SHADER_NV = -1000012000,
    // Extension: VK_BASE_VERSION_1_0
    VK_ERROR_VALIDATION_FAILED = -1000011001,
    // Extension: VK_KHR_display_swapchain
    VK_ERROR_INCOMPATIBLE_DISPLAY_KHR = -1000003001,
    // Extension: VK_KHR_swapchain
    VK_ERROR_OUT_OF_DATE_KHR = -1000001004,
    // Extension: VK_KHR_surface
    VK_ERROR_NATIVE_WINDOW_IN_USE_KHR = -1000000001,
    // Extension: VK_KHR_surface
    VK_ERROR_SURFACE_LOST_KHR = -1000000000,
    // Comment: An unknown error has occurred, due to an implementation or application bug
    VK_ERROR_UNKNOWN = -13,
    // Comment: A requested pool allocation has failed due to fragmentation of the pool's memory
    VK_ERROR_FRAGMENTED_POOL = -12,
    // Comment: Requested format is not supported on this device
    VK_ERROR_FORMAT_NOT_SUPPORTED = -11,
    // Comment: Too many objects of the type have already been created
    VK_ERROR_TOO_MANY_OBJECTS = -10,
    // Comment: Unable to find a Vulkan driver
    VK_ERROR_INCOMPATIBLE_DRIVER = -9,
    // Comment: Requested feature is not available on this device
    VK_ERROR_FEATURE_NOT_PRESENT = -8,
    // Comment: Extension specified does not exist
    VK_ERROR_EXTENSION_NOT_PRESENT = -7,
    // Comment: Layer specified does not exist
    VK_ERROR_LAYER_NOT_PRESENT = -6,
    // Comment: Mapping of a memory object has failed
    VK_ERROR_MEMORY_MAP_FAILED = -5,
    // Comment: The logical device has been lost. See &lt;&lt;devsandqueues-lost-device&gt;&gt;
    VK_ERROR_DEVICE_LOST = -4,
    // Comment: Initialization of an object has failed
    VK_ERROR_INITIALIZATION_FAILED = -3,
    // Comment: A device memory allocation has failed
    VK_ERROR_OUT_OF_DEVICE_MEMORY = -2,
    // Comment: A host memory allocation has failed
    VK_ERROR_OUT_OF_HOST_MEMORY = -1,
    // Comment: Command completed successfully
    VK_SUCCESS = 0,
    // Comment: A fence or query has not yet completed
    VK_NOT_READY = 1,
    // Comment: A wait operation has not completed in the specified time
    VK_TIMEOUT = 2,
    // Comment: An event is signaled
    VK_EVENT_SET = 3,
    // Comment: An event is unsignaled
    VK_EVENT_RESET = 4,
    // Comment: A return array was too small for the result
    VK_INCOMPLETE = 5,
    // Extension: VK_KHR_swapchain
    VK_SUBOPTIMAL_KHR = 1000001003,
    // Extension: VK_KHR_deferred_host_operations
    VK_THREAD_IDLE_KHR = 1000268000,
    // Extension: VK_KHR_deferred_host_operations
    VK_THREAD_DONE_KHR = 1000268001,
    // Extension: VK_KHR_deferred_host_operations
    VK_OPERATION_DEFERRED_KHR = 1000268002,
    // Extension: VK_KHR_deferred_host_operations
    VK_OPERATION_NOT_DEFERRED_KHR = 1000268003,
    // Extension: VK_COMPUTE_VERSION_1_3
    VK_PIPELINE_COMPILE_REQUIRED = 1000297000,
    // Extension: VK_EXT_shader_object
    VK_INCOMPATIBLE_SHADER_BINARY_EXT = 1000482000,
    // Extension: VK_KHR_pipeline_binary
    VK_PIPELINE_BINARY_MISSING_KHR = 1000483000,
    _,
};
pub const VkDynamicState = enum(i32) {
    VK_DYNAMIC_STATE_VIEWPORT = 0,
    VK_DYNAMIC_STATE_SCISSOR = 1,
    VK_DYNAMIC_STATE_LINE_WIDTH = 2,
    VK_DYNAMIC_STATE_DEPTH_BIAS = 3,
    VK_DYNAMIC_STATE_BLEND_CONSTANTS = 4,
    VK_DYNAMIC_STATE_DEPTH_BOUNDS = 5,
    VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK = 6,
    VK_DYNAMIC_STATE_STENCIL_WRITE_MASK = 7,
    VK_DYNAMIC_STATE_STENCIL_REFERENCE = 8,
    // Extension: VK_NV_clip_space_w_scaling
    VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV = 1000087000,
    // Extension: VK_EXT_discard_rectangles
    VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT = 1000099000,
    // Extension: VK_EXT_discard_rectangles
    VK_DYNAMIC_STATE_DISCARD_RECTANGLE_ENABLE_EXT = 1000099001,
    // Extension: VK_EXT_discard_rectangles
    VK_DYNAMIC_STATE_DISCARD_RECTANGLE_MODE_EXT = 1000099002,
    // Extension: VK_EXT_sample_locations
    VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT = 1000143000,
    // Extension: VK_NV_shading_rate_image
    VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV = 1000164004,
    // Extension: VK_NV_shading_rate_image
    VK_DYNAMIC_STATE_VIEWPORT_COARSE_SAMPLE_ORDER_NV = 1000164006,
    // Extension: VK_NV_scissor_exclusive
    VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_ENABLE_NV = 1000205000,
    // Extension: VK_NV_scissor_exclusive
    VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_NV = 1000205001,
    // Extension: VK_KHR_fragment_shading_rate
    VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR = 1000226000,
    // Extension: VK_GRAPHICS_VERSION_1_4
    VK_DYNAMIC_STATE_LINE_STIPPLE = 1000259000,
    // Extension: VK_GRAPHICS_VERSION_1_3
    VK_DYNAMIC_STATE_CULL_MODE = 1000267000,
    // Extension: VK_GRAPHICS_VERSION_1_3
    VK_DYNAMIC_STATE_FRONT_FACE = 1000267001,
    // Extension: VK_GRAPHICS_VERSION_1_3
    VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY = 1000267002,
    // Extension: VK_GRAPHICS_VERSION_1_3
    VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT = 1000267003,
    // Extension: VK_GRAPHICS_VERSION_1_3
    VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT = 1000267004,
    // Extension: VK_GRAPHICS_VERSION_1_3
    VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE = 1000267005,
    // Extension: VK_GRAPHICS_VERSION_1_3
    VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE = 1000267006,
    // Extension: VK_GRAPHICS_VERSION_1_3
    VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE = 1000267007,
    // Extension: VK_GRAPHICS_VERSION_1_3
    VK_DYNAMIC_STATE_DEPTH_COMPARE_OP = 1000267008,
    // Extension: VK_GRAPHICS_VERSION_1_3
    VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE = 1000267009,
    // Extension: VK_GRAPHICS_VERSION_1_3
    VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE = 1000267010,
    // Extension: VK_GRAPHICS_VERSION_1_3
    VK_DYNAMIC_STATE_STENCIL_OP = 1000267011,
    // Extension: VK_KHR_ray_tracing_pipeline
    VK_DYNAMIC_STATE_RAY_TRACING_PIPELINE_STACK_SIZE_KHR = 1000347000,
    // Extension: VK_EXT_vertex_input_dynamic_state
    VK_DYNAMIC_STATE_VERTEX_INPUT_EXT = 1000352000,
    // Extension: VK_EXT_extended_dynamic_state2
    VK_DYNAMIC_STATE_PATCH_CONTROL_POINTS_EXT = 1000377000,
    // Extension: VK_GRAPHICS_VERSION_1_3
    VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE = 1000377001,
    // Extension: VK_GRAPHICS_VERSION_1_3
    VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE = 1000377002,
    // Extension: VK_EXT_extended_dynamic_state2
    VK_DYNAMIC_STATE_LOGIC_OP_EXT = 1000377003,
    // Extension: VK_GRAPHICS_VERSION_1_3
    VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE = 1000377004,
    // Extension: VK_EXT_color_write_enable
    VK_DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT = 1000381000,
    // Extension: VK_EXT_extended_dynamic_state3
    VK_DYNAMIC_STATE_TESSELLATION_DOMAIN_ORIGIN_EXT = 1000455002,
    // Extension: VK_EXT_extended_dynamic_state3
    VK_DYNAMIC_STATE_DEPTH_CLAMP_ENABLE_EXT = 1000455003,
    // Extension: VK_EXT_extended_dynamic_state3
    VK_DYNAMIC_STATE_POLYGON_MODE_EXT = 1000455004,
    // Extension: VK_EXT_extended_dynamic_state3
    VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT = 1000455005,
    // Extension: VK_EXT_extended_dynamic_state3
    VK_DYNAMIC_STATE_SAMPLE_MASK_EXT = 1000455006,
    // Extension: VK_EXT_extended_dynamic_state3
    VK_DYNAMIC_STATE_ALPHA_TO_COVERAGE_ENABLE_EXT = 1000455007,
    // Extension: VK_EXT_extended_dynamic_state3
    VK_DYNAMIC_STATE_ALPHA_TO_ONE_ENABLE_EXT = 1000455008,
    // Extension: VK_EXT_extended_dynamic_state3
    VK_DYNAMIC_STATE_LOGIC_OP_ENABLE_EXT = 1000455009,
    // Extension: VK_EXT_extended_dynamic_state3
    VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT = 1000455010,
    // Extension: VK_EXT_extended_dynamic_state3
    VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT = 1000455011,
    // Extension: VK_EXT_extended_dynamic_state3
    VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT = 1000455012,
    // Extension: VK_EXT_extended_dynamic_state3
    VK_DYNAMIC_STATE_RASTERIZATION_STREAM_EXT = 1000455013,
    // Extension: VK_EXT_extended_dynamic_state3
    VK_DYNAMIC_STATE_CONSERVATIVE_RASTERIZATION_MODE_EXT = 1000455014,
    // Extension: VK_EXT_extended_dynamic_state3
    VK_DYNAMIC_STATE_EXTRA_PRIMITIVE_OVERESTIMATION_SIZE_EXT = 1000455015,
    // Extension: VK_EXT_extended_dynamic_state3
    VK_DYNAMIC_STATE_DEPTH_CLIP_ENABLE_EXT = 1000455016,
    // Extension: VK_EXT_extended_dynamic_state3
    VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT = 1000455017,
    // Extension: VK_EXT_extended_dynamic_state3
    VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT = 1000455018,
    // Extension: VK_EXT_extended_dynamic_state3
    VK_DYNAMIC_STATE_PROVOKING_VERTEX_MODE_EXT = 1000455019,
    // Extension: VK_EXT_extended_dynamic_state3
    VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT = 1000455020,
    // Extension: VK_EXT_extended_dynamic_state3
    VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT = 1000455021,
    // Extension: VK_EXT_extended_dynamic_state3
    VK_DYNAMIC_STATE_DEPTH_CLIP_NEGATIVE_ONE_TO_ONE_EXT = 1000455022,
    // Extension: VK_EXT_extended_dynamic_state3
    VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_ENABLE_NV = 1000455023,
    // Extension: VK_EXT_extended_dynamic_state3
    VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV = 1000455024,
    // Extension: VK_EXT_extended_dynamic_state3
    VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV = 1000455025,
    // Extension: VK_EXT_extended_dynamic_state3
    VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_LOCATION_NV = 1000455026,
    // Extension: VK_EXT_extended_dynamic_state3
    VK_DYNAMIC_STATE_COVERAGE_MODULATION_MODE_NV = 1000455027,
    // Extension: VK_EXT_extended_dynamic_state3
    VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_ENABLE_NV = 1000455028,
    // Extension: VK_EXT_extended_dynamic_state3
    VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_NV = 1000455029,
    // Extension: VK_EXT_extended_dynamic_state3
    VK_DYNAMIC_STATE_SHADING_RATE_IMAGE_ENABLE_NV = 1000455030,
    // Extension: VK_EXT_extended_dynamic_state3
    VK_DYNAMIC_STATE_REPRESENTATIVE_FRAGMENT_TEST_ENABLE_NV = 1000455031,
    // Extension: VK_EXT_extended_dynamic_state3
    VK_DYNAMIC_STATE_COVERAGE_REDUCTION_MODE_NV = 1000455032,
    // Extension: VK_EXT_attachment_feedback_loop_dynamic_state
    VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT = 1000524000,
    // Extension: VK_EXT_depth_clamp_control
    VK_DYNAMIC_STATE_DEPTH_CLAMP_RANGE_EXT = 1000582000,
    _,
};
pub const VkDescriptorUpdateTemplateType = enum(i32) {
    // Comment: Create descriptor update template for descriptor set updates
    VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET = 0,
    // Extension: VK_COMPUTE_VERSION_1_4
    VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS = 1,
    _,
};
pub const VkObjectType = enum(i32) {
    VK_OBJECT_TYPE_UNKNOWN = 0,
    VK_OBJECT_TYPE_INSTANCE = 1,
    VK_OBJECT_TYPE_PHYSICAL_DEVICE = 2,
    VK_OBJECT_TYPE_DEVICE = 3,
    VK_OBJECT_TYPE_QUEUE = 4,
    VK_OBJECT_TYPE_SEMAPHORE = 5,
    VK_OBJECT_TYPE_COMMAND_BUFFER = 6,
    VK_OBJECT_TYPE_FENCE = 7,
    VK_OBJECT_TYPE_DEVICE_MEMORY = 8,
    VK_OBJECT_TYPE_BUFFER = 9,
    VK_OBJECT_TYPE_IMAGE = 10,
    VK_OBJECT_TYPE_EVENT = 11,
    VK_OBJECT_TYPE_QUERY_POOL = 12,
    VK_OBJECT_TYPE_BUFFER_VIEW = 13,
    VK_OBJECT_TYPE_IMAGE_VIEW = 14,
    VK_OBJECT_TYPE_SHADER_MODULE = 15,
    VK_OBJECT_TYPE_PIPELINE_CACHE = 16,
    VK_OBJECT_TYPE_PIPELINE_LAYOUT = 17,
    VK_OBJECT_TYPE_RENDER_PASS = 18,
    VK_OBJECT_TYPE_PIPELINE = 19,
    VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT = 20,
    VK_OBJECT_TYPE_SAMPLER = 21,
    VK_OBJECT_TYPE_DESCRIPTOR_POOL = 22,
    VK_OBJECT_TYPE_DESCRIPTOR_SET = 23,
    VK_OBJECT_TYPE_FRAMEBUFFER = 24,
    VK_OBJECT_TYPE_COMMAND_POOL = 25,
    // Extension: VK_KHR_surface
    VK_OBJECT_TYPE_SURFACE_KHR = 1000000000,
    // Extension: VK_KHR_swapchain
    VK_OBJECT_TYPE_SWAPCHAIN_KHR = 1000001000,
    // Extension: VK_KHR_display
    VK_OBJECT_TYPE_DISPLAY_KHR = 1000002000,
    // Extension: VK_KHR_display
    VK_OBJECT_TYPE_DISPLAY_MODE_KHR = 1000002001,
    // Extension: VK_EXT_debug_report
    VK_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT = 1000011000,
    // Extension: VK_KHR_video_queue
    VK_OBJECT_TYPE_VIDEO_SESSION_KHR = 1000023000,
    // Extension: VK_KHR_video_queue
    VK_OBJECT_TYPE_VIDEO_SESSION_PARAMETERS_KHR = 1000023001,
    // Extension: VK_NVX_binary_import
    VK_OBJECT_TYPE_CU_MODULE_NVX = 1000029000,
    // Extension: VK_NVX_binary_import
    VK_OBJECT_TYPE_CU_FUNCTION_NVX = 1000029001,
    // Extension: VK_COMPUTE_VERSION_1_1
    VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE = 1000085000,
    // Extension: VK_EXT_debug_utils
    VK_OBJECT_TYPE_DEBUG_UTILS_MESSENGER_EXT = 1000128000,
    // Extension: VK_KHR_acceleration_structure
    VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_KHR = 1000150000,
    // Extension: VK_COMPUTE_VERSION_1_1
    VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION = 1000156000,
    // Extension: VK_EXT_validation_cache
    VK_OBJECT_TYPE_VALIDATION_CACHE_EXT = 1000160000,
    // Extension: VK_NV_ray_tracing
    VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV = 1000165000,
    // Extension: VK_INTEL_performance_query
    VK_OBJECT_TYPE_PERFORMANCE_CONFIGURATION_INTEL = 1000210000,
    // Extension: VK_KHR_deferred_host_operations
    VK_OBJECT_TYPE_DEFERRED_OPERATION_KHR = 1000268000,
    // Extension: VK_NV_device_generated_commands
    VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NV = 1000277000,
    // Extension: VK_BASE_VERSION_1_3
    VK_OBJECT_TYPE_PRIVATE_DATA_SLOT = 1000295000,
    // Extension: VK_NV_cuda_kernel_launch
    VK_OBJECT_TYPE_CUDA_MODULE_NV = 1000307000,
    // Extension: VK_NV_cuda_kernel_launch
    VK_OBJECT_TYPE_CUDA_FUNCTION_NV = 1000307001,
    // Extension: VK_FUCHSIA_buffer_collection
    VK_OBJECT_TYPE_BUFFER_COLLECTION_FUCHSIA = 1000366000,
    // Extension: VK_EXT_opacity_micromap
    VK_OBJECT_TYPE_MICROMAP_EXT = 1000396000,
    // Extension: VK_ARM_tensors
    VK_OBJECT_TYPE_TENSOR_ARM = 1000460000,
    // Extension: VK_ARM_tensors
    VK_OBJECT_TYPE_TENSOR_VIEW_ARM = 1000460001,
    // Extension: VK_NV_optical_flow
    VK_OBJECT_TYPE_OPTICAL_FLOW_SESSION_NV = 1000464000,
    // Extension: VK_EXT_shader_object
    VK_OBJECT_TYPE_SHADER_EXT = 1000482000,
    // Extension: VK_KHR_pipeline_binary
    VK_OBJECT_TYPE_PIPELINE_BINARY_KHR = 1000483000,
    // Extension: VK_NV_external_sci_sync2
    VK_OBJECT_TYPE_SEMAPHORE_SCI_SYNC_POOL_NV = 1000489000,
    // Extension: VK_ARM_data_graph
    VK_OBJECT_TYPE_DATA_GRAPH_PIPELINE_SESSION_ARM = 1000507000,
    // Extension: VK_NV_external_compute_queue
    VK_OBJECT_TYPE_EXTERNAL_COMPUTE_QUEUE_NV = 1000556000,
    // Extension: VK_EXT_device_generated_commands
    VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_EXT = 1000572000,
    // Extension: VK_EXT_device_generated_commands
    VK_OBJECT_TYPE_INDIRECT_EXECUTION_SET_EXT = 1000572001,
    _,
};
pub const VkRayTracingInvocationReorderModeEXT = enum(i32) {
    VK_RAY_TRACING_INVOCATION_REORDER_MODE_NONE_EXT = 0,
    VK_RAY_TRACING_INVOCATION_REORDER_MODE_REORDER_EXT = 1,
    _,
};
pub const VkRayTracingLssIndexingModeNV = enum(i32) {
    VK_RAY_TRACING_LSS_INDEXING_MODE_LIST_NV = 0,
    VK_RAY_TRACING_LSS_INDEXING_MODE_SUCCESSIVE_NV = 1,
    _,
};
pub const VkRayTracingLssPrimitiveEndCapsModeNV = enum(i32) {
    VK_RAY_TRACING_LSS_PRIMITIVE_END_CAPS_MODE_NONE_NV = 0,
    VK_RAY_TRACING_LSS_PRIMITIVE_END_CAPS_MODE_CHAINED_NV = 1,
    _,
};
pub const VkDirectDriverLoadingModeLUNARG = enum(i32) {
    VK_DIRECT_DRIVER_LOADING_MODE_EXCLUSIVE_LUNARG = 0,
    VK_DIRECT_DRIVER_LOADING_MODE_INCLUSIVE_LUNARG = 1,
    _,
};
pub const VkAntiLagModeAMD = enum(i32) {
    VK_ANTI_LAG_MODE_DRIVER_CONTROL_AMD = 0,
    VK_ANTI_LAG_MODE_ON_AMD = 1,
    VK_ANTI_LAG_MODE_OFF_AMD = 2,
    _,
};
pub const VkAntiLagStageAMD = enum(i32) {
    VK_ANTI_LAG_STAGE_INPUT_AMD = 0,
    VK_ANTI_LAG_STAGE_PRESENT_AMD = 1,
    _,
};
pub const VkSemaphoreType = enum(i32) {
    VK_SEMAPHORE_TYPE_BINARY = 0,
    VK_SEMAPHORE_TYPE_TIMELINE = 1,
    _,
};
pub const VkPresentModeKHR = enum(i32) {
    VK_PRESENT_MODE_IMMEDIATE_KHR = 0,
    VK_PRESENT_MODE_MAILBOX_KHR = 1,
    VK_PRESENT_MODE_FIFO_KHR = 2,
    VK_PRESENT_MODE_FIFO_RELAXED_KHR = 3,
    // Extension: VK_KHR_shared_presentable_image
    VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR = 1000111000,
    // Extension: VK_KHR_shared_presentable_image
    VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR = 1000111001,
    // Extension: VK_KHR_present_mode_fifo_latest_ready
    VK_PRESENT_MODE_FIFO_LATEST_READY_KHR = 1000361000,
    _,
};
pub const VkColorSpaceKHR = enum(i32) {
    VK_COLOR_SPACE_SRGB_NONLINEAR_KHR = 0,
    // Extension: VK_EXT_swapchain_colorspace
    VK_COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT = 1000104001,
    // Extension: VK_EXT_swapchain_colorspace
    VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT = 1000104002,
    // Extension: VK_EXT_swapchain_colorspace
    VK_COLOR_SPACE_DISPLAY_P3_LINEAR_EXT = 1000104003,
    // Extension: VK_EXT_swapchain_colorspace
    VK_COLOR_SPACE_DCI_P3_NONLINEAR_EXT = 1000104004,
    // Extension: VK_EXT_swapchain_colorspace
    VK_COLOR_SPACE_BT709_LINEAR_EXT = 1000104005,
    // Extension: VK_EXT_swapchain_colorspace
    VK_COLOR_SPACE_BT709_NONLINEAR_EXT = 1000104006,
    // Extension: VK_EXT_swapchain_colorspace
    VK_COLOR_SPACE_BT2020_LINEAR_EXT = 1000104007,
    // Extension: VK_EXT_swapchain_colorspace
    VK_COLOR_SPACE_HDR10_ST2084_EXT = 1000104008,
    // Extension: VK_EXT_swapchain_colorspace
    VK_COLOR_SPACE_DOLBYVISION_EXT = 1000104009,
    // Extension: VK_EXT_swapchain_colorspace
    VK_COLOR_SPACE_HDR10_HLG_EXT = 1000104010,
    // Extension: VK_EXT_swapchain_colorspace
    VK_COLOR_SPACE_ADOBERGB_LINEAR_EXT = 1000104011,
    // Extension: VK_EXT_swapchain_colorspace
    VK_COLOR_SPACE_ADOBERGB_NONLINEAR_EXT = 1000104012,
    // Extension: VK_EXT_swapchain_colorspace
    VK_COLOR_SPACE_PASS_THROUGH_EXT = 1000104013,
    // Extension: VK_EXT_swapchain_colorspace
    VK_COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT = 1000104014,
    // Extension: VK_AMD_display_native_hdr
    VK_COLOR_SPACE_DISPLAY_NATIVE_AMD = 1000213000,
    _,
};
pub const VkDisplaySurfaceStereoTypeNV = enum(i32) {
    VK_DISPLAY_SURFACE_STEREO_TYPE_NONE_NV = 0,
    VK_DISPLAY_SURFACE_STEREO_TYPE_ONBOARD_DIN_NV = 1,
    VK_DISPLAY_SURFACE_STEREO_TYPE_HDMI_3D_NV = 2,
    VK_DISPLAY_SURFACE_STEREO_TYPE_INBAND_DISPLAYPORT_NV = 3,
    _,
};
pub const VkTimeDomainKHR = enum(i32) {
    VK_TIME_DOMAIN_DEVICE_KHR = 0,
    VK_TIME_DOMAIN_CLOCK_MONOTONIC_KHR = 1,
    VK_TIME_DOMAIN_CLOCK_MONOTONIC_RAW_KHR = 2,
    VK_TIME_DOMAIN_QUERY_PERFORMANCE_COUNTER_KHR = 3,
    // Extension: VK_EXT_present_timing
    VK_TIME_DOMAIN_PRESENT_STAGE_LOCAL_EXT = 1000208000,
    // Extension: VK_EXT_present_timing
    VK_TIME_DOMAIN_SWAPCHAIN_LOCAL_EXT = 1000208001,
    _,
};
pub const VkDebugReportObjectTypeEXT = enum(i32) {
    VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT = 0,
    VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT = 1,
    VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT = 2,
    VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT = 3,
    VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT = 4,
    VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT = 5,
    VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT = 6,
    VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT = 7,
    VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT = 8,
    VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT = 9,
    VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT = 10,
    VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT = 11,
    VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT = 12,
    VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT = 13,
    VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT = 14,
    VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT = 15,
    VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT = 16,
    VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT = 17,
    VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT = 18,
    VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT = 19,
    VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT = 20,
    VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT = 21,
    VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT = 22,
    VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT = 23,
    VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT = 24,
    VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT = 25,
    VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT = 26,
    VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT = 27,
    VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT = 28,
    VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_KHR_EXT = 29,
    VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_MODE_KHR_EXT = 30,
    VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT = 33,
    // Extension: VK_NVX_binary_import
    VK_DEBUG_REPORT_OBJECT_TYPE_CU_MODULE_NVX_EXT = 1000029000,
    // Extension: VK_NVX_binary_import
    VK_DEBUG_REPORT_OBJECT_TYPE_CU_FUNCTION_NVX_EXT = 1000029001,
    // Extension: VK_EXT_debug_report
    VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_EXT = 1000085000,
    // Extension: VK_KHR_acceleration_structure
    VK_DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_KHR_EXT = 1000150000,
    // Extension: VK_EXT_debug_report
    // Extension: VK_KHR_sampler_ycbcr_conversion
    VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT = 1000156000,
    // Extension: VK_NV_ray_tracing
    VK_DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV_EXT = 1000165000,
    // Extension: VK_NV_cuda_kernel_launch
    VK_DEBUG_REPORT_OBJECT_TYPE_CUDA_MODULE_NV_EXT = 1000307000,
    // Extension: VK_NV_cuda_kernel_launch
    VK_DEBUG_REPORT_OBJECT_TYPE_CUDA_FUNCTION_NV_EXT = 1000307001,
    // Extension: VK_FUCHSIA_buffer_collection
    VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_COLLECTION_FUCHSIA_EXT = 1000366000,
    _,
};
pub const VkDeviceMemoryReportEventTypeEXT = enum(i32) {
    VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATE_EXT = 0,
    VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_FREE_EXT = 1,
    VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_IMPORT_EXT = 2,
    VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_UNIMPORT_EXT = 3,
    VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATION_FAILED_EXT = 4,
    _,
};
pub const VkRasterizationOrderAMD = enum(i32) {
    VK_RASTERIZATION_ORDER_STRICT_AMD = 0,
    VK_RASTERIZATION_ORDER_RELAXED_AMD = 1,
    _,
};
pub const VkClusterAccelerationStructureTypeNV = enum(i32) {
    VK_CLUSTER_ACCELERATION_STRUCTURE_TYPE_CLUSTERS_BOTTOM_LEVEL_NV = 0,
    VK_CLUSTER_ACCELERATION_STRUCTURE_TYPE_TRIANGLE_CLUSTER_NV = 1,
    VK_CLUSTER_ACCELERATION_STRUCTURE_TYPE_TRIANGLE_CLUSTER_TEMPLATE_NV = 2,
    _,
};
pub const VkClusterAccelerationStructureOpTypeNV = enum(i32) {
    VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_MOVE_OBJECTS_NV = 0,
    VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_BUILD_CLUSTERS_BOTTOM_LEVEL_NV = 1,
    VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_BUILD_TRIANGLE_CLUSTER_NV = 2,
    VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_BUILD_TRIANGLE_CLUSTER_TEMPLATE_NV = 3,
    VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_INSTANTIATE_TRIANGLE_CLUSTER_NV = 4,
    VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_GET_CLUSTER_TEMPLATE_INDICES_NV = 5,
    _,
};
pub const VkClusterAccelerationStructureOpModeNV = enum(i32) {
    VK_CLUSTER_ACCELERATION_STRUCTURE_OP_MODE_IMPLICIT_DESTINATIONS_NV = 0,
    VK_CLUSTER_ACCELERATION_STRUCTURE_OP_MODE_EXPLICIT_DESTINATIONS_NV = 1,
    VK_CLUSTER_ACCELERATION_STRUCTURE_OP_MODE_COMPUTE_SIZES_NV = 2,
    _,
};
pub const VkValidationCheckEXT = enum(i32) {
    VK_VALIDATION_CHECK_ALL_EXT = 0,
    VK_VALIDATION_CHECK_SHADERS_EXT = 1,
    _,
};
pub const VkValidationFeatureEnableEXT = enum(i32) {
    VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_EXT = 0,
    VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_RESERVE_BINDING_SLOT_EXT = 1,
    VK_VALIDATION_FEATURE_ENABLE_BEST_PRACTICES_EXT = 2,
    VK_VALIDATION_FEATURE_ENABLE_DEBUG_PRINTF_EXT = 3,
    VK_VALIDATION_FEATURE_ENABLE_SYNCHRONIZATION_VALIDATION_EXT = 4,
    _,
};
pub const VkValidationFeatureDisableEXT = enum(i32) {
    VK_VALIDATION_FEATURE_DISABLE_ALL_EXT = 0,
    VK_VALIDATION_FEATURE_DISABLE_SHADERS_EXT = 1,
    VK_VALIDATION_FEATURE_DISABLE_THREAD_SAFETY_EXT = 2,
    VK_VALIDATION_FEATURE_DISABLE_API_PARAMETERS_EXT = 3,
    VK_VALIDATION_FEATURE_DISABLE_OBJECT_LIFETIMES_EXT = 4,
    VK_VALIDATION_FEATURE_DISABLE_CORE_CHECKS_EXT = 5,
    VK_VALIDATION_FEATURE_DISABLE_UNIQUE_HANDLES_EXT = 6,
    VK_VALIDATION_FEATURE_DISABLE_SHADER_VALIDATION_CACHE_EXT = 7,
    _,
};
pub const VkLayerSettingTypeEXT = enum(i32) {
    VK_LAYER_SETTING_TYPE_BOOL32_EXT = 0,
    VK_LAYER_SETTING_TYPE_INT32_EXT = 1,
    VK_LAYER_SETTING_TYPE_INT64_EXT = 2,
    VK_LAYER_SETTING_TYPE_UINT32_EXT = 3,
    VK_LAYER_SETTING_TYPE_UINT64_EXT = 4,
    VK_LAYER_SETTING_TYPE_FLOAT32_EXT = 5,
    VK_LAYER_SETTING_TYPE_FLOAT64_EXT = 6,
    VK_LAYER_SETTING_TYPE_STRING_EXT = 7,
    _,
};
pub const VkIndirectCommandsTokenTypeNV = enum(i32) {
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_SHADER_GROUP_NV = 0,
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_STATE_FLAGS_NV = 1,
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_NV = 2,
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_NV = 3,
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NV = 4,
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_NV = 5,
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_NV = 6,
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_TASKS_NV = 7,
    // Extension: VK_EXT_mesh_shader
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_NV = 1000328000,
    // Extension: VK_NV_device_generated_commands_compute
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_PIPELINE_NV = 1000428003,
    // Extension: VK_NV_device_generated_commands_compute
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_NV = 1000428004,
    _,
};
pub const VkDisplayPowerStateEXT = enum(i32) {
    VK_DISPLAY_POWER_STATE_OFF_EXT = 0,
    VK_DISPLAY_POWER_STATE_SUSPEND_EXT = 1,
    VK_DISPLAY_POWER_STATE_ON_EXT = 2,
    _,
};
pub const VkDeviceEventTypeEXT = enum(i32) {
    VK_DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG_EXT = 0,
    _,
};
pub const VkDisplayEventTypeEXT = enum(i32) {
    VK_DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT_EXT = 0,
    _,
};
pub const VkViewportCoordinateSwizzleNV = enum(i32) {
    VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_X_NV = 0,
    VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_X_NV = 1,
    VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Y_NV = 2,
    VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Y_NV = 3,
    VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Z_NV = 4,
    VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Z_NV = 5,
    VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_W_NV = 6,
    VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_W_NV = 7,
    _,
};
pub const VkDiscardRectangleModeEXT = enum(i32) {
    VK_DISCARD_RECTANGLE_MODE_INCLUSIVE_EXT = 0,
    VK_DISCARD_RECTANGLE_MODE_EXCLUSIVE_EXT = 1,
    _,
};
pub const VkPointClippingBehavior = enum(i32) {
    VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES = 0,
    VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY = 1,
    _,
};
pub const VkSamplerReductionMode = enum(i32) {
    VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE = 0,
    VK_SAMPLER_REDUCTION_MODE_MIN = 1,
    VK_SAMPLER_REDUCTION_MODE_MAX = 2,
    // Extension: VK_QCOM_filter_cubic_clamp
    VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_RANGECLAMP_QCOM = 1000521000,
    _,
};
pub const VkTessellationDomainOrigin = enum(i32) {
    VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT = 0,
    VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT = 1,
    _,
};
pub const VkSamplerYcbcrModelConversion = enum(i32) {
    VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY = 0,
    // Comment: just range expansion
    VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY = 1,
    // Comment: aka HD YUV
    VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709 = 2,
    // Comment: aka SD YUV
    VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601 = 3,
    // Comment: aka UHD YUV
    VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020 = 4,
    _,
};
pub const VkSamplerYcbcrRange = enum(i32) {
    // Comment: Luma 0..1 maps to 0..255, chroma -0.5..0.5 to 1..255 (clamped)
    VK_SAMPLER_YCBCR_RANGE_ITU_FULL = 0,
    // Comment: Luma 0..1 maps to 16..235, chroma -0.5..0.5 to 16..240
    VK_SAMPLER_YCBCR_RANGE_ITU_NARROW = 1,
    _,
};
pub const VkChromaLocation = enum(i32) {
    VK_CHROMA_LOCATION_COSITED_EVEN = 0,
    VK_CHROMA_LOCATION_MIDPOINT = 1,
    _,
};
pub const VkBlendOverlapEXT = enum(i32) {
    VK_BLEND_OVERLAP_UNCORRELATED_EXT = 0,
    VK_BLEND_OVERLAP_DISJOINT_EXT = 1,
    VK_BLEND_OVERLAP_CONJOINT_EXT = 2,
    _,
};
pub const VkCoverageModulationModeNV = enum(i32) {
    VK_COVERAGE_MODULATION_MODE_NONE_NV = 0,
    VK_COVERAGE_MODULATION_MODE_RGB_NV = 1,
    VK_COVERAGE_MODULATION_MODE_ALPHA_NV = 2,
    VK_COVERAGE_MODULATION_MODE_RGBA_NV = 3,
    _,
};
pub const VkCoverageReductionModeNV = enum(i32) {
    VK_COVERAGE_REDUCTION_MODE_MERGE_NV = 0,
    VK_COVERAGE_REDUCTION_MODE_TRUNCATE_NV = 1,
    _,
};
pub const VkValidationCacheHeaderVersionEXT = enum(i32) {
    VK_VALIDATION_CACHE_HEADER_VERSION_ONE_EXT = 1,
    _,
};
pub const VkShaderInfoTypeAMD = enum(i32) {
    VK_SHADER_INFO_TYPE_STATISTICS_AMD = 0,
    VK_SHADER_INFO_TYPE_BINARY_AMD = 1,
    VK_SHADER_INFO_TYPE_DISASSEMBLY_AMD = 2,
    _,
};
pub const VkQueueGlobalPriority = enum(i32) {
    VK_QUEUE_GLOBAL_PRIORITY_LOW = 128,
    VK_QUEUE_GLOBAL_PRIORITY_MEDIUM = 256,
    VK_QUEUE_GLOBAL_PRIORITY_HIGH = 512,
    VK_QUEUE_GLOBAL_PRIORITY_REALTIME = 1024,
    _,
};
pub const VkConservativeRasterizationModeEXT = enum(i32) {
    VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT = 0,
    VK_CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT = 1,
    VK_CONSERVATIVE_RASTERIZATION_MODE_UNDERESTIMATE_EXT = 2,
    _,
};
pub const VkVendorId = enum(i32) {
    // Comment: Khronos vendor ID
    VK_VENDOR_ID_KHRONOS = 65536,
    // Comment: Vivante vendor ID
    VK_VENDOR_ID_VIV = 65537,
    // Comment: VeriSilicon vendor ID
    VK_VENDOR_ID_VSI = 65538,
    // Comment: Kazan Software Renderer
    VK_VENDOR_ID_KAZAN = 65539,
    // Comment: Codeplay Software Ltd. vendor ID
    VK_VENDOR_ID_CODEPLAY = 65540,
    // Comment: Mesa vendor ID
    VK_VENDOR_ID_MESA = 65541,
    // Comment: PoCL vendor ID
    VK_VENDOR_ID_POCL = 65542,
    // Comment: Mobileye vendor ID
    VK_VENDOR_ID_MOBILEYE = 65543,
    _,
};
pub const VkDriverId = enum(i32) {
    // Comment: Advanced Micro Devices, Inc.
    VK_DRIVER_ID_AMD_PROPRIETARY = 1,
    // Comment: Advanced Micro Devices, Inc.
    VK_DRIVER_ID_AMD_OPEN_SOURCE = 2,
    // Comment: Mesa open source project
    VK_DRIVER_ID_MESA_RADV = 3,
    // Comment: NVIDIA Corporation
    VK_DRIVER_ID_NVIDIA_PROPRIETARY = 4,
    // Comment: Intel Corporation
    VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS = 5,
    // Comment: Intel Corporation
    VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA = 6,
    // Comment: Imagination Technologies
    VK_DRIVER_ID_IMAGINATION_PROPRIETARY = 7,
    // Comment: Qualcomm Technologies, Inc.
    VK_DRIVER_ID_QUALCOMM_PROPRIETARY = 8,
    // Comment: Arm Limited
    VK_DRIVER_ID_ARM_PROPRIETARY = 9,
    // Comment: Google LLC
    VK_DRIVER_ID_GOOGLE_SWIFTSHADER = 10,
    // Comment: Google LLC
    VK_DRIVER_ID_GGP_PROPRIETARY = 11,
    // Comment: Broadcom Inc.
    VK_DRIVER_ID_BROADCOM_PROPRIETARY = 12,
    // Comment: Mesa
    VK_DRIVER_ID_MESA_LLVMPIPE = 13,
    // Comment: MoltenVK
    VK_DRIVER_ID_MOLTENVK = 14,
    // Comment: Core Avionics &amp; Industrial Inc.
    VK_DRIVER_ID_COREAVI_PROPRIETARY = 15,
    // Comment: Juice Technologies, Inc.
    VK_DRIVER_ID_JUICE_PROPRIETARY = 16,
    // Comment: Verisilicon, Inc.
    VK_DRIVER_ID_VERISILICON_PROPRIETARY = 17,
    // Comment: Mesa open source project
    VK_DRIVER_ID_MESA_TURNIP = 18,
    // Comment: Mesa open source project
    VK_DRIVER_ID_MESA_V3DV = 19,
    // Comment: Mesa open source project
    VK_DRIVER_ID_MESA_PANVK = 20,
    // Comment: Samsung Electronics Co., Ltd.
    VK_DRIVER_ID_SAMSUNG_PROPRIETARY = 21,
    // Comment: Mesa open source project
    VK_DRIVER_ID_MESA_VENUS = 22,
    // Comment: Mesa open source project
    VK_DRIVER_ID_MESA_DOZEN = 23,
    // Comment: Mesa open source project
    VK_DRIVER_ID_MESA_NVK = 24,
    // Comment: Imagination Technologies
    VK_DRIVER_ID_IMAGINATION_OPEN_SOURCE_MESA = 25,
    // Comment: Mesa open source project
    VK_DRIVER_ID_MESA_HONEYKRISP = 26,
    // Comment: Vulkan SC Emulation on Vulkan
    VK_DRIVER_ID_VULKAN_SC_EMULATION_ON_VULKAN = 27,
    // Comment: Mesa open source project
    VK_DRIVER_ID_MESA_KOSMICKRISP = 28,
    _,
};
pub const VkShadingRatePaletteEntryNV = enum(i32) {
    VK_SHADING_RATE_PALETTE_ENTRY_NO_INVOCATIONS_NV = 0,
    VK_SHADING_RATE_PALETTE_ENTRY_16_INVOCATIONS_PER_PIXEL_NV = 1,
    VK_SHADING_RATE_PALETTE_ENTRY_8_INVOCATIONS_PER_PIXEL_NV = 2,
    VK_SHADING_RATE_PALETTE_ENTRY_4_INVOCATIONS_PER_PIXEL_NV = 3,
    VK_SHADING_RATE_PALETTE_ENTRY_2_INVOCATIONS_PER_PIXEL_NV = 4,
    VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_PIXEL_NV = 5,
    VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X1_PIXELS_NV = 6,
    VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_1X2_PIXELS_NV = 7,
    VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X2_PIXELS_NV = 8,
    VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X2_PIXELS_NV = 9,
    VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X4_PIXELS_NV = 10,
    VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X4_PIXELS_NV = 11,
    _,
};
pub const VkCoarseSampleOrderTypeNV = enum(i32) {
    VK_COARSE_SAMPLE_ORDER_TYPE_DEFAULT_NV = 0,
    VK_COARSE_SAMPLE_ORDER_TYPE_CUSTOM_NV = 1,
    VK_COARSE_SAMPLE_ORDER_TYPE_PIXEL_MAJOR_NV = 2,
    VK_COARSE_SAMPLE_ORDER_TYPE_SAMPLE_MAJOR_NV = 3,
    _,
};
pub const VkCopyAccelerationStructureModeKHR = enum(i32) {
    VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_KHR = 0,
    VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_KHR = 1,
    // Extension: VK_KHR_acceleration_structure
    VK_COPY_ACCELERATION_STRUCTURE_MODE_SERIALIZE_KHR = 2,
    // Extension: VK_KHR_acceleration_structure
    VK_COPY_ACCELERATION_STRUCTURE_MODE_DESERIALIZE_KHR = 3,
    _,
};
pub const VkBuildAccelerationStructureModeKHR = enum(i32) {
    VK_BUILD_ACCELERATION_STRUCTURE_MODE_BUILD_KHR = 0,
    VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR = 1,
    _,
};
pub const VkAccelerationStructureTypeKHR = enum(i32) {
    VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR = 0,
    VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR = 1,
    VK_ACCELERATION_STRUCTURE_TYPE_GENERIC_KHR = 2,
    _,
};
pub const VkGeometryTypeKHR = enum(i32) {
    VK_GEOMETRY_TYPE_TRIANGLES_KHR = 0,
    VK_GEOMETRY_TYPE_AABBS_KHR = 1,
    VK_GEOMETRY_TYPE_INSTANCES_KHR = 2,
    // Extension: VK_NV_ray_tracing_linear_swept_spheres
    VK_GEOMETRY_TYPE_SPHERES_NV = 1000429004,
    // Extension: VK_NV_ray_tracing_linear_swept_spheres
    VK_GEOMETRY_TYPE_LINEAR_SWEPT_SPHERES_NV = 1000429005,
    // Extension: VK_AMDX_dense_geometry_format
    VK_GEOMETRY_TYPE_DENSE_GEOMETRY_FORMAT_TRIANGLES_AMDX = 1000478000,
    _,
};
pub const VkAccelerationStructureMemoryRequirementsTypeNV = enum(i32) {
    VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_OBJECT_NV = 0,
    VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_BUILD_SCRATCH_NV = 1,
    VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_UPDATE_SCRATCH_NV = 2,
    _,
};
pub const VkAccelerationStructureBuildTypeKHR = enum(i32) {
    VK_ACCELERATION_STRUCTURE_BUILD_TYPE_HOST_KHR = 0,
    VK_ACCELERATION_STRUCTURE_BUILD_TYPE_DEVICE_KHR = 1,
    VK_ACCELERATION_STRUCTURE_BUILD_TYPE_HOST_OR_DEVICE_KHR = 2,
    _,
};
pub const VkRayTracingShaderGroupTypeKHR = enum(i32) {
    VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR = 0,
    VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_KHR = 1,
    VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_KHR = 2,
    _,
};
pub const VkAccelerationStructureCompatibilityKHR = enum(i32) {
    VK_ACCELERATION_STRUCTURE_COMPATIBILITY_COMPATIBLE_KHR = 0,
    VK_ACCELERATION_STRUCTURE_COMPATIBILITY_INCOMPATIBLE_KHR = 1,
    _,
};
pub const VkShaderGroupShaderKHR = enum(i32) {
    VK_SHADER_GROUP_SHADER_GENERAL_KHR = 0,
    VK_SHADER_GROUP_SHADER_CLOSEST_HIT_KHR = 1,
    VK_SHADER_GROUP_SHADER_ANY_HIT_KHR = 2,
    VK_SHADER_GROUP_SHADER_INTERSECTION_KHR = 3,
    _,
};
pub const VkMemoryOverallocationBehaviorAMD = enum(i32) {
    VK_MEMORY_OVERALLOCATION_BEHAVIOR_DEFAULT_AMD = 0,
    VK_MEMORY_OVERALLOCATION_BEHAVIOR_ALLOWED_AMD = 1,
    VK_MEMORY_OVERALLOCATION_BEHAVIOR_DISALLOWED_AMD = 2,
    _,
};
pub const VkFullScreenExclusiveEXT = enum(i32) {
    VK_FULL_SCREEN_EXCLUSIVE_DEFAULT_EXT = 0,
    VK_FULL_SCREEN_EXCLUSIVE_ALLOWED_EXT = 1,
    VK_FULL_SCREEN_EXCLUSIVE_DISALLOWED_EXT = 2,
    VK_FULL_SCREEN_EXCLUSIVE_APPLICATION_CONTROLLED_EXT = 3,
    _,
};
pub const VkPerformanceCounterScopeKHR = enum(i32) {
    VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_BUFFER_KHR = 0,
    VK_PERFORMANCE_COUNTER_SCOPE_RENDER_PASS_KHR = 1,
    VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_KHR = 2,
    _,
};
pub const VkPerformanceCounterUnitKHR = enum(i32) {
    VK_PERFORMANCE_COUNTER_UNIT_GENERIC_KHR = 0,
    VK_PERFORMANCE_COUNTER_UNIT_PERCENTAGE_KHR = 1,
    VK_PERFORMANCE_COUNTER_UNIT_NANOSECONDS_KHR = 2,
    VK_PERFORMANCE_COUNTER_UNIT_BYTES_KHR = 3,
    VK_PERFORMANCE_COUNTER_UNIT_BYTES_PER_SECOND_KHR = 4,
    VK_PERFORMANCE_COUNTER_UNIT_KELVIN_KHR = 5,
    VK_PERFORMANCE_COUNTER_UNIT_WATTS_KHR = 6,
    VK_PERFORMANCE_COUNTER_UNIT_VOLTS_KHR = 7,
    VK_PERFORMANCE_COUNTER_UNIT_AMPS_KHR = 8,
    VK_PERFORMANCE_COUNTER_UNIT_HERTZ_KHR = 9,
    VK_PERFORMANCE_COUNTER_UNIT_CYCLES_KHR = 10,
    _,
};
pub const VkPerformanceCounterStorageKHR = enum(i32) {
    VK_PERFORMANCE_COUNTER_STORAGE_INT32_KHR = 0,
    VK_PERFORMANCE_COUNTER_STORAGE_INT64_KHR = 1,
    VK_PERFORMANCE_COUNTER_STORAGE_UINT32_KHR = 2,
    VK_PERFORMANCE_COUNTER_STORAGE_UINT64_KHR = 3,
    VK_PERFORMANCE_COUNTER_STORAGE_FLOAT32_KHR = 4,
    VK_PERFORMANCE_COUNTER_STORAGE_FLOAT64_KHR = 5,
    _,
};
pub const VkPerformanceConfigurationTypeINTEL = enum(i32) {
    VK_PERFORMANCE_CONFIGURATION_TYPE_COMMAND_QUEUE_METRICS_DISCOVERY_ACTIVATED_INTEL = 0,
    _,
};
pub const VkQueryPoolSamplingModeINTEL = enum(i32) {
    VK_QUERY_POOL_SAMPLING_MODE_MANUAL_INTEL = 0,
    _,
};
pub const VkPerformanceOverrideTypeINTEL = enum(i32) {
    VK_PERFORMANCE_OVERRIDE_TYPE_NULL_HARDWARE_INTEL = 0,
    VK_PERFORMANCE_OVERRIDE_TYPE_FLUSH_GPU_CACHES_INTEL = 1,
    _,
};
pub const VkPerformanceParameterTypeINTEL = enum(i32) {
    VK_PERFORMANCE_PARAMETER_TYPE_HW_COUNTERS_SUPPORTED_INTEL = 0,
    VK_PERFORMANCE_PARAMETER_TYPE_STREAM_MARKER_VALID_BITS_INTEL = 1,
    _,
};
pub const VkPerformanceValueTypeINTEL = enum(i32) {
    VK_PERFORMANCE_VALUE_TYPE_UINT32_INTEL = 0,
    VK_PERFORMANCE_VALUE_TYPE_UINT64_INTEL = 1,
    VK_PERFORMANCE_VALUE_TYPE_FLOAT_INTEL = 2,
    VK_PERFORMANCE_VALUE_TYPE_BOOL_INTEL = 3,
    VK_PERFORMANCE_VALUE_TYPE_STRING_INTEL = 4,
    _,
};
pub const VkShaderFloatControlsIndependence = enum(i32) {
    VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY = 0,
    VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL = 1,
    VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE = 2,
    _,
};
pub const VkPipelineExecutableStatisticFormatKHR = enum(i32) {
    VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_BOOL32_KHR = 0,
    VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_INT64_KHR = 1,
    VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_UINT64_KHR = 2,
    VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_FLOAT64_KHR = 3,
    _,
};
pub const VkLineRasterizationMode = enum(i32) {
    VK_LINE_RASTERIZATION_MODE_DEFAULT = 0,
    VK_LINE_RASTERIZATION_MODE_RECTANGULAR = 1,
    VK_LINE_RASTERIZATION_MODE_BRESENHAM = 2,
    VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH = 3,
    _,
};
pub const VkFaultLevel = enum(i32) {
    VK_FAULT_LEVEL_UNASSIGNED = 0,
    VK_FAULT_LEVEL_CRITICAL = 1,
    VK_FAULT_LEVEL_RECOVERABLE = 2,
    VK_FAULT_LEVEL_WARNING = 3,
    _,
};
pub const VkFaultType = enum(i32) {
    VK_FAULT_TYPE_INVALID = 0,
    VK_FAULT_TYPE_UNASSIGNED = 1,
    VK_FAULT_TYPE_IMPLEMENTATION = 2,
    VK_FAULT_TYPE_SYSTEM = 3,
    VK_FAULT_TYPE_PHYSICAL_DEVICE = 4,
    VK_FAULT_TYPE_COMMAND_BUFFER_FULL = 5,
    VK_FAULT_TYPE_INVALID_API_USAGE = 6,
    _,
};
pub const VkFaultQueryBehavior = enum(i32) {
    VK_FAULT_QUERY_BEHAVIOR_GET_AND_CLEAR_ALL_FAULTS = 0,
    _,
};
pub const VkPipelineMatchControl = enum(i32) {
    VK_PIPELINE_MATCH_CONTROL_APPLICATION_UUID_EXACT_MATCH = 0,
    _,
};
pub const VkFragmentShadingRateCombinerOpKHR = enum(i32) {
    VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR = 0,
    VK_FRAGMENT_SHADING_RATE_COMBINER_OP_REPLACE_KHR = 1,
    VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MIN_KHR = 2,
    VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MAX_KHR = 3,
    VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MUL_KHR = 4,
    _,
};
pub const VkFragmentShadingRateNV = enum(i32) {
    VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_PIXEL_NV = 0,
    VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_1X2_PIXELS_NV = 1,
    VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X1_PIXELS_NV = 4,
    VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X2_PIXELS_NV = 5,
    VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X4_PIXELS_NV = 6,
    VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_4X2_PIXELS_NV = 9,
    VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_4X4_PIXELS_NV = 10,
    VK_FRAGMENT_SHADING_RATE_2_INVOCATIONS_PER_PIXEL_NV = 11,
    VK_FRAGMENT_SHADING_RATE_4_INVOCATIONS_PER_PIXEL_NV = 12,
    VK_FRAGMENT_SHADING_RATE_8_INVOCATIONS_PER_PIXEL_NV = 13,
    VK_FRAGMENT_SHADING_RATE_16_INVOCATIONS_PER_PIXEL_NV = 14,
    VK_FRAGMENT_SHADING_RATE_NO_INVOCATIONS_NV = 15,
    _,
};
pub const VkFragmentShadingRateTypeNV = enum(i32) {
    VK_FRAGMENT_SHADING_RATE_TYPE_FRAGMENT_SIZE_NV = 0,
    VK_FRAGMENT_SHADING_RATE_TYPE_ENUMS_NV = 1,
    _,
};
pub const VkSubpassMergeStatusEXT = enum(i32) {
    VK_SUBPASS_MERGE_STATUS_MERGED_EXT = 0,
    VK_SUBPASS_MERGE_STATUS_DISALLOWED_EXT = 1,
    VK_SUBPASS_MERGE_STATUS_NOT_MERGED_SIDE_EFFECTS_EXT = 2,
    VK_SUBPASS_MERGE_STATUS_NOT_MERGED_SAMPLES_MISMATCH_EXT = 3,
    VK_SUBPASS_MERGE_STATUS_NOT_MERGED_VIEWS_MISMATCH_EXT = 4,
    VK_SUBPASS_MERGE_STATUS_NOT_MERGED_ALIASING_EXT = 5,
    VK_SUBPASS_MERGE_STATUS_NOT_MERGED_DEPENDENCIES_EXT = 6,
    VK_SUBPASS_MERGE_STATUS_NOT_MERGED_INCOMPATIBLE_INPUT_ATTACHMENT_EXT = 7,
    VK_SUBPASS_MERGE_STATUS_NOT_MERGED_TOO_MANY_ATTACHMENTS_EXT = 8,
    VK_SUBPASS_MERGE_STATUS_NOT_MERGED_INSUFFICIENT_STORAGE_EXT = 9,
    VK_SUBPASS_MERGE_STATUS_NOT_MERGED_DEPTH_STENCIL_COUNT_EXT = 10,
    VK_SUBPASS_MERGE_STATUS_NOT_MERGED_RESOLVE_ATTACHMENT_REUSE_EXT = 11,
    VK_SUBPASS_MERGE_STATUS_NOT_MERGED_SINGLE_SUBPASS_EXT = 12,
    VK_SUBPASS_MERGE_STATUS_NOT_MERGED_UNSPECIFIED_EXT = 13,
    _,
};
pub const VkSciSyncClientTypeNV = enum(i32) {
    VK_SCI_SYNC_CLIENT_TYPE_SIGNALER_NV = 0,
    VK_SCI_SYNC_CLIENT_TYPE_WAITER_NV = 1,
    VK_SCI_SYNC_CLIENT_TYPE_SIGNALER_WAITER_NV = 2,
    _,
};
pub const VkSciSyncPrimitiveTypeNV = enum(i32) {
    VK_SCI_SYNC_PRIMITIVE_TYPE_FENCE_NV = 0,
    VK_SCI_SYNC_PRIMITIVE_TYPE_SEMAPHORE_NV = 1,
    _,
};
pub const VkProvokingVertexModeEXT = enum(i32) {
    VK_PROVOKING_VERTEX_MODE_FIRST_VERTEX_EXT = 0,
    VK_PROVOKING_VERTEX_MODE_LAST_VERTEX_EXT = 1,
    _,
};
pub const VkPipelineCacheValidationVersion = enum(i32) {
    VK_PIPELINE_CACHE_VALIDATION_VERSION_SAFETY_CRITICAL_ONE = 1,
    _,
};
pub const VkAccelerationStructureMotionInstanceTypeNV = enum(i32) {
    VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_STATIC_NV = 0,
    VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_MATRIX_MOTION_NV = 1,
    VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_SRT_MOTION_NV = 2,
    _,
};
pub const VkDeviceAddressBindingTypeEXT = enum(i32) {
    VK_DEVICE_ADDRESS_BINDING_TYPE_BIND_EXT = 0,
    VK_DEVICE_ADDRESS_BINDING_TYPE_UNBIND_EXT = 1,
    _,
};
pub const VkQueryResultStatusKHR = enum(i32) {
    // Extension: VK_KHR_video_encode_queue
    VK_QUERY_RESULT_STATUS_INSUFFICIENT_BITSTREAM_BUFFER_RANGE_KHR = -1000299000,
    VK_QUERY_RESULT_STATUS_ERROR_KHR = -1,
    VK_QUERY_RESULT_STATUS_NOT_READY_KHR = 0,
    VK_QUERY_RESULT_STATUS_COMPLETE_KHR = 1,
    _,
};
pub const VkVideoEncodeTuningModeKHR = enum(i32) {
    VK_VIDEO_ENCODE_TUNING_MODE_DEFAULT_KHR = 0,
    VK_VIDEO_ENCODE_TUNING_MODE_HIGH_QUALITY_KHR = 1,
    VK_VIDEO_ENCODE_TUNING_MODE_LOW_LATENCY_KHR = 2,
    VK_VIDEO_ENCODE_TUNING_MODE_ULTRA_LOW_LATENCY_KHR = 3,
    VK_VIDEO_ENCODE_TUNING_MODE_LOSSLESS_KHR = 4,
    _,
};
pub const VkPartitionedAccelerationStructureOpTypeNV = enum(i32) {
    VK_PARTITIONED_ACCELERATION_STRUCTURE_OP_TYPE_WRITE_INSTANCE_NV = 0,
    VK_PARTITIONED_ACCELERATION_STRUCTURE_OP_TYPE_UPDATE_INSTANCE_NV = 1,
    VK_PARTITIONED_ACCELERATION_STRUCTURE_OP_TYPE_WRITE_PARTITION_TRANSLATION_NV = 2,
    _,
};
pub const VkVideoEncodeAV1PredictionModeKHR = enum(i32) {
    VK_VIDEO_ENCODE_AV1_PREDICTION_MODE_INTRA_ONLY_KHR = 0,
    VK_VIDEO_ENCODE_AV1_PREDICTION_MODE_SINGLE_REFERENCE_KHR = 1,
    VK_VIDEO_ENCODE_AV1_PREDICTION_MODE_UNIDIRECTIONAL_COMPOUND_KHR = 2,
    VK_VIDEO_ENCODE_AV1_PREDICTION_MODE_BIDIRECTIONAL_COMPOUND_KHR = 3,
    _,
};
pub const VkVideoEncodeAV1RateControlGroupKHR = enum(i32) {
    VK_VIDEO_ENCODE_AV1_RATE_CONTROL_GROUP_INTRA_KHR = 0,
    VK_VIDEO_ENCODE_AV1_RATE_CONTROL_GROUP_PREDICTIVE_KHR = 1,
    VK_VIDEO_ENCODE_AV1_RATE_CONTROL_GROUP_BIPREDICTIVE_KHR = 2,
    _,
};
pub const VkPipelineRobustnessBufferBehavior = enum(i32) {
    VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DEVICE_DEFAULT = 0,
    VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DISABLED = 1,
    VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS = 2,
    VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2 = 3,
    _,
};
pub const VkPipelineRobustnessImageBehavior = enum(i32) {
    VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DEVICE_DEFAULT = 0,
    VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DISABLED = 1,
    VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS = 2,
    VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS_2 = 3,
    _,
};
pub const VkOpticalFlowPerformanceLevelNV = enum(i32) {
    VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_UNKNOWN_NV = 0,
    VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_SLOW_NV = 1,
    VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_MEDIUM_NV = 2,
    VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_FAST_NV = 3,
    _,
};
pub const VkOpticalFlowSessionBindingPointNV = enum(i32) {
    VK_OPTICAL_FLOW_SESSION_BINDING_POINT_UNKNOWN_NV = 0,
    VK_OPTICAL_FLOW_SESSION_BINDING_POINT_INPUT_NV = 1,
    VK_OPTICAL_FLOW_SESSION_BINDING_POINT_REFERENCE_NV = 2,
    VK_OPTICAL_FLOW_SESSION_BINDING_POINT_HINT_NV = 3,
    VK_OPTICAL_FLOW_SESSION_BINDING_POINT_FLOW_VECTOR_NV = 4,
    VK_OPTICAL_FLOW_SESSION_BINDING_POINT_BACKWARD_FLOW_VECTOR_NV = 5,
    VK_OPTICAL_FLOW_SESSION_BINDING_POINT_COST_NV = 6,
    VK_OPTICAL_FLOW_SESSION_BINDING_POINT_BACKWARD_COST_NV = 7,
    VK_OPTICAL_FLOW_SESSION_BINDING_POINT_GLOBAL_FLOW_NV = 8,
    _,
};
pub const VkMicromapTypeEXT = enum(i32) {
    VK_MICROMAP_TYPE_OPACITY_MICROMAP_EXT = 0,
    // Extension: VK_NV_displacement_micromap
    VK_MICROMAP_TYPE_DISPLACEMENT_MICROMAP_NV = 1000397000,
    _,
};
pub const VkCopyMicromapModeEXT = enum(i32) {
    VK_COPY_MICROMAP_MODE_CLONE_EXT = 0,
    VK_COPY_MICROMAP_MODE_SERIALIZE_EXT = 1,
    VK_COPY_MICROMAP_MODE_DESERIALIZE_EXT = 2,
    VK_COPY_MICROMAP_MODE_COMPACT_EXT = 3,
    _,
};
pub const VkBuildMicromapModeEXT = enum(i32) {
    VK_BUILD_MICROMAP_MODE_BUILD_EXT = 0,
    _,
};
pub const VkOpacityMicromapFormatEXT = enum(i32) {
    VK_OPACITY_MICROMAP_FORMAT_2_STATE_EXT = 1,
    VK_OPACITY_MICROMAP_FORMAT_4_STATE_EXT = 2,
    _,
};
pub const VkOpacityMicromapSpecialIndexEXT = enum(i32) {
    // Extension: VK_NV_cluster_acceleration_structure
    VK_OPACITY_MICROMAP_SPECIAL_INDEX_CLUSTER_GEOMETRY_DISABLE_OPACITY_MICROMAP_NV = -5,
    VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_UNKNOWN_OPAQUE_EXT = -4,
    VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_UNKNOWN_TRANSPARENT_EXT = -3,
    VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_OPAQUE_EXT = -2,
    VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_TRANSPARENT_EXT = -1,
    _,
};
pub const VkDepthBiasRepresentationEXT = enum(i32) {
    VK_DEPTH_BIAS_REPRESENTATION_LEAST_REPRESENTABLE_VALUE_FORMAT_EXT = 0,
    VK_DEPTH_BIAS_REPRESENTATION_LEAST_REPRESENTABLE_VALUE_FORCE_UNORM_EXT = 1,
    VK_DEPTH_BIAS_REPRESENTATION_FLOAT_EXT = 2,
    _,
};
pub const VkDeviceFaultAddressTypeEXT = enum(i32) {
    // Comment: Currently unused
    VK_DEVICE_FAULT_ADDRESS_TYPE_NONE_EXT = 0,
    VK_DEVICE_FAULT_ADDRESS_TYPE_READ_INVALID_EXT = 1,
    VK_DEVICE_FAULT_ADDRESS_TYPE_WRITE_INVALID_EXT = 2,
    VK_DEVICE_FAULT_ADDRESS_TYPE_EXECUTE_INVALID_EXT = 3,
    VK_DEVICE_FAULT_ADDRESS_TYPE_INSTRUCTION_POINTER_UNKNOWN_EXT = 4,
    VK_DEVICE_FAULT_ADDRESS_TYPE_INSTRUCTION_POINTER_INVALID_EXT = 5,
    VK_DEVICE_FAULT_ADDRESS_TYPE_INSTRUCTION_POINTER_FAULT_EXT = 6,
    _,
};
pub const VkDeviceFaultVendorBinaryHeaderVersionEXT = enum(i32) {
    VK_DEVICE_FAULT_VENDOR_BINARY_HEADER_VERSION_ONE_EXT = 1,
    _,
};
pub const VkIndirectExecutionSetInfoTypeEXT = enum(i32) {
    VK_INDIRECT_EXECUTION_SET_INFO_TYPE_PIPELINES_EXT = 0,
    VK_INDIRECT_EXECUTION_SET_INFO_TYPE_SHADER_OBJECTS_EXT = 1,
    _,
};
pub const VkIndirectCommandsTokenTypeEXT = enum(i32) {
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_EXECUTION_SET_EXT = 0,
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_EXT = 1,
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_SEQUENCE_INDEX_EXT = 2,
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_EXT = 3,
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_EXT = 4,
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_EXT = 5,
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_EXT = 6,
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_COUNT_EXT = 7,
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_COUNT_EXT = 8,
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_EXT = 9,
    // Extension: VK_NV_mesh_shader
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_NV_EXT = 1000202002,
    // Extension: VK_NV_mesh_shader
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_COUNT_NV_EXT = 1000202003,
    // Extension: VK_EXT_mesh_shader
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_EXT = 1000328000,
    // Extension: VK_EXT_mesh_shader
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_COUNT_EXT = 1000328001,
    // Extension: VK_KHR_ray_tracing_maintenance1
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_TRACE_RAYS2_EXT = 1000386004,
    _,
};
pub const VkDisplacementMicromapFormatNV = enum(i32) {
    VK_DISPLACEMENT_MICROMAP_FORMAT_64_TRIANGLES_64_BYTES_NV = 1,
    VK_DISPLACEMENT_MICROMAP_FORMAT_256_TRIANGLES_128_BYTES_NV = 2,
    VK_DISPLACEMENT_MICROMAP_FORMAT_1024_TRIANGLES_128_BYTES_NV = 3,
    _,
};
pub const VkShaderCodeTypeEXT = enum(i32) {
    VK_SHADER_CODE_TYPE_BINARY_EXT = 0,
    VK_SHADER_CODE_TYPE_SPIRV_EXT = 1,
    _,
};
pub const VkScopeKHR = enum(i32) {
    VK_SCOPE_DEVICE_KHR = 1,
    VK_SCOPE_WORKGROUP_KHR = 2,
    VK_SCOPE_SUBGROUP_KHR = 3,
    VK_SCOPE_QUEUE_FAMILY_KHR = 5,
    _,
};
pub const VkComponentTypeKHR = enum(i32) {
    VK_COMPONENT_TYPE_FLOAT16_KHR = 0,
    VK_COMPONENT_TYPE_FLOAT32_KHR = 1,
    VK_COMPONENT_TYPE_FLOAT64_KHR = 2,
    VK_COMPONENT_TYPE_SINT8_KHR = 3,
    VK_COMPONENT_TYPE_SINT16_KHR = 4,
    VK_COMPONENT_TYPE_SINT32_KHR = 5,
    VK_COMPONENT_TYPE_SINT64_KHR = 6,
    VK_COMPONENT_TYPE_UINT8_KHR = 7,
    VK_COMPONENT_TYPE_UINT16_KHR = 8,
    VK_COMPONENT_TYPE_UINT32_KHR = 9,
    VK_COMPONENT_TYPE_UINT64_KHR = 10,
    // Extension: VK_KHR_shader_bfloat16
    VK_COMPONENT_TYPE_BFLOAT16_KHR = 1000141000,
    // Extension: VK_NV_cooperative_vector
    VK_COMPONENT_TYPE_SINT8_PACKED_NV = 1000491000,
    // Extension: VK_NV_cooperative_vector
    VK_COMPONENT_TYPE_UINT8_PACKED_NV = 1000491001,
    // Extension: VK_EXT_shader_float8
    VK_COMPONENT_TYPE_FLOAT8_E4M3_EXT = 1000491002,
    // Extension: VK_EXT_shader_float8
    VK_COMPONENT_TYPE_FLOAT8_E5M2_EXT = 1000491003,
    _,
};
pub const VkCubicFilterWeightsQCOM = enum(i32) {
    VK_CUBIC_FILTER_WEIGHTS_CATMULL_ROM_QCOM = 0,
    VK_CUBIC_FILTER_WEIGHTS_ZERO_TANGENT_CARDINAL_QCOM = 1,
    VK_CUBIC_FILTER_WEIGHTS_B_SPLINE_QCOM = 2,
    VK_CUBIC_FILTER_WEIGHTS_MITCHELL_NETRAVALI_QCOM = 3,
    _,
};
pub const VkBlockMatchWindowCompareModeQCOM = enum(i32) {
    VK_BLOCK_MATCH_WINDOW_COMPARE_MODE_MIN_QCOM = 0,
    VK_BLOCK_MATCH_WINDOW_COMPARE_MODE_MAX_QCOM = 1,
    _,
};
pub const VkPhysicalDeviceLayeredApiKHR = enum(i32) {
    VK_PHYSICAL_DEVICE_LAYERED_API_VULKAN_KHR = 0,
    VK_PHYSICAL_DEVICE_LAYERED_API_D3D12_KHR = 1,
    VK_PHYSICAL_DEVICE_LAYERED_API_METAL_KHR = 2,
    VK_PHYSICAL_DEVICE_LAYERED_API_OPENGL_KHR = 3,
    VK_PHYSICAL_DEVICE_LAYERED_API_OPENGLES_KHR = 4,
    _,
};
pub const VkLayeredDriverUnderlyingApiMSFT = enum(i32) {
    VK_LAYERED_DRIVER_UNDERLYING_API_NONE_MSFT = 0,
    VK_LAYERED_DRIVER_UNDERLYING_API_D3D12_MSFT = 1,
    _,
};
pub const VkLatencyMarkerNV = enum(i32) {
    VK_LATENCY_MARKER_SIMULATION_START_NV = 0,
    VK_LATENCY_MARKER_SIMULATION_END_NV = 1,
    VK_LATENCY_MARKER_RENDERSUBMIT_START_NV = 2,
    VK_LATENCY_MARKER_RENDERSUBMIT_END_NV = 3,
    VK_LATENCY_MARKER_PRESENT_START_NV = 4,
    VK_LATENCY_MARKER_PRESENT_END_NV = 5,
    VK_LATENCY_MARKER_INPUT_SAMPLE_NV = 6,
    VK_LATENCY_MARKER_TRIGGER_FLASH_NV = 7,
    VK_LATENCY_MARKER_OUT_OF_BAND_RENDERSUBMIT_START_NV = 8,
    VK_LATENCY_MARKER_OUT_OF_BAND_RENDERSUBMIT_END_NV = 9,
    VK_LATENCY_MARKER_OUT_OF_BAND_PRESENT_START_NV = 10,
    VK_LATENCY_MARKER_OUT_OF_BAND_PRESENT_END_NV = 11,
    _,
};
pub const VkOutOfBandQueueTypeNV = enum(i32) {
    VK_OUT_OF_BAND_QUEUE_TYPE_RENDER_NV = 0,
    VK_OUT_OF_BAND_QUEUE_TYPE_PRESENT_NV = 1,
    _,
};
pub const VkCompressedTriangleFormatAMDX = enum(i32) {
    VK_COMPRESSED_TRIANGLE_FORMAT_DGF1_AMDX = 0,
    _,
};
pub const VkDepthClampModeEXT = enum(i32) {
    VK_DEPTH_CLAMP_MODE_VIEWPORT_RANGE_EXT = 0,
    VK_DEPTH_CLAMP_MODE_USER_DEFINED_RANGE_EXT = 1,
    _,
};
pub const VkCooperativeVectorMatrixLayoutNV = enum(i32) {
    VK_COOPERATIVE_VECTOR_MATRIX_LAYOUT_ROW_MAJOR_NV = 0,
    VK_COOPERATIVE_VECTOR_MATRIX_LAYOUT_COLUMN_MAJOR_NV = 1,
    VK_COOPERATIVE_VECTOR_MATRIX_LAYOUT_INFERENCING_OPTIMAL_NV = 2,
    VK_COOPERATIVE_VECTOR_MATRIX_LAYOUT_TRAINING_OPTIMAL_NV = 3,
    _,
};
pub const VkTensorTilingARM = enum(i32) {
    VK_TENSOR_TILING_OPTIMAL_ARM = 0,
    VK_TENSOR_TILING_LINEAR_ARM = 1,
    _,
};
pub const VkDefaultVertexAttributeValueKHR = enum(i32) {
    VK_DEFAULT_VERTEX_ATTRIBUTE_VALUE_ZERO_ZERO_ZERO_ZERO_KHR = 0,
    VK_DEFAULT_VERTEX_ATTRIBUTE_VALUE_ZERO_ZERO_ZERO_ONE_KHR = 1,
    _,
};
pub const VkDataGraphPipelineSessionBindPointARM = enum(i32) {
    VK_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_TRANSIENT_ARM = 0,
    _,
};
pub const VkDataGraphPipelineSessionBindPointTypeARM = enum(i32) {
    VK_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_TYPE_MEMORY_ARM = 0,
    _,
};
pub const VkDataGraphPipelinePropertyARM = enum(i32) {
    VK_DATA_GRAPH_PIPELINE_PROPERTY_CREATION_LOG_ARM = 0,
    VK_DATA_GRAPH_PIPELINE_PROPERTY_IDENTIFIER_ARM = 1,
    _,
};
pub const VkPhysicalDeviceDataGraphProcessingEngineTypeARM = enum(i32) {
    VK_PHYSICAL_DEVICE_DATA_GRAPH_PROCESSING_ENGINE_TYPE_DEFAULT_ARM = 0,
    // Extension: VK_QCOM_data_graph_model
    VK_PHYSICAL_DEVICE_DATA_GRAPH_PROCESSING_ENGINE_TYPE_NEURAL_QCOM = 1000629000,
    // Extension: VK_QCOM_data_graph_model
    VK_PHYSICAL_DEVICE_DATA_GRAPH_PROCESSING_ENGINE_TYPE_COMPUTE_QCOM = 1000629001,
    _,
};
pub const VkPhysicalDeviceDataGraphOperationTypeARM = enum(i32) {
    VK_PHYSICAL_DEVICE_DATA_GRAPH_OPERATION_TYPE_SPIRV_EXTENDED_INSTRUCTION_SET_ARM = 0,
    // Extension: VK_QCOM_data_graph_model
    VK_PHYSICAL_DEVICE_DATA_GRAPH_OPERATION_TYPE_NEURAL_MODEL_QCOM = 1000629000,
    // Extension: VK_QCOM_data_graph_model
    VK_PHYSICAL_DEVICE_DATA_GRAPH_OPERATION_TYPE_BUILTIN_MODEL_QCOM = 1000629001,
    _,
};
pub const VkDataGraphModelCacheTypeQCOM = enum(i32) {
    VK_DATA_GRAPH_MODEL_CACHE_TYPE_GENERIC_BINARY_QCOM = 0,
    _,
};

// Structs
// Extension: VK_BASE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkBaseOutStructure = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = .VK_STRUCTURE_TYPE_APPLICATION_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*VkBaseOutStructure = null,
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkBaseInStructure = extern struct {
    // Extern sync: false
    // Optional: false
    sType: VkStructureType = .VK_STRUCTURE_TYPE_APPLICATION_INFO,
    // Extern sync: false
    // Optional: true
    pNext: ?*const VkBaseInStructure = null,
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkOffset2D = extern struct {
    // Extern sync: false
    // Optional: false
    x: i32 = 0,
    // Extern sync: false
    // Optional: false
    y: i32 = 0,
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkOffset3D = extern struct {
    // Extern sync: false
    // Optional: false
    x: i32 = 0,
    // Extern sync: false
    // Optional: false
    y: i32 = 0,
    // Extern sync: false
    // Optional: false
    z: i32 = 0,
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkExtent2D = extern struct {
    // Extern sync: false
    // Optional: false
    width: u32 = 0,
    // Extern sync: false
    // Optional: false
    height: u32 = 0,
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkExtent3D = extern struct {
    // Extern sync: false
    // Optional: false
    width: u32 = 0,
    // Extern sync: false
    // Optional: false
    height: u32 = 0,
    // Extern sync: false
    // Optional: false
    depth: u32 = 0,
};
// Extension: VK_GRAPHICS_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkViewport = extern struct {
    // Extern sync: false
    // Optional: false
    x: f32 = 0,
    // Extern sync: false
    // Optional: false
    y: f32 = 0,
    // Extern sync: false
    // Optional: false
    width: f32 = 0,
    // Extern sync: false
    // Optional: false
    height: f32 = 0,
    // Extern sync: false
    // Optional: false
    minDepth: f32 = 0,
    // Extern sync: false
    // Optional: false
    maxDepth: f32 = 0,
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkRect2D = extern struct {
    // Extern sync: false
    // Optional: false
    offset: VkOffset2D = .{},
    // Extern sync: false
    // Optional: false
    extent: VkExtent2D = .{},
};
// Extension: VK_GRAPHICS_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkClearRect = extern struct {
    // Extern sync: false
    // Optional: false
    rect: VkRect2D = .{},
    // Extern sync: false
    // Optional: false
    baseArrayLayer: u32 = 0,
    // Extern sync: false
    // Optional: false
    layerCount: u32 = 0,
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkComponentMapping = extern struct {
    // Extern sync: false
    // Optional: false
    r: VkComponentSwizzle = .VK_COMPONENT_SWIZZLE_IDENTITY,
    // Extern sync: false
    // Optional: false
    g: VkComponentSwizzle = .VK_COMPONENT_SWIZZLE_IDENTITY,
    // Extern sync: false
    // Optional: false
    b: VkComponentSwizzle = .VK_COMPONENT_SWIZZLE_IDENTITY,
    // Extern sync: false
    // Optional: false
    a: VkComponentSwizzle = .VK_COMPONENT_SWIZZLE_IDENTITY,
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceProperties = extern struct {
    // Extern sync: false
    // Optional: false
    apiVersion: ApiVersion = .{},
    // Extern sync: false
    // Optional: false
    driverVersion: ApiVersion = .{},
    // Extern sync: false
    // Optional: false
    vendorID: u32 = 0,
    // Extern sync: false
    // Optional: false
    deviceID: u32 = 0,
    // Extern sync: false
    // Optional: false
    deviceType: VkPhysicalDeviceType = .VK_PHYSICAL_DEVICE_TYPE_OTHER,
    // Length expression: null-terminated
    // Extern sync: false
    // Optional: false
    deviceName: [VK_MAX_PHYSICAL_DEVICE_NAME_SIZE]u8 = @import("std").mem.zeroes([VK_MAX_PHYSICAL_DEVICE_NAME_SIZE]u8),
    // Extern sync: false
    // Optional: false
    pipelineCacheUUID: [VK_UUID_SIZE]u8 = @import("std").mem.zeroes([VK_UUID_SIZE]u8),
    // Extern sync: false
    // Optional: false
    limits: VkPhysicalDeviceLimits = .{},
    // Extern sync: false
    // Optional: false
    sparseProperties: VkPhysicalDeviceSparseProperties = .{},
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkExtensionProperties = extern struct {
    // Length expression: null-terminated
    // Extern sync: false
    // Optional: false
    extensionName: [VK_MAX_EXTENSION_NAME_SIZE]u8 = @import("std").mem.zeroes([VK_MAX_EXTENSION_NAME_SIZE]u8),
    // Extern sync: false
    // Optional: false
    // Comment: version of the extension specification implemented
    specVersion: ApiVersion = .{},
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkLayerProperties = extern struct {
    // Length expression: null-terminated
    // Extern sync: false
    // Optional: false
    layerName: [VK_MAX_EXTENSION_NAME_SIZE]u8 = @import("std").mem.zeroes([VK_MAX_EXTENSION_NAME_SIZE]u8),
    // Extern sync: false
    // Optional: false
    // Comment: version of the layer specification implemented
    specVersion: ApiVersion = .{},
    // Extern sync: false
    // Optional: false
    // Comment: build or release version of the layer's library
    implementationVersion: ApiVersion = .{},
    // Length expression: null-terminated
    // Extern sync: false
    // Optional: false
    description: [VK_MAX_DESCRIPTION_SIZE]u8 = @import("std").mem.zeroes([VK_MAX_DESCRIPTION_SIZE]u8),
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkApplicationInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_APPLICATION_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Length expression: null-terminated
    // Extern sync: false
    // Optional: true
    pApplicationName: ?[*:0]const u8 = null,
    // Extern sync: false
    // Optional: false
    applicationVersion: ApiVersion = .{},
    // Length expression: null-terminated
    // Extern sync: false
    // Optional: true
    pEngineName: ?[*:0]const u8 = null,
    // Extern sync: false
    // Optional: false
    engineVersion: ApiVersion = .{},
    // Extern sync: false
    // Optional: false
    apiVersion: ApiVersion = .{},
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkAllocationCallbacks = extern struct {
    // Extern sync: false
    // Optional: true
    pUserData: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    pfnAllocation: ?*const vkAllocationFunction = null,
    // Extern sync: false
    // Optional: false
    pfnReallocation: ?*const vkReallocationFunction = null,
    // Extern sync: false
    // Optional: false
    pfnFree: ?*const vkFreeFunction = null,
    // Extern sync: false
    // Optional: true
    pfnInternalAllocation: ?*const vkInternalAllocationNotification = null,
    // Extern sync: false
    // Optional: true
    pfnInternalFree: ?*const vkInternalFreeNotification = null,
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDeviceQueueCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkDeviceQueueCreateFlags = .{},
    // Extern sync: false
    // Optional: false
    queueFamilyIndex: u32 = 0,
    // Extern sync: false
    // Optional: false
    queueCount: u32 = 0,
    // Length expression: queueCount
    // Extern sync: false
    // Optional: false
    pQueuePriorities: ?[*]const f32 = null,
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDeviceCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkDeviceCreateFlags = .{},
    // Extern sync: false
    // Optional: true
    queueCreateInfoCount: u32 = 0,
    // Length expression: queueCreateInfoCount
    // Extern sync: false
    // Optional: false
    pQueueCreateInfos: ?[*]const VkDeviceQueueCreateInfo = null,
    // Deprecated: ignored
    // Extern sync: false
    // Optional: true
    enabledLayerCount: u32 = 0,
    // Length expression: enabledLayerCount,null-terminated
    // Deprecated: ignored
    // Extern sync: false
    // Optional: false
    // Comment: Ordered list of layer names to be enabled
    ppEnabledLayerNames: ?[*]const [*:0]const u8 = null,
    // Extern sync: false
    // Optional: true
    enabledExtensionCount: u32 = 0,
    // Length expression: enabledExtensionCount,null-terminated
    // Extern sync: false
    // Optional: false
    ppEnabledExtensionNames: ?[*]const [*:0]const u8 = null,
    // Extern sync: false
    // Optional: true
    pEnabledFeatures: ?*const VkPhysicalDeviceFeatures = null,
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkInstanceCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkInstanceCreateFlags = .{},
    // Extern sync: false
    // Optional: true
    pApplicationInfo: ?*const VkApplicationInfo = null,
    // Extern sync: false
    // Optional: true
    enabledLayerCount: u32 = 0,
    // Length expression: enabledLayerCount,null-terminated
    // Extern sync: false
    // Optional: false
    // Comment: Ordered list of layer names to be enabled
    ppEnabledLayerNames: ?[*]const [*:0]const u8 = null,
    // Extern sync: false
    // Optional: true
    enabledExtensionCount: u32 = 0,
    // Length expression: enabledExtensionCount,null-terminated
    // Extern sync: false
    // Optional: false
    // Comment: Extension names to be enabled
    ppEnabledExtensionNames: ?[*]const [*:0]const u8 = null,
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkQueueFamilyProperties = extern struct {
    // Extern sync: false
    // Optional: true
    // Comment: Queue flags
    queueFlags: VkQueueFlags = .{},
    // Extern sync: false
    // Optional: false
    queueCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    timestampValidBits: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Minimum alignment requirement for image transfers
    minImageTransferGranularity: VkExtent3D = .{},
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceMemoryProperties = extern struct {
    // Extern sync: false
    // Optional: false
    memoryTypeCount: u32 = 0,
    // Length expression: memoryTypeCount
    // Extern sync: false
    // Optional: false
    memoryTypes: [VK_MAX_MEMORY_TYPES]VkMemoryType = .{VkMemoryType{}} ** VK_MAX_MEMORY_TYPES,
    // Extern sync: false
    // Optional: false
    memoryHeapCount: u32 = 0,
    // Length expression: memoryHeapCount
    // Extern sync: false
    // Optional: false
    memoryHeaps: [VK_MAX_MEMORY_HEAPS]VkMemoryHeap = .{VkMemoryHeap{}} ** VK_MAX_MEMORY_HEAPS,
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkMemoryAllocateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: Size of memory allocation
    allocationSize: u64 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Index of the of the memory type to allocate from
    memoryTypeIndex: u32 = 0,
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkMemoryRequirements = extern struct {
    // Extern sync: false
    // Optional: false
    // Comment: Specified in bytes
    size: u64 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Specified in bytes
    alignment: u64 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Bitmask of the allowed memory type indices into memoryTypes[] for this object
    memoryTypeBits: u32 = 0,
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkSparseImageFormatProperties = extern struct {
    // Extern sync: false
    // Optional: true
    aspectMask: VkImageAspectFlags = .{},
    // Extern sync: false
    // Optional: false
    imageGranularity: VkExtent3D = .{},
    // Extern sync: false
    // Optional: true
    flags: VkSparseImageFormatFlags = .{},
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkSparseImageMemoryRequirements = extern struct {
    // Extern sync: false
    // Optional: false
    formatProperties: VkSparseImageFormatProperties = .{},
    // Extern sync: false
    // Optional: false
    imageMipTailFirstLod: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Specified in bytes, must be a multiple of sparse block size in bytes / alignment
    imageMipTailSize: u64 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Specified in bytes, must be a multiple of sparse block size in bytes / alignment
    imageMipTailOffset: u64 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Specified in bytes, must be a multiple of sparse block size in bytes / alignment
    imageMipTailStride: u64 = 0,
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkMemoryType = extern struct {
    // Extern sync: false
    // Optional: true
    // Comment: Memory properties of this memory type
    propertyFlags: VkMemoryPropertyFlags = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Index of the memory heap allocations of this memory type are taken from
    heapIndex: u32 = 0,
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkMemoryHeap = extern struct {
    // Extern sync: false
    // Optional: false
    // Comment: Available memory in the heap
    size: u64 = 0,
    // Extern sync: false
    // Optional: true
    // Comment: Flags for the heap
    flags: VkMemoryHeapFlags = .{},
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkMappedMemoryRange = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: Mapped memory object
    memory: VkDeviceMemory = .none,
    // Extern sync: false
    // Optional: false
    // Comment: Offset within the memory object where the range starts
    offset: u64 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Size of the range within the memory object
    size: u64 = 0,
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkFormatProperties = extern struct {
    // Extern sync: false
    // Optional: true
    // Comment: Format features in case of linear tiling
    linearTilingFeatures: VkFormatFeatureFlags = .{},
    // Extern sync: false
    // Optional: true
    // Comment: Format features in case of optimal tiling
    optimalTilingFeatures: VkFormatFeatureFlags = .{},
    // Extern sync: false
    // Optional: true
    // Comment: Format features supported by buffers
    bufferFeatures: VkFormatFeatureFlags = .{},
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkImageFormatProperties = extern struct {
    // Extern sync: false
    // Optional: false
    // Comment: max image dimensions for this resource type
    maxExtent: VkExtent3D = .{},
    // Extern sync: false
    // Optional: false
    // Comment: max number of mipmap levels for this resource type
    maxMipLevels: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: max array size for this resource type
    maxArrayLayers: u32 = 0,
    // Extern sync: false
    // Optional: true
    // Comment: supported sample counts for this resource type
    sampleCounts: VkSampleCountFlags = .{},
    // Extern sync: false
    // Optional: false
    // Comment: max size (in bytes) of this resource type
    maxResourceSize: u64 = 0,
};
// Extension: VK_COMPUTE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDescriptorBufferInfo = extern struct {
    // Extern sync: false
    // Optional: true
    // Comment: Buffer used for this descriptor slot.
    buffer: VkBuffer = .none,
    // Extern sync: false
    // Optional: false
    // Comment: Base offset from buffer start in bytes to update in the descriptor set.
    offset: u64 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Size in bytes of the buffer resource for this descriptor update.
    range: u64 = 0,
};
// Extension: VK_COMPUTE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDescriptorImageInfo = extern struct {
    // Extern sync: false
    // Optional: false
    // Comment: Sampler to write to the descriptor in case it is a SAMPLER or COMBINED_IMAGE_SAMPLER descriptor. Ignored otherwise.
    sampler: VkSampler = .none,
    // Extern sync: false
    // Optional: false
    // Comment: Image view to write to the descriptor in case it is a SAMPLED_IMAGE, STORAGE_IMAGE, COMBINED_IMAGE_SAMPLER, or INPUT_ATTACHMENT descriptor. Ignored otherwise.
    imageView: VkImageView = .none,
    // Extern sync: false
    // Optional: false
    // Comment: Layout the image is expected to be in when accessed using this descriptor (only used if imageView is not VK_NULL_HANDLE).
    imageLayout: VkImageLayout = .VK_IMAGE_LAYOUT_UNDEFINED,
};
// Extension: VK_COMPUTE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkWriteDescriptorSet = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: Destination descriptor set
    dstSet: VkDescriptorSet = .none,
    // Extern sync: false
    // Optional: false
    // Comment: Binding within the destination descriptor set to write
    dstBinding: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Array element within the destination binding to write
    dstArrayElement: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Number of descriptors to write (determines the size of the array pointed by pDescriptors)
    descriptorCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Descriptor type to write (determines which members of the array pointed by pDescriptors are going to be used)
    descriptorType: VkDescriptorType = .VK_DESCRIPTOR_TYPE_SAMPLER,
    // Length expression: descriptorCount
    // Extern sync: false
    // Optional: false
    // Comment: Sampler, image view, and layout for SAMPLER, COMBINED_IMAGE_SAMPLER, {SAMPLED,STORAGE}_IMAGE, and INPUT_ATTACHMENT descriptor types.
    pImageInfo: ?[*]const VkDescriptorImageInfo = null,
    // Length expression: descriptorCount
    // Extern sync: false
    // Optional: false
    // Comment: Raw buffer, size, and offset for {UNIFORM,STORAGE}_BUFFER[_DYNAMIC] descriptor types.
    pBufferInfo: ?[*]const VkDescriptorBufferInfo = null,
    // Length expression: descriptorCount
    // Extern sync: false
    // Optional: false
    // Comment: Buffer view to write to the descriptor for {UNIFORM,STORAGE}_TEXEL_BUFFER descriptor types.
    pTexelBufferView: ?[*]const VkBufferView = null,
};
// Extension: VK_COMPUTE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkCopyDescriptorSet = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: Source descriptor set
    srcSet: VkDescriptorSet = .none,
    // Extern sync: false
    // Optional: false
    // Comment: Binding within the source descriptor set to copy from
    srcBinding: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Array element within the source binding to copy from
    srcArrayElement: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Destination descriptor set
    dstSet: VkDescriptorSet = .none,
    // Extern sync: false
    // Optional: false
    // Comment: Binding within the destination descriptor set to copy to
    dstBinding: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Array element within the destination binding to copy to
    dstArrayElement: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Number of descriptors to write (determines the size of the array pointed by pDescriptors)
    descriptorCount: u32 = 0,
};
// Extension: VK_KHR_maintenance5
// Extension: VK_BASE_VERSION_1_4
// Extends: VkBufferViewCreateInfo,VkBufferCreateInfo,VkPhysicalDeviceExternalBufferInfo,VkDescriptorBufferBindingInfoEXT
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkBufferUsageFlags2CreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    usage: VkBufferUsageFlags2 = .{},
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkBufferCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    // Comment: Buffer creation flags
    flags: VkBufferCreateFlags = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Specified in bytes
    size: u64 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Buffer usage flags
    usage: VkBufferUsageFlags = .{},
    // Extern sync: false
    // Optional: false
    sharingMode: VkSharingMode = .VK_SHARING_MODE_EXCLUSIVE,
    // Extern sync: false
    // Optional: true
    queueFamilyIndexCount: u32 = 0,
    // Length expression: queueFamilyIndexCount
    // Extern sync: false
    // Optional: false
    pQueueFamilyIndices: ?[*]const u32 = null,
};
// Extension: VK_COMPUTE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkBufferViewCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkBufferViewCreateFlags = .{},
    // Extern sync: false
    // Optional: false
    buffer: VkBuffer = .none,
    // Extern sync: false
    // Optional: false
    // Comment: Optionally specifies format of elements
    format: VkFormat = .VK_FORMAT_UNDEFINED,
    // Extern sync: false
    // Optional: false
    // Comment: Specified in bytes
    offset: u64 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: View size specified in bytes
    range: u64 = 0,
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImageSubresource = extern struct {
    // Extern sync: false
    // Optional: false
    aspectMask: VkImageAspectFlags = .{},
    // Extern sync: false
    // Optional: false
    mipLevel: u32 = 0,
    // Extern sync: false
    // Optional: false
    arrayLayer: u32 = 0,
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImageSubresourceLayers = extern struct {
    // Extern sync: false
    // Optional: false
    aspectMask: VkImageAspectFlags = .{},
    // Extern sync: false
    // Optional: false
    mipLevel: u32 = 0,
    // Extern sync: false
    // Optional: false
    baseArrayLayer: u32 = 0,
    // Extern sync: false
    // Optional: false
    layerCount: u32 = 0,
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImageSubresourceRange = extern struct {
    // Extern sync: false
    // Optional: false
    aspectMask: VkImageAspectFlags = .{},
    // Extern sync: false
    // Optional: false
    baseMipLevel: u32 = 0,
    // Extern sync: false
    // Optional: false
    levelCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    baseArrayLayer: u32 = 0,
    // Extern sync: false
    // Optional: false
    layerCount: u32 = 0,
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkMemoryBarrier = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_MEMORY_BARRIER;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    // Comment: Memory accesses from the source of the dependency to synchronize
    srcAccessMask: VkAccessFlags = .{},
    // Extern sync: false
    // Optional: true
    // Comment: Memory accesses from the destination of the dependency to synchronize
    dstAccessMask: VkAccessFlags = .{},
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkBufferMemoryBarrier = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: Memory accesses from the source of the dependency to synchronize
    srcAccessMask: VkAccessFlags = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Memory accesses from the destination of the dependency to synchronize
    dstAccessMask: VkAccessFlags = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Queue family to transition ownership from
    srcQueueFamilyIndex: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Queue family to transition ownership to
    dstQueueFamilyIndex: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Buffer to sync
    buffer: VkBuffer = .none,
    // Extern sync: false
    // Optional: false
    // Comment: Offset within the buffer to sync
    offset: u64 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Amount of bytes to sync
    size: u64 = 0,
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImageMemoryBarrier = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: Memory accesses from the source of the dependency to synchronize
    srcAccessMask: VkAccessFlags = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Memory accesses from the destination of the dependency to synchronize
    dstAccessMask: VkAccessFlags = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Current layout of the image
    oldLayout: VkImageLayout = .VK_IMAGE_LAYOUT_UNDEFINED,
    // Extern sync: false
    // Optional: false
    // Comment: New layout to transition the image to
    newLayout: VkImageLayout = .VK_IMAGE_LAYOUT_UNDEFINED,
    // Extern sync: false
    // Optional: false
    // Comment: Queue family to transition ownership from
    srcQueueFamilyIndex: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Queue family to transition ownership to
    dstQueueFamilyIndex: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Image to sync
    image: VkImage = .none,
    // Extern sync: false
    // Optional: false
    // Comment: Subresource range to sync
    subresourceRange: VkImageSubresourceRange = .{},
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImageCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    // Comment: Image creation flags
    flags: VkImageCreateFlags = .{},
    // Extern sync: false
    // Optional: false
    imageType: VkImageType = .VK_IMAGE_TYPE_1D,
    // Extern sync: false
    // Optional: false
    format: VkFormat = .VK_FORMAT_UNDEFINED,
    // Extern sync: false
    // Optional: false
    extent: VkExtent3D = .{},
    // Extern sync: false
    // Optional: false
    mipLevels: u32 = 0,
    // Extern sync: false
    // Optional: false
    arrayLayers: u32 = 0,
    // Extern sync: false
    // Optional: false
    samples: VkSampleCountFlags = .{},
    // Extern sync: false
    // Optional: false
    tiling: VkImageTiling = .VK_IMAGE_TILING_OPTIMAL,
    // Extern sync: false
    // Optional: false
    // Comment: Image usage flags
    usage: VkImageUsageFlags = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Cross-queue-family sharing mode
    sharingMode: VkSharingMode = .VK_SHARING_MODE_EXCLUSIVE,
    // Extern sync: false
    // Optional: true
    // Comment: Number of queue families to share across
    queueFamilyIndexCount: u32 = 0,
    // Length expression: queueFamilyIndexCount
    // Extern sync: false
    // Optional: false
    // Comment: Array of queue family indices to share across
    pQueueFamilyIndices: ?[*]const u32 = null,
    // Extern sync: false
    // Optional: false
    // Comment: Initial image layout for all subresources
    initialLayout: VkImageLayout = .VK_IMAGE_LAYOUT_UNDEFINED,
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSubresourceLayout = extern struct {
    // Extern sync: false
    // Optional: false
    // Comment: Specified in bytes
    offset: u64 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Specified in bytes
    size: u64 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Specified in bytes
    rowPitch: u64 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Specified in bytes
    arrayPitch: u64 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Specified in bytes
    depthPitch: u64 = 0,
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImageViewCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkImageViewCreateFlags = .{},
    // Extern sync: false
    // Optional: false
    image: VkImage = .none,
    // Extern sync: false
    // Optional: false
    viewType: VkImageViewType = .VK_IMAGE_VIEW_TYPE_1D,
    // Extern sync: false
    // Optional: false
    format: VkFormat = .VK_FORMAT_UNDEFINED,
    // Extern sync: false
    // Optional: false
    components: VkComponentMapping = .{},
    // Extern sync: false
    // Optional: false
    subresourceRange: VkImageSubresourceRange = .{},
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkBufferCopy = extern struct {
    // Extern sync: false
    // Optional: false
    // Comment: Specified in bytes
    srcOffset: u64 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Specified in bytes
    dstOffset: u64 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Specified in bytes
    size: u64 = 0,
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSparseMemoryBind = extern struct {
    // Extern sync: false
    // Optional: false
    // Comment: Specified in bytes
    resourceOffset: u64 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Specified in bytes
    size: u64 = 0,
    // Extern sync: false
    // Optional: true
    memory: VkDeviceMemory = .none,
    // Extern sync: false
    // Optional: false
    // Comment: Specified in bytes
    memoryOffset: u64 = 0,
    // Extern sync: false
    // Optional: true
    flags: VkSparseMemoryBindFlags = .{},
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSparseImageMemoryBind = extern struct {
    // Extern sync: false
    // Optional: false
    subresource: VkImageSubresource = .{},
    // Extern sync: false
    // Optional: false
    offset: VkOffset3D = .{},
    // Extern sync: false
    // Optional: false
    extent: VkExtent3D = .{},
    // Extern sync: false
    // Optional: true
    memory: VkDeviceMemory = .none,
    // Extern sync: false
    // Optional: false
    // Comment: Specified in bytes
    memoryOffset: u64 = 0,
    // Extern sync: false
    // Optional: true
    flags: VkSparseMemoryBindFlags = .{},
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSparseBufferMemoryBindInfo = extern struct {
    // Extern sync: false
    // Optional: false
    buffer: VkBuffer = .none,
    // Extern sync: false
    // Optional: false
    bindCount: u32 = 0,
    // Length expression: bindCount
    // Extern sync: false
    // Optional: false
    pBinds: ?[*]const VkSparseMemoryBind = null,
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSparseImageOpaqueMemoryBindInfo = extern struct {
    // Extern sync: false
    // Optional: false
    image: VkImage = .none,
    // Extern sync: false
    // Optional: false
    bindCount: u32 = 0,
    // Length expression: bindCount
    // Extern sync: false
    // Optional: false
    pBinds: ?[*]const VkSparseMemoryBind = null,
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSparseImageMemoryBindInfo = extern struct {
    // Extern sync: false
    // Optional: false
    image: VkImage = .none,
    // Extern sync: false
    // Optional: false
    bindCount: u32 = 0,
    // Length expression: bindCount
    // Extern sync: false
    // Optional: false
    pBinds: ?[*]const VkSparseImageMemoryBind = null,
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkBindSparseInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_BIND_SPARSE_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    waitSemaphoreCount: u32 = 0,
    // Length expression: waitSemaphoreCount
    // Extern sync: false
    // Optional: false
    pWaitSemaphores: ?[*]const VkSemaphore = null,
    // Extern sync: false
    // Optional: true
    bufferBindCount: u32 = 0,
    // Length expression: bufferBindCount
    // Extern sync: false
    // Optional: false
    pBufferBinds: ?[*]const VkSparseBufferMemoryBindInfo = null,
    // Extern sync: false
    // Optional: true
    imageOpaqueBindCount: u32 = 0,
    // Length expression: imageOpaqueBindCount
    // Extern sync: false
    // Optional: false
    pImageOpaqueBinds: ?[*]const VkSparseImageOpaqueMemoryBindInfo = null,
    // Extern sync: false
    // Optional: true
    imageBindCount: u32 = 0,
    // Length expression: imageBindCount
    // Extern sync: false
    // Optional: false
    pImageBinds: ?[*]const VkSparseImageMemoryBindInfo = null,
    // Extern sync: false
    // Optional: true
    signalSemaphoreCount: u32 = 0,
    // Length expression: signalSemaphoreCount
    // Extern sync: false
    // Optional: false
    pSignalSemaphores: ?[*]const VkSemaphore = null,
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImageCopy = extern struct {
    // Extern sync: false
    // Optional: false
    srcSubresource: VkImageSubresourceLayers = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Specified in pixels for both compressed and uncompressed images
    srcOffset: VkOffset3D = .{},
    // Extern sync: false
    // Optional: false
    dstSubresource: VkImageSubresourceLayers = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Specified in pixels for both compressed and uncompressed images
    dstOffset: VkOffset3D = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Specified in pixels for both compressed and uncompressed images
    extent: VkExtent3D = .{},
};
// Extension: VK_GRAPHICS_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImageBlit = extern struct {
    // Extern sync: false
    // Optional: false
    srcSubresource: VkImageSubresourceLayers = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Specified in pixels for both compressed and uncompressed images
    srcOffsets: [2]VkOffset3D = .{VkOffset3D{}} ** 2,
    // Extern sync: false
    // Optional: false
    dstSubresource: VkImageSubresourceLayers = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Specified in pixels for both compressed and uncompressed images
    dstOffsets: [2]VkOffset3D = .{VkOffset3D{}} ** 2,
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkBufferImageCopy = extern struct {
    // Extern sync: false
    // Optional: false
    // Comment: Specified in bytes
    bufferOffset: u64 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Specified in texels
    bufferRowLength: u32 = 0,
    // Extern sync: false
    // Optional: false
    bufferImageHeight: u32 = 0,
    // Extern sync: false
    // Optional: false
    imageSubresource: VkImageSubresourceLayers = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Specified in pixels for both compressed and uncompressed images
    imageOffset: VkOffset3D = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Specified in pixels for both compressed and uncompressed images
    imageExtent: VkExtent3D = .{},
};
// Extension: VK_KHR_copy_memory_indirect
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkStridedDeviceAddressRangeKHR = extern struct {
    // Extern sync: false
    // Optional: true
    address: u64 = 0,
    // Extern sync: false
    // Optional: false
    size: u64 = 0,
    // Extern sync: false
    // Optional: false
    stride: u64 = 0,
};
// Extension: VK_NV_copy_memory_indirect
// Extension: VK_KHR_copy_memory_indirect
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkCopyMemoryIndirectCommandKHR = extern struct {
    // Extern sync: false
    // Optional: false
    srcAddress: u64 = 0,
    // Extern sync: false
    // Optional: false
    dstAddress: u64 = 0,
    // Extern sync: false
    // Optional: false
    size: u64 = 0,
};
// Extension: VK_KHR_copy_memory_indirect
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkCopyMemoryIndirectInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_COPY_MEMORY_INDIRECT_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    srcCopyFlags: VkAddressCopyFlagsKHR = .{},
    // Extern sync: false
    // Optional: false
    dstCopyFlags: VkAddressCopyFlagsKHR = .{},
    // Extern sync: false
    // Optional: false
    copyCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    copyAddressRange: VkStridedDeviceAddressRangeKHR = .{},
};
// Extension: VK_NV_copy_memory_indirect
// Extension: VK_KHR_copy_memory_indirect
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkCopyMemoryToImageIndirectCommandKHR = extern struct {
    // Extern sync: false
    // Optional: false
    srcAddress: u64 = 0,
    // Extern sync: false
    // Optional: false
    bufferRowLength: u32 = 0,
    // Extern sync: false
    // Optional: false
    bufferImageHeight: u32 = 0,
    // Extern sync: false
    // Optional: false
    imageSubresource: VkImageSubresourceLayers = .{},
    // Extern sync: false
    // Optional: false
    imageOffset: VkOffset3D = .{},
    // Extern sync: false
    // Optional: false
    imageExtent: VkExtent3D = .{},
};
// Extension: VK_KHR_copy_memory_indirect
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkCopyMemoryToImageIndirectInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_COPY_MEMORY_TO_IMAGE_INDIRECT_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    srcCopyFlags: VkAddressCopyFlagsKHR = .{},
    // Extern sync: false
    // Optional: false
    copyCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    copyAddressRange: VkStridedDeviceAddressRangeKHR = .{},
    // Extern sync: false
    // Optional: false
    dstImage: VkImage = .none,
    // Extern sync: false
    // Optional: false
    dstImageLayout: VkImageLayout = .VK_IMAGE_LAYOUT_UNDEFINED,
    // Length expression: copyCount
    // Extern sync: false
    // Optional: false
    pImageSubresources: ?[*]const VkImageSubresourceLayers = null,
};
// Extension: VK_GRAPHICS_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImageResolve = extern struct {
    // Extern sync: false
    // Optional: false
    srcSubresource: VkImageSubresourceLayers = .{},
    // Extern sync: false
    // Optional: false
    srcOffset: VkOffset3D = .{},
    // Extern sync: false
    // Optional: false
    dstSubresource: VkImageSubresourceLayers = .{},
    // Extern sync: false
    // Optional: false
    dstOffset: VkOffset3D = .{},
    // Extern sync: false
    // Optional: false
    extent: VkExtent3D = .{},
};
// Extension: VK_COMPUTE_VERSION_1_0
// Extends: VkPipelineShaderStageCreateInfo,VkDataGraphPipelineCreateInfoARM
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkShaderModuleCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    // Comment: noautovalidity because this structure can be either an explicit parameter, or passed in a pNext chain
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkShaderModuleCreateFlags = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Specified in bytes
    codeSize: u64 = 0,
    // Length expression: codeSize / 4
    // Extern sync: false
    // Optional: false
    // Comment: Binary code of size codeSize
    pCode: ?[*]const u32 = null,
};
// Extension: VK_COMPUTE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDescriptorSetLayoutBinding = extern struct {
    // Extern sync: false
    // Optional: false
    // Comment: Binding number for this entry
    binding: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Type of the descriptors in this binding
    descriptorType: VkDescriptorType = .VK_DESCRIPTOR_TYPE_SAMPLER,
    // Extern sync: false
    // Optional: true
    // Comment: Number of descriptors in this binding
    descriptorCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Shader stages this binding is visible to
    stageFlags: VkShaderStageFlags = .{},
    // Length expression: descriptorCount
    // Extern sync: false
    // Optional: true
    // Comment: Immutable samplers (used if descriptor type is SAMPLER or COMBINED_IMAGE_SAMPLER, is either NULL or contains count number of elements)
    pImmutableSamplers: ?[*]const VkSampler = null,
};
// Extension: VK_COMPUTE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDescriptorSetLayoutCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkDescriptorSetLayoutCreateFlags = .{},
    // Extern sync: false
    // Optional: true
    // Comment: Number of bindings in the descriptor set layout
    bindingCount: u32 = 0,
    // Length expression: bindingCount
    // Extern sync: false
    // Optional: false
    // Comment: Array of descriptor set layout bindings
    pBindings: ?[*]const VkDescriptorSetLayoutBinding = null,
};
// Extension: VK_COMPUTE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDescriptorPoolSize = extern struct {
    // Extern sync: false
    // Optional: false
    type: VkDescriptorType = .VK_DESCRIPTOR_TYPE_SAMPLER,
    // Extern sync: false
    // Optional: false
    descriptorCount: u32 = 0,
};
// Extension: VK_COMPUTE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDescriptorPoolCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkDescriptorPoolCreateFlags = .{},
    // Extern sync: false
    // Optional: false
    maxSets: u32 = 0,
    // Extern sync: false
    // Optional: true
    poolSizeCount: u32 = 0,
    // Length expression: poolSizeCount
    // Extern sync: false
    // Optional: false
    pPoolSizes: ?[*]const VkDescriptorPoolSize = null,
};
// Extension: VK_COMPUTE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDescriptorSetAllocateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: true
    // Optional: false
    descriptorPool: VkDescriptorPool = .none,
    // Extern sync: false
    // Optional: false
    descriptorSetCount: u32 = 0,
    // Length expression: descriptorSetCount
    // Extern sync: false
    // Optional: false
    pSetLayouts: ?[*]const VkDescriptorSetLayout = null,
};
// Extension: VK_COMPUTE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSpecializationMapEntry = extern struct {
    // Extern sync: false
    // Optional: false
    // Comment: The SpecConstant ID specified in the BIL
    constantID: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Offset of the value in the data block
    offset: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Size in bytes of the SpecConstant
    size: u64 = 0,
};
// Extension: VK_COMPUTE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSpecializationInfo = extern struct {
    // Extern sync: false
    // Optional: true
    // Comment: Number of entries in the map
    mapEntryCount: u32 = 0,
    // Length expression: mapEntryCount
    // Extern sync: false
    // Optional: false
    // Comment: Array of map entries
    pMapEntries: ?[*]const VkSpecializationMapEntry = null,
    // Extern sync: false
    // Optional: true
    // Comment: Size in bytes of pData
    dataSize: u64 = 0,
    // Length expression: dataSize
    // Extern sync: false
    // Optional: false
    // Comment: Pointer to SpecConstant data
    pData: ?*const anyopaque = null,
};
// Extension: VK_COMPUTE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineShaderStageCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkPipelineShaderStageCreateFlags = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Shader stage
    stage: VkShaderStageFlags = .{},
    // Extern sync: false
    // Optional: true
    // Comment: Module containing entry point
    module: VkShaderModule = .none,
    // Length expression: null-terminated
    // Extern sync: false
    // Optional: false
    // Comment: Null-terminated entry point name
    pName: ?[*:0]const u8 = null,
    // Extern sync: false
    // Optional: true
    pSpecializationInfo: ?*const VkSpecializationInfo = null,
};
// Extension: VK_COMPUTE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkComputePipelineCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    // Comment: Pipeline creation flags
    flags: VkPipelineCreateFlags = .{},
    // Extern sync: false
    // Optional: false
    stage: VkPipelineShaderStageCreateInfo = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Interface layout of the pipeline
    layout: VkPipelineLayout = .none,
    // Extern sync: false
    // Optional: true
    // Comment: If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is nonzero, it specifies the handle of the base pipeline this is a derivative of
    basePipelineHandle: VkPipeline = .none,
    // Extern sync: false
    // Optional: false
    // Comment: If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is not -1, it specifies an index into pCreateInfos of the base pipeline this is a derivative of
    basePipelineIndex: i32 = 0,
};
// Extension: VK_NV_device_generated_commands_compute
// Extends: VkComputePipelineCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkComputePipelineIndirectBufferInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_INDIRECT_BUFFER_INFO_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    deviceAddress: u64 = 0,
    // Extern sync: false
    // Optional: false
    size: u64 = 0,
    // Extern sync: false
    // Optional: true
    pipelineDeviceAddressCaptureReplay: u64 = 0,
};
// Extension: VK_KHR_maintenance5
// Extension: VK_COMPUTE_VERSION_1_4
// Extends: VkComputePipelineCreateInfo,VkGraphicsPipelineCreateInfo,VkRayTracingPipelineCreateInfoNV,VkRayTracingPipelineCreateInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineCreateFlags2CreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkPipelineCreateFlags2 = .{},
};
// Extension: VK_GRAPHICS_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVertexInputBindingDescription = extern struct {
    // Extern sync: false
    // Optional: false
    // Comment: Vertex buffer binding id
    binding: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Distance between vertices in bytes (0 = no advancement)
    stride: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: The rate at which the vertex data is consumed
    inputRate: VkVertexInputRate = .VK_VERTEX_INPUT_RATE_VERTEX,
};
// Extension: VK_GRAPHICS_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVertexInputAttributeDescription = extern struct {
    // Extern sync: false
    // Optional: false
    // Comment: location of the shader vertex attrib
    location: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Vertex buffer binding id
    binding: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: format of source data
    format: VkFormat = .VK_FORMAT_UNDEFINED,
    // Extern sync: false
    // Optional: false
    // Comment: Offset of first element in bytes from base of vertex
    offset: u32 = 0,
};
// Extension: VK_GRAPHICS_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineVertexInputStateCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkPipelineVertexInputStateCreateFlags = .{},
    // Extern sync: false
    // Optional: true
    // Comment: number of bindings
    vertexBindingDescriptionCount: u32 = 0,
    // Length expression: vertexBindingDescriptionCount
    // Extern sync: false
    // Optional: false
    pVertexBindingDescriptions: ?[*]const VkVertexInputBindingDescription = null,
    // Extern sync: false
    // Optional: true
    // Comment: number of attributes
    vertexAttributeDescriptionCount: u32 = 0,
    // Length expression: vertexAttributeDescriptionCount
    // Extern sync: false
    // Optional: false
    pVertexAttributeDescriptions: ?[*]const VkVertexInputAttributeDescription = null,
};
// Extension: VK_GRAPHICS_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineInputAssemblyStateCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkPipelineInputAssemblyStateCreateFlags = .{},
    // Extern sync: false
    // Optional: false
    topology: VkPrimitiveTopology = .VK_PRIMITIVE_TOPOLOGY_POINT_LIST,
    // Extern sync: false
    // Optional: false
    primitiveRestartEnable: u32 = 0,
};
// Extension: VK_GRAPHICS_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineTessellationStateCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkPipelineTessellationStateCreateFlags = .{},
    // Extern sync: false
    // Optional: false
    patchControlPoints: u32 = 0,
};
// Extension: VK_GRAPHICS_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineViewportStateCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkPipelineViewportStateCreateFlags = .{},
    // Extern sync: false
    // Optional: true
    viewportCount: u32 = 0,
    // Length expression: viewportCount
    // Extern sync: false
    // Optional: true
    pViewports: ?[*]const VkViewport = null,
    // Extern sync: false
    // Optional: true
    scissorCount: u32 = 0,
    // Length expression: scissorCount
    // Extern sync: false
    // Optional: true
    pScissors: ?[*]const VkRect2D = null,
};
// Extension: VK_GRAPHICS_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineRasterizationStateCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkPipelineRasterizationStateCreateFlags = .{},
    // Extern sync: false
    // Optional: false
    depthClampEnable: u32 = 0,
    // Extern sync: false
    // Optional: false
    rasterizerDiscardEnable: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: optional (GL45)
    polygonMode: VkPolygonMode = .VK_POLYGON_MODE_FILL,
    // Extern sync: false
    // Optional: true
    cullMode: VkCullModeFlags = .{},
    // Extern sync: false
    // Optional: false
    frontFace: VkFrontFace = .VK_FRONT_FACE_COUNTER_CLOCKWISE,
    // Extern sync: false
    // Optional: false
    depthBiasEnable: u32 = 0,
    // Extern sync: false
    // Optional: false
    depthBiasConstantFactor: f32 = 0,
    // Extern sync: false
    // Optional: false
    depthBiasClamp: f32 = 0,
    // Extern sync: false
    // Optional: false
    depthBiasSlopeFactor: f32 = 0,
    // Extern sync: false
    // Optional: false
    lineWidth: f32 = 0,
};
// Extension: VK_GRAPHICS_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineMultisampleStateCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkPipelineMultisampleStateCreateFlags = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Number of samples used for rasterization
    rasterizationSamples: VkSampleCountFlags = .{},
    // Extern sync: false
    // Optional: false
    // Comment: optional (GL45)
    sampleShadingEnable: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: optional (GL45)
    minSampleShading: f32 = 0,
    // Length expression: (rasterizationSamples + 31) / 32
    // Extern sync: false
    // Optional: true
    // Comment: Array of sampleMask words
    pSampleMask: ?[*]const u32 = null,
    // Extern sync: false
    // Optional: false
    alphaToCoverageEnable: u32 = 0,
    // Extern sync: false
    // Optional: false
    alphaToOneEnable: u32 = 0,
};
// Extension: VK_GRAPHICS_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineColorBlendAttachmentState = extern struct {
    // Extern sync: false
    // Optional: false
    blendEnable: u32 = 0,
    // Extern sync: false
    // Optional: false
    srcColorBlendFactor: VkBlendFactor = .VK_BLEND_FACTOR_ZERO,
    // Extern sync: false
    // Optional: false
    dstColorBlendFactor: VkBlendFactor = .VK_BLEND_FACTOR_ZERO,
    // Extern sync: false
    // Optional: false
    colorBlendOp: VkBlendOp = .VK_BLEND_OP_ADD,
    // Extern sync: false
    // Optional: false
    srcAlphaBlendFactor: VkBlendFactor = .VK_BLEND_FACTOR_ZERO,
    // Extern sync: false
    // Optional: false
    dstAlphaBlendFactor: VkBlendFactor = .VK_BLEND_FACTOR_ZERO,
    // Extern sync: false
    // Optional: false
    alphaBlendOp: VkBlendOp = .VK_BLEND_OP_ADD,
    // Extern sync: false
    // Optional: true
    colorWriteMask: VkColorComponentFlags = .{},
};
// Extension: VK_GRAPHICS_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineColorBlendStateCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkPipelineColorBlendStateCreateFlags = .{},
    // Extern sync: false
    // Optional: false
    logicOpEnable: u32 = 0,
    // Extern sync: false
    // Optional: false
    logicOp: VkLogicOp = .VK_LOGIC_OP_CLEAR,
    // Extern sync: false
    // Optional: true
    // Comment: # of pAttachments
    attachmentCount: u32 = 0,
    // Length expression: attachmentCount
    // Extern sync: false
    // Optional: true
    pAttachments: ?[*]const VkPipelineColorBlendAttachmentState = null,
    // Extern sync: false
    // Optional: false
    blendConstants: [4]f32 = @import("std").mem.zeroes([4]f32),
};
// Extension: VK_GRAPHICS_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineDynamicStateCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkPipelineDynamicStateCreateFlags = .{},
    // Extern sync: false
    // Optional: true
    dynamicStateCount: u32 = 0,
    // Length expression: dynamicStateCount
    // Extern sync: false
    // Optional: false
    pDynamicStates: ?[*]const VkDynamicState = null,
};
// Extension: VK_GRAPHICS_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkStencilOpState = extern struct {
    // Extern sync: false
    // Optional: false
    failOp: VkStencilOp = .VK_STENCIL_OP_KEEP,
    // Extern sync: false
    // Optional: false
    passOp: VkStencilOp = .VK_STENCIL_OP_KEEP,
    // Extern sync: false
    // Optional: false
    depthFailOp: VkStencilOp = .VK_STENCIL_OP_KEEP,
    // Extern sync: false
    // Optional: false
    compareOp: VkCompareOp = .VK_COMPARE_OP_NEVER,
    // Extern sync: false
    // Optional: false
    compareMask: u32 = 0,
    // Extern sync: false
    // Optional: false
    writeMask: u32 = 0,
    // Extern sync: false
    // Optional: false
    reference: u32 = 0,
};
// Extension: VK_GRAPHICS_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineDepthStencilStateCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkPipelineDepthStencilStateCreateFlags = .{},
    // Extern sync: false
    // Optional: false
    depthTestEnable: u32 = 0,
    // Extern sync: false
    // Optional: false
    depthWriteEnable: u32 = 0,
    // Extern sync: false
    // Optional: false
    depthCompareOp: VkCompareOp = .VK_COMPARE_OP_NEVER,
    // Extern sync: false
    // Optional: false
    // Comment: optional (depth_bounds_test)
    depthBoundsTestEnable: u32 = 0,
    // Extern sync: false
    // Optional: false
    stencilTestEnable: u32 = 0,
    // Extern sync: false
    // Optional: false
    front: VkStencilOpState = .{},
    // Extern sync: false
    // Optional: false
    back: VkStencilOpState = .{},
    // Extern sync: false
    // Optional: false
    minDepthBounds: f32 = 0,
    // Extern sync: false
    // Optional: false
    maxDepthBounds: f32 = 0,
};
// Extension: VK_GRAPHICS_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkGraphicsPipelineCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    // Comment: Pipeline creation flags
    flags: VkPipelineCreateFlags = .{},
    // Extern sync: false
    // Optional: true
    stageCount: u32 = 0,
    // Length expression: stageCount
    // Extern sync: false
    // Optional: true
    // Comment: One entry for each active shader stage
    pStages: ?[*]const VkPipelineShaderStageCreateInfo = null,
    // Extern sync: false
    // Optional: true
    pVertexInputState: ?*const VkPipelineVertexInputStateCreateInfo = null,
    // Extern sync: false
    // Optional: true
    pInputAssemblyState: ?*const VkPipelineInputAssemblyStateCreateInfo = null,
    // Extern sync: false
    // Optional: true
    pTessellationState: ?*const VkPipelineTessellationStateCreateInfo = null,
    // Extern sync: false
    // Optional: true
    pViewportState: ?*const VkPipelineViewportStateCreateInfo = null,
    // Extern sync: false
    // Optional: true
    pRasterizationState: ?*const VkPipelineRasterizationStateCreateInfo = null,
    // Extern sync: false
    // Optional: true
    pMultisampleState: ?*const VkPipelineMultisampleStateCreateInfo = null,
    // Extern sync: false
    // Optional: true
    pDepthStencilState: ?*const VkPipelineDepthStencilStateCreateInfo = null,
    // Extern sync: false
    // Optional: true
    pColorBlendState: ?*const VkPipelineColorBlendStateCreateInfo = null,
    // Extern sync: false
    // Optional: true
    pDynamicState: ?*const VkPipelineDynamicStateCreateInfo = null,
    // Extern sync: false
    // Optional: true
    // Comment: Interface layout of the pipeline
    layout: VkPipelineLayout = .none,
    // Extern sync: false
    // Optional: true
    renderPass: VkRenderPass = .none,
    // Extern sync: false
    // Optional: false
    subpass: u32 = 0,
    // Extern sync: false
    // Optional: true
    // Comment: If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is nonzero, it specifies the handle of the base pipeline this is a derivative of
    basePipelineHandle: VkPipeline = .none,
    // Extern sync: false
    // Optional: false
    // Comment: If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is not -1, it specifies an index into pCreateInfos of the base pipeline this is a derivative of
    basePipelineIndex: i32 = 0,
};
// Extension: VK_COMPUTE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineCacheCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkPipelineCacheCreateFlags = .{},
    // Extern sync: false
    // Optional: true
    // Comment: Size of initial data to populate cache, in bytes
    initialDataSize: u64 = 0,
    // Length expression: initialDataSize
    // Extern sync: false
    // Optional: false
    // Comment: Initial data to populate cache
    pInitialData: ?*const anyopaque = null,
};
// Extension: VK_COMPUTE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineCacheHeaderVersionOne = extern struct {
    // Extern sync: false
    // Optional: false
    headerSize: u32 = 0,
    // Extern sync: false
    // Optional: false
    headerVersion: VkPipelineCacheHeaderVersion = .VK_PIPELINE_CACHE_HEADER_VERSION_ONE,
    // Extern sync: false
    // Optional: false
    vendorID: u32 = 0,
    // Extern sync: false
    // Optional: false
    deviceID: u32 = 0,
    // Extern sync: false
    // Optional: false
    pipelineCacheUUID: [VK_UUID_SIZE]u8 = @import("std").mem.zeroes([VK_UUID_SIZE]u8),
};
// Extension: VKSC_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineCacheStageValidationIndexEntry = extern struct {
    // Extern sync: false
    // Optional: false
    codeSize: u64 = 0,
    // Extern sync: false
    // Optional: false
    codeOffset: u64 = 0,
};
// Extension: VKSC_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineCacheSafetyCriticalIndexEntry = extern struct {
    // Extern sync: false
    // Optional: false
    pipelineIdentifier: [VK_UUID_SIZE]u8 = @import("std").mem.zeroes([VK_UUID_SIZE]u8),
    // Extern sync: false
    // Optional: false
    pipelineMemorySize: u64 = 0,
    // Extern sync: false
    // Optional: false
    jsonSize: u64 = 0,
    // Extern sync: false
    // Optional: false
    jsonOffset: u64 = 0,
    // Extern sync: false
    // Optional: false
    stageIndexCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    stageIndexStride: u32 = 0,
    // Extern sync: false
    // Optional: false
    stageIndexOffset: u64 = 0,
};
// Extension: VKSC_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineCacheHeaderVersionSafetyCriticalOne = extern struct {
    // Extern sync: false
    // Optional: false
    headerVersionOne: VkPipelineCacheHeaderVersionOne = .{},
    // Extern sync: false
    // Optional: false
    validationVersion: VkPipelineCacheValidationVersion = .VK_PIPELINE_CACHE_VALIDATION_VERSION_SAFETY_CRITICAL_ONE,
    // Extern sync: false
    // Optional: false
    implementationData: u32 = 0,
    // Extern sync: false
    // Optional: false
    pipelineIndexCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    pipelineIndexStride: u32 = 0,
    // Extern sync: false
    // Optional: false
    pipelineIndexOffset: u64 = 0,
};
// Extension: VK_QCOM_data_graph_model
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineCacheHeaderVersionDataGraphQCOM = extern struct {
    // Extern sync: false
    // Optional: false
    headerSize: u32 = 0,
    // Extern sync: false
    // Optional: false
    headerVersion: VkPipelineCacheHeaderVersion = .VK_PIPELINE_CACHE_HEADER_VERSION_ONE,
    // Extern sync: false
    // Optional: false
    cacheType: VkDataGraphModelCacheTypeQCOM = .VK_DATA_GRAPH_MODEL_CACHE_TYPE_GENERIC_BINARY_QCOM,
    // Extern sync: false
    // Optional: false
    cacheVersion: ApiVersion = .{},
    // Extern sync: false
    // Optional: false
    toolchainVersion: [VK_DATA_GRAPH_MODEL_TOOLCHAIN_VERSION_LENGTH_QCOM]u32 = @import("std").mem.zeroes([VK_DATA_GRAPH_MODEL_TOOLCHAIN_VERSION_LENGTH_QCOM]u32),
};
// Extension: VK_COMPUTE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPushConstantRange = extern struct {
    // Extern sync: false
    // Optional: false
    // Comment: Which stages use the range
    stageFlags: VkShaderStageFlags = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Start of the range, in bytes
    offset: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Size of the range, in bytes
    size: u32 = 0,
};
// Extension: VK_KHR_pipeline_binary
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineBinaryCreateInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_BINARY_CREATE_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    pKeysAndDataInfo: ?*const VkPipelineBinaryKeysAndDataKHR = null,
    // Extern sync: false
    // Optional: true
    pipeline: VkPipeline = .none,
    // Extern sync: false
    // Optional: true
    pPipelineCreateInfo: ?*const VkPipelineCreateInfoKHR = null,
};
// Extension: VK_KHR_pipeline_binary
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineBinaryHandlesInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_BINARY_HANDLES_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    pipelineBinaryCount: u32 = 0,
    // Length expression: pipelineBinaryCount
    // Extern sync: false
    // Optional: true
    pPipelineBinaries: ?[*]VkPipelineBinaryKHR = null,
};
// Extension: VK_KHR_pipeline_binary
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineBinaryDataKHR = extern struct {
    // Extern sync: false
    // Optional: false
    dataSize: u64 = 0,
    // Length expression: dataSize
    // Extern sync: false
    // Optional: false
    pData: ?*anyopaque = null,
};
// Extension: VK_KHR_pipeline_binary
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineBinaryKeysAndDataKHR = extern struct {
    // Extern sync: false
    // Optional: false
    binaryCount: u32 = 0,
    // Length expression: binaryCount
    // Extern sync: false
    // Optional: false
    pPipelineBinaryKeys: ?[*]const VkPipelineBinaryKeyKHR = null,
    // Length expression: binaryCount
    // Extern sync: false
    // Optional: false
    pPipelineBinaryData: ?[*]const VkPipelineBinaryDataKHR = null,
};
// Extension: VK_KHR_pipeline_binary
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineBinaryKeyKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_BINARY_KEY_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    keySize: u32 = 0,
    // Extern sync: false
    // Optional: false
    key: [VK_MAX_PIPELINE_BINARY_KEY_SIZE_KHR]u8 = @import("std").mem.zeroes([VK_MAX_PIPELINE_BINARY_KEY_SIZE_KHR]u8),
};
// Extension: VK_KHR_pipeline_binary
// Extends: VkGraphicsPipelineCreateInfo,VkComputePipelineCreateInfo,VkRayTracingPipelineCreateInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineBinaryInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_BINARY_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    binaryCount: u32 = 0,
    // Length expression: binaryCount
    // Extern sync: false
    // Optional: false
    pPipelineBinaries: ?[*]const VkPipelineBinaryKHR = null,
};
// Extension: VK_KHR_pipeline_binary
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkReleaseCapturedPipelineDataInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_RELEASE_CAPTURED_PIPELINE_DATA_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: true
    // Optional: false
    pipeline: VkPipeline = .none,
};
// Extension: VK_KHR_pipeline_binary
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineBinaryDataInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_BINARY_DATA_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    pipelineBinary: VkPipelineBinaryKHR = .none,
};
// Extension: VK_KHR_pipeline_binary
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineCreateInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_CREATE_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
};
// Extension: VK_COMPUTE_VERSION_1_0
// Extends: VkBindDescriptorSetsInfo,VkPushConstantsInfo,VkPushDescriptorSetInfo,VkPushDescriptorSetWithTemplateInfo,VkSetDescriptorBufferOffsetsInfoEXT,VkBindDescriptorBufferEmbeddedSamplersInfoEXT,VkIndirectCommandsLayoutCreateInfoEXT
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineLayoutCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkPipelineLayoutCreateFlags = .{},
    // Extern sync: false
    // Optional: true
    // Comment: Number of descriptor sets interfaced by the pipeline
    setLayoutCount: u32 = 0,
    // Length expression: setLayoutCount
    // Extern sync: false
    // Optional: false
    // Comment: Array of setCount number of descriptor set layout objects defining the layout of the
    pSetLayouts: ?[*]const VkDescriptorSetLayout = null,
    // Extern sync: false
    // Optional: true
    // Comment: Number of push-constant ranges used by the pipeline
    pushConstantRangeCount: u32 = 0,
    // Length expression: pushConstantRangeCount
    // Extern sync: false
    // Optional: false
    // Comment: Array of pushConstantRangeCount number of ranges used by various shader stages
    pPushConstantRanges: ?[*]const VkPushConstantRange = null,
};
// Extension: VK_COMPUTE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSamplerCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkSamplerCreateFlags = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Filter mode for magnification
    magFilter: VkFilter = .VK_FILTER_NEAREST,
    // Extern sync: false
    // Optional: false
    // Comment: Filter mode for minifiation
    minFilter: VkFilter = .VK_FILTER_NEAREST,
    // Extern sync: false
    // Optional: false
    // Comment: Mipmap selection mode
    mipmapMode: VkSamplerMipmapMode = .VK_SAMPLER_MIPMAP_MODE_NEAREST,
    // Extern sync: false
    // Optional: false
    addressModeU: VkSamplerAddressMode = .VK_SAMPLER_ADDRESS_MODE_REPEAT,
    // Extern sync: false
    // Optional: false
    addressModeV: VkSamplerAddressMode = .VK_SAMPLER_ADDRESS_MODE_REPEAT,
    // Extern sync: false
    // Optional: false
    addressModeW: VkSamplerAddressMode = .VK_SAMPLER_ADDRESS_MODE_REPEAT,
    // Extern sync: false
    // Optional: false
    mipLodBias: f32 = 0,
    // Extern sync: false
    // Optional: false
    anisotropyEnable: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxAnisotropy: f32 = 0,
    // Extern sync: false
    // Optional: false
    compareEnable: u32 = 0,
    // Extern sync: false
    // Optional: false
    compareOp: VkCompareOp = .VK_COMPARE_OP_NEVER,
    // Extern sync: false
    // Optional: false
    minLod: f32 = 0,
    // Extern sync: false
    // Optional: false
    maxLod: f32 = 0,
    // Extern sync: false
    // Optional: false
    borderColor: VkBorderColor = .VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK,
    // Extern sync: false
    // Optional: false
    unnormalizedCoordinates: u32 = 0,
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkCommandPoolCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    // Comment: Command pool creation flags
    flags: VkCommandPoolCreateFlags = .{},
    // Extern sync: false
    // Optional: false
    queueFamilyIndex: u32 = 0,
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkCommandBufferAllocateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: true
    // Optional: false
    commandPool: VkCommandPool = .none,
    // Extern sync: false
    // Optional: false
    level: VkCommandBufferLevel = .VK_COMMAND_BUFFER_LEVEL_PRIMARY,
    // Extern sync: false
    // Optional: false
    commandBufferCount: u32 = 0,
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkCommandBufferInheritanceInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    // Comment: Render pass for secondary command buffers
    renderPass: VkRenderPass = .none,
    // Extern sync: false
    // Optional: false
    subpass: u32 = 0,
    // Extern sync: false
    // Optional: true
    // Comment: Framebuffer for secondary command buffers
    framebuffer: VkFramebuffer = .none,
    // Extern sync: false
    // Optional: false
    // Comment: Whether this secondary command buffer may be executed during an occlusion query
    occlusionQueryEnable: u32 = 0,
    // Extern sync: false
    // Optional: true
    // Comment: Query flags used by this secondary command buffer, if executed during an occlusion query
    queryFlags: VkQueryControlFlags = .{},
    // Extern sync: false
    // Optional: true
    // Comment: Pipeline statistics that may be counted for this secondary command buffer
    pipelineStatistics: VkQueryPipelineStatisticFlags = .{},
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkCommandBufferBeginInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    // Comment: Command buffer usage flags
    flags: VkCommandBufferUsageFlags = .{},
    // Extern sync: false
    // Optional: true
    // Comment: Pointer to inheritance info for secondary command buffers
    pInheritanceInfo: ?*const VkCommandBufferInheritanceInfo = null,
};
// Extension: VK_GRAPHICS_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkRenderPassBeginInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    renderPass: VkRenderPass = .none,
    // Extern sync: false
    // Optional: false
    framebuffer: VkFramebuffer = .none,
    // Extern sync: false
    // Optional: false
    renderArea: VkRect2D = .{},
    // Extern sync: false
    // Optional: true
    clearValueCount: u32 = 0,
    // Length expression: clearValueCount
    // Extern sync: false
    // Optional: false
    pClearValues: ?[*]const VkClearValue = null,
};
// Extension: VK_GRAPHICS_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkClearDepthStencilValue = extern struct {
    // Extern sync: false
    // Optional: false
    depth: f32 = 0,
    // Extern sync: false
    // Optional: false
    stencil: u32 = 0,
};
// Extension: VK_GRAPHICS_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkClearAttachment = extern struct {
    // Extern sync: false
    // Optional: false
    aspectMask: VkImageAspectFlags = .{},
    // Extern sync: false
    // Optional: false
    colorAttachment: u32 = 0,
    // Extern sync: false
    // Optional: false
    clearValue: VkClearValue,
};
// Extension: VK_GRAPHICS_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkAttachmentDescription = extern struct {
    // Extern sync: false
    // Optional: true
    flags: VkAttachmentDescriptionFlags = .{},
    // Extern sync: false
    // Optional: false
    format: VkFormat = .VK_FORMAT_UNDEFINED,
    // Extern sync: false
    // Optional: false
    samples: VkSampleCountFlags = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Load operation for color or depth data
    loadOp: VkAttachmentLoadOp = .VK_ATTACHMENT_LOAD_OP_LOAD,
    // Extern sync: false
    // Optional: false
    // Comment: Store operation for color or depth data
    storeOp: VkAttachmentStoreOp = .VK_ATTACHMENT_STORE_OP_STORE,
    // Extern sync: false
    // Optional: false
    // Comment: Load operation for stencil data
    stencilLoadOp: VkAttachmentLoadOp = .VK_ATTACHMENT_LOAD_OP_LOAD,
    // Extern sync: false
    // Optional: false
    // Comment: Store operation for stencil data
    stencilStoreOp: VkAttachmentStoreOp = .VK_ATTACHMENT_STORE_OP_STORE,
    // Extern sync: false
    // Optional: false
    initialLayout: VkImageLayout = .VK_IMAGE_LAYOUT_UNDEFINED,
    // Extern sync: false
    // Optional: false
    finalLayout: VkImageLayout = .VK_IMAGE_LAYOUT_UNDEFINED,
};
// Extension: VK_GRAPHICS_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkAttachmentReference = extern struct {
    // Extern sync: false
    // Optional: false
    attachment: u32 = 0,
    // Extern sync: false
    // Optional: false
    layout: VkImageLayout = .VK_IMAGE_LAYOUT_UNDEFINED,
};
// Extension: VK_GRAPHICS_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSubpassDescription = extern struct {
    // Extern sync: false
    // Optional: true
    flags: VkSubpassDescriptionFlags = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Must be VK_PIPELINE_BIND_POINT_GRAPHICS for now
    pipelineBindPoint: VkPipelineBindPoint = .VK_PIPELINE_BIND_POINT_GRAPHICS,
    // Extern sync: false
    // Optional: true
    inputAttachmentCount: u32 = 0,
    // Length expression: inputAttachmentCount
    // Extern sync: false
    // Optional: false
    pInputAttachments: ?[*]const VkAttachmentReference = null,
    // Extern sync: false
    // Optional: true
    colorAttachmentCount: u32 = 0,
    // Length expression: colorAttachmentCount
    // Extern sync: false
    // Optional: false
    pColorAttachments: ?[*]const VkAttachmentReference = null,
    // Length expression: colorAttachmentCount
    // Extern sync: false
    // Optional: true
    pResolveAttachments: ?[*]const VkAttachmentReference = null,
    // Extern sync: false
    // Optional: true
    pDepthStencilAttachment: ?*const VkAttachmentReference = null,
    // Extern sync: false
    // Optional: true
    preserveAttachmentCount: u32 = 0,
    // Length expression: preserveAttachmentCount
    // Extern sync: false
    // Optional: false
    pPreserveAttachments: ?[*]const u32 = null,
};
// Extension: VK_GRAPHICS_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSubpassDependency = extern struct {
    // Extern sync: false
    // Optional: false
    srcSubpass: u32 = 0,
    // Extern sync: false
    // Optional: false
    dstSubpass: u32 = 0,
    // Extern sync: false
    // Optional: true
    srcStageMask: VkPipelineStageFlags = .{},
    // Extern sync: false
    // Optional: true
    dstStageMask: VkPipelineStageFlags = .{},
    // Extern sync: false
    // Optional: true
    // Comment: Memory accesses from the source of the dependency to synchronize
    srcAccessMask: VkAccessFlags = .{},
    // Extern sync: false
    // Optional: true
    // Comment: Memory accesses from the destination of the dependency to synchronize
    dstAccessMask: VkAccessFlags = .{},
    // Extern sync: false
    // Optional: true
    dependencyFlags: VkDependencyFlags = .{},
};
// Extension: VK_GRAPHICS_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkRenderPassCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkRenderPassCreateFlags = .{},
    // Extern sync: false
    // Optional: true
    attachmentCount: u32 = 0,
    // Length expression: attachmentCount
    // Extern sync: false
    // Optional: false
    pAttachments: ?[*]const VkAttachmentDescription = null,
    // Extern sync: false
    // Optional: false
    subpassCount: u32 = 0,
    // Length expression: subpassCount
    // Extern sync: false
    // Optional: false
    pSubpasses: ?[*]const VkSubpassDescription = null,
    // Extern sync: false
    // Optional: true
    dependencyCount: u32 = 0,
    // Length expression: dependencyCount
    // Extern sync: false
    // Optional: false
    pDependencies: ?[*]const VkSubpassDependency = null,
};
// Extension: VK_COMPUTE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkEventCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_EVENT_CREATE_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    // Comment: Event creation flags
    flags: VkEventCreateFlags = .{},
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkFenceCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_FENCE_CREATE_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    // Comment: Fence creation flags
    flags: VkFenceCreateFlags = .{},
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceFeatures = extern struct {
    // Extern sync: false
    // Optional: false
    // Comment: out of bounds buffer accesses are well defined
    robustBufferAccess: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: full 32-bit range of indices for indexed draw calls
    fullDrawIndexUint32: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: image views which are arrays of cube maps
    imageCubeArray: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: blending operations are controlled per-attachment
    independentBlend: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: geometry stage
    geometryShader: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: tessellation control and evaluation stage
    tessellationShader: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: per-sample shading and interpolation
    sampleRateShading: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: blend operations which take two sources
    dualSrcBlend: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: logic operations
    logicOp: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: multi draw indirect
    multiDrawIndirect: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: indirect drawing can use non-zero firstInstance
    drawIndirectFirstInstance: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: depth clamping
    depthClamp: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: depth bias clamping
    depthBiasClamp: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: point and wireframe fill modes
    fillModeNonSolid: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: depth bounds test
    depthBounds: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: lines with width greater than 1
    wideLines: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: points with size greater than 1
    largePoints: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: the fragment alpha component can be forced to maximum representable alpha value
    alphaToOne: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: viewport arrays
    multiViewport: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: anisotropic sampler filtering
    samplerAnisotropy: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: ETC texture compression formats
    textureCompressionETC2: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: ASTC LDR texture compression formats
    textureCompressionASTC_LDR: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: BC1-7 texture compressed formats
    textureCompressionBC: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: precise occlusion queries returning actual sample counts
    occlusionQueryPrecise: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: pipeline statistics query
    pipelineStatisticsQuery: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: stores and atomic ops on storage buffers and images are supported in vertex, tessellation, and geometry stages
    vertexPipelineStoresAndAtomics: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: stores and atomic ops on storage buffers and images are supported in the fragment stage
    fragmentStoresAndAtomics: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: tessellation and geometry stages can export point size
    shaderTessellationAndGeometryPointSize: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: image gather with runtime values and independent offsets
    shaderImageGatherExtended: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: the extended set of formats can be used for storage images
    shaderStorageImageExtendedFormats: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: multisample images can be used for storage images
    shaderStorageImageMultisample: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: read from storage image does not require format qualifier
    shaderStorageImageReadWithoutFormat: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: write to storage image does not require format qualifier
    shaderStorageImageWriteWithoutFormat: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: arrays of uniform buffers can be accessed with dynamically uniform indices
    shaderUniformBufferArrayDynamicIndexing: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: arrays of sampled images can be accessed with dynamically uniform indices
    shaderSampledImageArrayDynamicIndexing: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: arrays of storage buffers can be accessed with dynamically uniform indices
    shaderStorageBufferArrayDynamicIndexing: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: arrays of storage images can be accessed with dynamically uniform indices
    shaderStorageImageArrayDynamicIndexing: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: clip distance in shaders
    shaderClipDistance: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: cull distance in shaders
    shaderCullDistance: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: 64-bit floats (doubles) in shaders
    shaderFloat64: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: 64-bit integers in shaders
    shaderInt64: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: 16-bit integers in shaders
    shaderInt16: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: shader can use texture operations that return resource residency information (requires sparseNonResident support)
    shaderResourceResidency: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: shader can use texture operations that specify minimum resource LOD
    shaderResourceMinLod: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Sparse resources support: Resource memory can be managed at opaque page level rather than object level
    sparseBinding: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Sparse resources support: GPU can access partially resident buffers 
    sparseResidencyBuffer: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Sparse resources support: GPU can access partially resident 2D (non-MSAA non-depth/stencil) images 
    sparseResidencyImage2D: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Sparse resources support: GPU can access partially resident 3D images 
    sparseResidencyImage3D: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Sparse resources support: GPU can access partially resident MSAA 2D images with 2 samples
    sparseResidency2Samples: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Sparse resources support: GPU can access partially resident MSAA 2D images with 4 samples
    sparseResidency4Samples: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Sparse resources support: GPU can access partially resident MSAA 2D images with 8 samples
    sparseResidency8Samples: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Sparse resources support: GPU can access partially resident MSAA 2D images with 16 samples
    sparseResidency16Samples: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Sparse resources support: GPU can correctly access data aliased into multiple locations (opt-in)
    sparseResidencyAliased: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: multisample rate must be the same for all pipelines in a subpass
    variableMultisampleRate: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Queries may be inherited from primary to secondary command buffers
    inheritedQueries: u32 = 0,
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceSparseProperties = extern struct {
    // Extern sync: false
    // Optional: false
    // Comment: Sparse resources support: GPU will access all 2D (single sample) sparse resources using the standard sparse image block shapes (based on pixel format)
    residencyStandard2DBlockShape: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Sparse resources support: GPU will access all 2D (multisample) sparse resources using the standard sparse image block shapes (based on pixel format)
    residencyStandard2DMultisampleBlockShape: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Sparse resources support: GPU will access all 3D sparse resources using the standard sparse image block shapes (based on pixel format)
    residencyStandard3DBlockShape: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Sparse resources support: Images with mip level dimensions that are NOT a multiple of the sparse image block dimensions will be placed in the mip tail
    residencyAlignedMipSize: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Sparse resources support: GPU can consistently access non-resident regions of a resource, all reads return as if data is 0, writes are discarded
    residencyNonResidentStrict: u32 = 0,
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceLimits = extern struct {
    // Extern sync: false
    // Optional: false
    // Comment: max 1D image dimension
    maxImageDimension1D: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: max 2D image dimension
    maxImageDimension2D: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: max 3D image dimension
    maxImageDimension3D: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: max cube map image dimension
    maxImageDimensionCube: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: max layers for image arrays
    maxImageArrayLayers: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: max texel buffer size (fstexels)
    maxTexelBufferElements: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: max uniform buffer range (bytes)
    maxUniformBufferRange: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: max storage buffer range (bytes)
    maxStorageBufferRange: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: max size of the push constants pool (bytes)
    maxPushConstantsSize: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: max number of device memory allocations supported
    maxMemoryAllocationCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: max number of samplers that can be allocated on a device
    maxSamplerAllocationCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Granularity (in bytes) at which buffers and images can be bound to adjacent memory for simultaneous usage
    bufferImageGranularity: u64 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Total address space available for sparse allocations (bytes)
    sparseAddressSpaceSize: u64 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: max number of descriptors sets that can be bound to a pipeline
    maxBoundDescriptorSets: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: max number of samplers allowed per-stage in a descriptor set
    maxPerStageDescriptorSamplers: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: max number of uniform buffers allowed per-stage in a descriptor set
    maxPerStageDescriptorUniformBuffers: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: max number of storage buffers allowed per-stage in a descriptor set
    maxPerStageDescriptorStorageBuffers: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: max number of sampled images allowed per-stage in a descriptor set
    maxPerStageDescriptorSampledImages: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: max number of storage images allowed per-stage in a descriptor set
    maxPerStageDescriptorStorageImages: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: max number of input attachments allowed per-stage in a descriptor set
    maxPerStageDescriptorInputAttachments: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: max number of resources allowed by a single stage
    maxPerStageResources: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: max number of samplers allowed in all stages in a descriptor set
    maxDescriptorSetSamplers: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: max number of uniform buffers allowed in all stages in a descriptor set
    maxDescriptorSetUniformBuffers: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: max number of dynamic uniform buffers allowed in all stages in a descriptor set
    maxDescriptorSetUniformBuffersDynamic: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: max number of storage buffers allowed in all stages in a descriptor set
    maxDescriptorSetStorageBuffers: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: max number of dynamic storage buffers allowed in all stages in a descriptor set
    maxDescriptorSetStorageBuffersDynamic: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: max number of sampled images allowed in all stages in a descriptor set
    maxDescriptorSetSampledImages: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: max number of storage images allowed in all stages in a descriptor set
    maxDescriptorSetStorageImages: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: max number of input attachments allowed in all stages in a descriptor set
    maxDescriptorSetInputAttachments: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: max number of vertex input attribute slots
    maxVertexInputAttributes: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: max number of vertex input binding slots
    maxVertexInputBindings: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: max vertex input attribute offset added to vertex buffer offset
    maxVertexInputAttributeOffset: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: max vertex input binding stride
    maxVertexInputBindingStride: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: max number of output components written by vertex shader
    maxVertexOutputComponents: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: max level supported by tessellation primitive generator
    maxTessellationGenerationLevel: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: max patch size (vertices)
    maxTessellationPatchSize: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: max number of input components per-vertex in TCS
    maxTessellationControlPerVertexInputComponents: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: max number of output components per-vertex in TCS
    maxTessellationControlPerVertexOutputComponents: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: max number of output components per-patch in TCS
    maxTessellationControlPerPatchOutputComponents: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: max total number of per-vertex and per-patch output components in TCS
    maxTessellationControlTotalOutputComponents: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: max number of input components per vertex in TES
    maxTessellationEvaluationInputComponents: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: max number of output components per vertex in TES
    maxTessellationEvaluationOutputComponents: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: max invocation count supported in geometry shader
    maxGeometryShaderInvocations: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: max number of input components read in geometry stage
    maxGeometryInputComponents: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: max number of output components written in geometry stage
    maxGeometryOutputComponents: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: max number of vertices that can be emitted in geometry stage
    maxGeometryOutputVertices: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: max total number of components (all vertices) written in geometry stage
    maxGeometryTotalOutputComponents: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: max number of input components read in fragment stage
    maxFragmentInputComponents: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: max number of output attachments written in fragment stage
    maxFragmentOutputAttachments: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: max number of output attachments written when using dual source blending
    maxFragmentDualSrcAttachments: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: max total number of storage buffers, storage images and output buffers
    maxFragmentCombinedOutputResources: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: max total storage size of work group local storage (bytes)
    maxComputeSharedMemorySize: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: max num of compute work groups that may be dispatched by a single command (x,y,z)
    maxComputeWorkGroupCount: [3]u32 = @import("std").mem.zeroes([3]u32),
    // Extern sync: false
    // Optional: false
    // Comment: max total compute invocations in a single local work group
    maxComputeWorkGroupInvocations: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: max local size of a compute work group (x,y,z)
    maxComputeWorkGroupSize: [3]u32 = @import("std").mem.zeroes([3]u32),
    // Extern sync: false
    // Optional: false
    // Comment: number bits of subpixel precision in screen x and y
    subPixelPrecisionBits: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: number bits of precision for selecting texel weights
    subTexelPrecisionBits: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: number bits of precision for selecting mipmap weights
    mipmapPrecisionBits: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: max index value for indexed draw calls (for 32-bit indices)
    maxDrawIndexedIndexValue: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: max draw count for indirect drawing calls
    maxDrawIndirectCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: max absolute sampler LOD bias
    maxSamplerLodBias: f32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: max degree of sampler anisotropy
    maxSamplerAnisotropy: f32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: max number of active viewports
    maxViewports: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: max viewport dimensions (x,y)
    maxViewportDimensions: [2]u32 = @import("std").mem.zeroes([2]u32),
    // Extern sync: false
    // Optional: false
    // Comment: viewport bounds range (min,max)
    viewportBoundsRange: [2]f32 = @import("std").mem.zeroes([2]f32),
    // Extern sync: false
    // Optional: false
    // Comment: number bits of subpixel precision for viewport
    viewportSubPixelBits: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: min required alignment of pointers returned by MapMemory (bytes)
    minMemoryMapAlignment: u64 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: min required alignment for texel buffer offsets (bytes) 
    minTexelBufferOffsetAlignment: u64 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: min required alignment for uniform buffer sizes and offsets (bytes)
    minUniformBufferOffsetAlignment: u64 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: min required alignment for storage buffer offsets (bytes)
    minStorageBufferOffsetAlignment: u64 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: min texel offset for OpTextureSampleOffset
    minTexelOffset: i32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: max texel offset for OpTextureSampleOffset
    maxTexelOffset: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: min texel offset for OpTextureGatherOffset
    minTexelGatherOffset: i32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: max texel offset for OpTextureGatherOffset
    maxTexelGatherOffset: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: furthest negative offset for interpolateAtOffset
    minInterpolationOffset: f32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: furthest positive offset for interpolateAtOffset
    maxInterpolationOffset: f32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: number of subpixel bits for interpolateAtOffset
    subPixelInterpolationOffsetBits: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: max width for a framebuffer
    maxFramebufferWidth: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: max height for a framebuffer
    maxFramebufferHeight: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: max layer count for a layered framebuffer
    maxFramebufferLayers: u32 = 0,
    // Extern sync: false
    // Optional: true
    // Comment: supported color sample counts for a framebuffer
    framebufferColorSampleCounts: VkSampleCountFlags = .{},
    // Extern sync: false
    // Optional: true
    // Comment: supported depth sample counts for a framebuffer
    framebufferDepthSampleCounts: VkSampleCountFlags = .{},
    // Extern sync: false
    // Optional: true
    // Comment: supported stencil sample counts for a framebuffer
    framebufferStencilSampleCounts: VkSampleCountFlags = .{},
    // Extern sync: false
    // Optional: true
    // Comment: supported sample counts for a subpass which uses no attachments
    framebufferNoAttachmentsSampleCounts: VkSampleCountFlags = .{},
    // Extern sync: false
    // Optional: false
    // Comment: max number of color attachments per subpass
    maxColorAttachments: u32 = 0,
    // Extern sync: false
    // Optional: true
    // Comment: supported color sample counts for a non-integer sampled image
    sampledImageColorSampleCounts: VkSampleCountFlags = .{},
    // Extern sync: false
    // Optional: true
    // Comment: supported sample counts for an integer image
    sampledImageIntegerSampleCounts: VkSampleCountFlags = .{},
    // Extern sync: false
    // Optional: true
    // Comment: supported depth sample counts for a sampled image
    sampledImageDepthSampleCounts: VkSampleCountFlags = .{},
    // Extern sync: false
    // Optional: true
    // Comment: supported stencil sample counts for a sampled image
    sampledImageStencilSampleCounts: VkSampleCountFlags = .{},
    // Extern sync: false
    // Optional: true
    // Comment: supported sample counts for a storage image
    storageImageSampleCounts: VkSampleCountFlags = .{},
    // Extern sync: false
    // Optional: false
    // Comment: max number of sample mask words
    maxSampleMaskWords: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: timestamps on graphics and compute queues
    timestampComputeAndGraphics: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: number of nanoseconds it takes for timestamp query value to increment by 1
    timestampPeriod: f32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: max number of clip distances
    maxClipDistances: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: max number of cull distances
    maxCullDistances: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: max combined number of user clipping
    maxCombinedClipAndCullDistances: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: distinct queue priorities available 
    discreteQueuePriorities: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: range (min,max) of supported point sizes
    pointSizeRange: [2]f32 = @import("std").mem.zeroes([2]f32),
    // Extern sync: false
    // Optional: false
    // Comment: range (min,max) of supported line widths
    lineWidthRange: [2]f32 = @import("std").mem.zeroes([2]f32),
    // Extern sync: false
    // Optional: false
    // Comment: granularity of supported point sizes
    pointSizeGranularity: f32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: granularity of supported line widths
    lineWidthGranularity: f32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: line rasterization follows preferred rules
    strictLines: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: supports standard sample locations for all supported sample counts
    standardSampleLocations: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: optimal offset of buffer copies
    optimalBufferCopyOffsetAlignment: u64 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: optimal pitch of buffer copies
    optimalBufferCopyRowPitchAlignment: u64 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: minimum size and alignment for non-coherent host-mapped device memory access
    nonCoherentAtomSize: u64 = 0,
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSemaphoreCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    // Comment: Semaphore creation flags
    flags: VkSemaphoreCreateFlags = .{},
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkQueryPoolCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkQueryPoolCreateFlags = .{},
    // Extern sync: false
    // Optional: false
    queryType: VkQueryType = .VK_QUERY_TYPE_OCCLUSION,
    // Extern sync: false
    // Optional: false
    queryCount: u32 = 0,
    // Extern sync: false
    // Optional: true
    // Comment: Optional
    pipelineStatistics: VkQueryPipelineStatisticFlags = .{},
};
// Extension: VK_GRAPHICS_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkFramebufferCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkFramebufferCreateFlags = .{},
    // Extern sync: false
    // Optional: false
    renderPass: VkRenderPass = .none,
    // Extern sync: false
    // Optional: true
    attachmentCount: u32 = 0,
    // Length expression: attachmentCount
    // Extern sync: false
    // Optional: false
    pAttachments: ?[*]const VkImageView = null,
    // Extern sync: false
    // Optional: false
    width: u32 = 0,
    // Extern sync: false
    // Optional: false
    height: u32 = 0,
    // Extern sync: false
    // Optional: false
    layers: u32 = 0,
};
// Extension: VK_GRAPHICS_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDrawIndirectCommand = extern struct {
    // Extern sync: false
    // Optional: false
    vertexCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    instanceCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    firstVertex: u32 = 0,
    // Extern sync: false
    // Optional: false
    firstInstance: u32 = 0,
};
// Extension: VK_GRAPHICS_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDrawIndexedIndirectCommand = extern struct {
    // Extern sync: false
    // Optional: false
    indexCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    instanceCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    firstIndex: u32 = 0,
    // Extern sync: false
    // Optional: false
    vertexOffset: i32 = 0,
    // Extern sync: false
    // Optional: false
    firstInstance: u32 = 0,
};
// Extension: VK_COMPUTE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDispatchIndirectCommand = extern struct {
    // Extern sync: false
    // Optional: false
    x: u32 = 0,
    // Extern sync: false
    // Optional: false
    y: u32 = 0,
    // Extern sync: false
    // Optional: false
    z: u32 = 0,
};
// Extension: VK_EXT_multi_draw
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkMultiDrawInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    firstVertex: u32 = 0,
    // Extern sync: false
    // Optional: false
    vertexCount: u32 = 0,
};
// Extension: VK_EXT_multi_draw
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkMultiDrawIndexedInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    firstIndex: u32 = 0,
    // Extern sync: false
    // Optional: false
    indexCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    vertexOffset: i32 = 0,
};
// Extension: VK_BASE_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSubmitInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_SUBMIT_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    waitSemaphoreCount: u32 = 0,
    // Length expression: waitSemaphoreCount
    // Extern sync: false
    // Optional: false
    pWaitSemaphores: ?[*]const VkSemaphore = null,
    // Length expression: waitSemaphoreCount
    // Extern sync: false
    // Optional: false
    pWaitDstStageMask: ?[*]const VkPipelineStageFlags = null,
    // Extern sync: false
    // Optional: true
    commandBufferCount: u32 = 0,
    // Length expression: commandBufferCount
    // Extern sync: false
    // Optional: false
    pCommandBuffers: ?[*]const VkCommandBuffer = null,
    // Extern sync: false
    // Optional: true
    signalSemaphoreCount: u32 = 0,
    // Length expression: signalSemaphoreCount
    // Extern sync: false
    // Optional: false
    pSignalSemaphores: ?[*]const VkSemaphore = null,
};
// Extension: VK_KHR_display
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkDisplayPropertiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    // Comment: Handle of the display object
    display: VkDisplayKHR = .none,
    // Length expression: null-terminated
    // Extern sync: false
    // Optional: false
    // Comment: Name of the display
    displayName: ?[*:0]const u8 = null,
    // Extern sync: false
    // Optional: false
    // Comment: In millimeters?
    physicalDimensions: VkExtent2D = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Max resolution for CRT?
    physicalResolution: VkExtent2D = .{},
    // Extern sync: false
    // Optional: true
    // Comment: one or more bits from VkSurfaceTransformFlagsKHR
    supportedTransforms: VkSurfaceTransformFlagsKHR = .{},
    // Extern sync: false
    // Optional: false
    // Comment: VK_TRUE if the overlay plane's z-order can be changed on this display.
    planeReorderPossible: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: VK_TRUE if this is a "smart" display that supports self-refresh/internal buffering.
    persistentContent: u32 = 0,
};
// Extension: VK_KHR_display
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkDisplayPlanePropertiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    // Comment: Display the plane is currently associated with.  Will be VK_NULL_HANDLE if the plane is not in use.
    currentDisplay: VkDisplayKHR = .none,
    // Extern sync: false
    // Optional: false
    // Comment: Current z-order of the plane.
    currentStackIndex: u32 = 0,
};
// Extension: VK_KHR_display
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDisplayModeParametersKHR = extern struct {
    // Extern sync: false
    // Optional: false
    // Comment: Visible scanout region.
    visibleRegion: VkExtent2D = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Number of times per second the display is updated.
    refreshRate: u32 = 0,
};
// Extension: VK_KHR_display
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkDisplayModePropertiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    // Comment: Handle of this display mode.
    displayMode: VkDisplayModeKHR = .none,
    // Extern sync: false
    // Optional: false
    // Comment: The parameters this mode uses.
    parameters: VkDisplayModeParametersKHR = .{},
};
// Extension: VK_KHR_display
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDisplayModeCreateInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkDisplayModeCreateFlagsKHR = .{},
    // Extern sync: false
    // Optional: false
    // Comment: The parameters this mode uses.
    parameters: VkDisplayModeParametersKHR = .{},
};
// Extension: VK_KHR_display
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkDisplayPlaneCapabilitiesKHR = extern struct {
    // Extern sync: false
    // Optional: true
    // Comment: Types of alpha blending supported, if any.
    supportedAlpha: VkDisplayPlaneAlphaFlagsKHR = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Does the plane have any position and extent restrictions?
    minSrcPosition: VkOffset2D = .{},
    // Extern sync: false
    // Optional: false
    maxSrcPosition: VkOffset2D = .{},
    // Extern sync: false
    // Optional: false
    minSrcExtent: VkExtent2D = .{},
    // Extern sync: false
    // Optional: false
    maxSrcExtent: VkExtent2D = .{},
    // Extern sync: false
    // Optional: false
    minDstPosition: VkOffset2D = .{},
    // Extern sync: false
    // Optional: false
    maxDstPosition: VkOffset2D = .{},
    // Extern sync: false
    // Optional: false
    minDstExtent: VkExtent2D = .{},
    // Extern sync: false
    // Optional: false
    maxDstExtent: VkExtent2D = .{},
};
// Extension: VK_KHR_display
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDisplaySurfaceCreateInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkDisplaySurfaceCreateFlagsKHR = .{},
    // Extern sync: false
    // Optional: false
    // Comment: The mode to use when displaying this surface
    displayMode: VkDisplayModeKHR = .none,
    // Extern sync: false
    // Optional: false
    // Comment: The plane on which this surface appears.  Must be between 0 and the value returned by vkGetPhysicalDeviceDisplayPlanePropertiesKHR() in pPropertyCount.
    planeIndex: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: The z-order of the plane.
    planeStackIndex: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Transform to apply to the images as part of the scanout operation
    transform: VkSurfaceTransformFlagsKHR = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Global alpha value.  Must be between 0 and 1, inclusive.  Ignored if alphaMode is not VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR
    globalAlpha: f32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: The type of alpha blending to use. Must be one of the bits from VkDisplayPlaneCapabilitiesKHR::supportedAlpha for this display plane
    alphaMode: VkDisplayPlaneAlphaFlagsKHR = .{},
    // Extern sync: false
    // Optional: false
    // Comment: size of the images to use with this surface
    imageExtent: VkExtent2D = .{},
};
// Extension: VK_NV_display_stereo
// Extends: VkDisplaySurfaceCreateInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDisplaySurfaceStereoCreateInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_DISPLAY_SURFACE_STEREO_CREATE_INFO_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: The 3D stereo type to use when presenting this surface.
    stereoType: VkDisplaySurfaceStereoTypeNV = .VK_DISPLAY_SURFACE_STEREO_TYPE_NONE_NV,
};
// Extension: VK_KHR_display_swapchain
// Extends: VkPresentInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDisplayPresentInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: Rectangle within the presentable image to read pixel data from when presenting to the display.
    srcRect: VkRect2D = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Rectangle within the current display mode's visible region to display srcRectangle in.
    dstRect: VkRect2D = .{},
    // Extern sync: false
    // Optional: false
    // Comment: For smart displays, use buffered mode.  If the display properties member "persistentMode" is VK_FALSE, this member must always be VK_FALSE.
    persistent: u32 = 0,
};
// Extension: VK_KHR_surface
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkSurfaceCapabilitiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    // Comment: Supported minimum number of images for the surface
    minImageCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Supported maximum number of images for the surface, 0 for unlimited
    maxImageCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Current image width and height for the surface, (0, 0) if undefined
    currentExtent: VkExtent2D = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Supported minimum image width and height for the surface
    minImageExtent: VkExtent2D = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Supported maximum image width and height for the surface
    maxImageExtent: VkExtent2D = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Supported maximum number of image layers for the surface
    maxImageArrayLayers: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: 1 or more bits representing the transforms supported
    supportedTransforms: VkSurfaceTransformFlagsKHR = .{},
    // Extern sync: false
    // Optional: false
    // Comment: The surface's current transform relative to the device's natural orientation
    currentTransform: VkSurfaceTransformFlagsKHR = .{},
    // Extern sync: false
    // Optional: false
    // Comment: 1 or more bits representing the alpha compositing modes supported
    supportedCompositeAlpha: VkCompositeAlphaFlagsKHR = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Supported image usage flags for the surface
    supportedUsageFlags: VkImageUsageFlags = .{},
};
// Extension: VK_KHR_android_surface
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkAndroidSurfaceCreateInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkAndroidSurfaceCreateFlagsKHR = .{},
    // Extern sync: false
    // Optional: false
    window: ?*ANativeWindow = null,
};
// Extension: VK_NN_vi_surface
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkViSurfaceCreateInfoNN = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkViSurfaceCreateFlagsNN = .{},
    // Extern sync: false
    // Optional: false
    window: ?*anyopaque = null,
};
// Extension: VK_KHR_wayland_surface
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkWaylandSurfaceCreateInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkWaylandSurfaceCreateFlagsKHR = .{},
    // Extern sync: false
    // Optional: false
    display: ?*wl_display = null,
    // Extern sync: false
    // Optional: false
    surface: ?*wl_surface = null,
};
// Extension: VK_KHR_win32_surface
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkWin32SurfaceCreateInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkWin32SurfaceCreateFlagsKHR = .{},
    // Extern sync: false
    // Optional: false
    // Extern sync: false
    // Optional: false
};
// Extension: VK_KHR_xlib_surface
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkXlibSurfaceCreateInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkXlibSurfaceCreateFlagsKHR = .{},
    // Extern sync: false
    // Optional: false
    dpy: ?*Display = null,
    // Extern sync: false
    // Optional: false
};
// Extension: VK_KHR_xcb_surface
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkXcbSurfaceCreateInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkXcbSurfaceCreateFlagsKHR = .{},
    // Extern sync: false
    // Optional: false
    connection: ?*xcb_connection_t = null,
    // Extern sync: false
    // Optional: false
};
// Extension: VK_EXT_directfb_surface
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDirectFBSurfaceCreateInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_DIRECTFB_SURFACE_CREATE_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkDirectFBSurfaceCreateFlagsEXT = .{},
    // Extern sync: false
    // Optional: false
    dfb: ?*IDirectFB = null,
    // Extern sync: false
    // Optional: false
    surface: ?*IDirectFBSurface = null,
};
// Extension: VK_FUCHSIA_imagepipe_surface
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImagePipeSurfaceCreateInfoFUCHSIA = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkImagePipeSurfaceCreateFlagsFUCHSIA = .{},
    // Extern sync: false
    // Optional: false
};
// Extension: VK_GGP_stream_descriptor_surface
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkStreamDescriptorSurfaceCreateInfoGGP = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_STREAM_DESCRIPTOR_SURFACE_CREATE_INFO_GGP;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkStreamDescriptorSurfaceCreateFlagsGGP = .{},
    // Extern sync: false
    // Optional: false
};
// Extension: VK_QNX_screen_surface
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkScreenSurfaceCreateInfoQNX = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_SCREEN_SURFACE_CREATE_INFO_QNX;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkScreenSurfaceCreateFlagsQNX = .{},
    // Extern sync: false
    // Optional: false
    context: ?*_screen_context = null,
    // Extern sync: false
    // Optional: false
    window: ?*_screen_window = null,
};
// Extension: VK_KHR_surface
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkSurfaceFormatKHR = extern struct {
    // Extern sync: false
    // Optional: false
    // Comment: Supported pair of rendering format
    format: VkFormat = .VK_FORMAT_UNDEFINED,
    // Extern sync: false
    // Optional: false
    // Comment: and color space for the surface
    colorSpace: VkColorSpaceKHR = .VK_COLOR_SPACE_SRGB_NONLINEAR_KHR,
};
// Extension: VK_KHR_swapchain
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSwapchainCreateInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkSwapchainCreateFlagsKHR = .{},
    // Extern sync: true
    // Optional: false
    // Comment: The swapchain's target surface
    surface: VkSurfaceKHR = .none,
    // Extern sync: false
    // Optional: false
    // Comment: Minimum number of presentation images the application needs
    minImageCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Format of the presentation images
    imageFormat: VkFormat = .VK_FORMAT_UNDEFINED,
    // Extern sync: false
    // Optional: false
    // Comment: Colorspace of the presentation images
    imageColorSpace: VkColorSpaceKHR = .VK_COLOR_SPACE_SRGB_NONLINEAR_KHR,
    // Extern sync: false
    // Optional: false
    // Comment: Dimensions of the presentation images
    imageExtent: VkExtent2D = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Determines the number of views for multiview/stereo presentation
    imageArrayLayers: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Bits indicating how the presentation images will be used
    imageUsage: VkImageUsageFlags = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Sharing mode used for the presentation images
    imageSharingMode: VkSharingMode = .VK_SHARING_MODE_EXCLUSIVE,
    // Extern sync: false
    // Optional: true
    // Comment: Number of queue families having access to the images in case of concurrent sharing mode
    queueFamilyIndexCount: u32 = 0,
    // Length expression: queueFamilyIndexCount
    // Extern sync: false
    // Optional: false
    // Comment: Array of queue family indices having access to the images in case of concurrent sharing mode
    pQueueFamilyIndices: ?[*]const u32 = null,
    // Extern sync: false
    // Optional: false
    // Comment: The transform, relative to the device's natural orientation, applied to the image content prior to presentation
    preTransform: VkSurfaceTransformFlagsKHR = .{},
    // Extern sync: false
    // Optional: false
    // Comment: The alpha blending mode used when compositing this surface with other surfaces in the window system
    compositeAlpha: VkCompositeAlphaFlagsKHR = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Which presentation mode to use for presents on this swap chain
    presentMode: VkPresentModeKHR = .VK_PRESENT_MODE_IMMEDIATE_KHR,
    // Extern sync: false
    // Optional: false
    // Comment: Specifies whether presentable images may be affected by window clip regions
    clipped: u32 = 0,
    // Extern sync: true
    // Optional: true
    // Comment: Existing swap chain to replace, if any
    oldSwapchain: VkSwapchainKHR = .none,
};
// Extension: VK_KHR_swapchain
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPresentInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PRESENT_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    // Comment: Number of semaphores to wait for before presenting
    waitSemaphoreCount: u32 = 0,
    // Length expression: waitSemaphoreCount
    // Extern sync: true
    // Optional: false
    // Comment: Semaphores to wait for before presenting
    pWaitSemaphores: ?[*]const VkSemaphore = null,
    // Extern sync: false
    // Optional: false
    // Comment: Number of swapchains to present in this call
    swapchainCount: u32 = 0,
    // Length expression: swapchainCount
    // Extern sync: true
    // Optional: false
    // Comment: Swapchains to present an image from
    pSwapchains: ?[*]const VkSwapchainKHR = null,
    // Length expression: swapchainCount
    // Extern sync: false
    // Optional: false
    // Comment: Indices of which presentable images to present
    pImageIndices: ?[*]const u32 = null,
    // Length expression: swapchainCount
    // Extern sync: false
    // Optional: true
    // Comment: Optional (i.e. if non-NULL) VkResult for each swapchain
    pResults: ?[*]VkResult = null,
};
// Extension: VK_EXT_debug_report
// Extends: VkInstanceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDebugReportCallbackCreateInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    // Comment: Indicates which events call this callback
    flags: VkDebugReportFlagsEXT = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Function pointer of a callback function
    pfnCallback: ?*const vkDebugReportCallbackEXT = null,
    // Extern sync: false
    // Optional: true
    // Comment: Data provided to callback function
    pUserData: ?*anyopaque = null,
};
// Extension: VK_EXT_validation_flags
// Extends: VkInstanceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkValidationFlagsEXT = extern struct {
    // Extern sync: false
    // Optional: false
    // Comment: Must be VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: Number of validation checks to disable
    disabledValidationCheckCount: u32 = 0,
    // Length expression: disabledValidationCheckCount
    // Extern sync: false
    // Optional: false
    // Comment: Validation checks to disable
    pDisabledValidationChecks: ?[*]const VkValidationCheckEXT = null,
};
// Extension: VK_EXT_validation_features
// Extends: VkInstanceCreateInfo,VkShaderModuleCreateInfo,VkShaderCreateInfoEXT
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkValidationFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    // Comment: Must be VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    // Comment: Number of validation features to enable
    enabledValidationFeatureCount: u32 = 0,
    // Length expression: enabledValidationFeatureCount
    // Extern sync: false
    // Optional: false
    // Comment: Validation features to enable
    pEnabledValidationFeatures: ?[*]const VkValidationFeatureEnableEXT = null,
    // Extern sync: false
    // Optional: true
    // Comment: Number of validation features to disable
    disabledValidationFeatureCount: u32 = 0,
    // Length expression: disabledValidationFeatureCount
    // Extern sync: false
    // Optional: false
    // Comment: Validation features to disable
    pDisabledValidationFeatures: ?[*]const VkValidationFeatureDisableEXT = null,
};
// Extension: VK_EXT_layer_settings
// Extends: VkInstanceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: true
pub const VkLayerSettingsCreateInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    // Comment: Must be VK_STRUCTURE_TYPE_LAYER_SETTINGS_CREATE_INFO_EXT
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_LAYER_SETTINGS_CREATE_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    // Comment: Number of settings to configure
    settingCount: u32 = 0,
    // Length expression: settingCount
    // Extern sync: false
    // Optional: false
    // Comment: Validation features to enable
    pSettings: ?[*]const VkLayerSettingEXT = null,
};
// Extension: VK_EXT_layer_settings
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkLayerSettingEXT = extern struct {
    // Length expression: null-terminated
    // Extern sync: false
    // Optional: false
    pLayerName: ?[*:0]const u8 = null,
    // Length expression: null-terminated
    // Extern sync: false
    // Optional: false
    pSettingName: ?[*:0]const u8 = null,
    // Extern sync: false
    // Optional: false
    // Comment: The type of the object
    type: VkLayerSettingTypeEXT = .VK_LAYER_SETTING_TYPE_BOOL32_EXT,
    // Extern sync: false
    // Optional: true
    // Comment: Number of values of the setting
    valueCount: u32 = 0,
    // Length expression: valueCount
    // Extern sync: false
    // Optional: false
    // Comment: Values to pass for a setting
    pValues: ?*const anyopaque = null,
};
// Extension: VK_EXT_application_parameters
// Extends: VkApplicationInfo,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: true
pub const VkApplicationParametersEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_APPLICATION_PARAMETERS_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    vendorID: u32 = 0,
    // Extern sync: false
    // Optional: true
    deviceID: u32 = 0,
    // Extern sync: false
    // Optional: false
    key: u32 = 0,
    // Extern sync: false
    // Optional: false
    value: u64 = 0,
};
// Extension: VK_AMD_rasterization_order
// Extends: VkPipelineRasterizationStateCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineRasterizationStateRasterizationOrderAMD = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: Rasterization order to use for the pipeline
    rasterizationOrder: VkRasterizationOrderAMD = .VK_RASTERIZATION_ORDER_STRICT_AMD,
};
// Extension: VK_EXT_debug_marker
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDebugMarkerObjectNameInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: The type of the object
    objectType: VkDebugReportObjectTypeEXT = .VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT,
    // Extern sync: true
    // Optional: false
    // Object type: objectType (Which object handle is this)
    // Comment: The handle of the object, cast to uint64_t
    object: u64 = 0,
    // Length expression: null-terminated
    // Extern sync: false
    // Optional: false
    // Comment: Name to apply to the object
    pObjectName: ?[*:0]const u8 = null,
};
// Extension: VK_EXT_debug_marker
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDebugMarkerObjectTagInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: The type of the object
    objectType: VkDebugReportObjectTypeEXT = .VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT,
    // Extern sync: true
    // Optional: false
    // Object type: objectType (Which object handle is this)
    // Comment: The handle of the object, cast to uint64_t
    object: u64 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: The name of the tag to set on the object
    tagName: u64 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: The length in bytes of the tag data
    tagSize: u64 = 0,
    // Length expression: tagSize
    // Extern sync: false
    // Optional: false
    // Comment: Tag data to attach to the object
    pTag: ?*const anyopaque = null,
};
// Extension: VK_EXT_debug_marker
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDebugMarkerMarkerInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Length expression: null-terminated
    // Extern sync: false
    // Optional: false
    // Comment: Name of the debug marker
    pMarkerName: ?[*:0]const u8 = null,
    // Extern sync: false
    // Optional: false
    // Comment: Optional color for debug marker
    color: [4]f32 = @import("std").mem.zeroes([4]f32),
};
// Extension: VK_NV_dedicated_allocation
// Extends: VkImageCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDedicatedAllocationImageCreateInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: Whether this image uses a dedicated allocation
    dedicatedAllocation: u32 = 0,
};
// Extension: VK_NV_dedicated_allocation
// Extends: VkBufferCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDedicatedAllocationBufferCreateInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: Whether this buffer uses a dedicated allocation
    dedicatedAllocation: u32 = 0,
};
// Extension: VK_NV_dedicated_allocation
// Extends: VkMemoryAllocateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDedicatedAllocationMemoryAllocateInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    // Comment: Image that this allocation will be bound to
    image: VkImage = .none,
    // Extern sync: false
    // Optional: true
    // Comment: Buffer that this allocation will be bound to
    buffer: VkBuffer = .none,
};
// Extension: VK_NV_external_memory_capabilities
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkExternalImageFormatPropertiesNV = extern struct {
    // Extern sync: false
    // Optional: false
    imageFormatProperties: VkImageFormatProperties = .{},
    // Extern sync: false
    // Optional: true
    externalMemoryFeatures: VkExternalMemoryFeatureFlagsNV = .{},
    // Extern sync: false
    // Optional: true
    exportFromImportedHandleTypes: VkExternalMemoryHandleTypeFlagsNV = .{},
    // Extern sync: false
    // Optional: true
    compatibleHandleTypes: VkExternalMemoryHandleTypeFlagsNV = .{},
};
// Extension: VK_NV_external_memory
// Extends: VkImageCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkExternalMemoryImageCreateInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    handleTypes: VkExternalMemoryHandleTypeFlagsNV = .{},
};
// Extension: VK_NV_external_memory
// Extends: VkMemoryAllocateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkExportMemoryAllocateInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    handleTypes: VkExternalMemoryHandleTypeFlagsNV = .{},
};
// Extension: VK_NV_external_memory_win32
// Extends: VkMemoryAllocateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImportMemoryWin32HandleInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    handleType: VkExternalMemoryHandleTypeFlagsNV = .{},
    // Extern sync: false
    // Optional: true
};
// Extension: VK_NV_external_memory_win32
// Extends: VkMemoryAllocateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkExportMemoryWin32HandleInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    pAttributes: ?*const SECURITY_ATTRIBUTES = null,
    // Extern sync: false
    // Optional: true
};
// Extension: VK_NV_external_memory_sci_buf
// Extends: VkMemoryAllocateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkExportMemorySciBufInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_EXPORT_MEMORY_SCI_BUF_INFO_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
};
// Extension: VK_NV_external_memory_sci_buf
// Extends: VkMemoryAllocateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImportMemorySciBufInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_IMPORT_MEMORY_SCI_BUF_INFO_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    handleType: VkExternalMemoryHandleTypeFlags = .{},
    // Extern sync: false
    // Optional: false
};
// Extension: VK_NV_external_memory_sci_buf
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkMemoryGetSciBufInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_MEMORY_GET_SCI_BUF_INFO_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    memory: VkDeviceMemory = .none,
    // Extern sync: false
    // Optional: false
    handleType: VkExternalMemoryHandleTypeFlags = .{},
};
// Extension: VK_NV_external_memory_sci_buf
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkMemorySciBufPropertiesNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_MEMORY_SCI_BUF_PROPERTIES_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    memoryTypeBits: u32 = 0,
};
// Extension: VK_NV_external_memory_sci_buf
// Extension: VK_NV_external_memory_sci_buf
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceExternalMemorySciBufFeaturesNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_SCI_BUF_FEATURES_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    sciBufImport: u32 = 0,
    // Extern sync: false
    // Optional: false
    sciBufExport: u32 = 0,
};
// Extension: VK_NV_win32_keyed_mutex
// Extends: VkSubmitInfo,VkSubmitInfo2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkWin32KeyedMutexAcquireReleaseInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    acquireCount: u32 = 0,
    // Length expression: acquireCount
    // Extern sync: false
    // Optional: false
    pAcquireSyncs: ?[*]const VkDeviceMemory = null,
    // Length expression: acquireCount
    // Extern sync: false
    // Optional: false
    pAcquireKeys: ?[*]const u64 = null,
    // Length expression: acquireCount
    // Extern sync: false
    // Optional: false
    pAcquireTimeoutMilliseconds: ?[*]const u32 = null,
    // Extern sync: false
    // Optional: true
    releaseCount: u32 = 0,
    // Length expression: releaseCount
    // Extern sync: false
    // Optional: false
    pReleaseSyncs: ?[*]const VkDeviceMemory = null,
    // Length expression: releaseCount
    // Extern sync: false
    // Optional: false
    pReleaseKeys: ?[*]const u64 = null,
};
// Extension: VK_NV_device_generated_commands
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Feature link: deviceGeneratedCommandsNV
    deviceGeneratedCommands: u32 = 0,
};
// Extension: VK_NV_device_generated_commands_compute
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_COMPUTE_FEATURES_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    deviceGeneratedCompute: u32 = 0,
    // Extern sync: false
    // Optional: false
    deviceGeneratedComputePipelines: u32 = 0,
    // Extern sync: false
    // Optional: false
    deviceGeneratedComputeCaptureReplay: u32 = 0,
};
// Extension: VK_EXT_private_data
// Extension: VK_BASE_VERSION_1_3
// Extends: VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: true
pub const VkDevicePrivateDataCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    privateDataSlotRequestCount: u32 = 0,
};
// Extension: VK_EXT_private_data
// Extension: VK_BASE_VERSION_1_3
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPrivateDataSlotCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    flags: VkPrivateDataSlotCreateFlags = .{},
};
// Extension: VK_EXT_private_data
// Extension: VK_BASE_VERSION_1_3
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDevicePrivateDataFeatures = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    privateData: u32 = 0,
};
// Extension: VK_NV_device_generated_commands
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    maxGraphicsShaderGroupCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxIndirectSequenceCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxIndirectCommandsTokenCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxIndirectCommandsStreamCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxIndirectCommandsTokenOffset: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxIndirectCommandsStreamStride: u32 = 0,
    // Extern sync: false
    // Optional: false
    minSequencesCountBufferOffsetAlignment: u32 = 0,
    // Extern sync: false
    // Optional: false
    minSequencesIndexBufferOffsetAlignment: u32 = 0,
    // Extern sync: false
    // Optional: false
    minIndirectCommandsBufferOffsetAlignment: u32 = 0,
};
// Extension: VK_NV_cluster_acceleration_structure
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceClusterAccelerationStructureFeaturesNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_ACCELERATION_STRUCTURE_FEATURES_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    clusterAccelerationStructure: u32 = 0,
};
// Extension: VK_NV_cluster_acceleration_structure
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceClusterAccelerationStructurePropertiesNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_ACCELERATION_STRUCTURE_PROPERTIES_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    maxVerticesPerCluster: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxTrianglesPerCluster: u32 = 0,
    // Extern sync: false
    // Optional: false
    clusterScratchByteAlignment: u32 = 0,
    // Extern sync: false
    // Optional: false
    clusterByteAlignment: u32 = 0,
    // Extern sync: false
    // Optional: false
    clusterTemplateByteAlignment: u32 = 0,
    // Extern sync: false
    // Optional: false
    clusterBottomLevelByteAlignment: u32 = 0,
    // Extern sync: false
    // Optional: false
    clusterTemplateBoundsByteAlignment: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxClusterGeometryIndex: u32 = 0,
};
// Extension: VK_NV_cluster_acceleration_structure
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkStridedDeviceAddressNV = extern struct {
    // Extern sync: false
    // Optional: false
    startAddress: u64 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Specified in bytes
    strideInBytes: u64 = 0,
};
// Extension: VK_NV_cluster_acceleration_structure
// Extends: VkRayTracingPipelineCreateInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkRayTracingPipelineClusterAccelerationStructureCreateInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CLUSTER_ACCELERATION_STRUCTURE_CREATE_INFO_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    allowClusterAccelerationStructure: u32 = 0,
};
// Extension: VK_NV_cluster_acceleration_structure
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV = extern struct {
    packed_field0: packed struct(u32) {
        geometryIndex: u24 = 0,
        reserved: u5 = 0,
        geometryFlags: u3 = 0,
    } = .{},
};
// Extension: VK_NV_cluster_acceleration_structure
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkClusterAccelerationStructureMoveObjectsInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    srcAccelerationStructure: u64 = 0,
};
// Extension: VK_NV_cluster_acceleration_structure
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkClusterAccelerationStructureBuildClustersBottomLevelInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    clusterReferencesCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    clusterReferencesStride: u32 = 0,
    // Extern sync: false
    // Optional: false
    clusterReferences: u64 = 0,
};
// Extension: VK_NV_cluster_acceleration_structure
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkClusterAccelerationStructureGetTemplateIndicesInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    clusterTemplateAddress: u64 = 0,
};
// Extension: VK_NV_cluster_acceleration_structure
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkClusterAccelerationStructureBuildTriangleClusterInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    clusterID: u32 = 0,
    // Extern sync: false
    // Optional: true
    clusterFlags: VkClusterAccelerationStructureClusterFlagsNV = .{},
    packed_field0: packed struct(u32) {
        triangleCount: u9 = 0,
        vertexCount: u9 = 0,
        positionTruncateBitCount: u6 = 0,
        indexType: u4 = 0,
        opacityMicromapIndexType: u4 = 0,
    } = .{},
    // Extern sync: false
    // Optional: false
    baseGeometryIndexAndGeometryFlags: VkClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV = .{},
    // Extern sync: false
    // Optional: false
    indexBufferStride: u16 = 0,
    // Extern sync: false
    // Optional: false
    vertexBufferStride: u16 = 0,
    // Extern sync: false
    // Optional: false
    geometryIndexAndFlagsBufferStride: u16 = 0,
    // Extern sync: false
    // Optional: false
    opacityMicromapIndexBufferStride: u16 = 0,
    // Extern sync: false
    // Optional: false
    indexBuffer: u64 = 0,
    // Extern sync: false
    // Optional: false
    vertexBuffer: u64 = 0,
    // Extern sync: false
    // Optional: true
    geometryIndexAndFlagsBuffer: u64 = 0,
    // Extern sync: false
    // Optional: true
    opacityMicromapArray: u64 = 0,
    // Extern sync: false
    // Optional: true
    opacityMicromapIndexBuffer: u64 = 0,
};
// Extension: VK_NV_cluster_acceleration_structure
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkClusterAccelerationStructureBuildTriangleClusterTemplateInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    clusterID: u32 = 0,
    // Extern sync: false
    // Optional: true
    clusterFlags: VkClusterAccelerationStructureClusterFlagsNV = .{},
    packed_field0: packed struct(u32) {
        triangleCount: u9 = 0,
        vertexCount: u9 = 0,
        positionTruncateBitCount: u6 = 0,
        indexType: u4 = 0,
        opacityMicromapIndexType: u4 = 0,
    } = .{},
    // Extern sync: false
    // Optional: false
    baseGeometryIndexAndGeometryFlags: VkClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV = .{},
    // Extern sync: false
    // Optional: false
    indexBufferStride: u16 = 0,
    // Extern sync: false
    // Optional: false
    vertexBufferStride: u16 = 0,
    // Extern sync: false
    // Optional: false
    geometryIndexAndFlagsBufferStride: u16 = 0,
    // Extern sync: false
    // Optional: false
    opacityMicromapIndexBufferStride: u16 = 0,
    // Extern sync: false
    // Optional: false
    indexBuffer: u64 = 0,
    // Extern sync: false
    // Optional: true
    vertexBuffer: u64 = 0,
    // Extern sync: false
    // Optional: true
    geometryIndexAndFlagsBuffer: u64 = 0,
    // Extern sync: false
    // Optional: true
    opacityMicromapArray: u64 = 0,
    // Extern sync: false
    // Optional: true
    opacityMicromapIndexBuffer: u64 = 0,
    // Extern sync: false
    // Optional: true
    instantiationBoundingBoxLimit: u64 = 0,
};
// Extension: VK_NV_cluster_acceleration_structure
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkClusterAccelerationStructureInstantiateClusterInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    clusterIdOffset: u32 = 0,
    packed_field0: packed struct(u32) {
        geometryIndexOffset: u24 = 0,
        reserved: u8 = 0,
    } = .{},
    // Extern sync: false
    // Optional: false
    clusterTemplateAddress: u64 = 0,
    // Extern sync: false
    // Optional: false
    vertexBuffer: VkStridedDeviceAddressNV = .{},
};
// Extension: VK_NV_cluster_acceleration_structure
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkClusterAccelerationStructureClustersBottomLevelInputNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_CLUSTERS_BOTTOM_LEVEL_INPUT_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    maxTotalClusterCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxClusterCountPerAccelerationStructure: u32 = 0,
};
// Extension: VK_NV_cluster_acceleration_structure
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkClusterAccelerationStructureTriangleClusterInputNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_TRIANGLE_CLUSTER_INPUT_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    vertexFormat: VkFormat = .VK_FORMAT_UNDEFINED,
    // Extern sync: false
    // Optional: false
    maxGeometryIndexValue: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxClusterUniqueGeometryCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxClusterTriangleCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxClusterVertexCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxTotalTriangleCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxTotalVertexCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    minPositionTruncateBitCount: u32 = 0,
};
// Extension: VK_NV_cluster_acceleration_structure
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkClusterAccelerationStructureMoveObjectsInputNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_MOVE_OBJECTS_INPUT_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    type: VkClusterAccelerationStructureTypeNV = .VK_CLUSTER_ACCELERATION_STRUCTURE_TYPE_CLUSTERS_BOTTOM_LEVEL_NV,
    // Extern sync: false
    // Optional: false
    noMoveOverlap: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxMovedBytes: u64 = 0,
};
// Extension: VK_NV_cluster_acceleration_structure
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkClusterAccelerationStructureInputInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_INPUT_INFO_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    maxAccelerationStructureCount: u32 = 0,
    // Extern sync: false
    // Optional: true
    flags: VkBuildAccelerationStructureFlagsKHR = .{},
    // Extern sync: false
    // Optional: false
    opType: VkClusterAccelerationStructureOpTypeNV = .VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_MOVE_OBJECTS_NV,
    // Extern sync: false
    // Optional: false
    opMode: VkClusterAccelerationStructureOpModeNV = .VK_CLUSTER_ACCELERATION_STRUCTURE_OP_MODE_IMPLICIT_DESTINATIONS_NV,
    // Extern sync: false
    // Optional: false
    // Selector field: opType (What union field is valid)
    opInput: VkClusterAccelerationStructureOpInputNV,
};
// Extension: VK_NV_cluster_acceleration_structure
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkClusterAccelerationStructureCommandsInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_COMMANDS_INFO_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    input: VkClusterAccelerationStructureInputInfoNV,
    // Extern sync: false
    // Optional: true
    dstImplicitData: u64 = 0,
    // Extern sync: false
    // Optional: false
    scratchData: u64 = 0,
    // Extern sync: false
    // Optional: false
    dstAddressesArray: VkStridedDeviceAddressRegionKHR = .{},
    // Extern sync: false
    // Optional: false
    dstSizesArray: VkStridedDeviceAddressRegionKHR = .{},
    // Extern sync: false
    // Optional: false
    srcInfosArray: VkStridedDeviceAddressRegionKHR = .{},
    // Extern sync: false
    // Optional: true
    srcInfosCount: u64 = 0,
    // Extern sync: false
    // Optional: true
    addressResolutionFlags: VkClusterAccelerationStructureAddressResolutionFlagsNV = .{},
};
// Extension: VK_EXT_multi_draw
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceMultiDrawPropertiesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    maxMultiDrawCount: u32 = 0,
};
// Extension: VK_NV_device_generated_commands
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkGraphicsShaderGroupCreateInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_GRAPHICS_SHADER_GROUP_CREATE_INFO_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    stageCount: u32 = 0,
    // Length expression: stageCount
    // Extern sync: false
    // Optional: false
    pStages: ?[*]const VkPipelineShaderStageCreateInfo = null,
    // Extern sync: false
    // Optional: true
    pVertexInputState: ?*const VkPipelineVertexInputStateCreateInfo = null,
    // Extern sync: false
    // Optional: true
    pTessellationState: ?*const VkPipelineTessellationStateCreateInfo = null,
};
// Extension: VK_NV_device_generated_commands
// Extends: VkGraphicsPipelineCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkGraphicsPipelineShaderGroupsCreateInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    groupCount: u32 = 0,
    // Length expression: groupCount
    // Extern sync: false
    // Optional: false
    pGroups: ?[*]const VkGraphicsShaderGroupCreateInfoNV = null,
    // Extern sync: false
    // Optional: true
    pipelineCount: u32 = 0,
    // Length expression: pipelineCount
    // Extern sync: false
    // Optional: false
    pPipelines: ?[*]const VkPipeline = null,
};
// Extension: VK_NV_device_generated_commands
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkBindShaderGroupIndirectCommandNV = extern struct {
    // Extern sync: false
    // Optional: false
    groupIndex: u32 = 0,
};
// Extension: VK_NV_device_generated_commands
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkBindIndexBufferIndirectCommandNV = extern struct {
    // Extern sync: false
    // Optional: false
    bufferAddress: u64 = 0,
    // Extern sync: false
    // Optional: false
    size: u32 = 0,
    // Extern sync: false
    // Optional: false
    indexType: VkIndexType = .VK_INDEX_TYPE_UINT16,
};
// Extension: VK_NV_device_generated_commands
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkBindVertexBufferIndirectCommandNV = extern struct {
    // Extern sync: false
    // Optional: false
    bufferAddress: u64 = 0,
    // Extern sync: false
    // Optional: false
    size: u32 = 0,
    // Extern sync: false
    // Optional: false
    stride: u32 = 0,
};
// Extension: VK_NV_device_generated_commands
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSetStateFlagsIndirectCommandNV = extern struct {
    // Extern sync: false
    // Optional: false
    data: u32 = 0,
};
// Extension: VK_NV_device_generated_commands
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkIndirectCommandsStreamNV = extern struct {
    // Extern sync: false
    // Optional: false
    buffer: VkBuffer = .none,
    // Extern sync: false
    // Optional: false
    offset: u64 = 0,
};
// Extension: VK_NV_device_generated_commands
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkIndirectCommandsLayoutTokenNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    tokenType: VkIndirectCommandsTokenTypeNV = .VK_INDIRECT_COMMANDS_TOKEN_TYPE_SHADER_GROUP_NV,
    // Extern sync: false
    // Optional: false
    stream: u32 = 0,
    // Extern sync: false
    // Optional: false
    offset: u32 = 0,
    // Extern sync: false
    // Optional: false
    vertexBindingUnit: u32 = 0,
    // Extern sync: false
    // Optional: false
    vertexDynamicStride: u32 = 0,
    // Extern sync: false
    // Optional: true
    pushconstantPipelineLayout: VkPipelineLayout = .none,
    // Extern sync: false
    // Optional: true
    pushconstantShaderStageFlags: VkShaderStageFlags = .{},
    // Extern sync: false
    // Optional: false
    pushconstantOffset: u32 = 0,
    // Extern sync: false
    // Optional: false
    pushconstantSize: u32 = 0,
    // Extern sync: false
    // Optional: true
    indirectStateFlags: VkIndirectStateFlagsNV = .{},
    // Extern sync: false
    // Optional: true
    indexTypeCount: u32 = 0,
    // Length expression: indexTypeCount
    // Extern sync: false
    // Optional: false
    pIndexTypes: ?[*]const VkIndexType = null,
    // Length expression: indexTypeCount
    // Extern sync: false
    // Optional: false
    pIndexTypeValues: ?[*]const u32 = null,
};
// Extension: VK_NV_device_generated_commands
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkIndirectCommandsLayoutCreateInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkIndirectCommandsLayoutUsageFlagsNV = .{},
    // Extern sync: false
    // Optional: false
    pipelineBindPoint: VkPipelineBindPoint = .VK_PIPELINE_BIND_POINT_GRAPHICS,
    // Extern sync: false
    // Optional: false
    tokenCount: u32 = 0,
    // Length expression: tokenCount
    // Extern sync: false
    // Optional: false
    pTokens: ?[*]const VkIndirectCommandsLayoutTokenNV = null,
    // Extern sync: false
    // Optional: false
    streamCount: u32 = 0,
    // Length expression: streamCount
    // Extern sync: false
    // Optional: false
    pStreamStrides: ?[*]const u32 = null,
};
// Extension: VK_NV_device_generated_commands
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkGeneratedCommandsInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    pipelineBindPoint: VkPipelineBindPoint = .VK_PIPELINE_BIND_POINT_GRAPHICS,
    // Extern sync: false
    // Optional: true
    pipeline: VkPipeline = .none,
    // Extern sync: false
    // Optional: false
    indirectCommandsLayout: VkIndirectCommandsLayoutNV = .none,
    // Extern sync: false
    // Optional: false
    streamCount: u32 = 0,
    // Length expression: streamCount
    // Extern sync: false
    // Optional: false
    pStreams: ?[*]const VkIndirectCommandsStreamNV = null,
    // Extern sync: false
    // Optional: false
    sequencesCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    preprocessBuffer: VkBuffer = .none,
    // Extern sync: false
    // Optional: false
    preprocessOffset: u64 = 0,
    // Extern sync: false
    // Optional: false
    preprocessSize: u64 = 0,
    // Extern sync: false
    // Optional: true
    sequencesCountBuffer: VkBuffer = .none,
    // Extern sync: false
    // Optional: false
    sequencesCountOffset: u64 = 0,
    // Extern sync: false
    // Optional: true
    sequencesIndexBuffer: VkBuffer = .none,
    // Extern sync: false
    // Optional: false
    sequencesIndexOffset: u64 = 0,
};
// Extension: VK_NV_device_generated_commands
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkGeneratedCommandsMemoryRequirementsInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    pipelineBindPoint: VkPipelineBindPoint = .VK_PIPELINE_BIND_POINT_GRAPHICS,
    // Extern sync: false
    // Optional: true
    pipeline: VkPipeline = .none,
    // Extern sync: false
    // Optional: false
    indirectCommandsLayout: VkIndirectCommandsLayoutNV = .none,
    // Extern sync: false
    // Optional: false
    maxSequencesCount: u32 = 0,
};
// Extension: VK_NV_device_generated_commands_compute
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineIndirectDeviceAddressInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_INDIRECT_DEVICE_ADDRESS_INFO_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    pipelineBindPoint: VkPipelineBindPoint = .VK_PIPELINE_BIND_POINT_GRAPHICS,
    // Extern sync: false
    // Optional: false
    pipeline: VkPipeline = .none,
};
// Extension: VK_NV_device_generated_commands_compute
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkBindPipelineIndirectCommandNV = extern struct {
    // Extern sync: false
    // Optional: false
    pipelineAddress: u64 = 0,
};
// Extension: VK_KHR_get_physical_device_properties2
// Extension: VK_BASE_VERSION_1_1
// Extends: VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceFeatures2 = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    features: VkPhysicalDeviceFeatures = .{},
};
// Extension: VK_KHR_get_physical_device_properties2
// Extension: VK_BASE_VERSION_1_1
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceProperties2 = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    properties: VkPhysicalDeviceProperties = .{},
};
// Extension: VK_KHR_get_physical_device_properties2
// Extension: VK_BASE_VERSION_1_1
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkFormatProperties2 = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    formatProperties: VkFormatProperties = .{},
};
// Extension: VK_KHR_get_physical_device_properties2
// Extension: VK_BASE_VERSION_1_1
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkImageFormatProperties2 = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    imageFormatProperties: VkImageFormatProperties = .{},
};
// Extension: VK_KHR_get_physical_device_properties2
// Extension: VK_BASE_VERSION_1_1
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceImageFormatInfo2 = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    format: VkFormat = .VK_FORMAT_UNDEFINED,
    // Extern sync: false
    // Optional: false
    type: VkImageType = .VK_IMAGE_TYPE_1D,
    // Extern sync: false
    // Optional: false
    tiling: VkImageTiling = .VK_IMAGE_TILING_OPTIMAL,
    // Extern sync: false
    // Optional: false
    usage: VkImageUsageFlags = .{},
    // Extern sync: false
    // Optional: true
    flags: VkImageCreateFlags = .{},
};
// Extension: VK_KHR_get_physical_device_properties2
// Extension: VK_BASE_VERSION_1_1
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkQueueFamilyProperties2 = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    queueFamilyProperties: VkQueueFamilyProperties = .{},
};
// Extension: VK_KHR_get_physical_device_properties2
// Extension: VK_BASE_VERSION_1_1
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceMemoryProperties2 = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    memoryProperties: VkPhysicalDeviceMemoryProperties = .{},
};
// Extension: VK_KHR_get_physical_device_properties2
// Extension: VK_BASE_VERSION_1_1
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkSparseImageFormatProperties2 = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    properties: VkSparseImageFormatProperties = .{},
};
// Extension: VK_KHR_get_physical_device_properties2
// Extension: VK_BASE_VERSION_1_1
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceSparseImageFormatInfo2 = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    format: VkFormat = .VK_FORMAT_UNDEFINED,
    // Extern sync: false
    // Optional: false
    type: VkImageType = .VK_IMAGE_TYPE_1D,
    // Extern sync: false
    // Optional: false
    samples: VkSampleCountFlags = .{},
    // Extern sync: false
    // Optional: false
    usage: VkImageUsageFlags = .{},
    // Extern sync: false
    // Optional: false
    tiling: VkImageTiling = .VK_IMAGE_TILING_OPTIMAL,
};
// Extension: VK_KHR_push_descriptor
// Extension: VK_COMPUTE_VERSION_1_4
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDevicePushDescriptorProperties = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    maxPushDescriptors: u32 = 0,
};
// Extension: VK_KHR_driver_properties
// Extension: VK_BASE_VERSION_1_2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkConformanceVersion = extern struct {
    // Extern sync: false
    // Optional: false
    major: u8 = 0,
    // Extern sync: false
    // Optional: false
    minor: u8 = 0,
    // Extern sync: false
    // Optional: false
    subminor: u8 = 0,
    // Extern sync: false
    // Optional: false
    patch: u8 = 0,
};
// Extension: VK_KHR_driver_properties
// Extension: VK_BASE_VERSION_1_2
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceDriverProperties = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    driverID: VkDriverId = .VK_DRIVER_ID_AMD_PROPRIETARY,
    // Length expression: null-terminated
    // Extern sync: false
    // Optional: false
    driverName: [VK_MAX_DRIVER_NAME_SIZE]u8 = @import("std").mem.zeroes([VK_MAX_DRIVER_NAME_SIZE]u8),
    // Length expression: null-terminated
    // Extern sync: false
    // Optional: false
    driverInfo: [VK_MAX_DRIVER_INFO_SIZE]u8 = @import("std").mem.zeroes([VK_MAX_DRIVER_INFO_SIZE]u8),
    // Extern sync: false
    // Optional: false
    conformanceVersion: VkConformanceVersion = .{},
};
// Extension: VK_KHR_incremental_present
// Extends: VkPresentInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPresentRegionsKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: Copy of VkPresentInfoKHR::swapchainCount
    swapchainCount: u32 = 0,
    // Length expression: swapchainCount
    // Extern sync: false
    // Optional: true
    // Comment: The regions that have changed
    pRegions: ?[*]const VkPresentRegionKHR = null,
};
// Extension: VK_KHR_incremental_present
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPresentRegionKHR = extern struct {
    // Extern sync: false
    // Optional: true
    // Comment: Number of rectangles in pRectangles
    rectangleCount: u32 = 0,
    // Length expression: rectangleCount
    // Extern sync: false
    // Optional: true
    // Comment: Array of rectangles that have changed in a swapchain's image(s)
    pRectangles: ?[*]const VkRectLayerKHR = null,
};
// Extension: VK_KHR_incremental_present
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkRectLayerKHR = extern struct {
    // Extern sync: false
    // Optional: false
    // Comment: upper-left corner of a rectangle that has not changed, in pixels of a presentation images
    offset: VkOffset2D = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Dimensions of a rectangle that has not changed, in pixels of a presentation images
    extent: VkExtent2D = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Layer of a swapchain's image(s), for stereoscopic-3D images
    layer: u32 = 0,
};
// Extension: VK_KHR_variable_pointers
// Extension: VK_KHR_variable_pointers
// Extension: VK_COMPUTE_VERSION_1_1
// Extension: VK_COMPUTE_VERSION_1_1
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceVariablePointersFeatures = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    variablePointersStorageBuffer: u32 = 0,
    // Extern sync: false
    // Optional: false
    variablePointers: u32 = 0,
};
// Extension: VK_KHR_external_memory_capabilities
// Extension: VK_BASE_VERSION_1_1
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkExternalMemoryProperties = extern struct {
    // Extern sync: false
    // Optional: false
    externalMemoryFeatures: VkExternalMemoryFeatureFlags = .{},
    // Extern sync: false
    // Optional: true
    exportFromImportedHandleTypes: VkExternalMemoryHandleTypeFlags = .{},
    // Extern sync: false
    // Optional: false
    compatibleHandleTypes: VkExternalMemoryHandleTypeFlags = .{},
};
// Extension: VK_KHR_external_memory_capabilities
// Extension: VK_BASE_VERSION_1_1
// Extends: VkPhysicalDeviceImageFormatInfo2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceExternalImageFormatInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    handleType: VkExternalMemoryHandleTypeFlags = .{},
};
// Extension: VK_KHR_external_memory_capabilities
// Extension: VK_BASE_VERSION_1_1
// Extends: VkImageFormatProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkExternalImageFormatProperties = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    externalMemoryProperties: VkExternalMemoryProperties = .{},
};
// Extension: VK_KHR_external_memory_capabilities
// Extension: VK_BASE_VERSION_1_1
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceExternalBufferInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkBufferCreateFlags = .{},
    // Extern sync: false
    // Optional: true
    usage: VkBufferUsageFlags = .{},
    // Extern sync: false
    // Optional: false
    handleType: VkExternalMemoryHandleTypeFlags = .{},
};
// Extension: VK_KHR_external_memory_capabilities
// Extension: VK_BASE_VERSION_1_1
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkExternalBufferProperties = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    externalMemoryProperties: VkExternalMemoryProperties = .{},
};
// Extension: VK_KHR_external_memory_capabilities
// Extension: VK_BASE_VERSION_1_1
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceIDProperties = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    deviceUUID: [VK_UUID_SIZE]u8 = @import("std").mem.zeroes([VK_UUID_SIZE]u8),
    // Extern sync: false
    // Optional: false
    driverUUID: [VK_UUID_SIZE]u8 = @import("std").mem.zeroes([VK_UUID_SIZE]u8),
    // Extern sync: false
    // Optional: false
    deviceLUID: [VK_LUID_SIZE]u8 = @import("std").mem.zeroes([VK_LUID_SIZE]u8),
    // Extern sync: false
    // Optional: false
    deviceNodeMask: u32 = 0,
    // Extern sync: false
    // Optional: false
    deviceLUIDValid: u32 = 0,
};
// Extension: VK_KHR_external_memory
// Extension: VK_BASE_VERSION_1_1
// Extends: VkImageCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkExternalMemoryImageCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    handleTypes: VkExternalMemoryHandleTypeFlags = .{},
};
// Extension: VK_KHR_external_memory
// Extension: VK_BASE_VERSION_1_1
// Extends: VkBufferCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkExternalMemoryBufferCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    handleTypes: VkExternalMemoryHandleTypeFlags = .{},
};
// Extension: VK_KHR_external_memory
// Extension: VK_BASE_VERSION_1_1
// Extends: VkMemoryAllocateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkExportMemoryAllocateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    handleTypes: VkExternalMemoryHandleTypeFlags = .{},
};
// Extension: VK_KHR_external_memory_win32
// Extends: VkMemoryAllocateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImportMemoryWin32HandleInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    handleType: VkExternalMemoryHandleTypeFlags = .{},
    // Extern sync: false
    // Optional: true
    // Extern sync: false
    // Optional: true
};
// Extension: VK_KHR_external_memory_win32
// Extends: VkMemoryAllocateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkExportMemoryWin32HandleInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    pAttributes: ?*const SECURITY_ATTRIBUTES = null,
    // Extern sync: false
    // Optional: false
    // Extern sync: false
    // Optional: false
};
// Extension: VK_FUCHSIA_external_memory
// Extends: VkMemoryAllocateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImportMemoryZirconHandleInfoFUCHSIA = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_IMPORT_MEMORY_ZIRCON_HANDLE_INFO_FUCHSIA;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    handleType: VkExternalMemoryHandleTypeFlags = .{},
    // Extern sync: false
    // Optional: true
};
// Extension: VK_FUCHSIA_external_memory
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkMemoryZirconHandlePropertiesFUCHSIA = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_MEMORY_ZIRCON_HANDLE_PROPERTIES_FUCHSIA;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    memoryTypeBits: u32 = 0,
};
// Extension: VK_FUCHSIA_external_memory
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkMemoryGetZirconHandleInfoFUCHSIA = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_MEMORY_GET_ZIRCON_HANDLE_INFO_FUCHSIA;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    memory: VkDeviceMemory = .none,
    // Extern sync: false
    // Optional: false
    handleType: VkExternalMemoryHandleTypeFlags = .{},
};
// Extension: VK_KHR_external_memory_win32
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkMemoryWin32HandlePropertiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    memoryTypeBits: u32 = 0,
};
// Extension: VK_KHR_external_memory_win32
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkMemoryGetWin32HandleInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    memory: VkDeviceMemory = .none,
    // Extern sync: false
    // Optional: false
    handleType: VkExternalMemoryHandleTypeFlags = .{},
};
// Extension: VK_KHR_external_memory_fd
// Extends: VkMemoryAllocateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImportMemoryFdInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    handleType: VkExternalMemoryHandleTypeFlags = .{},
    // Extern sync: false
    // Optional: false
};
// Extension: VK_KHR_external_memory_fd
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkMemoryFdPropertiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    memoryTypeBits: u32 = 0,
};
// Extension: VK_KHR_external_memory_fd
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkMemoryGetFdInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    memory: VkDeviceMemory = .none,
    // Extern sync: false
    // Optional: false
    handleType: VkExternalMemoryHandleTypeFlags = .{},
};
// Extension: VK_KHR_win32_keyed_mutex
// Extends: VkSubmitInfo,VkSubmitInfo2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkWin32KeyedMutexAcquireReleaseInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    acquireCount: u32 = 0,
    // Length expression: acquireCount
    // Extern sync: false
    // Optional: false
    pAcquireSyncs: ?[*]const VkDeviceMemory = null,
    // Length expression: acquireCount
    // Extern sync: false
    // Optional: false
    pAcquireKeys: ?[*]const u64 = null,
    // Length expression: acquireCount
    // Extern sync: false
    // Optional: false
    pAcquireTimeouts: ?[*]const u32 = null,
    // Extern sync: false
    // Optional: true
    releaseCount: u32 = 0,
    // Length expression: releaseCount
    // Extern sync: false
    // Optional: false
    pReleaseSyncs: ?[*]const VkDeviceMemory = null,
    // Length expression: releaseCount
    // Extern sync: false
    // Optional: false
    pReleaseKeys: ?[*]const u64 = null,
};
// Extension: VK_EXT_external_memory_metal
// Extends: VkMemoryAllocateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImportMemoryMetalHandleInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_IMPORT_MEMORY_METAL_HANDLE_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    handleType: VkExternalMemoryHandleTypeFlags = .{},
    // Extern sync: false
    // Optional: true
    handle: ?*anyopaque = null,
};
// Extension: VK_EXT_external_memory_metal
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkMemoryMetalHandlePropertiesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_MEMORY_METAL_HANDLE_PROPERTIES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    memoryTypeBits: u32 = 0,
};
// Extension: VK_EXT_external_memory_metal
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkMemoryGetMetalHandleInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_MEMORY_GET_METAL_HANDLE_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    memory: VkDeviceMemory = .none,
    // Extern sync: false
    // Optional: false
    handleType: VkExternalMemoryHandleTypeFlags = .{},
};
// Extension: VK_KHR_external_semaphore_capabilities
// Extension: VK_BASE_VERSION_1_1
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceExternalSemaphoreInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    handleType: VkExternalSemaphoreHandleTypeFlags = .{},
};
// Extension: VK_KHR_external_semaphore_capabilities
// Extension: VK_BASE_VERSION_1_1
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkExternalSemaphoreProperties = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    exportFromImportedHandleTypes: VkExternalSemaphoreHandleTypeFlags = .{},
    // Extern sync: false
    // Optional: false
    compatibleHandleTypes: VkExternalSemaphoreHandleTypeFlags = .{},
    // Extern sync: false
    // Optional: true
    externalSemaphoreFeatures: VkExternalSemaphoreFeatureFlags = .{},
};
// Extension: VK_KHR_external_semaphore
// Extension: VK_BASE_VERSION_1_1
// Extends: VkSemaphoreCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkExportSemaphoreCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    handleTypes: VkExternalSemaphoreHandleTypeFlags = .{},
};
// Extension: VK_KHR_external_semaphore_win32
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImportSemaphoreWin32HandleInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: true
    // Optional: false
    semaphore: VkSemaphore = .none,
    // Extern sync: false
    // Optional: true
    flags: VkSemaphoreImportFlags = .{},
    // Extern sync: false
    // Optional: false
    handleType: VkExternalSemaphoreHandleTypeFlags = .{},
    // Extern sync: false
    // Optional: true
    // Extern sync: false
    // Optional: true
};
// Extension: VK_KHR_external_semaphore_win32
// Extends: VkSemaphoreCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkExportSemaphoreWin32HandleInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    pAttributes: ?*const SECURITY_ATTRIBUTES = null,
    // Extern sync: false
    // Optional: false
    // Extern sync: false
    // Optional: false
};
// Extension: VK_KHR_external_semaphore_win32
// Extends: VkSubmitInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkD3D12FenceSubmitInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    waitSemaphoreValuesCount: u32 = 0,
    // Length expression: waitSemaphoreValuesCount
    // Extern sync: false
    // Optional: true
    pWaitSemaphoreValues: ?[*]const u64 = null,
    // Extern sync: false
    // Optional: true
    signalSemaphoreValuesCount: u32 = 0,
    // Length expression: signalSemaphoreValuesCount
    // Extern sync: false
    // Optional: true
    pSignalSemaphoreValues: ?[*]const u64 = null,
};
// Extension: VK_KHR_external_semaphore_win32
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSemaphoreGetWin32HandleInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    semaphore: VkSemaphore = .none,
    // Extern sync: false
    // Optional: false
    handleType: VkExternalSemaphoreHandleTypeFlags = .{},
};
// Extension: VK_KHR_external_semaphore_fd
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImportSemaphoreFdInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: true
    // Optional: false
    semaphore: VkSemaphore = .none,
    // Extern sync: false
    // Optional: true
    flags: VkSemaphoreImportFlags = .{},
    // Extern sync: false
    // Optional: false
    handleType: VkExternalSemaphoreHandleTypeFlags = .{},
    // Extern sync: false
    // Optional: false
};
// Extension: VK_KHR_external_semaphore_fd
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSemaphoreGetFdInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    semaphore: VkSemaphore = .none,
    // Extern sync: false
    // Optional: false
    handleType: VkExternalSemaphoreHandleTypeFlags = .{},
};
// Extension: VK_FUCHSIA_external_semaphore
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImportSemaphoreZirconHandleInfoFUCHSIA = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_ZIRCON_HANDLE_INFO_FUCHSIA;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: true
    // Optional: false
    semaphore: VkSemaphore = .none,
    // Extern sync: false
    // Optional: true
    flags: VkSemaphoreImportFlags = .{},
    // Extern sync: false
    // Optional: false
    handleType: VkExternalSemaphoreHandleTypeFlags = .{},
    // Extern sync: false
    // Optional: false
};
// Extension: VK_FUCHSIA_external_semaphore
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSemaphoreGetZirconHandleInfoFUCHSIA = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_SEMAPHORE_GET_ZIRCON_HANDLE_INFO_FUCHSIA;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    semaphore: VkSemaphore = .none,
    // Extern sync: false
    // Optional: false
    handleType: VkExternalSemaphoreHandleTypeFlags = .{},
};
// Extension: VK_KHR_external_fence_capabilities
// Extension: VK_BASE_VERSION_1_1
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceExternalFenceInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    handleType: VkExternalFenceHandleTypeFlags = .{},
};
// Extension: VK_KHR_external_fence_capabilities
// Extension: VK_BASE_VERSION_1_1
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkExternalFenceProperties = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    exportFromImportedHandleTypes: VkExternalFenceHandleTypeFlags = .{},
    // Extern sync: false
    // Optional: false
    compatibleHandleTypes: VkExternalFenceHandleTypeFlags = .{},
    // Extern sync: false
    // Optional: true
    externalFenceFeatures: VkExternalFenceFeatureFlags = .{},
};
// Extension: VK_KHR_external_fence
// Extension: VK_BASE_VERSION_1_1
// Extends: VkFenceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkExportFenceCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    handleTypes: VkExternalFenceHandleTypeFlags = .{},
};
// Extension: VK_KHR_external_fence_win32
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImportFenceWin32HandleInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: true
    // Optional: false
    fence: VkFence = .none,
    // Extern sync: false
    // Optional: true
    flags: VkFenceImportFlags = .{},
    // Extern sync: false
    // Optional: false
    handleType: VkExternalFenceHandleTypeFlags = .{},
    // Extern sync: false
    // Optional: true
    // Extern sync: false
    // Optional: true
};
// Extension: VK_KHR_external_fence_win32
// Extends: VkFenceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkExportFenceWin32HandleInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    pAttributes: ?*const SECURITY_ATTRIBUTES = null,
    // Extern sync: false
    // Optional: false
    // Extern sync: false
    // Optional: false
};
// Extension: VK_KHR_external_fence_win32
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkFenceGetWin32HandleInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    fence: VkFence = .none,
    // Extern sync: false
    // Optional: false
    handleType: VkExternalFenceHandleTypeFlags = .{},
};
// Extension: VK_KHR_external_fence_fd
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImportFenceFdInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: true
    // Optional: false
    fence: VkFence = .none,
    // Extern sync: false
    // Optional: true
    flags: VkFenceImportFlags = .{},
    // Extern sync: false
    // Optional: false
    handleType: VkExternalFenceHandleTypeFlags = .{},
    // Extern sync: false
    // Optional: false
};
// Extension: VK_KHR_external_fence_fd
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkFenceGetFdInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    fence: VkFence = .none,
    // Extern sync: false
    // Optional: false
    handleType: VkExternalFenceHandleTypeFlags = .{},
};
// Extension: VK_NV_external_sci_sync
// Extends: VkFenceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkExportFenceSciSyncInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_EXPORT_FENCE_SCI_SYNC_INFO_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
};
// Extension: VK_NV_external_sci_sync
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImportFenceSciSyncInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_IMPORT_FENCE_SCI_SYNC_INFO_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: true
    // Optional: false
    fence: VkFence = .none,
    // Extern sync: false
    // Optional: false
    handleType: VkExternalFenceHandleTypeFlags = .{},
    // Extern sync: false
    // Optional: false
    handle: ?*anyopaque = null,
};
// Extension: VK_NV_external_sci_sync
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkFenceGetSciSyncInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_FENCE_GET_SCI_SYNC_INFO_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    fence: VkFence = .none,
    // Extern sync: false
    // Optional: false
    handleType: VkExternalFenceHandleTypeFlags = .{},
};
// Extension: VK_NV_external_sci_sync
// Extends: VkSemaphoreCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkExportSemaphoreSciSyncInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_SCI_SYNC_INFO_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
};
// Extension: VK_NV_external_sci_sync
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImportSemaphoreSciSyncInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_SCI_SYNC_INFO_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: true
    // Optional: false
    semaphore: VkSemaphore = .none,
    // Extern sync: false
    // Optional: false
    handleType: VkExternalSemaphoreHandleTypeFlags = .{},
    // Extern sync: false
    // Optional: false
    handle: ?*anyopaque = null,
};
// Extension: VK_NV_external_sci_sync
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSemaphoreGetSciSyncInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_SEMAPHORE_GET_SCI_SYNC_INFO_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    semaphore: VkSemaphore = .none,
    // Extern sync: false
    // Optional: false
    handleType: VkExternalSemaphoreHandleTypeFlags = .{},
};
// Extension: VK_NV_external_sci_sync
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSciSyncAttributesInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_SCI_SYNC_ATTRIBUTES_INFO_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    clientType: VkSciSyncClientTypeNV = .VK_SCI_SYNC_CLIENT_TYPE_SIGNALER_NV,
    // Extern sync: false
    // Optional: false
    primitiveType: VkSciSyncPrimitiveTypeNV = .VK_SCI_SYNC_PRIMITIVE_TYPE_FENCE_NV,
};
// Extension: VK_NV_external_sci_sync
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceExternalSciSyncFeaturesNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SCI_SYNC_FEATURES_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    sciSyncFence: u32 = 0,
    // Extern sync: false
    // Optional: false
    sciSyncSemaphore: u32 = 0,
    // Extern sync: false
    // Optional: false
    sciSyncImport: u32 = 0,
    // Extern sync: false
    // Optional: false
    sciSyncExport: u32 = 0,
};
// Extension: VK_NV_external_sci_sync2
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceExternalSciSync2FeaturesNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SCI_SYNC_2_FEATURES_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Feature link: sciSyncFence2
    sciSyncFence: u32 = 0,
    // Extern sync: false
    // Optional: false
    sciSyncSemaphore2: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Feature link: sciSyncImport2
    sciSyncImport: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Feature link: sciSyncExport2
    sciSyncExport: u32 = 0,
};
// Extension: VK_NV_external_sci_sync2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSemaphoreSciSyncPoolCreateInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_SEMAPHORE_SCI_SYNC_POOL_CREATE_INFO_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
};
// Extension: VK_NV_external_sci_sync2
// Extends: VkSemaphoreCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSemaphoreSciSyncCreateInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_SEMAPHORE_SCI_SYNC_CREATE_INFO_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    semaphorePool: VkSemaphoreSciSyncPoolNV = .none,
    // Extern sync: false
    // Optional: false
    pFence: ?*const NvSciSyncFence = null,
};
// Extension: VK_NV_external_sci_sync2
// Extends: VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: true
pub const VkDeviceSemaphoreSciSyncPoolReservationCreateInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_DEVICE_SEMAPHORE_SCI_SYNC_POOL_RESERVATION_CREATE_INFO_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    semaphoreSciSyncPoolRequestCount: u32 = 0,
};
// Extension: VK_KHR_multiview
// Extension: VK_GRAPHICS_VERSION_1_1
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceMultiviewFeatures = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: Multiple views in a render pass
    multiview: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Multiple views in a render pass w/ geometry shader
    multiviewGeometryShader: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Multiple views in a render pass w/ tessellation shader
    multiviewTessellationShader: u32 = 0,
};
// Extension: VK_KHR_multiview
// Extension: VK_GRAPHICS_VERSION_1_1
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceMultiviewProperties = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: max number of views in a subpass
    maxMultiviewViewCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: max instance index for a draw in a multiview subpass
    maxMultiviewInstanceIndex: u32 = 0,
};
// Extension: VK_KHR_multiview
// Extension: VK_GRAPHICS_VERSION_1_1
// Extends: VkRenderPassCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkRenderPassMultiviewCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    subpassCount: u32 = 0,
    // Length expression: subpassCount
    // Extern sync: false
    // Optional: false
    pViewMasks: ?[*]const u32 = null,
    // Extern sync: false
    // Optional: true
    dependencyCount: u32 = 0,
    // Length expression: dependencyCount
    // Extern sync: false
    // Optional: false
    pViewOffsets: ?[*]const i32 = null,
    // Extern sync: false
    // Optional: true
    correlationMaskCount: u32 = 0,
    // Length expression: correlationMaskCount
    // Extern sync: false
    // Optional: false
    pCorrelationMasks: ?[*]const u32 = null,
};
// Extension: VK_EXT_display_surface_counter
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkSurfaceCapabilities2EXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: Supported minimum number of images for the surface
    minImageCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Supported maximum number of images for the surface, 0 for unlimited
    maxImageCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Current image width and height for the surface, (0, 0) if undefined
    currentExtent: VkExtent2D = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Supported minimum image width and height for the surface
    minImageExtent: VkExtent2D = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Supported maximum image width and height for the surface
    maxImageExtent: VkExtent2D = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Supported maximum number of image layers for the surface
    maxImageArrayLayers: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: 1 or more bits representing the transforms supported
    supportedTransforms: VkSurfaceTransformFlagsKHR = .{},
    // Extern sync: false
    // Optional: false
    // Comment: The surface's current transform relative to the device's natural orientation
    currentTransform: VkSurfaceTransformFlagsKHR = .{},
    // Extern sync: false
    // Optional: false
    // Comment: 1 or more bits representing the alpha compositing modes supported
    supportedCompositeAlpha: VkCompositeAlphaFlagsKHR = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Supported image usage flags for the surface
    supportedUsageFlags: VkImageUsageFlags = .{},
    // Extern sync: false
    // Optional: true
    supportedSurfaceCounters: VkSurfaceCounterFlagsEXT = .{},
};
// Extension: VK_EXT_display_control
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDisplayPowerInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    powerState: VkDisplayPowerStateEXT = .VK_DISPLAY_POWER_STATE_OFF_EXT,
};
// Extension: VK_EXT_display_control
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDeviceEventInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    deviceEvent: VkDeviceEventTypeEXT = .VK_DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG_EXT,
};
// Extension: VK_EXT_display_control
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDisplayEventInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    displayEvent: VkDisplayEventTypeEXT = .VK_DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT_EXT,
};
// Extension: VK_EXT_display_control
// Extends: VkSwapchainCreateInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSwapchainCounterCreateInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    surfaceCounters: VkSurfaceCounterFlagsEXT = .{},
};
// Extension: VK_KHR_device_group_creation
// Extension: VK_BASE_VERSION_1_1
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceGroupProperties = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    physicalDeviceCount: u32 = 0,
    // Length expression: physicalDeviceCount
    // Extern sync: false
    // Optional: false
    physicalDevices: [VK_MAX_DEVICE_GROUP_SIZE]VkPhysicalDevice = .{VkPhysicalDevice.none} ** VK_MAX_DEVICE_GROUP_SIZE,
    // Extern sync: false
    // Optional: false
    subsetAllocation: u32 = 0,
};
// Extension: VK_KHR_device_group
// Extension: VK_BASE_VERSION_1_1
// Extends: VkMemoryAllocateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkMemoryAllocateFlagsInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkMemoryAllocateFlags = .{},
    // Extern sync: false
    // Optional: false
    deviceMask: u32 = 0,
};
// Extension: VK_KHR_bind_memory2
// Extension: VK_BASE_VERSION_1_1
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkBindBufferMemoryInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: true
    // Optional: false
    buffer: VkBuffer = .none,
    // Extern sync: false
    // Optional: false
    memory: VkDeviceMemory = .none,
    // Extern sync: false
    // Optional: false
    memoryOffset: u64 = 0,
};
// Extension: VK_KHR_device_group
// Extension: VK_BASE_VERSION_1_1
// Extends: VkBindBufferMemoryInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkBindBufferMemoryDeviceGroupInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    deviceIndexCount: u32 = 0,
    // Length expression: deviceIndexCount
    // Extern sync: false
    // Optional: false
    pDeviceIndices: ?[*]const u32 = null,
};
// Extension: VK_KHR_bind_memory2
// Extension: VK_BASE_VERSION_1_1
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkBindImageMemoryInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: true
    // Optional: false
    image: VkImage = .none,
    // Extern sync: false
    // Optional: false
    memory: VkDeviceMemory = .none,
    // Extern sync: false
    // Optional: false
    memoryOffset: u64 = 0,
};
// Extension: VK_KHR_device_group
// Extension: VK_BASE_VERSION_1_1
// Extends: VkBindImageMemoryInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkBindImageMemoryDeviceGroupInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    deviceIndexCount: u32 = 0,
    // Length expression: deviceIndexCount
    // Extern sync: false
    // Optional: false
    pDeviceIndices: ?[*]const u32 = null,
    // Extern sync: false
    // Optional: true
    splitInstanceBindRegionCount: u32 = 0,
    // Length expression: splitInstanceBindRegionCount
    // Extern sync: false
    // Optional: false
    pSplitInstanceBindRegions: ?[*]const VkRect2D = null,
};
// Extension: VK_KHR_device_group
// Extension: VK_GRAPHICS_VERSION_1_1
// Extends: VkRenderPassBeginInfo,VkRenderingInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDeviceGroupRenderPassBeginInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    deviceMask: u32 = 0,
    // Extern sync: false
    // Optional: true
    deviceRenderAreaCount: u32 = 0,
    // Length expression: deviceRenderAreaCount
    // Extern sync: false
    // Optional: false
    pDeviceRenderAreas: ?[*]const VkRect2D = null,
};
// Extension: VK_KHR_device_group
// Extension: VK_BASE_VERSION_1_1
// Extends: VkCommandBufferBeginInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDeviceGroupCommandBufferBeginInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    deviceMask: u32 = 0,
};
// Extension: VK_KHR_device_group
// Extension: VK_BASE_VERSION_1_1
// Extends: VkSubmitInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDeviceGroupSubmitInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    waitSemaphoreCount: u32 = 0,
    // Length expression: waitSemaphoreCount
    // Extern sync: false
    // Optional: false
    pWaitSemaphoreDeviceIndices: ?[*]const u32 = null,
    // Extern sync: false
    // Optional: true
    commandBufferCount: u32 = 0,
    // Length expression: commandBufferCount
    // Extern sync: false
    // Optional: false
    pCommandBufferDeviceMasks: ?[*]const u32 = null,
    // Extern sync: false
    // Optional: true
    signalSemaphoreCount: u32 = 0,
    // Length expression: signalSemaphoreCount
    // Extern sync: false
    // Optional: false
    pSignalSemaphoreDeviceIndices: ?[*]const u32 = null,
};
// Extension: VK_KHR_device_group
// Extension: VK_BASE_VERSION_1_1
// Extends: VkBindSparseInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDeviceGroupBindSparseInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    resourceDeviceIndex: u32 = 0,
    // Extern sync: false
    // Optional: false
    memoryDeviceIndex: u32 = 0,
};
// Extension: VK_KHR_swapchain
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkDeviceGroupPresentCapabilitiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    presentMask: [VK_MAX_DEVICE_GROUP_SIZE]u32 = @import("std").mem.zeroes([VK_MAX_DEVICE_GROUP_SIZE]u32),
    // Extern sync: false
    // Optional: false
    modes: VkDeviceGroupPresentModeFlagsKHR = .{},
};
// Extension: VK_KHR_swapchain
// Extends: VkImageCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImageSwapchainCreateInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    swapchain: VkSwapchainKHR = .none,
};
// Extension: VK_KHR_swapchain
// Extends: VkBindImageMemoryInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkBindImageMemorySwapchainInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: true
    // Optional: false
    swapchain: VkSwapchainKHR = .none,
    // Extern sync: false
    // Optional: false
    imageIndex: u32 = 0,
};
// Extension: VK_KHR_swapchain
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkAcquireNextImageInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: true
    // Optional: false
    swapchain: VkSwapchainKHR = .none,
    // Extern sync: false
    // Optional: false
    timeout: u64 = 0,
    // Extern sync: true
    // Optional: true
    semaphore: VkSemaphore = .none,
    // Extern sync: true
    // Optional: true
    fence: VkFence = .none,
    // Extern sync: false
    // Optional: false
    deviceMask: u32 = 0,
};
// Extension: VK_KHR_swapchain
// Extends: VkPresentInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDeviceGroupPresentInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    swapchainCount: u32 = 0,
    // Length expression: swapchainCount
    // Extern sync: false
    // Optional: false
    pDeviceMasks: ?[*]const u32 = null,
    // Extern sync: false
    // Optional: false
    mode: VkDeviceGroupPresentModeFlagsKHR = .{},
};
// Extension: VK_KHR_device_group_creation
// Extension: VK_BASE_VERSION_1_1
// Extends: VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDeviceGroupDeviceCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    physicalDeviceCount: u32 = 0,
    // Length expression: physicalDeviceCount
    // Extern sync: false
    // Optional: false
    pPhysicalDevices: ?[*]const VkPhysicalDevice = null,
};
// Extension: VK_KHR_swapchain
// Extends: VkSwapchainCreateInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDeviceGroupSwapchainCreateInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    modes: VkDeviceGroupPresentModeFlagsKHR = .{},
};
// Extension: VK_KHR_descriptor_update_template
// Extension: VK_COMPUTE_VERSION_1_1
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDescriptorUpdateTemplateEntry = extern struct {
    // Extern sync: false
    // Optional: false
    // Comment: Binding within the destination descriptor set to write
    dstBinding: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Array element within the destination binding to write
    dstArrayElement: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Number of descriptors to write
    descriptorCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Descriptor type to write
    descriptorType: VkDescriptorType = .VK_DESCRIPTOR_TYPE_SAMPLER,
    // Extern sync: false
    // Optional: false
    // Comment: Offset into pData where the descriptors to update are stored
    offset: u64 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Stride between two descriptors in pData when writing more than one descriptor
    stride: u64 = 0,
};
// Extension: VK_KHR_descriptor_update_template
// Extension: VK_COMPUTE_VERSION_1_1
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDescriptorUpdateTemplateCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkDescriptorUpdateTemplateCreateFlags = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Number of descriptor update entries to use for the update template
    descriptorUpdateEntryCount: u32 = 0,
    // Length expression: descriptorUpdateEntryCount
    // Extern sync: false
    // Optional: false
    // Comment: Descriptor update entries for the template
    pDescriptorUpdateEntries: ?[*]const VkDescriptorUpdateTemplateEntry = null,
    // Extern sync: false
    // Optional: false
    templateType: VkDescriptorUpdateTemplateType = .VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET,
    // Extern sync: false
    // Optional: false
    descriptorSetLayout: VkDescriptorSetLayout = .none,
    // Extern sync: false
    // Optional: false
    pipelineBindPoint: VkPipelineBindPoint = .VK_PIPELINE_BIND_POINT_GRAPHICS,
    // Extern sync: false
    // Optional: false
    // Comment: If used for push descriptors, this is the only allowed layout
    pipelineLayout: VkPipelineLayout = .none,
    // Extern sync: false
    // Optional: false
    set: u32 = 0,
};
// Extension: VK_EXT_hdr_metadata
// Comment: Chromaticity coordinate
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkXYColorEXT = extern struct {
    // Extern sync: false
    // Optional: false
    x: f32 = 0,
    // Extern sync: false
    // Optional: false
    y: f32 = 0,
};
// Extension: VK_KHR_present_id
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDevicePresentIdFeaturesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: Present ID in VkPresentInfoKHR
    presentId: u32 = 0,
};
// Extension: VK_KHR_present_id
// Extends: VkPresentInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPresentIdKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PRESENT_ID_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: Copy of VkPresentInfoKHR::swapchainCount
    swapchainCount: u32 = 0,
    // Length expression: swapchainCount
    // Extern sync: false
    // Optional: true
    // Comment: Present ID values for each swapchain
    pPresentIds: ?[*]const u64 = null,
};
// Extension: VK_KHR_present_id2
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDevicePresentId2FeaturesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_2_FEATURES_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: Present ID2 in VkPresentInfoKHR
    presentId2: u32 = 0,
};
// Extension: VK_KHR_present_id2
// Extends: VkPresentInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPresentId2KHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PRESENT_ID_2_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: Copy of VkPresentInfoKHR::swapchainCount
    swapchainCount: u32 = 0,
    // Length expression: swapchainCount
    // Extern sync: false
    // Optional: true
    // Comment: Present ID values for each swapchain
    pPresentIds: ?[*]const u64 = null,
};
// Extension: VK_KHR_present_wait2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPresentWait2InfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PRESENT_WAIT_2_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    presentId: u64 = 0,
    // Extern sync: false
    // Optional: false
    timeout: u64 = 0,
};
// Extension: VK_KHR_present_wait
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDevicePresentWaitFeaturesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: vkWaitForPresentKHR is supported
    presentWait: u32 = 0,
};
// Extension: VK_KHR_present_wait2
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDevicePresentWait2FeaturesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_2_FEATURES_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: vkWaitForPresent2KHR is supported
    presentWait2: u32 = 0,
};
// Extension: VK_EXT_present_timing
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDevicePresentTimingFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_TIMING_FEATURES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: vkGetPastPresentationTimingEXT is supported
    presentTiming: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Absolute time can be used to specify present time
    presentAtAbsoluteTime: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Relative time can be used to specify present duration
    presentAtRelativeTime: u32 = 0,
};
// Extension: VK_EXT_present_timing
// Extends: VkSurfaceCapabilities2KHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPresentTimingSurfaceCapabilitiesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PRESENT_TIMING_SURFACE_CAPABILITIES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: presentation timings of the surface can be queried using vkGetPastPresentationTimingEXT
    presentTimingSupported: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: surface can be presented using absolute times
    presentAtAbsoluteTimeSupported: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: surface can be presented using relative times
    presentAtRelativeTimeSupported: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: present stages that can be queried
    presentStageQueries: VkPresentStageFlagsEXT = .{},
};
// Extension: VK_EXT_present_timing
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSwapchainTimingPropertiesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_SWAPCHAIN_TIMING_PROPERTIES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: Number of nanoseconds from the start of one refresh cycle to the next
    refreshDuration: u64 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Interval in nanoseconds between refresh cycles durations
    refreshInterval: u64 = 0,
};
// Extension: VK_EXT_present_timing
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSwapchainTimeDomainPropertiesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_SWAPCHAIN_TIME_DOMAIN_PROPERTIES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    timeDomainCount: u32 = 0,
    // Length expression: timeDomainCount
    // Extern sync: false
    // Optional: true
    // Comment: Available time domains to use with the swapchain
    pTimeDomains: ?[*]VkTimeDomainKHR = null,
    // Length expression: timeDomainCount
    // Extern sync: false
    // Optional: true
    // Comment: Unique identifier for a time domain
    pTimeDomainIds: ?[*]u64 = null,
};
// Extension: VK_EXT_present_timing
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPresentStageTimeEXT = extern struct {
    // Extern sync: false
    // Optional: false
    stage: VkPresentStageFlagsEXT = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Time in nanoseconds of the associated stage
    time: u64 = 0,
};
// Extension: VK_EXT_present_timing
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPastPresentationTimingInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PAST_PRESENTATION_TIMING_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkPastPresentationTimingFlagsEXT = .{},
    // Extern sync: true
    // Optional: false
    swapchain: VkSwapchainKHR = .none,
};
// Extension: VK_EXT_present_timing
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPastPresentationTimingPropertiesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PAST_PRESENTATION_TIMING_PROPERTIES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    timingPropertiesCounter: u64 = 0,
    // Extern sync: false
    // Optional: false
    timeDomainsCounter: u64 = 0,
    // Extern sync: false
    // Optional: false
    presentationTimingCount: u32 = 0,
    // Length expression: presentationTimingCount
    // Extern sync: false
    // Optional: false
    pPresentationTimings: ?[*]VkPastPresentationTimingEXT = null,
};
// Extension: VK_EXT_present_timing
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPastPresentationTimingEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PAST_PRESENTATION_TIMING_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: Application-provided identifier, previously given to vkQueuePresentKHR
    presentId: u64 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Application-provided present time
    targetTime: u64 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Number of present stages results available in pPresentStages
    presentStageCount: u32 = 0,
    // Length expression: presentStageCount
    // Extern sync: false
    // Optional: false
    // Comment: Reported timings for each present stage
    pPresentStages: ?[*]VkPresentStageTimeEXT = null,
    // Extern sync: false
    // Optional: false
    // Comment: Time domain of the present stages
    timeDomain: VkTimeDomainKHR = .VK_TIME_DOMAIN_DEVICE_KHR,
    // Extern sync: false
    // Optional: false
    // Comment: Time domain id of the present stages
    timeDomainId: u64 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: VK_TRUE if all the present stages have been reported
    reportComplete: u32 = 0,
};
// Extension: VK_EXT_present_timing
// Extends: VkPresentInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPresentTimingsInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PRESENT_TIMINGS_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: Copy of VkPresentInfoKHR::swapchainCount
    swapchainCount: u32 = 0,
    // Length expression: swapchainCount
    // Extern sync: false
    // Optional: true
    // Comment: Present timing details for each swapchain
    pTimingInfos: ?[*]const VkPresentTimingInfoEXT = null,
};
// Extension: VK_EXT_present_timing
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPresentTimingInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PRESENT_TIMING_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkPresentTimingInfoFlagsEXT = .{},
    // Extern sync: false
    // Optional: false
    targetTime: u64 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Time domain to interpret the target present time and collect present stages timings with
    timeDomainId: u64 = 0,
    // Extern sync: false
    // Optional: true
    // Comment: Present stages to collect timing information for
    presentStageQueries: VkPresentStageFlagsEXT = .{},
    // Extern sync: false
    // Optional: true
    // Comment: Target stage-local time domain's stage
    targetTimeDomainPresentStage: VkPresentStageFlagsEXT = .{},
};
// Extension: VK_EXT_present_timing
// Extends: VkCalibratedTimestampInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSwapchainCalibratedTimestampInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_SWAPCHAIN_CALIBRATED_TIMESTAMP_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: true
    // Optional: false
    swapchain: VkSwapchainKHR = .none,
    // Extern sync: false
    // Optional: false
    presentStage: VkPresentStageFlagsEXT = .{},
    // Extern sync: false
    // Optional: false
    timeDomainId: u64 = 0,
};
// Extension: VK_EXT_hdr_metadata
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkHdrMetadataEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_HDR_METADATA_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: Display primary's Red
    displayPrimaryRed: VkXYColorEXT = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Display primary's Green
    displayPrimaryGreen: VkXYColorEXT = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Display primary's Blue
    displayPrimaryBlue: VkXYColorEXT = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Display primary's Blue
    whitePoint: VkXYColorEXT = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Display maximum luminance
    maxLuminance: f32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Display minimum luminance
    minLuminance: f32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Content maximum luminance
    maxContentLightLevel: f32 = 0,
    // Extern sync: false
    // Optional: false
    maxFrameAverageLightLevel: f32 = 0,
};
// Extension: VK_HUAWEI_hdr_vivid
// Extends: VkHdrMetadataEXT
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkHdrVividDynamicMetadataHUAWEI = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_HDR_VIVID_DYNAMIC_METADATA_HUAWEI;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: Specified in bytes
    dynamicMetadataSize: u64 = 0,
    // Length expression: dynamicMetadataSize
    // Extern sync: false
    // Optional: false
    // Comment: Binary code of size dynamicMetadataSize
    pDynamicMetadata: ?*const anyopaque = null,
};
// Extension: VK_AMD_display_native_hdr
// Extends: VkSurfaceCapabilities2KHR
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkDisplayNativeHdrSurfaceCapabilitiesAMD = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    localDimmingSupport: u32 = 0,
};
// Extension: VK_AMD_display_native_hdr
// Extends: VkSwapchainCreateInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSwapchainDisplayNativeHdrCreateInfoAMD = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    localDimmingEnable: u32 = 0,
};
// Extension: VK_GOOGLE_display_timing
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkRefreshCycleDurationGOOGLE = extern struct {
    // Extern sync: false
    // Optional: false
    // Comment: Number of nanoseconds from the start of one refresh cycle to the next
    refreshDuration: u64 = 0,
};
// Extension: VK_GOOGLE_display_timing
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPastPresentationTimingGOOGLE = extern struct {
    // Extern sync: false
    // Optional: false
    // Comment: Application-provided identifier, previously given to vkQueuePresentKHR
    presentID: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Earliest time an image should have been presented, previously given to vkQueuePresentKHR
    desiredPresentTime: u64 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Time the image was actually displayed
    actualPresentTime: u64 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Earliest time the image could have been displayed
    earliestPresentTime: u64 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: How early vkQueuePresentKHR was processed vs. how soon it needed to be and make earliestPresentTime
    presentMargin: u64 = 0,
};
// Extension: VK_GOOGLE_display_timing
// Extends: VkPresentInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPresentTimesInfoGOOGLE = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: Copy of VkPresentInfoKHR::swapchainCount
    swapchainCount: u32 = 0,
    // Length expression: swapchainCount
    // Extern sync: false
    // Optional: true
    // Comment: The earliest times to present images
    pTimes: ?[*]const VkPresentTimeGOOGLE = null,
};
// Extension: VK_GOOGLE_display_timing
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPresentTimeGOOGLE = extern struct {
    // Extern sync: false
    // Optional: false
    // Comment: Application-provided identifier
    presentID: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Earliest time an image should be presented
    desiredPresentTime: u64 = 0,
};
// Extension: VK_MVK_ios_surface
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkIOSSurfaceCreateInfoMVK = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkIOSSurfaceCreateFlagsMVK = .{},
    // Extern sync: false
    // Optional: false
    pView: ?*const anyopaque = null,
};
// Extension: VK_MVK_macos_surface
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkMacOSSurfaceCreateInfoMVK = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkMacOSSurfaceCreateFlagsMVK = .{},
    // Extern sync: false
    // Optional: false
    pView: ?*const anyopaque = null,
};
// Extension: VK_EXT_metal_surface
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkMetalSurfaceCreateInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_METAL_SURFACE_CREATE_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkMetalSurfaceCreateFlagsEXT = .{},
    // Extern sync: false
    // Optional: false
    pLayer: ?*const CAMetalLayer = null,
};
// Extension: VK_NV_clip_space_w_scaling
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkViewportWScalingNV = extern struct {
    // Extern sync: false
    // Optional: false
    xcoeff: f32 = 0,
    // Extern sync: false
    // Optional: false
    ycoeff: f32 = 0,
};
// Extension: VK_NV_clip_space_w_scaling
// Extends: VkPipelineViewportStateCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineViewportWScalingStateCreateInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    viewportWScalingEnable: u32 = 0,
    // Extern sync: false
    // Optional: false
    viewportCount: u32 = 0,
    // Length expression: viewportCount
    // Extern sync: false
    // Optional: true
    pViewportWScalings: ?[*]const VkViewportWScalingNV = null,
};
// Extension: VK_NV_viewport_swizzle
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkViewportSwizzleNV = extern struct {
    // Extern sync: false
    // Optional: false
    x: VkViewportCoordinateSwizzleNV = .VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_X_NV,
    // Extern sync: false
    // Optional: false
    y: VkViewportCoordinateSwizzleNV = .VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_X_NV,
    // Extern sync: false
    // Optional: false
    z: VkViewportCoordinateSwizzleNV = .VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_X_NV,
    // Extern sync: false
    // Optional: false
    w: VkViewportCoordinateSwizzleNV = .VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_X_NV,
};
// Extension: VK_NV_viewport_swizzle
// Extends: VkPipelineViewportStateCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineViewportSwizzleStateCreateInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkPipelineViewportSwizzleStateCreateFlagsNV = .{},
    // Extern sync: false
    // Optional: false
    viewportCount: u32 = 0,
    // Length expression: viewportCount
    // Extern sync: false
    // Optional: false
    pViewportSwizzles: ?[*]const VkViewportSwizzleNV = null,
};
// Extension: VK_EXT_discard_rectangles
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceDiscardRectanglePropertiesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: max number of active discard rectangles
    maxDiscardRectangles: u32 = 0,
};
// Extension: VK_EXT_discard_rectangles
// Extends: VkGraphicsPipelineCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineDiscardRectangleStateCreateInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkPipelineDiscardRectangleStateCreateFlagsEXT = .{},
    // Extern sync: false
    // Optional: false
    discardRectangleMode: VkDiscardRectangleModeEXT = .VK_DISCARD_RECTANGLE_MODE_INCLUSIVE_EXT,
    // Extern sync: false
    // Optional: true
    discardRectangleCount: u32 = 0,
    // Length expression: discardRectangleCount
    // Extern sync: false
    // Optional: false
    pDiscardRectangles: ?[*]const VkRect2D = null,
};
// Extension: VK_NVX_multiview_per_view_attributes
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    perViewPositionAllComponents: u32 = 0,
};
// Extension: VK_KHR_maintenance2
// Extension: VK_GRAPHICS_VERSION_1_1
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkInputAttachmentAspectReference = extern struct {
    // Extern sync: false
    // Optional: false
    subpass: u32 = 0,
    // Extern sync: false
    // Optional: false
    inputAttachmentIndex: u32 = 0,
    // Extern sync: false
    // Optional: false
    aspectMask: VkImageAspectFlags = .{},
};
// Extension: VK_KHR_maintenance2
// Extension: VK_GRAPHICS_VERSION_1_1
// Extends: VkRenderPassCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkRenderPassInputAttachmentAspectCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    aspectReferenceCount: u32 = 0,
    // Length expression: aspectReferenceCount
    // Extern sync: false
    // Optional: false
    pAspectReferences: ?[*]const VkInputAttachmentAspectReference = null,
};
// Extension: VK_KHR_get_surface_capabilities2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceSurfaceInfo2KHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    surface: VkSurfaceKHR = .none,
};
// Extension: VK_KHR_get_surface_capabilities2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkSurfaceCapabilities2KHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    surfaceCapabilities: VkSurfaceCapabilitiesKHR = .{},
};
// Extension: VK_KHR_get_surface_capabilities2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkSurfaceFormat2KHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    surfaceFormat: VkSurfaceFormatKHR = .{},
};
// Extension: VK_KHR_get_display_properties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkDisplayProperties2KHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    displayProperties: VkDisplayPropertiesKHR = .{},
};
// Extension: VK_KHR_get_display_properties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkDisplayPlaneProperties2KHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    displayPlaneProperties: VkDisplayPlanePropertiesKHR = .{},
};
// Extension: VK_KHR_get_display_properties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkDisplayModeProperties2KHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    displayModeProperties: VkDisplayModePropertiesKHR = .{},
};
// Extension: VK_NV_display_stereo
// Extends: VkDisplayModeProperties2KHR
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkDisplayModeStereoPropertiesNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_DISPLAY_MODE_STEREO_PROPERTIES_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: Whether this mode supports HDMI 3D stereo rendering.
    hdmi3DSupported: u32 = 0,
};
// Extension: VK_KHR_get_display_properties2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDisplayPlaneInfo2KHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: true
    // Optional: false
    mode: VkDisplayModeKHR = .none,
    // Extern sync: false
    // Optional: false
    planeIndex: u32 = 0,
};
// Extension: VK_KHR_get_display_properties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkDisplayPlaneCapabilities2KHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    capabilities: VkDisplayPlaneCapabilitiesKHR = .{},
};
// Extension: VK_KHR_shared_presentable_image
// Extends: VkSurfaceCapabilities2KHR
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkSharedPresentSurfaceCapabilitiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: true
    // Comment: Supported image usage flags if swapchain created using a shared present mode
    sharedPresentSupportedUsageFlags: VkImageUsageFlags = .{},
};
// Extension: VK_KHR_16bit_storage
// Extension: VK_COMPUTE_VERSION_1_1
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDevice16BitStorageFeatures = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: 16-bit integer/floating-point variables supported in BufferBlock
    storageBuffer16BitAccess: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: 16-bit integer/floating-point variables supported in BufferBlock and Block
    uniformAndStorageBuffer16BitAccess: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: 16-bit integer/floating-point variables supported in PushConstant
    storagePushConstant16: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: 16-bit integer/floating-point variables supported in shader inputs and outputs
    storageInputOutput16: u32 = 0,
};
// Extension: VK_COMPUTE_VERSION_1_1
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceSubgroupProperties = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: The size of a subgroup for this queue.
    subgroupSize: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Bitfield of what shader stages support subgroup operations
    supportedStages: VkShaderStageFlags = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Bitfield of what subgroup operations are supported.
    supportedOperations: VkSubgroupFeatureFlags = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Flag to specify whether quad operations are available in all stages.
    quadOperationsInAllStages: u32 = 0,
};
// Extension: VK_KHR_shader_subgroup_extended_types
// Extension: VK_COMPUTE_VERSION_1_2
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: Flag to specify whether subgroup operations with extended types are supported
    shaderSubgroupExtendedTypes: u32 = 0,
};
// Extension: VK_KHR_get_memory_requirements2
// Extension: VK_BASE_VERSION_1_1
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkBufferMemoryRequirementsInfo2 = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    buffer: VkBuffer = .none,
};
// Extension: VK_KHR_maintenance4
// Extension: VK_BASE_VERSION_1_3
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDeviceBufferMemoryRequirements = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    pCreateInfo: ?*const VkBufferCreateInfo = null,
};
// Extension: VK_KHR_get_memory_requirements2
// Extension: VK_BASE_VERSION_1_1
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImageMemoryRequirementsInfo2 = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    image: VkImage = .none,
};
// Extension: VK_KHR_get_memory_requirements2
// Extension: VK_BASE_VERSION_1_1
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImageSparseMemoryRequirementsInfo2 = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    image: VkImage = .none,
};
// Extension: VK_KHR_maintenance4
// Extension: VK_BASE_VERSION_1_3
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDeviceImageMemoryRequirements = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    pCreateInfo: ?*const VkImageCreateInfo = null,
    // Extern sync: false
    // Optional: true
    planeAspect: VkImageAspectFlags = .{},
};
// Extension: VK_KHR_get_memory_requirements2
// Extension: VK_BASE_VERSION_1_1
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkMemoryRequirements2 = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    memoryRequirements: VkMemoryRequirements = .{},
};
// Extension: VK_KHR_get_memory_requirements2
// Extension: VK_BASE_VERSION_1_1
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkSparseImageMemoryRequirements2 = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    memoryRequirements: VkSparseImageMemoryRequirements = .{},
};
// Extension: VK_KHR_maintenance2
// Extension: VK_GRAPHICS_VERSION_1_1
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDevicePointClippingProperties = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    pointClippingBehavior: VkPointClippingBehavior = .VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES,
};
// Extension: VK_KHR_dedicated_allocation
// Extension: VK_BASE_VERSION_1_1
// Extends: VkMemoryRequirements2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkMemoryDedicatedRequirements = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    prefersDedicatedAllocation: u32 = 0,
    // Extern sync: false
    // Optional: false
    requiresDedicatedAllocation: u32 = 0,
};
// Extension: VK_KHR_dedicated_allocation
// Extension: VK_BASE_VERSION_1_1
// Extends: VkMemoryAllocateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkMemoryDedicatedAllocateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    // Comment: Image that this allocation will be bound to
    image: VkImage = .none,
    // Extern sync: false
    // Optional: true
    // Comment: Buffer that this allocation will be bound to
    buffer: VkBuffer = .none,
};
// Extension: VK_KHR_maintenance2
// Extension: VK_BASE_VERSION_1_1
// Extends: VkImageViewCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImageViewUsageCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    usage: VkImageUsageFlags = .{},
};
// Extension: VK_EXT_image_sliced_view_of_3d
// Extends: VkImageViewCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImageViewSlicedCreateInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_IMAGE_VIEW_SLICED_CREATE_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    sliceOffset: u32 = 0,
    // Extern sync: false
    // Optional: false
    sliceCount: u32 = 0,
};
// Extension: VK_KHR_maintenance2
// Extension: VK_GRAPHICS_VERSION_1_1
// Extends: VkPipelineTessellationStateCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineTessellationDomainOriginStateCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    domainOrigin: VkTessellationDomainOrigin = .VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT,
};
// Extension: VK_KHR_sampler_ycbcr_conversion
// Extension: VK_COMPUTE_VERSION_1_1
// Extends: VkSamplerCreateInfo,VkImageViewCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSamplerYcbcrConversionInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    conversion: VkSamplerYcbcrConversion = .none,
};
// Extension: VK_KHR_sampler_ycbcr_conversion
// Extension: VK_COMPUTE_VERSION_1_1
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSamplerYcbcrConversionCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    format: VkFormat = .VK_FORMAT_UNDEFINED,
    // Extern sync: false
    // Optional: false
    ycbcrModel: VkSamplerYcbcrModelConversion = .VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY,
    // Extern sync: false
    // Optional: false
    ycbcrRange: VkSamplerYcbcrRange = .VK_SAMPLER_YCBCR_RANGE_ITU_FULL,
    // Extern sync: false
    // Optional: false
    components: VkComponentMapping = .{},
    // Extern sync: false
    // Optional: false
    xChromaOffset: VkChromaLocation = .VK_CHROMA_LOCATION_COSITED_EVEN,
    // Extern sync: false
    // Optional: false
    yChromaOffset: VkChromaLocation = .VK_CHROMA_LOCATION_COSITED_EVEN,
    // Extern sync: false
    // Optional: false
    chromaFilter: VkFilter = .VK_FILTER_NEAREST,
    // Extern sync: false
    // Optional: false
    forceExplicitReconstruction: u32 = 0,
};
// Extension: VK_KHR_sampler_ycbcr_conversion
// Extension: VK_BASE_VERSION_1_1
// Extends: VkBindImageMemoryInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkBindImagePlaneMemoryInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    planeAspect: VkImageAspectFlags = .{},
};
// Extension: VK_KHR_sampler_ycbcr_conversion
// Extension: VK_BASE_VERSION_1_1
// Extends: VkImageMemoryRequirementsInfo2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImagePlaneMemoryRequirementsInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    planeAspect: VkImageAspectFlags = .{},
};
// Extension: VK_KHR_sampler_ycbcr_conversion
// Extension: VK_COMPUTE_VERSION_1_1
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceSamplerYcbcrConversionFeatures = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: Sampler color conversion supported
    samplerYcbcrConversion: u32 = 0,
};
// Extension: VK_KHR_sampler_ycbcr_conversion
// Extension: VK_COMPUTE_VERSION_1_1
// Extends: VkImageFormatProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkSamplerYcbcrConversionImageFormatProperties = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    combinedImageSamplerDescriptorCount: u32 = 0,
};
// Extension: VK_AMD_texture_gather_bias_lod
// Extends: VkImageFormatProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkTextureLODGatherFormatPropertiesAMD = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    supportsTextureGatherLODBiasAMD: u32 = 0,
};
// Extension: VK_EXT_conditional_rendering
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkConditionalRenderingBeginInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    buffer: VkBuffer = .none,
    // Extern sync: false
    // Optional: false
    offset: u64 = 0,
    // Extern sync: false
    // Optional: true
    flags: VkConditionalRenderingFlagsEXT = .{},
};
// Extension: VK_BASE_VERSION_1_1
// Extends: VkSubmitInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkProtectedSubmitInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: Submit protected command buffers
    protectedSubmit: u32 = 0,
};
// Extension: VK_BASE_VERSION_1_1
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceProtectedMemoryFeatures = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    protectedMemory: u32 = 0,
};
// Extension: VK_BASE_VERSION_1_1
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceProtectedMemoryProperties = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    protectedNoFault: u32 = 0,
};
// Extension: VK_BASE_VERSION_1_1
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDeviceQueueInfo2 = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkDeviceQueueCreateFlags = .{},
    // Extern sync: false
    // Optional: false
    queueFamilyIndex: u32 = 0,
    // Extern sync: false
    // Optional: false
    queueIndex: u32 = 0,
};
// Extension: VK_NV_fragment_coverage_to_color
// Extends: VkPipelineMultisampleStateCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineCoverageToColorStateCreateInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkPipelineCoverageToColorStateCreateFlagsNV = .{},
    // Extern sync: false
    // Optional: false
    coverageToColorEnable: u32 = 0,
    // Extern sync: false
    // Optional: true
    coverageToColorLocation: u32 = 0,
};
// Extension: VK_EXT_sampler_filter_minmax
// Extension: VK_COMPUTE_VERSION_1_2
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceSamplerFilterMinmaxProperties = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    filterMinmaxSingleComponentFormats: u32 = 0,
    // Extern sync: false
    // Optional: false
    filterMinmaxImageComponentMapping: u32 = 0,
};
// Extension: VK_EXT_sample_locations
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSampleLocationEXT = extern struct {
    // Extern sync: false
    // Optional: false
    x: f32 = 0,
    // Extern sync: false
    // Optional: false
    y: f32 = 0,
};
// Extension: VK_EXT_sample_locations
// Extends: VkImageMemoryBarrier,VkImageMemoryBarrier2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSampleLocationsInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    sampleLocationsPerPixel: VkSampleCountFlags = .{},
    // Extern sync: false
    // Optional: false
    sampleLocationGridSize: VkExtent2D = .{},
    // Extern sync: false
    // Optional: true
    sampleLocationsCount: u32 = 0,
    // Length expression: sampleLocationsCount
    // Extern sync: false
    // Optional: false
    pSampleLocations: ?[*]const VkSampleLocationEXT = null,
};
// Extension: VK_EXT_sample_locations
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkAttachmentSampleLocationsEXT = extern struct {
    // Extern sync: false
    // Optional: false
    attachmentIndex: u32 = 0,
    // Extern sync: false
    // Optional: false
    sampleLocationsInfo: VkSampleLocationsInfoEXT = .{},
};
// Extension: VK_EXT_sample_locations
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSubpassSampleLocationsEXT = extern struct {
    // Extern sync: false
    // Optional: false
    subpassIndex: u32 = 0,
    // Extern sync: false
    // Optional: false
    sampleLocationsInfo: VkSampleLocationsInfoEXT = .{},
};
// Extension: VK_EXT_sample_locations
// Extends: VkRenderPassBeginInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkRenderPassSampleLocationsBeginInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    attachmentInitialSampleLocationsCount: u32 = 0,
    // Length expression: attachmentInitialSampleLocationsCount
    // Extern sync: false
    // Optional: false
    pAttachmentInitialSampleLocations: ?[*]const VkAttachmentSampleLocationsEXT = null,
    // Extern sync: false
    // Optional: true
    postSubpassSampleLocationsCount: u32 = 0,
    // Length expression: postSubpassSampleLocationsCount
    // Extern sync: false
    // Optional: false
    pPostSubpassSampleLocations: ?[*]const VkSubpassSampleLocationsEXT = null,
};
// Extension: VK_EXT_sample_locations
// Extends: VkPipelineMultisampleStateCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineSampleLocationsStateCreateInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    sampleLocationsEnable: u32 = 0,
    // Extern sync: false
    // Optional: false
    sampleLocationsInfo: VkSampleLocationsInfoEXT = .{},
};
// Extension: VK_EXT_sample_locations
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceSampleLocationsPropertiesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    sampleLocationSampleCounts: VkSampleCountFlags = .{},
    // Extern sync: false
    // Optional: false
    maxSampleLocationGridSize: VkExtent2D = .{},
    // Extern sync: false
    // Optional: false
    sampleLocationCoordinateRange: [2]f32 = @import("std").mem.zeroes([2]f32),
    // Extern sync: false
    // Optional: false
    sampleLocationSubPixelBits: u32 = 0,
    // Extern sync: false
    // Optional: false
    variableSampleLocations: u32 = 0,
};
// Extension: VK_EXT_sample_locations
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkMultisamplePropertiesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    maxSampleLocationGridSize: VkExtent2D = .{},
};
// Extension: VK_EXT_sampler_filter_minmax
// Extension: VK_COMPUTE_VERSION_1_2
// Extends: VkSamplerCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSamplerReductionModeCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    reductionMode: VkSamplerReductionMode = .VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE,
};
// Extension: VK_EXT_blend_operation_advanced
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    advancedBlendCoherentOperations: u32 = 0,
};
// Extension: VK_EXT_multi_draw
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceMultiDrawFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    multiDraw: u32 = 0,
};
// Extension: VK_EXT_blend_operation_advanced
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    advancedBlendMaxColorAttachments: u32 = 0,
    // Extern sync: false
    // Optional: false
    advancedBlendIndependentBlend: u32 = 0,
    // Extern sync: false
    // Optional: false
    advancedBlendNonPremultipliedSrcColor: u32 = 0,
    // Extern sync: false
    // Optional: false
    advancedBlendNonPremultipliedDstColor: u32 = 0,
    // Extern sync: false
    // Optional: false
    advancedBlendCorrelatedOverlap: u32 = 0,
    // Extern sync: false
    // Optional: false
    advancedBlendAllOperations: u32 = 0,
};
// Extension: VK_EXT_blend_operation_advanced
// Extends: VkPipelineColorBlendStateCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineColorBlendAdvancedStateCreateInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    srcPremultiplied: u32 = 0,
    // Extern sync: false
    // Optional: false
    dstPremultiplied: u32 = 0,
    // Extern sync: false
    // Optional: false
    blendOverlap: VkBlendOverlapEXT = .VK_BLEND_OVERLAP_UNCORRELATED_EXT,
};
// Extension: VK_EXT_inline_uniform_block
// Extension: VK_COMPUTE_VERSION_1_3
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceInlineUniformBlockFeatures = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    inlineUniformBlock: u32 = 0,
    // Extern sync: false
    // Optional: false
    descriptorBindingInlineUniformBlockUpdateAfterBind: u32 = 0,
};
// Extension: VK_EXT_inline_uniform_block
// Extension: VK_COMPUTE_VERSION_1_3
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceInlineUniformBlockProperties = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    maxInlineUniformBlockSize: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxPerStageDescriptorInlineUniformBlocks: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxDescriptorSetInlineUniformBlocks: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxDescriptorSetUpdateAfterBindInlineUniformBlocks: u32 = 0,
};
// Extension: VK_EXT_inline_uniform_block
// Extension: VK_COMPUTE_VERSION_1_3
// Extends: VkWriteDescriptorSet
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkWriteDescriptorSetInlineUniformBlock = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    dataSize: u32 = 0,
    // Length expression: dataSize
    // Extern sync: false
    // Optional: false
    pData: ?*const anyopaque = null,
};
// Extension: VK_EXT_inline_uniform_block
// Extension: VK_COMPUTE_VERSION_1_3
// Extends: VkDescriptorPoolCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDescriptorPoolInlineUniformBlockCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    maxInlineUniformBlockBindings: u32 = 0,
};
// Extension: VK_NV_framebuffer_mixed_samples
// Extends: VkPipelineMultisampleStateCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineCoverageModulationStateCreateInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkPipelineCoverageModulationStateCreateFlagsNV = .{},
    // Extern sync: false
    // Optional: false
    coverageModulationMode: VkCoverageModulationModeNV = .VK_COVERAGE_MODULATION_MODE_NONE_NV,
    // Extern sync: false
    // Optional: false
    coverageModulationTableEnable: u32 = 0,
    // Extern sync: false
    // Optional: true
    coverageModulationTableCount: u32 = 0,
    // Length expression: coverageModulationTableCount
    // Extern sync: false
    // Optional: true
    pCoverageModulationTable: ?[*]const f32 = null,
};
// Extension: VK_KHR_image_format_list
// Extension: VK_BASE_VERSION_1_2
// Extends: VkImageCreateInfo,VkSwapchainCreateInfoKHR,VkPhysicalDeviceImageFormatInfo2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImageFormatListCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    viewFormatCount: u32 = 0,
    // Length expression: viewFormatCount
    // Extern sync: false
    // Optional: false
    pViewFormats: ?[*]const VkFormat = null,
};
// Extension: VK_EXT_validation_cache
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkValidationCacheCreateInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkValidationCacheCreateFlagsEXT = .{},
    // Extern sync: false
    // Optional: true
    initialDataSize: u64 = 0,
    // Length expression: initialDataSize
    // Extern sync: false
    // Optional: false
    pInitialData: ?*const anyopaque = null,
};
// Extension: VK_EXT_validation_cache
// Extends: VkShaderModuleCreateInfo,VkPipelineShaderStageCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkShaderModuleValidationCacheCreateInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    validationCache: VkValidationCacheEXT = .none,
};
// Extension: VK_KHR_maintenance3
// Extension: VK_COMPUTE_VERSION_1_1
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceMaintenance3Properties = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    maxPerSetDescriptors: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxMemoryAllocationSize: u64 = 0,
};
// Extension: VK_KHR_maintenance4
// Extension: VK_BASE_VERSION_1_3
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceMaintenance4Features = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    maintenance4: u32 = 0,
};
// Extension: VK_KHR_maintenance4
// Extension: VK_BASE_VERSION_1_3
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceMaintenance4Properties = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    maxBufferSize: u64 = 0,
};
// Extension: VK_KHR_maintenance5
// Extension: VK_BASE_VERSION_1_4
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceMaintenance5Features = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    maintenance5: u32 = 0,
};
// Extension: VK_KHR_maintenance5
// Extension: VK_BASE_VERSION_1_4
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceMaintenance5Properties = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_PROPERTIES;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    earlyFragmentMultisampleCoverageAfterSampleCounting: u32 = 0,
    // Extern sync: false
    // Optional: false
    earlyFragmentSampleMaskTestBeforeSampleCounting: u32 = 0,
    // Extern sync: false
    // Optional: false
    depthStencilSwizzleOneSupport: u32 = 0,
    // Extern sync: false
    // Optional: false
    polygonModePointSize: u32 = 0,
    // Extern sync: false
    // Optional: false
    nonStrictSinglePixelWideLinesUseParallelogram: u32 = 0,
    // Extern sync: false
    // Optional: false
    nonStrictWideLinesUseParallelogram: u32 = 0,
};
// Extension: VK_KHR_maintenance6
// Extension: VK_BASE_VERSION_1_4
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceMaintenance6Features = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_FEATURES;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    maintenance6: u32 = 0,
};
// Extension: VK_KHR_maintenance6
// Extension: VK_BASE_VERSION_1_4
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceMaintenance6Properties = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_PROPERTIES;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    blockTexelViewCompatibleMultipleLayers: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxCombinedImageSamplerDescriptorCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    fragmentShadingRateClampCombinerInputs: u32 = 0,
};
// Extension: VK_KHR_maintenance7
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceMaintenance7FeaturesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_7_FEATURES_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    maintenance7: u32 = 0,
};
// Extension: VK_KHR_maintenance7
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceMaintenance7PropertiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_7_PROPERTIES_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    robustFragmentShadingRateAttachmentAccess: u32 = 0,
    // Extern sync: false
    // Optional: false
    separateDepthStencilAttachmentAccess: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxDescriptorSetTotalUniformBuffersDynamic: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxDescriptorSetTotalStorageBuffersDynamic: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxDescriptorSetTotalBuffersDynamic: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxDescriptorSetUpdateAfterBindTotalUniformBuffersDynamic: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxDescriptorSetUpdateAfterBindTotalStorageBuffersDynamic: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxDescriptorSetUpdateAfterBindTotalBuffersDynamic: u32 = 0,
};
// Extension: VK_KHR_maintenance7
// Extends: VkPhysicalDeviceProperties2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceLayeredApiPropertiesListKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_PROPERTIES_LIST_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: true
    layeredApiCount: u32 = 0,
    // Length expression: layeredApiCount
    // Extern sync: false
    // Optional: true
    // Comment: Output list of layered implementations underneath the physical device
    pLayeredApis: ?[*]VkPhysicalDeviceLayeredApiPropertiesKHR = null,
};
// Extension: VK_KHR_maintenance7
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceLayeredApiPropertiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_PROPERTIES_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    vendorID: u32 = 0,
    // Extern sync: false
    // Optional: false
    deviceID: u32 = 0,
    // Extern sync: false
    // Optional: false
    layeredAPI: VkPhysicalDeviceLayeredApiKHR = .VK_PHYSICAL_DEVICE_LAYERED_API_VULKAN_KHR,
    // Extern sync: false
    // Optional: false
    deviceName: [VK_MAX_PHYSICAL_DEVICE_NAME_SIZE]u8 = @import("std").mem.zeroes([VK_MAX_PHYSICAL_DEVICE_NAME_SIZE]u8),
};
// Extension: VK_KHR_maintenance7
// Extends: VkPhysicalDeviceLayeredApiPropertiesKHR
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceLayeredApiVulkanPropertiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_VULKAN_PROPERTIES_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    properties: VkPhysicalDeviceProperties2 = .{},
};
// Extension: VK_KHR_maintenance8
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceMaintenance8FeaturesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_8_FEATURES_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    maintenance8: u32 = 0,
};
// Extension: VK_KHR_maintenance9
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceMaintenance9FeaturesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_9_FEATURES_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    maintenance9: u32 = 0,
};
// Extension: VK_KHR_maintenance9
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceMaintenance9PropertiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_9_PROPERTIES_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    image2DViewOf3DSparse: u32 = 0,
    // Extern sync: false
    // Optional: false
    defaultVertexAttributeValue: VkDefaultVertexAttributeValueKHR = .VK_DEFAULT_VERTEX_ATTRIBUTE_VALUE_ZERO_ZERO_ZERO_ZERO_KHR,
};
// Extension: VK_KHR_maintenance10
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceMaintenance10PropertiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_10_PROPERTIES_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    rgba4OpaqueBlackSwizzled: u32 = 0,
    // Extern sync: false
    // Optional: false
    resolveSrgbFormatAppliesTransferFunction: u32 = 0,
    // Extern sync: false
    // Optional: false
    resolveSrgbFormatSupportsTransferFunctionControl: u32 = 0,
};
// Extension: VK_KHR_maintenance10
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceMaintenance10FeaturesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_10_FEATURES_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    maintenance10: u32 = 0,
};
// Extension: VK_KHR_maintenance9
// Extends: VkQueueFamilyProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkQueueFamilyOwnershipTransferPropertiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_QUEUE_FAMILY_OWNERSHIP_TRANSFER_PROPERTIES_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    optimalImageTransferToQueueFamilies: u32 = 0,
};
// Extension: VK_KHR_maintenance5
// Extension: VK_GRAPHICS_VERSION_1_4
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkRenderingAreaInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_RENDERING_AREA_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    viewMask: u32 = 0,
    // Extern sync: false
    // Optional: true
    colorAttachmentCount: u32 = 0,
    // Length expression: colorAttachmentCount
    // Extern sync: false
    // Optional: false
    pColorAttachmentFormats: ?[*]const VkFormat = null,
    // Extern sync: false
    // Optional: false
    depthAttachmentFormat: VkFormat = .VK_FORMAT_UNDEFINED,
    // Extern sync: false
    // Optional: false
    stencilAttachmentFormat: VkFormat = .VK_FORMAT_UNDEFINED,
};
// Extension: VK_KHR_maintenance3
// Extension: VK_COMPUTE_VERSION_1_1
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkDescriptorSetLayoutSupport = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    supported: u32 = 0,
};
// Extension: VK_GRAPHICS_VERSION_1_1
// Extension: VK_GRAPHICS_VERSION_1_1
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceShaderDrawParametersFeatures = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    shaderDrawParameters: u32 = 0,
};
// Extension: VK_KHR_shader_float16_int8
// Extension: VK_KHR_shader_float16_int8
// Extension: VK_COMPUTE_VERSION_1_2
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceShaderFloat16Int8Features = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: 16-bit floats (halfs) in shaders
    shaderFloat16: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: 8-bit integers in shaders
    shaderInt8: u32 = 0,
};
// Extension: VK_KHR_shader_float_controls
// Extension: VK_COMPUTE_VERSION_1_2
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceFloatControlsProperties = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    denormBehaviorIndependence: VkShaderFloatControlsIndependence = .VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY,
    // Extern sync: false
    // Optional: false
    roundingModeIndependence: VkShaderFloatControlsIndependence = .VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY,
    // Extern sync: false
    // Optional: false
    // Comment: An implementation can preserve signed zero, nan, inf
    shaderSignedZeroInfNanPreserveFloat16: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: An implementation can preserve signed zero, nan, inf
    shaderSignedZeroInfNanPreserveFloat32: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: An implementation can preserve signed zero, nan, inf
    shaderSignedZeroInfNanPreserveFloat64: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: An implementation can preserve  denormals
    shaderDenormPreserveFloat16: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: An implementation can preserve  denormals
    shaderDenormPreserveFloat32: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: An implementation can preserve  denormals
    shaderDenormPreserveFloat64: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: An implementation can flush to zero  denormals
    shaderDenormFlushToZeroFloat16: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: An implementation can flush to zero  denormals
    shaderDenormFlushToZeroFloat32: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: An implementation can flush to zero  denormals
    shaderDenormFlushToZeroFloat64: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: An implementation can support RTE
    shaderRoundingModeRTEFloat16: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: An implementation can support RTE
    shaderRoundingModeRTEFloat32: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: An implementation can support RTE
    shaderRoundingModeRTEFloat64: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: An implementation can support RTZ
    shaderRoundingModeRTZFloat16: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: An implementation can support RTZ
    shaderRoundingModeRTZFloat32: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: An implementation can support RTZ
    shaderRoundingModeRTZFloat64: u32 = 0,
};
// Extension: VK_EXT_host_query_reset
// Extension: VK_BASE_VERSION_1_2
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceHostQueryResetFeatures = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    hostQueryReset: u32 = 0,
};
// Extension: VK_AMD_shader_info
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkShaderResourceUsageAMD = extern struct {
    // Extern sync: false
    // Optional: false
    numUsedVgprs: u32 = 0,
    // Extern sync: false
    // Optional: false
    numUsedSgprs: u32 = 0,
    // Extern sync: false
    // Optional: false
    ldsSizePerLocalWorkGroup: u32 = 0,
    // Extern sync: false
    // Optional: false
    ldsUsageSizeInBytes: u64 = 0,
    // Extern sync: false
    // Optional: false
    scratchMemUsageInBytes: u64 = 0,
};
// Extension: VK_AMD_shader_info
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkShaderStatisticsInfoAMD = extern struct {
    // Extern sync: false
    // Optional: false
    shaderStageMask: VkShaderStageFlags = .{},
    // Extern sync: false
    // Optional: false
    resourceUsage: VkShaderResourceUsageAMD = .{},
    // Extern sync: false
    // Optional: false
    numPhysicalVgprs: u32 = 0,
    // Extern sync: false
    // Optional: false
    numPhysicalSgprs: u32 = 0,
    // Extern sync: false
    // Optional: false
    numAvailableVgprs: u32 = 0,
    // Extern sync: false
    // Optional: false
    numAvailableSgprs: u32 = 0,
    // Extern sync: false
    // Optional: false
    computeWorkGroupSize: [3]u32 = @import("std").mem.zeroes([3]u32),
};
// Extension: VK_KHR_global_priority
// Extension: VK_EXT_global_priority
// Extension: VK_BASE_VERSION_1_4
// Extends: VkDeviceQueueCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDeviceQueueGlobalPriorityCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    globalPriority: VkQueueGlobalPriority = .VK_QUEUE_GLOBAL_PRIORITY_LOW,
};
// Extension: VK_KHR_global_priority
// Extension: VK_EXT_global_priority_query
// Extension: VK_BASE_VERSION_1_4
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceGlobalPriorityQueryFeatures = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    globalPriorityQuery: u32 = 0,
};
// Extension: VK_KHR_global_priority
// Extension: VK_EXT_global_priority_query
// Extension: VK_BASE_VERSION_1_4
// Extends: VkQueueFamilyProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkQueueFamilyGlobalPriorityProperties = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    priorityCount: u32 = 0,
    // Length expression: priorityCount
    // Extern sync: false
    // Optional: false
    priorities: [VK_MAX_GLOBAL_PRIORITY_SIZE]VkQueueGlobalPriority = .{VkQueueGlobalPriority.VK_QUEUE_GLOBAL_PRIORITY_LOW} ** VK_MAX_GLOBAL_PRIORITY_SIZE,
};
// Extension: VK_EXT_debug_utils
// Extends: VkPipelineShaderStageCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDebugUtilsObjectNameInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    objectType: VkObjectType = .VK_OBJECT_TYPE_UNKNOWN,
    // Extern sync: false
    // Optional: false
    // Object type: objectType (Which object handle is this)
    objectHandle: u64 = 0,
    // Length expression: null-terminated
    // Extern sync: false
    // Optional: true
    pObjectName: ?[*:0]const u8 = null,
};
// Extension: VK_EXT_debug_utils
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDebugUtilsObjectTagInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    objectType: VkObjectType = .VK_OBJECT_TYPE_UNKNOWN,
    // Extern sync: true
    // Optional: false
    // Object type: objectType (Which object handle is this)
    objectHandle: u64 = 0,
    // Extern sync: false
    // Optional: false
    tagName: u64 = 0,
    // Extern sync: false
    // Optional: false
    tagSize: u64 = 0,
    // Length expression: tagSize
    // Extern sync: false
    // Optional: false
    pTag: ?*const anyopaque = null,
};
// Extension: VK_EXT_debug_utils
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDebugUtilsLabelEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Length expression: null-terminated
    // Extern sync: false
    // Optional: false
    pLabelName: ?[*:0]const u8 = null,
    // Extern sync: false
    // Optional: false
    color: [4]f32 = @import("std").mem.zeroes([4]f32),
};
// Extension: VK_EXT_debug_utils
// Extends: VkInstanceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: true
pub const VkDebugUtilsMessengerCreateInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkDebugUtilsMessengerCreateFlagsEXT = .{},
    // Extern sync: false
    // Optional: false
    messageSeverity: VkDebugUtilsMessageSeverityFlagsEXT = .{},
    // Extern sync: false
    // Optional: false
    messageType: VkDebugUtilsMessageTypeFlagsEXT = .{},
    // Extern sync: false
    // Optional: false
    pfnUserCallback: ?*const vkDebugUtilsMessengerCallbackEXT = null,
    // Extern sync: false
    // Optional: true
    pUserData: ?*anyopaque = null,
};
// Extension: VK_EXT_debug_utils
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDebugUtilsMessengerCallbackDataEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkDebugUtilsMessengerCallbackDataFlagsEXT = .{},
    // Length expression: null-terminated
    // Extern sync: false
    // Optional: true
    pMessageIdName: ?[*:0]const u8 = null,
    // Extern sync: false
    // Optional: false
    messageIdNumber: i32 = 0,
    // Length expression: null-terminated
    // Extern sync: false
    // Optional: true
    pMessage: ?[*:0]const u8 = null,
    // Extern sync: false
    // Optional: true
    queueLabelCount: u32 = 0,
    // Length expression: queueLabelCount
    // Extern sync: false
    // Optional: false
    pQueueLabels: ?[*]const VkDebugUtilsLabelEXT = null,
    // Extern sync: false
    // Optional: true
    cmdBufLabelCount: u32 = 0,
    // Length expression: cmdBufLabelCount
    // Extern sync: false
    // Optional: false
    pCmdBufLabels: ?[*]const VkDebugUtilsLabelEXT = null,
    // Extern sync: false
    // Optional: true
    objectCount: u32 = 0,
    // Length expression: objectCount
    // Extern sync: false
    // Optional: false
    pObjects: ?[*]const VkDebugUtilsObjectNameInfoEXT = null,
};
// Extension: VK_EXT_device_memory_report
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceDeviceMemoryReportFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    deviceMemoryReport: u32 = 0,
};
// Extension: VK_EXT_device_memory_report
// Extends: VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: true
pub const VkDeviceDeviceMemoryReportCreateInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    flags: VkDeviceMemoryReportFlagsEXT = .{},
    // Extern sync: false
    // Optional: false
    pfnUserCallback: ?*const vkDeviceMemoryReportCallbackEXT = null,
    // Extern sync: false
    // Optional: true
    pUserData: ?*anyopaque = null,
};
// Extension: VK_EXT_device_memory_report
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkDeviceMemoryReportCallbackDataEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_DEVICE_MEMORY_REPORT_CALLBACK_DATA_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    flags: VkDeviceMemoryReportFlagsEXT = .{},
    // Extern sync: false
    // Optional: false
    type: VkDeviceMemoryReportEventTypeEXT = .VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATE_EXT,
    // Extern sync: false
    // Optional: false
    memoryObjectId: u64 = 0,
    // Extern sync: false
    // Optional: false
    size: u64 = 0,
    // Extern sync: false
    // Optional: false
    objectType: VkObjectType = .VK_OBJECT_TYPE_UNKNOWN,
    // Extern sync: false
    // Optional: false
    // Object type: objectType (Which object handle is this)
    objectHandle: u64 = 0,
    // Extern sync: false
    // Optional: false
    heapIndex: u32 = 0,
};
// Extension: VK_EXT_external_memory_host
// Extends: VkMemoryAllocateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImportMemoryHostPointerInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    handleType: VkExternalMemoryHandleTypeFlags = .{},
    // Extern sync: false
    // Optional: false
    pHostPointer: ?*anyopaque = null,
};
// Extension: VK_EXT_external_memory_host
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkMemoryHostPointerPropertiesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    memoryTypeBits: u32 = 0,
};
// Extension: VK_EXT_external_memory_host
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceExternalMemoryHostPropertiesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    minImportedHostPointerAlignment: u64 = 0,
};
// Extension: VK_EXT_conservative_rasterization
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceConservativeRasterizationPropertiesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: The size in pixels the primitive is enlarged at each edge during conservative rasterization
    primitiveOverestimationSize: f32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: The maximum additional overestimation the client can specify in the pipeline state
    maxExtraPrimitiveOverestimationSize: f32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: The granularity of extra overestimation sizes the implementations supports between 0 and maxExtraOverestimationSize
    extraPrimitiveOverestimationSizeGranularity: f32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: true if the implementation supports conservative rasterization underestimation mode
    primitiveUnderestimation: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: true if conservative rasterization also applies to points and lines
    conservativePointAndLineRasterization: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: true if degenerate triangles (those with zero area after snap) are rasterized
    degenerateTrianglesRasterized: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: true if degenerate lines (those with zero length after snap) are rasterized
    degenerateLinesRasterized: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: true if the implementation supports the FullyCoveredEXT SPIR-V builtin fragment shader input variable
    fullyCoveredFragmentShaderInputVariable: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: true if the implementation supports both conservative rasterization and post depth coverage sample coverage mask
    conservativeRasterizationPostDepthCoverage: u32 = 0,
};
// Extension: VK_EXT_calibrated_timestamps
// Extension: VK_KHR_calibrated_timestamps
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkCalibratedTimestampInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    timeDomain: VkTimeDomainKHR = .VK_TIME_DOMAIN_DEVICE_KHR,
};
// Extension: VK_AMD_shader_core_properties
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceShaderCorePropertiesAMD = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: number of shader engines
    shaderEngineCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: number of shader arrays
    shaderArraysPerEngineCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: number of physical CUs per shader array
    computeUnitsPerShaderArray: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: number of SIMDs per compute unit
    simdPerComputeUnit: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: number of wavefront slots in each SIMD
    wavefrontsPerSimd: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: maximum number of threads per wavefront
    wavefrontSize: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: number of physical SGPRs per SIMD
    sgprsPerSimd: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: minimum number of SGPRs that can be allocated by a wave
    minSgprAllocation: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: number of available SGPRs
    maxSgprAllocation: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: SGPRs are allocated in groups of this size
    sgprAllocationGranularity: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: number of physical VGPRs per SIMD
    vgprsPerSimd: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: minimum number of VGPRs that can be allocated by a wave
    minVgprAllocation: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: number of available VGPRs
    maxVgprAllocation: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: VGPRs are allocated in groups of this size
    vgprAllocationGranularity: u32 = 0,
};
// Extension: VK_AMD_shader_core_properties2
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceShaderCoreProperties2AMD = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    // Comment: Pointer to next structure
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: features supported by the shader core
    shaderCoreFeatures: VkShaderCorePropertiesFlagsAMD = .{},
    // Extern sync: false
    // Optional: false
    // Comment: number of active compute units across all shader engines/arrays
    activeComputeUnitCount: u32 = 0,
};
// Extension: VK_EXT_conservative_rasterization
// Extends: VkPipelineRasterizationStateCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineRasterizationConservativeStateCreateInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    // Comment: Reserved
    flags: VkPipelineRasterizationConservativeStateCreateFlagsEXT = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Conservative rasterization mode
    conservativeRasterizationMode: VkConservativeRasterizationModeEXT = .VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT,
    // Extern sync: false
    // Optional: false
    // Comment: Extra overestimation to add to the primitive
    extraPrimitiveOverestimationSize: f32 = 0,
};
// Extension: VK_EXT_descriptor_indexing
// Extension: VK_COMPUTE_VERSION_1_2
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceDescriptorIndexingFeatures = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    shaderInputAttachmentArrayDynamicIndexing: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderUniformTexelBufferArrayDynamicIndexing: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderStorageTexelBufferArrayDynamicIndexing: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderUniformBufferArrayNonUniformIndexing: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderSampledImageArrayNonUniformIndexing: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderStorageBufferArrayNonUniformIndexing: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderStorageImageArrayNonUniformIndexing: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderInputAttachmentArrayNonUniformIndexing: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderUniformTexelBufferArrayNonUniformIndexing: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderStorageTexelBufferArrayNonUniformIndexing: u32 = 0,
    // Extern sync: false
    // Optional: false
    descriptorBindingUniformBufferUpdateAfterBind: u32 = 0,
    // Extern sync: false
    // Optional: false
    descriptorBindingSampledImageUpdateAfterBind: u32 = 0,
    // Extern sync: false
    // Optional: false
    descriptorBindingStorageImageUpdateAfterBind: u32 = 0,
    // Extern sync: false
    // Optional: false
    descriptorBindingStorageBufferUpdateAfterBind: u32 = 0,
    // Extern sync: false
    // Optional: false
    descriptorBindingUniformTexelBufferUpdateAfterBind: u32 = 0,
    // Extern sync: false
    // Optional: false
    descriptorBindingStorageTexelBufferUpdateAfterBind: u32 = 0,
    // Extern sync: false
    // Optional: false
    descriptorBindingUpdateUnusedWhilePending: u32 = 0,
    // Extern sync: false
    // Optional: false
    descriptorBindingPartiallyBound: u32 = 0,
    // Extern sync: false
    // Optional: false
    descriptorBindingVariableDescriptorCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    runtimeDescriptorArray: u32 = 0,
};
// Extension: VK_EXT_descriptor_indexing
// Extension: VK_COMPUTE_VERSION_1_2
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceDescriptorIndexingProperties = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    maxUpdateAfterBindDescriptorsInAllPools: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderUniformBufferArrayNonUniformIndexingNative: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderSampledImageArrayNonUniformIndexingNative: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderStorageBufferArrayNonUniformIndexingNative: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderStorageImageArrayNonUniformIndexingNative: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderInputAttachmentArrayNonUniformIndexingNative: u32 = 0,
    // Extern sync: false
    // Optional: false
    robustBufferAccessUpdateAfterBind: u32 = 0,
    // Extern sync: false
    // Optional: false
    quadDivergentImplicitLod: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxPerStageDescriptorUpdateAfterBindSamplers: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxPerStageDescriptorUpdateAfterBindUniformBuffers: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxPerStageDescriptorUpdateAfterBindStorageBuffers: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxPerStageDescriptorUpdateAfterBindSampledImages: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxPerStageDescriptorUpdateAfterBindStorageImages: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxPerStageDescriptorUpdateAfterBindInputAttachments: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxPerStageUpdateAfterBindResources: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxDescriptorSetUpdateAfterBindSamplers: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxDescriptorSetUpdateAfterBindUniformBuffers: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxDescriptorSetUpdateAfterBindUniformBuffersDynamic: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxDescriptorSetUpdateAfterBindStorageBuffers: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxDescriptorSetUpdateAfterBindStorageBuffersDynamic: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxDescriptorSetUpdateAfterBindSampledImages: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxDescriptorSetUpdateAfterBindStorageImages: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxDescriptorSetUpdateAfterBindInputAttachments: u32 = 0,
};
// Extension: VK_EXT_descriptor_indexing
// Extension: VK_COMPUTE_VERSION_1_2
// Extends: VkDescriptorSetLayoutCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDescriptorSetLayoutBindingFlagsCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    bindingCount: u32 = 0,
    // Length expression: bindingCount
    // Extern sync: false
    // Optional: false
    pBindingFlags: ?[*]const VkDescriptorBindingFlags = null,
};
// Extension: VK_EXT_descriptor_indexing
// Extension: VK_COMPUTE_VERSION_1_2
// Extends: VkDescriptorSetAllocateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDescriptorSetVariableDescriptorCountAllocateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    descriptorSetCount: u32 = 0,
    // Length expression: descriptorSetCount
    // Extern sync: false
    // Optional: false
    pDescriptorCounts: ?[*]const u32 = null,
};
// Extension: VK_EXT_descriptor_indexing
// Extension: VK_COMPUTE_VERSION_1_2
// Extends: VkDescriptorSetLayoutSupport
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkDescriptorSetVariableDescriptorCountLayoutSupport = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    maxVariableDescriptorCount: u32 = 0,
};
// Extension: VK_KHR_create_renderpass2
// Extension: VK_GRAPHICS_VERSION_1_2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkAttachmentDescription2 = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkAttachmentDescriptionFlags = .{},
    // Extern sync: false
    // Optional: false
    format: VkFormat = .VK_FORMAT_UNDEFINED,
    // Extern sync: false
    // Optional: false
    samples: VkSampleCountFlags = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Load operation for color or depth data
    loadOp: VkAttachmentLoadOp = .VK_ATTACHMENT_LOAD_OP_LOAD,
    // Extern sync: false
    // Optional: false
    // Comment: Store operation for color or depth data
    storeOp: VkAttachmentStoreOp = .VK_ATTACHMENT_STORE_OP_STORE,
    // Extern sync: false
    // Optional: false
    // Comment: Load operation for stencil data
    stencilLoadOp: VkAttachmentLoadOp = .VK_ATTACHMENT_LOAD_OP_LOAD,
    // Extern sync: false
    // Optional: false
    // Comment: Store operation for stencil data
    stencilStoreOp: VkAttachmentStoreOp = .VK_ATTACHMENT_STORE_OP_STORE,
    // Extern sync: false
    // Optional: false
    initialLayout: VkImageLayout = .VK_IMAGE_LAYOUT_UNDEFINED,
    // Extern sync: false
    // Optional: false
    finalLayout: VkImageLayout = .VK_IMAGE_LAYOUT_UNDEFINED,
};
// Extension: VK_KHR_create_renderpass2
// Extension: VK_GRAPHICS_VERSION_1_2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkAttachmentReference2 = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    attachment: u32 = 0,
    // Extern sync: false
    // Optional: false
    layout: VkImageLayout = .VK_IMAGE_LAYOUT_UNDEFINED,
    // Extern sync: false
    // Optional: false
    aspectMask: VkImageAspectFlags = .{},
};
// Extension: VK_KHR_create_renderpass2
// Extension: VK_GRAPHICS_VERSION_1_2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSubpassDescription2 = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkSubpassDescriptionFlags = .{},
    // Extern sync: false
    // Optional: false
    pipelineBindPoint: VkPipelineBindPoint = .VK_PIPELINE_BIND_POINT_GRAPHICS,
    // Extern sync: false
    // Optional: false
    viewMask: u32 = 0,
    // Extern sync: false
    // Optional: true
    inputAttachmentCount: u32 = 0,
    // Length expression: inputAttachmentCount
    // Extern sync: false
    // Optional: false
    pInputAttachments: ?[*]const VkAttachmentReference2 = null,
    // Extern sync: false
    // Optional: true
    colorAttachmentCount: u32 = 0,
    // Length expression: colorAttachmentCount
    // Extern sync: false
    // Optional: false
    pColorAttachments: ?[*]const VkAttachmentReference2 = null,
    // Length expression: colorAttachmentCount
    // Extern sync: false
    // Optional: true
    pResolveAttachments: ?[*]const VkAttachmentReference2 = null,
    // Extern sync: false
    // Optional: true
    pDepthStencilAttachment: ?*const VkAttachmentReference2 = null,
    // Extern sync: false
    // Optional: true
    preserveAttachmentCount: u32 = 0,
    // Length expression: preserveAttachmentCount
    // Extern sync: false
    // Optional: false
    pPreserveAttachments: ?[*]const u32 = null,
};
// Extension: VK_KHR_create_renderpass2
// Extension: VK_GRAPHICS_VERSION_1_2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSubpassDependency2 = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    srcSubpass: u32 = 0,
    // Extern sync: false
    // Optional: false
    dstSubpass: u32 = 0,
    // Extern sync: false
    // Optional: true
    srcStageMask: VkPipelineStageFlags = .{},
    // Extern sync: false
    // Optional: true
    dstStageMask: VkPipelineStageFlags = .{},
    // Extern sync: false
    // Optional: true
    srcAccessMask: VkAccessFlags = .{},
    // Extern sync: false
    // Optional: true
    dstAccessMask: VkAccessFlags = .{},
    // Extern sync: false
    // Optional: true
    dependencyFlags: VkDependencyFlags = .{},
    // Extern sync: false
    // Optional: false
    viewOffset: i32 = 0,
};
// Extension: VK_KHR_create_renderpass2
// Extension: VK_GRAPHICS_VERSION_1_2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkRenderPassCreateInfo2 = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkRenderPassCreateFlags = .{},
    // Extern sync: false
    // Optional: true
    attachmentCount: u32 = 0,
    // Length expression: attachmentCount
    // Extern sync: false
    // Optional: false
    pAttachments: ?[*]const VkAttachmentDescription2 = null,
    // Extern sync: false
    // Optional: false
    subpassCount: u32 = 0,
    // Length expression: subpassCount
    // Extern sync: false
    // Optional: false
    pSubpasses: ?[*]const VkSubpassDescription2 = null,
    // Extern sync: false
    // Optional: true
    dependencyCount: u32 = 0,
    // Length expression: dependencyCount
    // Extern sync: false
    // Optional: false
    pDependencies: ?[*]const VkSubpassDependency2 = null,
    // Extern sync: false
    // Optional: true
    correlatedViewMaskCount: u32 = 0,
    // Length expression: correlatedViewMaskCount
    // Extern sync: false
    // Optional: false
    pCorrelatedViewMasks: ?[*]const u32 = null,
};
// Extension: VK_KHR_create_renderpass2
// Extension: VK_GRAPHICS_VERSION_1_2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSubpassBeginInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    contents: VkSubpassContents = .VK_SUBPASS_CONTENTS_INLINE,
};
// Extension: VK_KHR_create_renderpass2
// Extension: VK_GRAPHICS_VERSION_1_2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSubpassEndInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_SUBPASS_END_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
};
// Extension: VK_KHR_timeline_semaphore
// Extension: VK_BASE_VERSION_1_2
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceTimelineSemaphoreFeatures = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    timelineSemaphore: u32 = 0,
};
// Extension: VK_KHR_timeline_semaphore
// Extension: VK_BASE_VERSION_1_2
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceTimelineSemaphoreProperties = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    maxTimelineSemaphoreValueDifference: u64 = 0,
};
// Extension: VK_KHR_timeline_semaphore
// Extension: VK_BASE_VERSION_1_2
// Extends: VkSemaphoreCreateInfo,VkPhysicalDeviceExternalSemaphoreInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSemaphoreTypeCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    semaphoreType: VkSemaphoreType = .VK_SEMAPHORE_TYPE_BINARY,
    // Extern sync: false
    // Optional: false
    initialValue: u64 = 0,
};
// Extension: VK_KHR_timeline_semaphore
// Extension: VK_BASE_VERSION_1_2
// Extends: VkSubmitInfo,VkBindSparseInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkTimelineSemaphoreSubmitInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    waitSemaphoreValueCount: u32 = 0,
    // Length expression: waitSemaphoreValueCount
    // Extern sync: false
    // Optional: true
    pWaitSemaphoreValues: ?[*]const u64 = null,
    // Extern sync: false
    // Optional: true
    signalSemaphoreValueCount: u32 = 0,
    // Length expression: signalSemaphoreValueCount
    // Extern sync: false
    // Optional: true
    pSignalSemaphoreValues: ?[*]const u64 = null,
};
// Extension: VK_KHR_timeline_semaphore
// Extension: VK_BASE_VERSION_1_2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSemaphoreWaitInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkSemaphoreWaitFlags = .{},
    // Extern sync: false
    // Optional: false
    semaphoreCount: u32 = 0,
    // Length expression: semaphoreCount
    // Extern sync: false
    // Optional: false
    pSemaphores: ?[*]const VkSemaphore = null,
    // Length expression: semaphoreCount
    // Extern sync: false
    // Optional: false
    pValues: ?[*]const u64 = null,
};
// Extension: VK_KHR_timeline_semaphore
// Extension: VK_BASE_VERSION_1_2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSemaphoreSignalInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    semaphore: VkSemaphore = .none,
    // Extern sync: false
    // Optional: false
    value: u64 = 0,
};
// Extension: VK_KHR_vertex_attribute_divisor
// Extension: VK_EXT_vertex_attribute_divisor
// Extension: VK_GRAPHICS_VERSION_1_4
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVertexInputBindingDivisorDescription = extern struct {
    // Extern sync: false
    // Optional: false
    binding: u32 = 0,
    // Extern sync: false
    // Optional: false
    divisor: u32 = 0,
};
// Extension: VK_KHR_vertex_attribute_divisor
// Extension: VK_EXT_vertex_attribute_divisor
// Extension: VK_GRAPHICS_VERSION_1_4
// Extends: VkPipelineVertexInputStateCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineVertexInputDivisorStateCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    vertexBindingDivisorCount: u32 = 0,
    // Length expression: vertexBindingDivisorCount
    // Extern sync: false
    // Optional: false
    pVertexBindingDivisors: ?[*]const VkVertexInputBindingDivisorDescription = null,
};
// Extension: VK_EXT_vertex_attribute_divisor
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: max value of vertex attribute divisor
    maxVertexAttribDivisor: u32 = 0,
};
// Extension: VK_KHR_vertex_attribute_divisor
// Extension: VK_GRAPHICS_VERSION_1_4
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceVertexAttributeDivisorProperties = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: max value of vertex attribute divisor
    maxVertexAttribDivisor: u32 = 0,
    // Extern sync: false
    // Optional: false
    supportsNonZeroFirstInstance: u32 = 0,
};
// Extension: VK_EXT_pci_bus_info
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDevicePCIBusInfoPropertiesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    pciDomain: u32 = 0,
    // Extern sync: false
    // Optional: false
    pciBus: u32 = 0,
    // Extern sync: false
    // Optional: false
    pciDevice: u32 = 0,
    // Extern sync: false
    // Optional: false
    pciFunction: u32 = 0,
};
// Extension: VK_ANDROID_external_memory_android_hardware_buffer
// Extends: VkMemoryAllocateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImportAndroidHardwareBufferInfoANDROID = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    buffer: ?*AHardwareBuffer = null,
};
// Extension: VK_ANDROID_external_memory_android_hardware_buffer
// Extends: VkImageFormatProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkAndroidHardwareBufferUsageANDROID = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    androidHardwareBufferUsage: u64 = 0,
};
// Extension: VK_ANDROID_external_memory_android_hardware_buffer
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkAndroidHardwareBufferPropertiesANDROID = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    allocationSize: u64 = 0,
    // Extern sync: false
    // Optional: false
    memoryTypeBits: u32 = 0,
};
// Extension: VK_ANDROID_external_memory_android_hardware_buffer
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkMemoryGetAndroidHardwareBufferInfoANDROID = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    memory: VkDeviceMemory = .none,
};
// Extension: VK_ANDROID_external_memory_android_hardware_buffer
// Extends: VkAndroidHardwareBufferPropertiesANDROID
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkAndroidHardwareBufferFormatPropertiesANDROID = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    format: VkFormat = .VK_FORMAT_UNDEFINED,
    // Extern sync: false
    // Optional: false
    externalFormat: u64 = 0,
    // Extern sync: false
    // Optional: false
    formatFeatures: VkFormatFeatureFlags = .{},
    // Extern sync: false
    // Optional: false
    samplerYcbcrConversionComponents: VkComponentMapping = .{},
    // Extern sync: false
    // Optional: false
    suggestedYcbcrModel: VkSamplerYcbcrModelConversion = .VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY,
    // Extern sync: false
    // Optional: false
    suggestedYcbcrRange: VkSamplerYcbcrRange = .VK_SAMPLER_YCBCR_RANGE_ITU_FULL,
    // Extern sync: false
    // Optional: false
    suggestedXChromaOffset: VkChromaLocation = .VK_CHROMA_LOCATION_COSITED_EVEN,
    // Extern sync: false
    // Optional: false
    suggestedYChromaOffset: VkChromaLocation = .VK_CHROMA_LOCATION_COSITED_EVEN,
};
// Extension: VK_EXT_conditional_rendering
// Extends: VkCommandBufferInheritanceInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkCommandBufferInheritanceConditionalRenderingInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: Whether this secondary command buffer may be executed during an active conditional rendering
    conditionalRenderingEnable: u32 = 0,
};
// Extension: VK_ANDROID_external_memory_android_hardware_buffer
// Extends: VkImageCreateInfo,VkSamplerYcbcrConversionCreateInfo,VkAttachmentDescription2,VkGraphicsPipelineCreateInfo,VkCommandBufferInheritanceInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkExternalFormatANDROID = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    externalFormat: u64 = 0,
};
// Extension: VK_KHR_8bit_storage
// Extension: VK_COMPUTE_VERSION_1_2
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDevice8BitStorageFeatures = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: 8-bit integer variables supported in StorageBuffer
    storageBuffer8BitAccess: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: 8-bit integer variables supported in StorageBuffer and Uniform
    uniformAndStorageBuffer8BitAccess: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: 8-bit integer variables supported in PushConstant
    storagePushConstant8: u32 = 0,
};
// Extension: VK_EXT_conditional_rendering
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceConditionalRenderingFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    conditionalRendering: u32 = 0,
    // Extern sync: false
    // Optional: false
    inheritedConditionalRendering: u32 = 0,
};
// Extension: VK_KHR_vulkan_memory_model
// Extension: VK_BASE_VERSION_1_2
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceVulkanMemoryModelFeatures = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    vulkanMemoryModel: u32 = 0,
    // Extern sync: false
    // Optional: false
    vulkanMemoryModelDeviceScope: u32 = 0,
    // Extern sync: false
    // Optional: false
    vulkanMemoryModelAvailabilityVisibilityChains: u32 = 0,
};
// Extension: VK_KHR_shader_atomic_int64
// Extension: VK_COMPUTE_VERSION_1_2
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceShaderAtomicInt64Features = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    shaderBufferInt64Atomics: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderSharedInt64Atomics: u32 = 0,
};
// Extension: VK_EXT_shader_atomic_float
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceShaderAtomicFloatFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    shaderBufferFloat32Atomics: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderBufferFloat32AtomicAdd: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderBufferFloat64Atomics: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderBufferFloat64AtomicAdd: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderSharedFloat32Atomics: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderSharedFloat32AtomicAdd: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderSharedFloat64Atomics: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderSharedFloat64AtomicAdd: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderImageFloat32Atomics: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderImageFloat32AtomicAdd: u32 = 0,
    // Extern sync: false
    // Optional: false
    sparseImageFloat32Atomics: u32 = 0,
    // Extern sync: false
    // Optional: false
    sparseImageFloat32AtomicAdd: u32 = 0,
};
// Extension: VK_EXT_shader_atomic_float2
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    shaderBufferFloat16Atomics: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderBufferFloat16AtomicAdd: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderBufferFloat16AtomicMinMax: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderBufferFloat32AtomicMinMax: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderBufferFloat64AtomicMinMax: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderSharedFloat16Atomics: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderSharedFloat16AtomicAdd: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderSharedFloat16AtomicMinMax: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderSharedFloat32AtomicMinMax: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderSharedFloat64AtomicMinMax: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderImageFloat32AtomicMinMax: u32 = 0,
    // Extern sync: false
    // Optional: false
    sparseImageFloat32AtomicMinMax: u32 = 0,
};
// Extension: VK_KHR_vertex_attribute_divisor
// Extension: VK_EXT_vertex_attribute_divisor
// Extension: VK_GRAPHICS_VERSION_1_4
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceVertexAttributeDivisorFeatures = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    vertexAttributeInstanceRateDivisor: u32 = 0,
    // Extern sync: false
    // Optional: false
    vertexAttributeInstanceRateZeroDivisor: u32 = 0,
};
// Extension: VK_NV_device_diagnostic_checkpoints
// Extends: VkQueueFamilyProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkQueueFamilyCheckpointPropertiesNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    checkpointExecutionStageMask: VkPipelineStageFlags = .{},
};
// Extension: VK_NV_device_diagnostic_checkpoints
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkCheckpointDataNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    stage: VkPipelineStageFlags = .{},
    // Extern sync: false
    // Optional: false
    pCheckpointMarker: ?*anyopaque = null,
};
// Extension: VK_KHR_depth_stencil_resolve
// Extension: VK_GRAPHICS_VERSION_1_2
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceDepthStencilResolveProperties = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: supported depth resolve modes
    supportedDepthResolveModes: VkResolveModeFlags = .{},
    // Extern sync: false
    // Optional: false
    // Comment: supported stencil resolve modes
    supportedStencilResolveModes: VkResolveModeFlags = .{},
    // Extern sync: false
    // Optional: false
    // Comment: depth and stencil resolve modes can be set independently if one of them is none
    independentResolveNone: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: depth and stencil resolve modes can be set independently
    independentResolve: u32 = 0,
};
// Extension: VK_KHR_depth_stencil_resolve
// Extension: VK_GRAPHICS_VERSION_1_2
// Extends: VkSubpassDescription2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSubpassDescriptionDepthStencilResolve = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: depth resolve mode
    depthResolveMode: VkResolveModeFlags = .{},
    // Extern sync: false
    // Optional: false
    // Comment: stencil resolve mode
    stencilResolveMode: VkResolveModeFlags = .{},
    // Extern sync: false
    // Optional: true
    // Comment: depth/stencil resolve attachment
    pDepthStencilResolveAttachment: ?*const VkAttachmentReference2 = null,
};
// Extension: VK_EXT_astc_decode_mode
// Extends: VkImageViewCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImageViewASTCDecodeModeEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    decodeMode: VkFormat = .VK_FORMAT_UNDEFINED,
};
// Extension: VK_EXT_astc_decode_mode
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceASTCDecodeFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    decodeModeSharedExponent: u32 = 0,
};
// Extension: VK_EXT_transform_feedback
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceTransformFeedbackFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    transformFeedback: u32 = 0,
    // Extern sync: false
    // Optional: false
    geometryStreams: u32 = 0,
};
// Extension: VK_EXT_transform_feedback
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceTransformFeedbackPropertiesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    maxTransformFeedbackStreams: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxTransformFeedbackBuffers: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxTransformFeedbackBufferSize: u64 = 0,
    // Extern sync: false
    // Optional: false
    maxTransformFeedbackStreamDataSize: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxTransformFeedbackBufferDataSize: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxTransformFeedbackBufferDataStride: u32 = 0,
    // Extern sync: false
    // Optional: false
    transformFeedbackQueries: u32 = 0,
    // Extern sync: false
    // Optional: false
    transformFeedbackStreamsLinesTriangles: u32 = 0,
    // Extern sync: false
    // Optional: false
    transformFeedbackRasterizationStreamSelect: u32 = 0,
    // Extern sync: false
    // Optional: false
    transformFeedbackDraw: u32 = 0,
};
// Extension: VK_EXT_transform_feedback
// Extends: VkPipelineRasterizationStateCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineRasterizationStateStreamCreateInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkPipelineRasterizationStateStreamCreateFlagsEXT = .{},
    // Extern sync: false
    // Optional: false
    rasterizationStream: u32 = 0,
};
// Extension: VK_NV_representative_fragment_test
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    representativeFragmentTest: u32 = 0,
};
// Extension: VK_NV_representative_fragment_test
// Extends: VkGraphicsPipelineCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineRepresentativeFragmentTestStateCreateInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    representativeFragmentTestEnable: u32 = 0,
};
// Extension: VK_NV_scissor_exclusive
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceExclusiveScissorFeaturesNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    exclusiveScissor: u32 = 0,
};
// Extension: VK_NV_scissor_exclusive
// Extends: VkPipelineViewportStateCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineViewportExclusiveScissorStateCreateInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    exclusiveScissorCount: u32 = 0,
    // Length expression: exclusiveScissorCount
    // Extern sync: false
    // Optional: false
    pExclusiveScissors: ?[*]const VkRect2D = null,
};
// Extension: VK_NV_corner_sampled_image
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceCornerSampledImageFeaturesNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    cornerSampledImage: u32 = 0,
};
// Extension: VK_NV_compute_shader_derivatives
// Extension: VK_KHR_compute_shader_derivatives
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    computeDerivativeGroupQuads: u32 = 0,
    // Extern sync: false
    // Optional: false
    computeDerivativeGroupLinear: u32 = 0,
};
// Extension: VK_KHR_compute_shader_derivatives
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceComputeShaderDerivativesPropertiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_PROPERTIES_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    meshAndTaskShaderDerivatives: u32 = 0,
};
// Extension: VK_NV_shader_image_footprint
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceShaderImageFootprintFeaturesNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    imageFootprint: u32 = 0,
};
// Extension: VK_NV_dedicated_allocation_image_aliasing
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    dedicatedAllocationImageAliasing: u32 = 0,
};
// Extension: VK_KHR_copy_memory_indirect
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceCopyMemoryIndirectFeaturesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_FEATURES_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    indirectMemoryCopy: u32 = 0,
    // Extern sync: false
    // Optional: false
    indirectMemoryToImageCopy: u32 = 0,
};
// Extension: VK_NV_copy_memory_indirect
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceCopyMemoryIndirectFeaturesNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_FEATURES_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    indirectCopy: u32 = 0,
};
// Extension: VK_NV_copy_memory_indirect
// Extension: VK_KHR_copy_memory_indirect
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceCopyMemoryIndirectPropertiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_PROPERTIES_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: Bitmask of VkQueueFlagBits indicating the family of queues that support indirect copy
    supportedQueues: VkQueueFlags = .{},
};
// Extension: VK_NV_memory_decompression
// Extension: VK_EXT_memory_decompression
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceMemoryDecompressionFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_FEATURES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    memoryDecompression: u32 = 0,
};
// Extension: VK_NV_memory_decompression
// Extension: VK_EXT_memory_decompression
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceMemoryDecompressionPropertiesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_PROPERTIES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    decompressionMethods: VkMemoryDecompressionMethodFlagsEXT = .{},
    // Extern sync: false
    // Optional: false
    maxDecompressionIndirectCount: u64 = 0,
};
// Extension: VK_NV_shading_rate_image
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkShadingRatePaletteNV = extern struct {
    // Extern sync: false
    // Optional: false
    shadingRatePaletteEntryCount: u32 = 0,
    // Length expression: shadingRatePaletteEntryCount
    // Extern sync: false
    // Optional: false
    pShadingRatePaletteEntries: ?[*]const VkShadingRatePaletteEntryNV = null,
};
// Extension: VK_NV_shading_rate_image
// Extends: VkPipelineViewportStateCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineViewportShadingRateImageStateCreateInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    shadingRateImageEnable: u32 = 0,
    // Extern sync: false
    // Optional: true
    viewportCount: u32 = 0,
    // Length expression: viewportCount
    // Extern sync: false
    // Optional: false
    pShadingRatePalettes: ?[*]const VkShadingRatePaletteNV = null,
};
// Extension: VK_NV_shading_rate_image
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceShadingRateImageFeaturesNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    shadingRateImage: u32 = 0,
    // Extern sync: false
    // Optional: false
    shadingRateCoarseSampleOrder: u32 = 0,
};
// Extension: VK_NV_shading_rate_image
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceShadingRateImagePropertiesNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    shadingRateTexelSize: VkExtent2D = .{},
    // Extern sync: false
    // Optional: false
    shadingRatePaletteSize: u32 = 0,
    // Extern sync: false
    // Optional: false
    shadingRateMaxCoarseSamples: u32 = 0,
};
// Extension: VK_HUAWEI_invocation_mask
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceInvocationMaskFeaturesHUAWEI = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    invocationMask: u32 = 0,
};
// Extension: VK_NV_shading_rate_image
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkCoarseSampleLocationNV = extern struct {
    // Extern sync: false
    // Optional: false
    pixelX: u32 = 0,
    // Extern sync: false
    // Optional: false
    pixelY: u32 = 0,
    // Extern sync: false
    // Optional: false
    sample: u32 = 0,
};
// Extension: VK_NV_shading_rate_image
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkCoarseSampleOrderCustomNV = extern struct {
    // Extern sync: false
    // Optional: false
    shadingRate: VkShadingRatePaletteEntryNV = .VK_SHADING_RATE_PALETTE_ENTRY_NO_INVOCATIONS_NV,
    // Extern sync: false
    // Optional: false
    sampleCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    sampleLocationCount: u32 = 0,
    // Length expression: sampleLocationCount
    // Extern sync: false
    // Optional: false
    pSampleLocations: ?[*]const VkCoarseSampleLocationNV = null,
};
// Extension: VK_NV_shading_rate_image
// Extends: VkPipelineViewportStateCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineViewportCoarseSampleOrderStateCreateInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    sampleOrderType: VkCoarseSampleOrderTypeNV = .VK_COARSE_SAMPLE_ORDER_TYPE_DEFAULT_NV,
    // Extern sync: false
    // Optional: true
    customSampleOrderCount: u32 = 0,
    // Length expression: customSampleOrderCount
    // Extern sync: false
    // Optional: false
    pCustomSampleOrders: ?[*]const VkCoarseSampleOrderCustomNV = null,
};
// Extension: VK_NV_mesh_shader
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceMeshShaderFeaturesNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Feature link: taskShaderNV
    taskShader: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Feature link: meshShaderNV
    meshShader: u32 = 0,
};
// Extension: VK_NV_mesh_shader
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceMeshShaderPropertiesNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    maxDrawMeshTasksCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxTaskWorkGroupInvocations: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxTaskWorkGroupSize: [3]u32 = @import("std").mem.zeroes([3]u32),
    // Extern sync: false
    // Optional: false
    maxTaskTotalMemorySize: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxTaskOutputCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxMeshWorkGroupInvocations: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxMeshWorkGroupSize: [3]u32 = @import("std").mem.zeroes([3]u32),
    // Extern sync: false
    // Optional: false
    maxMeshTotalMemorySize: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxMeshOutputVertices: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxMeshOutputPrimitives: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxMeshMultiviewViewCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    meshOutputPerVertexGranularity: u32 = 0,
    // Extern sync: false
    // Optional: false
    meshOutputPerPrimitiveGranularity: u32 = 0,
};
// Extension: VK_NV_mesh_shader
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDrawMeshTasksIndirectCommandNV = extern struct {
    // Extern sync: false
    // Optional: false
    taskCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    firstTask: u32 = 0,
};
// Extension: VK_EXT_mesh_shader
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceMeshShaderFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    taskShader: u32 = 0,
    // Extern sync: false
    // Optional: false
    meshShader: u32 = 0,
    // Extern sync: false
    // Optional: false
    multiviewMeshShader: u32 = 0,
    // Extern sync: false
    // Optional: false
    primitiveFragmentShadingRateMeshShader: u32 = 0,
    // Extern sync: false
    // Optional: false
    meshShaderQueries: u32 = 0,
};
// Extension: VK_EXT_mesh_shader
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceMeshShaderPropertiesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    maxTaskWorkGroupTotalCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxTaskWorkGroupCount: [3]u32 = @import("std").mem.zeroes([3]u32),
    // Extern sync: false
    // Optional: false
    maxTaskWorkGroupInvocations: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxTaskWorkGroupSize: [3]u32 = @import("std").mem.zeroes([3]u32),
    // Extern sync: false
    // Optional: false
    maxTaskPayloadSize: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxTaskSharedMemorySize: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxTaskPayloadAndSharedMemorySize: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxMeshWorkGroupTotalCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxMeshWorkGroupCount: [3]u32 = @import("std").mem.zeroes([3]u32),
    // Extern sync: false
    // Optional: false
    maxMeshWorkGroupInvocations: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxMeshWorkGroupSize: [3]u32 = @import("std").mem.zeroes([3]u32),
    // Extern sync: false
    // Optional: false
    maxMeshSharedMemorySize: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxMeshPayloadAndSharedMemorySize: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxMeshOutputMemorySize: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxMeshPayloadAndOutputMemorySize: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxMeshOutputComponents: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxMeshOutputVertices: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxMeshOutputPrimitives: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxMeshOutputLayers: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxMeshMultiviewViewCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    meshOutputPerVertexGranularity: u32 = 0,
    // Extern sync: false
    // Optional: false
    meshOutputPerPrimitiveGranularity: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxPreferredTaskWorkGroupInvocations: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxPreferredMeshWorkGroupInvocations: u32 = 0,
    // Extern sync: false
    // Optional: false
    prefersLocalInvocationVertexOutput: u32 = 0,
    // Extern sync: false
    // Optional: false
    prefersLocalInvocationPrimitiveOutput: u32 = 0,
    // Extern sync: false
    // Optional: false
    prefersCompactVertexOutput: u32 = 0,
    // Extern sync: false
    // Optional: false
    prefersCompactPrimitiveOutput: u32 = 0,
};
// Extension: VK_EXT_mesh_shader
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDrawMeshTasksIndirectCommandEXT = extern struct {
    // Extern sync: false
    // Optional: false
    groupCountX: u32 = 0,
    // Extern sync: false
    // Optional: false
    groupCountY: u32 = 0,
    // Extern sync: false
    // Optional: false
    groupCountZ: u32 = 0,
};
// Extension: VK_NV_ray_tracing
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkRayTracingShaderGroupCreateInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    type: VkRayTracingShaderGroupTypeKHR = .VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR,
    // Extern sync: false
    // Optional: false
    generalShader: u32 = 0,
    // Extern sync: false
    // Optional: false
    closestHitShader: u32 = 0,
    // Extern sync: false
    // Optional: false
    anyHitShader: u32 = 0,
    // Extern sync: false
    // Optional: false
    intersectionShader: u32 = 0,
};
// Extension: VK_KHR_ray_tracing_pipeline
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkRayTracingShaderGroupCreateInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    type: VkRayTracingShaderGroupTypeKHR = .VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR,
    // Extern sync: false
    // Optional: false
    generalShader: u32 = 0,
    // Extern sync: false
    // Optional: false
    closestHitShader: u32 = 0,
    // Extern sync: false
    // Optional: false
    anyHitShader: u32 = 0,
    // Extern sync: false
    // Optional: false
    intersectionShader: u32 = 0,
    // Extern sync: false
    // Optional: true
    pShaderGroupCaptureReplayHandle: ?*const anyopaque = null,
};
// Extension: VK_NV_ray_tracing
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkRayTracingPipelineCreateInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    // Comment: Pipeline creation flags
    flags: VkPipelineCreateFlags = .{},
    // Extern sync: false
    // Optional: false
    stageCount: u32 = 0,
    // Length expression: stageCount
    // Extern sync: false
    // Optional: false
    // Comment: One entry for each active shader stage
    pStages: ?[*]const VkPipelineShaderStageCreateInfo = null,
    // Extern sync: false
    // Optional: false
    groupCount: u32 = 0,
    // Length expression: groupCount
    // Extern sync: false
    // Optional: false
    pGroups: ?[*]const VkRayTracingShaderGroupCreateInfoNV = null,
    // Extern sync: false
    // Optional: false
    maxRecursionDepth: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Interface layout of the pipeline
    layout: VkPipelineLayout = .none,
    // Extern sync: false
    // Optional: true
    // Comment: If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is nonzero, it specifies the handle of the base pipeline this is a derivative of
    basePipelineHandle: VkPipeline = .none,
    // Extern sync: false
    // Optional: false
    // Comment: If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is not -1, it specifies an index into pCreateInfos of the base pipeline this is a derivative of
    basePipelineIndex: i32 = 0,
};
// Extension: VK_KHR_ray_tracing_pipeline
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkRayTracingPipelineCreateInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    // Comment: Pipeline creation flags
    flags: VkPipelineCreateFlags = .{},
    // Extern sync: false
    // Optional: true
    stageCount: u32 = 0,
    // Length expression: stageCount
    // Extern sync: false
    // Optional: false
    // Comment: One entry for each active shader stage
    pStages: ?[*]const VkPipelineShaderStageCreateInfo = null,
    // Extern sync: false
    // Optional: true
    groupCount: u32 = 0,
    // Length expression: groupCount
    // Extern sync: false
    // Optional: false
    pGroups: ?[*]const VkRayTracingShaderGroupCreateInfoKHR = null,
    // Extern sync: false
    // Optional: false
    maxPipelineRayRecursionDepth: u32 = 0,
    // Extern sync: false
    // Optional: true
    pLibraryInfo: ?*const VkPipelineLibraryCreateInfoKHR = null,
    // Extern sync: false
    // Optional: true
    pLibraryInterface: ?*const VkRayTracingPipelineInterfaceCreateInfoKHR = null,
    // Extern sync: false
    // Optional: true
    pDynamicState: ?*const VkPipelineDynamicStateCreateInfo = null,
    // Extern sync: false
    // Optional: false
    // Comment: Interface layout of the pipeline
    layout: VkPipelineLayout = .none,
    // Extern sync: false
    // Optional: true
    // Comment: If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is nonzero, it specifies the handle of the base pipeline this is a derivative of
    basePipelineHandle: VkPipeline = .none,
    // Extern sync: false
    // Optional: false
    // Comment: If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is not -1, it specifies an index into pCreateInfos of the base pipeline this is a derivative of
    basePipelineIndex: i32 = 0,
};
// Extension: VK_NV_ray_tracing
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkGeometryTrianglesNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    vertexData: VkBuffer = .none,
    // Extern sync: false
    // Optional: false
    vertexOffset: u64 = 0,
    // Extern sync: false
    // Optional: false
    vertexCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    vertexStride: u64 = 0,
    // Extern sync: false
    // Optional: false
    vertexFormat: VkFormat = .VK_FORMAT_UNDEFINED,
    // Extern sync: false
    // Optional: true
    indexData: VkBuffer = .none,
    // Extern sync: false
    // Optional: false
    indexOffset: u64 = 0,
    // Extern sync: false
    // Optional: false
    indexCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    indexType: VkIndexType = .VK_INDEX_TYPE_UINT16,
    // Extern sync: false
    // Optional: true
    // Comment: Optional reference to array of floats representing a 3x4 row major affine transformation matrix.
    transformData: VkBuffer = .none,
    // Extern sync: false
    // Optional: false
    transformOffset: u64 = 0,
};
// Extension: VK_NV_ray_tracing
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkGeometryAABBNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_GEOMETRY_AABB_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    aabbData: VkBuffer = .none,
    // Extern sync: false
    // Optional: false
    numAABBs: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Stride in bytes between AABBs
    stride: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Offset in bytes of the first AABB in aabbData
    offset: u64 = 0,
};
// Extension: VK_NV_ray_tracing
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkGeometryDataNV = extern struct {
    // Extern sync: false
    // Optional: false
    triangles: VkGeometryTrianglesNV = .{},
    // Extern sync: false
    // Optional: false
    aabbs: VkGeometryAABBNV = .{},
};
// Extension: VK_NV_ray_tracing
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkGeometryNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_GEOMETRY_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    geometryType: VkGeometryTypeKHR = .VK_GEOMETRY_TYPE_TRIANGLES_KHR,
    // Extern sync: false
    // Optional: false
    geometry: VkGeometryDataNV = .{},
    // Extern sync: false
    // Optional: true
    flags: VkGeometryFlagsKHR = .{},
};
// Extension: VK_NV_ray_tracing
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkAccelerationStructureInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    type: VkAccelerationStructureTypeKHR = .VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR,
    // Extern sync: false
    // Optional: true
    // Extern sync: false
    // Optional: true
    instanceCount: u32 = 0,
    // Extern sync: false
    // Optional: true
    geometryCount: u32 = 0,
    // Length expression: geometryCount
    // Extern sync: false
    // Optional: false
    pGeometries: ?[*]const VkGeometryNV = null,
};
// Extension: VK_NV_ray_tracing
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkAccelerationStructureCreateInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    compactedSize: u64 = 0,
    // Extern sync: false
    // Optional: false
    info: VkAccelerationStructureInfoNV = .{},
};
// Extension: VK_NV_ray_tracing
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkBindAccelerationStructureMemoryInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    accelerationStructure: VkAccelerationStructureNV = .none,
    // Extern sync: false
    // Optional: false
    memory: VkDeviceMemory = .none,
    // Extern sync: false
    // Optional: false
    memoryOffset: u64 = 0,
    // Extern sync: false
    // Optional: true
    deviceIndexCount: u32 = 0,
    // Length expression: deviceIndexCount
    // Extern sync: false
    // Optional: false
    pDeviceIndices: ?[*]const u32 = null,
};
// Extension: VK_KHR_acceleration_structure
// Extends: VkWriteDescriptorSet
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkWriteDescriptorSetAccelerationStructureKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    accelerationStructureCount: u32 = 0,
    // Length expression: accelerationStructureCount
    // Extern sync: false
    // Optional: false
    pAccelerationStructures: ?[*]const VkAccelerationStructureKHR = null,
};
// Extension: VK_NV_ray_tracing
// Extends: VkWriteDescriptorSet
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkWriteDescriptorSetAccelerationStructureNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    accelerationStructureCount: u32 = 0,
    // Length expression: accelerationStructureCount
    // Extern sync: false
    // Optional: false
    pAccelerationStructures: ?[*]const VkAccelerationStructureNV = null,
};
// Extension: VK_NV_ray_tracing
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkAccelerationStructureMemoryRequirementsInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    type: VkAccelerationStructureMemoryRequirementsTypeNV = .VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_OBJECT_NV,
    // Extern sync: false
    // Optional: false
    accelerationStructure: VkAccelerationStructureNV = .none,
};
// Extension: VK_KHR_acceleration_structure
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceAccelerationStructureFeaturesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    accelerationStructure: u32 = 0,
    // Extern sync: false
    // Optional: false
    accelerationStructureCaptureReplay: u32 = 0,
    // Extern sync: false
    // Optional: false
    accelerationStructureIndirectBuild: u32 = 0,
    // Extern sync: false
    // Optional: false
    accelerationStructureHostCommands: u32 = 0,
    // Extern sync: false
    // Optional: false
    descriptorBindingAccelerationStructureUpdateAfterBind: u32 = 0,
};
// Extension: VK_KHR_ray_tracing_pipeline
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceRayTracingPipelineFeaturesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    rayTracingPipeline: u32 = 0,
    // Extern sync: false
    // Optional: false
    rayTracingPipelineShaderGroupHandleCaptureReplay: u32 = 0,
    // Extern sync: false
    // Optional: false
    rayTracingPipelineShaderGroupHandleCaptureReplayMixed: u32 = 0,
    // Extern sync: false
    // Optional: false
    rayTracingPipelineTraceRaysIndirect: u32 = 0,
    // Extern sync: false
    // Optional: false
    rayTraversalPrimitiveCulling: u32 = 0,
};
// Extension: VK_KHR_ray_query
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceRayQueryFeaturesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    rayQuery: u32 = 0,
};
// Extension: VK_KHR_acceleration_structure
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceAccelerationStructurePropertiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    maxGeometryCount: u64 = 0,
    // Extern sync: false
    // Optional: false
    maxInstanceCount: u64 = 0,
    // Extern sync: false
    // Optional: false
    maxPrimitiveCount: u64 = 0,
    // Extern sync: false
    // Optional: false
    maxPerStageDescriptorAccelerationStructures: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxPerStageDescriptorUpdateAfterBindAccelerationStructures: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxDescriptorSetAccelerationStructures: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxDescriptorSetUpdateAfterBindAccelerationStructures: u32 = 0,
    // Extern sync: false
    // Optional: false
    minAccelerationStructureScratchOffsetAlignment: u32 = 0,
};
// Extension: VK_KHR_ray_tracing_pipeline
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceRayTracingPipelinePropertiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    shaderGroupHandleSize: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxRayRecursionDepth: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxShaderGroupStride: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderGroupBaseAlignment: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderGroupHandleCaptureReplaySize: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxRayDispatchInvocationCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderGroupHandleAlignment: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxRayHitAttributeSize: u32 = 0,
};
// Extension: VK_NV_ray_tracing
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceRayTracingPropertiesNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    shaderGroupHandleSize: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxRecursionDepth: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxShaderGroupStride: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderGroupBaseAlignment: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxGeometryCount: u64 = 0,
    // Extern sync: false
    // Optional: false
    maxInstanceCount: u64 = 0,
    // Extern sync: false
    // Optional: false
    maxTriangleCount: u64 = 0,
    // Extern sync: false
    // Optional: false
    maxDescriptorSetAccelerationStructures: u32 = 0,
};
// Extension: VK_KHR_ray_tracing_pipeline
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkStridedDeviceAddressRegionKHR = extern struct {
    // Extern sync: false
    // Optional: true
    deviceAddress: u64 = 0,
    // Extern sync: false
    // Optional: false
    stride: u64 = 0,
    // Extern sync: false
    // Optional: false
    size: u64 = 0,
};
// Extension: VK_KHR_ray_tracing_pipeline
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkTraceRaysIndirectCommandKHR = extern struct {
    // Extern sync: false
    // Optional: false
    width: u32 = 0,
    // Extern sync: false
    // Optional: false
    height: u32 = 0,
    // Extern sync: false
    // Optional: false
    depth: u32 = 0,
};
// Extension: VK_KHR_ray_tracing_maintenance1
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkTraceRaysIndirectCommand2KHR = extern struct {
    // Extern sync: false
    // Optional: false
    raygenShaderRecordAddress: u64 = 0,
    // Extern sync: false
    // Optional: false
    raygenShaderRecordSize: u64 = 0,
    // Extern sync: false
    // Optional: false
    missShaderBindingTableAddress: u64 = 0,
    // Extern sync: false
    // Optional: false
    missShaderBindingTableSize: u64 = 0,
    // Extern sync: false
    // Optional: false
    missShaderBindingTableStride: u64 = 0,
    // Extern sync: false
    // Optional: false
    hitShaderBindingTableAddress: u64 = 0,
    // Extern sync: false
    // Optional: false
    hitShaderBindingTableSize: u64 = 0,
    // Extern sync: false
    // Optional: false
    hitShaderBindingTableStride: u64 = 0,
    // Extern sync: false
    // Optional: false
    callableShaderBindingTableAddress: u64 = 0,
    // Extern sync: false
    // Optional: false
    callableShaderBindingTableSize: u64 = 0,
    // Extern sync: false
    // Optional: false
    callableShaderBindingTableStride: u64 = 0,
    // Extern sync: false
    // Optional: false
    width: u32 = 0,
    // Extern sync: false
    // Optional: false
    height: u32 = 0,
    // Extern sync: false
    // Optional: false
    depth: u32 = 0,
};
// Extension: VK_KHR_ray_tracing_maintenance1
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    rayTracingMaintenance1: u32 = 0,
    // Extern sync: false
    // Optional: false
    rayTracingPipelineTraceRaysIndirect2: u32 = 0,
};
// Extension: VK_EXT_image_drm_format_modifier
// Extends: VkFormatProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkDrmFormatModifierPropertiesListEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: true
    drmFormatModifierCount: u32 = 0,
    // Length expression: drmFormatModifierCount
    // Extern sync: false
    // Optional: true
    pDrmFormatModifierProperties: ?[*]VkDrmFormatModifierPropertiesEXT = null,
};
// Extension: VK_EXT_image_drm_format_modifier
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkDrmFormatModifierPropertiesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    drmFormatModifier: u64 = 0,
    // Extern sync: false
    // Optional: false
    drmFormatModifierPlaneCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    drmFormatModifierTilingFeatures: VkFormatFeatureFlags = .{},
};
// Extension: VK_EXT_image_drm_format_modifier
// Extends: VkPhysicalDeviceImageFormatInfo2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceImageDrmFormatModifierInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    drmFormatModifier: u64 = 0,
    // Extern sync: false
    // Optional: false
    sharingMode: VkSharingMode = .VK_SHARING_MODE_EXCLUSIVE,
    // Extern sync: false
    // Optional: true
    queueFamilyIndexCount: u32 = 0,
    // Length expression: queueFamilyIndexCount
    // Extern sync: false
    // Optional: false
    pQueueFamilyIndices: ?[*]const u32 = null,
};
// Extension: VK_EXT_image_drm_format_modifier
// Extends: VkImageCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImageDrmFormatModifierListCreateInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    drmFormatModifierCount: u32 = 0,
    // Length expression: drmFormatModifierCount
    // Extern sync: false
    // Optional: false
    pDrmFormatModifiers: ?[*]const u64 = null,
};
// Extension: VK_EXT_image_drm_format_modifier
// Extends: VkImageCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImageDrmFormatModifierExplicitCreateInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    drmFormatModifier: u64 = 0,
    // Extern sync: false
    // Optional: false
    drmFormatModifierPlaneCount: u32 = 0,
    // Length expression: drmFormatModifierPlaneCount
    // Extern sync: false
    // Optional: false
    pPlaneLayouts: ?[*]const VkSubresourceLayout = null,
};
// Extension: VK_EXT_image_drm_format_modifier
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkImageDrmFormatModifierPropertiesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    drmFormatModifier: u64 = 0,
};
// Extension: VK_EXT_separate_stencil_usage
// Extension: VK_GRAPHICS_VERSION_1_2
// Extends: VkImageCreateInfo,VkPhysicalDeviceImageFormatInfo2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImageStencilUsageCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    stencilUsage: VkImageUsageFlags = .{},
};
// Extension: VK_AMD_memory_overallocation_behavior
// Extends: VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDeviceMemoryOverallocationCreateInfoAMD = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    overallocationBehavior: VkMemoryOverallocationBehaviorAMD = .VK_MEMORY_OVERALLOCATION_BEHAVIOR_DEFAULT_AMD,
};
// Extension: VK_EXT_fragment_density_map
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceFragmentDensityMapFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    fragmentDensityMap: u32 = 0,
    // Extern sync: false
    // Optional: false
    fragmentDensityMapDynamic: u32 = 0,
    // Extern sync: false
    // Optional: false
    fragmentDensityMapNonSubsampledImages: u32 = 0,
};
// Extension: VK_EXT_fragment_density_map2
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceFragmentDensityMap2FeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    fragmentDensityMapDeferred: u32 = 0,
};
// Extension: VK_QCOM_fragment_density_map_offset
// Extension: VK_EXT_fragment_density_map_offset
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceFragmentDensityMapOffsetFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    fragmentDensityMapOffset: u32 = 0,
};
// Extension: VK_EXT_fragment_density_map
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceFragmentDensityMapPropertiesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    minFragmentDensityTexelSize: VkExtent2D = .{},
    // Extern sync: false
    // Optional: false
    maxFragmentDensityTexelSize: VkExtent2D = .{},
    // Extern sync: false
    // Optional: false
    fragmentDensityInvocations: u32 = 0,
};
// Extension: VK_EXT_fragment_density_map2
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceFragmentDensityMap2PropertiesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    subsampledLoads: u32 = 0,
    // Extern sync: false
    // Optional: false
    subsampledCoarseReconstructionEarlyAccess: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxSubsampledArrayLayers: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxDescriptorSetSubsampledSamplers: u32 = 0,
};
// Extension: VK_QCOM_fragment_density_map_offset
// Extension: VK_EXT_fragment_density_map_offset
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceFragmentDensityMapOffsetPropertiesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    fragmentDensityOffsetGranularity: VkExtent2D = .{},
};
// Extension: VK_EXT_fragment_density_map
// Extends: VkRenderPassCreateInfo,VkRenderPassCreateInfo2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkRenderPassFragmentDensityMapCreateInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    fragmentDensityMapAttachment: VkAttachmentReference = .{},
};
// Extension: VK_QCOM_fragment_density_map_offset
// Extension: VK_EXT_fragment_density_map_offset
// Extends: VkSubpassEndInfo,VkRenderingEndInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkRenderPassFragmentDensityMapOffsetEndInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    fragmentDensityOffsetCount: u32 = 0,
    // Length expression: fragmentDensityOffsetCount
    // Extern sync: false
    // Optional: false
    pFragmentDensityOffsets: ?[*]const VkOffset2D = null,
};
// Extension: VK_EXT_scalar_block_layout
// Extension: VK_COMPUTE_VERSION_1_2
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceScalarBlockLayoutFeatures = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    scalarBlockLayout: u32 = 0,
};
// Extension: VK_KHR_surface_protected_capabilities
// Extends: VkSurfaceCapabilities2KHR
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkSurfaceProtectedCapabilitiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: Represents if surface can be protected
    supportsProtected: u32 = 0,
};
// Extension: VK_KHR_uniform_buffer_standard_layout
// Extension: VK_COMPUTE_VERSION_1_2
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceUniformBufferStandardLayoutFeatures = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    uniformBufferStandardLayout: u32 = 0,
};
// Extension: VK_EXT_depth_clip_enable
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceDepthClipEnableFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    depthClipEnable: u32 = 0,
};
// Extension: VK_EXT_depth_clip_enable
// Extends: VkPipelineRasterizationStateCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineRasterizationDepthClipStateCreateInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    // Comment: Reserved
    flags: VkPipelineRasterizationDepthClipStateCreateFlagsEXT = .{},
    // Extern sync: false
    // Optional: false
    depthClipEnable: u32 = 0,
};
// Extension: VK_EXT_memory_budget
// Extends: VkPhysicalDeviceMemoryProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceMemoryBudgetPropertiesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    heapBudget: [VK_MAX_MEMORY_HEAPS]u64 = @import("std").mem.zeroes([VK_MAX_MEMORY_HEAPS]u64),
    // Extern sync: false
    // Optional: false
    heapUsage: [VK_MAX_MEMORY_HEAPS]u64 = @import("std").mem.zeroes([VK_MAX_MEMORY_HEAPS]u64),
};
// Extension: VK_EXT_memory_priority
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceMemoryPriorityFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    memoryPriority: u32 = 0,
};
// Extension: VK_EXT_memory_priority
// Extends: VkMemoryAllocateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkMemoryPriorityAllocateInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    priority: f32 = 0,
};
// Extension: VK_EXT_pageable_device_local_memory
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    pageableDeviceLocalMemory: u32 = 0,
};
// Extension: VK_KHR_buffer_device_address
// Extension: VK_BASE_VERSION_1_2
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceBufferDeviceAddressFeatures = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    bufferDeviceAddress: u32 = 0,
    // Extern sync: false
    // Optional: false
    bufferDeviceAddressCaptureReplay: u32 = 0,
    // Extern sync: false
    // Optional: false
    bufferDeviceAddressMultiDevice: u32 = 0,
};
// Extension: VK_EXT_buffer_device_address
// Extension: VK_EXT_buffer_device_address
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceBufferDeviceAddressFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Feature link: bufferDeviceAddressEXT
    bufferDeviceAddress: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Feature link: bufferDeviceAddressCaptureReplayEXT
    bufferDeviceAddressCaptureReplay: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Feature link: bufferDeviceAddressMultiDeviceEXT
    bufferDeviceAddressMultiDevice: u32 = 0,
};
// Extension: VK_KHR_buffer_device_address
// Extension: VK_EXT_buffer_device_address
// Extension: VK_BASE_VERSION_1_2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkBufferDeviceAddressInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    buffer: VkBuffer = .none,
};
// Extension: VK_KHR_buffer_device_address
// Extension: VK_BASE_VERSION_1_2
// Extends: VkBufferCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkBufferOpaqueCaptureAddressCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    opaqueCaptureAddress: u64 = 0,
};
// Extension: VK_EXT_buffer_device_address
// Extends: VkBufferCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkBufferDeviceAddressCreateInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    deviceAddress: u64 = 0,
};
// Extension: VK_EXT_filter_cubic
// Extends: VkPhysicalDeviceImageFormatInfo2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceImageViewImageFormatInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    imageViewType: VkImageViewType = .VK_IMAGE_VIEW_TYPE_1D,
};
// Extension: VK_EXT_filter_cubic
// Extends: VkImageFormatProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkFilterCubicImageViewImageFormatPropertiesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: The combinations of format, image type (and image view type if provided) can be filtered with VK_FILTER_CUBIC_EXT
    filterCubic: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: The combination of format, image type (and image view type if provided) can be filtered with VK_FILTER_CUBIC_EXT and ReductionMode of Min or Max
    filterCubicMinmax: u32 = 0,
};
// Extension: VK_KHR_imageless_framebuffer
// Extension: VK_GRAPHICS_VERSION_1_2
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceImagelessFramebufferFeatures = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    imagelessFramebuffer: u32 = 0,
};
// Extension: VK_KHR_imageless_framebuffer
// Extension: VK_GRAPHICS_VERSION_1_2
// Extends: VkFramebufferCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkFramebufferAttachmentsCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    attachmentImageInfoCount: u32 = 0,
    // Length expression: attachmentImageInfoCount
    // Extern sync: false
    // Optional: false
    pAttachmentImageInfos: ?[*]const VkFramebufferAttachmentImageInfo = null,
};
// Extension: VK_KHR_imageless_framebuffer
// Extension: VK_GRAPHICS_VERSION_1_2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkFramebufferAttachmentImageInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    // Comment: Image creation flags
    flags: VkImageCreateFlags = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Image usage flags
    usage: VkImageUsageFlags = .{},
    // Extern sync: false
    // Optional: false
    width: u32 = 0,
    // Extern sync: false
    // Optional: false
    height: u32 = 0,
    // Extern sync: false
    // Optional: false
    layerCount: u32 = 0,
    // Extern sync: false
    // Optional: true
    viewFormatCount: u32 = 0,
    // Length expression: viewFormatCount
    // Extern sync: false
    // Optional: false
    pViewFormats: ?[*]const VkFormat = null,
};
// Extension: VK_KHR_imageless_framebuffer
// Extension: VK_GRAPHICS_VERSION_1_2
// Extends: VkRenderPassBeginInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkRenderPassAttachmentBeginInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    attachmentCount: u32 = 0,
    // Length expression: attachmentCount
    // Extern sync: false
    // Optional: false
    pAttachments: ?[*]const VkImageView = null,
};
// Extension: VK_EXT_texture_compression_astc_hdr
// Extension: VK_BASE_VERSION_1_3
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceTextureCompressionASTCHDRFeatures = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    textureCompressionASTC_HDR: u32 = 0,
};
// Extension: VK_NV_cooperative_matrix
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceCooperativeMatrixFeaturesNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Feature link: cooperativeMatrixNV
    cooperativeMatrix: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Feature link: cooperativeMatrixRobustBufferAccessNV
    cooperativeMatrixRobustBufferAccess: u32 = 0,
};
// Extension: VK_NV_cooperative_matrix
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceCooperativeMatrixPropertiesNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    cooperativeMatrixSupportedStages: VkShaderStageFlags = .{},
};
// Extension: VK_NV_cooperative_matrix
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkCooperativeMatrixPropertiesNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    MSize: u32 = 0,
    // Extern sync: false
    // Optional: false
    NSize: u32 = 0,
    // Extern sync: false
    // Optional: false
    KSize: u32 = 0,
    // Extern sync: false
    // Optional: false
    AType: VkComponentTypeKHR = .VK_COMPONENT_TYPE_FLOAT16_KHR,
    // Extern sync: false
    // Optional: false
    BType: VkComponentTypeKHR = .VK_COMPONENT_TYPE_FLOAT16_KHR,
    // Extern sync: false
    // Optional: false
    CType: VkComponentTypeKHR = .VK_COMPONENT_TYPE_FLOAT16_KHR,
    // Extern sync: false
    // Optional: false
    DType: VkComponentTypeKHR = .VK_COMPONENT_TYPE_FLOAT16_KHR,
    // Extern sync: false
    // Optional: false
    scope: VkScopeKHR = .VK_SCOPE_DEVICE_KHR,
};
// Extension: VK_EXT_ycbcr_image_arrays
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceYcbcrImageArraysFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    ycbcrImageArrays: u32 = 0,
};
// Extension: VK_NVX_image_view_handle
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImageViewHandleInfoNVX = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_IMAGE_VIEW_HANDLE_INFO_NVX;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    imageView: VkImageView = .none,
    // Extern sync: false
    // Optional: false
    descriptorType: VkDescriptorType = .VK_DESCRIPTOR_TYPE_SAMPLER,
    // Extern sync: false
    // Optional: true
    sampler: VkSampler = .none,
};
// Extension: VK_NVX_image_view_handle
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkImageViewAddressPropertiesNVX = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_IMAGE_VIEW_ADDRESS_PROPERTIES_NVX;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    deviceAddress: u64 = 0,
    // Extern sync: false
    // Optional: false
    size: u64 = 0,
};
// Extension: VK_GGP_frame_token
// Extends: VkPresentInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPresentFrameTokenGGP = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
};
// Extension: VK_EXT_pipeline_creation_feedback
// Extension: VK_COMPUTE_VERSION_1_3
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPipelineCreationFeedback = extern struct {
    // Extern sync: false
    // Optional: false
    flags: VkPipelineCreationFeedbackFlags = .{},
    // Extern sync: false
    // Optional: false
    duration: u64 = 0,
};
// Extension: VK_EXT_pipeline_creation_feedback
// Extension: VK_COMPUTE_VERSION_1_3
// Extends: VkGraphicsPipelineCreateInfo,VkComputePipelineCreateInfo,VkRayTracingPipelineCreateInfoNV,VkRayTracingPipelineCreateInfoKHR,VkExecutionGraphPipelineCreateInfoAMDX,VkDataGraphPipelineCreateInfoARM
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineCreationFeedbackCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: Output pipeline creation feedback.
    pPipelineCreationFeedback: ?*VkPipelineCreationFeedback = null,
    // Extern sync: false
    // Optional: true
    pipelineStageCreationFeedbackCount: u32 = 0,
    // Length expression: pipelineStageCreationFeedbackCount
    // Extern sync: false
    // Optional: false
    // Comment: One entry for each shader stage specified in the parent Vk*PipelineCreateInfo struct
    pPipelineStageCreationFeedbacks: ?[*]VkPipelineCreationFeedback = null,
};
// Extension: VK_EXT_full_screen_exclusive
// Extends: VkPhysicalDeviceSurfaceInfo2KHR,VkSwapchainCreateInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSurfaceFullScreenExclusiveInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    fullScreenExclusive: VkFullScreenExclusiveEXT = .VK_FULL_SCREEN_EXCLUSIVE_DEFAULT_EXT,
};
// Extension: VK_EXT_full_screen_exclusive
// Extends: VkPhysicalDeviceSurfaceInfo2KHR,VkSwapchainCreateInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSurfaceFullScreenExclusiveWin32InfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
};
// Extension: VK_EXT_full_screen_exclusive
// Extends: VkSurfaceCapabilities2KHR
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkSurfaceCapabilitiesFullScreenExclusiveEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    fullScreenExclusiveSupported: u32 = 0,
};
// Extension: VK_NV_present_barrier
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDevicePresentBarrierFeaturesNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_BARRIER_FEATURES_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    presentBarrier: u32 = 0,
};
// Extension: VK_NV_present_barrier
// Extends: VkSurfaceCapabilities2KHR
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkSurfaceCapabilitiesPresentBarrierNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_BARRIER_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    presentBarrierSupported: u32 = 0,
};
// Extension: VK_NV_present_barrier
// Extends: VkSwapchainCreateInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSwapchainPresentBarrierCreateInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_BARRIER_CREATE_INFO_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    presentBarrierEnable: u32 = 0,
};
// Extension: VK_KHR_performance_query
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDevicePerformanceQueryFeaturesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: performance counters supported in query pools
    performanceCounterQueryPools: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: performance counters from multiple query pools can be accessed in the same primary command buffer
    performanceCounterMultipleQueryPools: u32 = 0,
};
// Extension: VK_KHR_performance_query
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDevicePerformanceQueryPropertiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: Flag to specify whether performance queries are allowed to be used in vkCmdCopyQueryPoolResults
    allowCommandBufferQueryCopies: u32 = 0,
};
// Extension: VK_KHR_performance_query
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPerformanceCounterKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    unit: VkPerformanceCounterUnitKHR = .VK_PERFORMANCE_COUNTER_UNIT_GENERIC_KHR,
    // Extern sync: false
    // Optional: false
    scope: VkPerformanceCounterScopeKHR = .VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_BUFFER_KHR,
    // Extern sync: false
    // Optional: false
    storage: VkPerformanceCounterStorageKHR = .VK_PERFORMANCE_COUNTER_STORAGE_INT32_KHR,
    // Extern sync: false
    // Optional: false
    uuid: [VK_UUID_SIZE]u8 = @import("std").mem.zeroes([VK_UUID_SIZE]u8),
};
// Extension: VK_KHR_performance_query
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPerformanceCounterDescriptionKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_DESCRIPTION_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkPerformanceCounterDescriptionFlagsKHR = .{},
    // Length expression: null-terminated
    // Extern sync: false
    // Optional: false
    name: [VK_MAX_DESCRIPTION_SIZE]u8 = @import("std").mem.zeroes([VK_MAX_DESCRIPTION_SIZE]u8),
    // Length expression: null-terminated
    // Extern sync: false
    // Optional: false
    category: [VK_MAX_DESCRIPTION_SIZE]u8 = @import("std").mem.zeroes([VK_MAX_DESCRIPTION_SIZE]u8),
    // Length expression: null-terminated
    // Extern sync: false
    // Optional: false
    description: [VK_MAX_DESCRIPTION_SIZE]u8 = @import("std").mem.zeroes([VK_MAX_DESCRIPTION_SIZE]u8),
};
// Extension: VK_KHR_performance_query
// Extends: VkQueryPoolCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkQueryPoolPerformanceCreateInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    queueFamilyIndex: u32 = 0,
    // Extern sync: false
    // Optional: false
    counterIndexCount: u32 = 0,
    // Length expression: counterIndexCount
    // Extern sync: false
    // Optional: false
    pCounterIndices: ?[*]const u32 = null,
};
// Extension: VK_KHR_performance_query
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkAcquireProfilingLockInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_ACQUIRE_PROFILING_LOCK_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    // Comment: Acquire profiling lock flags
    flags: VkAcquireProfilingLockFlagsKHR = .{},
    // Extern sync: false
    // Optional: false
    timeout: u64 = 0,
};
// Extension: VK_KHR_performance_query
// Extends: VkSubmitInfo,VkSubmitInfo2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPerformanceQuerySubmitInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: Index for which counter pass to submit
    counterPassIndex: u32 = 0,
};
// Extension: VK_KHR_performance_query
// Extends: VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: true
pub const VkPerformanceQueryReservationInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_RESERVATION_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: Maximum number of VK_QUERY_TYPE_PERFORMANCE_QUERY_KHR queries in a query pool
    maxPerformanceQueriesPerPool: u32 = 0,
};
// Extension: VK_EXT_headless_surface
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkHeadlessSurfaceCreateInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkHeadlessSurfaceCreateFlagsEXT = .{},
};
// Extension: VK_NV_coverage_reduction_mode
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceCoverageReductionModeFeaturesNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    coverageReductionMode: u32 = 0,
};
// Extension: VK_NV_coverage_reduction_mode
// Extends: VkPipelineMultisampleStateCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineCoverageReductionStateCreateInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkPipelineCoverageReductionStateCreateFlagsNV = .{},
    // Extern sync: false
    // Optional: false
    coverageReductionMode: VkCoverageReductionModeNV = .VK_COVERAGE_REDUCTION_MODE_MERGE_NV,
};
// Extension: VK_NV_coverage_reduction_mode
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkFramebufferMixedSamplesCombinationNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    coverageReductionMode: VkCoverageReductionModeNV = .VK_COVERAGE_REDUCTION_MODE_MERGE_NV,
    // Extern sync: false
    // Optional: false
    rasterizationSamples: VkSampleCountFlags = .{},
    // Extern sync: false
    // Optional: false
    depthStencilSamples: VkSampleCountFlags = .{},
    // Extern sync: false
    // Optional: false
    colorSamples: VkSampleCountFlags = .{},
};
// Extension: VK_INTEL_shader_integer_functions2
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    shaderIntegerFunctions2: u32 = 0,
};
// Extension: VK_INTEL_performance_query
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPerformanceValueINTEL = extern struct {
    // Extern sync: false
    // Optional: false
    type: VkPerformanceValueTypeINTEL = .VK_PERFORMANCE_VALUE_TYPE_UINT32_INTEL,
    // Extern sync: false
    // Optional: false
    // Selector field: type (What union field is valid)
    data: VkPerformanceValueDataINTEL,
};
// Extension: VK_INTEL_performance_query
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkInitializePerformanceApiInfoINTEL = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_INITIALIZE_PERFORMANCE_API_INFO_INTEL;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    pUserData: ?*anyopaque = null,
};
// Extension: VK_INTEL_performance_query
// Extension: VK_INTEL_performance_query
// Extends: VkQueryPoolCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkQueryPoolPerformanceQueryCreateInfoINTEL = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    performanceCountersSampling: VkQueryPoolSamplingModeINTEL = .VK_QUERY_POOL_SAMPLING_MODE_MANUAL_INTEL,
};
// Extension: VK_INTEL_performance_query
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPerformanceMarkerInfoINTEL = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PERFORMANCE_MARKER_INFO_INTEL;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    marker: u64 = 0,
};
// Extension: VK_INTEL_performance_query
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPerformanceStreamMarkerInfoINTEL = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PERFORMANCE_STREAM_MARKER_INFO_INTEL;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    marker: u32 = 0,
};
// Extension: VK_INTEL_performance_query
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPerformanceOverrideInfoINTEL = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PERFORMANCE_OVERRIDE_INFO_INTEL;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    type: VkPerformanceOverrideTypeINTEL = .VK_PERFORMANCE_OVERRIDE_TYPE_NULL_HARDWARE_INTEL,
    // Extern sync: false
    // Optional: false
    enable: u32 = 0,
    // Extern sync: false
    // Optional: false
    parameter: u64 = 0,
};
// Extension: VK_INTEL_performance_query
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPerformanceConfigurationAcquireInfoINTEL = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    type: VkPerformanceConfigurationTypeINTEL = .VK_PERFORMANCE_CONFIGURATION_TYPE_COMMAND_QUEUE_METRICS_DISCOVERY_ACTIVATED_INTEL,
};
// Extension: VK_KHR_shader_clock
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceShaderClockFeaturesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    shaderSubgroupClock: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderDeviceClock: u32 = 0,
};
// Extension: VK_KHR_index_type_uint8
// Extension: VK_EXT_index_type_uint8
// Extension: VK_BASE_VERSION_1_4
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceIndexTypeUint8Features = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    indexTypeUint8: u32 = 0,
};
// Extension: VK_NV_shader_sm_builtins
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceShaderSMBuiltinsPropertiesNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    shaderSMCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderWarpsPerSM: u32 = 0,
};
// Extension: VK_NV_shader_sm_builtins
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceShaderSMBuiltinsFeaturesNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    shaderSMBuiltins: u32 = 0,
};
// Extension: VK_EXT_fragment_shader_interlock
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    // Comment: Pointer to next structure
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    fragmentShaderSampleInterlock: u32 = 0,
    // Extern sync: false
    // Optional: false
    fragmentShaderPixelInterlock: u32 = 0,
    // Extern sync: false
    // Optional: false
    fragmentShaderShadingRateInterlock: u32 = 0,
};
// Extension: VK_KHR_separate_depth_stencil_layouts
// Extension: VK_GRAPHICS_VERSION_1_2
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    separateDepthStencilLayouts: u32 = 0,
};
// Extension: VK_KHR_separate_depth_stencil_layouts
// Extension: VK_GRAPHICS_VERSION_1_2
// Extends: VkAttachmentReference2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkAttachmentReferenceStencilLayout = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    stencilLayout: VkImageLayout = .VK_IMAGE_LAYOUT_UNDEFINED,
};
// Extension: VK_EXT_primitive_topology_list_restart
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    primitiveTopologyListRestart: u32 = 0,
    // Extern sync: false
    // Optional: false
    primitiveTopologyPatchListRestart: u32 = 0,
};
// Extension: VK_KHR_separate_depth_stencil_layouts
// Extension: VK_GRAPHICS_VERSION_1_2
// Extends: VkAttachmentDescription2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkAttachmentDescriptionStencilLayout = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    stencilInitialLayout: VkImageLayout = .VK_IMAGE_LAYOUT_UNDEFINED,
    // Extern sync: false
    // Optional: false
    stencilFinalLayout: VkImageLayout = .VK_IMAGE_LAYOUT_UNDEFINED,
};
// Extension: VK_KHR_pipeline_executable_properties
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    pipelineExecutableInfo: u32 = 0,
};
// Extension: VK_EXT_pipeline_properties
// Extension: VK_KHR_pipeline_executable_properties
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    pipeline: VkPipeline = .none,
};
// Extension: VK_KHR_pipeline_executable_properties
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPipelineExecutablePropertiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_PROPERTIES_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    stages: VkShaderStageFlags = .{},
    // Length expression: null-terminated
    // Extern sync: false
    // Optional: false
    name: [VK_MAX_DESCRIPTION_SIZE]u8 = @import("std").mem.zeroes([VK_MAX_DESCRIPTION_SIZE]u8),
    // Length expression: null-terminated
    // Extern sync: false
    // Optional: false
    description: [VK_MAX_DESCRIPTION_SIZE]u8 = @import("std").mem.zeroes([VK_MAX_DESCRIPTION_SIZE]u8),
    // Extern sync: false
    // Optional: false
    subgroupSize: u32 = 0,
};
// Extension: VK_KHR_pipeline_executable_properties
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineExecutableInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    pipeline: VkPipeline = .none,
    // Extern sync: false
    // Optional: false
    executableIndex: u32 = 0,
};
// Extension: VK_KHR_pipeline_executable_properties
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPipelineExecutableStatisticKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_STATISTIC_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Length expression: null-terminated
    // Extern sync: false
    // Optional: false
    name: [VK_MAX_DESCRIPTION_SIZE]u8 = @import("std").mem.zeroes([VK_MAX_DESCRIPTION_SIZE]u8),
    // Length expression: null-terminated
    // Extern sync: false
    // Optional: false
    description: [VK_MAX_DESCRIPTION_SIZE]u8 = @import("std").mem.zeroes([VK_MAX_DESCRIPTION_SIZE]u8),
    // Extern sync: false
    // Optional: false
    format: VkPipelineExecutableStatisticFormatKHR = .VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_BOOL32_KHR,
    // Extern sync: false
    // Optional: false
    // Selector field: format (What union field is valid)
    value: VkPipelineExecutableStatisticValueKHR,
};
// Extension: VK_KHR_pipeline_executable_properties
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPipelineExecutableInternalRepresentationKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Length expression: null-terminated
    // Extern sync: false
    // Optional: false
    name: [VK_MAX_DESCRIPTION_SIZE]u8 = @import("std").mem.zeroes([VK_MAX_DESCRIPTION_SIZE]u8),
    // Length expression: null-terminated
    // Extern sync: false
    // Optional: false
    description: [VK_MAX_DESCRIPTION_SIZE]u8 = @import("std").mem.zeroes([VK_MAX_DESCRIPTION_SIZE]u8),
    // Extern sync: false
    // Optional: false
    isText: u32 = 0,
    // Extern sync: false
    // Optional: false
    dataSize: u64 = 0,
    // Length expression: dataSize
    // Extern sync: false
    // Optional: true
    pData: ?*anyopaque = null,
};
// Extension: VK_EXT_shader_demote_to_helper_invocation
// Extension: VK_COMPUTE_VERSION_1_3
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    shaderDemoteToHelperInvocation: u32 = 0,
};
// Extension: VK_EXT_texel_buffer_alignment
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    texelBufferAlignment: u32 = 0,
};
// Extension: VK_EXT_texel_buffer_alignment
// Extension: VK_COMPUTE_VERSION_1_3
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceTexelBufferAlignmentProperties = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    storageTexelBufferOffsetAlignmentBytes: u64 = 0,
    // Extern sync: false
    // Optional: false
    storageTexelBufferOffsetSingleTexelAlignment: u32 = 0,
    // Extern sync: false
    // Optional: false
    uniformTexelBufferOffsetAlignmentBytes: u64 = 0,
    // Extern sync: false
    // Optional: false
    uniformTexelBufferOffsetSingleTexelAlignment: u32 = 0,
};
// Extension: VK_EXT_subgroup_size_control
// Extension: VK_COMPUTE_VERSION_1_3
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceSubgroupSizeControlFeatures = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    subgroupSizeControl: u32 = 0,
    // Extern sync: false
    // Optional: false
    computeFullSubgroups: u32 = 0,
};
// Extension: VK_EXT_subgroup_size_control
// Extension: VK_COMPUTE_VERSION_1_3
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceSubgroupSizeControlProperties = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: The minimum subgroup size supported by this device
    minSubgroupSize: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: The maximum subgroup size supported by this device
    maxSubgroupSize: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: The maximum number of subgroups supported in a workgroup
    maxComputeWorkgroupSubgroups: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: The shader stages that support specifying a subgroup size
    requiredSubgroupSizeStages: VkShaderStageFlags = .{},
};
// Extension: VK_EXT_subgroup_size_control
// Extension: VK_EXT_shader_object
// Extension: VK_COMPUTE_VERSION_1_3
// Extends: VkPipelineShaderStageCreateInfo,VkShaderCreateInfoEXT
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineShaderStageRequiredSubgroupSizeCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    requiredSubgroupSize: u32 = 0,
};
// Extension: VK_HUAWEI_subpass_shading
// Extends: VkComputePipelineCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSubpassShadingPipelineCreateInfoHUAWEI = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_SUBPASS_SHADING_PIPELINE_CREATE_INFO_HUAWEI;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    renderPass: VkRenderPass = .none,
    // Extern sync: false
    // Optional: false
    subpass: u32 = 0,
};
// Extension: VK_HUAWEI_subpass_shading
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceSubpassShadingPropertiesHUAWEI = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_PROPERTIES_HUAWEI;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    maxSubpassShadingWorkgroupSizeAspectRatio: u32 = 0,
};
// Extension: VK_HUAWEI_cluster_culling_shader
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_PROPERTIES_HUAWEI;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    maxWorkGroupCount: [3]u32 = @import("std").mem.zeroes([3]u32),
    // Extern sync: false
    // Optional: false
    maxWorkGroupSize: [3]u32 = @import("std").mem.zeroes([3]u32),
    // Extern sync: false
    // Optional: false
    maxOutputClusterCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    indirectBufferOffsetAlignment: u64 = 0,
};
// Extension: VK_KHR_buffer_device_address
// Extension: VK_BASE_VERSION_1_2
// Extends: VkMemoryAllocateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkMemoryOpaqueCaptureAddressAllocateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    opaqueCaptureAddress: u64 = 0,
};
// Extension: VK_KHR_buffer_device_address
// Extension: VK_BASE_VERSION_1_2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDeviceMemoryOpaqueCaptureAddressInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    memory: VkDeviceMemory = .none,
};
// Extension: VK_KHR_line_rasterization
// Extension: VK_EXT_line_rasterization
// Extension: VK_GRAPHICS_VERSION_1_4
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceLineRasterizationFeatures = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    rectangularLines: u32 = 0,
    // Extern sync: false
    // Optional: false
    bresenhamLines: u32 = 0,
    // Extern sync: false
    // Optional: false
    smoothLines: u32 = 0,
    // Extern sync: false
    // Optional: false
    stippledRectangularLines: u32 = 0,
    // Extern sync: false
    // Optional: false
    stippledBresenhamLines: u32 = 0,
    // Extern sync: false
    // Optional: false
    stippledSmoothLines: u32 = 0,
};
// Extension: VK_KHR_line_rasterization
// Extension: VK_EXT_line_rasterization
// Extension: VK_GRAPHICS_VERSION_1_4
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceLineRasterizationProperties = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    lineSubPixelPrecisionBits: u32 = 0,
};
// Extension: VK_KHR_line_rasterization
// Extension: VK_EXT_line_rasterization
// Extension: VK_GRAPHICS_VERSION_1_4
// Extends: VkPipelineRasterizationStateCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineRasterizationLineStateCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    lineRasterizationMode: VkLineRasterizationMode = .VK_LINE_RASTERIZATION_MODE_DEFAULT,
    // Extern sync: false
    // Optional: false
    stippledLineEnable: u32 = 0,
    // Extern sync: false
    // Optional: false
    lineStippleFactor: u32 = 0,
    // Extern sync: false
    // Optional: false
    lineStipplePattern: u16 = 0,
};
// Extension: VK_EXT_pipeline_creation_cache_control
// Extension: VK_COMPUTE_VERSION_1_3
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDevicePipelineCreationCacheControlFeatures = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    pipelineCreationCacheControl: u32 = 0,
};
// Extension: VK_BASE_VERSION_1_2
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceVulkan11Features = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: 16-bit integer/floating-point variables supported in BufferBlock
    storageBuffer16BitAccess: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: 16-bit integer/floating-point variables supported in BufferBlock and Block
    uniformAndStorageBuffer16BitAccess: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: 16-bit integer/floating-point variables supported in PushConstant
    storagePushConstant16: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: 16-bit integer/floating-point variables supported in shader inputs and outputs
    storageInputOutput16: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Multiple views in a render pass
    multiview: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Multiple views in a render pass w/ geometry shader
    multiviewGeometryShader: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Multiple views in a render pass w/ tessellation shader
    multiviewTessellationShader: u32 = 0,
    // Extern sync: false
    // Optional: false
    variablePointersStorageBuffer: u32 = 0,
    // Extern sync: false
    // Optional: false
    variablePointers: u32 = 0,
    // Extern sync: false
    // Optional: false
    protectedMemory: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Sampler color conversion supported
    samplerYcbcrConversion: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderDrawParameters: u32 = 0,
};
// Extension: VK_BASE_VERSION_1_2
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceVulkan11Properties = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    deviceUUID: [VK_UUID_SIZE]u8 = @import("std").mem.zeroes([VK_UUID_SIZE]u8),
    // Extern sync: false
    // Optional: false
    driverUUID: [VK_UUID_SIZE]u8 = @import("std").mem.zeroes([VK_UUID_SIZE]u8),
    // Extern sync: false
    // Optional: false
    deviceLUID: [VK_LUID_SIZE]u8 = @import("std").mem.zeroes([VK_LUID_SIZE]u8),
    // Extern sync: false
    // Optional: false
    deviceNodeMask: u32 = 0,
    // Extern sync: false
    // Optional: false
    deviceLUIDValid: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: The size of a subgroup for this queue.
    subgroupSize: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Bitfield of what shader stages support subgroup operations
    subgroupSupportedStages: VkShaderStageFlags = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Bitfield of what subgroup operations are supported.
    subgroupSupportedOperations: VkSubgroupFeatureFlags = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Flag to specify whether quad operations are available in all stages.
    subgroupQuadOperationsInAllStages: u32 = 0,
    // Extern sync: false
    // Optional: false
    pointClippingBehavior: VkPointClippingBehavior = .VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES,
    // Extern sync: false
    // Optional: false
    // Comment: max number of views in a subpass
    maxMultiviewViewCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: max instance index for a draw in a multiview subpass
    maxMultiviewInstanceIndex: u32 = 0,
    // Extern sync: false
    // Optional: false
    protectedNoFault: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxPerSetDescriptors: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxMemoryAllocationSize: u64 = 0,
};
// Extension: VK_BASE_VERSION_1_2
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceVulkan12Features = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    samplerMirrorClampToEdge: u32 = 0,
    // Extern sync: false
    // Optional: false
    drawIndirectCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: 8-bit integer variables supported in StorageBuffer
    storageBuffer8BitAccess: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: 8-bit integer variables supported in StorageBuffer and Uniform
    uniformAndStorageBuffer8BitAccess: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: 8-bit integer variables supported in PushConstant
    storagePushConstant8: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderBufferInt64Atomics: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderSharedInt64Atomics: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: 16-bit floats (halfs) in shaders
    shaderFloat16: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: 8-bit integers in shaders
    shaderInt8: u32 = 0,
    // Extern sync: false
    // Optional: false
    descriptorIndexing: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderInputAttachmentArrayDynamicIndexing: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderUniformTexelBufferArrayDynamicIndexing: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderStorageTexelBufferArrayDynamicIndexing: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderUniformBufferArrayNonUniformIndexing: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderSampledImageArrayNonUniformIndexing: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderStorageBufferArrayNonUniformIndexing: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderStorageImageArrayNonUniformIndexing: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderInputAttachmentArrayNonUniformIndexing: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderUniformTexelBufferArrayNonUniformIndexing: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderStorageTexelBufferArrayNonUniformIndexing: u32 = 0,
    // Extern sync: false
    // Optional: false
    descriptorBindingUniformBufferUpdateAfterBind: u32 = 0,
    // Extern sync: false
    // Optional: false
    descriptorBindingSampledImageUpdateAfterBind: u32 = 0,
    // Extern sync: false
    // Optional: false
    descriptorBindingStorageImageUpdateAfterBind: u32 = 0,
    // Extern sync: false
    // Optional: false
    descriptorBindingStorageBufferUpdateAfterBind: u32 = 0,
    // Extern sync: false
    // Optional: false
    descriptorBindingUniformTexelBufferUpdateAfterBind: u32 = 0,
    // Extern sync: false
    // Optional: false
    descriptorBindingStorageTexelBufferUpdateAfterBind: u32 = 0,
    // Extern sync: false
    // Optional: false
    descriptorBindingUpdateUnusedWhilePending: u32 = 0,
    // Extern sync: false
    // Optional: false
    descriptorBindingPartiallyBound: u32 = 0,
    // Extern sync: false
    // Optional: false
    descriptorBindingVariableDescriptorCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    runtimeDescriptorArray: u32 = 0,
    // Extern sync: false
    // Optional: false
    samplerFilterMinmax: u32 = 0,
    // Extern sync: false
    // Optional: false
    scalarBlockLayout: u32 = 0,
    // Extern sync: false
    // Optional: false
    imagelessFramebuffer: u32 = 0,
    // Extern sync: false
    // Optional: false
    uniformBufferStandardLayout: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderSubgroupExtendedTypes: u32 = 0,
    // Extern sync: false
    // Optional: false
    separateDepthStencilLayouts: u32 = 0,
    // Extern sync: false
    // Optional: false
    hostQueryReset: u32 = 0,
    // Extern sync: false
    // Optional: false
    timelineSemaphore: u32 = 0,
    // Extern sync: false
    // Optional: false
    bufferDeviceAddress: u32 = 0,
    // Extern sync: false
    // Optional: false
    bufferDeviceAddressCaptureReplay: u32 = 0,
    // Extern sync: false
    // Optional: false
    bufferDeviceAddressMultiDevice: u32 = 0,
    // Extern sync: false
    // Optional: false
    vulkanMemoryModel: u32 = 0,
    // Extern sync: false
    // Optional: false
    vulkanMemoryModelDeviceScope: u32 = 0,
    // Extern sync: false
    // Optional: false
    vulkanMemoryModelAvailabilityVisibilityChains: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderOutputViewportIndex: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderOutputLayer: u32 = 0,
    // Extern sync: false
    // Optional: false
    subgroupBroadcastDynamicId: u32 = 0,
};
// Extension: VK_BASE_VERSION_1_2
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceVulkan12Properties = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    driverID: VkDriverId = .VK_DRIVER_ID_AMD_PROPRIETARY,
    // Length expression: null-terminated
    // Extern sync: false
    // Optional: false
    driverName: [VK_MAX_DRIVER_NAME_SIZE]u8 = @import("std").mem.zeroes([VK_MAX_DRIVER_NAME_SIZE]u8),
    // Length expression: null-terminated
    // Extern sync: false
    // Optional: false
    driverInfo: [VK_MAX_DRIVER_INFO_SIZE]u8 = @import("std").mem.zeroes([VK_MAX_DRIVER_INFO_SIZE]u8),
    // Extern sync: false
    // Optional: false
    conformanceVersion: VkConformanceVersion = .{},
    // Extern sync: false
    // Optional: false
    denormBehaviorIndependence: VkShaderFloatControlsIndependence = .VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY,
    // Extern sync: false
    // Optional: false
    roundingModeIndependence: VkShaderFloatControlsIndependence = .VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY,
    // Extern sync: false
    // Optional: false
    // Comment: An implementation can preserve signed zero, nan, inf
    shaderSignedZeroInfNanPreserveFloat16: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: An implementation can preserve signed zero, nan, inf
    shaderSignedZeroInfNanPreserveFloat32: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: An implementation can preserve signed zero, nan, inf
    shaderSignedZeroInfNanPreserveFloat64: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: An implementation can preserve  denormals
    shaderDenormPreserveFloat16: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: An implementation can preserve  denormals
    shaderDenormPreserveFloat32: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: An implementation can preserve  denormals
    shaderDenormPreserveFloat64: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: An implementation can flush to zero  denormals
    shaderDenormFlushToZeroFloat16: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: An implementation can flush to zero  denormals
    shaderDenormFlushToZeroFloat32: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: An implementation can flush to zero  denormals
    shaderDenormFlushToZeroFloat64: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: An implementation can support RTE
    shaderRoundingModeRTEFloat16: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: An implementation can support RTE
    shaderRoundingModeRTEFloat32: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: An implementation can support RTE
    shaderRoundingModeRTEFloat64: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: An implementation can support RTZ
    shaderRoundingModeRTZFloat16: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: An implementation can support RTZ
    shaderRoundingModeRTZFloat32: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: An implementation can support RTZ
    shaderRoundingModeRTZFloat64: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxUpdateAfterBindDescriptorsInAllPools: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderUniformBufferArrayNonUniformIndexingNative: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderSampledImageArrayNonUniformIndexingNative: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderStorageBufferArrayNonUniformIndexingNative: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderStorageImageArrayNonUniformIndexingNative: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderInputAttachmentArrayNonUniformIndexingNative: u32 = 0,
    // Extern sync: false
    // Optional: false
    robustBufferAccessUpdateAfterBind: u32 = 0,
    // Extern sync: false
    // Optional: false
    quadDivergentImplicitLod: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxPerStageDescriptorUpdateAfterBindSamplers: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxPerStageDescriptorUpdateAfterBindUniformBuffers: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxPerStageDescriptorUpdateAfterBindStorageBuffers: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxPerStageDescriptorUpdateAfterBindSampledImages: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxPerStageDescriptorUpdateAfterBindStorageImages: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxPerStageDescriptorUpdateAfterBindInputAttachments: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxPerStageUpdateAfterBindResources: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxDescriptorSetUpdateAfterBindSamplers: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxDescriptorSetUpdateAfterBindUniformBuffers: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxDescriptorSetUpdateAfterBindUniformBuffersDynamic: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxDescriptorSetUpdateAfterBindStorageBuffers: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxDescriptorSetUpdateAfterBindStorageBuffersDynamic: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxDescriptorSetUpdateAfterBindSampledImages: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxDescriptorSetUpdateAfterBindStorageImages: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxDescriptorSetUpdateAfterBindInputAttachments: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: supported depth resolve modes
    supportedDepthResolveModes: VkResolveModeFlags = .{},
    // Extern sync: false
    // Optional: false
    // Comment: supported stencil resolve modes
    supportedStencilResolveModes: VkResolveModeFlags = .{},
    // Extern sync: false
    // Optional: false
    // Comment: depth and stencil resolve modes can be set independently if one of them is none
    independentResolveNone: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: depth and stencil resolve modes can be set independently
    independentResolve: u32 = 0,
    // Extern sync: false
    // Optional: false
    filterMinmaxSingleComponentFormats: u32 = 0,
    // Extern sync: false
    // Optional: false
    filterMinmaxImageComponentMapping: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxTimelineSemaphoreValueDifference: u64 = 0,
    // Extern sync: false
    // Optional: true
    framebufferIntegerColorSampleCounts: VkSampleCountFlags = .{},
};
// Extension: VK_BASE_VERSION_1_3
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceVulkan13Features = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    robustImageAccess: u32 = 0,
    // Extern sync: false
    // Optional: false
    inlineUniformBlock: u32 = 0,
    // Extern sync: false
    // Optional: false
    descriptorBindingInlineUniformBlockUpdateAfterBind: u32 = 0,
    // Extern sync: false
    // Optional: false
    pipelineCreationCacheControl: u32 = 0,
    // Extern sync: false
    // Optional: false
    privateData: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderDemoteToHelperInvocation: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderTerminateInvocation: u32 = 0,
    // Extern sync: false
    // Optional: false
    subgroupSizeControl: u32 = 0,
    // Extern sync: false
    // Optional: false
    computeFullSubgroups: u32 = 0,
    // Extern sync: false
    // Optional: false
    synchronization2: u32 = 0,
    // Extern sync: false
    // Optional: false
    textureCompressionASTC_HDR: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderZeroInitializeWorkgroupMemory: u32 = 0,
    // Extern sync: false
    // Optional: false
    dynamicRendering: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderIntegerDotProduct: u32 = 0,
    // Extern sync: false
    // Optional: false
    maintenance4: u32 = 0,
};
// Extension: VK_BASE_VERSION_1_3
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceVulkan13Properties = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: The minimum subgroup size supported by this device
    minSubgroupSize: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: The maximum subgroup size supported by this device
    maxSubgroupSize: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: The maximum number of subgroups supported in a workgroup
    maxComputeWorkgroupSubgroups: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: The shader stages that support specifying a subgroup size
    requiredSubgroupSizeStages: VkShaderStageFlags = .{},
    // Extern sync: false
    // Optional: false
    maxInlineUniformBlockSize: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxPerStageDescriptorInlineUniformBlocks: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxDescriptorSetInlineUniformBlocks: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxDescriptorSetUpdateAfterBindInlineUniformBlocks: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxInlineUniformTotalSize: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProduct8BitUnsignedAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProduct8BitSignedAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProduct8BitMixedSignednessAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProduct4x8BitPackedUnsignedAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProduct4x8BitPackedSignedAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProduct4x8BitPackedMixedSignednessAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProduct16BitUnsignedAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProduct16BitSignedAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProduct16BitMixedSignednessAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProduct32BitUnsignedAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProduct32BitSignedAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProduct32BitMixedSignednessAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProduct64BitUnsignedAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProduct64BitSignedAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProduct64BitMixedSignednessAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProductAccumulatingSaturating8BitUnsignedAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProductAccumulatingSaturating8BitSignedAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProductAccumulatingSaturating16BitUnsignedAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProductAccumulatingSaturating16BitSignedAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProductAccumulatingSaturating32BitUnsignedAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProductAccumulatingSaturating32BitSignedAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProductAccumulatingSaturating64BitUnsignedAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProductAccumulatingSaturating64BitSignedAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    storageTexelBufferOffsetAlignmentBytes: u64 = 0,
    // Extern sync: false
    // Optional: false
    storageTexelBufferOffsetSingleTexelAlignment: u32 = 0,
    // Extern sync: false
    // Optional: false
    uniformTexelBufferOffsetAlignmentBytes: u64 = 0,
    // Extern sync: false
    // Optional: false
    uniformTexelBufferOffsetSingleTexelAlignment: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxBufferSize: u64 = 0,
};
// Extension: VK_BASE_VERSION_1_4
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceVulkan14Features = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_FEATURES;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    globalPriorityQuery: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderSubgroupRotate: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderSubgroupRotateClustered: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderFloatControls2: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderExpectAssume: u32 = 0,
    // Extern sync: false
    // Optional: false
    rectangularLines: u32 = 0,
    // Extern sync: false
    // Optional: false
    bresenhamLines: u32 = 0,
    // Extern sync: false
    // Optional: false
    smoothLines: u32 = 0,
    // Extern sync: false
    // Optional: false
    stippledRectangularLines: u32 = 0,
    // Extern sync: false
    // Optional: false
    stippledBresenhamLines: u32 = 0,
    // Extern sync: false
    // Optional: false
    stippledSmoothLines: u32 = 0,
    // Extern sync: false
    // Optional: false
    vertexAttributeInstanceRateDivisor: u32 = 0,
    // Extern sync: false
    // Optional: false
    vertexAttributeInstanceRateZeroDivisor: u32 = 0,
    // Extern sync: false
    // Optional: false
    indexTypeUint8: u32 = 0,
    // Extern sync: false
    // Optional: false
    dynamicRenderingLocalRead: u32 = 0,
    // Extern sync: false
    // Optional: false
    maintenance5: u32 = 0,
    // Extern sync: false
    // Optional: false
    maintenance6: u32 = 0,
    // Extern sync: false
    // Optional: false
    pipelineProtectedAccess: u32 = 0,
    // Extern sync: false
    // Optional: false
    pipelineRobustness: u32 = 0,
    // Extern sync: false
    // Optional: false
    hostImageCopy: u32 = 0,
    // Extern sync: false
    // Optional: false
    pushDescriptor: u32 = 0,
};
// Extension: VK_BASE_VERSION_1_4
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceVulkan14Properties = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_PROPERTIES;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    lineSubPixelPrecisionBits: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: max value of vertex attribute divisor
    maxVertexAttribDivisor: u32 = 0,
    // Extern sync: false
    // Optional: false
    supportsNonZeroFirstInstance: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxPushDescriptors: u32 = 0,
    // Extern sync: false
    // Optional: false
    dynamicRenderingLocalReadDepthStencilAttachments: u32 = 0,
    // Extern sync: false
    // Optional: false
    dynamicRenderingLocalReadMultisampledAttachments: u32 = 0,
    // Extern sync: false
    // Optional: false
    earlyFragmentMultisampleCoverageAfterSampleCounting: u32 = 0,
    // Extern sync: false
    // Optional: false
    earlyFragmentSampleMaskTestBeforeSampleCounting: u32 = 0,
    // Extern sync: false
    // Optional: false
    depthStencilSwizzleOneSupport: u32 = 0,
    // Extern sync: false
    // Optional: false
    polygonModePointSize: u32 = 0,
    // Extern sync: false
    // Optional: false
    nonStrictSinglePixelWideLinesUseParallelogram: u32 = 0,
    // Extern sync: false
    // Optional: false
    nonStrictWideLinesUseParallelogram: u32 = 0,
    // Extern sync: false
    // Optional: false
    blockTexelViewCompatibleMultipleLayers: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxCombinedImageSamplerDescriptorCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    fragmentShadingRateClampCombinerInputs: u32 = 0,
    // Extern sync: false
    // Optional: false
    defaultRobustnessStorageBuffers: VkPipelineRobustnessBufferBehavior = .VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DEVICE_DEFAULT,
    // Extern sync: false
    // Optional: false
    defaultRobustnessUniformBuffers: VkPipelineRobustnessBufferBehavior = .VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DEVICE_DEFAULT,
    // Extern sync: false
    // Optional: false
    defaultRobustnessVertexInputs: VkPipelineRobustnessBufferBehavior = .VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DEVICE_DEFAULT,
    // Extern sync: false
    // Optional: false
    defaultRobustnessImages: VkPipelineRobustnessImageBehavior = .VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DEVICE_DEFAULT,
    // Extern sync: false
    // Optional: true
    copySrcLayoutCount: u32 = 0,
    // Length expression: copySrcLayoutCount
    // Extern sync: false
    // Optional: true
    pCopySrcLayouts: ?[*]VkImageLayout = null,
    // Extern sync: false
    // Optional: true
    copyDstLayoutCount: u32 = 0,
    // Length expression: copyDstLayoutCount
    // Extern sync: false
    // Optional: true
    pCopyDstLayouts: ?[*]VkImageLayout = null,
    // Extern sync: false
    // Optional: true
    optimalTilingLayoutUUID: [VK_UUID_SIZE]u8 = @import("std").mem.zeroes([VK_UUID_SIZE]u8),
    // Extern sync: false
    // Optional: false
    identicalMemoryTypeRequirements: u32 = 0,
};
// Extension: VK_AMD_pipeline_compiler_control
// Extends: VkGraphicsPipelineCreateInfo,VkComputePipelineCreateInfo,VkExecutionGraphPipelineCreateInfoAMDX
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineCompilerControlCreateInfoAMD = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    compilerControlFlags: VkPipelineCompilerControlFlagsAMD = .{},
};
// Extension: VK_AMD_device_coherent_memory
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceCoherentMemoryFeaturesAMD = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    deviceCoherentMemory: u32 = 0,
};
// Extension: VKSC_VERSION_1_0
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkFaultData = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_FAULT_DATA;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    faultLevel: VkFaultLevel = .VK_FAULT_LEVEL_UNASSIGNED,
    // Extern sync: false
    // Optional: false
    faultType: VkFaultType = .VK_FAULT_TYPE_INVALID,
};
// Extension: VKSC_VERSION_1_0
// Extends: VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkFaultCallbackInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_FAULT_CALLBACK_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    faultCount: u32 = 0,
    // Length expression: faultCount
    // Extern sync: false
    // Optional: true
    pFaults: ?[*]VkFaultData = null,
    // Extern sync: false
    // Optional: false
    pfnFaultCallback: ?*const vkFaultCallbackFunction = null,
};
// Extension: VK_EXT_tooling_info
// Extension: VK_BASE_VERSION_1_3
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceToolProperties = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Length expression: null-terminated
    // Extern sync: false
    // Optional: false
    name: [VK_MAX_EXTENSION_NAME_SIZE]u8 = @import("std").mem.zeroes([VK_MAX_EXTENSION_NAME_SIZE]u8),
    // Length expression: null-terminated
    // Extern sync: false
    // Optional: false
    version: [VK_MAX_EXTENSION_NAME_SIZE]u8 = @import("std").mem.zeroes([VK_MAX_EXTENSION_NAME_SIZE]u8),
    // Extern sync: false
    // Optional: false
    purposes: VkToolPurposeFlags = .{},
    // Length expression: null-terminated
    // Extern sync: false
    // Optional: false
    description: [VK_MAX_DESCRIPTION_SIZE]u8 = @import("std").mem.zeroes([VK_MAX_DESCRIPTION_SIZE]u8),
    // Length expression: null-terminated
    // Extern sync: false
    // Optional: false
    layer: [VK_MAX_EXTENSION_NAME_SIZE]u8 = @import("std").mem.zeroes([VK_MAX_EXTENSION_NAME_SIZE]u8),
};
// Extension: VK_EXT_custom_border_color
// Extends: VkSamplerCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSamplerCustomBorderColorCreateInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    customBorderColor: VkClearColorValue,
    // Extern sync: false
    // Optional: false
    format: VkFormat = .VK_FORMAT_UNDEFINED,
};
// Extension: VK_EXT_custom_border_color
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceCustomBorderColorPropertiesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    maxCustomBorderColorSamplers: u32 = 0,
};
// Extension: VK_EXT_custom_border_color
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceCustomBorderColorFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    customBorderColors: u32 = 0,
    // Extern sync: false
    // Optional: false
    customBorderColorWithoutFormat: u32 = 0,
};
// Extension: VK_EXT_border_color_swizzle
// Extends: VkSamplerCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSamplerBorderColorComponentMappingCreateInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    components: VkComponentMapping = .{},
    // Extern sync: false
    // Optional: false
    srgb: u32 = 0,
};
// Extension: VK_EXT_border_color_swizzle
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceBorderColorSwizzleFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    borderColorSwizzle: u32 = 0,
    // Extern sync: false
    // Optional: false
    borderColorSwizzleFromImage: u32 = 0,
};
// Extension: VK_KHR_acceleration_structure
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkAccelerationStructureGeometryTrianglesDataKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    vertexFormat: VkFormat = .VK_FORMAT_UNDEFINED,
    // Extern sync: false
    // Optional: false
    vertexData: VkDeviceOrHostAddressConstKHR,
    // Extern sync: false
    // Optional: false
    vertexStride: u64 = 0,
    // Extern sync: false
    // Optional: false
    maxVertex: u32 = 0,
    // Extern sync: false
    // Optional: false
    indexType: VkIndexType = .VK_INDEX_TYPE_UINT16,
    // Extern sync: false
    // Optional: false
    indexData: VkDeviceOrHostAddressConstKHR,
    // Extern sync: false
    // Optional: false
    transformData: VkDeviceOrHostAddressConstKHR,
};
// Extension: VK_KHR_acceleration_structure
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkAccelerationStructureGeometryAabbsDataKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_AABBS_DATA_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    data: VkDeviceOrHostAddressConstKHR,
    // Extern sync: false
    // Optional: false
    stride: u64 = 0,
};
// Extension: VK_KHR_acceleration_structure
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkAccelerationStructureGeometryInstancesDataKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    arrayOfPointers: u32 = 0,
    // Extern sync: false
    // Optional: false
    data: VkDeviceOrHostAddressConstKHR,
};
// Extension: VK_NV_ray_tracing_linear_swept_spheres
// Extends: VkAccelerationStructureGeometryKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkAccelerationStructureGeometryLinearSweptSpheresDataNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_LINEAR_SWEPT_SPHERES_DATA_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    vertexFormat: VkFormat = .VK_FORMAT_UNDEFINED,
    // Extern sync: false
    // Optional: false
    vertexData: VkDeviceOrHostAddressConstKHR,
    // Extern sync: false
    // Optional: false
    vertexStride: u64 = 0,
    // Extern sync: false
    // Optional: false
    radiusFormat: VkFormat = .VK_FORMAT_UNDEFINED,
    // Extern sync: false
    // Optional: false
    radiusData: VkDeviceOrHostAddressConstKHR,
    // Extern sync: false
    // Optional: false
    radiusStride: u64 = 0,
    // Extern sync: false
    // Optional: false
    indexType: VkIndexType = .VK_INDEX_TYPE_UINT16,
    // Extern sync: false
    // Optional: false
    indexData: VkDeviceOrHostAddressConstKHR,
    // Extern sync: false
    // Optional: false
    indexStride: u64 = 0,
    // Extern sync: false
    // Optional: false
    indexingMode: VkRayTracingLssIndexingModeNV = .VK_RAY_TRACING_LSS_INDEXING_MODE_LIST_NV,
    // Extern sync: false
    // Optional: false
    endCapsMode: VkRayTracingLssPrimitiveEndCapsModeNV = .VK_RAY_TRACING_LSS_PRIMITIVE_END_CAPS_MODE_NONE_NV,
};
// Extension: VK_NV_ray_tracing_linear_swept_spheres
// Extends: VkAccelerationStructureGeometryKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkAccelerationStructureGeometrySpheresDataNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_SPHERES_DATA_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    vertexFormat: VkFormat = .VK_FORMAT_UNDEFINED,
    // Extern sync: false
    // Optional: false
    vertexData: VkDeviceOrHostAddressConstKHR,
    // Extern sync: false
    // Optional: false
    vertexStride: u64 = 0,
    // Extern sync: false
    // Optional: false
    radiusFormat: VkFormat = .VK_FORMAT_UNDEFINED,
    // Extern sync: false
    // Optional: false
    radiusData: VkDeviceOrHostAddressConstKHR,
    // Extern sync: false
    // Optional: false
    radiusStride: u64 = 0,
    // Extern sync: false
    // Optional: false
    indexType: VkIndexType = .VK_INDEX_TYPE_UINT16,
    // Extern sync: false
    // Optional: false
    indexData: VkDeviceOrHostAddressConstKHR,
    // Extern sync: false
    // Optional: false
    indexStride: u64 = 0,
};
// Extension: VK_KHR_acceleration_structure
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkAccelerationStructureGeometryKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    geometryType: VkGeometryTypeKHR = .VK_GEOMETRY_TYPE_TRIANGLES_KHR,
    // Extern sync: false
    // Optional: false
    // Selector field: geometryType (What union field is valid)
    geometry: VkAccelerationStructureGeometryDataKHR,
    // Extern sync: false
    // Optional: true
    flags: VkGeometryFlagsKHR = .{},
};
// Extension: VK_KHR_acceleration_structure
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkAccelerationStructureBuildGeometryInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    type: VkAccelerationStructureTypeKHR = .VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR,
    // Extern sync: false
    // Optional: true
    flags: VkBuildAccelerationStructureFlagsKHR = .{},
    // Extern sync: false
    // Optional: false
    mode: VkBuildAccelerationStructureModeKHR = .VK_BUILD_ACCELERATION_STRUCTURE_MODE_BUILD_KHR,
    // Extern sync: false
    // Optional: true
    srcAccelerationStructure: VkAccelerationStructureKHR = .none,
    // Extern sync: false
    // Optional: true
    dstAccelerationStructure: VkAccelerationStructureKHR = .none,
    // Extern sync: false
    // Optional: true
    geometryCount: u32 = 0,
    // Length expression: geometryCount
    // Extern sync: false
    // Optional: true
    pGeometries: ?[*]const VkAccelerationStructureGeometryKHR = null,
    // Length expression: geometryCount,1
    // Extern sync: false
    // Optional: false
    ppGeometries: ?[*]const *const VkAccelerationStructureGeometryKHR = null,
    // Extern sync: false
    // Optional: false
    scratchData: VkDeviceOrHostAddressKHR,
};
// Extension: VK_KHR_acceleration_structure
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkAccelerationStructureBuildRangeInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    primitiveCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    primitiveOffset: u32 = 0,
    // Extern sync: false
    // Optional: false
    firstVertex: u32 = 0,
    // Extern sync: false
    // Optional: false
    transformOffset: u32 = 0,
};
// Extension: VK_KHR_acceleration_structure
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkAccelerationStructureCreateInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    createFlags: VkAccelerationStructureCreateFlagsKHR = .{},
    // Extern sync: false
    // Optional: false
    buffer: VkBuffer = .none,
    // Extern sync: false
    // Optional: false
    // Comment: Specified in bytes
    offset: u64 = 0,
    // Extern sync: false
    // Optional: false
    size: u64 = 0,
    // Extern sync: false
    // Optional: false
    type: VkAccelerationStructureTypeKHR = .VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR,
    // Extern sync: false
    // Optional: true
    deviceAddress: u64 = 0,
};
// Extension: VK_NV_ray_tracing
// Extension: VK_KHR_acceleration_structure
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkAabbPositionsKHR = extern struct {
    // Extern sync: false
    // Optional: false
    minX: f32 = 0,
    // Extern sync: false
    // Optional: false
    minY: f32 = 0,
    // Extern sync: false
    // Optional: false
    minZ: f32 = 0,
    // Extern sync: false
    // Optional: false
    maxX: f32 = 0,
    // Extern sync: false
    // Optional: false
    maxY: f32 = 0,
    // Extern sync: false
    // Optional: false
    maxZ: f32 = 0,
};
// Extension: VK_NV_ray_tracing
// Extension: VK_KHR_acceleration_structure
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkTransformMatrixKHR = extern struct {
    // Extern sync: false
    // Optional: false
    matrix: [3][4]f32 = @import("std").mem.zeroes([3][4]f32),
};
// Extension: VK_NV_ray_tracing
// Extension: VK_KHR_acceleration_structure
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkAccelerationStructureInstanceKHR = extern struct {
    // Extern sync: false
    // Optional: false
    transform: VkTransformMatrixKHR = .{},
    packed_field0: packed struct(u32) {
        instanceCustomIndex: u24 = 0,
        mask: u8 = 0,
        instanceShaderBindingTableRecordOffset: u24 = 0,
        flags: u8 = 0,
    } = .{},
    // Extern sync: false
    // Optional: false
    accelerationStructureReference: u64 = 0,
};
// Extension: VK_KHR_acceleration_structure
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkAccelerationStructureDeviceAddressInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    accelerationStructure: VkAccelerationStructureKHR = .none,
};
// Extension: VK_KHR_acceleration_structure
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkAccelerationStructureVersionInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_VERSION_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Length expression: 2*VK_UUID_SIZE
    // Extern sync: false
    // Optional: false
    pVersionData: ?[*]const u8 = null,
};
// Extension: VK_KHR_acceleration_structure
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkCopyAccelerationStructureInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    src: VkAccelerationStructureKHR = .none,
    // Extern sync: false
    // Optional: false
    dst: VkAccelerationStructureKHR = .none,
    // Extern sync: false
    // Optional: false
    mode: VkCopyAccelerationStructureModeKHR = .VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_KHR,
};
// Extension: VK_KHR_acceleration_structure
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkCopyAccelerationStructureToMemoryInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    src: VkAccelerationStructureKHR = .none,
    // Extern sync: false
    // Optional: false
    dst: VkDeviceOrHostAddressKHR,
    // Extern sync: false
    // Optional: false
    mode: VkCopyAccelerationStructureModeKHR = .VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_KHR,
};
// Extension: VK_KHR_acceleration_structure
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkCopyMemoryToAccelerationStructureInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    src: VkDeviceOrHostAddressConstKHR,
    // Extern sync: false
    // Optional: false
    dst: VkAccelerationStructureKHR = .none,
    // Extern sync: false
    // Optional: false
    mode: VkCopyAccelerationStructureModeKHR = .VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_KHR,
};
// Extension: VK_KHR_ray_tracing_pipeline
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkRayTracingPipelineInterfaceCreateInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_INTERFACE_CREATE_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    maxPipelineRayPayloadSize: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxPipelineRayHitAttributeSize: u32 = 0,
};
// Extension: VK_KHR_pipeline_library
// Extends: VkGraphicsPipelineCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineLibraryCreateInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    libraryCount: u32 = 0,
    // Length expression: libraryCount
    // Extern sync: false
    // Optional: false
    pLibraries: ?[*]const VkPipeline = null,
};
// Extension: VK_KHR_object_refresh
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkRefreshObjectKHR = extern struct {
    // Extern sync: false
    // Optional: false
    objectType: VkObjectType = .VK_OBJECT_TYPE_UNKNOWN,
    // Extern sync: true
    // Optional: false
    // Object type: objectType (Which object handle is this)
    objectHandle: u64 = 0,
    // Extern sync: false
    // Optional: true
    flags: VkRefreshObjectFlagsKHR = .{},
};
// Extension: VK_KHR_object_refresh
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkRefreshObjectListKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_REFRESH_OBJECT_LIST_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    objectCount: u32 = 0,
    // Length expression: objectCount
    // Extern sync: false
    // Optional: false
    pObjects: ?[*]const VkRefreshObjectKHR = null,
};
// Extension: VK_EXT_extended_dynamic_state
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceExtendedDynamicStateFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    extendedDynamicState: u32 = 0,
};
// Extension: VK_EXT_extended_dynamic_state2
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceExtendedDynamicState2FeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    extendedDynamicState2: u32 = 0,
    // Extern sync: false
    // Optional: false
    extendedDynamicState2LogicOp: u32 = 0,
    // Extern sync: false
    // Optional: false
    extendedDynamicState2PatchControlPoints: u32 = 0,
};
// Extension: VK_EXT_extended_dynamic_state3
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceExtendedDynamicState3FeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_FEATURES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    extendedDynamicState3TessellationDomainOrigin: u32 = 0,
    // Extern sync: false
    // Optional: false
    extendedDynamicState3DepthClampEnable: u32 = 0,
    // Extern sync: false
    // Optional: false
    extendedDynamicState3PolygonMode: u32 = 0,
    // Extern sync: false
    // Optional: false
    extendedDynamicState3RasterizationSamples: u32 = 0,
    // Extern sync: false
    // Optional: false
    extendedDynamicState3SampleMask: u32 = 0,
    // Extern sync: false
    // Optional: false
    extendedDynamicState3AlphaToCoverageEnable: u32 = 0,
    // Extern sync: false
    // Optional: false
    extendedDynamicState3AlphaToOneEnable: u32 = 0,
    // Extern sync: false
    // Optional: false
    extendedDynamicState3LogicOpEnable: u32 = 0,
    // Extern sync: false
    // Optional: false
    extendedDynamicState3ColorBlendEnable: u32 = 0,
    // Extern sync: false
    // Optional: false
    extendedDynamicState3ColorBlendEquation: u32 = 0,
    // Extern sync: false
    // Optional: false
    extendedDynamicState3ColorWriteMask: u32 = 0,
    // Extern sync: false
    // Optional: false
    extendedDynamicState3RasterizationStream: u32 = 0,
    // Extern sync: false
    // Optional: false
    extendedDynamicState3ConservativeRasterizationMode: u32 = 0,
    // Extern sync: false
    // Optional: false
    extendedDynamicState3ExtraPrimitiveOverestimationSize: u32 = 0,
    // Extern sync: false
    // Optional: false
    extendedDynamicState3DepthClipEnable: u32 = 0,
    // Extern sync: false
    // Optional: false
    extendedDynamicState3SampleLocationsEnable: u32 = 0,
    // Extern sync: false
    // Optional: false
    extendedDynamicState3ColorBlendAdvanced: u32 = 0,
    // Extern sync: false
    // Optional: false
    extendedDynamicState3ProvokingVertexMode: u32 = 0,
    // Extern sync: false
    // Optional: false
    extendedDynamicState3LineRasterizationMode: u32 = 0,
    // Extern sync: false
    // Optional: false
    extendedDynamicState3LineStippleEnable: u32 = 0,
    // Extern sync: false
    // Optional: false
    extendedDynamicState3DepthClipNegativeOneToOne: u32 = 0,
    // Extern sync: false
    // Optional: false
    extendedDynamicState3ViewportWScalingEnable: u32 = 0,
    // Extern sync: false
    // Optional: false
    extendedDynamicState3ViewportSwizzle: u32 = 0,
    // Extern sync: false
    // Optional: false
    extendedDynamicState3CoverageToColorEnable: u32 = 0,
    // Extern sync: false
    // Optional: false
    extendedDynamicState3CoverageToColorLocation: u32 = 0,
    // Extern sync: false
    // Optional: false
    extendedDynamicState3CoverageModulationMode: u32 = 0,
    // Extern sync: false
    // Optional: false
    extendedDynamicState3CoverageModulationTableEnable: u32 = 0,
    // Extern sync: false
    // Optional: false
    extendedDynamicState3CoverageModulationTable: u32 = 0,
    // Extern sync: false
    // Optional: false
    extendedDynamicState3CoverageReductionMode: u32 = 0,
    // Extern sync: false
    // Optional: false
    extendedDynamicState3RepresentativeFragmentTestEnable: u32 = 0,
    // Extern sync: false
    // Optional: false
    extendedDynamicState3ShadingRateImageEnable: u32 = 0,
};
// Extension: VK_EXT_extended_dynamic_state3
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceExtendedDynamicState3PropertiesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_PROPERTIES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    dynamicPrimitiveTopologyUnrestricted: u32 = 0,
};
// Extension: VK_EXT_extended_dynamic_state3
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkColorBlendEquationEXT = extern struct {
    // Extern sync: false
    // Optional: false
    srcColorBlendFactor: VkBlendFactor = .VK_BLEND_FACTOR_ZERO,
    // Extern sync: false
    // Optional: false
    dstColorBlendFactor: VkBlendFactor = .VK_BLEND_FACTOR_ZERO,
    // Extern sync: false
    // Optional: false
    colorBlendOp: VkBlendOp = .VK_BLEND_OP_ADD,
    // Extern sync: false
    // Optional: false
    srcAlphaBlendFactor: VkBlendFactor = .VK_BLEND_FACTOR_ZERO,
    // Extern sync: false
    // Optional: false
    dstAlphaBlendFactor: VkBlendFactor = .VK_BLEND_FACTOR_ZERO,
    // Extern sync: false
    // Optional: false
    alphaBlendOp: VkBlendOp = .VK_BLEND_OP_ADD,
};
// Extension: VK_EXT_extended_dynamic_state3
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkColorBlendAdvancedEXT = extern struct {
    // Extern sync: false
    // Optional: false
    advancedBlendOp: VkBlendOp = .VK_BLEND_OP_ADD,
    // Extern sync: false
    // Optional: false
    srcPremultiplied: u32 = 0,
    // Extern sync: false
    // Optional: false
    dstPremultiplied: u32 = 0,
    // Extern sync: false
    // Optional: false
    blendOverlap: VkBlendOverlapEXT = .VK_BLEND_OVERLAP_UNCORRELATED_EXT,
    // Extern sync: false
    // Optional: false
    clampResults: u32 = 0,
};
// Extension: VK_QCOM_render_pass_transform
// Extends: VkRenderPassBeginInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkRenderPassTransformBeginInfoQCOM = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    // Comment: Pointer to next structure
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    transform: VkSurfaceTransformFlagsKHR = .{},
};
// Extension: VK_QCOM_rotated_copy_commands
// Extends: VkBufferImageCopy2,VkImageBlit2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkCopyCommandTransformInfoQCOM = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    transform: VkSurfaceTransformFlagsKHR = .{},
};
// Extension: VK_QCOM_render_pass_transform
// Extends: VkCommandBufferInheritanceInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkCommandBufferInheritanceRenderPassTransformInfoQCOM = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    // Comment: Pointer to next structure
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    transform: VkSurfaceTransformFlagsKHR = .{},
    // Extern sync: false
    // Optional: false
    renderArea: VkRect2D = .{},
};
// Extension: VK_NV_partitioned_acceleration_structure
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDevicePartitionedAccelerationStructureFeaturesNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PARTITIONED_ACCELERATION_STRUCTURE_FEATURES_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    partitionedAccelerationStructure: u32 = 0,
};
// Extension: VK_NV_partitioned_acceleration_structure
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDevicePartitionedAccelerationStructurePropertiesNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PARTITIONED_ACCELERATION_STRUCTURE_PROPERTIES_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    maxPartitionCount: u32 = 0,
};
// Extension: VK_NV_partitioned_acceleration_structure
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkBuildPartitionedAccelerationStructureIndirectCommandNV = extern struct {
    // Extern sync: false
    // Optional: false
    opType: VkPartitionedAccelerationStructureOpTypeNV = .VK_PARTITIONED_ACCELERATION_STRUCTURE_OP_TYPE_WRITE_INSTANCE_NV,
    // Extern sync: false
    // Optional: false
    argCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    argData: VkStridedDeviceAddressNV = .{},
};
// Extension: VK_NV_partitioned_acceleration_structure
// Extends: VkPartitionedAccelerationStructureInstancesInputNV
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPartitionedAccelerationStructureFlagsNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PARTITIONED_ACCELERATION_STRUCTURE_FLAGS_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    enablePartitionTranslation: u32 = 0,
};
// Extension: VK_NV_partitioned_acceleration_structure
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPartitionedAccelerationStructureWriteInstanceDataNV = extern struct {
    // Extern sync: false
    // Optional: false
    transform: VkTransformMatrixKHR = .{},
    // Extern sync: false
    // Optional: false
    explicitAABB: [6]f32 = @import("std").mem.zeroes([6]f32),
    // Extern sync: false
    // Optional: false
    instanceID: u32 = 0,
    // Extern sync: false
    // Optional: false
    instanceMask: u32 = 0,
    // Extern sync: false
    // Optional: false
    instanceContributionToHitGroupIndex: u32 = 0,
    // Extern sync: false
    // Optional: true
    instanceFlags: VkPartitionedAccelerationStructureInstanceFlagsNV = .{},
    // Extern sync: false
    // Optional: false
    instanceIndex: u32 = 0,
    // Extern sync: false
    // Optional: false
    partitionIndex: u32 = 0,
    // Extern sync: false
    // Optional: false
    accelerationStructure: u64 = 0,
};
// Extension: VK_NV_partitioned_acceleration_structure
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPartitionedAccelerationStructureUpdateInstanceDataNV = extern struct {
    // Extern sync: false
    // Optional: false
    instanceIndex: u32 = 0,
    // Extern sync: false
    // Optional: false
    instanceContributionToHitGroupIndex: u32 = 0,
    // Extern sync: false
    // Optional: false
    accelerationStructure: u64 = 0,
};
// Extension: VK_NV_partitioned_acceleration_structure
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPartitionedAccelerationStructureWritePartitionTranslationDataNV = extern struct {
    // Extern sync: false
    // Optional: false
    partitionIndex: u32 = 0,
    // Extern sync: false
    // Optional: false
    partitionTranslation: [3]f32 = @import("std").mem.zeroes([3]f32),
};
// Extension: VK_NV_partitioned_acceleration_structure
// Extends: VkWriteDescriptorSet
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkWriteDescriptorSetPartitionedAccelerationStructureNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_PARTITIONED_ACCELERATION_STRUCTURE_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    accelerationStructureCount: u32 = 0,
    // Length expression: accelerationStructureCount
    // Extern sync: false
    // Optional: false
    pAccelerationStructures: ?[*]const u64 = null,
};
// Extension: VK_NV_partitioned_acceleration_structure
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPartitionedAccelerationStructureInstancesInputNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCES_INPUT_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkBuildAccelerationStructureFlagsKHR = .{},
    // Extern sync: false
    // Optional: false
    instanceCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxInstancePerPartitionCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    partitionCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxInstanceInGlobalPartitionCount: u32 = 0,
};
// Extension: VK_NV_partitioned_acceleration_structure
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkBuildPartitionedAccelerationStructureInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_BUILD_PARTITIONED_ACCELERATION_STRUCTURE_INFO_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    input: VkPartitionedAccelerationStructureInstancesInputNV = .{},
    // Extern sync: false
    // Optional: true
    srcAccelerationStructureData: u64 = 0,
    // Extern sync: false
    // Optional: false
    dstAccelerationStructureData: u64 = 0,
    // Extern sync: false
    // Optional: false
    scratchData: u64 = 0,
    // Extern sync: false
    // Optional: false
    srcInfos: u64 = 0,
    // Extern sync: false
    // Optional: false
    srcInfosCount: u64 = 0,
};
// Extension: VK_NV_device_diagnostics_config
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceDiagnosticsConfigFeaturesNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    diagnosticsConfig: u32 = 0,
};
// Extension: VK_NV_device_diagnostics_config
// Extends: VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDeviceDiagnosticsConfigCreateInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkDeviceDiagnosticsConfigFlagsNV = .{},
};
// Extension: VKSC_VERSION_1_0
// Extends: VkGraphicsPipelineCreateInfo,VkComputePipelineCreateInfo,VkRayTracingPipelineCreateInfoKHR,VkRayTracingPipelineCreateInfoNV
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineOfflineCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_OFFLINE_CREATE_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    pipelineIdentifier: [VK_UUID_SIZE]u8 = @import("std").mem.zeroes([VK_UUID_SIZE]u8),
    // Extern sync: false
    // Optional: false
    matchControl: VkPipelineMatchControl = .VK_PIPELINE_MATCH_CONTROL_APPLICATION_UUID_EXACT_MATCH,
    // Extern sync: false
    // Optional: false
    poolEntrySize: u64 = 0,
};
// Extension: VK_KHR_zero_initialize_workgroup_memory
// Extension: VK_COMPUTE_VERSION_1_3
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    shaderZeroInitializeWorkgroupMemory: u32 = 0,
};
// Extension: VK_KHR_shader_subgroup_uniform_control_flow
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    shaderSubgroupUniformControlFlow: u32 = 0,
};
// Extension: VK_EXT_robustness2
// Extension: VK_KHR_robustness2
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceRobustness2FeaturesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    robustBufferAccess2: u32 = 0,
    // Extern sync: false
    // Optional: false
    robustImageAccess2: u32 = 0,
    // Extern sync: false
    // Optional: false
    nullDescriptor: u32 = 0,
};
// Extension: VK_EXT_robustness2
// Extension: VK_KHR_robustness2
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceRobustness2PropertiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    robustStorageBufferAccessSizeAlignment: u64 = 0,
    // Extern sync: false
    // Optional: false
    robustUniformBufferAccessSizeAlignment: u64 = 0,
};
// Extension: VK_EXT_image_robustness
// Extension: VK_COMPUTE_VERSION_1_3
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceImageRobustnessFeatures = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    robustImageAccess: u32 = 0,
};
// Extension: VK_KHR_workgroup_memory_explicit_layout
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    workgroupMemoryExplicitLayout: u32 = 0,
    // Extern sync: false
    // Optional: false
    workgroupMemoryExplicitLayoutScalarBlockLayout: u32 = 0,
    // Extern sync: false
    // Optional: false
    workgroupMemoryExplicitLayout8BitAccess: u32 = 0,
    // Extern sync: false
    // Optional: false
    workgroupMemoryExplicitLayout16BitAccess: u32 = 0,
};
// Extension: VK_KHR_portability_subset
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDevicePortabilitySubsetFeaturesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_FEATURES_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    constantAlphaColorBlendFactors: u32 = 0,
    // Extern sync: false
    // Optional: false
    events: u32 = 0,
    // Extern sync: false
    // Optional: false
    imageViewFormatReinterpretation: u32 = 0,
    // Extern sync: false
    // Optional: false
    imageViewFormatSwizzle: u32 = 0,
    // Extern sync: false
    // Optional: false
    imageView2DOn3DImage: u32 = 0,
    // Extern sync: false
    // Optional: false
    multisampleArrayImage: u32 = 0,
    // Extern sync: false
    // Optional: false
    mutableComparisonSamplers: u32 = 0,
    // Extern sync: false
    // Optional: false
    pointPolygons: u32 = 0,
    // Extern sync: false
    // Optional: false
    samplerMipLodBias: u32 = 0,
    // Extern sync: false
    // Optional: false
    separateStencilMaskRef: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderSampleRateInterpolationFunctions: u32 = 0,
    // Extern sync: false
    // Optional: false
    tessellationIsolines: u32 = 0,
    // Extern sync: false
    // Optional: false
    tessellationPointMode: u32 = 0,
    // Extern sync: false
    // Optional: false
    triangleFans: u32 = 0,
    // Extern sync: false
    // Optional: false
    vertexAttributeAccessBeyondStride: u32 = 0,
};
// Extension: VK_KHR_portability_subset
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDevicePortabilitySubsetPropertiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_PROPERTIES_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    minVertexInputBindingStrideAlignment: u32 = 0,
};
// Extension: VK_EXT_4444_formats
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDevice4444FormatsFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    formatA4R4G4B4: u32 = 0,
    // Extern sync: false
    // Optional: false
    formatA4B4G4R4: u32 = 0,
};
// Extension: VK_HUAWEI_subpass_shading
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceSubpassShadingFeaturesHUAWEI = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    subpassShading: u32 = 0,
};
// Extension: VK_HUAWEI_cluster_culling_shader
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_FEATURES_HUAWEI;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    clustercullingShader: u32 = 0,
    // Extern sync: false
    // Optional: false
    multiviewClusterCullingShader: u32 = 0,
};
// Extension: VK_HUAWEI_cluster_culling_shader
// Extends: VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_VRS_FEATURES_HUAWEI;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    clusterShadingRate: u32 = 0,
};
// Extension: VK_KHR_copy_commands2
// Extension: VK_BASE_VERSION_1_3
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkBufferCopy2 = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_BUFFER_COPY_2;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: Specified in bytes
    srcOffset: u64 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Specified in bytes
    dstOffset: u64 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Specified in bytes
    size: u64 = 0,
};
// Extension: VK_KHR_copy_commands2
// Extension: VK_BASE_VERSION_1_3
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImageCopy2 = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_IMAGE_COPY_2;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    srcSubresource: VkImageSubresourceLayers = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Specified in pixels for both compressed and uncompressed images
    srcOffset: VkOffset3D = .{},
    // Extern sync: false
    // Optional: false
    dstSubresource: VkImageSubresourceLayers = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Specified in pixels for both compressed and uncompressed images
    dstOffset: VkOffset3D = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Specified in pixels for both compressed and uncompressed images
    extent: VkExtent3D = .{},
};
// Extension: VK_KHR_copy_commands2
// Extension: VK_GRAPHICS_VERSION_1_3
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImageBlit2 = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_IMAGE_BLIT_2;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    srcSubresource: VkImageSubresourceLayers = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Specified in pixels for both compressed and uncompressed images
    srcOffsets: [2]VkOffset3D = .{VkOffset3D{}} ** 2,
    // Extern sync: false
    // Optional: false
    dstSubresource: VkImageSubresourceLayers = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Specified in pixels for both compressed and uncompressed images
    dstOffsets: [2]VkOffset3D = .{VkOffset3D{}} ** 2,
};
// Extension: VK_KHR_copy_commands2
// Extension: VK_BASE_VERSION_1_3
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkBufferImageCopy2 = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: Specified in bytes
    bufferOffset: u64 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Specified in texels
    bufferRowLength: u32 = 0,
    // Extern sync: false
    // Optional: false
    bufferImageHeight: u32 = 0,
    // Extern sync: false
    // Optional: false
    imageSubresource: VkImageSubresourceLayers = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Specified in pixels for both compressed and uncompressed images
    imageOffset: VkOffset3D = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Specified in pixels for both compressed and uncompressed images
    imageExtent: VkExtent3D = .{},
};
// Extension: VK_KHR_copy_commands2
// Extension: VK_GRAPHICS_VERSION_1_3
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImageResolve2 = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    srcSubresource: VkImageSubresourceLayers = .{},
    // Extern sync: false
    // Optional: false
    srcOffset: VkOffset3D = .{},
    // Extern sync: false
    // Optional: false
    dstSubresource: VkImageSubresourceLayers = .{},
    // Extern sync: false
    // Optional: false
    dstOffset: VkOffset3D = .{},
    // Extern sync: false
    // Optional: false
    extent: VkExtent3D = .{},
};
// Extension: VK_KHR_copy_commands2
// Extension: VK_BASE_VERSION_1_3
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkCopyBufferInfo2 = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    srcBuffer: VkBuffer = .none,
    // Extern sync: false
    // Optional: false
    dstBuffer: VkBuffer = .none,
    // Extern sync: false
    // Optional: false
    regionCount: u32 = 0,
    // Length expression: regionCount
    // Extern sync: false
    // Optional: false
    pRegions: ?[*]const VkBufferCopy2 = null,
};
// Extension: VK_KHR_copy_commands2
// Extension: VK_BASE_VERSION_1_3
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkCopyImageInfo2 = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    srcImage: VkImage = .none,
    // Extern sync: false
    // Optional: false
    srcImageLayout: VkImageLayout = .VK_IMAGE_LAYOUT_UNDEFINED,
    // Extern sync: false
    // Optional: false
    dstImage: VkImage = .none,
    // Extern sync: false
    // Optional: false
    dstImageLayout: VkImageLayout = .VK_IMAGE_LAYOUT_UNDEFINED,
    // Extern sync: false
    // Optional: false
    regionCount: u32 = 0,
    // Length expression: regionCount
    // Extern sync: false
    // Optional: false
    pRegions: ?[*]const VkImageCopy2 = null,
};
// Extension: VK_KHR_copy_commands2
// Extension: VK_GRAPHICS_VERSION_1_3
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkBlitImageInfo2 = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    srcImage: VkImage = .none,
    // Extern sync: false
    // Optional: false
    srcImageLayout: VkImageLayout = .VK_IMAGE_LAYOUT_UNDEFINED,
    // Extern sync: false
    // Optional: false
    dstImage: VkImage = .none,
    // Extern sync: false
    // Optional: false
    dstImageLayout: VkImageLayout = .VK_IMAGE_LAYOUT_UNDEFINED,
    // Extern sync: false
    // Optional: false
    regionCount: u32 = 0,
    // Length expression: regionCount
    // Extern sync: false
    // Optional: false
    pRegions: ?[*]const VkImageBlit2 = null,
    // Extern sync: false
    // Optional: false
    filter: VkFilter = .VK_FILTER_NEAREST,
};
// Extension: VK_KHR_copy_commands2
// Extension: VK_BASE_VERSION_1_3
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkCopyBufferToImageInfo2 = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    srcBuffer: VkBuffer = .none,
    // Extern sync: false
    // Optional: false
    dstImage: VkImage = .none,
    // Extern sync: false
    // Optional: false
    dstImageLayout: VkImageLayout = .VK_IMAGE_LAYOUT_UNDEFINED,
    // Extern sync: false
    // Optional: false
    regionCount: u32 = 0,
    // Length expression: regionCount
    // Extern sync: false
    // Optional: false
    pRegions: ?[*]const VkBufferImageCopy2 = null,
};
// Extension: VK_KHR_copy_commands2
// Extension: VK_BASE_VERSION_1_3
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkCopyImageToBufferInfo2 = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    srcImage: VkImage = .none,
    // Extern sync: false
    // Optional: false
    srcImageLayout: VkImageLayout = .VK_IMAGE_LAYOUT_UNDEFINED,
    // Extern sync: false
    // Optional: false
    dstBuffer: VkBuffer = .none,
    // Extern sync: false
    // Optional: false
    regionCount: u32 = 0,
    // Length expression: regionCount
    // Extern sync: false
    // Optional: false
    pRegions: ?[*]const VkBufferImageCopy2 = null,
};
// Extension: VK_KHR_copy_commands2
// Extension: VK_GRAPHICS_VERSION_1_3
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkResolveImageInfo2 = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    srcImage: VkImage = .none,
    // Extern sync: false
    // Optional: false
    srcImageLayout: VkImageLayout = .VK_IMAGE_LAYOUT_UNDEFINED,
    // Extern sync: false
    // Optional: false
    dstImage: VkImage = .none,
    // Extern sync: false
    // Optional: false
    dstImageLayout: VkImageLayout = .VK_IMAGE_LAYOUT_UNDEFINED,
    // Extern sync: false
    // Optional: false
    regionCount: u32 = 0,
    // Length expression: regionCount
    // Extern sync: false
    // Optional: false
    pRegions: ?[*]const VkImageResolve2 = null,
};
// Extension: VK_EXT_shader_image_atomic_int64
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    shaderImageInt64Atomics: u32 = 0,
    // Extern sync: false
    // Optional: false
    sparseImageInt64Atomics: u32 = 0,
};
// Extension: VK_KHR_fragment_shading_rate
// Extends: VkSubpassDescription2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkFragmentShadingRateAttachmentInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    pFragmentShadingRateAttachment: ?*const VkAttachmentReference2 = null,
    // Extern sync: false
    // Optional: false
    shadingRateAttachmentTexelSize: VkExtent2D = .{},
};
// Extension: VK_KHR_fragment_shading_rate
// Extends: VkGraphicsPipelineCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineFragmentShadingRateStateCreateInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    fragmentSize: VkExtent2D = .{},
    // Extern sync: false
    // Optional: false
    combinerOps: [2]VkFragmentShadingRateCombinerOpKHR = .{VkFragmentShadingRateCombinerOpKHR.VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR} ** 2,
};
// Extension: VK_KHR_fragment_shading_rate
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceFragmentShadingRateFeaturesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    pipelineFragmentShadingRate: u32 = 0,
    // Extern sync: false
    // Optional: false
    primitiveFragmentShadingRate: u32 = 0,
    // Extern sync: false
    // Optional: false
    attachmentFragmentShadingRate: u32 = 0,
};
// Extension: VK_KHR_fragment_shading_rate
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceFragmentShadingRatePropertiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    minFragmentShadingRateAttachmentTexelSize: VkExtent2D = .{},
    // Extern sync: false
    // Optional: false
    maxFragmentShadingRateAttachmentTexelSize: VkExtent2D = .{},
    // Extern sync: false
    // Optional: false
    maxFragmentShadingRateAttachmentTexelSizeAspectRatio: u32 = 0,
    // Extern sync: false
    // Optional: false
    primitiveFragmentShadingRateWithMultipleViewports: u32 = 0,
    // Extern sync: false
    // Optional: false
    layeredShadingRateAttachments: u32 = 0,
    // Extern sync: false
    // Optional: false
    fragmentShadingRateNonTrivialCombinerOps: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxFragmentSize: VkExtent2D = .{},
    // Extern sync: false
    // Optional: false
    maxFragmentSizeAspectRatio: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxFragmentShadingRateCoverageSamples: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxFragmentShadingRateRasterizationSamples: VkSampleCountFlags = .{},
    // Extern sync: false
    // Optional: false
    fragmentShadingRateWithShaderDepthStencilWrites: u32 = 0,
    // Extern sync: false
    // Optional: false
    fragmentShadingRateWithSampleMask: u32 = 0,
    // Extern sync: false
    // Optional: false
    fragmentShadingRateWithShaderSampleMask: u32 = 0,
    // Extern sync: false
    // Optional: false
    fragmentShadingRateWithConservativeRasterization: u32 = 0,
    // Extern sync: false
    // Optional: false
    fragmentShadingRateWithFragmentShaderInterlock: u32 = 0,
    // Extern sync: false
    // Optional: false
    fragmentShadingRateWithCustomSampleLocations: u32 = 0,
    // Extern sync: false
    // Optional: false
    fragmentShadingRateStrictMultiplyCombiner: u32 = 0,
};
// Extension: VK_KHR_fragment_shading_rate
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceFragmentShadingRateKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    sampleCounts: VkSampleCountFlags = .{},
    // Extern sync: false
    // Optional: false
    fragmentSize: VkExtent2D = .{},
};
// Extension: VK_KHR_shader_terminate_invocation
// Extension: VK_COMPUTE_VERSION_1_3
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceShaderTerminateInvocationFeatures = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    shaderTerminateInvocation: u32 = 0,
};
// Extension: VK_NV_fragment_shading_rate_enums
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    fragmentShadingRateEnums: u32 = 0,
    // Extern sync: false
    // Optional: false
    supersampleFragmentShadingRates: u32 = 0,
    // Extern sync: false
    // Optional: false
    noInvocationFragmentShadingRates: u32 = 0,
};
// Extension: VK_NV_fragment_shading_rate_enums
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    maxFragmentShadingRateInvocationCount: VkSampleCountFlags = .{},
};
// Extension: VK_NV_fragment_shading_rate_enums
// Extends: VkGraphicsPipelineCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineFragmentShadingRateEnumStateCreateInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    shadingRateType: VkFragmentShadingRateTypeNV = .VK_FRAGMENT_SHADING_RATE_TYPE_FRAGMENT_SIZE_NV,
    // Extern sync: false
    // Optional: false
    shadingRate: VkFragmentShadingRateNV = .VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_PIXEL_NV,
    // Extern sync: false
    // Optional: false
    combinerOps: [2]VkFragmentShadingRateCombinerOpKHR = .{VkFragmentShadingRateCombinerOpKHR.VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR} ** 2,
};
// Extension: VK_KHR_acceleration_structure
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkAccelerationStructureBuildSizesInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    accelerationStructureSize: u64 = 0,
    // Extern sync: false
    // Optional: false
    updateScratchSize: u64 = 0,
    // Extern sync: false
    // Optional: false
    buildScratchSize: u64 = 0,
};
// Extension: VK_EXT_image_2d_view_of_3d
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceImage2DViewOf3DFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    image2DViewOf3D: u32 = 0,
    // Extern sync: false
    // Optional: false
    sampler2DViewOf3D: u32 = 0,
};
// Extension: VK_EXT_image_sliced_view_of_3d
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_SLICED_VIEW_OF_3D_FEATURES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    imageSlicedViewOf3D: u32 = 0,
};
// Extension: VK_EXT_attachment_feedback_loop_dynamic_state
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_FEATURES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    attachmentFeedbackLoopDynamicState: u32 = 0,
};
// Extension: VK_EXT_legacy_vertex_attributes
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_FEATURES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    legacyVertexAttributes: u32 = 0,
};
// Extension: VK_EXT_legacy_vertex_attributes
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_PROPERTIES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    nativeUnalignedPerformance: u32 = 0,
};
// Extension: VK_VALVE_mutable_descriptor_type
// Extension: VK_EXT_mutable_descriptor_type
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    mutableDescriptorType: u32 = 0,
};
// Extension: VK_VALVE_mutable_descriptor_type
// Extension: VK_EXT_mutable_descriptor_type
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkMutableDescriptorTypeListEXT = extern struct {
    // Extern sync: false
    // Optional: true
    descriptorTypeCount: u32 = 0,
    // Length expression: descriptorTypeCount
    // Extern sync: false
    // Optional: false
    pDescriptorTypes: ?[*]const VkDescriptorType = null,
};
// Extension: VK_VALVE_mutable_descriptor_type
// Extension: VK_EXT_mutable_descriptor_type
// Extends: VkDescriptorSetLayoutCreateInfo,VkDescriptorPoolCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkMutableDescriptorTypeCreateInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    mutableDescriptorTypeListCount: u32 = 0,
    // Length expression: mutableDescriptorTypeListCount
    // Extern sync: false
    // Optional: false
    pMutableDescriptorTypeLists: ?[*]const VkMutableDescriptorTypeListEXT = null,
};
// Extension: VK_EXT_depth_clip_control
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceDepthClipControlFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    depthClipControl: u32 = 0,
};
// Extension: VK_EXT_zero_initialize_device_memory
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_DEVICE_MEMORY_FEATURES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    zeroInitializeDeviceMemory: u32 = 0,
};
// Extension: VK_EXT_custom_resolve
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkBeginCustomResolveInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_BEGIN_CUSTOM_RESOLVE_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
};
// Extension: VK_EXT_custom_resolve
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceCustomResolveFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_RESOLVE_FEATURES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    customResolve: u32 = 0,
};
// Extension: VK_EXT_custom_resolve
// Extends: VkGraphicsPipelineCreateInfo,VkCommandBufferInheritanceInfo,VkShaderCreateInfoEXT
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkCustomResolveCreateInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_CUSTOM_RESOLVE_CREATE_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    customResolve: u32 = 0,
    // Extern sync: false
    // Optional: true
    colorAttachmentCount: u32 = 0,
    // Length expression: colorAttachmentCount
    // Extern sync: false
    // Optional: false
    pColorAttachmentFormats: ?[*]const VkFormat = null,
    // Extern sync: false
    // Optional: false
    depthAttachmentFormat: VkFormat = .VK_FORMAT_UNDEFINED,
    // Extern sync: false
    // Optional: false
    stencilAttachmentFormat: VkFormat = .VK_FORMAT_UNDEFINED,
};
// Extension: VK_EXT_device_generated_commands
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    deviceGeneratedCommands: u32 = 0,
    // Extern sync: false
    // Optional: false
    dynamicGeneratedPipelineLayout: u32 = 0,
};
// Extension: VK_EXT_device_generated_commands
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    maxIndirectPipelineCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxIndirectShaderObjectCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxIndirectSequenceCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxIndirectCommandsTokenCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxIndirectCommandsTokenOffset: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxIndirectCommandsIndirectStride: u32 = 0,
    // Extern sync: false
    // Optional: false
    supportedIndirectCommandsInputModes: VkIndirectCommandsInputModeFlagsEXT = .{},
    // Extern sync: false
    // Optional: false
    supportedIndirectCommandsShaderStages: VkShaderStageFlags = .{},
    // Extern sync: false
    // Optional: false
    supportedIndirectCommandsShaderStagesPipelineBinding: VkShaderStageFlags = .{},
    // Extern sync: false
    // Optional: false
    supportedIndirectCommandsShaderStagesShaderBinding: VkShaderStageFlags = .{},
    // Extern sync: false
    // Optional: false
    deviceGeneratedCommandsTransformFeedback: u32 = 0,
    // Extern sync: false
    // Optional: false
    deviceGeneratedCommandsMultiDrawIndirectCount: u32 = 0,
};
// Extension: VK_EXT_device_generated_commands
// Extends: VkGeneratedCommandsInfoEXT,VkGeneratedCommandsMemoryRequirementsInfoEXT
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkGeneratedCommandsPipelineInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_GENERATED_COMMANDS_PIPELINE_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    pipeline: VkPipeline = .none,
};
// Extension: VK_EXT_device_generated_commands
// Extends: VkGeneratedCommandsInfoEXT,VkGeneratedCommandsMemoryRequirementsInfoEXT
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkGeneratedCommandsShaderInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_GENERATED_COMMANDS_SHADER_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    shaderCount: u32 = 0,
    // Length expression: shaderCount
    // Extern sync: false
    // Optional: false
    pShaders: ?[*]const VkShaderEXT = null,
};
// Extension: VK_EXT_device_generated_commands
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkGeneratedCommandsMemoryRequirementsInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    indirectExecutionSet: VkIndirectExecutionSetEXT = .none,
    // Extern sync: false
    // Optional: false
    indirectCommandsLayout: VkIndirectCommandsLayoutEXT = .none,
    // Extern sync: false
    // Optional: false
    maxSequenceCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxDrawCount: u32 = 0,
};
// Extension: VK_EXT_device_generated_commands
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkIndirectExecutionSetPipelineInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_PIPELINE_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    initialPipeline: VkPipeline = .none,
    // Extern sync: false
    // Optional: false
    maxPipelineCount: u32 = 0,
};
// Extension: VK_EXT_device_generated_commands
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkIndirectExecutionSetShaderLayoutInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_SHADER_LAYOUT_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    setLayoutCount: u32 = 0,
    // Length expression: setLayoutCount
    // Extern sync: false
    // Optional: false
    pSetLayouts: ?[*]const VkDescriptorSetLayout = null,
};
// Extension: VK_EXT_device_generated_commands
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkIndirectExecutionSetShaderInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_SHADER_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    shaderCount: u32 = 0,
    // Length expression: shaderCount
    // Extern sync: false
    // Optional: false
    pInitialShaders: ?[*]const VkShaderEXT = null,
    // Length expression: shaderCount
    // Extern sync: false
    // Optional: true
    pSetLayoutInfos: ?[*]const VkIndirectExecutionSetShaderLayoutInfoEXT = null,
    // Extern sync: false
    // Optional: false
    maxShaderCount: u32 = 0,
    // Extern sync: false
    // Optional: true
    pushConstantRangeCount: u32 = 0,
    // Length expression: pushConstantRangeCount
    // Extern sync: false
    // Optional: false
    pPushConstantRanges: ?[*]const VkPushConstantRange = null,
};
// Extension: VK_EXT_device_generated_commands
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkIndirectExecutionSetCreateInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_CREATE_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    type: VkIndirectExecutionSetInfoTypeEXT = .VK_INDIRECT_EXECUTION_SET_INFO_TYPE_PIPELINES_EXT,
    // Extern sync: false
    // Optional: false
    // Selector field: type (What union field is valid)
    info: VkIndirectExecutionSetInfoEXT,
};
// Extension: VK_EXT_device_generated_commands
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkGeneratedCommandsInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    shaderStages: VkShaderStageFlags = .{},
    // Extern sync: false
    // Optional: true
    indirectExecutionSet: VkIndirectExecutionSetEXT = .none,
    // Extern sync: false
    // Optional: false
    indirectCommandsLayout: VkIndirectCommandsLayoutEXT = .none,
    // Extern sync: false
    // Optional: false
    indirectAddress: u64 = 0,
    // Extern sync: false
    // Optional: false
    indirectAddressSize: u64 = 0,
    // Extern sync: false
    // Optional: true
    preprocessAddress: u64 = 0,
    // Extern sync: false
    // Optional: false
    preprocessSize: u64 = 0,
    // Extern sync: false
    // Optional: false
    maxSequenceCount: u32 = 0,
    // Extern sync: false
    // Optional: true
    sequenceCountAddress: u64 = 0,
    // Extern sync: false
    // Optional: false
    maxDrawCount: u32 = 0,
};
// Extension: VK_EXT_device_generated_commands
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkWriteIndirectExecutionSetPipelineEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_WRITE_INDIRECT_EXECUTION_SET_PIPELINE_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    index: u32 = 0,
    // Extern sync: false
    // Optional: false
    pipeline: VkPipeline = .none,
};
// Extension: VK_EXT_device_generated_commands
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkWriteIndirectExecutionSetShaderEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_WRITE_INDIRECT_EXECUTION_SET_SHADER_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    index: u32 = 0,
    // Extern sync: false
    // Optional: false
    shader: VkShaderEXT = .none,
};
// Extension: VK_EXT_device_generated_commands
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkIndirectCommandsLayoutCreateInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkIndirectCommandsLayoutUsageFlagsEXT = .{},
    // Extern sync: false
    // Optional: false
    shaderStages: VkShaderStageFlags = .{},
    // Extern sync: false
    // Optional: false
    indirectStride: u32 = 0,
    // Extern sync: false
    // Optional: true
    pipelineLayout: VkPipelineLayout = .none,
    // Extern sync: false
    // Optional: false
    tokenCount: u32 = 0,
    // Length expression: tokenCount
    // Extern sync: false
    // Optional: false
    pTokens: ?[*]const VkIndirectCommandsLayoutTokenEXT = null,
};
// Extension: VK_EXT_device_generated_commands
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkIndirectCommandsLayoutTokenEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    type: VkIndirectCommandsTokenTypeEXT = .VK_INDIRECT_COMMANDS_TOKEN_TYPE_EXECUTION_SET_EXT,
    // Extern sync: false
    // Optional: false
    // Selector field: type (What union field is valid)
    data: VkIndirectCommandsTokenDataEXT,
    // Extern sync: false
    // Optional: false
    offset: u32 = 0,
};
// Extension: VK_EXT_device_generated_commands
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDrawIndirectCountIndirectCommandEXT = extern struct {
    // Extern sync: false
    // Optional: false
    bufferAddress: u64 = 0,
    // Extern sync: false
    // Optional: false
    stride: u32 = 0,
    // Extern sync: false
    // Optional: false
    commandCount: u32 = 0,
};
// Extension: VK_EXT_device_generated_commands
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkIndirectCommandsVertexBufferTokenEXT = extern struct {
    // Extern sync: false
    // Optional: false
    vertexBindingUnit: u32 = 0,
};
// Extension: VK_EXT_device_generated_commands
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkBindVertexBufferIndirectCommandEXT = extern struct {
    // Extern sync: false
    // Optional: false
    bufferAddress: u64 = 0,
    // Extern sync: false
    // Optional: false
    size: u32 = 0,
    // Extern sync: false
    // Optional: false
    stride: u32 = 0,
};
// Extension: VK_EXT_device_generated_commands
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkIndirectCommandsIndexBufferTokenEXT = extern struct {
    // Extern sync: false
    // Optional: false
    mode: VkIndirectCommandsInputModeFlagsEXT = .{},
};
// Extension: VK_EXT_device_generated_commands
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkBindIndexBufferIndirectCommandEXT = extern struct {
    // Extern sync: false
    // Optional: false
    bufferAddress: u64 = 0,
    // Extern sync: false
    // Optional: false
    size: u32 = 0,
    // Extern sync: false
    // Optional: false
    indexType: VkIndexType = .VK_INDEX_TYPE_UINT16,
};
// Extension: VK_EXT_device_generated_commands
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkIndirectCommandsPushConstantTokenEXT = extern struct {
    // Extern sync: false
    // Optional: false
    updateRange: VkPushConstantRange = .{},
};
// Extension: VK_EXT_device_generated_commands
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkIndirectCommandsExecutionSetTokenEXT = extern struct {
    // Extern sync: false
    // Optional: false
    type: VkIndirectExecutionSetInfoTypeEXT = .VK_INDIRECT_EXECUTION_SET_INFO_TYPE_PIPELINES_EXT,
    // Extern sync: false
    // Optional: false
    shaderStages: VkShaderStageFlags = .{},
};
// Extension: VK_EXT_depth_clip_control
// Extends: VkPipelineViewportStateCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineViewportDepthClipControlCreateInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLIP_CONTROL_CREATE_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    negativeOneToOne: u32 = 0,
};
// Extension: VK_EXT_depth_clamp_control
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceDepthClampControlFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_CONTROL_FEATURES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    depthClampControl: u32 = 0,
};
// Extension: VK_EXT_depth_clamp_control
// Extends: VkPipelineViewportStateCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineViewportDepthClampControlCreateInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLAMP_CONTROL_CREATE_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    depthClampMode: VkDepthClampModeEXT = .VK_DEPTH_CLAMP_MODE_VIEWPORT_RANGE_EXT,
    // Extern sync: false
    // Optional: true
    pDepthClampRange: ?*const VkDepthClampRangeEXT = null,
};
// Extension: VK_EXT_vertex_input_dynamic_state
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    vertexInputDynamicState: u32 = 0,
};
// Extension: VK_NV_external_memory_rdma
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceExternalMemoryRDMAFeaturesNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_RDMA_FEATURES_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    externalMemoryRDMA: u32 = 0,
};
// Extension: VK_KHR_shader_relaxed_extended_instruction
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_RELAXED_EXTENDED_INSTRUCTION_FEATURES_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    shaderRelaxedExtendedInstruction: u32 = 0,
};
// Extension: VK_EXT_vertex_input_dynamic_state
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVertexInputBindingDescription2EXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VERTEX_INPUT_BINDING_DESCRIPTION_2_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    binding: u32 = 0,
    // Extern sync: false
    // Optional: false
    stride: u32 = 0,
    // Extern sync: false
    // Optional: false
    inputRate: VkVertexInputRate = .VK_VERTEX_INPUT_RATE_VERTEX,
    // Extern sync: false
    // Optional: false
    divisor: u32 = 0,
};
// Extension: VK_EXT_vertex_input_dynamic_state
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVertexInputAttributeDescription2EXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VERTEX_INPUT_ATTRIBUTE_DESCRIPTION_2_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: location of the shader vertex attrib
    location: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Vertex buffer binding id
    binding: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: format of source data
    format: VkFormat = .VK_FORMAT_UNDEFINED,
    // Extern sync: false
    // Optional: false
    // Comment: Offset of first element in bytes from base of vertex
    offset: u32 = 0,
};
// Extension: VK_EXT_color_write_enable
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceColorWriteEnableFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    colorWriteEnable: u32 = 0,
};
// Extension: VK_EXT_color_write_enable
// Extends: VkPipelineColorBlendStateCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineColorWriteCreateInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_COLOR_WRITE_CREATE_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    // Comment: # of pAttachments
    attachmentCount: u32 = 0,
    // Length expression: attachmentCount
    // Extern sync: false
    // Optional: false
    pColorWriteEnables: ?[*]const u32 = null,
};
// Extension: VK_KHR_synchronization2
// Extension: VK_BASE_VERSION_1_3
// Extends: VkSubpassDependency2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkMemoryBarrier2 = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_MEMORY_BARRIER_2;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    srcStageMask: VkPipelineStageFlags2 = .{},
    // Extern sync: false
    // Optional: true
    srcAccessMask: VkAccessFlags2 = .{},
    // Extern sync: false
    // Optional: true
    dstStageMask: VkPipelineStageFlags2 = .{},
    // Extern sync: false
    // Optional: true
    dstAccessMask: VkAccessFlags2 = .{},
};
// Extension: VK_KHR_synchronization2
// Extension: VK_BASE_VERSION_1_3
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImageMemoryBarrier2 = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    srcStageMask: VkPipelineStageFlags2 = .{},
    // Extern sync: false
    // Optional: true
    srcAccessMask: VkAccessFlags2 = .{},
    // Extern sync: false
    // Optional: true
    dstStageMask: VkPipelineStageFlags2 = .{},
    // Extern sync: false
    // Optional: true
    dstAccessMask: VkAccessFlags2 = .{},
    // Extern sync: false
    // Optional: false
    oldLayout: VkImageLayout = .VK_IMAGE_LAYOUT_UNDEFINED,
    // Extern sync: false
    // Optional: false
    newLayout: VkImageLayout = .VK_IMAGE_LAYOUT_UNDEFINED,
    // Extern sync: false
    // Optional: false
    srcQueueFamilyIndex: u32 = 0,
    // Extern sync: false
    // Optional: false
    dstQueueFamilyIndex: u32 = 0,
    // Extern sync: false
    // Optional: false
    image: VkImage = .none,
    // Extern sync: false
    // Optional: false
    subresourceRange: VkImageSubresourceRange = .{},
};
// Extension: VK_KHR_synchronization2
// Extension: VK_BASE_VERSION_1_3
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkBufferMemoryBarrier2 = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    srcStageMask: VkPipelineStageFlags2 = .{},
    // Extern sync: false
    // Optional: true
    srcAccessMask: VkAccessFlags2 = .{},
    // Extern sync: false
    // Optional: true
    dstStageMask: VkPipelineStageFlags2 = .{},
    // Extern sync: false
    // Optional: true
    dstAccessMask: VkAccessFlags2 = .{},
    // Extern sync: false
    // Optional: false
    srcQueueFamilyIndex: u32 = 0,
    // Extern sync: false
    // Optional: false
    dstQueueFamilyIndex: u32 = 0,
    // Extern sync: false
    // Optional: false
    buffer: VkBuffer = .none,
    // Extern sync: false
    // Optional: false
    offset: u64 = 0,
    // Extern sync: false
    // Optional: false
    size: u64 = 0,
};
// Extension: VK_KHR_maintenance8
// Extends: VkSubpassDependency2,VkBufferMemoryBarrier2,VkImageMemoryBarrier2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkMemoryBarrierAccessFlags3KHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_MEMORY_BARRIER_ACCESS_FLAGS_3_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    srcAccessMask3: VkAccessFlags3KHR = .{},
    // Extern sync: false
    // Optional: true
    dstAccessMask3: VkAccessFlags3KHR = .{},
};
// Extension: VK_KHR_synchronization2
// Extension: VK_BASE_VERSION_1_3
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDependencyInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_DEPENDENCY_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    dependencyFlags: VkDependencyFlags = .{},
    // Extern sync: false
    // Optional: true
    memoryBarrierCount: u32 = 0,
    // Length expression: memoryBarrierCount
    // Extern sync: false
    // Optional: false
    pMemoryBarriers: ?[*]const VkMemoryBarrier2 = null,
    // Extern sync: false
    // Optional: true
    bufferMemoryBarrierCount: u32 = 0,
    // Length expression: bufferMemoryBarrierCount
    // Extern sync: false
    // Optional: false
    pBufferMemoryBarriers: ?[*]const VkBufferMemoryBarrier2 = null,
    // Extern sync: false
    // Optional: true
    imageMemoryBarrierCount: u32 = 0,
    // Length expression: imageMemoryBarrierCount
    // Extern sync: false
    // Optional: false
    pImageMemoryBarriers: ?[*]const VkImageMemoryBarrier2 = null,
};
// Extension: VK_KHR_synchronization2
// Extension: VK_BASE_VERSION_1_3
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSemaphoreSubmitInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    semaphore: VkSemaphore = .none,
    // Extern sync: false
    // Optional: false
    value: u64 = 0,
    // Extern sync: false
    // Optional: true
    stageMask: VkPipelineStageFlags2 = .{},
    // Extern sync: false
    // Optional: false
    deviceIndex: u32 = 0,
};
// Extension: VK_KHR_synchronization2
// Extension: VK_BASE_VERSION_1_3
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkCommandBufferSubmitInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    commandBuffer: VkCommandBuffer = .none,
    // Extern sync: false
    // Optional: false
    deviceMask: u32 = 0,
};
// Extension: VK_KHR_synchronization2
// Extension: VK_BASE_VERSION_1_3
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSubmitInfo2 = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_SUBMIT_INFO_2;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkSubmitFlags = .{},
    // Extern sync: false
    // Optional: true
    waitSemaphoreInfoCount: u32 = 0,
    // Length expression: waitSemaphoreInfoCount
    // Extern sync: false
    // Optional: false
    pWaitSemaphoreInfos: ?[*]const VkSemaphoreSubmitInfo = null,
    // Extern sync: false
    // Optional: true
    commandBufferInfoCount: u32 = 0,
    // Length expression: commandBufferInfoCount
    // Extern sync: false
    // Optional: false
    pCommandBufferInfos: ?[*]const VkCommandBufferSubmitInfo = null,
    // Extern sync: false
    // Optional: true
    signalSemaphoreInfoCount: u32 = 0,
    // Length expression: signalSemaphoreInfoCount
    // Extern sync: false
    // Optional: false
    pSignalSemaphoreInfos: ?[*]const VkSemaphoreSubmitInfo = null,
};
// Extension: VK_NV_device_diagnostic_checkpoints
// Extends: VkQueueFamilyProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkQueueFamilyCheckpointProperties2NV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    checkpointExecutionStageMask: VkPipelineStageFlags2 = .{},
};
// Extension: VK_NV_device_diagnostic_checkpoints
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkCheckpointData2NV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_CHECKPOINT_DATA_2_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    stage: VkPipelineStageFlags2 = .{},
    // Extern sync: false
    // Optional: false
    pCheckpointMarker: ?*anyopaque = null,
};
// Extension: VK_KHR_synchronization2
// Extension: VK_BASE_VERSION_1_3
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceSynchronization2Features = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    synchronization2: u32 = 0,
};
// Extension: VK_KHR_unified_image_layouts
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceUnifiedImageLayoutsFeaturesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFIED_IMAGE_LAYOUTS_FEATURES_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    unifiedImageLayouts: u32 = 0,
    // Extern sync: false
    // Optional: false
    unifiedImageLayoutsVideo: u32 = 0,
};
// Extension: VK_EXT_host_image_copy
// Extension: VK_BASE_VERSION_1_4
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceHostImageCopyFeatures = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    hostImageCopy: u32 = 0,
};
// Extension: VK_EXT_host_image_copy
// Extension: VK_BASE_VERSION_1_4
// Extends: VkPhysicalDeviceProperties2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceHostImageCopyProperties = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_PROPERTIES;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: true
    copySrcLayoutCount: u32 = 0,
    // Length expression: copySrcLayoutCount
    // Extern sync: false
    // Optional: true
    pCopySrcLayouts: ?[*]VkImageLayout = null,
    // Extern sync: false
    // Optional: true
    copyDstLayoutCount: u32 = 0,
    // Length expression: copyDstLayoutCount
    // Extern sync: false
    // Optional: true
    pCopyDstLayouts: ?[*]VkImageLayout = null,
    // Extern sync: false
    // Optional: true
    optimalTilingLayoutUUID: [VK_UUID_SIZE]u8 = @import("std").mem.zeroes([VK_UUID_SIZE]u8),
    // Extern sync: false
    // Optional: false
    identicalMemoryTypeRequirements: u32 = 0,
};
// Extension: VK_EXT_host_image_copy
// Extension: VK_BASE_VERSION_1_4
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkMemoryToImageCopy = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_MEMORY_TO_IMAGE_COPY;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    pHostPointer: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: Specified in texels
    memoryRowLength: u32 = 0,
    // Extern sync: false
    // Optional: false
    memoryImageHeight: u32 = 0,
    // Extern sync: false
    // Optional: false
    imageSubresource: VkImageSubresourceLayers = .{},
    // Extern sync: false
    // Optional: false
    imageOffset: VkOffset3D = .{},
    // Extern sync: false
    // Optional: false
    imageExtent: VkExtent3D = .{},
};
// Extension: VK_EXT_host_image_copy
// Extension: VK_BASE_VERSION_1_4
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImageToMemoryCopy = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_IMAGE_TO_MEMORY_COPY;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    pHostPointer: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: Specified in texels
    memoryRowLength: u32 = 0,
    // Extern sync: false
    // Optional: false
    memoryImageHeight: u32 = 0,
    // Extern sync: false
    // Optional: false
    imageSubresource: VkImageSubresourceLayers = .{},
    // Extern sync: false
    // Optional: false
    imageOffset: VkOffset3D = .{},
    // Extern sync: false
    // Optional: false
    imageExtent: VkExtent3D = .{},
};
// Extension: VK_EXT_host_image_copy
// Extension: VK_BASE_VERSION_1_4
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkCopyMemoryToImageInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_COPY_MEMORY_TO_IMAGE_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkHostImageCopyFlags = .{},
    // Extern sync: false
    // Optional: false
    dstImage: VkImage = .none,
    // Extern sync: false
    // Optional: false
    dstImageLayout: VkImageLayout = .VK_IMAGE_LAYOUT_UNDEFINED,
    // Extern sync: false
    // Optional: false
    regionCount: u32 = 0,
    // Length expression: regionCount
    // Extern sync: false
    // Optional: false
    pRegions: ?[*]const VkMemoryToImageCopy = null,
};
// Extension: VK_EXT_host_image_copy
// Extension: VK_BASE_VERSION_1_4
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkCopyImageToMemoryInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_COPY_IMAGE_TO_MEMORY_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkHostImageCopyFlags = .{},
    // Extern sync: false
    // Optional: false
    srcImage: VkImage = .none,
    // Extern sync: false
    // Optional: false
    srcImageLayout: VkImageLayout = .VK_IMAGE_LAYOUT_UNDEFINED,
    // Extern sync: false
    // Optional: false
    regionCount: u32 = 0,
    // Length expression: regionCount
    // Extern sync: false
    // Optional: false
    pRegions: ?[*]const VkImageToMemoryCopy = null,
};
// Extension: VK_EXT_host_image_copy
// Extension: VK_BASE_VERSION_1_4
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkCopyImageToImageInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_COPY_IMAGE_TO_IMAGE_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkHostImageCopyFlags = .{},
    // Extern sync: false
    // Optional: false
    srcImage: VkImage = .none,
    // Extern sync: false
    // Optional: false
    srcImageLayout: VkImageLayout = .VK_IMAGE_LAYOUT_UNDEFINED,
    // Extern sync: false
    // Optional: false
    dstImage: VkImage = .none,
    // Extern sync: false
    // Optional: false
    dstImageLayout: VkImageLayout = .VK_IMAGE_LAYOUT_UNDEFINED,
    // Extern sync: false
    // Optional: false
    regionCount: u32 = 0,
    // Length expression: regionCount
    // Extern sync: false
    // Optional: false
    pRegions: ?[*]const VkImageCopy2 = null,
};
// Extension: VK_EXT_host_image_copy
// Extension: VK_BASE_VERSION_1_4
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkHostImageLayoutTransitionInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_HOST_IMAGE_LAYOUT_TRANSITION_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    image: VkImage = .none,
    // Extern sync: false
    // Optional: false
    oldLayout: VkImageLayout = .VK_IMAGE_LAYOUT_UNDEFINED,
    // Extern sync: false
    // Optional: false
    newLayout: VkImageLayout = .VK_IMAGE_LAYOUT_UNDEFINED,
    // Extern sync: false
    // Optional: false
    subresourceRange: VkImageSubresourceRange = .{},
};
// Extension: VK_EXT_host_image_copy
// Extension: VK_BASE_VERSION_1_4
// Extends: VkSubresourceLayout2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkSubresourceHostMemcpySize = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_SUBRESOURCE_HOST_MEMCPY_SIZE;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: Specified in bytes
    size: u64 = 0,
};
// Extension: VK_EXT_host_image_copy
// Extension: VK_BASE_VERSION_1_4
// Extends: VkImageFormatProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkHostImageCopyDevicePerformanceQuery = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_HOST_IMAGE_COPY_DEVICE_PERFORMANCE_QUERY;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: Specifies if device access is optimal
    optimalDeviceAccess: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Specifies if memory layout is identical
    identicalMemoryLayout: u32 = 0,
};
// Extension: VKSC_VERSION_1_0
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceVulkanSC10Properties = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_SC_1_0_PROPERTIES;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    deviceNoDynamicHostAllocations: u32 = 0,
    // Extern sync: false
    // Optional: false
    deviceDestroyFreesMemory: u32 = 0,
    // Extern sync: false
    // Optional: false
    commandPoolMultipleCommandBuffersRecording: u32 = 0,
    // Extern sync: false
    // Optional: false
    commandPoolResetCommandBuffer: u32 = 0,
    // Extern sync: false
    // Optional: false
    commandBufferSimultaneousUse: u32 = 0,
    // Extern sync: false
    // Optional: false
    secondaryCommandBufferNullOrImagelessFramebuffer: u32 = 0,
    // Extern sync: false
    // Optional: false
    recycleDescriptorSetMemory: u32 = 0,
    // Extern sync: false
    // Optional: false
    recyclePipelineMemory: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxRenderPassSubpasses: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxRenderPassDependencies: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxSubpassInputAttachments: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxSubpassPreserveAttachments: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxFramebufferAttachments: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxDescriptorSetLayoutBindings: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxQueryFaultCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxCallbackFaultCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxCommandPoolCommandBuffers: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxCommandBufferSize: u64 = 0,
};
// Extension: VKSC_VERSION_1_0
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelinePoolSize = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_POOL_SIZE;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    poolEntrySize: u64 = 0,
    // Extern sync: false
    // Optional: false
    poolEntryCount: u32 = 0,
};
// Extension: VKSC_VERSION_1_0
// Extends: VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: true
pub const VkDeviceObjectReservationCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_DEVICE_OBJECT_RESERVATION_CREATE_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    pipelineCacheCreateInfoCount: u32 = 0,
    // Length expression: pipelineCacheCreateInfoCount
    // Extern sync: false
    // Optional: false
    pPipelineCacheCreateInfos: ?[*]const VkPipelineCacheCreateInfo = null,
    // Extern sync: false
    // Optional: true
    pipelinePoolSizeCount: u32 = 0,
    // Length expression: pipelinePoolSizeCount
    // Extern sync: false
    // Optional: false
    pPipelinePoolSizes: ?[*]const VkPipelinePoolSize = null,
    // Extern sync: false
    // Optional: true
    semaphoreRequestCount: u32 = 0,
    // Extern sync: false
    // Optional: true
    commandBufferRequestCount: u32 = 0,
    // Extern sync: false
    // Optional: true
    fenceRequestCount: u32 = 0,
    // Extern sync: false
    // Optional: true
    deviceMemoryRequestCount: u32 = 0,
    // Extern sync: false
    // Optional: true
    bufferRequestCount: u32 = 0,
    // Extern sync: false
    // Optional: true
    imageRequestCount: u32 = 0,
    // Extern sync: false
    // Optional: true
    eventRequestCount: u32 = 0,
    // Extern sync: false
    // Optional: true
    queryPoolRequestCount: u32 = 0,
    // Extern sync: false
    // Optional: true
    bufferViewRequestCount: u32 = 0,
    // Extern sync: false
    // Optional: true
    imageViewRequestCount: u32 = 0,
    // Extern sync: false
    // Optional: true
    layeredImageViewRequestCount: u32 = 0,
    // Extern sync: false
    // Optional: true
    pipelineCacheRequestCount: u32 = 0,
    // Extern sync: false
    // Optional: true
    pipelineLayoutRequestCount: u32 = 0,
    // Extern sync: false
    // Optional: true
    renderPassRequestCount: u32 = 0,
    // Extern sync: false
    // Optional: true
    graphicsPipelineRequestCount: u32 = 0,
    // Extern sync: false
    // Optional: true
    computePipelineRequestCount: u32 = 0,
    // Extern sync: false
    // Optional: true
    descriptorSetLayoutRequestCount: u32 = 0,
    // Extern sync: false
    // Optional: true
    samplerRequestCount: u32 = 0,
    // Extern sync: false
    // Optional: true
    descriptorPoolRequestCount: u32 = 0,
    // Extern sync: false
    // Optional: true
    descriptorSetRequestCount: u32 = 0,
    // Extern sync: false
    // Optional: true
    framebufferRequestCount: u32 = 0,
    // Extern sync: false
    // Optional: true
    commandPoolRequestCount: u32 = 0,
    // Extern sync: false
    // Optional: true
    samplerYcbcrConversionRequestCount: u32 = 0,
    // Extern sync: false
    // Optional: true
    surfaceRequestCount: u32 = 0,
    // Extern sync: false
    // Optional: true
    swapchainRequestCount: u32 = 0,
    // Extern sync: false
    // Optional: true
    displayModeRequestCount: u32 = 0,
    // Extern sync: false
    // Optional: true
    subpassDescriptionRequestCount: u32 = 0,
    // Extern sync: false
    // Optional: true
    attachmentDescriptionRequestCount: u32 = 0,
    // Extern sync: false
    // Optional: true
    descriptorSetLayoutBindingRequestCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    descriptorSetLayoutBindingLimit: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxImageViewMipLevels: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxImageViewArrayLayers: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxLayeredImageViewMipLevels: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxOcclusionQueriesPerPool: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxPipelineStatisticsQueriesPerPool: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxTimestampQueriesPerPool: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxImmutableSamplersPerDescriptorSetLayout: u32 = 0,
};
// Extension: VKSC_VERSION_1_0
// Extends: VkCommandPoolCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkCommandPoolMemoryReservationCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_COMMAND_POOL_MEMORY_RESERVATION_CREATE_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    commandPoolReservedSize: u64 = 0,
    // Extern sync: false
    // Optional: false
    commandPoolMaxCommandBuffers: u32 = 0,
};
// Extension: VKSC_VERSION_1_0
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkCommandPoolMemoryConsumption = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_COMMAND_POOL_MEMORY_CONSUMPTION;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    commandPoolAllocated: u64 = 0,
    // Extern sync: false
    // Optional: false
    commandPoolReservedSize: u64 = 0,
    // Extern sync: false
    // Optional: false
    commandBufferAllocated: u64 = 0,
};
// Extension: VKSC_VERSION_1_0
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceVulkanSC10Features = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_SC_1_0_FEATURES;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    shaderAtomicInstructions: u32 = 0,
};
// Extension: VK_EXT_primitives_generated_query
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    primitivesGeneratedQuery: u32 = 0,
    // Extern sync: false
    // Optional: false
    primitivesGeneratedQueryWithRasterizerDiscard: u32 = 0,
    // Extern sync: false
    // Optional: false
    primitivesGeneratedQueryWithNonZeroStreams: u32 = 0,
};
// Extension: VK_EXT_legacy_dithering
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceLegacyDitheringFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    legacyDithering: u32 = 0,
};
// Extension: VK_EXT_multisampled_render_to_single_sampled
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    multisampledRenderToSingleSampled: u32 = 0,
};
// Extension: VK_KHR_present_id2
// Extends: VkSurfaceCapabilities2KHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSurfaceCapabilitiesPresentId2KHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_ID_2_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    presentId2Supported: u32 = 0,
};
// Extension: VK_KHR_present_wait2
// Extends: VkSurfaceCapabilities2KHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSurfaceCapabilitiesPresentWait2KHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_WAIT_2_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    presentWait2Supported: u32 = 0,
};
// Extension: VK_EXT_multisampled_render_to_single_sampled
// Extends: VkFormatProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkSubpassResolvePerformanceQueryEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_SUBPASS_RESOLVE_PERFORMANCE_QUERY_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    optimal: u32 = 0,
};
// Extension: VK_EXT_multisampled_render_to_single_sampled
// Extends: VkSubpassDescription2,VkRenderingInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkMultisampledRenderToSingleSampledInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    multisampledRenderToSingleSampledEnable: u32 = 0,
    // Extern sync: false
    // Optional: false
    rasterizationSamples: VkSampleCountFlags = .{},
};
// Extension: VK_EXT_pipeline_protected_access
// Extension: VK_COMPUTE_VERSION_1_4
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDevicePipelineProtectedAccessFeatures = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    pipelineProtectedAccess: u32 = 0,
};
// Extension: VK_KHR_video_queue
// Extends: VkQueueFamilyProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkQueueFamilyVideoPropertiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_QUEUE_FAMILY_VIDEO_PROPERTIES_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    videoCodecOperations: VkVideoCodecOperationFlagsKHR = .{},
};
// Extension: VK_KHR_video_queue
// Extends: VkQueueFamilyProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkQueueFamilyQueryResultStatusPropertiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_QUEUE_FAMILY_QUERY_RESULT_STATUS_PROPERTIES_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    queryResultStatusSupport: u32 = 0,
};
// Extension: VK_KHR_video_queue
// Extends: VkPhysicalDeviceImageFormatInfo2,VkPhysicalDeviceVideoFormatInfoKHR,VkImageCreateInfo,VkBufferCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoProfileListInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    profileCount: u32 = 0,
    // Length expression: profileCount
    // Extern sync: false
    // Optional: false
    pProfiles: ?[*]const VkVideoProfileInfoKHR = null,
};
// Extension: VK_KHR_video_queue
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceVideoFormatInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_FORMAT_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    imageUsage: VkImageUsageFlags = .{},
};
// Extension: VK_KHR_video_queue
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkVideoFormatPropertiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_FORMAT_PROPERTIES_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    format: VkFormat = .VK_FORMAT_UNDEFINED,
    // Extern sync: false
    // Optional: false
    componentMapping: VkComponentMapping = .{},
    // Extern sync: false
    // Optional: false
    imageCreateFlags: VkImageCreateFlags = .{},
    // Extern sync: false
    // Optional: false
    imageType: VkImageType = .VK_IMAGE_TYPE_1D,
    // Extern sync: false
    // Optional: false
    imageTiling: VkImageTiling = .VK_IMAGE_TILING_OPTIMAL,
    // Extern sync: false
    // Optional: false
    imageUsageFlags: VkImageUsageFlags = .{},
};
// Extension: VK_KHR_video_encode_quantization_map
// Extends: VkVideoCapabilitiesKHR
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeQuantizationMapCapabilitiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_CAPABILITIES_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    maxQuantizationMapExtent: VkExtent2D = .{},
};
// Extension: VK_KHR_video_encode_quantization_map
// Extends: VkVideoCapabilitiesKHR
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeH264QuantizationMapCapabilitiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_QUANTIZATION_MAP_CAPABILITIES_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    minQpDelta: i32 = 0,
    // Extern sync: false
    // Optional: false
    maxQpDelta: i32 = 0,
};
// Extension: VK_KHR_video_encode_quantization_map
// Extends: VkVideoCapabilitiesKHR
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeH265QuantizationMapCapabilitiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_QUANTIZATION_MAP_CAPABILITIES_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    minQpDelta: i32 = 0,
    // Extern sync: false
    // Optional: false
    maxQpDelta: i32 = 0,
};
// Extension: VK_KHR_video_encode_quantization_map
// Extends: VkVideoCapabilitiesKHR
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeAV1QuantizationMapCapabilitiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_QUANTIZATION_MAP_CAPABILITIES_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    minQIndexDelta: i32 = 0,
    // Extern sync: false
    // Optional: false
    maxQIndexDelta: i32 = 0,
};
// Extension: VK_KHR_video_encode_quantization_map
// Extends: VkVideoFormatPropertiesKHR
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkVideoFormatQuantizationMapPropertiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_FORMAT_QUANTIZATION_MAP_PROPERTIES_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    quantizationMapTexelSize: VkExtent2D = .{},
};
// Extension: VK_KHR_video_encode_quantization_map
// Extends: VkVideoFormatPropertiesKHR
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkVideoFormatH265QuantizationMapPropertiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_FORMAT_H265_QUANTIZATION_MAP_PROPERTIES_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    compatibleCtbSizes: VkVideoEncodeH265CtbSizeFlagsKHR = .{},
};
// Extension: VK_KHR_video_encode_quantization_map
// Extends: VkVideoFormatPropertiesKHR
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkVideoFormatAV1QuantizationMapPropertiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_FORMAT_AV1_QUANTIZATION_MAP_PROPERTIES_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    compatibleSuperblockSizes: VkVideoEncodeAV1SuperblockSizeFlagsKHR = .{},
};
// Extension: VK_KHR_video_queue
// Extends: VkQueryPoolCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoProfileInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_PROFILE_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    videoCodecOperation: VkVideoCodecOperationFlagsKHR = .{},
    // Extern sync: false
    // Optional: false
    chromaSubsampling: VkVideoChromaSubsamplingFlagsKHR = .{},
    // Extern sync: false
    // Optional: false
    lumaBitDepth: VkVideoComponentBitDepthFlagsKHR = .{},
    // Extern sync: false
    // Optional: true
    chromaBitDepth: VkVideoComponentBitDepthFlagsKHR = .{},
};
// Extension: VK_KHR_video_queue
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkVideoCapabilitiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_CAPABILITIES_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    flags: VkVideoCapabilityFlagsKHR = .{},
    // Extern sync: false
    // Optional: false
    minBitstreamBufferOffsetAlignment: u64 = 0,
    // Extern sync: false
    // Optional: false
    minBitstreamBufferSizeAlignment: u64 = 0,
    // Extern sync: false
    // Optional: false
    pictureAccessGranularity: VkExtent2D = .{},
    // Extern sync: false
    // Optional: false
    minCodedExtent: VkExtent2D = .{},
    // Extern sync: false
    // Optional: false
    maxCodedExtent: VkExtent2D = .{},
    // Extern sync: false
    // Optional: false
    maxDpbSlots: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxActiveReferencePictures: u32 = 0,
    // Extern sync: false
    // Optional: false
    stdHeaderVersion: VkExtensionProperties = .{},
};
// Extension: VK_KHR_video_queue
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkVideoSessionMemoryRequirementsKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_SESSION_MEMORY_REQUIREMENTS_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    memoryBindIndex: u32 = 0,
    // Extern sync: false
    // Optional: false
    memoryRequirements: VkMemoryRequirements = .{},
};
// Extension: VK_KHR_video_queue
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkBindVideoSessionMemoryInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_BIND_VIDEO_SESSION_MEMORY_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    memoryBindIndex: u32 = 0,
    // Extern sync: false
    // Optional: false
    memory: VkDeviceMemory = .none,
    // Extern sync: false
    // Optional: false
    memoryOffset: u64 = 0,
    // Extern sync: false
    // Optional: false
    memorySize: u64 = 0,
};
// Extension: VK_KHR_video_queue
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoPictureResourceInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_PICTURE_RESOURCE_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: The offset to be used for the picture resource, currently only used in field mode
    codedOffset: VkOffset2D = .{},
    // Extern sync: false
    // Optional: false
    // Comment: The extent to be used for the picture resource
    codedExtent: VkExtent2D = .{},
    // Extern sync: false
    // Optional: false
    // Comment: The first array layer to be accessed for the Decode or Encode Operations
    baseArrayLayer: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: The ImageView binding of the resource
    imageViewBinding: VkImageView = .none,
};
// Extension: VK_KHR_video_queue
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoReferenceSlotInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_REFERENCE_SLOT_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: The reference slot index
    slotIndex: i32 = 0,
    // Extern sync: false
    // Optional: true
    // Comment: The reference picture resource
    pPictureResource: ?*const VkVideoPictureResourceInfoKHR = null,
};
// Extension: VK_KHR_video_decode_queue
// Extends: VkVideoCapabilitiesKHR
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkVideoDecodeCapabilitiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_DECODE_CAPABILITIES_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    flags: VkVideoDecodeCapabilityFlagsKHR = .{},
};
// Extension: VK_KHR_video_decode_queue
// Extends: VkVideoProfileInfoKHR,VkQueryPoolCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoDecodeUsageInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_DECODE_USAGE_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    videoUsageHints: VkVideoDecodeUsageFlagsKHR = .{},
};
// Extension: VK_KHR_video_decode_queue
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoDecodeInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_DECODE_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkVideoDecodeFlagsKHR = .{},
    // Extern sync: false
    // Optional: false
    srcBuffer: VkBuffer = .none,
    // Extern sync: false
    // Optional: false
    srcBufferOffset: u64 = 0,
    // Extern sync: false
    // Optional: false
    srcBufferRange: u64 = 0,
    // Extern sync: false
    // Optional: false
    dstPictureResource: VkVideoPictureResourceInfoKHR = .{},
    // Extern sync: false
    // Optional: true
    pSetupReferenceSlot: ?*const VkVideoReferenceSlotInfoKHR = null,
    // Extern sync: false
    // Optional: true
    referenceSlotCount: u32 = 0,
    // Length expression: referenceSlotCount
    // Extern sync: false
    // Optional: false
    pReferenceSlots: ?[*]const VkVideoReferenceSlotInfoKHR = null,
};
// Extension: VK_KHR_video_maintenance1
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceVideoMaintenance1FeaturesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_1_FEATURES_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    videoMaintenance1: u32 = 0,
};
// Extension: VK_KHR_video_maintenance2
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceVideoMaintenance2FeaturesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_2_FEATURES_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    videoMaintenance2: u32 = 0,
};
// Extension: VK_KHR_video_maintenance1
// Extends: VkVideoDecodeInfoKHR,VkVideoEncodeInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoInlineQueryInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_INLINE_QUERY_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    queryPool: VkQueryPool = .none,
    // Extern sync: false
    // Optional: false
    firstQuery: u32 = 0,
    // Extern sync: false
    // Optional: false
    queryCount: u32 = 0,
};
// Extension: VK_KHR_video_decode_h264
// Extends: VkVideoProfileInfoKHR,VkQueryPoolCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoDecodeH264ProfileInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PROFILE_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Extern sync: false
    // Optional: true
    pictureLayout: VkVideoDecodeH264PictureLayoutFlagsKHR = .{},
};
// Extension: VK_KHR_video_decode_h264
// Extends: VkVideoCapabilitiesKHR
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkVideoDecodeH264CapabilitiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_CAPABILITIES_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Extern sync: false
    // Optional: false
    fieldOffsetGranularity: VkOffset2D = .{},
};
// Extension: VK_KHR_video_decode_h264
// Extends: VkVideoSessionParametersUpdateInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoDecodeH264SessionParametersAddInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    stdSPSCount: u32 = 0,
    // Length expression: stdSPSCount
    // Extern sync: false
    // Optional: false
    pStdSPSs: ?[*]const StdVideoH264SequenceParameterSet = null,
    // Extern sync: false
    // Optional: true
    stdPPSCount: u32 = 0,
    // Length expression: stdPPSCount
    // Extern sync: false
    // Optional: false
    // Comment: List of Picture Parameters associated with the spsStd, above
    pStdPPSs: ?[*]const StdVideoH264PictureParameterSet = null,
};
// Extension: VK_KHR_video_decode_h264
// Extends: VkVideoSessionParametersCreateInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoDecodeH264SessionParametersCreateInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    maxStdSPSCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxStdPPSCount: u32 = 0,
    // Extern sync: false
    // Optional: true
    pParametersAddInfo: ?*const VkVideoDecodeH264SessionParametersAddInfoKHR = null,
};
// Extension: VK_KHR_video_maintenance2
// Extends: VkVideoDecodeInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoDecodeH264InlineSessionParametersInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_INLINE_SESSION_PARAMETERS_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    pStdSPS: ?*const StdVideoH264SequenceParameterSet = null,
    // Extern sync: false
    // Optional: true
    pStdPPS: ?*const StdVideoH264PictureParameterSet = null,
};
// Extension: VK_KHR_video_decode_h264
// Extends: VkVideoDecodeInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoDecodeH264PictureInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PICTURE_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    pStdPictureInfo: ?*const StdVideoDecodeH264PictureInfo = null,
    // Extern sync: false
    // Optional: false
    sliceCount: u32 = 0,
    // Length expression: sliceCount
    // Extern sync: false
    // Optional: false
    pSliceOffsets: ?[*]const u32 = null,
};
// Extension: VK_KHR_video_decode_h264
// Extends: VkVideoReferenceSlotInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoDecodeH264DpbSlotInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_DPB_SLOT_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    pStdReferenceInfo: ?*const StdVideoDecodeH264ReferenceInfo = null,
};
// Extension: VK_KHR_video_decode_h265
// Extends: VkVideoProfileInfoKHR,VkQueryPoolCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoDecodeH265ProfileInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PROFILE_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
};
// Extension: VK_KHR_video_decode_h265
// Extends: VkVideoCapabilitiesKHR
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkVideoDecodeH265CapabilitiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_CAPABILITIES_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
};
// Extension: VK_KHR_video_decode_h265
// Extends: VkVideoSessionParametersUpdateInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoDecodeH265SessionParametersAddInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    stdVPSCount: u32 = 0,
    // Length expression: stdVPSCount
    // Extern sync: false
    // Optional: false
    pStdVPSs: ?[*]const StdVideoH265VideoParameterSet = null,
    // Extern sync: false
    // Optional: true
    stdSPSCount: u32 = 0,
    // Length expression: stdSPSCount
    // Extern sync: false
    // Optional: false
    pStdSPSs: ?[*]const StdVideoH265SequenceParameterSet = null,
    // Extern sync: false
    // Optional: true
    stdPPSCount: u32 = 0,
    // Length expression: stdPPSCount
    // Extern sync: false
    // Optional: false
    // Comment: List of Picture Parameters associated with the spsStd, above
    pStdPPSs: ?[*]const StdVideoH265PictureParameterSet = null,
};
// Extension: VK_KHR_video_decode_h265
// Extends: VkVideoSessionParametersCreateInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoDecodeH265SessionParametersCreateInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    maxStdVPSCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxStdSPSCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxStdPPSCount: u32 = 0,
    // Extern sync: false
    // Optional: true
    pParametersAddInfo: ?*const VkVideoDecodeH265SessionParametersAddInfoKHR = null,
};
// Extension: VK_KHR_video_maintenance2
// Extends: VkVideoDecodeInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoDecodeH265InlineSessionParametersInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_INLINE_SESSION_PARAMETERS_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    pStdVPS: ?*const StdVideoH265VideoParameterSet = null,
    // Extern sync: false
    // Optional: true
    pStdSPS: ?*const StdVideoH265SequenceParameterSet = null,
    // Extern sync: false
    // Optional: true
    pStdPPS: ?*const StdVideoH265PictureParameterSet = null,
};
// Extension: VK_KHR_video_decode_h265
// Extends: VkVideoDecodeInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoDecodeH265PictureInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PICTURE_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    pStdPictureInfo: ?*const StdVideoDecodeH265PictureInfo = null,
    // Extern sync: false
    // Optional: false
    sliceSegmentCount: u32 = 0,
    // Length expression: sliceSegmentCount
    // Extern sync: false
    // Optional: false
    pSliceSegmentOffsets: ?[*]const u32 = null,
};
// Extension: VK_KHR_video_decode_h265
// Extends: VkVideoReferenceSlotInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoDecodeH265DpbSlotInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_DPB_SLOT_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    pStdReferenceInfo: ?*const StdVideoDecodeH265ReferenceInfo = null,
};
// Extension: VK_KHR_video_decode_vp9
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceVideoDecodeVP9FeaturesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_DECODE_VP9_FEATURES_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    videoDecodeVP9: u32 = 0,
};
// Extension: VK_KHR_video_decode_vp9
// Extends: VkVideoProfileInfoKHR,VkQueryPoolCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoDecodeVP9ProfileInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_DECODE_VP9_PROFILE_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
};
// Extension: VK_KHR_video_decode_vp9
// Extends: VkVideoCapabilitiesKHR
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkVideoDecodeVP9CapabilitiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_DECODE_VP9_CAPABILITIES_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
};
// Extension: VK_KHR_video_decode_vp9
// Extends: VkVideoDecodeInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoDecodeVP9PictureInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_DECODE_VP9_PICTURE_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    pStdPictureInfo: ?*const StdVideoDecodeVP9PictureInfo = null,
    // Extern sync: false
    // Optional: false
    referenceNameSlotIndices: [VK_MAX_VIDEO_VP9_REFERENCES_PER_FRAME_KHR]i32 = @import("std").mem.zeroes([VK_MAX_VIDEO_VP9_REFERENCES_PER_FRAME_KHR]i32),
    // Extern sync: false
    // Optional: false
    uncompressedHeaderOffset: u32 = 0,
    // Extern sync: false
    // Optional: false
    compressedHeaderOffset: u32 = 0,
    // Extern sync: false
    // Optional: false
    tilesOffset: u32 = 0,
};
// Extension: VK_KHR_video_decode_av1
// Extends: VkVideoProfileInfoKHR,VkQueryPoolCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoDecodeAV1ProfileInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_PROFILE_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Extern sync: false
    // Optional: false
    filmGrainSupport: u32 = 0,
};
// Extension: VK_KHR_video_decode_av1
// Extends: VkVideoCapabilitiesKHR
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkVideoDecodeAV1CapabilitiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_CAPABILITIES_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
};
// Extension: VK_KHR_video_decode_av1
// Extends: VkVideoSessionParametersCreateInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoDecodeAV1SessionParametersCreateInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_SESSION_PARAMETERS_CREATE_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    pStdSequenceHeader: ?*const StdVideoAV1SequenceHeader = null,
};
// Extension: VK_KHR_video_maintenance2
// Extends: VkVideoDecodeInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoDecodeAV1InlineSessionParametersInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_INLINE_SESSION_PARAMETERS_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    pStdSequenceHeader: ?*const StdVideoAV1SequenceHeader = null,
};
// Extension: VK_KHR_video_decode_av1
// Extends: VkVideoDecodeInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoDecodeAV1PictureInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_PICTURE_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    pStdPictureInfo: ?*const StdVideoDecodeAV1PictureInfo = null,
    // Extern sync: false
    // Optional: false
    referenceNameSlotIndices: [VK_MAX_VIDEO_AV1_REFERENCES_PER_FRAME_KHR]i32 = @import("std").mem.zeroes([VK_MAX_VIDEO_AV1_REFERENCES_PER_FRAME_KHR]i32),
    // Extern sync: false
    // Optional: false
    frameHeaderOffset: u32 = 0,
    // Extern sync: false
    // Optional: false
    tileCount: u32 = 0,
    // Length expression: tileCount
    // Extern sync: false
    // Optional: false
    pTileOffsets: ?[*]const u32 = null,
    // Length expression: tileCount
    // Extern sync: false
    // Optional: false
    pTileSizes: ?[*]const u32 = null,
};
// Extension: VK_KHR_video_decode_av1
// Extends: VkVideoReferenceSlotInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoDecodeAV1DpbSlotInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_DPB_SLOT_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    pStdReferenceInfo: ?*const StdVideoDecodeAV1ReferenceInfo = null,
};
// Extension: VK_KHR_video_queue
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoSessionCreateInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_SESSION_CREATE_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    queueFamilyIndex: u32 = 0,
    // Extern sync: false
    // Optional: true
    flags: VkVideoSessionCreateFlagsKHR = .{},
    // Extern sync: false
    // Optional: false
    pVideoProfile: ?*const VkVideoProfileInfoKHR = null,
    // Extern sync: false
    // Optional: false
    pictureFormat: VkFormat = .VK_FORMAT_UNDEFINED,
    // Extern sync: false
    // Optional: false
    maxCodedExtent: VkExtent2D = .{},
    // Extern sync: false
    // Optional: false
    referencePictureFormat: VkFormat = .VK_FORMAT_UNDEFINED,
    // Extern sync: false
    // Optional: false
    maxDpbSlots: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxActiveReferencePictures: u32 = 0,
    // Extern sync: false
    // Optional: false
    pStdHeaderVersion: ?*const VkExtensionProperties = null,
};
// Extension: VK_KHR_video_queue
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoSessionParametersCreateInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_CREATE_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkVideoSessionParametersCreateFlagsKHR = .{},
    // Extern sync: false
    // Optional: true
    videoSessionParametersTemplate: VkVideoSessionParametersKHR = .none,
    // Extern sync: false
    // Optional: false
    videoSession: VkVideoSessionKHR = .none,
};
// Extension: VK_KHR_video_queue
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoSessionParametersUpdateInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_UPDATE_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    updateSequenceCount: u32 = 0,
};
// Extension: VK_KHR_video_encode_queue
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeSessionParametersGetInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_GET_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    videoSessionParameters: VkVideoSessionParametersKHR = .none,
};
// Extension: VK_KHR_video_encode_queue
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeSessionParametersFeedbackInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_FEEDBACK_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    hasOverrides: u32 = 0,
};
// Extension: VK_KHR_video_queue
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoBeginCodingInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_BEGIN_CODING_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkVideoBeginCodingFlagsKHR = .{},
    // Extern sync: false
    // Optional: false
    videoSession: VkVideoSessionKHR = .none,
    // Extern sync: false
    // Optional: true
    videoSessionParameters: VkVideoSessionParametersKHR = .none,
    // Extern sync: false
    // Optional: true
    referenceSlotCount: u32 = 0,
    // Length expression: referenceSlotCount
    // Extern sync: false
    // Optional: false
    pReferenceSlots: ?[*]const VkVideoReferenceSlotInfoKHR = null,
};
// Extension: VK_KHR_video_queue
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoEndCodingInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_END_CODING_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkVideoEndCodingFlagsKHR = .{},
};
// Extension: VK_KHR_video_queue
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoCodingControlInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_CODING_CONTROL_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    flags: VkVideoCodingControlFlagsKHR = .{},
};
// Extension: VK_KHR_video_encode_queue
// Extends: VkVideoProfileInfoKHR,VkQueryPoolCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeUsageInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_USAGE_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    videoUsageHints: VkVideoEncodeUsageFlagsKHR = .{},
    // Extern sync: false
    // Optional: true
    videoContentHints: VkVideoEncodeContentFlagsKHR = .{},
    // Extern sync: false
    // Optional: true
    tuningMode: VkVideoEncodeTuningModeKHR = .VK_VIDEO_ENCODE_TUNING_MODE_DEFAULT_KHR,
};
// Extension: VK_KHR_video_encode_queue
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkVideoEncodeFlagsKHR = .{},
    // Extern sync: false
    // Optional: false
    dstBuffer: VkBuffer = .none,
    // Extern sync: false
    // Optional: false
    dstBufferOffset: u64 = 0,
    // Extern sync: false
    // Optional: false
    dstBufferRange: u64 = 0,
    // Extern sync: false
    // Optional: false
    srcPictureResource: VkVideoPictureResourceInfoKHR = .{},
    // Extern sync: false
    // Optional: true
    pSetupReferenceSlot: ?*const VkVideoReferenceSlotInfoKHR = null,
    // Extern sync: false
    // Optional: true
    referenceSlotCount: u32 = 0,
    // Length expression: referenceSlotCount
    // Extern sync: false
    // Optional: false
    pReferenceSlots: ?[*]const VkVideoReferenceSlotInfoKHR = null,
    // Extern sync: false
    // Optional: false
    precedingExternallyEncodedBytes: u32 = 0,
};
// Extension: VK_KHR_video_encode_quantization_map
// Extends: VkVideoEncodeInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeQuantizationMapInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    quantizationMap: VkImageView = .none,
    // Extern sync: false
    // Optional: false
    quantizationMapExtent: VkExtent2D = .{},
};
// Extension: VK_KHR_video_encode_quantization_map
// Extends: VkVideoSessionParametersCreateInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_SESSION_PARAMETERS_CREATE_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    quantizationMapTexelSize: VkExtent2D = .{},
};
// Extension: VK_KHR_video_encode_quantization_map
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUANTIZATION_MAP_FEATURES_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    videoEncodeQuantizationMap: u32 = 0,
};
// Extension: VK_KHR_video_encode_queue
// Extends: VkQueryPoolCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkQueryPoolVideoEncodeFeedbackCreateInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_QUERY_POOL_VIDEO_ENCODE_FEEDBACK_CREATE_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    encodeFeedbackFlags: VkVideoEncodeFeedbackFlagsKHR = .{},
};
// Extension: VK_KHR_video_encode_queue
// Extends: VkVideoCodingControlInfoKHR,VkVideoSessionParametersCreateInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeQualityLevelInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    qualityLevel: u32 = 0,
};
// Extension: VK_KHR_video_encode_queue
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    pVideoProfile: ?*const VkVideoProfileInfoKHR = null,
    // Extern sync: false
    // Optional: false
    qualityLevel: u32 = 0,
};
// Extension: VK_KHR_video_encode_queue
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeQualityLevelPropertiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_PROPERTIES_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    preferredRateControlMode: VkVideoEncodeRateControlModeFlagsKHR = .{},
    // Extern sync: false
    // Optional: false
    preferredRateControlLayerCount: u32 = 0,
};
// Extension: VK_KHR_video_encode_queue
// Extends: VkVideoCodingControlInfoKHR,VkVideoBeginCodingInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeRateControlInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkVideoEncodeRateControlFlagsKHR = .{},
    // Extern sync: false
    // Optional: true
    rateControlMode: VkVideoEncodeRateControlModeFlagsKHR = .{},
    // Extern sync: false
    // Optional: true
    layerCount: u32 = 0,
    // Length expression: layerCount
    // Extern sync: false
    // Optional: false
    pLayers: ?[*]const VkVideoEncodeRateControlLayerInfoKHR = null,
    // Extern sync: false
    // Optional: false
    virtualBufferSizeInMs: u32 = 0,
    // Extern sync: false
    // Optional: false
    initialVirtualBufferSizeInMs: u32 = 0,
};
// Extension: VK_KHR_video_encode_queue
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeRateControlLayerInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_LAYER_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    averageBitrate: u64 = 0,
    // Extern sync: false
    // Optional: false
    maxBitrate: u64 = 0,
    // Extern sync: false
    // Optional: false
    frameRateNumerator: u32 = 0,
    // Extern sync: false
    // Optional: false
    frameRateDenominator: u32 = 0,
};
// Extension: VK_KHR_video_encode_queue
// Extends: VkVideoCapabilitiesKHR
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeCapabilitiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_CAPABILITIES_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    flags: VkVideoEncodeCapabilityFlagsKHR = .{},
    // Extern sync: false
    // Optional: false
    rateControlModes: VkVideoEncodeRateControlModeFlagsKHR = .{},
    // Extern sync: false
    // Optional: false
    maxRateControlLayers: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxBitrate: u64 = 0,
    // Extern sync: false
    // Optional: false
    maxQualityLevels: u32 = 0,
    // Extern sync: false
    // Optional: false
    encodeInputPictureGranularity: VkExtent2D = .{},
    // Extern sync: false
    // Optional: false
    supportedEncodeFeedbackFlags: VkVideoEncodeFeedbackFlagsKHR = .{},
};
// Extension: VK_KHR_video_encode_h264
// Extends: VkVideoCapabilitiesKHR
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeH264CapabilitiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_CAPABILITIES_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    flags: VkVideoEncodeH264CapabilityFlagsKHR = .{},
    // Extern sync: false
    // Optional: false
    // Extern sync: false
    // Optional: false
    maxSliceCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxPPictureL0ReferenceCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxBPictureL0ReferenceCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxL1ReferenceCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxTemporalLayerCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    expectDyadicTemporalLayerPattern: u32 = 0,
    // Extern sync: false
    // Optional: false
    minQp: i32 = 0,
    // Extern sync: false
    // Optional: false
    maxQp: i32 = 0,
    // Extern sync: false
    // Optional: false
    prefersGopRemainingFrames: u32 = 0,
    // Extern sync: false
    // Optional: false
    requiresGopRemainingFrames: u32 = 0,
    // Extern sync: false
    // Optional: false
    stdSyntaxFlags: VkVideoEncodeH264StdFlagsKHR = .{},
};
// Extension: VK_KHR_video_encode_h264
// Extends: VkVideoEncodeQualityLevelPropertiesKHR
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeH264QualityLevelPropertiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_QUALITY_LEVEL_PROPERTIES_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    preferredRateControlFlags: VkVideoEncodeH264RateControlFlagsKHR = .{},
    // Extern sync: false
    // Optional: false
    preferredGopFrameCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    preferredIdrPeriod: u32 = 0,
    // Extern sync: false
    // Optional: false
    preferredConsecutiveBFrameCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    preferredTemporalLayerCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    preferredConstantQp: VkVideoEncodeH264QpKHR = .{},
    // Extern sync: false
    // Optional: false
    preferredMaxL0ReferenceCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    preferredMaxL1ReferenceCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    preferredStdEntropyCodingModeFlag: u32 = 0,
};
// Extension: VK_KHR_video_encode_h264
// Extends: VkVideoSessionCreateInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeH264SessionCreateInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_CREATE_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    useMaxLevelIdc: u32 = 0,
    // Extern sync: false
    // Optional: false
};
// Extension: VK_KHR_video_encode_h264
// Extends: VkVideoSessionParametersUpdateInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeH264SessionParametersAddInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    stdSPSCount: u32 = 0,
    // Length expression: stdSPSCount
    // Extern sync: false
    // Optional: true
    pStdSPSs: ?[*]const StdVideoH264SequenceParameterSet = null,
    // Extern sync: false
    // Optional: true
    stdPPSCount: u32 = 0,
    // Length expression: stdPPSCount
    // Extern sync: false
    // Optional: true
    // Comment: List of Picture Parameters associated with the spsStd, above
    pStdPPSs: ?[*]const StdVideoH264PictureParameterSet = null,
};
// Extension: VK_KHR_video_encode_h264
// Extends: VkVideoSessionParametersCreateInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeH264SessionParametersCreateInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    maxStdSPSCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxStdPPSCount: u32 = 0,
    // Extern sync: false
    // Optional: true
    pParametersAddInfo: ?*const VkVideoEncodeH264SessionParametersAddInfoKHR = null,
};
// Extension: VK_KHR_video_encode_h264
// Extends: VkVideoEncodeSessionParametersGetInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeH264SessionParametersGetInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_GET_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    writeStdSPS: u32 = 0,
    // Extern sync: false
    // Optional: false
    writeStdPPS: u32 = 0,
    // Extern sync: false
    // Optional: false
    stdSPSId: u32 = 0,
    // Extern sync: false
    // Optional: false
    stdPPSId: u32 = 0,
};
// Extension: VK_KHR_video_encode_h264
// Extends: VkVideoEncodeSessionParametersFeedbackInfoKHR
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeH264SessionParametersFeedbackInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_FEEDBACK_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    hasStdSPSOverrides: u32 = 0,
    // Extern sync: false
    // Optional: false
    hasStdPPSOverrides: u32 = 0,
};
// Extension: VK_KHR_video_encode_h264
// Extends: VkVideoReferenceSlotInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeH264DpbSlotInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_DPB_SLOT_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    pStdReferenceInfo: ?*const StdVideoEncodeH264ReferenceInfo = null,
};
// Extension: VK_KHR_video_encode_h264
// Extends: VkVideoEncodeInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeH264PictureInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PICTURE_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    naluSliceEntryCount: u32 = 0,
    // Length expression: naluSliceEntryCount
    // Extern sync: false
    // Optional: false
    pNaluSliceEntries: ?[*]const VkVideoEncodeH264NaluSliceInfoKHR = null,
    // Extern sync: false
    // Optional: false
    pStdPictureInfo: ?*const StdVideoEncodeH264PictureInfo = null,
    // Extern sync: false
    // Optional: false
    generatePrefixNalu: u32 = 0,
};
// Extension: VK_KHR_video_encode_h264
// Extends: VkVideoProfileInfoKHR,VkQueryPoolCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeH264ProfileInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PROFILE_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
};
// Extension: VK_KHR_video_encode_h264
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeH264NaluSliceInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_NALU_SLICE_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    constantQp: i32 = 0,
    // Extern sync: false
    // Optional: false
    pStdSliceHeader: ?*const StdVideoEncodeH264SliceHeader = null,
};
// Extension: VK_KHR_video_encode_h264
// Extends: VkVideoCodingControlInfoKHR,VkVideoBeginCodingInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeH264RateControlInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkVideoEncodeH264RateControlFlagsKHR = .{},
    // Extern sync: false
    // Optional: false
    gopFrameCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    idrPeriod: u32 = 0,
    // Extern sync: false
    // Optional: false
    consecutiveBFrameCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    temporalLayerCount: u32 = 0,
};
// Extension: VK_KHR_video_encode_h264
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeH264QpKHR = extern struct {
    // Extern sync: false
    // Optional: false
    qpI: i32 = 0,
    // Extern sync: false
    // Optional: false
    qpP: i32 = 0,
    // Extern sync: false
    // Optional: false
    qpB: i32 = 0,
};
// Extension: VK_KHR_video_encode_h264
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeH264FrameSizeKHR = extern struct {
    // Extern sync: false
    // Optional: false
    frameISize: u32 = 0,
    // Extern sync: false
    // Optional: false
    framePSize: u32 = 0,
    // Extern sync: false
    // Optional: false
    frameBSize: u32 = 0,
};
// Extension: VK_KHR_video_encode_h264
// Extends: VkVideoBeginCodingInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeH264GopRemainingFrameInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_GOP_REMAINING_FRAME_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    useGopRemainingFrames: u32 = 0,
    // Extern sync: false
    // Optional: false
    gopRemainingI: u32 = 0,
    // Extern sync: false
    // Optional: false
    gopRemainingP: u32 = 0,
    // Extern sync: false
    // Optional: false
    gopRemainingB: u32 = 0,
};
// Extension: VK_KHR_video_encode_h264
// Extends: VkVideoEncodeRateControlLayerInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeH264RateControlLayerInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_LAYER_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    useMinQp: u32 = 0,
    // Extern sync: false
    // Optional: false
    minQp: VkVideoEncodeH264QpKHR = .{},
    // Extern sync: false
    // Optional: false
    useMaxQp: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxQp: VkVideoEncodeH264QpKHR = .{},
    // Extern sync: false
    // Optional: false
    useMaxFrameSize: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxFrameSize: VkVideoEncodeH264FrameSizeKHR = .{},
};
// Extension: VK_KHR_video_encode_h265
// Extends: VkVideoCapabilitiesKHR
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeH265CapabilitiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_CAPABILITIES_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    flags: VkVideoEncodeH265CapabilityFlagsKHR = .{},
    // Extern sync: false
    // Optional: false
    // Extern sync: false
    // Optional: false
    maxSliceSegmentCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxTiles: VkExtent2D = .{},
    // Extern sync: false
    // Optional: false
    ctbSizes: VkVideoEncodeH265CtbSizeFlagsKHR = .{},
    // Extern sync: false
    // Optional: false
    transformBlockSizes: VkVideoEncodeH265TransformBlockSizeFlagsKHR = .{},
    // Extern sync: false
    // Optional: false
    maxPPictureL0ReferenceCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxBPictureL0ReferenceCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxL1ReferenceCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxSubLayerCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    expectDyadicTemporalSubLayerPattern: u32 = 0,
    // Extern sync: false
    // Optional: false
    minQp: i32 = 0,
    // Extern sync: false
    // Optional: false
    maxQp: i32 = 0,
    // Extern sync: false
    // Optional: false
    prefersGopRemainingFrames: u32 = 0,
    // Extern sync: false
    // Optional: false
    requiresGopRemainingFrames: u32 = 0,
    // Extern sync: false
    // Optional: false
    stdSyntaxFlags: VkVideoEncodeH265StdFlagsKHR = .{},
};
// Extension: VK_KHR_video_encode_h265
// Extends: VkVideoEncodeQualityLevelPropertiesKHR
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeH265QualityLevelPropertiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_QUALITY_LEVEL_PROPERTIES_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    preferredRateControlFlags: VkVideoEncodeH265RateControlFlagsKHR = .{},
    // Extern sync: false
    // Optional: false
    preferredGopFrameCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    preferredIdrPeriod: u32 = 0,
    // Extern sync: false
    // Optional: false
    preferredConsecutiveBFrameCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    preferredSubLayerCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    preferredConstantQp: VkVideoEncodeH265QpKHR = .{},
    // Extern sync: false
    // Optional: false
    preferredMaxL0ReferenceCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    preferredMaxL1ReferenceCount: u32 = 0,
};
// Extension: VK_KHR_video_encode_h265
// Extends: VkVideoSessionCreateInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeH265SessionCreateInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_CREATE_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    useMaxLevelIdc: u32 = 0,
    // Extern sync: false
    // Optional: false
};
// Extension: VK_KHR_video_encode_h265
// Extends: VkVideoSessionParametersUpdateInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeH265SessionParametersAddInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    stdVPSCount: u32 = 0,
    // Length expression: stdVPSCount
    // Extern sync: false
    // Optional: true
    pStdVPSs: ?[*]const StdVideoH265VideoParameterSet = null,
    // Extern sync: false
    // Optional: true
    stdSPSCount: u32 = 0,
    // Length expression: stdSPSCount
    // Extern sync: false
    // Optional: true
    pStdSPSs: ?[*]const StdVideoH265SequenceParameterSet = null,
    // Extern sync: false
    // Optional: true
    stdPPSCount: u32 = 0,
    // Length expression: stdPPSCount
    // Extern sync: false
    // Optional: true
    // Comment: List of Picture Parameters associated with the spsStd, above
    pStdPPSs: ?[*]const StdVideoH265PictureParameterSet = null,
};
// Extension: VK_KHR_video_encode_h265
// Extends: VkVideoSessionParametersCreateInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeH265SessionParametersCreateInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    maxStdVPSCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxStdSPSCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxStdPPSCount: u32 = 0,
    // Extern sync: false
    // Optional: true
    pParametersAddInfo: ?*const VkVideoEncodeH265SessionParametersAddInfoKHR = null,
};
// Extension: VK_KHR_video_encode_h265
// Extends: VkVideoEncodeSessionParametersGetInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeH265SessionParametersGetInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_GET_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    writeStdVPS: u32 = 0,
    // Extern sync: false
    // Optional: false
    writeStdSPS: u32 = 0,
    // Extern sync: false
    // Optional: false
    writeStdPPS: u32 = 0,
    // Extern sync: false
    // Optional: false
    stdVPSId: u32 = 0,
    // Extern sync: false
    // Optional: false
    stdSPSId: u32 = 0,
    // Extern sync: false
    // Optional: false
    stdPPSId: u32 = 0,
};
// Extension: VK_KHR_video_encode_h265
// Extends: VkVideoEncodeSessionParametersFeedbackInfoKHR
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeH265SessionParametersFeedbackInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_FEEDBACK_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    hasStdVPSOverrides: u32 = 0,
    // Extern sync: false
    // Optional: false
    hasStdSPSOverrides: u32 = 0,
    // Extern sync: false
    // Optional: false
    hasStdPPSOverrides: u32 = 0,
};
// Extension: VK_KHR_video_encode_h265
// Extends: VkVideoEncodeInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeH265PictureInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PICTURE_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    naluSliceSegmentEntryCount: u32 = 0,
    // Length expression: naluSliceSegmentEntryCount
    // Extern sync: false
    // Optional: false
    pNaluSliceSegmentEntries: ?[*]const VkVideoEncodeH265NaluSliceSegmentInfoKHR = null,
    // Extern sync: false
    // Optional: false
    pStdPictureInfo: ?*const StdVideoEncodeH265PictureInfo = null,
};
// Extension: VK_KHR_video_encode_h265
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeH265NaluSliceSegmentInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_NALU_SLICE_SEGMENT_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    constantQp: i32 = 0,
    // Extern sync: false
    // Optional: false
    pStdSliceSegmentHeader: ?*const StdVideoEncodeH265SliceSegmentHeader = null,
};
// Extension: VK_KHR_video_encode_h265
// Extends: VkVideoCodingControlInfoKHR,VkVideoBeginCodingInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeH265RateControlInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkVideoEncodeH265RateControlFlagsKHR = .{},
    // Extern sync: false
    // Optional: false
    gopFrameCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    idrPeriod: u32 = 0,
    // Extern sync: false
    // Optional: false
    consecutiveBFrameCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    subLayerCount: u32 = 0,
};
// Extension: VK_KHR_video_encode_h265
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeH265QpKHR = extern struct {
    // Extern sync: false
    // Optional: false
    qpI: i32 = 0,
    // Extern sync: false
    // Optional: false
    qpP: i32 = 0,
    // Extern sync: false
    // Optional: false
    qpB: i32 = 0,
};
// Extension: VK_KHR_video_encode_h265
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeH265FrameSizeKHR = extern struct {
    // Extern sync: false
    // Optional: false
    frameISize: u32 = 0,
    // Extern sync: false
    // Optional: false
    framePSize: u32 = 0,
    // Extern sync: false
    // Optional: false
    frameBSize: u32 = 0,
};
// Extension: VK_KHR_video_encode_h265
// Extends: VkVideoBeginCodingInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeH265GopRemainingFrameInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_GOP_REMAINING_FRAME_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    useGopRemainingFrames: u32 = 0,
    // Extern sync: false
    // Optional: false
    gopRemainingI: u32 = 0,
    // Extern sync: false
    // Optional: false
    gopRemainingP: u32 = 0,
    // Extern sync: false
    // Optional: false
    gopRemainingB: u32 = 0,
};
// Extension: VK_KHR_video_encode_h265
// Extends: VkVideoEncodeRateControlLayerInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeH265RateControlLayerInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_LAYER_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    useMinQp: u32 = 0,
    // Extern sync: false
    // Optional: false
    minQp: VkVideoEncodeH265QpKHR = .{},
    // Extern sync: false
    // Optional: false
    useMaxQp: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxQp: VkVideoEncodeH265QpKHR = .{},
    // Extern sync: false
    // Optional: false
    useMaxFrameSize: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxFrameSize: VkVideoEncodeH265FrameSizeKHR = .{},
};
// Extension: VK_KHR_video_encode_h265
// Extends: VkVideoProfileInfoKHR,VkQueryPoolCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeH265ProfileInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PROFILE_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
};
// Extension: VK_KHR_video_encode_h265
// Extends: VkVideoReferenceSlotInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeH265DpbSlotInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_DPB_SLOT_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    pStdReferenceInfo: ?*const StdVideoEncodeH265ReferenceInfo = null,
};
// Extension: VK_KHR_video_encode_av1
// Extends: VkVideoCapabilitiesKHR
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeAV1CapabilitiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_CAPABILITIES_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    flags: VkVideoEncodeAV1CapabilityFlagsKHR = .{},
    // Extern sync: false
    // Optional: false
    // Extern sync: false
    // Optional: false
    codedPictureAlignment: VkExtent2D = .{},
    // Extern sync: false
    // Optional: false
    maxTiles: VkExtent2D = .{},
    // Extern sync: false
    // Optional: false
    minTileSize: VkExtent2D = .{},
    // Extern sync: false
    // Optional: false
    maxTileSize: VkExtent2D = .{},
    // Extern sync: false
    // Optional: false
    superblockSizes: VkVideoEncodeAV1SuperblockSizeFlagsKHR = .{},
    // Extern sync: false
    // Optional: false
    maxSingleReferenceCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    singleReferenceNameMask: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxUnidirectionalCompoundReferenceCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxUnidirectionalCompoundGroup1ReferenceCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    unidirectionalCompoundReferenceNameMask: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxBidirectionalCompoundReferenceCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxBidirectionalCompoundGroup1ReferenceCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxBidirectionalCompoundGroup2ReferenceCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    bidirectionalCompoundReferenceNameMask: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxTemporalLayerCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxSpatialLayerCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxOperatingPoints: u32 = 0,
    // Extern sync: false
    // Optional: false
    minQIndex: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxQIndex: u32 = 0,
    // Extern sync: false
    // Optional: false
    prefersGopRemainingFrames: u32 = 0,
    // Extern sync: false
    // Optional: false
    requiresGopRemainingFrames: u32 = 0,
    // Extern sync: false
    // Optional: false
    stdSyntaxFlags: VkVideoEncodeAV1StdFlagsKHR = .{},
};
// Extension: VK_KHR_video_encode_av1
// Extends: VkVideoEncodeQualityLevelPropertiesKHR
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeAV1QualityLevelPropertiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_QUALITY_LEVEL_PROPERTIES_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    preferredRateControlFlags: VkVideoEncodeAV1RateControlFlagsKHR = .{},
    // Extern sync: false
    // Optional: false
    preferredGopFrameCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    preferredKeyFramePeriod: u32 = 0,
    // Extern sync: false
    // Optional: false
    preferredConsecutiveBipredictiveFrameCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    preferredTemporalLayerCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    preferredConstantQIndex: VkVideoEncodeAV1QIndexKHR = .{},
    // Extern sync: false
    // Optional: false
    preferredMaxSingleReferenceCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    preferredSingleReferenceNameMask: u32 = 0,
    // Extern sync: false
    // Optional: false
    preferredMaxUnidirectionalCompoundReferenceCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    preferredMaxUnidirectionalCompoundGroup1ReferenceCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    preferredUnidirectionalCompoundReferenceNameMask: u32 = 0,
    // Extern sync: false
    // Optional: false
    preferredMaxBidirectionalCompoundReferenceCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    preferredMaxBidirectionalCompoundGroup1ReferenceCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    preferredMaxBidirectionalCompoundGroup2ReferenceCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    preferredBidirectionalCompoundReferenceNameMask: u32 = 0,
};
// Extension: VK_KHR_video_encode_av1
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceVideoEncodeAV1FeaturesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_AV1_FEATURES_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    videoEncodeAV1: u32 = 0,
};
// Extension: VK_KHR_video_encode_av1
// Extends: VkVideoSessionCreateInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeAV1SessionCreateInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_SESSION_CREATE_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    useMaxLevel: u32 = 0,
    // Extern sync: false
    // Optional: false
};
// Extension: VK_KHR_video_encode_av1
// Extends: VkVideoSessionParametersCreateInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeAV1SessionParametersCreateInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_SESSION_PARAMETERS_CREATE_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    pStdSequenceHeader: ?*const StdVideoAV1SequenceHeader = null,
    // Extern sync: false
    // Optional: true
    pStdDecoderModelInfo: ?*const StdVideoEncodeAV1DecoderModelInfo = null,
    // Extern sync: false
    // Optional: true
    stdOperatingPointCount: u32 = 0,
    // Length expression: stdOperatingPointCount
    // Extern sync: false
    // Optional: true
    pStdOperatingPoints: ?[*]const StdVideoEncodeAV1OperatingPointInfo = null,
};
// Extension: VK_KHR_video_encode_av1
// Extends: VkVideoReferenceSlotInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeAV1DpbSlotInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_DPB_SLOT_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    pStdReferenceInfo: ?*const StdVideoEncodeAV1ReferenceInfo = null,
};
// Extension: VK_KHR_video_encode_av1
// Extends: VkVideoEncodeInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeAV1PictureInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_PICTURE_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    predictionMode: VkVideoEncodeAV1PredictionModeKHR = .VK_VIDEO_ENCODE_AV1_PREDICTION_MODE_INTRA_ONLY_KHR,
    // Extern sync: false
    // Optional: false
    rateControlGroup: VkVideoEncodeAV1RateControlGroupKHR = .VK_VIDEO_ENCODE_AV1_RATE_CONTROL_GROUP_INTRA_KHR,
    // Extern sync: false
    // Optional: false
    constantQIndex: u32 = 0,
    // Extern sync: false
    // Optional: false
    pStdPictureInfo: ?*const StdVideoEncodeAV1PictureInfo = null,
    // Extern sync: false
    // Optional: false
    referenceNameSlotIndices: [VK_MAX_VIDEO_AV1_REFERENCES_PER_FRAME_KHR]i32 = @import("std").mem.zeroes([VK_MAX_VIDEO_AV1_REFERENCES_PER_FRAME_KHR]i32),
    // Extern sync: false
    // Optional: false
    primaryReferenceCdfOnly: u32 = 0,
    // Extern sync: false
    // Optional: false
    generateObuExtensionHeader: u32 = 0,
};
// Extension: VK_KHR_video_encode_av1
// Extends: VkVideoProfileInfoKHR,VkQueryPoolCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeAV1ProfileInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_PROFILE_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
};
// Extension: VK_KHR_video_encode_av1
// Extends: VkVideoCodingControlInfoKHR,VkVideoBeginCodingInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeAV1RateControlInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_RATE_CONTROL_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkVideoEncodeAV1RateControlFlagsKHR = .{},
    // Extern sync: false
    // Optional: false
    gopFrameCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    keyFramePeriod: u32 = 0,
    // Extern sync: false
    // Optional: false
    consecutiveBipredictiveFrameCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    temporalLayerCount: u32 = 0,
};
// Extension: VK_KHR_video_encode_av1
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeAV1QIndexKHR = extern struct {
    // Extern sync: false
    // Optional: false
    intraQIndex: u32 = 0,
    // Extern sync: false
    // Optional: false
    predictiveQIndex: u32 = 0,
    // Extern sync: false
    // Optional: false
    bipredictiveQIndex: u32 = 0,
};
// Extension: VK_KHR_video_encode_av1
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeAV1FrameSizeKHR = extern struct {
    // Extern sync: false
    // Optional: false
    intraFrameSize: u32 = 0,
    // Extern sync: false
    // Optional: false
    predictiveFrameSize: u32 = 0,
    // Extern sync: false
    // Optional: false
    bipredictiveFrameSize: u32 = 0,
};
// Extension: VK_KHR_video_encode_av1
// Extends: VkVideoBeginCodingInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeAV1GopRemainingFrameInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_GOP_REMAINING_FRAME_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    useGopRemainingFrames: u32 = 0,
    // Extern sync: false
    // Optional: false
    gopRemainingIntra: u32 = 0,
    // Extern sync: false
    // Optional: false
    gopRemainingPredictive: u32 = 0,
    // Extern sync: false
    // Optional: false
    gopRemainingBipredictive: u32 = 0,
};
// Extension: VK_KHR_video_encode_av1
// Extends: VkVideoEncodeRateControlLayerInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeAV1RateControlLayerInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_RATE_CONTROL_LAYER_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    useMinQIndex: u32 = 0,
    // Extern sync: false
    // Optional: false
    minQIndex: VkVideoEncodeAV1QIndexKHR = .{},
    // Extern sync: false
    // Optional: false
    useMaxQIndex: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxQIndex: VkVideoEncodeAV1QIndexKHR = .{},
    // Extern sync: false
    // Optional: false
    useMaxFrameSize: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxFrameSize: VkVideoEncodeAV1FrameSizeKHR = .{},
};
// Extension: VK_NV_inherited_viewport_scissor
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceInheritedViewportScissorFeaturesNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    inheritedViewportScissor2D: u32 = 0,
};
// Extension: VK_NV_inherited_viewport_scissor
// Extends: VkCommandBufferInheritanceInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkCommandBufferInheritanceViewportScissorInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_VIEWPORT_SCISSOR_INFO_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    viewportScissor2D: u32 = 0,
    // Extern sync: false
    // Optional: false
    viewportDepthCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    pViewportDepths: ?*const VkViewport = null,
};
// Extension: VK_EXT_ycbcr_2plane_444_formats
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    ycbcr2plane444Formats: u32 = 0,
};
// Extension: VK_EXT_provoking_vertex
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceProvokingVertexFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    provokingVertexLast: u32 = 0,
    // Extern sync: false
    // Optional: false
    transformFeedbackPreservesProvokingVertex: u32 = 0,
};
// Extension: VK_EXT_provoking_vertex
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceProvokingVertexPropertiesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    provokingVertexModePerPipeline: u32 = 0,
    // Extern sync: false
    // Optional: false
    transformFeedbackPreservesTriangleFanProvokingVertex: u32 = 0,
};
// Extension: VK_EXT_provoking_vertex
// Extends: VkPipelineRasterizationStateCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineRasterizationProvokingVertexStateCreateInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    provokingVertexMode: VkProvokingVertexModeEXT = .VK_PROVOKING_VERTEX_MODE_FIRST_VERTEX_EXT,
};
// Extension: VK_KHR_video_encode_intra_refresh
// Extends: VkVideoCapabilitiesKHR
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeIntraRefreshCapabilitiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_INTRA_REFRESH_CAPABILITIES_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: true
    intraRefreshModes: VkVideoEncodeIntraRefreshModeFlagsKHR = .{},
    // Extern sync: false
    // Optional: false
    maxIntraRefreshCycleDuration: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxIntraRefreshActiveReferencePictures: u32 = 0,
    // Extern sync: false
    // Optional: false
    partitionIndependentIntraRefreshRegions: u32 = 0,
    // Extern sync: false
    // Optional: false
    nonRectangularIntraRefreshRegions: u32 = 0,
};
// Extension: VK_KHR_video_encode_intra_refresh
// Extends: VkVideoSessionCreateInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeSessionIntraRefreshCreateInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_INTRA_REFRESH_CREATE_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    intraRefreshMode: VkVideoEncodeIntraRefreshModeFlagsKHR = .{},
};
// Extension: VK_KHR_video_encode_intra_refresh
// Extends: VkVideoEncodeInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeIntraRefreshInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_INTRA_REFRESH_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    intraRefreshCycleDuration: u32 = 0,
    // Extern sync: false
    // Optional: false
    intraRefreshIndex: u32 = 0,
};
// Extension: VK_KHR_video_encode_intra_refresh
// Extends: VkVideoReferenceSlotInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoReferenceIntraRefreshInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_REFERENCE_INTRA_REFRESH_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    dirtyIntraRefreshRegions: u32 = 0,
};
// Extension: VK_KHR_video_encode_intra_refresh
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_INTRA_REFRESH_FEATURES_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    videoEncodeIntraRefresh: u32 = 0,
};
// Extension: VK_NVX_binary_import
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkCuModuleCreateInfoNVX = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_CU_MODULE_CREATE_INFO_NVX;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    dataSize: u64 = 0,
    // Length expression: dataSize
    // Extern sync: false
    // Optional: false
    pData: ?*const anyopaque = null,
};
// Extension: VK_NVX_binary_import
// Extends: VkCuModuleCreateInfoNVX
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkCuModuleTexturingModeCreateInfoNVX = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_CU_MODULE_TEXTURING_MODE_CREATE_INFO_NVX;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    use64bitTexturing: u32 = 0,
};
// Extension: VK_NVX_binary_import
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkCuFunctionCreateInfoNVX = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_CU_FUNCTION_CREATE_INFO_NVX;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    module: VkCuModuleNVX = .none,
    // Length expression: null-terminated
    // Extern sync: false
    // Optional: false
    pName: ?[*:0]const u8 = null,
};
// Extension: VK_NVX_binary_import
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkCuLaunchInfoNVX = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_CU_LAUNCH_INFO_NVX;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    function: VkCuFunctionNVX = .none,
    // Extern sync: false
    // Optional: false
    gridDimX: u32 = 0,
    // Extern sync: false
    // Optional: false
    gridDimY: u32 = 0,
    // Extern sync: false
    // Optional: false
    gridDimZ: u32 = 0,
    // Extern sync: false
    // Optional: false
    blockDimX: u32 = 0,
    // Extern sync: false
    // Optional: false
    blockDimY: u32 = 0,
    // Extern sync: false
    // Optional: false
    blockDimZ: u32 = 0,
    // Extern sync: false
    // Optional: false
    sharedMemBytes: u32 = 0,
    // Extern sync: false
    // Optional: true
    paramCount: u64 = 0,
    // Length expression: paramCount
    // Extern sync: false
    // Optional: false
    pParams: ?[*]const *const anyopaque = null,
    // Extern sync: false
    // Optional: true
    extraCount: u64 = 0,
    // Length expression: extraCount
    // Extern sync: false
    // Optional: false
    pExtras: ?[*]const *const anyopaque = null,
};
// Extension: VK_EXT_descriptor_buffer
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceDescriptorBufferFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_FEATURES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    descriptorBuffer: u32 = 0,
    // Extern sync: false
    // Optional: false
    descriptorBufferCaptureReplay: u32 = 0,
    // Extern sync: false
    // Optional: false
    descriptorBufferImageLayoutIgnored: u32 = 0,
    // Extern sync: false
    // Optional: false
    descriptorBufferPushDescriptors: u32 = 0,
};
// Extension: VK_EXT_descriptor_buffer
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceDescriptorBufferPropertiesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_PROPERTIES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    combinedImageSamplerDescriptorSingleArray: u32 = 0,
    // Extern sync: false
    // Optional: false
    bufferlessPushDescriptors: u32 = 0,
    // Extern sync: false
    // Optional: false
    allowSamplerImageViewPostSubmitCreation: u32 = 0,
    // Extern sync: false
    // Optional: false
    descriptorBufferOffsetAlignment: u64 = 0,
    // Extern sync: false
    // Optional: false
    maxDescriptorBufferBindings: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxResourceDescriptorBufferBindings: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxSamplerDescriptorBufferBindings: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxEmbeddedImmutableSamplerBindings: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxEmbeddedImmutableSamplers: u32 = 0,
    // Extern sync: false
    // Optional: false
    bufferCaptureReplayDescriptorDataSize: u64 = 0,
    // Extern sync: false
    // Optional: false
    imageCaptureReplayDescriptorDataSize: u64 = 0,
    // Extern sync: false
    // Optional: false
    imageViewCaptureReplayDescriptorDataSize: u64 = 0,
    // Extern sync: false
    // Optional: false
    samplerCaptureReplayDescriptorDataSize: u64 = 0,
    // Extern sync: false
    // Optional: false
    accelerationStructureCaptureReplayDescriptorDataSize: u64 = 0,
    // Extern sync: false
    // Optional: false
    samplerDescriptorSize: u64 = 0,
    // Extern sync: false
    // Optional: false
    combinedImageSamplerDescriptorSize: u64 = 0,
    // Extern sync: false
    // Optional: false
    sampledImageDescriptorSize: u64 = 0,
    // Extern sync: false
    // Optional: false
    storageImageDescriptorSize: u64 = 0,
    // Extern sync: false
    // Optional: false
    uniformTexelBufferDescriptorSize: u64 = 0,
    // Extern sync: false
    // Optional: false
    robustUniformTexelBufferDescriptorSize: u64 = 0,
    // Extern sync: false
    // Optional: false
    storageTexelBufferDescriptorSize: u64 = 0,
    // Extern sync: false
    // Optional: false
    robustStorageTexelBufferDescriptorSize: u64 = 0,
    // Extern sync: false
    // Optional: false
    uniformBufferDescriptorSize: u64 = 0,
    // Extern sync: false
    // Optional: false
    robustUniformBufferDescriptorSize: u64 = 0,
    // Extern sync: false
    // Optional: false
    storageBufferDescriptorSize: u64 = 0,
    // Extern sync: false
    // Optional: false
    robustStorageBufferDescriptorSize: u64 = 0,
    // Extern sync: false
    // Optional: false
    inputAttachmentDescriptorSize: u64 = 0,
    // Extern sync: false
    // Optional: false
    accelerationStructureDescriptorSize: u64 = 0,
    // Extern sync: false
    // Optional: false
    maxSamplerDescriptorBufferRange: u64 = 0,
    // Extern sync: false
    // Optional: false
    maxResourceDescriptorBufferRange: u64 = 0,
    // Extern sync: false
    // Optional: false
    samplerDescriptorBufferAddressSpaceSize: u64 = 0,
    // Extern sync: false
    // Optional: false
    resourceDescriptorBufferAddressSpaceSize: u64 = 0,
    // Extern sync: false
    // Optional: false
    descriptorBufferAddressSpaceSize: u64 = 0,
};
// Extension: VK_EXT_descriptor_buffer
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_DENSITY_MAP_PROPERTIES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    combinedImageSamplerDensityMapDescriptorSize: u64 = 0,
};
// Extension: VK_EXT_descriptor_buffer
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDescriptorAddressInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_DESCRIPTOR_ADDRESS_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: true
    address: u64 = 0,
    // Extern sync: false
    // Optional: false
    range: u64 = 0,
    // Extern sync: false
    // Optional: false
    format: VkFormat = .VK_FORMAT_UNDEFINED,
};
// Extension: VK_EXT_descriptor_buffer
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDescriptorBufferBindingInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    address: u64 = 0,
    // Extern sync: false
    // Optional: true
    usage: VkBufferUsageFlags = .{},
};
// Extension: VK_EXT_descriptor_buffer
// Extends: VkDescriptorBufferBindingInfoEXT
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDescriptorBufferBindingPushDescriptorBufferHandleEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_PUSH_DESCRIPTOR_BUFFER_HANDLE_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    buffer: VkBuffer = .none,
};
// Extension: VK_EXT_descriptor_buffer
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDescriptorGetInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_DESCRIPTOR_GET_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    type: VkDescriptorType = .VK_DESCRIPTOR_TYPE_SAMPLER,
    // Extern sync: false
    // Optional: false
    // Selector field: type (What union field is valid)
    data: VkDescriptorDataEXT,
};
// Extension: VK_EXT_descriptor_buffer
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkBufferCaptureDescriptorDataInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_BUFFER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    buffer: VkBuffer = .none,
};
// Extension: VK_EXT_descriptor_buffer
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImageCaptureDescriptorDataInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_IMAGE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    image: VkImage = .none,
};
// Extension: VK_EXT_descriptor_buffer
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImageViewCaptureDescriptorDataInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_IMAGE_VIEW_CAPTURE_DESCRIPTOR_DATA_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    imageView: VkImageView = .none,
};
// Extension: VK_EXT_descriptor_buffer
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSamplerCaptureDescriptorDataInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_SAMPLER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    sampler: VkSampler = .none,
};
// Extension: VK_EXT_descriptor_buffer
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkAccelerationStructureCaptureDescriptorDataInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    accelerationStructure: VkAccelerationStructureKHR = .none,
    // Extern sync: false
    // Optional: true
    accelerationStructureNV: VkAccelerationStructureNV = .none,
};
// Extension: VK_EXT_descriptor_buffer
// Extends: VkBufferCreateInfo,VkImageCreateInfo,VkImageViewCreateInfo,VkSamplerCreateInfo,VkAccelerationStructureCreateInfoKHR,VkAccelerationStructureCreateInfoNV,VkTensorCreateInfoARM,VkTensorViewCreateInfoARM
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkOpaqueCaptureDescriptorDataCreateInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    opaqueCaptureDescriptorData: ?*const anyopaque = null,
};
// Extension: VK_KHR_shader_integer_dot_product
// Extension: VK_COMPUTE_VERSION_1_3
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceShaderIntegerDotProductFeatures = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    shaderIntegerDotProduct: u32 = 0,
};
// Extension: VK_KHR_shader_integer_dot_product
// Extension: VK_COMPUTE_VERSION_1_3
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceShaderIntegerDotProductProperties = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    integerDotProduct8BitUnsignedAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProduct8BitSignedAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProduct8BitMixedSignednessAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProduct4x8BitPackedUnsignedAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProduct4x8BitPackedSignedAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProduct4x8BitPackedMixedSignednessAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProduct16BitUnsignedAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProduct16BitSignedAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProduct16BitMixedSignednessAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProduct32BitUnsignedAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProduct32BitSignedAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProduct32BitMixedSignednessAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProduct64BitUnsignedAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProduct64BitSignedAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProduct64BitMixedSignednessAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProductAccumulatingSaturating8BitUnsignedAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProductAccumulatingSaturating8BitSignedAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProductAccumulatingSaturating16BitUnsignedAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProductAccumulatingSaturating16BitSignedAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProductAccumulatingSaturating32BitUnsignedAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProductAccumulatingSaturating32BitSignedAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProductAccumulatingSaturating64BitUnsignedAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProductAccumulatingSaturating64BitSignedAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated: u32 = 0,
};
// Extension: VK_EXT_physical_device_drm
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceDrmPropertiesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRM_PROPERTIES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    hasPrimary: u32 = 0,
    // Extern sync: false
    // Optional: false
    hasRender: u32 = 0,
    // Extern sync: false
    // Optional: false
    primaryMajor: i64 = 0,
    // Extern sync: false
    // Optional: false
    primaryMinor: i64 = 0,
    // Extern sync: false
    // Optional: false
    renderMajor: i64 = 0,
    // Extern sync: false
    // Optional: false
    renderMinor: i64 = 0,
};
// Extension: VK_NV_fragment_shader_barycentric
// Extension: VK_KHR_fragment_shader_barycentric
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    fragmentShaderBarycentric: u32 = 0,
};
// Extension: VK_KHR_fragment_shader_barycentric
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_PROPERTIES_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    triStripVertexOrderIndependentOfProvokingVertex: u32 = 0,
};
// Extension: VK_KHR_shader_fma
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceShaderFmaFeaturesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FMA_FEATURES_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    shaderFmaFloat16: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderFmaFloat32: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderFmaFloat64: u32 = 0,
};
// Extension: VK_NV_ray_tracing_motion_blur
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceRayTracingMotionBlurFeaturesNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    rayTracingMotionBlur: u32 = 0,
    // Extern sync: false
    // Optional: false
    rayTracingMotionBlurPipelineTraceRaysIndirect: u32 = 0,
};
// Extension: VK_NV_ray_tracing_validation
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceRayTracingValidationFeaturesNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_VALIDATION_FEATURES_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    rayTracingValidation: u32 = 0,
};
// Extension: VK_NV_ray_tracing_linear_swept_spheres
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_LINEAR_SWEPT_SPHERES_FEATURES_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    spheres: u32 = 0,
    // Extern sync: false
    // Optional: false
    linearSweptSpheres: u32 = 0,
};
// Extension: VK_NV_ray_tracing_motion_blur
// Extends: VkAccelerationStructureGeometryTrianglesDataKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkAccelerationStructureGeometryMotionTrianglesDataNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_MOTION_TRIANGLES_DATA_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    vertexData: VkDeviceOrHostAddressConstKHR,
};
// Extension: VK_NV_ray_tracing_motion_blur
// Extends: VkAccelerationStructureCreateInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkAccelerationStructureMotionInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MOTION_INFO_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    maxInstances: u32 = 0,
    // Extern sync: false
    // Optional: true
    flags: VkAccelerationStructureMotionInfoFlagsNV = .{},
};
// Extension: VK_NV_ray_tracing_motion_blur
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSRTDataNV = extern struct {
    // Extern sync: false
    // Optional: false
    sx: f32 = 0,
    // Extern sync: false
    // Optional: false
    a: f32 = 0,
    // Extern sync: false
    // Optional: false
    b: f32 = 0,
    // Extern sync: false
    // Optional: false
    pvx: f32 = 0,
    // Extern sync: false
    // Optional: false
    sy: f32 = 0,
    // Extern sync: false
    // Optional: false
    c: f32 = 0,
    // Extern sync: false
    // Optional: false
    pvy: f32 = 0,
    // Extern sync: false
    // Optional: false
    sz: f32 = 0,
    // Extern sync: false
    // Optional: false
    pvz: f32 = 0,
    // Extern sync: false
    // Optional: false
    qx: f32 = 0,
    // Extern sync: false
    // Optional: false
    qy: f32 = 0,
    // Extern sync: false
    // Optional: false
    qz: f32 = 0,
    // Extern sync: false
    // Optional: false
    qw: f32 = 0,
    // Extern sync: false
    // Optional: false
    tx: f32 = 0,
    // Extern sync: false
    // Optional: false
    ty: f32 = 0,
    // Extern sync: false
    // Optional: false
    tz: f32 = 0,
};
// Extension: VK_NV_ray_tracing_motion_blur
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkAccelerationStructureSRTMotionInstanceNV = extern struct {
    // Extern sync: false
    // Optional: false
    transformT0: VkSRTDataNV = .{},
    // Extern sync: false
    // Optional: false
    transformT1: VkSRTDataNV = .{},
    packed_field0: packed struct(u32) {
        instanceCustomIndex: u24 = 0,
        mask: u8 = 0,
        instanceShaderBindingTableRecordOffset: u24 = 0,
        flags: u8 = 0,
    } = .{},
    // Extern sync: false
    // Optional: false
    accelerationStructureReference: u64 = 0,
};
// Extension: VK_NV_ray_tracing_motion_blur
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkAccelerationStructureMatrixMotionInstanceNV = extern struct {
    // Extern sync: false
    // Optional: false
    transformT0: VkTransformMatrixKHR = .{},
    // Extern sync: false
    // Optional: false
    transformT1: VkTransformMatrixKHR = .{},
    packed_field0: packed struct(u32) {
        instanceCustomIndex: u24 = 0,
        mask: u8 = 0,
        instanceShaderBindingTableRecordOffset: u24 = 0,
        flags: u8 = 0,
    } = .{},
    // Extern sync: false
    // Optional: false
    accelerationStructureReference: u64 = 0,
};
// Extension: VK_NV_ray_tracing_motion_blur
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkAccelerationStructureMotionInstanceNV = extern struct {
    // Extern sync: false
    // Optional: false
    type: VkAccelerationStructureMotionInstanceTypeNV = .VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_STATIC_NV,
    // Extern sync: false
    // Optional: true
    flags: VkAccelerationStructureMotionInstanceFlagsNV = .{},
    // Extern sync: false
    // Optional: false
    // Selector field: type (What union field is valid)
    data: VkAccelerationStructureMotionInstanceDataNV,
};
// Extension: VK_NV_external_memory_rdma
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkMemoryGetRemoteAddressInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_MEMORY_GET_REMOTE_ADDRESS_INFO_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    memory: VkDeviceMemory = .none,
    // Extern sync: false
    // Optional: false
    handleType: VkExternalMemoryHandleTypeFlags = .{},
};
// Extension: VK_FUCHSIA_buffer_collection
// Extends: VkMemoryAllocateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImportMemoryBufferCollectionFUCHSIA = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_IMPORT_MEMORY_BUFFER_COLLECTION_FUCHSIA;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    collection: VkBufferCollectionFUCHSIA = .none,
    // Extern sync: false
    // Optional: false
    index: u32 = 0,
};
// Extension: VK_FUCHSIA_buffer_collection
// Extends: VkImageCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkBufferCollectionImageCreateInfoFUCHSIA = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_BUFFER_COLLECTION_IMAGE_CREATE_INFO_FUCHSIA;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    collection: VkBufferCollectionFUCHSIA = .none,
    // Extern sync: false
    // Optional: false
    index: u32 = 0,
};
// Extension: VK_FUCHSIA_buffer_collection
// Extends: VkBufferCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkBufferCollectionBufferCreateInfoFUCHSIA = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_BUFFER_COLLECTION_BUFFER_CREATE_INFO_FUCHSIA;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    collection: VkBufferCollectionFUCHSIA = .none,
    // Extern sync: false
    // Optional: false
    index: u32 = 0,
};
// Extension: VK_FUCHSIA_buffer_collection
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkBufferCollectionCreateInfoFUCHSIA = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_BUFFER_COLLECTION_CREATE_INFO_FUCHSIA;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
};
// Extension: VK_FUCHSIA_buffer_collection
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkBufferCollectionPropertiesFUCHSIA = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_BUFFER_COLLECTION_PROPERTIES_FUCHSIA;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    memoryTypeBits: u32 = 0,
    // Extern sync: false
    // Optional: false
    bufferCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    createInfoIndex: u32 = 0,
    // Extern sync: false
    // Optional: false
    sysmemPixelFormat: u64 = 0,
    // Extern sync: false
    // Optional: false
    formatFeatures: VkFormatFeatureFlags = .{},
    // Extern sync: false
    // Optional: false
    sysmemColorSpaceIndex: VkSysmemColorSpaceFUCHSIA = .{},
    // Extern sync: false
    // Optional: false
    samplerYcbcrConversionComponents: VkComponentMapping = .{},
    // Extern sync: false
    // Optional: false
    suggestedYcbcrModel: VkSamplerYcbcrModelConversion = .VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY,
    // Extern sync: false
    // Optional: false
    suggestedYcbcrRange: VkSamplerYcbcrRange = .VK_SAMPLER_YCBCR_RANGE_ITU_FULL,
    // Extern sync: false
    // Optional: false
    suggestedXChromaOffset: VkChromaLocation = .VK_CHROMA_LOCATION_COSITED_EVEN,
    // Extern sync: false
    // Optional: false
    suggestedYChromaOffset: VkChromaLocation = .VK_CHROMA_LOCATION_COSITED_EVEN,
};
// Extension: VK_FUCHSIA_buffer_collection
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkBufferConstraintsInfoFUCHSIA = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_BUFFER_CONSTRAINTS_INFO_FUCHSIA;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    createInfo: VkBufferCreateInfo = .{},
    // Extern sync: false
    // Optional: true
    requiredFormatFeatures: VkFormatFeatureFlags = .{},
    // Extern sync: false
    // Optional: false
    bufferCollectionConstraints: VkBufferCollectionConstraintsInfoFUCHSIA = .{},
};
// Extension: VK_FUCHSIA_buffer_collection
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSysmemColorSpaceFUCHSIA = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_SYSMEM_COLOR_SPACE_FUCHSIA;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    colorSpace: u32 = 0,
};
// Extension: VK_FUCHSIA_buffer_collection
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImageFormatConstraintsInfoFUCHSIA = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_IMAGE_FORMAT_CONSTRAINTS_INFO_FUCHSIA;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    imageCreateInfo: VkImageCreateInfo = .{},
    // Extern sync: false
    // Optional: false
    requiredFormatFeatures: VkFormatFeatureFlags = .{},
    // Extern sync: false
    // Optional: true
    flags: VkImageFormatConstraintsFlagsFUCHSIA = .{},
    // Extern sync: false
    // Optional: true
    sysmemPixelFormat: u64 = 0,
    // Extern sync: false
    // Optional: false
    colorSpaceCount: u32 = 0,
    // Length expression: colorSpaceCount
    // Extern sync: false
    // Optional: false
    pColorSpaces: ?[*]const VkSysmemColorSpaceFUCHSIA = null,
};
// Extension: VK_FUCHSIA_buffer_collection
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImageConstraintsInfoFUCHSIA = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_IMAGE_CONSTRAINTS_INFO_FUCHSIA;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    formatConstraintsCount: u32 = 0,
    // Length expression: formatConstraintsCount
    // Extern sync: false
    // Optional: false
    pFormatConstraints: ?[*]const VkImageFormatConstraintsInfoFUCHSIA = null,
    // Extern sync: false
    // Optional: false
    bufferCollectionConstraints: VkBufferCollectionConstraintsInfoFUCHSIA = .{},
    // Extern sync: false
    // Optional: true
    flags: VkImageConstraintsInfoFlagsFUCHSIA = .{},
};
// Extension: VK_FUCHSIA_buffer_collection
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkBufferCollectionConstraintsInfoFUCHSIA = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_BUFFER_COLLECTION_CONSTRAINTS_INFO_FUCHSIA;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    minBufferCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxBufferCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    minBufferCountForCamping: u32 = 0,
    // Extern sync: false
    // Optional: false
    minBufferCountForDedicatedSlack: u32 = 0,
    // Extern sync: false
    // Optional: false
    minBufferCountForSharedSlack: u32 = 0,
};
// Extension: VK_NV_cuda_kernel_launch
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkCudaModuleCreateInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_CUDA_MODULE_CREATE_INFO_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    dataSize: u64 = 0,
    // Length expression: dataSize
    // Extern sync: false
    // Optional: false
    pData: ?*const anyopaque = null,
};
// Extension: VK_NV_cuda_kernel_launch
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkCudaFunctionCreateInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_CUDA_FUNCTION_CREATE_INFO_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    module: VkCudaModuleNV = .none,
    // Length expression: null-terminated
    // Extern sync: false
    // Optional: false
    pName: ?[*:0]const u8 = null,
};
// Extension: VK_NV_cuda_kernel_launch
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkCudaLaunchInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_CUDA_LAUNCH_INFO_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    function: VkCudaFunctionNV = .none,
    // Extern sync: false
    // Optional: false
    gridDimX: u32 = 0,
    // Extern sync: false
    // Optional: false
    gridDimY: u32 = 0,
    // Extern sync: false
    // Optional: false
    gridDimZ: u32 = 0,
    // Extern sync: false
    // Optional: false
    blockDimX: u32 = 0,
    // Extern sync: false
    // Optional: false
    blockDimY: u32 = 0,
    // Extern sync: false
    // Optional: false
    blockDimZ: u32 = 0,
    // Extern sync: false
    // Optional: false
    sharedMemBytes: u32 = 0,
    // Extern sync: false
    // Optional: true
    paramCount: u64 = 0,
    // Length expression: paramCount
    // Extern sync: false
    // Optional: false
    pParams: ?[*]const *const anyopaque = null,
    // Extern sync: false
    // Optional: true
    extraCount: u64 = 0,
    // Length expression: extraCount
    // Extern sync: false
    // Optional: false
    pExtras: ?[*]const *const anyopaque = null,
};
// Extension: VK_EXT_rgba10x6_formats
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    formatRgba10x6WithoutYCbCrSampler: u32 = 0,
};
// Extension: VK_KHR_format_feature_flags2
// Extension: VK_BASE_VERSION_1_3
// Extends: VkFormatProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkFormatProperties3 = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: true
    linearTilingFeatures: VkFormatFeatureFlags2 = .{},
    // Extern sync: false
    // Optional: true
    optimalTilingFeatures: VkFormatFeatureFlags2 = .{},
    // Extern sync: false
    // Optional: true
    bufferFeatures: VkFormatFeatureFlags2 = .{},
};
// Extension: VK_EXT_image_drm_format_modifier
// Extends: VkFormatProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkDrmFormatModifierPropertiesList2EXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: true
    drmFormatModifierCount: u32 = 0,
    // Length expression: drmFormatModifierCount
    // Extern sync: false
    // Optional: true
    pDrmFormatModifierProperties: ?[*]VkDrmFormatModifierProperties2EXT = null,
};
// Extension: VK_EXT_image_drm_format_modifier
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkDrmFormatModifierProperties2EXT = extern struct {
    // Extern sync: false
    // Optional: false
    drmFormatModifier: u64 = 0,
    // Extern sync: false
    // Optional: false
    drmFormatModifierPlaneCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    drmFormatModifierTilingFeatures: VkFormatFeatureFlags2 = .{},
};
// Extension: VK_ANDROID_external_memory_android_hardware_buffer
// Extends: VkAndroidHardwareBufferPropertiesANDROID
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkAndroidHardwareBufferFormatProperties2ANDROID = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_2_ANDROID;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    format: VkFormat = .VK_FORMAT_UNDEFINED,
    // Extern sync: false
    // Optional: false
    externalFormat: u64 = 0,
    // Extern sync: false
    // Optional: false
    formatFeatures: VkFormatFeatureFlags2 = .{},
    // Extern sync: false
    // Optional: false
    samplerYcbcrConversionComponents: VkComponentMapping = .{},
    // Extern sync: false
    // Optional: false
    suggestedYcbcrModel: VkSamplerYcbcrModelConversion = .VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY,
    // Extern sync: false
    // Optional: false
    suggestedYcbcrRange: VkSamplerYcbcrRange = .VK_SAMPLER_YCBCR_RANGE_ITU_FULL,
    // Extern sync: false
    // Optional: false
    suggestedXChromaOffset: VkChromaLocation = .VK_CHROMA_LOCATION_COSITED_EVEN,
    // Extern sync: false
    // Optional: false
    suggestedYChromaOffset: VkChromaLocation = .VK_CHROMA_LOCATION_COSITED_EVEN,
};
// Extension: VK_KHR_dynamic_rendering
// Extension: VK_GRAPHICS_VERSION_1_3
// Extends: VkGraphicsPipelineCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineRenderingCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    viewMask: u32 = 0,
    // Extern sync: false
    // Optional: true
    colorAttachmentCount: u32 = 0,
    // Length expression: colorAttachmentCount
    // Extern sync: false
    // Optional: false
    pColorAttachmentFormats: ?[*]const VkFormat = null,
    // Extern sync: false
    // Optional: false
    depthAttachmentFormat: VkFormat = .VK_FORMAT_UNDEFINED,
    // Extern sync: false
    // Optional: false
    stencilAttachmentFormat: VkFormat = .VK_FORMAT_UNDEFINED,
};
// Extension: VK_KHR_dynamic_rendering
// Extension: VK_GRAPHICS_VERSION_1_3
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkRenderingInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_RENDERING_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkRenderingFlags = .{},
    // Extern sync: false
    // Optional: false
    renderArea: VkRect2D = .{},
    // Extern sync: false
    // Optional: false
    layerCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    viewMask: u32 = 0,
    // Extern sync: false
    // Optional: true
    colorAttachmentCount: u32 = 0,
    // Length expression: colorAttachmentCount
    // Extern sync: false
    // Optional: false
    pColorAttachments: ?[*]const VkRenderingAttachmentInfo = null,
    // Extern sync: false
    // Optional: true
    pDepthAttachment: ?*const VkRenderingAttachmentInfo = null,
    // Extern sync: false
    // Optional: true
    pStencilAttachment: ?*const VkRenderingAttachmentInfo = null,
};
// Extension: VK_EXT_fragment_density_map_offset
// Extension: VK_KHR_maintenance10
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkRenderingEndInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_RENDERING_END_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
};
// Extension: VK_KHR_dynamic_rendering
// Extension: VK_GRAPHICS_VERSION_1_3
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkRenderingAttachmentInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    imageView: VkImageView = .none,
    // Extern sync: false
    // Optional: false
    imageLayout: VkImageLayout = .VK_IMAGE_LAYOUT_UNDEFINED,
    // Extern sync: false
    // Optional: true
    resolveMode: VkResolveModeFlags = .{},
    // Extern sync: false
    // Optional: true
    resolveImageView: VkImageView = .none,
    // Extern sync: false
    // Optional: false
    resolveImageLayout: VkImageLayout = .VK_IMAGE_LAYOUT_UNDEFINED,
    // Extern sync: false
    // Optional: false
    loadOp: VkAttachmentLoadOp = .VK_ATTACHMENT_LOAD_OP_LOAD,
    // Extern sync: false
    // Optional: false
    storeOp: VkAttachmentStoreOp = .VK_ATTACHMENT_STORE_OP_STORE,
    // Extern sync: false
    // Optional: false
    clearValue: VkClearValue,
};
// Extension: VK_KHR_fragment_shading_rate
// Extends: VkRenderingInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkRenderingFragmentShadingRateAttachmentInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    imageView: VkImageView = .none,
    // Extern sync: false
    // Optional: false
    imageLayout: VkImageLayout = .VK_IMAGE_LAYOUT_UNDEFINED,
    // Extern sync: false
    // Optional: false
    shadingRateAttachmentTexelSize: VkExtent2D = .{},
};
// Extension: VK_EXT_fragment_density_map
// Extends: VkRenderingInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkRenderingFragmentDensityMapAttachmentInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    imageView: VkImageView = .none,
    // Extern sync: false
    // Optional: false
    imageLayout: VkImageLayout = .VK_IMAGE_LAYOUT_UNDEFINED,
};
// Extension: VK_KHR_dynamic_rendering
// Extension: VK_GRAPHICS_VERSION_1_3
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceDynamicRenderingFeatures = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    dynamicRendering: u32 = 0,
};
// Extension: VK_KHR_dynamic_rendering
// Extension: VK_GRAPHICS_VERSION_1_3
// Extends: VkCommandBufferInheritanceInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkCommandBufferInheritanceRenderingInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkRenderingFlags = .{},
    // Extern sync: false
    // Optional: false
    viewMask: u32 = 0,
    // Extern sync: false
    // Optional: true
    colorAttachmentCount: u32 = 0,
    // Length expression: colorAttachmentCount
    // Extern sync: false
    // Optional: false
    pColorAttachmentFormats: ?[*]const VkFormat = null,
    // Extern sync: false
    // Optional: false
    depthAttachmentFormat: VkFormat = .VK_FORMAT_UNDEFINED,
    // Extern sync: false
    // Optional: false
    stencilAttachmentFormat: VkFormat = .VK_FORMAT_UNDEFINED,
    // Extern sync: false
    // Optional: true
    rasterizationSamples: VkSampleCountFlags = .{},
};
// Extension: VK_NV_framebuffer_mixed_samples
// Extension: VK_AMD_mixed_attachment_samples
// Extends: VkCommandBufferInheritanceInfo,VkGraphicsPipelineCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkAttachmentSampleCountInfoAMD = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    colorAttachmentCount: u32 = 0,
    // Length expression: colorAttachmentCount
    // Extern sync: false
    // Optional: false
    pColorAttachmentSamples: ?[*]const VkSampleCountFlags = null,
    // Extern sync: false
    // Optional: true
    depthStencilAttachmentSamples: VkSampleCountFlags = .{},
};
// Extension: VK_NVX_multiview_per_view_attributes
// Extends: VkCommandBufferInheritanceInfo,VkGraphicsPipelineCreateInfo,VkRenderingInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkMultiviewPerViewAttributesInfoNVX = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_NVX;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    perViewAttributes: u32 = 0,
    // Extern sync: false
    // Optional: false
    perViewAttributesPositionXOnly: u32 = 0,
};
// Extension: VK_EXT_image_view_min_lod
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceImageViewMinLodFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    minLod: u32 = 0,
};
// Extension: VK_EXT_image_view_min_lod
// Extends: VkImageViewCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImageViewMinLodCreateInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_IMAGE_VIEW_MIN_LOD_CREATE_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    minLod: f32 = 0,
};
// Extension: VK_ARM_rasterization_order_attachment_access
// Extension: VK_EXT_rasterization_order_attachment_access
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    rasterizationOrderColorAttachmentAccess: u32 = 0,
    // Extern sync: false
    // Optional: false
    rasterizationOrderDepthAttachmentAccess: u32 = 0,
    // Extern sync: false
    // Optional: false
    rasterizationOrderStencilAttachmentAccess: u32 = 0,
};
// Extension: VK_NV_linear_color_attachment
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceLinearColorAttachmentFeaturesNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINEAR_COLOR_ATTACHMENT_FEATURES_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    linearColorAttachment: u32 = 0,
};
// Extension: VK_EXT_graphics_pipeline_library
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    graphicsPipelineLibrary: u32 = 0,
};
// Extension: VK_KHR_pipeline_binary
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDevicePipelineBinaryFeaturesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_FEATURES_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    pipelineBinaries: u32 = 0,
};
// Extension: VK_KHR_pipeline_binary
// Extends: VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDevicePipelineBinaryInternalCacheControlKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_DEVICE_PIPELINE_BINARY_INTERNAL_CACHE_CONTROL_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    disableInternalCache: u32 = 0,
};
// Extension: VK_KHR_pipeline_binary
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDevicePipelineBinaryPropertiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_PROPERTIES_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    pipelineBinaryInternalCache: u32 = 0,
    // Extern sync: false
    // Optional: false
    pipelineBinaryInternalCacheControl: u32 = 0,
    // Extern sync: false
    // Optional: false
    pipelineBinaryPrefersInternalCache: u32 = 0,
    // Extern sync: false
    // Optional: false
    pipelineBinaryPrecompiledInternalCache: u32 = 0,
    // Extern sync: false
    // Optional: false
    pipelineBinaryCompressedData: u32 = 0,
};
// Extension: VK_EXT_graphics_pipeline_library
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_PROPERTIES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    graphicsPipelineLibraryFastLinking: u32 = 0,
    // Extern sync: false
    // Optional: false
    graphicsPipelineLibraryIndependentInterpolationDecoration: u32 = 0,
};
// Extension: VK_EXT_graphics_pipeline_library
// Extends: VkGraphicsPipelineCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkGraphicsPipelineLibraryCreateInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_LIBRARY_CREATE_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    flags: VkGraphicsPipelineLibraryFlagsEXT = .{},
};
// Extension: VK_VALVE_descriptor_set_host_mapping
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    descriptorSetHostMapping: u32 = 0,
};
// Extension: VK_VALVE_descriptor_set_host_mapping
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDescriptorSetBindingReferenceVALVE = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_BINDING_REFERENCE_VALVE;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    descriptorSetLayout: VkDescriptorSetLayout = .none,
    // Extern sync: false
    // Optional: false
    binding: u32 = 0,
};
// Extension: VK_VALVE_descriptor_set_host_mapping
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDescriptorSetLayoutHostMappingInfoVALVE = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_HOST_MAPPING_INFO_VALVE;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    descriptorOffset: u64 = 0,
    // Extern sync: false
    // Optional: false
    descriptorSize: u32 = 0,
};
// Extension: VK_EXT_nested_command_buffer
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceNestedCommandBufferFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_FEATURES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    nestedCommandBuffer: u32 = 0,
    // Extern sync: false
    // Optional: false
    nestedCommandBufferRendering: u32 = 0,
    // Extern sync: false
    // Optional: false
    nestedCommandBufferSimultaneousUse: u32 = 0,
};
// Extension: VK_EXT_nested_command_buffer
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceNestedCommandBufferPropertiesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_PROPERTIES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    maxCommandBufferNestingLevel: u32 = 0,
};
// Extension: VK_EXT_shader_module_identifier
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    shaderModuleIdentifier: u32 = 0,
};
// Extension: VK_EXT_shader_module_identifier
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_PROPERTIES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    shaderModuleIdentifierAlgorithmUUID: [VK_UUID_SIZE]u8 = @import("std").mem.zeroes([VK_UUID_SIZE]u8),
};
// Extension: VK_EXT_shader_module_identifier
// Extends: VkPipelineShaderStageCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineShaderStageModuleIdentifierCreateInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_MODULE_IDENTIFIER_CREATE_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    identifierSize: u32 = 0,
    // Length expression: identifierSize
    // Extern sync: false
    // Optional: false
    pIdentifier: ?[*]const u8 = null,
};
// Extension: VK_EXT_shader_module_identifier
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkShaderModuleIdentifierEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_SHADER_MODULE_IDENTIFIER_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    identifierSize: u32 = 0,
    // Length expression: identifierSize
    // Extern sync: false
    // Optional: false
    identifier: [VK_MAX_SHADER_MODULE_IDENTIFIER_SIZE_EXT]u8 = @import("std").mem.zeroes([VK_MAX_SHADER_MODULE_IDENTIFIER_SIZE_EXT]u8),
};
// Extension: VK_EXT_image_compression_control
// Extends: VkImageCreateInfo,VkSwapchainCreateInfoKHR,VkPhysicalDeviceImageFormatInfo2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImageCompressionControlEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    flags: VkImageCompressionFlagsEXT = .{},
    // Extern sync: false
    // Optional: true
    compressionControlPlaneCount: u32 = 0,
    // Length expression: compressionControlPlaneCount
    // Extern sync: false
    // Optional: false
    pFixedRateFlags: ?[*]VkImageCompressionFixedRateFlagsEXT = null,
};
// Extension: VK_EXT_image_compression_control
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceImageCompressionControlFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    imageCompressionControl: u32 = 0,
};
// Extension: VK_EXT_image_compression_control
// Extends: VkImageFormatProperties2,VkSurfaceFormat2KHR,VkSubresourceLayout2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkImageCompressionPropertiesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    imageCompressionFlags: VkImageCompressionFlagsEXT = .{},
    // Extern sync: false
    // Optional: false
    imageCompressionFixedRateFlags: VkImageCompressionFixedRateFlagsEXT = .{},
};
// Extension: VK_EXT_image_compression_control_swapchain
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    imageCompressionControlSwapchain: u32 = 0,
};
// Extension: VK_KHR_maintenance5
// Extension: VK_EXT_host_image_copy
// Extension: VK_BASE_VERSION_1_4
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImageSubresource2 = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    imageSubresource: VkImageSubresource = .{},
};
// Extension: VK_KHR_maintenance5
// Extension: VK_EXT_host_image_copy
// Extension: VK_BASE_VERSION_1_4
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkSubresourceLayout2 = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    subresourceLayout: VkSubresourceLayout = .{},
};
// Extension: VK_EXT_subpass_merge_feedback
// Extends: VkRenderPassCreateInfo2,VkSubpassDescription2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkRenderPassCreationControlEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_CONTROL_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    disallowMerging: u32 = 0,
};
// Extension: VK_EXT_subpass_merge_feedback
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkRenderPassCreationFeedbackInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    postMergeSubpassCount: u32 = 0,
};
// Extension: VK_EXT_subpass_merge_feedback
// Extends: VkRenderPassCreateInfo2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkRenderPassCreationFeedbackCreateInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_FEEDBACK_CREATE_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    pRenderPassFeedback: ?*VkRenderPassCreationFeedbackInfoEXT = null,
};
// Extension: VK_EXT_subpass_merge_feedback
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkRenderPassSubpassFeedbackInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    subpassMergeStatus: VkSubpassMergeStatusEXT = .VK_SUBPASS_MERGE_STATUS_MERGED_EXT,
    // Length expression: null-terminated
    // Extern sync: false
    // Optional: false
    description: [VK_MAX_DESCRIPTION_SIZE]u8 = @import("std").mem.zeroes([VK_MAX_DESCRIPTION_SIZE]u8),
    // Extern sync: false
    // Optional: false
    postMergeIndex: u32 = 0,
};
// Extension: VK_EXT_subpass_merge_feedback
// Extends: VkSubpassDescription2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkRenderPassSubpassFeedbackCreateInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_RENDER_PASS_SUBPASS_FEEDBACK_CREATE_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    pSubpassFeedback: ?*VkRenderPassSubpassFeedbackInfoEXT = null,
};
// Extension: VK_EXT_subpass_merge_feedback
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    subpassMergeFeedback: u32 = 0,
};
// Extension: VK_EXT_opacity_micromap
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkMicromapBuildInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_MICROMAP_BUILD_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    type: VkMicromapTypeEXT = .VK_MICROMAP_TYPE_OPACITY_MICROMAP_EXT,
    // Extern sync: false
    // Optional: true
    flags: VkBuildMicromapFlagsEXT = .{},
    // Extern sync: false
    // Optional: false
    mode: VkBuildMicromapModeEXT = .VK_BUILD_MICROMAP_MODE_BUILD_EXT,
    // Extern sync: false
    // Optional: true
    dstMicromap: VkMicromapEXT = .none,
    // Extern sync: false
    // Optional: true
    usageCountsCount: u32 = 0,
    // Length expression: usageCountsCount
    // Extern sync: false
    // Optional: true
    pUsageCounts: ?[*]const VkMicromapUsageEXT = null,
    // Length expression: usageCountsCount,1
    // Extern sync: false
    // Optional: false
    ppUsageCounts: ?[*]const *const VkMicromapUsageEXT = null,
    // Extern sync: false
    // Optional: false
    data: VkDeviceOrHostAddressConstKHR,
    // Extern sync: false
    // Optional: false
    scratchData: VkDeviceOrHostAddressKHR,
    // Extern sync: false
    // Optional: false
    triangleArray: VkDeviceOrHostAddressConstKHR,
    // Extern sync: false
    // Optional: false
    triangleArrayStride: u64 = 0,
};
// Extension: VK_EXT_opacity_micromap
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkMicromapCreateInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_MICROMAP_CREATE_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    createFlags: VkMicromapCreateFlagsEXT = .{},
    // Extern sync: false
    // Optional: false
    buffer: VkBuffer = .none,
    // Extern sync: false
    // Optional: false
    // Comment: Specified in bytes
    offset: u64 = 0,
    // Extern sync: false
    // Optional: false
    size: u64 = 0,
    // Extern sync: false
    // Optional: false
    type: VkMicromapTypeEXT = .VK_MICROMAP_TYPE_OPACITY_MICROMAP_EXT,
    // Extern sync: false
    // Optional: true
    deviceAddress: u64 = 0,
};
// Extension: VK_EXT_opacity_micromap
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkMicromapVersionInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_MICROMAP_VERSION_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Length expression: 2*VK_UUID_SIZE
    // Extern sync: false
    // Optional: false
    pVersionData: ?[*]const u8 = null,
};
// Extension: VK_EXT_opacity_micromap
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkCopyMicromapInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_COPY_MICROMAP_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    src: VkMicromapEXT = .none,
    // Extern sync: false
    // Optional: false
    dst: VkMicromapEXT = .none,
    // Extern sync: false
    // Optional: false
    mode: VkCopyMicromapModeEXT = .VK_COPY_MICROMAP_MODE_CLONE_EXT,
};
// Extension: VK_EXT_opacity_micromap
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkCopyMicromapToMemoryInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_COPY_MICROMAP_TO_MEMORY_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    src: VkMicromapEXT = .none,
    // Extern sync: false
    // Optional: false
    dst: VkDeviceOrHostAddressKHR,
    // Extern sync: false
    // Optional: false
    mode: VkCopyMicromapModeEXT = .VK_COPY_MICROMAP_MODE_CLONE_EXT,
};
// Extension: VK_EXT_opacity_micromap
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkCopyMemoryToMicromapInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_COPY_MEMORY_TO_MICROMAP_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    src: VkDeviceOrHostAddressConstKHR,
    // Extern sync: false
    // Optional: false
    dst: VkMicromapEXT = .none,
    // Extern sync: false
    // Optional: false
    mode: VkCopyMicromapModeEXT = .VK_COPY_MICROMAP_MODE_CLONE_EXT,
};
// Extension: VK_EXT_opacity_micromap
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkMicromapBuildSizesInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_MICROMAP_BUILD_SIZES_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    micromapSize: u64 = 0,
    // Extern sync: false
    // Optional: false
    buildScratchSize: u64 = 0,
    // Extern sync: false
    // Optional: false
    discardable: u32 = 0,
};
// Extension: VK_EXT_opacity_micromap
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkMicromapUsageEXT = extern struct {
    // Extern sync: false
    // Optional: false
    count: u32 = 0,
    // Extern sync: false
    // Optional: false
    subdivisionLevel: u32 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Interpretation depends on parent type
    format: u32 = 0,
};
// Extension: VK_EXT_opacity_micromap
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkMicromapTriangleEXT = extern struct {
    // Extern sync: false
    // Optional: false
    // Comment: Specified in bytes
    dataOffset: u32 = 0,
    // Extern sync: false
    // Optional: false
    subdivisionLevel: u16 = 0,
    // Extern sync: false
    // Optional: false
    format: u16 = 0,
};
// Extension: VK_EXT_opacity_micromap
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceOpacityMicromapFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_FEATURES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    micromap: u32 = 0,
    // Extern sync: false
    // Optional: false
    micromapCaptureReplay: u32 = 0,
    // Extern sync: false
    // Optional: false
    micromapHostCommands: u32 = 0,
};
// Extension: VK_EXT_opacity_micromap
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceOpacityMicromapPropertiesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_PROPERTIES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    maxOpacity2StateSubdivisionLevel: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxOpacity4StateSubdivisionLevel: u32 = 0,
};
// Extension: VK_EXT_opacity_micromap
// Extends: VkAccelerationStructureGeometryTrianglesDataKHR,VkAccelerationStructureDenseGeometryFormatTrianglesDataAMDX
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkAccelerationStructureTrianglesOpacityMicromapEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_OPACITY_MICROMAP_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    indexType: VkIndexType = .VK_INDEX_TYPE_UINT16,
    // Extern sync: false
    // Optional: false
    indexBuffer: VkDeviceOrHostAddressConstKHR,
    // Extern sync: false
    // Optional: false
    indexStride: u64 = 0,
    // Extern sync: false
    // Optional: false
    baseTriangle: u32 = 0,
    // Extern sync: false
    // Optional: true
    usageCountsCount: u32 = 0,
    // Length expression: usageCountsCount
    // Extern sync: false
    // Optional: true
    pUsageCounts: ?[*]const VkMicromapUsageEXT = null,
    // Length expression: usageCountsCount,1
    // Extern sync: false
    // Optional: false
    ppUsageCounts: ?[*]const *const VkMicromapUsageEXT = null,
    // Extern sync: false
    // Optional: true
    micromap: VkMicromapEXT = .none,
};
// Extension: VK_NV_displacement_micromap
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceDisplacementMicromapFeaturesNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISPLACEMENT_MICROMAP_FEATURES_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    displacementMicromap: u32 = 0,
};
// Extension: VK_NV_displacement_micromap
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceDisplacementMicromapPropertiesNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISPLACEMENT_MICROMAP_PROPERTIES_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    maxDisplacementMicromapSubdivisionLevel: u32 = 0,
};
// Extension: VK_NV_displacement_micromap
// Extends: VkAccelerationStructureGeometryTrianglesDataKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkAccelerationStructureTrianglesDisplacementMicromapNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_DISPLACEMENT_MICROMAP_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    displacementBiasAndScaleFormat: VkFormat = .VK_FORMAT_UNDEFINED,
    // Extern sync: false
    // Optional: false
    displacementVectorFormat: VkFormat = .VK_FORMAT_UNDEFINED,
    // Extern sync: false
    // Optional: false
    displacementBiasAndScaleBuffer: VkDeviceOrHostAddressConstKHR,
    // Extern sync: false
    // Optional: false
    displacementBiasAndScaleStride: u64 = 0,
    // Extern sync: false
    // Optional: false
    displacementVectorBuffer: VkDeviceOrHostAddressConstKHR,
    // Extern sync: false
    // Optional: false
    displacementVectorStride: u64 = 0,
    // Extern sync: false
    // Optional: false
    displacedMicromapPrimitiveFlags: VkDeviceOrHostAddressConstKHR,
    // Extern sync: false
    // Optional: false
    displacedMicromapPrimitiveFlagsStride: u64 = 0,
    // Extern sync: false
    // Optional: false
    indexType: VkIndexType = .VK_INDEX_TYPE_UINT16,
    // Extern sync: false
    // Optional: false
    indexBuffer: VkDeviceOrHostAddressConstKHR,
    // Extern sync: false
    // Optional: false
    indexStride: u64 = 0,
    // Extern sync: false
    // Optional: false
    baseTriangle: u32 = 0,
    // Extern sync: false
    // Optional: true
    usageCountsCount: u32 = 0,
    // Length expression: usageCountsCount
    // Extern sync: false
    // Optional: true
    pUsageCounts: ?[*]const VkMicromapUsageEXT = null,
    // Length expression: usageCountsCount,1
    // Extern sync: false
    // Optional: false
    ppUsageCounts: ?[*]const *const VkMicromapUsageEXT = null,
    // Extern sync: false
    // Optional: true
    micromap: VkMicromapEXT = .none,
};
// Extension: VK_EXT_pipeline_properties
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPipelinePropertiesIdentifierEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_PROPERTIES_IDENTIFIER_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    pipelineIdentifier: [VK_UUID_SIZE]u8 = @import("std").mem.zeroes([VK_UUID_SIZE]u8),
};
// Extension: VK_EXT_pipeline_properties
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDevicePipelinePropertiesFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROPERTIES_FEATURES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    pipelinePropertiesIdentifier: u32 = 0,
};
// Extension: VK_AMD_shader_early_and_late_fragment_tests
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_FEATURES_AMD;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    shaderEarlyAndLateFragmentTests: u32 = 0,
};
// Extension: VK_EXT_external_memory_acquire_unmodified
// Extends: VkBufferMemoryBarrier,VkBufferMemoryBarrier2,VkImageMemoryBarrier,VkImageMemoryBarrier2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkExternalMemoryAcquireUnmodifiedEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    acquireUnmodifiedMemory: u32 = 0,
};
// Extension: VK_EXT_metal_objects
// Extends: VkInstanceCreateInfo,VkMemoryAllocateInfo,VkImageCreateInfo,VkImageViewCreateInfo,VkBufferViewCreateInfo,VkSemaphoreCreateInfo,VkEventCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: true
pub const VkExportMetalObjectCreateInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    exportObjectType: VkExportMetalObjectTypeFlagsEXT = .{},
};
// Extension: VK_EXT_metal_objects
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkExportMetalObjectsInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECTS_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
};
// Extension: VK_EXT_metal_objects
// Extends: VkExportMetalObjectsInfoEXT
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkExportMetalDeviceInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_EXPORT_METAL_DEVICE_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
};
// Extension: VK_EXT_metal_objects
// Extends: VkExportMetalObjectsInfoEXT
// Returned only: false
// Allow duplicate in pNext chain: true
pub const VkExportMetalCommandQueueInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_EXPORT_METAL_COMMAND_QUEUE_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    queue: VkQueue = .none,
    // Extern sync: false
    // Optional: false
};
// Extension: VK_EXT_metal_objects
// Extends: VkExportMetalObjectsInfoEXT
// Returned only: false
// Allow duplicate in pNext chain: true
pub const VkExportMetalBufferInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_EXPORT_METAL_BUFFER_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    memory: VkDeviceMemory = .none,
    // Extern sync: false
    // Optional: false
};
// Extension: VK_EXT_metal_objects
// Extends: VkMemoryAllocateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImportMetalBufferInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_IMPORT_METAL_BUFFER_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
};
// Extension: VK_EXT_metal_objects
// Extends: VkExportMetalObjectsInfoEXT
// Returned only: false
// Allow duplicate in pNext chain: true
pub const VkExportMetalTextureInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_EXPORT_METAL_TEXTURE_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    image: VkImage = .none,
    // Extern sync: false
    // Optional: true
    imageView: VkImageView = .none,
    // Extern sync: false
    // Optional: true
    bufferView: VkBufferView = .none,
    // Extern sync: false
    // Optional: false
    plane: VkImageAspectFlags = .{},
    // Extern sync: false
    // Optional: false
};
// Extension: VK_EXT_metal_objects
// Extends: VkImageCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: true
pub const VkImportMetalTextureInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_IMPORT_METAL_TEXTURE_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    plane: VkImageAspectFlags = .{},
    // Extern sync: false
    // Optional: false
};
// Extension: VK_EXT_metal_objects
// Extends: VkExportMetalObjectsInfoEXT
// Returned only: false
// Allow duplicate in pNext chain: true
pub const VkExportMetalIOSurfaceInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_EXPORT_METAL_IO_SURFACE_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    image: VkImage = .none,
    // Extern sync: false
    // Optional: false
};
// Extension: VK_EXT_metal_objects
// Extends: VkImageCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImportMetalIOSurfaceInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_IMPORT_METAL_IO_SURFACE_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
};
// Extension: VK_EXT_metal_objects
// Extends: VkExportMetalObjectsInfoEXT
// Returned only: false
// Allow duplicate in pNext chain: true
pub const VkExportMetalSharedEventInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_EXPORT_METAL_SHARED_EVENT_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    semaphore: VkSemaphore = .none,
    // Extern sync: false
    // Optional: true
    event: VkEvent = .none,
    // Extern sync: false
    // Optional: false
};
// Extension: VK_EXT_metal_objects
// Extends: VkSemaphoreCreateInfo,VkEventCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImportMetalSharedEventInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_IMPORT_METAL_SHARED_EVENT_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
};
// Extension: VK_EXT_non_seamless_cube_map
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    nonSeamlessCubeMap: u32 = 0,
};
// Extension: VK_EXT_pipeline_robustness
// Extension: VK_COMPUTE_VERSION_1_4
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDevicePipelineRobustnessFeatures = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    pipelineRobustness: u32 = 0,
};
// Extension: VK_EXT_pipeline_robustness
// Extension: VK_COMPUTE_VERSION_1_4
// Extends: VkGraphicsPipelineCreateInfo,VkComputePipelineCreateInfo,VkPipelineShaderStageCreateInfo,VkRayTracingPipelineCreateInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineRobustnessCreateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    storageBuffers: VkPipelineRobustnessBufferBehavior = .VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DEVICE_DEFAULT,
    // Extern sync: false
    // Optional: false
    uniformBuffers: VkPipelineRobustnessBufferBehavior = .VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DEVICE_DEFAULT,
    // Extern sync: false
    // Optional: false
    vertexInputs: VkPipelineRobustnessBufferBehavior = .VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DEVICE_DEFAULT,
    // Extern sync: false
    // Optional: false
    images: VkPipelineRobustnessImageBehavior = .VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DEVICE_DEFAULT,
};
// Extension: VK_EXT_pipeline_robustness
// Extension: VK_COMPUTE_VERSION_1_4
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDevicePipelineRobustnessProperties = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    defaultRobustnessStorageBuffers: VkPipelineRobustnessBufferBehavior = .VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DEVICE_DEFAULT,
    // Extern sync: false
    // Optional: false
    defaultRobustnessUniformBuffers: VkPipelineRobustnessBufferBehavior = .VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DEVICE_DEFAULT,
    // Extern sync: false
    // Optional: false
    defaultRobustnessVertexInputs: VkPipelineRobustnessBufferBehavior = .VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DEVICE_DEFAULT,
    // Extern sync: false
    // Optional: false
    defaultRobustnessImages: VkPipelineRobustnessImageBehavior = .VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DEVICE_DEFAULT,
};
// Extension: VK_QCOM_image_processing
// Extends: VkImageViewCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImageViewSampleWeightCreateInfoQCOM = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_IMAGE_VIEW_SAMPLE_WEIGHT_CREATE_INFO_QCOM;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    filterCenter: VkOffset2D = .{},
    // Extern sync: false
    // Optional: false
    filterSize: VkExtent2D = .{},
    // Extern sync: false
    // Optional: false
    numPhases: u32 = 0,
};
// Extension: VK_QCOM_image_processing
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceImageProcessingFeaturesQCOM = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_FEATURES_QCOM;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    textureSampleWeighted: u32 = 0,
    // Extern sync: false
    // Optional: false
    textureBoxFilter: u32 = 0,
    // Extern sync: false
    // Optional: false
    textureBlockMatch: u32 = 0,
};
// Extension: VK_QCOM_image_processing
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceImageProcessingPropertiesQCOM = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_PROPERTIES_QCOM;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: true
    maxWeightFilterPhases: u32 = 0,
    // Extern sync: false
    // Optional: true
    maxWeightFilterDimension: VkExtent2D = .{},
    // Extern sync: false
    // Optional: true
    maxBlockMatchRegion: VkExtent2D = .{},
    // Extern sync: false
    // Optional: true
    maxBoxFilterBlockSize: VkExtent2D = .{},
};
// Extension: VK_QCOM_tile_properties
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceTilePropertiesFeaturesQCOM = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_PROPERTIES_FEATURES_QCOM;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    tileProperties: u32 = 0,
};
// Extension: VK_QCOM_tile_properties
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkTilePropertiesQCOM = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_TILE_PROPERTIES_QCOM;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    tileSize: VkExtent3D = .{},
    // Extern sync: false
    // Optional: false
    apronSize: VkExtent2D = .{},
    // Extern sync: false
    // Optional: false
    origin: VkOffset2D = .{},
};
// Extension: VK_QCOM_tile_memory_heap
// Extends: VkCommandBufferInheritanceInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkTileMemoryBindInfoQCOM = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_TILE_MEMORY_BIND_INFO_QCOM;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    memory: VkDeviceMemory = .none,
};
// Extension: VK_SEC_amigo_profiling
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceAmigoProfilingFeaturesSEC = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_AMIGO_PROFILING_FEATURES_SEC;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    amigoProfiling: u32 = 0,
};
// Extension: VK_SEC_amigo_profiling
// Extends: VkSubmitInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkAmigoProfilingSubmitInfoSEC = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_AMIGO_PROFILING_SUBMIT_INFO_SEC;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    firstDrawTimestamp: u64 = 0,
    // Extern sync: false
    // Optional: false
    swapBufferTimestamp: u64 = 0,
};
// Extension: VK_EXT_attachment_feedback_loop_layout
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    attachmentFeedbackLoopLayout: u32 = 0,
};
// Extension: VK_KHR_unified_image_layouts
// Extends: VkRenderingAttachmentInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkAttachmentFeedbackLoopInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_ATTACHMENT_FEEDBACK_LOOP_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    feedbackLoopEnable: u32 = 0,
};
// Extension: VK_EXT_device_address_binding_report
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceAddressBindingReportFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ADDRESS_BINDING_REPORT_FEATURES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    reportAddressBinding: u32 = 0,
};
// Extension: VK_KHR_maintenance10
// Extends: VkRenderingAttachmentInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkRenderingAttachmentFlagsInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_FLAGS_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkRenderingAttachmentFlagsKHR = .{},
};
// Extension: VK_KHR_maintenance10
// Extends: VkResolveImageInfo2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkResolveImageModeInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_RESOLVE_IMAGE_MODE_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkResolveImageFlagsKHR = .{},
    // Extern sync: false
    // Optional: true
    resolveMode: VkResolveModeFlags = .{},
    // Extern sync: false
    // Optional: true
    stencilResolveMode: VkResolveModeFlags = .{},
};
// Extension: VK_EXT_device_address_binding_report
// Extends: VkDebugUtilsMessengerCallbackDataEXT
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDeviceAddressBindingCallbackDataEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_DEVICE_ADDRESS_BINDING_CALLBACK_DATA_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkDeviceAddressBindingFlagsEXT = .{},
    // Extern sync: false
    // Optional: false
    baseAddress: u64 = 0,
    // Extern sync: false
    // Optional: false
    size: u64 = 0,
    // Extern sync: false
    // Optional: false
    bindingType: VkDeviceAddressBindingTypeEXT = .VK_DEVICE_ADDRESS_BINDING_TYPE_BIND_EXT,
};
// Extension: VK_NV_optical_flow
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceOpticalFlowFeaturesNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_FEATURES_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    opticalFlow: u32 = 0,
};
// Extension: VK_NV_optical_flow
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceOpticalFlowPropertiesNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_PROPERTIES_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    supportedOutputGridSizes: VkOpticalFlowGridSizeFlagsNV = .{},
    // Extern sync: false
    // Optional: false
    supportedHintGridSizes: VkOpticalFlowGridSizeFlagsNV = .{},
    // Extern sync: false
    // Optional: false
    hintSupported: u32 = 0,
    // Extern sync: false
    // Optional: false
    costSupported: u32 = 0,
    // Extern sync: false
    // Optional: false
    bidirectionalFlowSupported: u32 = 0,
    // Extern sync: false
    // Optional: false
    globalFlowSupported: u32 = 0,
    // Extern sync: false
    // Optional: false
    minWidth: u32 = 0,
    // Extern sync: false
    // Optional: false
    minHeight: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxWidth: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxHeight: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxNumRegionsOfInterest: u32 = 0,
};
// Extension: VK_NV_optical_flow
// Extends: VkPhysicalDeviceImageFormatInfo2,VkImageCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkOpticalFlowImageFormatInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    usage: VkOpticalFlowUsageFlagsNV = .{},
};
// Extension: VK_NV_optical_flow
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkOpticalFlowImageFormatPropertiesNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_PROPERTIES_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    format: VkFormat = .VK_FORMAT_UNDEFINED,
};
// Extension: VK_NV_optical_flow
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkOpticalFlowSessionCreateInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_INFO_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    width: u32 = 0,
    // Extern sync: false
    // Optional: false
    height: u32 = 0,
    // Extern sync: false
    // Optional: false
    imageFormat: VkFormat = .VK_FORMAT_UNDEFINED,
    // Extern sync: false
    // Optional: false
    flowVectorFormat: VkFormat = .VK_FORMAT_UNDEFINED,
    // Extern sync: false
    // Optional: true
    costFormat: VkFormat = .VK_FORMAT_UNDEFINED,
    // Extern sync: false
    // Optional: false
    outputGridSize: VkOpticalFlowGridSizeFlagsNV = .{},
    // Extern sync: false
    // Optional: true
    hintGridSize: VkOpticalFlowGridSizeFlagsNV = .{},
    // Extern sync: false
    // Optional: true
    performanceLevel: VkOpticalFlowPerformanceLevelNV = .VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_UNKNOWN_NV,
    // Extern sync: false
    // Optional: true
    flags: VkOpticalFlowSessionCreateFlagsNV = .{},
};
// Extension: VK_NV_optical_flow
// Extends: VkOpticalFlowSessionCreateInfoNV
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkOpticalFlowSessionCreatePrivateDataInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_PRIVATE_DATA_INFO_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    id: u32 = 0,
    // Extern sync: false
    // Optional: false
    size: u32 = 0,
    // Extern sync: false
    // Optional: false
    pPrivateData: ?*const anyopaque = null,
};
// Extension: VK_NV_optical_flow
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkOpticalFlowExecuteInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_OPTICAL_FLOW_EXECUTE_INFO_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkOpticalFlowExecuteFlagsNV = .{},
    // Extern sync: false
    // Optional: true
    regionCount: u32 = 0,
    // Length expression: regionCount
    // Extern sync: false
    // Optional: false
    pRegions: ?[*]const VkRect2D = null,
};
// Extension: VK_EXT_device_fault
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceFaultFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FAULT_FEATURES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    deviceFault: u32 = 0,
    // Extern sync: false
    // Optional: false
    deviceFaultVendorBinary: u32 = 0,
};
// Extension: VK_EXT_device_fault
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDeviceFaultAddressInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    addressType: VkDeviceFaultAddressTypeEXT = .VK_DEVICE_FAULT_ADDRESS_TYPE_NONE_EXT,
    // Extern sync: false
    // Optional: false
    reportedAddress: u64 = 0,
    // Extern sync: false
    // Optional: false
    addressPrecision: u64 = 0,
};
// Extension: VK_EXT_device_fault
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDeviceFaultVendorInfoEXT = extern struct {
    // Length expression: null-terminated
    // Extern sync: false
    // Optional: false
    description: [VK_MAX_DESCRIPTION_SIZE]u8 = @import("std").mem.zeroes([VK_MAX_DESCRIPTION_SIZE]u8),
    // Extern sync: false
    // Optional: false
    vendorFaultCode: u64 = 0,
    // Extern sync: false
    // Optional: false
    vendorFaultData: u64 = 0,
};
// Extension: VK_EXT_device_fault
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDeviceFaultCountsEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_DEVICE_FAULT_COUNTS_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: true
    addressInfoCount: u32 = 0,
    // Extern sync: false
    // Optional: true
    vendorInfoCount: u32 = 0,
    // Extern sync: false
    // Optional: true
    // Comment: Specified in bytes
    vendorBinarySize: u64 = 0,
};
// Extension: VK_EXT_device_fault
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkDeviceFaultInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_DEVICE_FAULT_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Length expression: null-terminated
    // Extern sync: false
    // Optional: false
    description: [VK_MAX_DESCRIPTION_SIZE]u8 = @import("std").mem.zeroes([VK_MAX_DESCRIPTION_SIZE]u8),
    // Extern sync: false
    // Optional: true
    pAddressInfos: ?*VkDeviceFaultAddressInfoEXT = null,
    // Extern sync: false
    // Optional: true
    pVendorInfos: ?*VkDeviceFaultVendorInfoEXT = null,
    // Extern sync: false
    // Optional: true
    pVendorBinaryData: ?*anyopaque = null,
};
// Extension: VK_EXT_device_fault
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDeviceFaultVendorBinaryHeaderVersionOneEXT = extern struct {
    // Extern sync: false
    // Optional: false
    headerSize: u32 = 0,
    // Extern sync: false
    // Optional: false
    headerVersion: VkDeviceFaultVendorBinaryHeaderVersionEXT = .VK_DEVICE_FAULT_VENDOR_BINARY_HEADER_VERSION_ONE_EXT,
    // Extern sync: false
    // Optional: false
    vendorID: u32 = 0,
    // Extern sync: false
    // Optional: false
    deviceID: u32 = 0,
    // Extern sync: false
    // Optional: false
    driverVersion: ApiVersion = .{},
    // Extern sync: false
    // Optional: false
    pipelineCacheUUID: [VK_UUID_SIZE]u8 = @import("std").mem.zeroes([VK_UUID_SIZE]u8),
    // Extern sync: false
    // Optional: false
    applicationNameOffset: u32 = 0,
    // Extern sync: false
    // Optional: false
    applicationVersion: ApiVersion = .{},
    // Extern sync: false
    // Optional: false
    engineNameOffset: u32 = 0,
    // Extern sync: false
    // Optional: false
    engineVersion: ApiVersion = .{},
    // Extern sync: false
    // Optional: false
    apiVersion: ApiVersion = .{},
};
// Extension: VK_EXT_pipeline_library_group_handles
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_LIBRARY_GROUP_HANDLES_FEATURES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    pipelineLibraryGroupHandles: u32 = 0,
};
// Extension: VK_EXT_depth_bias_control
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDepthBiasInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_DEPTH_BIAS_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    depthBiasConstantFactor: f32 = 0,
    // Extern sync: false
    // Optional: false
    depthBiasClamp: f32 = 0,
    // Extern sync: false
    // Optional: false
    depthBiasSlopeFactor: f32 = 0,
};
// Extension: VK_EXT_depth_bias_control
// Extends: VkDepthBiasInfoEXT,VkPipelineRasterizationStateCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDepthBiasRepresentationInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_DEPTH_BIAS_REPRESENTATION_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    depthBiasRepresentation: VkDepthBiasRepresentationEXT = .VK_DEPTH_BIAS_REPRESENTATION_LEAST_REPRESENTABLE_VALUE_FORMAT_EXT,
    // Extern sync: false
    // Optional: false
    depthBiasExact: u32 = 0,
};
// Extension: VK_NV_memory_decompression
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDecompressMemoryRegionNV = extern struct {
    // Extern sync: false
    // Optional: false
    srcAddress: u64 = 0,
    // Extern sync: false
    // Optional: false
    dstAddress: u64 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Specified in bytes
    compressedSize: u64 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Specified in bytes
    decompressedSize: u64 = 0,
    // Extern sync: false
    // Optional: false
};
// Extension: VK_EXT_memory_decompression
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDecompressMemoryRegionEXT = extern struct {
    // Extern sync: false
    // Optional: false
    srcAddress: u64 = 0,
    // Extern sync: false
    // Optional: false
    dstAddress: u64 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Specified in bytes
    compressedSize: u64 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Specified in bytes
    decompressedSize: u64 = 0,
};
// Extension: VK_EXT_memory_decompression
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDecompressMemoryInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_DECOMPRESS_MEMORY_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    decompressionMethod: VkMemoryDecompressionMethodFlagsEXT = .{},
    // Extern sync: false
    // Optional: false
    regionCount: u32 = 0,
    // Length expression: regionCount
    // Extern sync: false
    // Optional: false
    pRegions: ?[*]const VkDecompressMemoryRegionEXT = null,
};
// Extension: VK_ARM_shader_core_builtins
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_PROPERTIES_ARM;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    shaderCoreMask: u64 = 0,
    // Extern sync: false
    // Optional: false
    shaderCoreCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderWarpsPerCore: u32 = 0,
};
// Extension: VK_ARM_shader_core_builtins
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_FEATURES_ARM;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    shaderCoreBuiltins: u32 = 0,
};
// Extension: VK_EXT_frame_boundary
// Extends: VkSubmitInfo,VkSubmitInfo2,VkPresentInfoKHR,VkBindSparseInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkFrameBoundaryEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkFrameBoundaryFlagsEXT = .{},
    // Extern sync: false
    // Optional: false
    frameID: u64 = 0,
    // Extern sync: false
    // Optional: true
    imageCount: u32 = 0,
    // Length expression: imageCount
    // Extern sync: false
    // Optional: true
    pImages: ?[*]const VkImage = null,
    // Extern sync: false
    // Optional: true
    bufferCount: u32 = 0,
    // Length expression: bufferCount
    // Extern sync: false
    // Optional: true
    pBuffers: ?[*]const VkBuffer = null,
    // Extern sync: false
    // Optional: true
    tagName: u64 = 0,
    // Extern sync: false
    // Optional: true
    tagSize: u64 = 0,
    // Length expression: tagSize
    // Extern sync: false
    // Optional: true
    pTag: ?*const anyopaque = null,
};
// Extension: VK_EXT_frame_boundary
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceFrameBoundaryFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAME_BOUNDARY_FEATURES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    frameBoundary: u32 = 0,
};
// Extension: VK_EXT_dynamic_rendering_unused_attachments
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_FEATURES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    dynamicRenderingUnusedAttachments: u32 = 0,
};
// Extension: VK_EXT_surface_maintenance1
// Extension: VK_KHR_surface_maintenance1
// Extends: VkPhysicalDeviceSurfaceInfo2KHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSurfacePresentModeKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    presentMode: VkPresentModeKHR = .VK_PRESENT_MODE_IMMEDIATE_KHR,
};
// Extension: VK_EXT_surface_maintenance1
// Extension: VK_KHR_surface_maintenance1
// Extends: VkSurfaceCapabilities2KHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSurfacePresentScalingCapabilitiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_SURFACE_PRESENT_SCALING_CAPABILITIES_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: true
    supportedPresentScaling: VkPresentScalingFlagsKHR = .{},
    // Extern sync: false
    // Optional: true
    supportedPresentGravityX: VkPresentGravityFlagsKHR = .{},
    // Extern sync: false
    // Optional: true
    supportedPresentGravityY: VkPresentGravityFlagsKHR = .{},
    // Extern sync: false
    // Optional: true
    // Comment: Supported minimum image width and height for the surface when scaling is used
    minScaledImageExtent: VkExtent2D = .{},
    // Extern sync: false
    // Optional: true
    // Comment: Supported maximum image width and height for the surface when scaling is used
    maxScaledImageExtent: VkExtent2D = .{},
};
// Extension: VK_EXT_surface_maintenance1
// Extension: VK_KHR_surface_maintenance1
// Extends: VkSurfaceCapabilities2KHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSurfacePresentModeCompatibilityKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_COMPATIBILITY_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: true
    presentModeCount: u32 = 0,
    // Length expression: presentModeCount
    // Extern sync: false
    // Optional: true
    // Comment: Output list of present modes compatible with the one specified in VkSurfacePresentModeKHR
    pPresentModes: ?[*]VkPresentModeKHR = null,
};
// Extension: VK_EXT_swapchain_maintenance1
// Extension: VK_KHR_swapchain_maintenance1
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceSwapchainMaintenance1FeaturesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    swapchainMaintenance1: u32 = 0,
};
// Extension: VK_EXT_swapchain_maintenance1
// Extension: VK_KHR_swapchain_maintenance1
// Extends: VkPresentInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSwapchainPresentFenceInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: Copy of VkPresentInfoKHR::swapchainCount
    swapchainCount: u32 = 0,
    // Length expression: swapchainCount
    // Extern sync: false
    // Optional: false
    // Comment: Fence to signal for each swapchain
    pFences: ?[*]const VkFence = null,
};
// Extension: VK_EXT_swapchain_maintenance1
// Extension: VK_KHR_swapchain_maintenance1
// Extends: VkSwapchainCreateInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSwapchainPresentModesCreateInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODES_CREATE_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    presentModeCount: u32 = 0,
    // Length expression: presentModeCount
    // Extern sync: false
    // Optional: false
    pPresentModes: ?[*]const VkPresentModeKHR = null,
};
// Extension: VK_EXT_swapchain_maintenance1
// Extension: VK_KHR_swapchain_maintenance1
// Extends: VkPresentInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSwapchainPresentModeInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODE_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: Copy of VkPresentInfoKHR::swapchainCount
    swapchainCount: u32 = 0,
    // Length expression: swapchainCount
    // Extern sync: false
    // Optional: false
    // Comment: Presentation mode for each swapchain
    pPresentModes: ?[*]const VkPresentModeKHR = null,
};
// Extension: VK_EXT_swapchain_maintenance1
// Extension: VK_KHR_swapchain_maintenance1
// Extends: VkSwapchainCreateInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSwapchainPresentScalingCreateInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_SCALING_CREATE_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    scalingBehavior: VkPresentScalingFlagsKHR = .{},
    // Extern sync: false
    // Optional: true
    presentGravityX: VkPresentGravityFlagsKHR = .{},
    // Extern sync: false
    // Optional: true
    presentGravityY: VkPresentGravityFlagsKHR = .{},
};
// Extension: VK_EXT_swapchain_maintenance1
// Extension: VK_KHR_swapchain_maintenance1
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkReleaseSwapchainImagesInfoKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_RELEASE_SWAPCHAIN_IMAGES_INFO_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: true
    // Optional: false
    // Comment: Swapchain for which images are being released
    swapchain: VkSwapchainKHR = .none,
    // Extern sync: false
    // Optional: false
    // Comment: Number of indices to release
    imageIndexCount: u32 = 0,
    // Length expression: imageIndexCount
    // Extern sync: false
    // Optional: false
    // Comment: Indices of which presentable images to release
    pImageIndices: ?[*]const u32 = null,
};
// Extension: VK_EXT_depth_bias_control
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceDepthBiasControlFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_BIAS_CONTROL_FEATURES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    depthBiasControl: u32 = 0,
    // Extern sync: false
    // Optional: false
    leastRepresentableValueForceUnormRepresentation: u32 = 0,
    // Extern sync: false
    // Optional: false
    floatRepresentation: u32 = 0,
    // Extern sync: false
    // Optional: false
    depthBiasExact: u32 = 0,
};
// Extension: VK_EXT_ray_tracing_invocation_reorder
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceRayTracingInvocationReorderFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_FEATURES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    rayTracingInvocationReorder: u32 = 0,
};
// Extension: VK_NV_ray_tracing_invocation_reorder
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_FEATURES_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Feature link: rayTracingInvocationReorderNV
    rayTracingInvocationReorder: u32 = 0,
};
// Extension: VK_EXT_ray_tracing_invocation_reorder
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceRayTracingInvocationReorderPropertiesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_PROPERTIES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    rayTracingInvocationReorderReorderingHint: VkRayTracingInvocationReorderModeEXT = .VK_RAY_TRACING_INVOCATION_REORDER_MODE_NONE_EXT,
    // Extern sync: false
    // Optional: false
    maxShaderBindingTableRecordIndex: u32 = 0,
};
// Extension: VK_NV_ray_tracing_invocation_reorder
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_PROPERTIES_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    rayTracingInvocationReorderReorderingHint: VkRayTracingInvocationReorderModeEXT = .VK_RAY_TRACING_INVOCATION_REORDER_MODE_NONE_EXT,
};
// Extension: VK_NV_extended_sparse_address_space
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_FEATURES_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    extendedSparseAddressSpace: u32 = 0,
};
// Extension: VK_NV_extended_sparse_address_space
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_PROPERTIES_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: Total address space available for extended sparse allocations (bytes)
    extendedSparseAddressSpaceSize: u64 = 0,
    // Extern sync: false
    // Optional: false
    // Comment: Bitfield of which image usages are supported for extended sparse allocations
    extendedSparseImageUsageFlags: VkImageUsageFlags = .{},
    // Extern sync: false
    // Optional: false
    // Comment: Bitfield of which buffer usages are supported for extended sparse allocations
    extendedSparseBufferUsageFlags: VkBufferUsageFlags = .{},
};
// Extension: VK_LUNARG_direct_driver_loading
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDirectDriverLoadingInfoLUNARG = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_INFO_LUNARG;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    flags: VkDirectDriverLoadingFlagsLUNARG = .{},
    // Extern sync: false
    // Optional: false
    pfnGetInstanceProcAddr: ?*const vkGetInstanceProcAddrLUNARG = null,
};
// Extension: VK_LUNARG_direct_driver_loading
// Extends: VkInstanceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDirectDriverLoadingListLUNARG = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_LIST_LUNARG;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    mode: VkDirectDriverLoadingModeLUNARG = .VK_DIRECT_DRIVER_LOADING_MODE_EXCLUSIVE_LUNARG,
    // Extern sync: false
    // Optional: false
    driverCount: u32 = 0,
    // Length expression: driverCount
    // Extern sync: false
    // Optional: false
    pDrivers: ?[*]const VkDirectDriverLoadingInfoLUNARG = null,
};
// Extension: VK_QCOM_multiview_per_view_viewports
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_VIEWPORTS_FEATURES_QCOM;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    multiviewPerViewViewports: u32 = 0,
};
// Extension: VK_KHR_ray_tracing_position_fetch
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_POSITION_FETCH_FEATURES_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    rayTracingPositionFetch: u32 = 0,
};
// Extension: VK_KHR_maintenance5
// Extension: VK_BASE_VERSION_1_4
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDeviceImageSubresourceInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_DEVICE_IMAGE_SUBRESOURCE_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    pCreateInfo: ?*const VkImageCreateInfo = null,
    // Extern sync: false
    // Optional: false
    pSubresource: ?*const VkImageSubresource2 = null,
};
// Extension: VK_ARM_shader_core_properties
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceShaderCorePropertiesARM = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_ARM;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    pixelRate: u32 = 0,
    // Extern sync: false
    // Optional: false
    texelRate: u32 = 0,
    // Extern sync: false
    // Optional: false
    fmaRate: u32 = 0,
};
// Extension: VK_QCOM_multiview_per_view_render_areas
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_RENDER_AREAS_FEATURES_QCOM;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    multiviewPerViewRenderAreas: u32 = 0,
};
// Extension: VK_QCOM_multiview_per_view_render_areas
// Extends: VkRenderPassBeginInfo,VkRenderingInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_RENDER_AREAS_RENDER_PASS_BEGIN_INFO_QCOM;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    perViewRenderAreaCount: u32 = 0,
    // Length expression: perViewRenderAreaCount
    // Extern sync: false
    // Optional: false
    pPerViewRenderAreas: ?[*]const VkRect2D = null,
};
// Extension: VK_NV_low_latency
// Extends: VkSemaphoreCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkQueryLowLatencySupportNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_QUERY_LOW_LATENCY_SUPPORT_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    pQueriedLowLatencyData: ?*anyopaque = null,
};
// Extension: VK_KHR_map_memory2
// Extension: VK_BASE_VERSION_1_4
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkMemoryMapInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_MEMORY_MAP_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkMemoryMapFlags = .{},
    // Extern sync: true
    // Optional: false
    memory: VkDeviceMemory = .none,
    // Extern sync: false
    // Optional: false
    offset: u64 = 0,
    // Extern sync: false
    // Optional: false
    size: u64 = 0,
};
// Extension: VK_KHR_map_memory2
// Extension: VK_BASE_VERSION_1_4
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkMemoryUnmapInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_MEMORY_UNMAP_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkMemoryUnmapFlags = .{},
    // Extern sync: true
    // Optional: false
    memory: VkDeviceMemory = .none,
};
// Extension: VK_EXT_shader_object
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceShaderObjectFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_FEATURES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    shaderObject: u32 = 0,
};
// Extension: VK_EXT_shader_object
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceShaderObjectPropertiesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_PROPERTIES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    shaderBinaryUUID: [VK_UUID_SIZE]u8 = @import("std").mem.zeroes([VK_UUID_SIZE]u8),
    // Extern sync: false
    // Optional: false
    shaderBinaryVersion: ApiVersion = .{},
};
// Extension: VK_EXT_shader_object
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkShaderCreateInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_SHADER_CREATE_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkShaderCreateFlagsEXT = .{},
    // Extern sync: false
    // Optional: false
    stage: VkShaderStageFlags = .{},
    // Extern sync: false
    // Optional: true
    nextStage: VkShaderStageFlags = .{},
    // Extern sync: false
    // Optional: false
    codeType: VkShaderCodeTypeEXT = .VK_SHADER_CODE_TYPE_BINARY_EXT,
    // Extern sync: false
    // Optional: false
    codeSize: u64 = 0,
    // Length expression: codeSize
    // Extern sync: false
    // Optional: false
    pCode: ?*const anyopaque = null,
    // Length expression: null-terminated
    // Extern sync: false
    // Optional: true
    pName: ?[*:0]const u8 = null,
    // Extern sync: false
    // Optional: true
    setLayoutCount: u32 = 0,
    // Length expression: setLayoutCount
    // Extern sync: false
    // Optional: true
    pSetLayouts: ?[*]const VkDescriptorSetLayout = null,
    // Extern sync: false
    // Optional: true
    pushConstantRangeCount: u32 = 0,
    // Length expression: pushConstantRangeCount
    // Extern sync: false
    // Optional: true
    pPushConstantRanges: ?[*]const VkPushConstantRange = null,
    // Extern sync: false
    // Optional: true
    pSpecializationInfo: ?*const VkSpecializationInfo = null,
};
// Extension: VK_EXT_shader_tile_image
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceShaderTileImageFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_FEATURES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    shaderTileImageColorReadAccess: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderTileImageDepthReadAccess: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderTileImageStencilReadAccess: u32 = 0,
};
// Extension: VK_EXT_shader_tile_image
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceShaderTileImagePropertiesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_PROPERTIES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    shaderTileImageCoherentReadAccelerated: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderTileImageReadSampleFromPixelRateInvocation: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderTileImageReadFromHelperInvocation: u32 = 0,
};
// Extension: VK_QNX_external_memory_screen_buffer
// Extends: VkMemoryAllocateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImportScreenBufferInfoQNX = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_IMPORT_SCREEN_BUFFER_INFO_QNX;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    buffer: ?*_screen_buffer = null,
};
// Extension: VK_QNX_external_memory_screen_buffer
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkScreenBufferPropertiesQNX = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_SCREEN_BUFFER_PROPERTIES_QNX;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    allocationSize: u64 = 0,
    // Extern sync: false
    // Optional: false
    memoryTypeBits: u32 = 0,
};
// Extension: VK_QNX_external_memory_screen_buffer
// Extends: VkScreenBufferPropertiesQNX
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkScreenBufferFormatPropertiesQNX = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_SCREEN_BUFFER_FORMAT_PROPERTIES_QNX;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    format: VkFormat = .VK_FORMAT_UNDEFINED,
    // Extern sync: false
    // Optional: false
    externalFormat: u64 = 0,
    // Extern sync: false
    // Optional: false
    screenUsage: u64 = 0,
    // Extern sync: false
    // Optional: false
    formatFeatures: VkFormatFeatureFlags = .{},
    // Extern sync: false
    // Optional: false
    samplerYcbcrConversionComponents: VkComponentMapping = .{},
    // Extern sync: false
    // Optional: false
    suggestedYcbcrModel: VkSamplerYcbcrModelConversion = .VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY,
    // Extern sync: false
    // Optional: false
    suggestedYcbcrRange: VkSamplerYcbcrRange = .VK_SAMPLER_YCBCR_RANGE_ITU_FULL,
    // Extern sync: false
    // Optional: false
    suggestedXChromaOffset: VkChromaLocation = .VK_CHROMA_LOCATION_COSITED_EVEN,
    // Extern sync: false
    // Optional: false
    suggestedYChromaOffset: VkChromaLocation = .VK_CHROMA_LOCATION_COSITED_EVEN,
};
// Extension: VK_QNX_external_memory_screen_buffer
// Extends: VkImageCreateInfo,VkSamplerYcbcrConversionCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkExternalFormatQNX = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_QNX;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    externalFormat: u64 = 0,
};
// Extension: VK_QNX_external_memory_screen_buffer
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_SCREEN_BUFFER_FEATURES_QNX;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    screenBufferImport: u32 = 0,
};
// Extension: VK_KHR_cooperative_matrix
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceCooperativeMatrixFeaturesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    cooperativeMatrix: u32 = 0,
    // Extern sync: false
    // Optional: false
    cooperativeMatrixRobustBufferAccess: u32 = 0,
};
// Extension: VK_KHR_cooperative_matrix
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkCooperativeMatrixPropertiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    MSize: u32 = 0,
    // Extern sync: false
    // Optional: false
    NSize: u32 = 0,
    // Extern sync: false
    // Optional: false
    KSize: u32 = 0,
    // Extern sync: false
    // Optional: false
    AType: VkComponentTypeKHR = .VK_COMPONENT_TYPE_FLOAT16_KHR,
    // Extern sync: false
    // Optional: false
    BType: VkComponentTypeKHR = .VK_COMPONENT_TYPE_FLOAT16_KHR,
    // Extern sync: false
    // Optional: false
    CType: VkComponentTypeKHR = .VK_COMPONENT_TYPE_FLOAT16_KHR,
    // Extern sync: false
    // Optional: false
    ResultType: VkComponentTypeKHR = .VK_COMPONENT_TYPE_FLOAT16_KHR,
    // Extern sync: false
    // Optional: false
    saturatingAccumulation: u32 = 0,
    // Extern sync: false
    // Optional: false
    scope: VkScopeKHR = .VK_SCOPE_DEVICE_KHR,
};
// Extension: VK_KHR_cooperative_matrix
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceCooperativeMatrixPropertiesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    cooperativeMatrixSupportedStages: VkShaderStageFlags = .{},
};
// Extension: VK_AMDX_shader_enqueue
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceShaderEnqueuePropertiesAMDX = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ENQUEUE_PROPERTIES_AMDX;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    maxExecutionGraphDepth: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxExecutionGraphShaderOutputNodes: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxExecutionGraphShaderPayloadSize: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxExecutionGraphShaderPayloadCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    executionGraphDispatchAddressAlignment: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxExecutionGraphWorkgroupCount: [3]u32 = @import("std").mem.zeroes([3]u32),
    // Extern sync: false
    // Optional: false
    maxExecutionGraphWorkgroups: u32 = 0,
};
// Extension: VK_AMDX_shader_enqueue
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceShaderEnqueueFeaturesAMDX = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ENQUEUE_FEATURES_AMDX;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    shaderEnqueue: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderMeshEnqueue: u32 = 0,
};
// Extension: VK_AMDX_shader_enqueue
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkExecutionGraphPipelineCreateInfoAMDX = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_EXECUTION_GRAPH_PIPELINE_CREATE_INFO_AMDX;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkPipelineCreateFlags = .{},
    // Extern sync: false
    // Optional: true
    stageCount: u32 = 0,
    // Length expression: stageCount
    // Extern sync: false
    // Optional: true
    pStages: ?[*]const VkPipelineShaderStageCreateInfo = null,
    // Extern sync: false
    // Optional: true
    pLibraryInfo: ?*const VkPipelineLibraryCreateInfoKHR = null,
    // Extern sync: false
    // Optional: false
    layout: VkPipelineLayout = .none,
    // Extern sync: false
    // Optional: true
    basePipelineHandle: VkPipeline = .none,
    // Extern sync: false
    // Optional: false
    basePipelineIndex: i32 = 0,
};
// Extension: VK_AMDX_shader_enqueue
// Extends: VkPipelineShaderStageCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineShaderStageNodeCreateInfoAMDX = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_NODE_CREATE_INFO_AMDX;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Length expression: null-terminated
    // Extern sync: false
    // Optional: true
    pName: ?[*:0]const u8 = null,
    // Extern sync: false
    // Optional: false
    index: u32 = 0,
};
// Extension: VK_AMDX_shader_enqueue
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkExecutionGraphPipelineScratchSizeAMDX = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_EXECUTION_GRAPH_PIPELINE_SCRATCH_SIZE_AMDX;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    minSize: u64 = 0,
    // Extern sync: false
    // Optional: false
    maxSize: u64 = 0,
    // Extern sync: false
    // Optional: false
    sizeGranularity: u64 = 0,
};
// Extension: VK_AMDX_shader_enqueue
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDispatchGraphInfoAMDX = extern struct {
    // Extern sync: false
    // Optional: false
    nodeIndex: u32 = 0,
    // Extern sync: false
    // Optional: true
    payloadCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    payloads: VkDeviceOrHostAddressConstAMDX,
    // Extern sync: false
    // Optional: false
    payloadStride: u64 = 0,
};
// Extension: VK_AMDX_shader_enqueue
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDispatchGraphCountInfoAMDX = extern struct {
    // Extern sync: false
    // Optional: true
    count: u32 = 0,
    // Extern sync: false
    // Optional: false
    infos: VkDeviceOrHostAddressConstAMDX,
    // Extern sync: false
    // Optional: false
    stride: u64 = 0,
};
// Extension: VK_AMD_anti_lag
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceAntiLagFeaturesAMD = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ANTI_LAG_FEATURES_AMD;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    antiLag: u32 = 0,
};
// Extension: VK_AMD_anti_lag
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkAntiLagDataAMD = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_ANTI_LAG_DATA_AMD;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    mode: VkAntiLagModeAMD = .VK_ANTI_LAG_MODE_DRIVER_CONTROL_AMD,
    // Extern sync: false
    // Optional: false
    maxFPS: u32 = 0,
    // Extern sync: false
    // Optional: true
    pPresentationInfo: ?*const VkAntiLagPresentationInfoAMD = null,
};
// Extension: VK_AMD_anti_lag
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkAntiLagPresentationInfoAMD = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_ANTI_LAG_PRESENTATION_INFO_AMD;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    stage: VkAntiLagStageAMD = .VK_ANTI_LAG_STAGE_INPUT_AMD,
    // Extern sync: false
    // Optional: false
    frameIndex: u64 = 0,
};
// Extension: VK_KHR_maintenance6
// Extension: VK_BASE_VERSION_1_4
// Extends: VkBindBufferMemoryInfo,VkBindImageMemoryInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkBindMemoryStatus = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_BIND_MEMORY_STATUS;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    pResult: ?*VkResult = null,
};
// Extension: VK_QCOM_tile_memory_heap
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceTileMemoryHeapFeaturesQCOM = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_MEMORY_HEAP_FEATURES_QCOM;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    tileMemoryHeap: u32 = 0,
};
// Extension: VK_QCOM_tile_memory_heap
// Extends: VkPhysicalDeviceProperties2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceTileMemoryHeapPropertiesQCOM = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_MEMORY_HEAP_PROPERTIES_QCOM;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    queueSubmitBoundary: u32 = 0,
    // Extern sync: false
    // Optional: false
    tileBufferTransfers: u32 = 0,
};
// Extension: VK_QCOM_tile_memory_heap
// Extends: VkRenderPassCreateInfo,VkRenderPassCreateInfo2,VkRenderingInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkTileMemorySizeInfoQCOM = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_TILE_MEMORY_SIZE_INFO_QCOM;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    size: u64 = 0,
};
// Extension: VK_QCOM_tile_memory_heap
// Extends: VkMemoryRequirements2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkTileMemoryRequirementsQCOM = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_TILE_MEMORY_REQUIREMENTS_QCOM;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    size: u64 = 0,
    // Extern sync: false
    // Optional: false
    alignment: u64 = 0,
};
// Extension: VK_KHR_maintenance6
// Extension: VK_COMPUTE_VERSION_1_4
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkBindDescriptorSetsInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_SETS_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    stageFlags: VkShaderStageFlags = .{},
    // Extern sync: false
    // Optional: true
    layout: VkPipelineLayout = .none,
    // Extern sync: false
    // Optional: true
    firstSet: u32 = 0,
    // Extern sync: false
    // Optional: false
    descriptorSetCount: u32 = 0,
    // Length expression: descriptorSetCount
    // Extern sync: false
    // Optional: false
    pDescriptorSets: ?[*]const VkDescriptorSet = null,
    // Extern sync: false
    // Optional: true
    dynamicOffsetCount: u32 = 0,
    // Length expression: dynamicOffsetCount
    // Extern sync: false
    // Optional: false
    pDynamicOffsets: ?[*]const u32 = null,
};
// Extension: VK_KHR_maintenance6
// Extension: VK_COMPUTE_VERSION_1_4
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPushConstantsInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PUSH_CONSTANTS_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    layout: VkPipelineLayout = .none,
    // Extern sync: false
    // Optional: false
    stageFlags: VkShaderStageFlags = .{},
    // Extern sync: false
    // Optional: true
    offset: u32 = 0,
    // Extern sync: false
    // Optional: false
    size: u32 = 0,
    // Length expression: size
    // Extern sync: false
    // Optional: false
    pValues: ?*const anyopaque = null,
};
// Extension: VK_KHR_maintenance6
// Extension: VK_COMPUTE_VERSION_1_4
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPushDescriptorSetInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    stageFlags: VkShaderStageFlags = .{},
    // Extern sync: false
    // Optional: true
    layout: VkPipelineLayout = .none,
    // Extern sync: false
    // Optional: true
    set: u32 = 0,
    // Extern sync: false
    // Optional: false
    descriptorWriteCount: u32 = 0,
    // Length expression: descriptorWriteCount
    // Extern sync: false
    // Optional: false
    pDescriptorWrites: ?[*]const VkWriteDescriptorSet = null,
};
// Extension: VK_KHR_maintenance6
// Extension: VK_COMPUTE_VERSION_1_4
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPushDescriptorSetWithTemplateInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_WITH_TEMPLATE_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    descriptorUpdateTemplate: VkDescriptorUpdateTemplate = .none,
    // Extern sync: false
    // Optional: true
    layout: VkPipelineLayout = .none,
    // Extern sync: false
    // Optional: true
    set: u32 = 0,
    // Extern sync: false
    // Optional: false
    pData: ?*const anyopaque = null,
};
// Extension: VK_KHR_maintenance6
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSetDescriptorBufferOffsetsInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_SET_DESCRIPTOR_BUFFER_OFFSETS_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    stageFlags: VkShaderStageFlags = .{},
    // Extern sync: false
    // Optional: true
    layout: VkPipelineLayout = .none,
    // Extern sync: false
    // Optional: true
    firstSet: u32 = 0,
    // Extern sync: false
    // Optional: false
    setCount: u32 = 0,
    // Length expression: setCount
    // Extern sync: false
    // Optional: false
    pBufferIndices: ?[*]const u32 = null,
    // Length expression: setCount
    // Extern sync: false
    // Optional: false
    pOffsets: ?[*]const u64 = null,
};
// Extension: VK_KHR_maintenance6
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkBindDescriptorBufferEmbeddedSamplersInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_BUFFER_EMBEDDED_SAMPLERS_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    stageFlags: VkShaderStageFlags = .{},
    // Extern sync: false
    // Optional: true
    layout: VkPipelineLayout = .none,
    // Extern sync: false
    // Optional: true
    set: u32 = 0,
};
// Extension: VK_QCOM_filter_cubic_clamp
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceCubicClampFeaturesQCOM = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_CLAMP_FEATURES_QCOM;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    cubicRangeClamp: u32 = 0,
};
// Extension: VK_QCOM_ycbcr_degamma
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceYcbcrDegammaFeaturesQCOM = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_DEGAMMA_FEATURES_QCOM;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    ycbcrDegamma: u32 = 0,
};
// Extension: VK_QCOM_ycbcr_degamma
// Extends: VkSamplerYcbcrConversionCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_YCBCR_DEGAMMA_CREATE_INFO_QCOM;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    enableYDegamma: u32 = 0,
    // Extern sync: false
    // Optional: false
    enableCbCrDegamma: u32 = 0,
};
// Extension: VK_QCOM_filter_cubic_weights
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceCubicWeightsFeaturesQCOM = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_WEIGHTS_FEATURES_QCOM;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    selectableCubicWeights: u32 = 0,
};
// Extension: VK_QCOM_filter_cubic_weights
// Extends: VkSamplerCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSamplerCubicWeightsCreateInfoQCOM = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_SAMPLER_CUBIC_WEIGHTS_CREATE_INFO_QCOM;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    cubicWeights: VkCubicFilterWeightsQCOM = .VK_CUBIC_FILTER_WEIGHTS_CATMULL_ROM_QCOM,
};
// Extension: VK_QCOM_filter_cubic_weights
// Extends: VkBlitImageInfo2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkBlitImageCubicWeightsInfoQCOM = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_BLIT_IMAGE_CUBIC_WEIGHTS_INFO_QCOM;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    cubicWeights: VkCubicFilterWeightsQCOM = .VK_CUBIC_FILTER_WEIGHTS_CATMULL_ROM_QCOM,
};
// Extension: VK_QCOM_image_processing2
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceImageProcessing2FeaturesQCOM = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_FEATURES_QCOM;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    textureBlockMatch2: u32 = 0,
};
// Extension: VK_QCOM_image_processing2
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceImageProcessing2PropertiesQCOM = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_PROPERTIES_QCOM;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: true
    maxBlockMatchWindow: VkExtent2D = .{},
};
// Extension: VK_QCOM_image_processing2
// Extends: VkSamplerCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSamplerBlockMatchWindowCreateInfoQCOM = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_SAMPLER_BLOCK_MATCH_WINDOW_CREATE_INFO_QCOM;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    windowExtent: VkExtent2D = .{},
    // Extern sync: false
    // Optional: false
    windowCompareMode: VkBlockMatchWindowCompareModeQCOM = .VK_BLOCK_MATCH_WINDOW_COMPARE_MODE_MIN_QCOM,
};
// Extension: VK_NV_descriptor_pool_overallocation
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_POOL_OVERALLOCATION_FEATURES_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    descriptorPoolOverallocation: u32 = 0,
};
// Extension: VK_MSFT_layered_driver
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceLayeredDriverPropertiesMSFT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_DRIVER_PROPERTIES_MSFT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    underlyingAPI: VkLayeredDriverUnderlyingApiMSFT = .VK_LAYERED_DRIVER_UNDERLYING_API_NONE_MSFT,
};
// Extension: VK_NV_per_stage_descriptor_set
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDevicePerStageDescriptorSetFeaturesNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PER_STAGE_DESCRIPTOR_SET_FEATURES_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    perStageDescriptorSet: u32 = 0,
    // Extern sync: false
    // Optional: false
    dynamicPipelineLayout: u32 = 0,
};
// Extension: VK_ANDROID_external_format_resolve
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceExternalFormatResolveFeaturesANDROID = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FORMAT_RESOLVE_FEATURES_ANDROID;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    externalFormatResolve: u32 = 0,
};
// Extension: VK_ANDROID_external_format_resolve
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceExternalFormatResolvePropertiesANDROID = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FORMAT_RESOLVE_PROPERTIES_ANDROID;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    nullColorAttachmentWithExternalFormatResolve: u32 = 0,
    // Extern sync: false
    // Optional: false
    externalFormatResolveChromaOffsetX: VkChromaLocation = .VK_CHROMA_LOCATION_COSITED_EVEN,
    // Extern sync: false
    // Optional: false
    externalFormatResolveChromaOffsetY: VkChromaLocation = .VK_CHROMA_LOCATION_COSITED_EVEN,
};
// Extension: VK_ANDROID_external_format_resolve
// Extends: VkAndroidHardwareBufferPropertiesANDROID
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkAndroidHardwareBufferFormatResolvePropertiesANDROID = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_RESOLVE_PROPERTIES_ANDROID;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    colorAttachmentFormat: VkFormat = .VK_FORMAT_UNDEFINED,
};
// Extension: VK_NV_low_latency2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkLatencySleepModeInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_LATENCY_SLEEP_MODE_INFO_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    lowLatencyMode: u32 = 0,
    // Extern sync: false
    // Optional: false
    lowLatencyBoost: u32 = 0,
    // Extern sync: false
    // Optional: false
    minimumIntervalUs: u32 = 0,
};
// Extension: VK_NV_low_latency2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkLatencySleepInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_LATENCY_SLEEP_INFO_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    signalSemaphore: VkSemaphore = .none,
    // Extern sync: false
    // Optional: false
    value: u64 = 0,
};
// Extension: VK_NV_low_latency2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSetLatencyMarkerInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_SET_LATENCY_MARKER_INFO_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    presentID: u64 = 0,
    // Extern sync: false
    // Optional: false
    marker: VkLatencyMarkerNV = .VK_LATENCY_MARKER_SIMULATION_START_NV,
};
// Extension: VK_NV_low_latency2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkGetLatencyMarkerInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_GET_LATENCY_MARKER_INFO_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    timingCount: u32 = 0,
    // Length expression: timingCount
    // Extern sync: false
    // Optional: true
    pTimings: ?[*]VkLatencyTimingsFrameReportNV = null,
};
// Extension: VK_NV_low_latency2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkLatencyTimingsFrameReportNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_LATENCY_TIMINGS_FRAME_REPORT_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    presentID: u64 = 0,
    // Extern sync: false
    // Optional: false
    inputSampleTimeUs: u64 = 0,
    // Extern sync: false
    // Optional: false
    simStartTimeUs: u64 = 0,
    // Extern sync: false
    // Optional: false
    simEndTimeUs: u64 = 0,
    // Extern sync: false
    // Optional: false
    renderSubmitStartTimeUs: u64 = 0,
    // Extern sync: false
    // Optional: false
    renderSubmitEndTimeUs: u64 = 0,
    // Extern sync: false
    // Optional: false
    presentStartTimeUs: u64 = 0,
    // Extern sync: false
    // Optional: false
    presentEndTimeUs: u64 = 0,
    // Extern sync: false
    // Optional: false
    driverStartTimeUs: u64 = 0,
    // Extern sync: false
    // Optional: false
    driverEndTimeUs: u64 = 0,
    // Extern sync: false
    // Optional: false
    osRenderQueueStartTimeUs: u64 = 0,
    // Extern sync: false
    // Optional: false
    osRenderQueueEndTimeUs: u64 = 0,
    // Extern sync: false
    // Optional: false
    gpuRenderStartTimeUs: u64 = 0,
    // Extern sync: false
    // Optional: false
    gpuRenderEndTimeUs: u64 = 0,
};
// Extension: VK_NV_low_latency2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkOutOfBandQueueTypeInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_OUT_OF_BAND_QUEUE_TYPE_INFO_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    queueType: VkOutOfBandQueueTypeNV = .VK_OUT_OF_BAND_QUEUE_TYPE_RENDER_NV,
};
// Extension: VK_NV_low_latency2
// Extends: VkSubmitInfo,VkSubmitInfo2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkLatencySubmissionPresentIdNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_LATENCY_SUBMISSION_PRESENT_ID_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    presentID: u64 = 0,
};
// Extension: VK_NV_low_latency2
// Extends: VkSwapchainCreateInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSwapchainLatencyCreateInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_SWAPCHAIN_LATENCY_CREATE_INFO_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    latencyModeEnable: u32 = 0,
};
// Extension: VK_NV_low_latency2
// Extends: VkSurfaceCapabilities2KHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkLatencySurfaceCapabilitiesNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_LATENCY_SURFACE_CAPABILITIES_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    presentModeCount: u32 = 0,
    // Length expression: presentModeCount
    // Extern sync: false
    // Optional: true
    pPresentModes: ?[*]VkPresentModeKHR = null,
};
// Extension: VK_NV_cuda_kernel_launch
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceCudaKernelLaunchFeaturesNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUDA_KERNEL_LAUNCH_FEATURES_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    cudaKernelLaunchFeatures: u32 = 0,
};
// Extension: VK_NV_cuda_kernel_launch
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceCudaKernelLaunchPropertiesNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUDA_KERNEL_LAUNCH_PROPERTIES_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    computeCapabilityMinor: u32 = 0,
    // Extern sync: false
    // Optional: false
    computeCapabilityMajor: u32 = 0,
};
// Extension: VK_ARM_scheduling_controls
// Extends: VkDeviceQueueCreateInfo,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDeviceQueueShaderCoreControlCreateInfoARM = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_DEVICE_QUEUE_SHADER_CORE_CONTROL_CREATE_INFO_ARM;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    shaderCoreCount: u32 = 0,
};
// Extension: VK_ARM_scheduling_controls
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceSchedulingControlsFeaturesARM = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_FEATURES_ARM;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    schedulingControls: u32 = 0,
};
// Extension: VK_ARM_scheduling_controls
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceSchedulingControlsPropertiesARM = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_PROPERTIES_ARM;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    schedulingControlsFlags: VkPhysicalDeviceSchedulingControlsFlagsARM = .{},
};
// Extension: VK_IMG_relaxed_line_rasterization
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RELAXED_LINE_RASTERIZATION_FEATURES_IMG;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    relaxedLineRasterization: u32 = 0,
};
// Extension: VK_ARM_render_pass_striped
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceRenderPassStripedFeaturesARM = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_FEATURES_ARM;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    renderPassStriped: u32 = 0,
};
// Extension: VK_ARM_render_pass_striped
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceRenderPassStripedPropertiesARM = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_PROPERTIES_ARM;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    renderPassStripeGranularity: VkExtent2D = .{},
    // Extern sync: false
    // Optional: false
    maxRenderPassStripes: u32 = 0,
};
// Extension: VK_ARM_render_pass_striped
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkRenderPassStripeInfoARM = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_INFO_ARM;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    stripeArea: VkRect2D = .{},
};
// Extension: VK_ARM_render_pass_striped
// Extends: VkRenderingInfo,VkRenderPassBeginInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkRenderPassStripeBeginInfoARM = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_BEGIN_INFO_ARM;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    stripeInfoCount: u32 = 0,
    // Length expression: stripeInfoCount
    // Extern sync: false
    // Optional: false
    pStripeInfos: ?[*]const VkRenderPassStripeInfoARM = null,
};
// Extension: VK_ARM_render_pass_striped
// Extends: VkCommandBufferSubmitInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkRenderPassStripeSubmitInfoARM = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_SUBMIT_INFO_ARM;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    stripeSemaphoreInfoCount: u32 = 0,
    // Length expression: stripeSemaphoreInfoCount
    // Extern sync: false
    // Optional: false
    pStripeSemaphoreInfos: ?[*]const VkSemaphoreSubmitInfo = null,
};
// Extension: VK_ARM_pipeline_opacity_micromap
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDevicePipelineOpacityMicromapFeaturesARM = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_OPACITY_MICROMAP_FEATURES_ARM;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    pipelineOpacityMicromap: u32 = 0,
};
// Extension: VK_KHR_shader_maximal_reconvergence
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MAXIMAL_RECONVERGENCE_FEATURES_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    shaderMaximalReconvergence: u32 = 0,
};
// Extension: VK_KHR_shader_subgroup_rotate
// Extension: VK_COMPUTE_VERSION_1_4
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceShaderSubgroupRotateFeatures = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_ROTATE_FEATURES;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    shaderSubgroupRotate: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderSubgroupRotateClustered: u32 = 0,
};
// Extension: VK_KHR_shader_expect_assume
// Extension: VK_COMPUTE_VERSION_1_4
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceShaderExpectAssumeFeatures = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EXPECT_ASSUME_FEATURES;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    shaderExpectAssume: u32 = 0,
};
// Extension: VK_KHR_shader_float_controls2
// Extension: VK_COMPUTE_VERSION_1_4
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceShaderFloatControls2Features = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT_CONTROLS_2_FEATURES;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    shaderFloatControls2: u32 = 0,
};
// Extension: VK_KHR_dynamic_rendering_local_read
// Extension: VK_GRAPHICS_VERSION_1_4
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceDynamicRenderingLocalReadFeatures = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_LOCAL_READ_FEATURES;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    dynamicRenderingLocalRead: u32 = 0,
};
// Extension: VK_KHR_dynamic_rendering_local_read
// Extension: VK_GRAPHICS_VERSION_1_4
// Extends: VkGraphicsPipelineCreateInfo,VkCommandBufferInheritanceInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkRenderingAttachmentLocationInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_LOCATION_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    colorAttachmentCount: u32 = 0,
    // Length expression: colorAttachmentCount
    // Extern sync: false
    // Optional: false
    pColorAttachmentLocations: ?[*]const u32 = null,
};
// Extension: VK_KHR_dynamic_rendering_local_read
// Extension: VK_GRAPHICS_VERSION_1_4
// Extends: VkGraphicsPipelineCreateInfo,VkCommandBufferInheritanceInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkRenderingInputAttachmentIndexInfo = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_RENDERING_INPUT_ATTACHMENT_INDEX_INFO;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    colorAttachmentCount: u32 = 0,
    // Length expression: colorAttachmentCount
    // Extern sync: false
    // Optional: true
    pColorAttachmentInputIndices: ?[*]const u32 = null,
    // Extern sync: false
    // Optional: true
    pDepthInputAttachmentIndex: ?*const u32 = null,
    // Extern sync: false
    // Optional: true
    pStencilInputAttachmentIndex: ?*const u32 = null,
};
// Extension: VK_KHR_shader_quad_control
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceShaderQuadControlFeaturesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_QUAD_CONTROL_FEATURES_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    shaderQuadControl: u32 = 0,
};
// Extension: VK_NV_shader_atomic_float16_vector
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT16_VECTOR_FEATURES_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    shaderFloat16VectorAtomics: u32 = 0,
};
// Extension: VK_EXT_map_memory_placed
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceMapMemoryPlacedFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_FEATURES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    memoryMapPlaced: u32 = 0,
    // Extern sync: false
    // Optional: false
    memoryMapRangePlaced: u32 = 0,
    // Extern sync: false
    // Optional: false
    memoryUnmapReserve: u32 = 0,
};
// Extension: VK_EXT_map_memory_placed
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceMapMemoryPlacedPropertiesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_PROPERTIES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    minPlacedMemoryMapAlignment: u64 = 0,
};
// Extension: VK_EXT_map_memory_placed
// Extends: VkMemoryMapInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkMemoryMapPlacedInfoEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_MEMORY_MAP_PLACED_INFO_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    pPlacedAddress: ?*anyopaque = null,
};
// Extension: VK_KHR_shader_bfloat16
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceShaderBfloat16FeaturesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_BFLOAT16_FEATURES_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    shaderBFloat16Type: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderBFloat16DotProduct: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderBFloat16CooperativeMatrix: u32 = 0,
};
// Extension: VK_NV_raw_access_chains
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceRawAccessChainsFeaturesNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAW_ACCESS_CHAINS_FEATURES_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    shaderRawAccessChains: u32 = 0,
};
// Extension: VK_NV_command_buffer_inheritance
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceCommandBufferInheritanceFeaturesNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMMAND_BUFFER_INHERITANCE_FEATURES_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    commandBufferInheritance: u32 = 0,
};
// Extension: VK_MESA_image_alignment_control
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceImageAlignmentControlFeaturesMESA = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_FEATURES_MESA;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    imageAlignmentControl: u32 = 0,
};
// Extension: VK_MESA_image_alignment_control
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceImageAlignmentControlPropertiesMESA = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_PROPERTIES_MESA;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    supportedImageAlignmentMask: u32 = 0,
};
// Extension: VK_MESA_image_alignment_control
// Extends: VkImageCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImageAlignmentControlCreateInfoMESA = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_IMAGE_ALIGNMENT_CONTROL_CREATE_INFO_MESA;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    maximumRequestedAlignment: u32 = 0,
};
// Extension: VK_EXT_shader_replicated_composites
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_REPLICATED_COMPOSITES_FEATURES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    shaderReplicatedComposites: u32 = 0,
};
// Extension: VK_EXT_present_mode_fifo_latest_ready
// Extension: VK_KHR_present_mode_fifo_latest_ready
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDevicePresentModeFifoLatestReadyFeaturesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_MODE_FIFO_LATEST_READY_FEATURES_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    presentModeFifoLatestReady: u32 = 0,
};
// Extension: VK_EXT_depth_clamp_control
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDepthClampRangeEXT = extern struct {
    // Extern sync: false
    // Optional: false
    minDepthClamp: f32 = 0,
    // Extern sync: false
    // Optional: false
    maxDepthClamp: f32 = 0,
};
// Extension: VK_NV_cooperative_matrix2
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceCooperativeMatrix2FeaturesNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_2_FEATURES_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    cooperativeMatrixWorkgroupScope: u32 = 0,
    // Extern sync: false
    // Optional: false
    cooperativeMatrixFlexibleDimensions: u32 = 0,
    // Extern sync: false
    // Optional: false
    cooperativeMatrixReductions: u32 = 0,
    // Extern sync: false
    // Optional: false
    cooperativeMatrixConversions: u32 = 0,
    // Extern sync: false
    // Optional: false
    cooperativeMatrixPerElementOperations: u32 = 0,
    // Extern sync: false
    // Optional: false
    cooperativeMatrixTensorAddressing: u32 = 0,
    // Extern sync: false
    // Optional: false
    cooperativeMatrixBlockLoads: u32 = 0,
};
// Extension: VK_NV_cooperative_matrix2
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceCooperativeMatrix2PropertiesNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_2_PROPERTIES_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    cooperativeMatrixWorkgroupScopeMaxWorkgroupSize: u32 = 0,
    // Extern sync: false
    // Optional: false
    cooperativeMatrixFlexibleDimensionsMaxDimension: u32 = 0,
    // Extern sync: false
    // Optional: false
    cooperativeMatrixWorkgroupScopeReservedSharedMemory: u32 = 0,
};
// Extension: VK_NV_cooperative_matrix2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkCooperativeMatrixFlexibleDimensionsPropertiesNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_FLEXIBLE_DIMENSIONS_PROPERTIES_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    MGranularity: u32 = 0,
    // Extern sync: false
    // Optional: false
    NGranularity: u32 = 0,
    // Extern sync: false
    // Optional: false
    KGranularity: u32 = 0,
    // Extern sync: false
    // Optional: false
    AType: VkComponentTypeKHR = .VK_COMPONENT_TYPE_FLOAT16_KHR,
    // Extern sync: false
    // Optional: false
    BType: VkComponentTypeKHR = .VK_COMPONENT_TYPE_FLOAT16_KHR,
    // Extern sync: false
    // Optional: false
    CType: VkComponentTypeKHR = .VK_COMPONENT_TYPE_FLOAT16_KHR,
    // Extern sync: false
    // Optional: false
    ResultType: VkComponentTypeKHR = .VK_COMPONENT_TYPE_FLOAT16_KHR,
    // Extern sync: false
    // Optional: false
    saturatingAccumulation: u32 = 0,
    // Extern sync: false
    // Optional: false
    scope: VkScopeKHR = .VK_SCOPE_DEVICE_KHR,
    // Extern sync: false
    // Optional: false
    workgroupInvocations: u32 = 0,
};
// Extension: VK_HUAWEI_hdr_vivid
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceHdrVividFeaturesHUAWEI = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HDR_VIVID_FEATURES_HUAWEI;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    hdrVivid: u32 = 0,
};
// Extension: VK_EXT_vertex_attribute_robustness
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_ROBUSTNESS_FEATURES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    vertexAttributeRobustness: u32 = 0,
};
// Extension: VK_AMDX_dense_geometry_format
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceDenseGeometryFormatFeaturesAMDX = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DENSE_GEOMETRY_FORMAT_FEATURES_AMDX;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    denseGeometryFormat: u32 = 0,
};
// Extension: VK_AMDX_dense_geometry_format
// Extends: VkAccelerationStructureGeometryKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkAccelerationStructureDenseGeometryFormatTrianglesDataAMDX = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DENSE_GEOMETRY_FORMAT_TRIANGLES_DATA_AMDX;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    compressedData: VkDeviceOrHostAddressConstKHR,
    // Extern sync: false
    // Optional: false
    dataSize: u64 = 0,
    // Extern sync: false
    // Optional: false
    numTriangles: u32 = 0,
    // Extern sync: false
    // Optional: false
    numVertices: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxPrimitiveIndex: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxGeometryIndex: u32 = 0,
    // Extern sync: false
    // Optional: false
    format: VkCompressedTriangleFormatAMDX = .VK_COMPRESSED_TRIANGLE_FORMAT_DGF1_AMDX,
};
// Extension: VK_EXT_depth_clamp_zero_one
// Extension: VK_KHR_depth_clamp_zero_one
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceDepthClampZeroOneFeaturesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    depthClampZeroOne: u32 = 0,
};
// Extension: VK_NV_cooperative_vector
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceCooperativeVectorFeaturesNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_VECTOR_FEATURES_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    cooperativeVector: u32 = 0,
    // Extern sync: false
    // Optional: false
    cooperativeVectorTraining: u32 = 0,
};
// Extension: VK_NV_cooperative_vector
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkCooperativeVectorPropertiesNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_COOPERATIVE_VECTOR_PROPERTIES_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    inputType: VkComponentTypeKHR = .VK_COMPONENT_TYPE_FLOAT16_KHR,
    // Extern sync: false
    // Optional: false
    inputInterpretation: VkComponentTypeKHR = .VK_COMPONENT_TYPE_FLOAT16_KHR,
    // Extern sync: false
    // Optional: false
    matrixInterpretation: VkComponentTypeKHR = .VK_COMPONENT_TYPE_FLOAT16_KHR,
    // Extern sync: false
    // Optional: false
    biasInterpretation: VkComponentTypeKHR = .VK_COMPONENT_TYPE_FLOAT16_KHR,
    // Extern sync: false
    // Optional: false
    resultType: VkComponentTypeKHR = .VK_COMPONENT_TYPE_FLOAT16_KHR,
    // Extern sync: false
    // Optional: false
    transpose: u32 = 0,
};
// Extension: VK_NV_cooperative_vector
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceCooperativeVectorPropertiesNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_VECTOR_PROPERTIES_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    cooperativeVectorSupportedStages: VkShaderStageFlags = .{},
    // Extern sync: false
    // Optional: false
    cooperativeVectorTrainingFloat16Accumulation: u32 = 0,
    // Extern sync: false
    // Optional: false
    cooperativeVectorTrainingFloat32Accumulation: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxCooperativeVectorComponents: u32 = 0,
};
// Extension: VK_NV_cooperative_vector
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkConvertCooperativeVectorMatrixInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_CONVERT_COOPERATIVE_VECTOR_MATRIX_INFO_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    srcSize: u64 = 0,
    // Extern sync: false
    // Optional: false
    srcData: VkDeviceOrHostAddressConstKHR,
    // Extern sync: false
    // Optional: false
    pDstSize: ?*u64 = null,
    // Extern sync: false
    // Optional: false
    dstData: VkDeviceOrHostAddressKHR,
    // Extern sync: false
    // Optional: false
    srcComponentType: VkComponentTypeKHR = .VK_COMPONENT_TYPE_FLOAT16_KHR,
    // Extern sync: false
    // Optional: false
    dstComponentType: VkComponentTypeKHR = .VK_COMPONENT_TYPE_FLOAT16_KHR,
    // Extern sync: false
    // Optional: false
    numRows: u32 = 0,
    // Extern sync: false
    // Optional: false
    numColumns: u32 = 0,
    // Extern sync: false
    // Optional: false
    srcLayout: VkCooperativeVectorMatrixLayoutNV = .VK_COOPERATIVE_VECTOR_MATRIX_LAYOUT_ROW_MAJOR_NV,
    // Extern sync: false
    // Optional: false
    srcStride: u64 = 0,
    // Extern sync: false
    // Optional: false
    dstLayout: VkCooperativeVectorMatrixLayoutNV = .VK_COOPERATIVE_VECTOR_MATRIX_LAYOUT_ROW_MAJOR_NV,
    // Extern sync: false
    // Optional: false
    dstStride: u64 = 0,
};
// Extension: VK_QCOM_tile_shading
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceTileShadingFeaturesQCOM = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_SHADING_FEATURES_QCOM;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    tileShading: u32 = 0,
    // Extern sync: false
    // Optional: false
    tileShadingFragmentStage: u32 = 0,
    // Extern sync: false
    // Optional: false
    tileShadingColorAttachments: u32 = 0,
    // Extern sync: false
    // Optional: false
    tileShadingDepthAttachments: u32 = 0,
    // Extern sync: false
    // Optional: false
    tileShadingStencilAttachments: u32 = 0,
    // Extern sync: false
    // Optional: false
    tileShadingInputAttachments: u32 = 0,
    // Extern sync: false
    // Optional: false
    tileShadingSampledAttachments: u32 = 0,
    // Extern sync: false
    // Optional: false
    tileShadingPerTileDraw: u32 = 0,
    // Extern sync: false
    // Optional: false
    tileShadingPerTileDispatch: u32 = 0,
    // Extern sync: false
    // Optional: false
    tileShadingDispatchTile: u32 = 0,
    // Extern sync: false
    // Optional: false
    tileShadingApron: u32 = 0,
    // Extern sync: false
    // Optional: false
    tileShadingAnisotropicApron: u32 = 0,
    // Extern sync: false
    // Optional: false
    tileShadingAtomicOps: u32 = 0,
    // Extern sync: false
    // Optional: false
    tileShadingImageProcessing: u32 = 0,
};
// Extension: VK_QCOM_tile_shading
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceTileShadingPropertiesQCOM = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_SHADING_PROPERTIES_QCOM;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    maxApronSize: u32 = 0,
    // Extern sync: false
    // Optional: false
    preferNonCoherent: u32 = 0,
    // Extern sync: false
    // Optional: false
    tileGranularity: VkExtent2D = .{},
    // Extern sync: false
    // Optional: false
    maxTileShadingRate: VkExtent2D = .{},
};
// Extension: VK_QCOM_tile_shading
// Extends: VkRenderPassCreateInfo,VkRenderPassCreateInfo2,VkRenderingInfo,VkCommandBufferInheritanceInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkRenderPassTileShadingCreateInfoQCOM = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_RENDER_PASS_TILE_SHADING_CREATE_INFO_QCOM;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkTileShadingRenderPassFlagsQCOM = .{},
    // Extern sync: false
    // Optional: true
    tileApronSize: VkExtent2D = .{},
};
// Extension: VK_QCOM_tile_shading
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPerTileBeginInfoQCOM = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PER_TILE_BEGIN_INFO_QCOM;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
};
// Extension: VK_QCOM_tile_shading
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPerTileEndInfoQCOM = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PER_TILE_END_INFO_QCOM;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
};
// Extension: VK_QCOM_tile_shading
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDispatchTileInfoQCOM = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_DISPATCH_TILE_INFO_QCOM;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
};
// Extension: VK_VALVE_fragment_density_map_layered
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceFragmentDensityMapLayeredPropertiesVALVE = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_LAYERED_PROPERTIES_VALVE;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    maxFragmentDensityMapLayers: u32 = 0,
};
// Extension: VK_VALVE_fragment_density_map_layered
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_LAYERED_FEATURES_VALVE;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    fragmentDensityMapLayered: u32 = 0,
};
// Extension: VK_VALVE_fragment_density_map_layered
// Extends: VkGraphicsPipelineCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPipelineFragmentDensityMapLayeredCreateInfoVALVE = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_DENSITY_MAP_LAYERED_CREATE_INFO_VALVE;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    maxFragmentDensityMapLayers: u32 = 0,
};
// Extension: VK_NV_present_metering
// Extends: VkPresentInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSetPresentConfigNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_SET_PRESENT_CONFIG_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    numFramesPerBatch: u32 = 0,
    // Extern sync: false
    // Optional: false
    presentConfigFeedback: u32 = 0,
};
// Extension: VK_NV_present_metering
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDevicePresentMeteringFeaturesNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_METERING_FEATURES_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    presentMetering: u32 = 0,
};
// Extension: VK_NV_external_compute_queue
// Extends: VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkExternalComputeQueueDeviceCreateInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_EXTERNAL_COMPUTE_QUEUE_DEVICE_CREATE_INFO_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    reservedExternalQueues: u32 = 0,
};
// Extension: VK_NV_external_compute_queue
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkExternalComputeQueueCreateInfoNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_EXTERNAL_COMPUTE_QUEUE_CREATE_INFO_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    preferredQueue: VkQueue = .none,
};
// Extension: VK_NV_external_compute_queue
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkExternalComputeQueueDataParamsNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_EXTERNAL_COMPUTE_QUEUE_DATA_PARAMS_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    deviceIndex: u32 = 0,
};
// Extension: VK_NV_external_compute_queue
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceExternalComputeQueuePropertiesNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_COMPUTE_QUEUE_PROPERTIES_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    externalDataSize: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxExternalQueues: u32 = 0,
};
// Extension: VK_EXT_shader_uniform_buffer_unsized_array
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceShaderUniformBufferUnsizedArrayFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_UNIFORM_BUFFER_UNSIZED_ARRAY_FEATURES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    shaderUniformBufferUnsizedArray: u32 = 0,
};
// Extension: VK_ARM_format_pack
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceFormatPackFeaturesARM = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FORMAT_PACK_FEATURES_ARM;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    formatPack: u32 = 0,
};
// Extension: VK_ARM_tensors
// Extends: VkDataGraphPipelineResourceInfoARM,VkDataGraphPipelineConstantARM
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkTensorDescriptionARM = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_TENSOR_DESCRIPTION_ARM;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    tiling: VkTensorTilingARM = .VK_TENSOR_TILING_OPTIMAL_ARM,
    // Extern sync: false
    // Optional: false
    format: VkFormat = .VK_FORMAT_UNDEFINED,
    // Extern sync: false
    // Optional: false
    dimensionCount: u32 = 0,
    // Length expression: dimensionCount
    // Extern sync: false
    // Optional: false
    pDimensions: ?[*]const i64 = null,
    // Length expression: dimensionCount
    // Extern sync: false
    // Optional: true
    pStrides: ?[*]const i64 = null,
    // Extern sync: false
    // Optional: false
    usage: VkTensorUsageFlagsARM = .{},
};
// Extension: VK_ARM_tensors
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkTensorCreateInfoARM = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_TENSOR_CREATE_INFO_ARM;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkTensorCreateFlagsARM = .{},
    // Extern sync: false
    // Optional: false
    pDescription: ?*const VkTensorDescriptionARM = null,
    // Extern sync: false
    // Optional: false
    sharingMode: VkSharingMode = .VK_SHARING_MODE_EXCLUSIVE,
    // Extern sync: false
    // Optional: true
    queueFamilyIndexCount: u32 = 0,
    // Length expression: queueFamilyIndexCount
    // Extern sync: false
    // Optional: false
    pQueueFamilyIndices: ?[*]const u32 = null,
};
// Extension: VK_ARM_tensors
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkTensorViewCreateInfoARM = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_TENSOR_VIEW_CREATE_INFO_ARM;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkTensorViewCreateFlagsARM = .{},
    // Extern sync: false
    // Optional: false
    tensor: VkTensorARM = .none,
    // Extern sync: false
    // Optional: false
    format: VkFormat = .VK_FORMAT_UNDEFINED,
};
// Extension: VK_ARM_tensors
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkTensorMemoryRequirementsInfoARM = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_TENSOR_MEMORY_REQUIREMENTS_INFO_ARM;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    tensor: VkTensorARM = .none,
};
// Extension: VK_ARM_tensors
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkBindTensorMemoryInfoARM = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_BIND_TENSOR_MEMORY_INFO_ARM;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: true
    // Optional: false
    tensor: VkTensorARM = .none,
    // Extern sync: false
    // Optional: false
    memory: VkDeviceMemory = .none,
    // Extern sync: false
    // Optional: false
    memoryOffset: u64 = 0,
};
// Extension: VK_ARM_tensors
// Extends: VkWriteDescriptorSet
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkWriteDescriptorSetTensorARM = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_TENSOR_ARM;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    tensorViewCount: u32 = 0,
    // Length expression: tensorViewCount
    // Extern sync: false
    // Optional: false
    pTensorViews: ?[*]const VkTensorViewARM = null,
};
// Extension: VK_ARM_tensors
// Extends: VkFormatProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkTensorFormatPropertiesARM = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_TENSOR_FORMAT_PROPERTIES_ARM;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    optimalTilingTensorFeatures: VkFormatFeatureFlags2 = .{},
    // Extern sync: false
    // Optional: false
    linearTilingTensorFeatures: VkFormatFeatureFlags2 = .{},
};
// Extension: VK_ARM_tensors
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceTensorPropertiesARM = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TENSOR_PROPERTIES_ARM;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    maxTensorDimensionCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxTensorElements: u64 = 0,
    // Extern sync: false
    // Optional: false
    maxPerDimensionTensorElements: u64 = 0,
    // Extern sync: false
    // Optional: false
    maxTensorStride: i64 = 0,
    // Extern sync: false
    // Optional: false
    maxTensorSize: u64 = 0,
    // Extern sync: false
    // Optional: false
    maxTensorShaderAccessArrayLength: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxTensorShaderAccessSize: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxDescriptorSetStorageTensors: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxPerStageDescriptorSetStorageTensors: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxDescriptorSetUpdateAfterBindStorageTensors: u32 = 0,
    // Extern sync: false
    // Optional: false
    maxPerStageDescriptorUpdateAfterBindStorageTensors: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderStorageTensorArrayNonUniformIndexingNative: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderTensorSupportedStages: VkShaderStageFlags = .{},
};
// Extension: VK_ARM_tensors
// Extends: VkDependencyInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkTensorMemoryBarrierARM = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_TENSOR_MEMORY_BARRIER_ARM;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    srcStageMask: VkPipelineStageFlags2 = .{},
    // Extern sync: false
    // Optional: true
    srcAccessMask: VkAccessFlags2 = .{},
    // Extern sync: false
    // Optional: true
    dstStageMask: VkPipelineStageFlags2 = .{},
    // Extern sync: false
    // Optional: true
    dstAccessMask: VkAccessFlags2 = .{},
    // Extern sync: false
    // Optional: false
    srcQueueFamilyIndex: u32 = 0,
    // Extern sync: false
    // Optional: false
    dstQueueFamilyIndex: u32 = 0,
    // Extern sync: false
    // Optional: false
    tensor: VkTensorARM = .none,
};
// Extension: VK_ARM_tensors
// Extends: VkDependencyInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkTensorDependencyInfoARM = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_TENSOR_DEPENDENCY_INFO_ARM;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    tensorMemoryBarrierCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    pTensorMemoryBarriers: ?*const VkTensorMemoryBarrierARM = null,
};
// Extension: VK_ARM_tensors
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceTensorFeaturesARM = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TENSOR_FEATURES_ARM;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    tensorNonPacked: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderTensorAccess: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderStorageTensorArrayDynamicIndexing: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderStorageTensorArrayNonUniformIndexing: u32 = 0,
    // Extern sync: false
    // Optional: false
    descriptorBindingStorageTensorUpdateAfterBind: u32 = 0,
    // Extern sync: false
    // Optional: false
    tensors: u32 = 0,
};
// Extension: VK_ARM_tensors
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDeviceTensorMemoryRequirementsARM = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_DEVICE_TENSOR_MEMORY_REQUIREMENTS_ARM;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    pCreateInfo: ?*const VkTensorCreateInfoARM = null,
};
// Extension: VK_ARM_tensors
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkCopyTensorInfoARM = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_COPY_TENSOR_INFO_ARM;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    srcTensor: VkTensorARM = .none,
    // Extern sync: false
    // Optional: false
    dstTensor: VkTensorARM = .none,
    // Extern sync: false
    // Optional: false
    regionCount: u32 = 0,
    // Length expression: regionCount
    // Extern sync: false
    // Optional: false
    pRegions: ?[*]const VkTensorCopyARM = null,
};
// Extension: VK_ARM_tensors
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkTensorCopyARM = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_TENSOR_COPY_ARM;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    dimensionCount: u32 = 0,
    // Length expression: dimensionCount
    // Extern sync: false
    // Optional: true
    pSrcOffset: ?[*]const u64 = null,
    // Length expression: dimensionCount
    // Extern sync: false
    // Optional: true
    pDstOffset: ?[*]const u64 = null,
    // Length expression: dimensionCount
    // Extern sync: false
    // Optional: true
    pExtent: ?[*]const u64 = null,
};
// Extension: VK_ARM_tensors
// Extends: VkMemoryAllocateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkMemoryDedicatedAllocateInfoTensorARM = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_TENSOR_ARM;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Comment: Tensor that this allocation will be bound to
    tensor: VkTensorARM = .none,
};
// Extension: VK_ARM_tensors
// Extends: VkPhysicalDeviceProperties2
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceDescriptorBufferTensorPropertiesARM = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_TENSOR_PROPERTIES_ARM;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    tensorCaptureReplayDescriptorDataSize: u64 = 0,
    // Extern sync: false
    // Optional: false
    tensorViewCaptureReplayDescriptorDataSize: u64 = 0,
    // Extern sync: false
    // Optional: false
    tensorDescriptorSize: u64 = 0,
};
// Extension: VK_ARM_tensors
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceDescriptorBufferTensorFeaturesARM = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_TENSOR_FEATURES_ARM;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    descriptorBufferTensorDescriptors: u32 = 0,
};
// Extension: VK_ARM_tensors
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkTensorCaptureDescriptorDataInfoARM = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_TENSOR_CAPTURE_DESCRIPTOR_DATA_INFO_ARM;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    tensor: VkTensorARM = .none,
};
// Extension: VK_ARM_tensors
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkTensorViewCaptureDescriptorDataInfoARM = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_TENSOR_VIEW_CAPTURE_DESCRIPTOR_DATA_INFO_ARM;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    tensorView: VkTensorViewARM = .none,
};
// Extension: VK_ARM_tensors
// Extends: VkDescriptorGetInfoEXT
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDescriptorGetTensorInfoARM = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_DESCRIPTOR_GET_TENSOR_INFO_ARM;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    tensorView: VkTensorViewARM = .none,
};
// Extension: VK_ARM_tensors
// Extends: VkSubmitInfo,VkSubmitInfo2,VkPresentInfoKHR,VkBindSparseInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkFrameBoundaryTensorsARM = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_FRAME_BOUNDARY_TENSORS_ARM;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    tensorCount: u32 = 0,
    // Length expression: tensorCount
    // Extern sync: false
    // Optional: false
    pTensors: ?[*]const VkTensorARM = null,
};
// Extension: VK_ARM_tensors
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceExternalTensorInfoARM = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_TENSOR_INFO_ARM;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkTensorCreateFlagsARM = .{},
    // Extern sync: false
    // Optional: false
    pDescription: ?*const VkTensorDescriptionARM = null,
    // Extern sync: false
    // Optional: false
    handleType: VkExternalMemoryHandleTypeFlags = .{},
};
// Extension: VK_ARM_tensors
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkExternalTensorPropertiesARM = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_EXTERNAL_TENSOR_PROPERTIES_ARM;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    externalMemoryProperties: VkExternalMemoryProperties = .{},
};
// Extension: VK_ARM_tensors
// Extends: VkTensorCreateInfoARM
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkExternalMemoryTensorCreateInfoARM = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_TENSOR_CREATE_INFO_ARM;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    handleTypes: VkExternalMemoryHandleTypeFlags = .{},
};
// Extension: VK_EXT_shader_float8
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceShaderFloat8FeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT8_FEATURES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    shaderFloat8: u32 = 0,
    // Extern sync: false
    // Optional: false
    shaderFloat8CooperativeMatrix: u32 = 0,
};
// Extension: VK_OHOS_surface
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSurfaceCreateInfoOHOS = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_SURFACE_CREATE_INFO_OHOS;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkSurfaceCreateFlagsOHOS = .{},
    // Extern sync: false
    // Optional: false
    window: ?*OHNativeWindow = null,
};
// Extension: VK_ARM_data_graph
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceDataGraphFeaturesARM = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DATA_GRAPH_FEATURES_ARM;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    dataGraph: u32 = 0,
    // Extern sync: false
    // Optional: false
    dataGraphUpdateAfterBind: u32 = 0,
    // Extern sync: false
    // Optional: false
    dataGraphSpecializationConstants: u32 = 0,
    // Extern sync: false
    // Optional: false
    dataGraphDescriptorBuffer: u32 = 0,
    // Extern sync: false
    // Optional: false
    dataGraphShaderModule: u32 = 0,
};
// Extension: VK_ARM_data_graph
// Extends: VkDataGraphPipelineConstantARM
// Returned only: false
// Allow duplicate in pNext chain: true
pub const VkDataGraphPipelineConstantTensorSemiStructuredSparsityInfoARM = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_CONSTANT_TENSOR_SEMI_STRUCTURED_SPARSITY_INFO_ARM;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    dimension: u32 = 0,
    // Extern sync: false
    // Optional: false
    zeroCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    groupSize: u32 = 0,
};
// Extension: VK_ARM_data_graph
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDataGraphPipelineConstantARM = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_CONSTANT_ARM;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    id: u32 = 0,
    // Extern sync: false
    // Optional: false
    pConstantData: ?*const anyopaque = null,
};
// Extension: VK_ARM_data_graph
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDataGraphPipelineResourceInfoARM = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_RESOURCE_INFO_ARM;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    descriptorSet: u32 = 0,
    // Extern sync: false
    // Optional: false
    binding: u32 = 0,
    // Extern sync: false
    // Optional: true
    arrayElement: u32 = 0,
};
// Extension: VK_ARM_data_graph
// Extends: VkDataGraphPipelineCreateInfoARM
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDataGraphPipelineCompilerControlCreateInfoARM = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_COMPILER_CONTROL_CREATE_INFO_ARM;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Length expression: null-terminated
    // Extern sync: false
    // Optional: false
    pVendorOptions: ?[*:0]const u8 = null,
};
// Extension: VK_ARM_data_graph
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDataGraphPipelineCreateInfoARM = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_CREATE_INFO_ARM;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    // Extern sync: false
    // Optional: false
    layout: VkPipelineLayout = .none,
    // Extern sync: false
    // Optional: false
    resourceInfoCount: u32 = 0,
    // Length expression: resourceInfoCount
    // Extern sync: false
    // Optional: false
    pResourceInfos: ?[*]const VkDataGraphPipelineResourceInfoARM = null,
};
// Extension: VK_ARM_data_graph
// Extends: VkDataGraphPipelineCreateInfoARM
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDataGraphPipelineShaderModuleCreateInfoARM = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SHADER_MODULE_CREATE_INFO_ARM;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    module: VkShaderModule = .none,
    // Length expression: null-terminated
    // Extern sync: false
    // Optional: false
    pName: ?[*:0]const u8 = null,
    // Extern sync: false
    // Optional: true
    pSpecializationInfo: ?*const VkSpecializationInfo = null,
    // Extern sync: false
    // Optional: true
    constantCount: u32 = 0,
    // Length expression: constantCount
    // Extern sync: false
    // Optional: true
    pConstants: ?[*]const VkDataGraphPipelineConstantARM = null,
};
// Extension: VK_ARM_data_graph
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDataGraphPipelineSessionCreateInfoARM = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_CREATE_INFO_ARM;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkDataGraphPipelineSessionCreateFlagsARM = .{},
    // Extern sync: false
    // Optional: false
    dataGraphPipeline: VkPipeline = .none,
};
// Extension: VK_ARM_data_graph
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDataGraphPipelineSessionBindPointRequirementsInfoARM = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_REQUIREMENTS_INFO_ARM;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    session: VkDataGraphPipelineSessionARM = .none,
};
// Extension: VK_ARM_data_graph
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDataGraphPipelineSessionBindPointRequirementARM = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_REQUIREMENT_ARM;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    bindPoint: VkDataGraphPipelineSessionBindPointARM = .VK_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_TRANSIENT_ARM,
    // Extern sync: false
    // Optional: false
    bindPointType: VkDataGraphPipelineSessionBindPointTypeARM = .VK_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_TYPE_MEMORY_ARM,
    // Extern sync: false
    // Optional: false
    numObjects: u32 = 0,
};
// Extension: VK_ARM_data_graph
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDataGraphPipelineSessionMemoryRequirementsInfoARM = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_MEMORY_REQUIREMENTS_INFO_ARM;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    session: VkDataGraphPipelineSessionARM = .none,
    // Extern sync: false
    // Optional: false
    bindPoint: VkDataGraphPipelineSessionBindPointARM = .VK_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_TRANSIENT_ARM,
    // Extern sync: false
    // Optional: false
    objectIndex: u32 = 0,
};
// Extension: VK_ARM_data_graph
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkBindDataGraphPipelineSessionMemoryInfoARM = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_BIND_DATA_GRAPH_PIPELINE_SESSION_MEMORY_INFO_ARM;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    session: VkDataGraphPipelineSessionARM = .none,
    // Extern sync: false
    // Optional: false
    bindPoint: VkDataGraphPipelineSessionBindPointARM = .VK_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_TRANSIENT_ARM,
    // Extern sync: false
    // Optional: false
    objectIndex: u32 = 0,
    // Extern sync: false
    // Optional: false
    memory: VkDeviceMemory = .none,
    // Extern sync: false
    // Optional: false
    memoryOffset: u64 = 0,
};
// Extension: VK_ARM_data_graph
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDataGraphPipelineInfoARM = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_INFO_ARM;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    dataGraphPipeline: VkPipeline = .none,
};
// Extension: VK_ARM_data_graph
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDataGraphPipelinePropertyQueryResultARM = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_PROPERTY_QUERY_RESULT_ARM;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    property: VkDataGraphPipelinePropertyARM = .VK_DATA_GRAPH_PIPELINE_PROPERTY_CREATION_LOG_ARM,
    // Extern sync: false
    // Optional: false
    isText: u32 = 0,
    // Extern sync: false
    // Optional: true
    dataSize: u64 = 0,
    // Length expression: dataSize
    // Extern sync: false
    // Optional: true
    pData: ?*anyopaque = null,
};
// Extension: VK_ARM_data_graph
// Extends: VkDataGraphPipelineCreateInfoARM
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDataGraphPipelineIdentifierCreateInfoARM = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_IDENTIFIER_CREATE_INFO_ARM;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    identifierSize: u32 = 0,
    // Length expression: identifierSize
    // Extern sync: false
    // Optional: false
    pIdentifier: ?[*]const u8 = null,
};
// Extension: VK_ARM_data_graph
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDataGraphPipelineDispatchInfoARM = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_DISPATCH_INFO_ARM;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkDataGraphPipelineDispatchFlagsARM = .{},
};
// Extension: VK_ARM_data_graph
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceDataGraphProcessingEngineARM = extern struct {
    // Extern sync: false
    // Optional: false
    type: VkPhysicalDeviceDataGraphProcessingEngineTypeARM = .VK_PHYSICAL_DEVICE_DATA_GRAPH_PROCESSING_ENGINE_TYPE_DEFAULT_ARM,
    // Extern sync: false
    // Optional: false
    isForeign: u32 = 0,
};
// Extension: VK_ARM_data_graph
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceDataGraphOperationSupportARM = extern struct {
    // Extern sync: false
    // Optional: false
    operationType: VkPhysicalDeviceDataGraphOperationTypeARM = .VK_PHYSICAL_DEVICE_DATA_GRAPH_OPERATION_TYPE_SPIRV_EXTENDED_INSTRUCTION_SET_ARM,
    // Length expression: null-terminated
    // Extern sync: false
    // Optional: false
    name: [VK_MAX_PHYSICAL_DEVICE_DATA_GRAPH_OPERATION_SET_NAME_SIZE_ARM]u8 = @import("std").mem.zeroes([VK_MAX_PHYSICAL_DEVICE_DATA_GRAPH_OPERATION_SET_NAME_SIZE_ARM]u8),
    // Extern sync: false
    // Optional: false
    version: u32 = 0,
};
// Extension: VK_ARM_data_graph
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkQueueFamilyDataGraphPropertiesARM = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_QUEUE_FAMILY_DATA_GRAPH_PROPERTIES_ARM;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    engine: VkPhysicalDeviceDataGraphProcessingEngineARM = .{},
    // Extern sync: false
    // Optional: false
    operation: VkPhysicalDeviceDataGraphOperationSupportARM = .{},
};
// Extension: VK_ARM_data_graph
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARM = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_QUEUE_FAMILY_DATA_GRAPH_PROCESSING_ENGINE_INFO_ARM;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    queueFamilyIndex: u32 = 0,
    // Extern sync: false
    // Optional: false
    engineType: VkPhysicalDeviceDataGraphProcessingEngineTypeARM = .VK_PHYSICAL_DEVICE_DATA_GRAPH_PROCESSING_ENGINE_TYPE_DEFAULT_ARM,
};
// Extension: VK_ARM_data_graph
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkQueueFamilyDataGraphProcessingEnginePropertiesARM = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_QUEUE_FAMILY_DATA_GRAPH_PROCESSING_ENGINE_PROPERTIES_ARM;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    foreignSemaphoreHandleTypes: VkExternalSemaphoreHandleTypeFlags = .{},
    // Extern sync: false
    // Optional: false
    foreignMemoryHandleTypes: VkExternalMemoryHandleTypeFlags = .{},
};
// Extension: VK_ARM_data_graph
// Extends: VkDataGraphPipelineCreateInfoARM,VkDescriptorPoolCreateInfo,VkCommandPoolCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDataGraphProcessingEngineCreateInfoARM = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_DATA_GRAPH_PROCESSING_ENGINE_CREATE_INFO_ARM;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    processingEngineCount: u32 = 0,
    // Length expression: processingEngineCount
    // Extern sync: false
    // Optional: false
    pProcessingEngines: ?[*]VkPhysicalDeviceDataGraphProcessingEngineARM = null,
};
// Extension: VK_SEC_pipeline_cache_incremental_mode
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDevicePipelineCacheIncrementalModeFeaturesSEC = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CACHE_INCREMENTAL_MODE_FEATURES_SEC;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    pipelineCacheIncrementalMode: u32 = 0,
};
// Extension: VK_QCOM_data_graph_model
// Extends: VkDataGraphPipelineCreateInfoARM
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkDataGraphPipelineBuiltinModelCreateInfoQCOM = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_BUILTIN_MODEL_CREATE_INFO_QCOM;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    pOperation: ?*const VkPhysicalDeviceDataGraphOperationSupportARM = null,
};
// Extension: VK_QCOM_data_graph_model
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceDataGraphModelFeaturesQCOM = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DATA_GRAPH_MODEL_FEATURES_QCOM;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    // Feature link: dataGraphModelQCOM
    dataGraphModel: u32 = 0,
};
// Extension: VK_KHR_shader_untyped_pointers
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceShaderUntypedPointersFeaturesKHR = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_UNTYPED_POINTERS_FEATURES_KHR;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    shaderUntypedPointers: u32 = 0,
};
// Extension: VK_OHOS_native_buffer
// Extends: VkImageCreateInfo,VkBindImageMemoryInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkNativeBufferOHOS = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_NATIVE_BUFFER_OHOS;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    handle: ?*OHBufferHandle = null,
};
// Extension: VK_OHOS_native_buffer
// Extends: VkImageCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkSwapchainImageCreateInfoOHOS = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_SWAPCHAIN_IMAGE_CREATE_INFO_OHOS;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    usage: VkSwapchainImageUsageFlagsOHOS = .{},
};
// Extension: VK_OHOS_native_buffer
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDevicePresentationPropertiesOHOS = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENTATION_PROPERTIES_OHOS;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    sharedImage: u32 = 0,
};
// Extension: VK_VALVE_video_encode_rgb_conversion
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceVideoEncodeRgbConversionFeaturesVALVE = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_RGB_CONVERSION_FEATURES_VALVE;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    videoEncodeRgbConversion: u32 = 0,
};
// Extension: VK_VALVE_video_encode_rgb_conversion
// Extends: VkVideoCapabilitiesKHR
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeRgbConversionCapabilitiesVALVE = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_RGB_CONVERSION_CAPABILITIES_VALVE;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    rgbModels: VkVideoEncodeRgbModelConversionFlagsVALVE = .{},
    // Extern sync: false
    // Optional: false
    rgbRanges: VkVideoEncodeRgbRangeCompressionFlagsVALVE = .{},
    // Extern sync: false
    // Optional: false
    xChromaOffsets: VkVideoEncodeRgbChromaOffsetFlagsVALVE = .{},
    // Extern sync: false
    // Optional: false
    yChromaOffsets: VkVideoEncodeRgbChromaOffsetFlagsVALVE = .{},
};
// Extension: VK_VALVE_video_encode_rgb_conversion
// Extends: VkVideoProfileInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeProfileRgbConversionInfoVALVE = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_PROFILE_RGB_CONVERSION_INFO_VALVE;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    performEncodeRgbConversion: u32 = 0,
};
// Extension: VK_VALVE_video_encode_rgb_conversion
// Extends: VkVideoSessionCreateInfoKHR
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkVideoEncodeSessionRgbConversionCreateInfoVALVE = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_RGB_CONVERSION_CREATE_INFO_VALVE;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    rgbModel: VkVideoEncodeRgbModelConversionFlagsVALVE = .{},
    // Extern sync: false
    // Optional: false
    rgbRange: VkVideoEncodeRgbRangeCompressionFlagsVALVE = .{},
    // Extern sync: false
    // Optional: false
    xChromaOffset: VkVideoEncodeRgbChromaOffsetFlagsVALVE = .{},
    // Extern sync: false
    // Optional: false
    yChromaOffset: VkVideoEncodeRgbChromaOffsetFlagsVALVE = .{},
};
// Extension: VK_EXT_shader_64bit_indexing
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceShader64BitIndexingFeaturesEXT = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_64_BIT_INDEXING_FEATURES_EXT;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    shader64BitIndexing: u32 = 0,
};
// Extension: VK_OHOS_external_memory
// Extends: VkImageFormatProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkNativeBufferUsageOHOS = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_NATIVE_BUFFER_USAGE_OHOS;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    OHOSNativeBufferUsage: u64 = 0,
};
// Extension: VK_OHOS_external_memory
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkNativeBufferPropertiesOHOS = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_NATIVE_BUFFER_PROPERTIES_OHOS;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    allocationSize: u64 = 0,
    // Extern sync: false
    // Optional: false
    memoryTypeBits: u32 = 0,
};
// Extension: VK_OHOS_external_memory
// Extends: VkNativeBufferPropertiesOHOS
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkNativeBufferFormatPropertiesOHOS = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_NATIVE_BUFFER_FORMAT_PROPERTIES_OHOS;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    format: VkFormat = .VK_FORMAT_UNDEFINED,
    // Extern sync: false
    // Optional: false
    externalFormat: u64 = 0,
    // Extern sync: false
    // Optional: false
    formatFeatures: VkFormatFeatureFlags = .{},
    // Extern sync: false
    // Optional: false
    samplerYcbcrConversionComponents: VkComponentMapping = .{},
    // Extern sync: false
    // Optional: false
    suggestedYcbcrModel: VkSamplerYcbcrModelConversion = .VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY,
    // Extern sync: false
    // Optional: false
    suggestedYcbcrRange: VkSamplerYcbcrRange = .VK_SAMPLER_YCBCR_RANGE_ITU_FULL,
    // Extern sync: false
    // Optional: false
    suggestedXChromaOffset: VkChromaLocation = .VK_CHROMA_LOCATION_COSITED_EVEN,
    // Extern sync: false
    // Optional: false
    suggestedYChromaOffset: VkChromaLocation = .VK_CHROMA_LOCATION_COSITED_EVEN,
};
// Extension: VK_OHOS_external_memory
// Extends: VkMemoryAllocateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkImportNativeBufferInfoOHOS = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_IMPORT_NATIVE_BUFFER_INFO_OHOS;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    buffer: ?*OH_NativeBuffer = null,
};
// Extension: VK_OHOS_external_memory
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkMemoryGetNativeBufferInfoOHOS = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_MEMORY_GET_NATIVE_BUFFER_INFO_OHOS;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    memory: VkDeviceMemory = .none,
};
// Extension: VK_OHOS_external_memory
// Extends: VkImageCreateInfo,VkSamplerYcbcrConversionCreateInfo,VkAttachmentDescription2,VkGraphicsPipelineCreateInfo,VkCommandBufferInheritanceInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkExternalFormatOHOS = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_OHOS;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    externalFormat: u64 = 0,
};
// Extension: VK_ARM_performance_counters_by_region
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDevicePerformanceCountersByRegionFeaturesARM = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_COUNTERS_BY_REGION_FEATURES_ARM;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    performanceCountersByRegion: u32 = 0,
};
// Extension: VK_ARM_performance_counters_by_region
// Extends: VkPhysicalDeviceProperties2
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPhysicalDevicePerformanceCountersByRegionPropertiesARM = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_COUNTERS_BY_REGION_PROPERTIES_ARM;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    maxPerRegionPerformanceCounters: u32 = 0,
    // Extern sync: false
    // Optional: false
    performanceCounterRegionSize: VkExtent2D = .{},
    // Extern sync: false
    // Optional: false
    rowStrideAlignment: u32 = 0,
    // Extern sync: false
    // Optional: false
    regionAlignment: u32 = 0,
    // Extern sync: false
    // Optional: false
    identityTransformOrder: u32 = 0,
};
// Extension: VK_ARM_performance_counters_by_region
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPerformanceCounterARM = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_ARM;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    counterID: u32 = 0,
};
// Extension: VK_ARM_performance_counters_by_region
// Returned only: true
// Allow duplicate in pNext chain: false
pub const VkPerformanceCounterDescriptionARM = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_DESCRIPTION_ARM;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: true
    flags: VkPerformanceCounterDescriptionFlagsARM = .{},
    // Length expression: null-terminated
    // Extern sync: false
    // Optional: false
    name: [VK_MAX_DESCRIPTION_SIZE]u8 = @import("std").mem.zeroes([VK_MAX_DESCRIPTION_SIZE]u8),
};
// Extension: VK_ARM_performance_counters_by_region
// Extends: VkRenderPassBeginInfo,VkRenderingInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkRenderPassPerformanceCountersByRegionBeginInfoARM = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_RENDER_PASS_PERFORMANCE_COUNTERS_BY_REGION_BEGIN_INFO_ARM;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    // Comment: Pointer to next structure
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    counterAddressCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    pCounterAddresses: ?*const u64 = null,
    // Extern sync: false
    // Optional: false
    serializeRegions: u32 = 0,
    // Extern sync: false
    // Optional: false
    counterIndexCount: u32 = 0,
    // Extern sync: false
    // Optional: false
    pCounterIndices: ?*u32 = null,
};
// Extension: VK_NV_compute_occupancy_priority
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkComputeOccupancyPriorityParametersNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_COMPUTE_OCCUPANCY_PRIORITY_PARAMETERS_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*const anyopaque = null,
    // Extern sync: false
    // Optional: false
    occupancyPriority: f32 = 0,
    // Extern sync: false
    // Optional: false
    occupancyThrottling: f32 = 0,
};
// Extension: VK_NV_compute_occupancy_priority
// Extends: VkPhysicalDeviceFeatures2,VkDeviceCreateInfo
// Returned only: false
// Allow duplicate in pNext chain: false
pub const VkPhysicalDeviceComputeOccupancyPriorityFeaturesNV = extern struct {
    // Extern sync: false
    // Optional: false
    pub const STYPE = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_OCCUPANCY_PRIORITY_FEATURES_NV;
    sType: VkStructureType = @This().STYPE,
    // Extern sync: false
    // Optional: true
    pNext: ?*anyopaque = null,
    // Extern sync: false
    // Optional: false
    computeOccupancyPriority: u32 = 0,
};

// Unions
// Extension: VK_COMPUTE_VERSION_1_0
// Comment: // Union allowing specification of floating-point, integer, or unsigned integer color data. Actual value selected is based on image/attachment being cleared.
pub const VkClearColorValue = extern union {
    float32: [4]f32,
    int32: [4]i32,
    uint32: [4]u32,
};
// Extension: VK_GRAPHICS_VERSION_1_0
// Comment: // Union allowing specification of color or depth and stencil values. Actual value selected is based on attachment being cleared.
pub const VkClearValue = extern union {
    color: VkClearColorValue,
    depthStencil: VkClearDepthStencilValue,
};
// Extension: VK_NV_cluster_acceleration_structure
pub const VkClusterAccelerationStructureOpInputNV = extern union {
    // Selected with: VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_BUILD_CLUSTERS_BOTTOM_LEVEL_NV
    pClustersBottomLevel: *VkClusterAccelerationStructureClustersBottomLevelInputNV,
    // Selected with: VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_BUILD_TRIANGLE_CLUSTER_NV,VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_BUILD_TRIANGLE_CLUSTER_TEMPLATE_NV,VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_INSTANTIATE_TRIANGLE_CLUSTER_NV,VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_GET_CLUSTER_TEMPLATE_INDICES_NV
    pTriangleClusters: *VkClusterAccelerationStructureTriangleClusterInputNV,
    // Selected with: VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_MOVE_OBJECTS_NV
    pMoveObjects: *VkClusterAccelerationStructureMoveObjectsInputNV,
};
// Extension: VK_KHR_performance_query
// Comment: // Union of all the possible return types a counter result could return
pub const VkPerformanceCounterResultKHR = extern union {
    int32: i32,
    int64: i64,
    uint32: u32,
    uint64: u64,
    float32: f32,
    float64: f64,
};
// Extension: VK_INTEL_performance_query
pub const VkPerformanceValueDataINTEL = extern union {
    // Selected with: VK_PERFORMANCE_VALUE_TYPE_UINT32_INTEL
    value32: u32,
    // Selected with: VK_PERFORMANCE_VALUE_TYPE_UINT64_INTEL
    value64: u64,
    // Selected with: VK_PERFORMANCE_VALUE_TYPE_FLOAT_INTEL
    valueFloat: f32,
    // Selected with: VK_PERFORMANCE_VALUE_TYPE_BOOL_INTEL
    valueBool: u32,
    // Selected with: VK_PERFORMANCE_VALUE_TYPE_STRING_INTEL
    // Length expression: null-terminated
    valueString: *const u8,
};
// Extension: VK_KHR_pipeline_executable_properties
pub const VkPipelineExecutableStatisticValueKHR = extern union {
    // Selected with: VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_BOOL32_KHR
    b32: u32,
    // Selected with: VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_INT64_KHR
    i64: i64,
    // Selected with: VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_UINT64_KHR
    u64: u64,
    // Selected with: VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_FLOAT64_KHR
    f64: f64,
};
// Extension: VK_KHR_acceleration_structure
// Extension: VK_NV_cooperative_vector
pub const VkDeviceOrHostAddressKHR = extern union {
    deviceAddress: u64,
    hostAddress: *anyopaque,
};
// Extension: VK_KHR_acceleration_structure
// Extension: VK_NV_cooperative_vector
pub const VkDeviceOrHostAddressConstKHR = extern union {
    deviceAddress: u64,
    hostAddress: *const anyopaque,
};
// Extension: VK_AMDX_shader_enqueue
pub const VkDeviceOrHostAddressConstAMDX = extern union {
    deviceAddress: u64,
    hostAddress: *const anyopaque,
};
// Extension: VK_KHR_acceleration_structure
pub const VkAccelerationStructureGeometryDataKHR = extern union {
    // Selected with: VK_GEOMETRY_TYPE_TRIANGLES_KHR
    triangles: VkAccelerationStructureGeometryTrianglesDataKHR,
    // Selected with: VK_GEOMETRY_TYPE_AABBS_KHR
    aabbs: VkAccelerationStructureGeometryAabbsDataKHR,
    // Selected with: VK_GEOMETRY_TYPE_INSTANCES_KHR
    instances: VkAccelerationStructureGeometryInstancesDataKHR,
};
// Extension: VK_EXT_device_generated_commands
pub const VkIndirectExecutionSetInfoEXT = extern union {
    // Selected with: VK_INDIRECT_EXECUTION_SET_INFO_TYPE_PIPELINES_EXT
    pPipelineInfo: *const VkIndirectExecutionSetPipelineInfoEXT,
    // Selected with: VK_INDIRECT_EXECUTION_SET_INFO_TYPE_SHADER_OBJECTS_EXT
    pShaderInfo: *const VkIndirectExecutionSetShaderInfoEXT,
};
// Extension: VK_EXT_device_generated_commands
pub const VkIndirectCommandsTokenDataEXT = extern union {
    // Selected with: VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_EXT,VK_INDIRECT_COMMANDS_TOKEN_TYPE_SEQUENCE_INDEX_EXT
    pPushConstant: *const VkIndirectCommandsPushConstantTokenEXT,
    // Selected with: VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_EXT
    pVertexBuffer: *const VkIndirectCommandsVertexBufferTokenEXT,
    // Selected with: VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_EXT
    pIndexBuffer: *const VkIndirectCommandsIndexBufferTokenEXT,
    // Selected with: VK_INDIRECT_COMMANDS_TOKEN_TYPE_EXECUTION_SET_EXT
    pExecutionSet: *const VkIndirectCommandsExecutionSetTokenEXT,
};
// Extension: VK_EXT_descriptor_buffer
pub const VkDescriptorDataEXT = extern union {
    // Selected with: VK_DESCRIPTOR_TYPE_SAMPLER
    pSampler: *const VkSampler,
    // Selected with: VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER
    pCombinedImageSampler: *const VkDescriptorImageInfo,
    // Selected with: VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT
    pInputAttachmentImage: *const VkDescriptorImageInfo,
    // Selected with: VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE
    pSampledImage: *const VkDescriptorImageInfo,
    // Selected with: VK_DESCRIPTOR_TYPE_STORAGE_IMAGE
    pStorageImage: *const VkDescriptorImageInfo,
    // Selected with: VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER
    pUniformTexelBuffer: *const VkDescriptorAddressInfoEXT,
    // Selected with: VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER
    pStorageTexelBuffer: *const VkDescriptorAddressInfoEXT,
    // Selected with: VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER
    pUniformBuffer: *const VkDescriptorAddressInfoEXT,
    // Selected with: VK_DESCRIPTOR_TYPE_STORAGE_BUFFER
    pStorageBuffer: *const VkDescriptorAddressInfoEXT,
    // Selected with: VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR,VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV
    accelerationStructure: u64,
};
// Extension: VK_NV_ray_tracing_motion_blur
pub const VkAccelerationStructureMotionInstanceDataNV = extern union {
    // Selected with: VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_STATIC_NV
    staticInstance: VkAccelerationStructureInstanceKHR,
    // Selected with: VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_MATRIX_MOTION_NV
    matrixMotionInstance: VkAccelerationStructureMatrixMotionInstanceNV,
    // Selected with: VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_SRT_MOTION_NV
    srtMotionInstance: VkAccelerationStructureSRTMotionInstanceNV,
};

// Commands
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_LAYER_NOT_PRESENT,VK_ERROR_EXTENSION_NOT_PRESENT,VK_ERROR_INCOMPATIBLE_DRIVER,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateInstance = fn (
    pCreateInfo: *const VkInstanceCreateInfo,
    pAllocator: ?*const VkAllocationCallbacks,
    pInstance: *VkInstance,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkDestroyInstance = fn (
    instance: VkInstance,
    pAllocator: ?*const VkAllocationCallbacks,
) callconv(.c) void;
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkEnumeratePhysicalDevices = fn (
    instance: VkInstance,
    pPhysicalDeviceCount: *u32,
    // Length expression: pPhysicalDeviceCount
    pPhysicalDevices: ?[*]VkPhysicalDevice,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkGetDeviceProcAddr = fn (
    device: VkDevice,
    // Length expression: null-terminated
    pName: [*:0]const u8,
) callconv(.c) ?*const vkVoidFunction;
// Can be used without queues: false
pub const vkGetInstanceProcAddr = fn (
    instance: VkInstance,
    // Length expression: null-terminated
    pName: [*:0]const u8,
) callconv(.c) ?*const vkVoidFunction;
// Can be used without queues: false
pub const vkGetPhysicalDeviceProperties = fn (
    physicalDevice: VkPhysicalDevice,
    pProperties: *VkPhysicalDeviceProperties,
) callconv(.c) void;
// Can be used without queues: false
pub const vkGetPhysicalDeviceQueueFamilyProperties = fn (
    physicalDevice: VkPhysicalDevice,
    pQueueFamilyPropertyCount: *u32,
    // Length expression: pQueueFamilyPropertyCount
    pQueueFamilyProperties: ?[*]VkQueueFamilyProperties,
) callconv(.c) void;
// Can be used without queues: false
pub const vkGetPhysicalDeviceMemoryProperties = fn (
    physicalDevice: VkPhysicalDevice,
    pMemoryProperties: *VkPhysicalDeviceMemoryProperties,
) callconv(.c) void;
// Can be used without queues: false
pub const vkGetPhysicalDeviceFeatures = fn (
    physicalDevice: VkPhysicalDevice,
    pFeatures: *VkPhysicalDeviceFeatures,
) callconv(.c) void;
// Can be used without queues: false
pub const vkGetPhysicalDeviceFormatProperties = fn (
    physicalDevice: VkPhysicalDevice,
    format: VkFormat,
    pFormatProperties: *VkFormatProperties,
) callconv(.c) void;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_FORMAT_NOT_SUPPORTED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetPhysicalDeviceImageFormatProperties = fn (
    physicalDevice: VkPhysicalDevice,
    format: VkFormat,
    type: VkImageType,
    tiling: VkImageTiling,
    usage: VkImageUsageFlags,
    flags: VkImageCreateFlags,
    pImageFormatProperties: *VkImageFormatProperties,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_EXTENSION_NOT_PRESENT,VK_ERROR_FEATURE_NOT_PRESENT,VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_DEVICE_LOST,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateDevice = fn (
    physicalDevice: VkPhysicalDevice,
    pCreateInfo: *const VkDeviceCreateInfo,
    pAllocator: ?*const VkAllocationCallbacks,
    pDevice: *VkDevice,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkDestroyDevice = fn (
    device: VkDevice,
    pAllocator: ?*const VkAllocationCallbacks,
) callconv(.c) void;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkEnumerateInstanceVersion = fn (
    pApiVersion: *u32,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkEnumerateInstanceLayerProperties = fn (
    pPropertyCount: *u32,
    // Length expression: pPropertyCount
    pProperties: ?[*]VkLayerProperties,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_LAYER_NOT_PRESENT,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkEnumerateInstanceExtensionProperties = fn (
    // Length expression: null-terminated
    pLayerName: ?[*:0]const u8,
    pPropertyCount: *u32,
    // Length expression: pPropertyCount
    pProperties: ?[*]VkExtensionProperties,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkEnumerateDeviceLayerProperties = fn (
    physicalDevice: VkPhysicalDevice,
    pPropertyCount: *u32,
    // Length expression: pPropertyCount
    pProperties: ?[*]VkLayerProperties,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_LAYER_NOT_PRESENT,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkEnumerateDeviceExtensionProperties = fn (
    physicalDevice: VkPhysicalDevice,
    // Length expression: null-terminated
    pLayerName: ?[*:0]const u8,
    pPropertyCount: *u32,
    // Length expression: pPropertyCount
    pProperties: ?[*]VkExtensionProperties,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkGetDeviceQueue = fn (
    device: VkDevice,
    queueFamilyIndex: u32,
    queueIndex: u32,
    pQueue: *VkQueue,
) callconv(.c) void;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkQueueSubmit = fn (
    queue: VkQueue,
    submitCount: u32,
    // Length expression: submitCount
    pSubmits: [*]const VkSubmitInfo,
    fence: VkFence,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkQueueWaitIdle = fn (
    queue: VkQueue,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkDeviceWaitIdle = fn (
    device: VkDevice,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INVALID_EXTERNAL_HANDLE,VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkAllocateMemory = fn (
    device: VkDevice,
    pAllocateInfo: *const VkMemoryAllocateInfo,
    pAllocator: ?*const VkAllocationCallbacks,
    pMemory: *VkDeviceMemory,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkFreeMemory = fn (
    device: VkDevice,
    memory: VkDeviceMemory,
    pAllocator: ?*const VkAllocationCallbacks,
) callconv(.c) void;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_MEMORY_MAP_FAILED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkMapMemory = fn (
    device: VkDevice,
    memory: VkDeviceMemory,
    offset: u64,
    size: u64,
    flags: VkMemoryMapFlags,
    ppData: **anyopaque,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkUnmapMemory = fn (
    device: VkDevice,
    memory: VkDeviceMemory,
) callconv(.c) void;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkFlushMappedMemoryRanges = fn (
    device: VkDevice,
    memoryRangeCount: u32,
    // Length expression: memoryRangeCount
    pMemoryRanges: [*]const VkMappedMemoryRange,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkInvalidateMappedMemoryRanges = fn (
    device: VkDevice,
    memoryRangeCount: u32,
    // Length expression: memoryRangeCount
    pMemoryRanges: [*]const VkMappedMemoryRange,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkGetDeviceMemoryCommitment = fn (
    device: VkDevice,
    memory: VkDeviceMemory,
    pCommittedMemoryInBytes: *u64,
) callconv(.c) void;
// Can be used without queues: false
pub const vkGetBufferMemoryRequirements = fn (
    device: VkDevice,
    buffer: VkBuffer,
    pMemoryRequirements: *VkMemoryRequirements,
) callconv(.c) void;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkBindBufferMemory = fn (
    device: VkDevice,
    buffer: VkBuffer,
    memory: VkDeviceMemory,
    memoryOffset: u64,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkGetImageMemoryRequirements = fn (
    device: VkDevice,
    image: VkImage,
    pMemoryRequirements: *VkMemoryRequirements,
) callconv(.c) void;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkBindImageMemory = fn (
    device: VkDevice,
    image: VkImage,
    memory: VkDeviceMemory,
    memoryOffset: u64,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkGetImageSparseMemoryRequirements = fn (
    device: VkDevice,
    image: VkImage,
    pSparseMemoryRequirementCount: *u32,
    // Length expression: pSparseMemoryRequirementCount
    pSparseMemoryRequirements: ?[*]VkSparseImageMemoryRequirements,
) callconv(.c) void;
// Can be used without queues: false
pub const vkGetPhysicalDeviceSparseImageFormatProperties = fn (
    physicalDevice: VkPhysicalDevice,
    format: VkFormat,
    type: VkImageType,
    samples: VkSampleCountFlags,
    usage: VkImageUsageFlags,
    tiling: VkImageTiling,
    pPropertyCount: *u32,
    // Length expression: pPropertyCount
    pProperties: ?[*]VkSparseImageFormatProperties,
) callconv(.c) void;
// Queues: VK_QUEUE_SPARSE_BINDING_BIT
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkQueueBindSparse = fn (
    queue: VkQueue,
    bindInfoCount: u32,
    // Length expression: bindInfoCount
    pBindInfo: [*]const VkBindSparseInfo,
    fence: VkFence,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateFence = fn (
    device: VkDevice,
    pCreateInfo: *const VkFenceCreateInfo,
    pAllocator: ?*const VkAllocationCallbacks,
    pFence: *VkFence,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkDestroyFence = fn (
    device: VkDevice,
    fence: VkFence,
    pAllocator: ?*const VkAllocationCallbacks,
) callconv(.c) void;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkResetFences = fn (
    device: VkDevice,
    fenceCount: u32,
    // Length expression: fenceCount
    pFences: [*]const VkFence,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS,VK_NOT_READY
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetFenceStatus = fn (
    device: VkDevice,
    fence: VkFence,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS,VK_TIMEOUT
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkWaitForFences = fn (
    device: VkDevice,
    fenceCount: u32,
    // Length expression: fenceCount
    pFences: [*]const VkFence,
    waitAll: u32,
    timeout: u64,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateSemaphore = fn (
    device: VkDevice,
    pCreateInfo: *const VkSemaphoreCreateInfo,
    pAllocator: ?*const VkAllocationCallbacks,
    pSemaphore: *VkSemaphore,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkDestroySemaphore = fn (
    device: VkDevice,
    semaphore: VkSemaphore,
    pAllocator: ?*const VkAllocationCallbacks,
) callconv(.c) void;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateEvent = fn (
    device: VkDevice,
    pCreateInfo: *const VkEventCreateInfo,
    pAllocator: ?*const VkAllocationCallbacks,
    pEvent: *VkEvent,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkDestroyEvent = fn (
    device: VkDevice,
    event: VkEvent,
    pAllocator: ?*const VkAllocationCallbacks,
) callconv(.c) void;
// Success codes: VK_EVENT_SET,VK_EVENT_RESET
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetEventStatus = fn (
    device: VkDevice,
    event: VkEvent,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkSetEvent = fn (
    device: VkDevice,
    event: VkEvent,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkResetEvent = fn (
    device: VkDevice,
    event: VkEvent,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateQueryPool = fn (
    device: VkDevice,
    pCreateInfo: *const VkQueryPoolCreateInfo,
    pAllocator: ?*const VkAllocationCallbacks,
    pQueryPool: *VkQueryPool,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkDestroyQueryPool = fn (
    device: VkDevice,
    queryPool: VkQueryPool,
    pAllocator: ?*const VkAllocationCallbacks,
) callconv(.c) void;
// Success codes: VK_SUCCESS,VK_NOT_READY
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetQueryPoolResults = fn (
    device: VkDevice,
    queryPool: VkQueryPool,
    firstQuery: u32,
    queryCount: u32,
    dataSize: u64,
    // Length expression: dataSize
    pData: *anyopaque,
    stride: u64,
    flags: VkQueryResultFlags,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkResetQueryPool = fn (
    device: VkDevice,
    queryPool: VkQueryPool,
    firstQuery: u32,
    queryCount: u32,
) callconv(.c) void;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateBuffer = fn (
    device: VkDevice,
    pCreateInfo: *const VkBufferCreateInfo,
    pAllocator: ?*const VkAllocationCallbacks,
    pBuffer: *VkBuffer,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkDestroyBuffer = fn (
    device: VkDevice,
    buffer: VkBuffer,
    pAllocator: ?*const VkAllocationCallbacks,
) callconv(.c) void;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateBufferView = fn (
    device: VkDevice,
    pCreateInfo: *const VkBufferViewCreateInfo,
    pAllocator: ?*const VkAllocationCallbacks,
    pView: *VkBufferView,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkDestroyBufferView = fn (
    device: VkDevice,
    bufferView: VkBufferView,
    pAllocator: ?*const VkAllocationCallbacks,
) callconv(.c) void;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_COMPRESSION_EXHAUSTED_EXT,VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateImage = fn (
    device: VkDevice,
    pCreateInfo: *const VkImageCreateInfo,
    pAllocator: ?*const VkAllocationCallbacks,
    pImage: *VkImage,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkDestroyImage = fn (
    device: VkDevice,
    image: VkImage,
    pAllocator: ?*const VkAllocationCallbacks,
) callconv(.c) void;
// Can be used without queues: false
pub const vkGetImageSubresourceLayout = fn (
    device: VkDevice,
    image: VkImage,
    pSubresource: *const VkImageSubresource,
    pLayout: *VkSubresourceLayout,
) callconv(.c) void;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateImageView = fn (
    device: VkDevice,
    pCreateInfo: *const VkImageViewCreateInfo,
    pAllocator: ?*const VkAllocationCallbacks,
    pView: *VkImageView,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkDestroyImageView = fn (
    device: VkDevice,
    imageView: VkImageView,
    pAllocator: ?*const VkAllocationCallbacks,
) callconv(.c) void;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INVALID_SHADER_NV,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: true
pub const vkCreateShaderModule = fn (
    device: VkDevice,
    pCreateInfo: *const VkShaderModuleCreateInfo,
    pAllocator: ?*const VkAllocationCallbacks,
    pShaderModule: *VkShaderModule,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkDestroyShaderModule = fn (
    device: VkDevice,
    shaderModule: VkShaderModule,
    pAllocator: ?*const VkAllocationCallbacks,
) callconv(.c) void;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: true
pub const vkCreatePipelineCache = fn (
    device: VkDevice,
    pCreateInfo: *const VkPipelineCacheCreateInfo,
    pAllocator: ?*const VkAllocationCallbacks,
    pPipelineCache: *VkPipelineCache,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkDestroyPipelineCache = fn (
    device: VkDevice,
    pipelineCache: VkPipelineCache,
    pAllocator: ?*const VkAllocationCallbacks,
) callconv(.c) void;
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetPipelineCacheData = fn (
    device: VkDevice,
    pipelineCache: VkPipelineCache,
    pDataSize: *u64,
    // Length expression: pDataSize
    pData: ?*anyopaque,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkMergePipelineCaches = fn (
    device: VkDevice,
    dstCache: VkPipelineCache,
    srcCacheCount: u32,
    // Length expression: srcCacheCount
    pSrcCaches: [*]const VkPipelineCache,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS,VK_INCOMPLETE,VK_PIPELINE_BINARY_MISSING_KHR
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: true
pub const vkCreatePipelineBinariesKHR = fn (
    device: VkDevice,
    pCreateInfo: *const VkPipelineBinaryCreateInfoKHR,
    pAllocator: ?*const VkAllocationCallbacks,
    pBinaries: *VkPipelineBinaryHandlesInfoKHR,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkDestroyPipelineBinaryKHR = fn (
    device: VkDevice,
    pipelineBinary: VkPipelineBinaryKHR,
    pAllocator: ?*const VkAllocationCallbacks,
) callconv(.c) void;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetPipelineKeyKHR = fn (
    device: VkDevice,
    pPipelineCreateInfo: ?*const VkPipelineCreateInfoKHR,
    pPipelineKey: *VkPipelineBinaryKeyKHR,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_NOT_ENOUGH_SPACE_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetPipelineBinaryDataKHR = fn (
    device: VkDevice,
    pInfo: *const VkPipelineBinaryDataInfoKHR,
    pPipelineBinaryKey: *VkPipelineBinaryKeyKHR,
    pPipelineBinaryDataSize: *u64,
    // Length expression: pPipelineBinaryDataSize
    pPipelineBinaryData: ?*anyopaque,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkReleaseCapturedPipelineDataKHR = fn (
    device: VkDevice,
    pInfo: *const VkReleaseCapturedPipelineDataInfoKHR,
    pAllocator: ?*const VkAllocationCallbacks,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS,VK_PIPELINE_COMPILE_REQUIRED_EXT
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INVALID_SHADER_NV,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: true
pub const vkCreateGraphicsPipelines = fn (
    device: VkDevice,
    pipelineCache: VkPipelineCache,
    createInfoCount: u32,
    // Length expression: createInfoCount
    pCreateInfos: [*]const VkGraphicsPipelineCreateInfo,
    pAllocator: ?*const VkAllocationCallbacks,
    // Length expression: createInfoCount
    pPipelines: [*]VkPipeline,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS,VK_PIPELINE_COMPILE_REQUIRED_EXT
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INVALID_SHADER_NV,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: true
pub const vkCreateComputePipelines = fn (
    device: VkDevice,
    pipelineCache: VkPipelineCache,
    createInfoCount: u32,
    // Length expression: createInfoCount
    pCreateInfos: [*]const VkComputePipelineCreateInfo,
    pAllocator: ?*const VkAllocationCallbacks,
    // Length expression: createInfoCount
    pPipelines: [*]VkPipeline,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI = fn (
    device: VkDevice,
    renderpass: VkRenderPass,
    // Length expression: 1
    pMaxWorkgroupSize: *VkExtent2D,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkDestroyPipeline = fn (
    device: VkDevice,
    pipeline: VkPipeline,
    pAllocator: ?*const VkAllocationCallbacks,
) callconv(.c) void;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: true
pub const vkCreatePipelineLayout = fn (
    device: VkDevice,
    pCreateInfo: *const VkPipelineLayoutCreateInfo,
    pAllocator: ?*const VkAllocationCallbacks,
    pPipelineLayout: *VkPipelineLayout,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkDestroyPipelineLayout = fn (
    device: VkDevice,
    pipelineLayout: VkPipelineLayout,
    pAllocator: ?*const VkAllocationCallbacks,
) callconv(.c) void;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: true
pub const vkCreateSampler = fn (
    device: VkDevice,
    pCreateInfo: *const VkSamplerCreateInfo,
    pAllocator: ?*const VkAllocationCallbacks,
    pSampler: *VkSampler,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkDestroySampler = fn (
    device: VkDevice,
    sampler: VkSampler,
    pAllocator: ?*const VkAllocationCallbacks,
) callconv(.c) void;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: true
pub const vkCreateDescriptorSetLayout = fn (
    device: VkDevice,
    pCreateInfo: *const VkDescriptorSetLayoutCreateInfo,
    pAllocator: ?*const VkAllocationCallbacks,
    pSetLayout: *VkDescriptorSetLayout,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkDestroyDescriptorSetLayout = fn (
    device: VkDevice,
    descriptorSetLayout: VkDescriptorSetLayout,
    pAllocator: ?*const VkAllocationCallbacks,
) callconv(.c) void;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_FRAGMENTATION_EXT,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateDescriptorPool = fn (
    device: VkDevice,
    pCreateInfo: *const VkDescriptorPoolCreateInfo,
    pAllocator: ?*const VkAllocationCallbacks,
    pDescriptorPool: *VkDescriptorPool,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkDestroyDescriptorPool = fn (
    device: VkDevice,
    descriptorPool: VkDescriptorPool,
    pAllocator: ?*const VkAllocationCallbacks,
) callconv(.c) void;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkResetDescriptorPool = fn (
    device: VkDevice,
    descriptorPool: VkDescriptorPool,
    flags: VkDescriptorPoolResetFlags,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_FRAGMENTED_POOL,VK_ERROR_OUT_OF_POOL_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkAllocateDescriptorSets = fn (
    device: VkDevice,
    pAllocateInfo: *const VkDescriptorSetAllocateInfo,
    // Length expression: pAllocateInfo-&gt;descriptorSetCount
    pDescriptorSets: [*]VkDescriptorSet,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkFreeDescriptorSets = fn (
    device: VkDevice,
    descriptorPool: VkDescriptorPool,
    descriptorSetCount: u32,
    // Length expression: descriptorSetCount
    pDescriptorSets: [*]const VkDescriptorSet,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkUpdateDescriptorSets = fn (
    device: VkDevice,
    descriptorWriteCount: u32,
    // Length expression: descriptorWriteCount
    pDescriptorWrites: [*]const VkWriteDescriptorSet,
    descriptorCopyCount: u32,
    // Length expression: descriptorCopyCount
    pDescriptorCopies: [*]const VkCopyDescriptorSet,
) callconv(.c) void;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateFramebuffer = fn (
    device: VkDevice,
    pCreateInfo: *const VkFramebufferCreateInfo,
    pAllocator: ?*const VkAllocationCallbacks,
    pFramebuffer: *VkFramebuffer,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkDestroyFramebuffer = fn (
    device: VkDevice,
    framebuffer: VkFramebuffer,
    pAllocator: ?*const VkAllocationCallbacks,
) callconv(.c) void;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: true
pub const vkCreateRenderPass = fn (
    device: VkDevice,
    pCreateInfo: *const VkRenderPassCreateInfo,
    pAllocator: ?*const VkAllocationCallbacks,
    pRenderPass: *VkRenderPass,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkDestroyRenderPass = fn (
    device: VkDevice,
    renderPass: VkRenderPass,
    pAllocator: ?*const VkAllocationCallbacks,
) callconv(.c) void;
// Can be used without queues: false
pub const vkGetRenderAreaGranularity = fn (
    device: VkDevice,
    renderPass: VkRenderPass,
    pGranularity: *VkExtent2D,
) callconv(.c) void;
// Can be used without queues: false
pub const vkGetRenderingAreaGranularity = fn (
    device: VkDevice,
    pRenderingAreaInfo: *const VkRenderingAreaInfo,
    pGranularity: *VkExtent2D,
) callconv(.c) void;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateCommandPool = fn (
    device: VkDevice,
    pCreateInfo: *const VkCommandPoolCreateInfo,
    pAllocator: ?*const VkAllocationCallbacks,
    pCommandPool: *VkCommandPool,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkDestroyCommandPool = fn (
    device: VkDevice,
    commandPool: VkCommandPool,
    pAllocator: ?*const VkAllocationCallbacks,
) callconv(.c) void;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkResetCommandPool = fn (
    device: VkDevice,
    commandPool: VkCommandPool,
    flags: VkCommandPoolResetFlags,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkAllocateCommandBuffers = fn (
    device: VkDevice,
    pAllocateInfo: *const VkCommandBufferAllocateInfo,
    // Length expression: pAllocateInfo-&gt;commandBufferCount
    pCommandBuffers: [*]VkCommandBuffer,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkFreeCommandBuffers = fn (
    device: VkDevice,
    commandPool: VkCommandPool,
    commandBufferCount: u32,
    // Length expression: commandBufferCount
    pCommandBuffers: [*]const VkCommandBuffer,
) callconv(.c) void;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkBeginCommandBuffer = fn (
    commandBuffer: VkCommandBuffer,
    pBeginInfo: *const VkCommandBufferBeginInfo,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INVALID_VIDEO_STD_PARAMETERS_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkEndCommandBuffer = fn (
    commandBuffer: VkCommandBuffer,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkResetCommandBuffer = fn (
    commandBuffer: VkCommandBuffer,
    flags: VkCommandBufferResetFlags,
) callconv(.c) VkResult;
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT,VK_QUEUE_DATA_GRAPH_BIT_ARM
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdBindPipeline = fn (
    commandBuffer: VkCommandBuffer,
    pipelineBindPoint: VkPipelineBindPoint,
    pipeline: VkPipeline,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetAttachmentFeedbackLoopEnableEXT = fn (
    commandBuffer: VkCommandBuffer,
    aspectMask: VkImageAspectFlags,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetViewport = fn (
    commandBuffer: VkCommandBuffer,
    firstViewport: u32,
    viewportCount: u32,
    // Length expression: viewportCount
    pViewports: [*]const VkViewport,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetScissor = fn (
    commandBuffer: VkCommandBuffer,
    firstScissor: u32,
    scissorCount: u32,
    // Length expression: scissorCount
    pScissors: [*]const VkRect2D,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetLineWidth = fn (
    commandBuffer: VkCommandBuffer,
    lineWidth: f32,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetDepthBias = fn (
    commandBuffer: VkCommandBuffer,
    depthBiasConstantFactor: f32,
    depthBiasClamp: f32,
    depthBiasSlopeFactor: f32,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetBlendConstants = fn (
    commandBuffer: VkCommandBuffer,
    blendConstants: *const [4]f32,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetDepthBounds = fn (
    commandBuffer: VkCommandBuffer,
    minDepthBounds: f32,
    maxDepthBounds: f32,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetStencilCompareMask = fn (
    commandBuffer: VkCommandBuffer,
    faceMask: VkStencilFaceFlags,
    compareMask: u32,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetStencilWriteMask = fn (
    commandBuffer: VkCommandBuffer,
    faceMask: VkStencilFaceFlags,
    writeMask: u32,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetStencilReference = fn (
    commandBuffer: VkCommandBuffer,
    faceMask: VkStencilFaceFlags,
    reference: u32,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT,VK_QUEUE_DATA_GRAPH_BIT_ARM
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdBindDescriptorSets = fn (
    commandBuffer: VkCommandBuffer,
    pipelineBindPoint: VkPipelineBindPoint,
    layout: VkPipelineLayout,
    firstSet: u32,
    descriptorSetCount: u32,
    // Length expression: descriptorSetCount
    pDescriptorSets: [*]const VkDescriptorSet,
    dynamicOffsetCount: u32,
    // Length expression: dynamicOffsetCount
    pDynamicOffsets: [*]const u32,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdBindIndexBuffer = fn (
    commandBuffer: VkCommandBuffer,
    buffer: VkBuffer,
    offset: u64,
    indexType: VkIndexType,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdBindVertexBuffers = fn (
    commandBuffer: VkCommandBuffer,
    firstBinding: u32,
    bindingCount: u32,
    // Length expression: bindingCount
    pBuffers: [*]const VkBuffer,
    // Length expression: bindingCount
    pOffsets: [*]const u64,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: inside
// Command buffer levels: primary,secondary
// Conditional rendering: true
// Can be used without queues: false
pub const vkCmdDraw = fn (
    commandBuffer: VkCommandBuffer,
    vertexCount: u32,
    instanceCount: u32,
    firstVertex: u32,
    firstInstance: u32,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: inside
// Command buffer levels: primary,secondary
// Conditional rendering: true
// Can be used without queues: false
pub const vkCmdDrawIndexed = fn (
    commandBuffer: VkCommandBuffer,
    indexCount: u32,
    instanceCount: u32,
    firstIndex: u32,
    vertexOffset: i32,
    firstInstance: u32,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: inside
// Command buffer levels: primary,secondary
// Conditional rendering: true
// Can be used without queues: false
pub const vkCmdDrawMultiEXT = fn (
    commandBuffer: VkCommandBuffer,
    drawCount: u32,
    // Length expression: drawCount
    pVertexInfo: [*]const VkMultiDrawInfoEXT,
    instanceCount: u32,
    firstInstance: u32,
    stride: u32,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: inside
// Command buffer levels: primary,secondary
// Conditional rendering: true
// Can be used without queues: false
pub const vkCmdDrawMultiIndexedEXT = fn (
    commandBuffer: VkCommandBuffer,
    drawCount: u32,
    // Length expression: drawCount
    pIndexInfo: [*]const VkMultiDrawIndexedInfoEXT,
    instanceCount: u32,
    firstInstance: u32,
    stride: u32,
    pVertexOffset: ?*const i32,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: inside
// Command buffer levels: primary,secondary
// Conditional rendering: true
// Can be used without queues: false
pub const vkCmdDrawIndirect = fn (
    commandBuffer: VkCommandBuffer,
    buffer: VkBuffer,
    offset: u64,
    drawCount: u32,
    stride: u32,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: inside
// Command buffer levels: primary,secondary
// Conditional rendering: true
// Can be used without queues: false
pub const vkCmdDrawIndexedIndirect = fn (
    commandBuffer: VkCommandBuffer,
    buffer: VkBuffer,
    offset: u64,
    drawCount: u32,
    stride: u32,
) callconv(.c) void;
// Queues: VK_QUEUE_COMPUTE_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: true
// Can be used without queues: false
pub const vkCmdDispatch = fn (
    commandBuffer: VkCommandBuffer,
    groupCountX: u32,
    groupCountY: u32,
    groupCountZ: u32,
) callconv(.c) void;
// Queues: VK_QUEUE_COMPUTE_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: true
// Can be used without queues: false
pub const vkCmdDispatchIndirect = fn (
    commandBuffer: VkCommandBuffer,
    buffer: VkBuffer,
    offset: u64,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: inside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSubpassShadingHUAWEI = fn (
    commandBuffer: VkCommandBuffer,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: inside
// Command buffer levels: primary,secondary
// Conditional rendering: true
// Can be used without queues: false
pub const vkCmdDrawClusterHUAWEI = fn (
    commandBuffer: VkCommandBuffer,
    groupCountX: u32,
    groupCountY: u32,
    groupCountZ: u32,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: inside
// Command buffer levels: primary,secondary
// Conditional rendering: true
// Can be used without queues: false
pub const vkCmdDrawClusterIndirectHUAWEI = fn (
    commandBuffer: VkCommandBuffer,
    buffer: VkBuffer,
    offset: u64,
) callconv(.c) void;
// Queues: VK_QUEUE_TRANSFER_BIT,VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdUpdatePipelineIndirectBufferNV = fn (
    commandBuffer: VkCommandBuffer,
    pipelineBindPoint: VkPipelineBindPoint,
    pipeline: VkPipeline,
) callconv(.c) void;
// Queues: VK_QUEUE_TRANSFER_BIT,VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdCopyBuffer = fn (
    commandBuffer: VkCommandBuffer,
    srcBuffer: VkBuffer,
    dstBuffer: VkBuffer,
    regionCount: u32,
    // Length expression: regionCount
    pRegions: [*]const VkBufferCopy,
) callconv(.c) void;
// Queues: VK_QUEUE_TRANSFER_BIT,VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdCopyImage = fn (
    commandBuffer: VkCommandBuffer,
    srcImage: VkImage,
    srcImageLayout: VkImageLayout,
    dstImage: VkImage,
    dstImageLayout: VkImageLayout,
    regionCount: u32,
    // Length expression: regionCount
    pRegions: [*]const VkImageCopy,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdBlitImage = fn (
    commandBuffer: VkCommandBuffer,
    srcImage: VkImage,
    srcImageLayout: VkImageLayout,
    dstImage: VkImage,
    dstImageLayout: VkImageLayout,
    regionCount: u32,
    // Length expression: regionCount
    pRegions: [*]const VkImageBlit,
    filter: VkFilter,
) callconv(.c) void;
// Queues: VK_QUEUE_TRANSFER_BIT,VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdCopyBufferToImage = fn (
    commandBuffer: VkCommandBuffer,
    srcBuffer: VkBuffer,
    dstImage: VkImage,
    dstImageLayout: VkImageLayout,
    regionCount: u32,
    // Length expression: regionCount
    pRegions: [*]const VkBufferImageCopy,
) callconv(.c) void;
// Queues: VK_QUEUE_TRANSFER_BIT,VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdCopyImageToBuffer = fn (
    commandBuffer: VkCommandBuffer,
    srcImage: VkImage,
    srcImageLayout: VkImageLayout,
    dstBuffer: VkBuffer,
    regionCount: u32,
    // Length expression: regionCount
    pRegions: [*]const VkBufferImageCopy,
) callconv(.c) void;
// Queues: VK_QUEUE_TRANSFER_BIT,VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdCopyMemoryIndirectNV = fn (
    commandBuffer: VkCommandBuffer,
    copyBufferAddress: u64,
    copyCount: u32,
    stride: u32,
) callconv(.c) void;
// Queues: VK_QUEUE_TRANSFER_BIT,VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdCopyMemoryIndirectKHR = fn (
    commandBuffer: VkCommandBuffer,
    pCopyMemoryIndirectInfo: *const VkCopyMemoryIndirectInfoKHR,
) callconv(.c) void;
// Queues: VK_QUEUE_TRANSFER_BIT,VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdCopyMemoryToImageIndirectNV = fn (
    commandBuffer: VkCommandBuffer,
    copyBufferAddress: u64,
    copyCount: u32,
    stride: u32,
    dstImage: VkImage,
    dstImageLayout: VkImageLayout,
    // Length expression: copyCount
    pImageSubresources: [*]const VkImageSubresourceLayers,
) callconv(.c) void;
// Queues: VK_QUEUE_TRANSFER_BIT,VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdCopyMemoryToImageIndirectKHR = fn (
    commandBuffer: VkCommandBuffer,
    pCopyMemoryToImageIndirectInfo: *const VkCopyMemoryToImageIndirectInfoKHR,
) callconv(.c) void;
// Queues: VK_QUEUE_TRANSFER_BIT,VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdUpdateBuffer = fn (
    commandBuffer: VkCommandBuffer,
    dstBuffer: VkBuffer,
    dstOffset: u64,
    dataSize: u64,
    // Length expression: dataSize
    pData: *const anyopaque,
) callconv(.c) void;
// Queues: VK_QUEUE_TRANSFER_BIT,VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
// Comment: transfer support is only available when VK_KHR_maintenance1 is enabled, as documented in valid usage language in the specification
pub const vkCmdFillBuffer = fn (
    commandBuffer: VkCommandBuffer,
    dstBuffer: VkBuffer,
    dstOffset: u64,
    size: u64,
    data: u32,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdClearColorImage = fn (
    commandBuffer: VkCommandBuffer,
    image: VkImage,
    imageLayout: VkImageLayout,
    pColor: *const VkClearColorValue,
    rangeCount: u32,
    // Length expression: rangeCount
    pRanges: [*]const VkImageSubresourceRange,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdClearDepthStencilImage = fn (
    commandBuffer: VkCommandBuffer,
    image: VkImage,
    imageLayout: VkImageLayout,
    pDepthStencil: *const VkClearDepthStencilValue,
    rangeCount: u32,
    // Length expression: rangeCount
    pRanges: [*]const VkImageSubresourceRange,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: inside
// Command buffer levels: primary,secondary
// Conditional rendering: true
// Can be used without queues: false
pub const vkCmdClearAttachments = fn (
    commandBuffer: VkCommandBuffer,
    attachmentCount: u32,
    // Length expression: attachmentCount
    pAttachments: [*]const VkClearAttachment,
    rectCount: u32,
    // Length expression: rectCount
    pRects: [*]const VkClearRect,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdResolveImage = fn (
    commandBuffer: VkCommandBuffer,
    srcImage: VkImage,
    srcImageLayout: VkImageLayout,
    dstImage: VkImage,
    dstImageLayout: VkImageLayout,
    regionCount: u32,
    // Length expression: regionCount
    pRegions: [*]const VkImageResolve,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT,VK_QUEUE_VIDEO_DECODE_BIT_KHR,VK_QUEUE_VIDEO_ENCODE_BIT_KHR
// Render pass: outside
// Video conding: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetEvent = fn (
    commandBuffer: VkCommandBuffer,
    event: VkEvent,
    stageMask: VkPipelineStageFlags,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT,VK_QUEUE_VIDEO_DECODE_BIT_KHR,VK_QUEUE_VIDEO_ENCODE_BIT_KHR
// Render pass: outside
// Video conding: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdResetEvent = fn (
    commandBuffer: VkCommandBuffer,
    event: VkEvent,
    stageMask: VkPipelineStageFlags,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT,VK_QUEUE_VIDEO_DECODE_BIT_KHR,VK_QUEUE_VIDEO_ENCODE_BIT_KHR
// Render pass: both
// Video conding: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdWaitEvents = fn (
    commandBuffer: VkCommandBuffer,
    eventCount: u32,
    // Length expression: eventCount
    pEvents: [*]const VkEvent,
    srcStageMask: VkPipelineStageFlags,
    dstStageMask: VkPipelineStageFlags,
    memoryBarrierCount: u32,
    // Length expression: memoryBarrierCount
    pMemoryBarriers: [*]const VkMemoryBarrier,
    bufferMemoryBarrierCount: u32,
    // Length expression: bufferMemoryBarrierCount
    pBufferMemoryBarriers: [*]const VkBufferMemoryBarrier,
    imageMemoryBarrierCount: u32,
    // Length expression: imageMemoryBarrierCount
    pImageMemoryBarriers: [*]const VkImageMemoryBarrier,
) callconv(.c) void;
// Queues: VK_QUEUE_TRANSFER_BIT,VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT,VK_QUEUE_VIDEO_DECODE_BIT_KHR,VK_QUEUE_VIDEO_ENCODE_BIT_KHR
// Render pass: both
// Video conding: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdPipelineBarrier = fn (
    commandBuffer: VkCommandBuffer,
    srcStageMask: VkPipelineStageFlags,
    dstStageMask: VkPipelineStageFlags,
    dependencyFlags: VkDependencyFlags,
    memoryBarrierCount: u32,
    // Length expression: memoryBarrierCount
    pMemoryBarriers: [*]const VkMemoryBarrier,
    bufferMemoryBarrierCount: u32,
    // Length expression: bufferMemoryBarrierCount
    pBufferMemoryBarriers: [*]const VkBufferMemoryBarrier,
    imageMemoryBarrierCount: u32,
    // Length expression: imageMemoryBarrierCount
    pImageMemoryBarriers: [*]const VkImageMemoryBarrier,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT,VK_QUEUE_VIDEO_DECODE_BIT_KHR,VK_QUEUE_VIDEO_ENCODE_BIT_KHR
// Render pass: both
// Video conding: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdBeginQuery = fn (
    commandBuffer: VkCommandBuffer,
    queryPool: VkQueryPool,
    query: u32,
    flags: VkQueryControlFlags,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT,VK_QUEUE_VIDEO_DECODE_BIT_KHR,VK_QUEUE_VIDEO_ENCODE_BIT_KHR
// Render pass: both
// Video conding: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdEndQuery = fn (
    commandBuffer: VkCommandBuffer,
    queryPool: VkQueryPool,
    query: u32,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdBeginConditionalRenderingEXT = fn (
    commandBuffer: VkCommandBuffer,
    pConditionalRenderingBegin: *const VkConditionalRenderingBeginInfoEXT,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdEndConditionalRenderingEXT = fn (
    commandBuffer: VkCommandBuffer,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: inside
// Command buffer levels: primary,secondary
// Conditional rendering: true
// Can be used without queues: false
pub const vkCmdBeginCustomResolveEXT = fn (
    commandBuffer: VkCommandBuffer,
    pBeginCustomResolveInfo: ?*const VkBeginCustomResolveInfoEXT,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT,VK_QUEUE_VIDEO_DECODE_BIT_KHR,VK_QUEUE_VIDEO_ENCODE_BIT_KHR,VK_QUEUE_OPTICAL_FLOW_BIT_NV
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdResetQueryPool = fn (
    commandBuffer: VkCommandBuffer,
    queryPool: VkQueryPool,
    firstQuery: u32,
    queryCount: u32,
) callconv(.c) void;
// Queues: VK_QUEUE_TRANSFER_BIT,VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT,VK_QUEUE_VIDEO_DECODE_BIT_KHR,VK_QUEUE_VIDEO_ENCODE_BIT_KHR,VK_QUEUE_OPTICAL_FLOW_BIT_NV
// Render pass: both
// Video conding: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdWriteTimestamp = fn (
    commandBuffer: VkCommandBuffer,
    pipelineStage: VkPipelineStageFlags,
    queryPool: VkQueryPool,
    query: u32,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdCopyQueryPoolResults = fn (
    commandBuffer: VkCommandBuffer,
    queryPool: VkQueryPool,
    firstQuery: u32,
    queryCount: u32,
    dstBuffer: VkBuffer,
    dstOffset: u64,
    stride: u64,
    flags: VkQueryResultFlags,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdPushConstants = fn (
    commandBuffer: VkCommandBuffer,
    layout: VkPipelineLayout,
    stageFlags: VkShaderStageFlags,
    offset: u32,
    size: u32,
    // Length expression: size
    pValues: *const anyopaque,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: outside
// Command buffer levels: primary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdBeginRenderPass = fn (
    commandBuffer: VkCommandBuffer,
    pRenderPassBegin: *const VkRenderPassBeginInfo,
    contents: VkSubpassContents,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: inside
// Command buffer levels: primary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdNextSubpass = fn (
    commandBuffer: VkCommandBuffer,
    contents: VkSubpassContents,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: inside
// Command buffer levels: primary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdEndRenderPass = fn (
    commandBuffer: VkCommandBuffer,
) callconv(.c) void;
// Queues: VK_QUEUE_TRANSFER_BIT,VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdExecuteCommands = fn (
    commandBuffer: VkCommandBuffer,
    commandBufferCount: u32,
    // Length expression: commandBufferCount
    pCommandBuffers: [*]const VkCommandBuffer,
) callconv(.c) void;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_NATIVE_WINDOW_IN_USE_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateAndroidSurfaceKHR = fn (
    instance: VkInstance,
    pCreateInfo: *const VkAndroidSurfaceCreateInfoKHR,
    pAllocator: ?*const VkAllocationCallbacks,
    pSurface: *VkSurfaceKHR,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateSurfaceOHOS = fn (
    instance: VkInstance,
    pCreateInfo: *const VkSurfaceCreateInfoOHOS,
    pAllocator: ?*const VkAllocationCallbacks,
    pSurface: *VkSurfaceKHR,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetPhysicalDeviceDisplayPropertiesKHR = fn (
    physicalDevice: VkPhysicalDevice,
    pPropertyCount: *u32,
    // Length expression: pPropertyCount
    pProperties: ?[*]VkDisplayPropertiesKHR,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetPhysicalDeviceDisplayPlanePropertiesKHR = fn (
    physicalDevice: VkPhysicalDevice,
    pPropertyCount: *u32,
    // Length expression: pPropertyCount
    pProperties: ?[*]VkDisplayPlanePropertiesKHR,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetDisplayPlaneSupportedDisplaysKHR = fn (
    physicalDevice: VkPhysicalDevice,
    planeIndex: u32,
    pDisplayCount: *u32,
    // Length expression: pDisplayCount
    pDisplays: ?[*]VkDisplayKHR,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetDisplayModePropertiesKHR = fn (
    physicalDevice: VkPhysicalDevice,
    display: VkDisplayKHR,
    pPropertyCount: *u32,
    // Length expression: pPropertyCount
    pProperties: ?[*]VkDisplayModePropertiesKHR,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateDisplayModeKHR = fn (
    physicalDevice: VkPhysicalDevice,
    display: VkDisplayKHR,
    pCreateInfo: *const VkDisplayModeCreateInfoKHR,
    pAllocator: ?*const VkAllocationCallbacks,
    pMode: *VkDisplayModeKHR,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetDisplayPlaneCapabilitiesKHR = fn (
    physicalDevice: VkPhysicalDevice,
    mode: VkDisplayModeKHR,
    planeIndex: u32,
    pCapabilities: *VkDisplayPlaneCapabilitiesKHR,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateDisplayPlaneSurfaceKHR = fn (
    instance: VkInstance,
    pCreateInfo: *const VkDisplaySurfaceCreateInfoKHR,
    pAllocator: ?*const VkAllocationCallbacks,
    pSurface: *VkSurfaceKHR,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INCOMPATIBLE_DISPLAY_KHR,VK_ERROR_DEVICE_LOST,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateSharedSwapchainsKHR = fn (
    device: VkDevice,
    swapchainCount: u32,
    // Length expression: swapchainCount
    pCreateInfos: [*]const VkSwapchainCreateInfoKHR,
    pAllocator: ?*const VkAllocationCallbacks,
    // Length expression: swapchainCount
    pSwapchains: [*]VkSwapchainKHR,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkDestroySurfaceKHR = fn (
    instance: VkInstance,
    surface: VkSurfaceKHR,
    pAllocator: ?*const VkAllocationCallbacks,
) callconv(.c) void;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetPhysicalDeviceSurfaceSupportKHR = fn (
    physicalDevice: VkPhysicalDevice,
    queueFamilyIndex: u32,
    surface: VkSurfaceKHR,
    pSupported: *u32,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetPhysicalDeviceSurfaceCapabilitiesKHR = fn (
    physicalDevice: VkPhysicalDevice,
    surface: VkSurfaceKHR,
    pSurfaceCapabilities: *VkSurfaceCapabilitiesKHR,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetPhysicalDeviceSurfaceFormatsKHR = fn (
    physicalDevice: VkPhysicalDevice,
    surface: VkSurfaceKHR,
    pSurfaceFormatCount: *u32,
    // Length expression: pSurfaceFormatCount
    pSurfaceFormats: ?[*]VkSurfaceFormatKHR,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetPhysicalDeviceSurfacePresentModesKHR = fn (
    physicalDevice: VkPhysicalDevice,
    surface: VkSurfaceKHR,
    pPresentModeCount: *u32,
    // Length expression: pPresentModeCount
    pPresentModes: ?[*]VkPresentModeKHR,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_NATIVE_WINDOW_IN_USE_KHR,VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_COMPRESSION_EXHAUSTED_EXT,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateSwapchainKHR = fn (
    device: VkDevice,
    pCreateInfo: *const VkSwapchainCreateInfoKHR,
    pAllocator: ?*const VkAllocationCallbacks,
    pSwapchain: *VkSwapchainKHR,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkDestroySwapchainKHR = fn (
    device: VkDevice,
    swapchain: VkSwapchainKHR,
    pAllocator: ?*const VkAllocationCallbacks,
) callconv(.c) void;
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetSwapchainImagesKHR = fn (
    device: VkDevice,
    swapchain: VkSwapchainKHR,
    pSwapchainImageCount: *u32,
    // Length expression: pSwapchainImageCount
    pSwapchainImages: ?[*]VkImage,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS,VK_TIMEOUT,VK_NOT_READY,VK_SUBOPTIMAL_KHR
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_OUT_OF_DATE_KHR,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkAcquireNextImageKHR = fn (
    device: VkDevice,
    swapchain: VkSwapchainKHR,
    timeout: u64,
    semaphore: VkSemaphore,
    fence: VkFence,
    pImageIndex: *u32,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS,VK_SUBOPTIMAL_KHR
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_OUT_OF_DATE_KHR,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED,VK_ERROR_PRESENT_TIMING_QUEUE_FULL_EXT
// Can be used without queues: false
pub const vkQueuePresentKHR = fn (
    queue: VkQueue,
    pPresentInfo: *const VkPresentInfoKHR,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_NATIVE_WINDOW_IN_USE_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateViSurfaceNN = fn (
    instance: VkInstance,
    pCreateInfo: *const VkViSurfaceCreateInfoNN,
    pAllocator: ?*const VkAllocationCallbacks,
    pSurface: *VkSurfaceKHR,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateWaylandSurfaceKHR = fn (
    instance: VkInstance,
    pCreateInfo: *const VkWaylandSurfaceCreateInfoKHR,
    pAllocator: ?*const VkAllocationCallbacks,
    pSurface: *VkSurfaceKHR,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkGetPhysicalDeviceWaylandPresentationSupportKHR = fn (
    physicalDevice: VkPhysicalDevice,
    queueFamilyIndex: u32,
    display: *wl_display,
) callconv(.c) u32;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateWin32SurfaceKHR = fn (
    instance: VkInstance,
    pCreateInfo: *const VkWin32SurfaceCreateInfoKHR,
    pAllocator: ?*const VkAllocationCallbacks,
    pSurface: *VkSurfaceKHR,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkGetPhysicalDeviceWin32PresentationSupportKHR = fn (
    physicalDevice: VkPhysicalDevice,
    queueFamilyIndex: u32,
) callconv(.c) u32;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateXlibSurfaceKHR = fn (
    instance: VkInstance,
    pCreateInfo: *const VkXlibSurfaceCreateInfoKHR,
    pAllocator: ?*const VkAllocationCallbacks,
    pSurface: *VkSurfaceKHR,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkGetPhysicalDeviceXlibPresentationSupportKHR = fn (
    physicalDevice: VkPhysicalDevice,
    queueFamilyIndex: u32,
    dpy: *Display,
    visualID: VisualID,
) callconv(.c) u32;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateXcbSurfaceKHR = fn (
    instance: VkInstance,
    pCreateInfo: *const VkXcbSurfaceCreateInfoKHR,
    pAllocator: ?*const VkAllocationCallbacks,
    pSurface: *VkSurfaceKHR,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkGetPhysicalDeviceXcbPresentationSupportKHR = fn (
    physicalDevice: VkPhysicalDevice,
    queueFamilyIndex: u32,
    connection: *xcb_connection_t,
    visual_id: xcb_visualid_t,
) callconv(.c) u32;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateDirectFBSurfaceEXT = fn (
    instance: VkInstance,
    pCreateInfo: *const VkDirectFBSurfaceCreateInfoEXT,
    pAllocator: ?*const VkAllocationCallbacks,
    pSurface: *VkSurfaceKHR,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkGetPhysicalDeviceDirectFBPresentationSupportEXT = fn (
    physicalDevice: VkPhysicalDevice,
    queueFamilyIndex: u32,
    dfb: *IDirectFB,
) callconv(.c) u32;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateImagePipeSurfaceFUCHSIA = fn (
    instance: VkInstance,
    pCreateInfo: *const VkImagePipeSurfaceCreateInfoFUCHSIA,
    pAllocator: ?*const VkAllocationCallbacks,
    pSurface: *VkSurfaceKHR,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_NATIVE_WINDOW_IN_USE_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateStreamDescriptorSurfaceGGP = fn (
    instance: VkInstance,
    pCreateInfo: *const VkStreamDescriptorSurfaceCreateInfoGGP,
    pAllocator: ?*const VkAllocationCallbacks,
    pSurface: *VkSurfaceKHR,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateScreenSurfaceQNX = fn (
    instance: VkInstance,
    pCreateInfo: *const VkScreenSurfaceCreateInfoQNX,
    pAllocator: ?*const VkAllocationCallbacks,
    pSurface: *VkSurfaceKHR,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkGetPhysicalDeviceScreenPresentationSupportQNX = fn (
    physicalDevice: VkPhysicalDevice,
    queueFamilyIndex: u32,
    window: *_screen_window,
) callconv(.c) u32;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateDebugReportCallbackEXT = fn (
    instance: VkInstance,
    pCreateInfo: *const VkDebugReportCallbackCreateInfoEXT,
    pAllocator: ?*const VkAllocationCallbacks,
    pCallback: *VkDebugReportCallbackEXT,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkDestroyDebugReportCallbackEXT = fn (
    instance: VkInstance,
    callback: VkDebugReportCallbackEXT,
    pAllocator: ?*const VkAllocationCallbacks,
) callconv(.c) void;
// Can be used without queues: false
pub const vkDebugReportMessageEXT = fn (
    instance: VkInstance,
    flags: VkDebugReportFlagsEXT,
    objectType: VkDebugReportObjectTypeEXT,
    object: u64,
    location: u64,
    messageCode: i32,
    // Length expression: null-terminated
    pLayerPrefix: [*:0]const u8,
    // Length expression: null-terminated
    pMessage: [*:0]const u8,
) callconv(.c) void;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkDebugMarkerSetObjectNameEXT = fn (
    device: VkDevice,
    pNameInfo: *const VkDebugMarkerObjectNameInfoEXT,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkDebugMarkerSetObjectTagEXT = fn (
    device: VkDevice,
    pTagInfo: *const VkDebugMarkerObjectTagInfoEXT,
) callconv(.c) VkResult;
// Queues: VK_QUEUE_TRANSFER_BIT,VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT,VK_QUEUE_VIDEO_DECODE_BIT_KHR,VK_QUEUE_VIDEO_ENCODE_BIT_KHR,VK_QUEUE_OPTICAL_FLOW_BIT_NV
// Render pass: both
// Video conding: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdDebugMarkerBeginEXT = fn (
    commandBuffer: VkCommandBuffer,
    pMarkerInfo: *const VkDebugMarkerMarkerInfoEXT,
) callconv(.c) void;
// Queues: VK_QUEUE_TRANSFER_BIT,VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT,VK_QUEUE_VIDEO_DECODE_BIT_KHR,VK_QUEUE_VIDEO_ENCODE_BIT_KHR,VK_QUEUE_OPTICAL_FLOW_BIT_NV
// Render pass: both
// Video conding: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdDebugMarkerEndEXT = fn (
    commandBuffer: VkCommandBuffer,
) callconv(.c) void;
// Queues: VK_QUEUE_TRANSFER_BIT,VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT,VK_QUEUE_VIDEO_DECODE_BIT_KHR,VK_QUEUE_VIDEO_ENCODE_BIT_KHR,VK_QUEUE_OPTICAL_FLOW_BIT_NV
// Render pass: both
// Video conding: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdDebugMarkerInsertEXT = fn (
    commandBuffer: VkCommandBuffer,
    pMarkerInfo: *const VkDebugMarkerMarkerInfoEXT,
) callconv(.c) void;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_FORMAT_NOT_SUPPORTED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetPhysicalDeviceExternalImageFormatPropertiesNV = fn (
    physicalDevice: VkPhysicalDevice,
    format: VkFormat,
    type: VkImageType,
    tiling: VkImageTiling,
    usage: VkImageUsageFlags,
    flags: VkImageCreateFlags,
    externalHandleType: VkExternalMemoryHandleTypeFlagsNV,
    pExternalImageFormatProperties: *VkExternalImageFormatPropertiesNV,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetMemoryWin32HandleNV = fn (
    device: VkDevice,
    memory: VkDeviceMemory,
    handleType: VkExternalMemoryHandleTypeFlagsNV,
    pHandle: *HANDLE,
) callconv(.c) VkResult;
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT
// Render pass: inside
// Command buffer levels: primary,secondary
// Conditional rendering: true
// Can be used without queues: false
pub const vkCmdExecuteGeneratedCommandsNV = fn (
    commandBuffer: VkCommandBuffer,
    isPreprocessed: u32,
    pGeneratedCommandsInfo: *const VkGeneratedCommandsInfoNV,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdPreprocessGeneratedCommandsNV = fn (
    commandBuffer: VkCommandBuffer,
    pGeneratedCommandsInfo: *const VkGeneratedCommandsInfoNV,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdBindPipelineShaderGroupNV = fn (
    commandBuffer: VkCommandBuffer,
    pipelineBindPoint: VkPipelineBindPoint,
    pipeline: VkPipeline,
    groupIndex: u32,
) callconv(.c) void;
// Can be used without queues: false
pub const vkGetGeneratedCommandsMemoryRequirementsNV = fn (
    device: VkDevice,
    pInfo: *const VkGeneratedCommandsMemoryRequirementsInfoNV,
    pMemoryRequirements: *VkMemoryRequirements2,
) callconv(.c) void;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateIndirectCommandsLayoutNV = fn (
    device: VkDevice,
    pCreateInfo: *const VkIndirectCommandsLayoutCreateInfoNV,
    pAllocator: ?*const VkAllocationCallbacks,
    pIndirectCommandsLayout: *VkIndirectCommandsLayoutNV,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkDestroyIndirectCommandsLayoutNV = fn (
    device: VkDevice,
    indirectCommandsLayout: VkIndirectCommandsLayoutNV,
    pAllocator: ?*const VkAllocationCallbacks,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT
// Render pass: both
// Command buffer levels: primary
// Conditional rendering: true
// Can be used without queues: false
pub const vkCmdExecuteGeneratedCommandsEXT = fn (
    commandBuffer: VkCommandBuffer,
    isPreprocessed: u32,
    pGeneratedCommandsInfo: *const VkGeneratedCommandsInfoEXT,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT
// Render pass: outside
// Command buffer levels: primary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdPreprocessGeneratedCommandsEXT = fn (
    commandBuffer: VkCommandBuffer,
    pGeneratedCommandsInfo: *const VkGeneratedCommandsInfoEXT,
    stateCommandBuffer: VkCommandBuffer,
) callconv(.c) void;
// Can be used without queues: false
pub const vkGetGeneratedCommandsMemoryRequirementsEXT = fn (
    device: VkDevice,
    pInfo: *const VkGeneratedCommandsMemoryRequirementsInfoEXT,
    pMemoryRequirements: *VkMemoryRequirements2,
) callconv(.c) void;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateIndirectCommandsLayoutEXT = fn (
    device: VkDevice,
    pCreateInfo: *const VkIndirectCommandsLayoutCreateInfoEXT,
    pAllocator: ?*const VkAllocationCallbacks,
    pIndirectCommandsLayout: *VkIndirectCommandsLayoutEXT,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkDestroyIndirectCommandsLayoutEXT = fn (
    device: VkDevice,
    indirectCommandsLayout: VkIndirectCommandsLayoutEXT,
    pAllocator: ?*const VkAllocationCallbacks,
) callconv(.c) void;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateIndirectExecutionSetEXT = fn (
    device: VkDevice,
    pCreateInfo: *const VkIndirectExecutionSetCreateInfoEXT,
    pAllocator: ?*const VkAllocationCallbacks,
    pIndirectExecutionSet: *VkIndirectExecutionSetEXT,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkDestroyIndirectExecutionSetEXT = fn (
    device: VkDevice,
    indirectExecutionSet: VkIndirectExecutionSetEXT,
    pAllocator: ?*const VkAllocationCallbacks,
) callconv(.c) void;
// Can be used without queues: false
pub const vkUpdateIndirectExecutionSetPipelineEXT = fn (
    device: VkDevice,
    indirectExecutionSet: VkIndirectExecutionSetEXT,
    executionSetWriteCount: u32,
    // Length expression: executionSetWriteCount
    pExecutionSetWrites: [*]const VkWriteIndirectExecutionSetPipelineEXT,
) callconv(.c) void;
// Can be used without queues: false
pub const vkUpdateIndirectExecutionSetShaderEXT = fn (
    device: VkDevice,
    indirectExecutionSet: VkIndirectExecutionSetEXT,
    executionSetWriteCount: u32,
    // Length expression: executionSetWriteCount
    pExecutionSetWrites: [*]const VkWriteIndirectExecutionSetShaderEXT,
) callconv(.c) void;
// Can be used without queues: false
pub const vkGetPhysicalDeviceFeatures2 = fn (
    physicalDevice: VkPhysicalDevice,
    pFeatures: *VkPhysicalDeviceFeatures2,
) callconv(.c) void;
// Can be used without queues: false
pub const vkGetPhysicalDeviceProperties2 = fn (
    physicalDevice: VkPhysicalDevice,
    pProperties: *VkPhysicalDeviceProperties2,
) callconv(.c) void;
// Can be used without queues: false
pub const vkGetPhysicalDeviceFormatProperties2 = fn (
    physicalDevice: VkPhysicalDevice,
    format: VkFormat,
    pFormatProperties: *VkFormatProperties2,
) callconv(.c) void;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_FORMAT_NOT_SUPPORTED,VK_ERROR_IMAGE_USAGE_NOT_SUPPORTED_KHR,VK_ERROR_VIDEO_PROFILE_OPERATION_NOT_SUPPORTED_KHR,VK_ERROR_VIDEO_PROFILE_FORMAT_NOT_SUPPORTED_KHR,VK_ERROR_VIDEO_PICTURE_LAYOUT_NOT_SUPPORTED_KHR,VK_ERROR_VIDEO_PROFILE_CODEC_NOT_SUPPORTED_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetPhysicalDeviceImageFormatProperties2 = fn (
    physicalDevice: VkPhysicalDevice,
    pImageFormatInfo: *const VkPhysicalDeviceImageFormatInfo2,
    pImageFormatProperties: *VkImageFormatProperties2,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkGetPhysicalDeviceQueueFamilyProperties2 = fn (
    physicalDevice: VkPhysicalDevice,
    pQueueFamilyPropertyCount: *u32,
    // Length expression: pQueueFamilyPropertyCount
    pQueueFamilyProperties: ?[*]VkQueueFamilyProperties2,
) callconv(.c) void;
// Can be used without queues: false
pub const vkGetPhysicalDeviceMemoryProperties2 = fn (
    physicalDevice: VkPhysicalDevice,
    pMemoryProperties: *VkPhysicalDeviceMemoryProperties2,
) callconv(.c) void;
// Can be used without queues: false
pub const vkGetPhysicalDeviceSparseImageFormatProperties2 = fn (
    physicalDevice: VkPhysicalDevice,
    pFormatInfo: *const VkPhysicalDeviceSparseImageFormatInfo2,
    pPropertyCount: *u32,
    // Length expression: pPropertyCount
    pProperties: ?[*]VkSparseImageFormatProperties2,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdPushDescriptorSet = fn (
    commandBuffer: VkCommandBuffer,
    pipelineBindPoint: VkPipelineBindPoint,
    layout: VkPipelineLayout,
    set: u32,
    descriptorWriteCount: u32,
    // Length expression: descriptorWriteCount
    pDescriptorWrites: [*]const VkWriteDescriptorSet,
) callconv(.c) void;
// Can be used without queues: false
pub const vkTrimCommandPool = fn (
    device: VkDevice,
    commandPool: VkCommandPool,
    flags: VkCommandPoolTrimFlags,
) callconv(.c) void;
// Can be used without queues: false
pub const vkGetPhysicalDeviceExternalBufferProperties = fn (
    physicalDevice: VkPhysicalDevice,
    pExternalBufferInfo: *const VkPhysicalDeviceExternalBufferInfo,
    pExternalBufferProperties: *VkExternalBufferProperties,
) callconv(.c) void;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetMemoryWin32HandleKHR = fn (
    device: VkDevice,
    pGetWin32HandleInfo: *const VkMemoryGetWin32HandleInfoKHR,
    pHandle: *HANDLE,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_INVALID_EXTERNAL_HANDLE,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetMemoryWin32HandlePropertiesKHR = fn (
    device: VkDevice,
    handleType: VkExternalMemoryHandleTypeFlags,
    handle: HANDLE,
    pMemoryWin32HandleProperties: *VkMemoryWin32HandlePropertiesKHR,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetMemoryFdKHR = fn (
    device: VkDevice,
    pGetFdInfo: *const VkMemoryGetFdInfoKHR,
    pFd: *int,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_INVALID_EXTERNAL_HANDLE,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetMemoryFdPropertiesKHR = fn (
    device: VkDevice,
    handleType: VkExternalMemoryHandleTypeFlags,
    fd: int,
    pMemoryFdProperties: *VkMemoryFdPropertiesKHR,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetMemoryZirconHandleFUCHSIA = fn (
    device: VkDevice,
    pGetZirconHandleInfo: *const VkMemoryGetZirconHandleInfoFUCHSIA,
    pZirconHandle: *zx_handle_t,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_INVALID_EXTERNAL_HANDLE,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetMemoryZirconHandlePropertiesFUCHSIA = fn (
    device: VkDevice,
    handleType: VkExternalMemoryHandleTypeFlags,
    zirconHandle: zx_handle_t,
    pMemoryZirconHandleProperties: *VkMemoryZirconHandlePropertiesFUCHSIA,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_INVALID_EXTERNAL_HANDLE,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetMemoryRemoteAddressNV = fn (
    device: VkDevice,
    pMemoryGetRemoteAddressInfo: *const VkMemoryGetRemoteAddressInfoNV,
    pAddress: **anyopaque,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetMemorySciBufNV = fn (
    device: VkDevice,
    pGetSciBufInfo: *const VkMemoryGetSciBufInfoNV,
    pHandle: *NvSciBufObj,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_INVALID_EXTERNAL_HANDLE,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetPhysicalDeviceExternalMemorySciBufPropertiesNV = fn (
    physicalDevice: VkPhysicalDevice,
    handleType: VkExternalMemoryHandleTypeFlags,
    handle: NvSciBufObj,
    pMemorySciBufProperties: *VkMemorySciBufPropertiesNV,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetPhysicalDeviceSciBufAttributesNV = fn (
    physicalDevice: VkPhysicalDevice,
    pAttributes: NvSciBufAttrList,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkGetPhysicalDeviceExternalSemaphoreProperties = fn (
    physicalDevice: VkPhysicalDevice,
    pExternalSemaphoreInfo: *const VkPhysicalDeviceExternalSemaphoreInfo,
    pExternalSemaphoreProperties: *VkExternalSemaphoreProperties,
) callconv(.c) void;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetSemaphoreWin32HandleKHR = fn (
    device: VkDevice,
    pGetWin32HandleInfo: *const VkSemaphoreGetWin32HandleInfoKHR,
    pHandle: *HANDLE,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_INVALID_EXTERNAL_HANDLE,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkImportSemaphoreWin32HandleKHR = fn (
    device: VkDevice,
    pImportSemaphoreWin32HandleInfo: *const VkImportSemaphoreWin32HandleInfoKHR,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetSemaphoreFdKHR = fn (
    device: VkDevice,
    pGetFdInfo: *const VkSemaphoreGetFdInfoKHR,
    pFd: *int,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_INVALID_EXTERNAL_HANDLE,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkImportSemaphoreFdKHR = fn (
    device: VkDevice,
    pImportSemaphoreFdInfo: *const VkImportSemaphoreFdInfoKHR,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetSemaphoreZirconHandleFUCHSIA = fn (
    device: VkDevice,
    pGetZirconHandleInfo: *const VkSemaphoreGetZirconHandleInfoFUCHSIA,
    pZirconHandle: *zx_handle_t,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_INVALID_EXTERNAL_HANDLE,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkImportSemaphoreZirconHandleFUCHSIA = fn (
    device: VkDevice,
    pImportSemaphoreZirconHandleInfo: *const VkImportSemaphoreZirconHandleInfoFUCHSIA,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkGetPhysicalDeviceExternalFenceProperties = fn (
    physicalDevice: VkPhysicalDevice,
    pExternalFenceInfo: *const VkPhysicalDeviceExternalFenceInfo,
    pExternalFenceProperties: *VkExternalFenceProperties,
) callconv(.c) void;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetFenceWin32HandleKHR = fn (
    device: VkDevice,
    pGetWin32HandleInfo: *const VkFenceGetWin32HandleInfoKHR,
    pHandle: *HANDLE,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_INVALID_EXTERNAL_HANDLE,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkImportFenceWin32HandleKHR = fn (
    device: VkDevice,
    pImportFenceWin32HandleInfo: *const VkImportFenceWin32HandleInfoKHR,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetFenceFdKHR = fn (
    device: VkDevice,
    pGetFdInfo: *const VkFenceGetFdInfoKHR,
    pFd: *int,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_INVALID_EXTERNAL_HANDLE,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkImportFenceFdKHR = fn (
    device: VkDevice,
    pImportFenceFdInfo: *const VkImportFenceFdInfoKHR,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_INVALID_EXTERNAL_HANDLE,VK_ERROR_NOT_PERMITTED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetFenceSciSyncFenceNV = fn (
    device: VkDevice,
    pGetSciSyncHandleInfo: *const VkFenceGetSciSyncInfoNV,
    pHandle: *anyopaque,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_INVALID_EXTERNAL_HANDLE,VK_ERROR_NOT_PERMITTED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetFenceSciSyncObjNV = fn (
    device: VkDevice,
    pGetSciSyncHandleInfo: *const VkFenceGetSciSyncInfoNV,
    pHandle: *anyopaque,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_INVALID_EXTERNAL_HANDLE,VK_ERROR_NOT_PERMITTED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkImportFenceSciSyncFenceNV = fn (
    device: VkDevice,
    pImportFenceSciSyncInfo: *const VkImportFenceSciSyncInfoNV,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_INVALID_EXTERNAL_HANDLE,VK_ERROR_NOT_PERMITTED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkImportFenceSciSyncObjNV = fn (
    device: VkDevice,
    pImportFenceSciSyncInfo: *const VkImportFenceSciSyncInfoNV,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_INVALID_EXTERNAL_HANDLE,VK_ERROR_NOT_PERMITTED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetSemaphoreSciSyncObjNV = fn (
    device: VkDevice,
    pGetSciSyncInfo: *const VkSemaphoreGetSciSyncInfoNV,
    pHandle: *anyopaque,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_INVALID_EXTERNAL_HANDLE,VK_ERROR_NOT_PERMITTED,VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkImportSemaphoreSciSyncObjNV = fn (
    device: VkDevice,
    pImportSemaphoreSciSyncInfo: *const VkImportSemaphoreSciSyncInfoNV,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetPhysicalDeviceSciSyncAttributesNV = fn (
    physicalDevice: VkPhysicalDevice,
    pSciSyncAttributesInfo: *const VkSciSyncAttributesInfoNV,
    pAttributes: NvSciSyncAttrList,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateSemaphoreSciSyncPoolNV = fn (
    device: VkDevice,
    pCreateInfo: *const VkSemaphoreSciSyncPoolCreateInfoNV,
    pAllocator: ?*const VkAllocationCallbacks,
    pSemaphorePool: *VkSemaphoreSciSyncPoolNV,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkDestroySemaphoreSciSyncPoolNV = fn (
    device: VkDevice,
    semaphorePool: VkSemaphoreSciSyncPoolNV,
    pAllocator: ?*const VkAllocationCallbacks,
) callconv(.c) void;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkReleaseDisplayEXT = fn (
    physicalDevice: VkPhysicalDevice,
    display: VkDisplayKHR,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkAcquireXlibDisplayEXT = fn (
    physicalDevice: VkPhysicalDevice,
    dpy: *Display,
    display: VkDisplayKHR,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetRandROutputDisplayEXT = fn (
    physicalDevice: VkPhysicalDevice,
    dpy: *Display,
    rrOutput: RROutput,
    pDisplay: *VkDisplayKHR,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkAcquireWinrtDisplayNV = fn (
    physicalDevice: VkPhysicalDevice,
    display: VkDisplayKHR,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetWinrtDisplayNV = fn (
    physicalDevice: VkPhysicalDevice,
    deviceRelativeId: u32,
    pDisplay: *VkDisplayKHR,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkDisplayPowerControlEXT = fn (
    device: VkDevice,
    display: VkDisplayKHR,
    pDisplayPowerInfo: *const VkDisplayPowerInfoEXT,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkRegisterDeviceEventEXT = fn (
    device: VkDevice,
    pDeviceEventInfo: *const VkDeviceEventInfoEXT,
    pAllocator: ?*const VkAllocationCallbacks,
    pFence: *VkFence,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkRegisterDisplayEventEXT = fn (
    device: VkDevice,
    display: VkDisplayKHR,
    pDisplayEventInfo: *const VkDisplayEventInfoEXT,
    pAllocator: ?*const VkAllocationCallbacks,
    pFence: *VkFence,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_OUT_OF_DATE_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetSwapchainCounterEXT = fn (
    device: VkDevice,
    swapchain: VkSwapchainKHR,
    counter: VkSurfaceCounterFlagsEXT,
    pCounterValue: *u64,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetPhysicalDeviceSurfaceCapabilities2EXT = fn (
    physicalDevice: VkPhysicalDevice,
    surface: VkSurfaceKHR,
    pSurfaceCapabilities: *VkSurfaceCapabilities2EXT,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkEnumeratePhysicalDeviceGroups = fn (
    instance: VkInstance,
    pPhysicalDeviceGroupCount: *u32,
    // Length expression: pPhysicalDeviceGroupCount
    pPhysicalDeviceGroupProperties: ?[*]VkPhysicalDeviceGroupProperties,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkGetDeviceGroupPeerMemoryFeatures = fn (
    device: VkDevice,
    heapIndex: u32,
    localDeviceIndex: u32,
    remoteDeviceIndex: u32,
    pPeerMemoryFeatures: *VkPeerMemoryFeatureFlags,
) callconv(.c) void;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkBindBufferMemory2 = fn (
    device: VkDevice,
    bindInfoCount: u32,
    // Length expression: bindInfoCount
    pBindInfos: [*]const VkBindBufferMemoryInfo,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkBindImageMemory2 = fn (
    device: VkDevice,
    bindInfoCount: u32,
    // Length expression: bindInfoCount
    pBindInfos: [*]const VkBindImageMemoryInfo,
) callconv(.c) VkResult;
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT,VK_QUEUE_TRANSFER_BIT
// Render pass: both
// Video conding: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetDeviceMask = fn (
    commandBuffer: VkCommandBuffer,
    deviceMask: u32,
) callconv(.c) void;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetDeviceGroupPresentCapabilitiesKHR = fn (
    device: VkDevice,
    pDeviceGroupPresentCapabilities: *VkDeviceGroupPresentCapabilitiesKHR,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetDeviceGroupSurfacePresentModesKHR = fn (
    device: VkDevice,
    surface: VkSurfaceKHR,
    pModes: *VkDeviceGroupPresentModeFlagsKHR,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS,VK_TIMEOUT,VK_NOT_READY,VK_SUBOPTIMAL_KHR
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_OUT_OF_DATE_KHR,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkAcquireNextImage2KHR = fn (
    device: VkDevice,
    pAcquireInfo: *const VkAcquireNextImageInfoKHR,
    pImageIndex: *u32,
) callconv(.c) VkResult;
// Queues: VK_QUEUE_COMPUTE_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: true
// Can be used without queues: false
pub const vkCmdDispatchBase = fn (
    commandBuffer: VkCommandBuffer,
    baseGroupX: u32,
    baseGroupY: u32,
    baseGroupZ: u32,
    groupCountX: u32,
    groupCountY: u32,
    groupCountZ: u32,
) callconv(.c) void;
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetPhysicalDevicePresentRectanglesKHR = fn (
    physicalDevice: VkPhysicalDevice,
    surface: VkSurfaceKHR,
    pRectCount: *u32,
    // Length expression: pRectCount
    pRects: ?[*]VkRect2D,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateDescriptorUpdateTemplate = fn (
    device: VkDevice,
    pCreateInfo: *const VkDescriptorUpdateTemplateCreateInfo,
    pAllocator: ?*const VkAllocationCallbacks,
    pDescriptorUpdateTemplate: *VkDescriptorUpdateTemplate,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkDestroyDescriptorUpdateTemplate = fn (
    device: VkDevice,
    descriptorUpdateTemplate: VkDescriptorUpdateTemplate,
    pAllocator: ?*const VkAllocationCallbacks,
) callconv(.c) void;
// Can be used without queues: false
pub const vkUpdateDescriptorSetWithTemplate = fn (
    device: VkDevice,
    descriptorSet: VkDescriptorSet,
    descriptorUpdateTemplate: VkDescriptorUpdateTemplate,
    pData: *const anyopaque,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdPushDescriptorSetWithTemplate = fn (
    commandBuffer: VkCommandBuffer,
    descriptorUpdateTemplate: VkDescriptorUpdateTemplate,
    layout: VkPipelineLayout,
    set: u32,
    pData: *const anyopaque,
) callconv(.c) void;
// Can be used without queues: false
pub const vkSetHdrMetadataEXT = fn (
    device: VkDevice,
    swapchainCount: u32,
    // Length expression: swapchainCount
    pSwapchains: [*]const VkSwapchainKHR,
    // Length expression: swapchainCount
    pMetadata: [*]const VkHdrMetadataEXT,
) callconv(.c) void;
// Success codes: VK_SUCCESS,VK_SUBOPTIMAL_KHR
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_OUT_OF_DATE_KHR,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetSwapchainStatusKHR = fn (
    device: VkDevice,
    swapchain: VkSwapchainKHR,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetRefreshCycleDurationGOOGLE = fn (
    device: VkDevice,
    swapchain: VkSwapchainKHR,
    pDisplayTimingProperties: *VkRefreshCycleDurationGOOGLE,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_OUT_OF_DATE_KHR,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetPastPresentationTimingGOOGLE = fn (
    device: VkDevice,
    swapchain: VkSwapchainKHR,
    pPresentationTimingCount: *u32,
    // Length expression: pPresentationTimingCount
    pPresentationTimings: ?[*]VkPastPresentationTimingGOOGLE,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_NATIVE_WINDOW_IN_USE_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateIOSSurfaceMVK = fn (
    instance: VkInstance,
    pCreateInfo: *const VkIOSSurfaceCreateInfoMVK,
    pAllocator: ?*const VkAllocationCallbacks,
    pSurface: *VkSurfaceKHR,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_NATIVE_WINDOW_IN_USE_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateMacOSSurfaceMVK = fn (
    instance: VkInstance,
    pCreateInfo: *const VkMacOSSurfaceCreateInfoMVK,
    pAllocator: ?*const VkAllocationCallbacks,
    pSurface: *VkSurfaceKHR,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_NATIVE_WINDOW_IN_USE_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateMetalSurfaceEXT = fn (
    instance: VkInstance,
    pCreateInfo: *const VkMetalSurfaceCreateInfoEXT,
    pAllocator: ?*const VkAllocationCallbacks,
    pSurface: *VkSurfaceKHR,
) callconv(.c) VkResult;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetViewportWScalingNV = fn (
    commandBuffer: VkCommandBuffer,
    firstViewport: u32,
    viewportCount: u32,
    // Length expression: viewportCount
    pViewportWScalings: [*]const VkViewportWScalingNV,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetDiscardRectangleEXT = fn (
    commandBuffer: VkCommandBuffer,
    firstDiscardRectangle: u32,
    discardRectangleCount: u32,
    // Length expression: discardRectangleCount
    pDiscardRectangles: [*]const VkRect2D,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetDiscardRectangleEnableEXT = fn (
    commandBuffer: VkCommandBuffer,
    discardRectangleEnable: u32,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetDiscardRectangleModeEXT = fn (
    commandBuffer: VkCommandBuffer,
    discardRectangleMode: VkDiscardRectangleModeEXT,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetSampleLocationsEXT = fn (
    commandBuffer: VkCommandBuffer,
    pSampleLocationsInfo: *const VkSampleLocationsInfoEXT,
) callconv(.c) void;
// Can be used without queues: false
pub const vkGetPhysicalDeviceMultisamplePropertiesEXT = fn (
    physicalDevice: VkPhysicalDevice,
    samples: VkSampleCountFlags,
    pMultisampleProperties: *VkMultisamplePropertiesEXT,
) callconv(.c) void;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetPhysicalDeviceSurfaceCapabilities2KHR = fn (
    physicalDevice: VkPhysicalDevice,
    pSurfaceInfo: *const VkPhysicalDeviceSurfaceInfo2KHR,
    pSurfaceCapabilities: *VkSurfaceCapabilities2KHR,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetPhysicalDeviceSurfaceFormats2KHR = fn (
    physicalDevice: VkPhysicalDevice,
    pSurfaceInfo: *const VkPhysicalDeviceSurfaceInfo2KHR,
    pSurfaceFormatCount: *u32,
    // Length expression: pSurfaceFormatCount
    pSurfaceFormats: ?[*]VkSurfaceFormat2KHR,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetPhysicalDeviceDisplayProperties2KHR = fn (
    physicalDevice: VkPhysicalDevice,
    pPropertyCount: *u32,
    // Length expression: pPropertyCount
    pProperties: ?[*]VkDisplayProperties2KHR,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetPhysicalDeviceDisplayPlaneProperties2KHR = fn (
    physicalDevice: VkPhysicalDevice,
    pPropertyCount: *u32,
    // Length expression: pPropertyCount
    pProperties: ?[*]VkDisplayPlaneProperties2KHR,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetDisplayModeProperties2KHR = fn (
    physicalDevice: VkPhysicalDevice,
    display: VkDisplayKHR,
    pPropertyCount: *u32,
    // Length expression: pPropertyCount
    pProperties: ?[*]VkDisplayModeProperties2KHR,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetDisplayPlaneCapabilities2KHR = fn (
    physicalDevice: VkPhysicalDevice,
    pDisplayPlaneInfo: *const VkDisplayPlaneInfo2KHR,
    pCapabilities: *VkDisplayPlaneCapabilities2KHR,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkGetBufferMemoryRequirements2 = fn (
    device: VkDevice,
    pInfo: *const VkBufferMemoryRequirementsInfo2,
    pMemoryRequirements: *VkMemoryRequirements2,
) callconv(.c) void;
// Can be used without queues: false
pub const vkGetImageMemoryRequirements2 = fn (
    device: VkDevice,
    pInfo: *const VkImageMemoryRequirementsInfo2,
    pMemoryRequirements: *VkMemoryRequirements2,
) callconv(.c) void;
// Can be used without queues: false
pub const vkGetImageSparseMemoryRequirements2 = fn (
    device: VkDevice,
    pInfo: *const VkImageSparseMemoryRequirementsInfo2,
    pSparseMemoryRequirementCount: *u32,
    // Length expression: pSparseMemoryRequirementCount
    pSparseMemoryRequirements: ?[*]VkSparseImageMemoryRequirements2,
) callconv(.c) void;
// Can be used without queues: false
pub const vkGetDeviceBufferMemoryRequirements = fn (
    device: VkDevice,
    pInfo: *const VkDeviceBufferMemoryRequirements,
    pMemoryRequirements: *VkMemoryRequirements2,
) callconv(.c) void;
// Can be used without queues: false
pub const vkGetDeviceImageMemoryRequirements = fn (
    device: VkDevice,
    pInfo: *const VkDeviceImageMemoryRequirements,
    pMemoryRequirements: *VkMemoryRequirements2,
) callconv(.c) void;
// Can be used without queues: false
pub const vkGetDeviceImageSparseMemoryRequirements = fn (
    device: VkDevice,
    pInfo: *const VkDeviceImageMemoryRequirements,
    pSparseMemoryRequirementCount: *u32,
    // Length expression: pSparseMemoryRequirementCount
    pSparseMemoryRequirements: ?[*]VkSparseImageMemoryRequirements2,
) callconv(.c) void;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: true
pub const vkCreateSamplerYcbcrConversion = fn (
    device: VkDevice,
    pCreateInfo: *const VkSamplerYcbcrConversionCreateInfo,
    pAllocator: ?*const VkAllocationCallbacks,
    pYcbcrConversion: *VkSamplerYcbcrConversion,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkDestroySamplerYcbcrConversion = fn (
    device: VkDevice,
    ycbcrConversion: VkSamplerYcbcrConversion,
    pAllocator: ?*const VkAllocationCallbacks,
) callconv(.c) void;
// Can be used without queues: false
pub const vkGetDeviceQueue2 = fn (
    device: VkDevice,
    pQueueInfo: *const VkDeviceQueueInfo2,
    pQueue: *VkQueue,
) callconv(.c) void;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateValidationCacheEXT = fn (
    device: VkDevice,
    pCreateInfo: *const VkValidationCacheCreateInfoEXT,
    pAllocator: ?*const VkAllocationCallbacks,
    pValidationCache: *VkValidationCacheEXT,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkDestroyValidationCacheEXT = fn (
    device: VkDevice,
    validationCache: VkValidationCacheEXT,
    pAllocator: ?*const VkAllocationCallbacks,
) callconv(.c) void;
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetValidationCacheDataEXT = fn (
    device: VkDevice,
    validationCache: VkValidationCacheEXT,
    pDataSize: *u64,
    // Length expression: pDataSize
    pData: ?*anyopaque,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkMergeValidationCachesEXT = fn (
    device: VkDevice,
    dstCache: VkValidationCacheEXT,
    srcCacheCount: u32,
    // Length expression: srcCacheCount
    pSrcCaches: [*]const VkValidationCacheEXT,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkGetDescriptorSetLayoutSupport = fn (
    device: VkDevice,
    pCreateInfo: *const VkDescriptorSetLayoutCreateInfo,
    pSupport: *VkDescriptorSetLayoutSupport,
) callconv(.c) void;
// Can be used without queues: false
pub const vkGetSwapchainGrallocUsageANDROID = fn (
    device: VkDevice,
    format: VkFormat,
    imageUsage: VkImageUsageFlags,
    grallocUsage: *int,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkGetSwapchainGrallocUsage2ANDROID = fn (
    device: VkDevice,
    format: VkFormat,
    imageUsage: VkImageUsageFlags,
    swapchainImageUsage: VkSwapchainImageUsageFlagsANDROID,
    grallocConsumerUsage: *u64,
    grallocProducerUsage: *u64,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkAcquireImageANDROID = fn (
    device: VkDevice,
    image: VkImage,
    nativeFenceFd: int,
    semaphore: VkSemaphore,
    fence: VkFence,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkQueueSignalReleaseImageANDROID = fn (
    queue: VkQueue,
    waitSemaphoreCount: u32,
    // Length expression: waitSemaphoreCount
    pWaitSemaphores: [*]const VkSemaphore,
    image: VkImage,
    pNativeFenceFd: *int,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_FEATURE_NOT_PRESENT,VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetShaderInfoAMD = fn (
    device: VkDevice,
    pipeline: VkPipeline,
    shaderStage: VkShaderStageFlags,
    infoType: VkShaderInfoTypeAMD,
    pInfoSize: *u64,
    // Length expression: pInfoSize
    pInfo: ?*anyopaque,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkSetLocalDimmingAMD = fn (
    device: VkDevice,
    swapChain: VkSwapchainKHR,
    localDimmingEnable: u32,
) callconv(.c) void;
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetPhysicalDeviceCalibrateableTimeDomainsKHR = fn (
    physicalDevice: VkPhysicalDevice,
    pTimeDomainCount: *u32,
    // Length expression: pTimeDomainCount
    pTimeDomains: ?[*]VkTimeDomainKHR,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetCalibratedTimestampsKHR = fn (
    device: VkDevice,
    timestampCount: u32,
    // Length expression: timestampCount
    pTimestampInfos: [*]const VkCalibratedTimestampInfoKHR,
    // Length expression: timestampCount
    pTimestamps: [*]u64,
    pMaxDeviation: *u64,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkSetDebugUtilsObjectNameEXT = fn (
    device: VkDevice,
    pNameInfo: *const VkDebugUtilsObjectNameInfoEXT,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkSetDebugUtilsObjectTagEXT = fn (
    device: VkDevice,
    pTagInfo: *const VkDebugUtilsObjectTagInfoEXT,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkQueueBeginDebugUtilsLabelEXT = fn (
    queue: VkQueue,
    pLabelInfo: *const VkDebugUtilsLabelEXT,
) callconv(.c) void;
// Can be used without queues: false
pub const vkQueueEndDebugUtilsLabelEXT = fn (
    queue: VkQueue,
) callconv(.c) void;
// Can be used without queues: false
pub const vkQueueInsertDebugUtilsLabelEXT = fn (
    queue: VkQueue,
    pLabelInfo: *const VkDebugUtilsLabelEXT,
) callconv(.c) void;
// Queues: VK_QUEUE_TRANSFER_BIT,VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT,VK_QUEUE_VIDEO_DECODE_BIT_KHR,VK_QUEUE_VIDEO_ENCODE_BIT_KHR,VK_QUEUE_OPTICAL_FLOW_BIT_NV
// Render pass: both
// Video conding: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdBeginDebugUtilsLabelEXT = fn (
    commandBuffer: VkCommandBuffer,
    pLabelInfo: *const VkDebugUtilsLabelEXT,
) callconv(.c) void;
// Queues: VK_QUEUE_TRANSFER_BIT,VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT,VK_QUEUE_VIDEO_DECODE_BIT_KHR,VK_QUEUE_VIDEO_ENCODE_BIT_KHR,VK_QUEUE_OPTICAL_FLOW_BIT_NV
// Render pass: both
// Video conding: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdEndDebugUtilsLabelEXT = fn (
    commandBuffer: VkCommandBuffer,
) callconv(.c) void;
// Queues: VK_QUEUE_TRANSFER_BIT,VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT,VK_QUEUE_VIDEO_DECODE_BIT_KHR,VK_QUEUE_VIDEO_ENCODE_BIT_KHR,VK_QUEUE_OPTICAL_FLOW_BIT_NV
// Render pass: both
// Video conding: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdInsertDebugUtilsLabelEXT = fn (
    commandBuffer: VkCommandBuffer,
    pLabelInfo: *const VkDebugUtilsLabelEXT,
) callconv(.c) void;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateDebugUtilsMessengerEXT = fn (
    instance: VkInstance,
    pCreateInfo: *const VkDebugUtilsMessengerCreateInfoEXT,
    pAllocator: ?*const VkAllocationCallbacks,
    pMessenger: *VkDebugUtilsMessengerEXT,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkDestroyDebugUtilsMessengerEXT = fn (
    instance: VkInstance,
    messenger: VkDebugUtilsMessengerEXT,
    pAllocator: ?*const VkAllocationCallbacks,
) callconv(.c) void;
// Can be used without queues: false
pub const vkSubmitDebugUtilsMessageEXT = fn (
    instance: VkInstance,
    messageSeverity: VkDebugUtilsMessageSeverityFlagsEXT,
    messageTypes: VkDebugUtilsMessageTypeFlagsEXT,
    pCallbackData: *const VkDebugUtilsMessengerCallbackDataEXT,
) callconv(.c) void;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_INVALID_EXTERNAL_HANDLE,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetMemoryHostPointerPropertiesEXT = fn (
    device: VkDevice,
    handleType: VkExternalMemoryHandleTypeFlags,
    pHostPointer: *const anyopaque,
    pMemoryHostPointerProperties: *VkMemoryHostPointerPropertiesEXT,
) callconv(.c) VkResult;
// Queues: VK_QUEUE_TRANSFER_BIT,VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdWriteBufferMarkerAMD = fn (
    commandBuffer: VkCommandBuffer,
    pipelineStage: VkPipelineStageFlags,
    dstBuffer: VkBuffer,
    dstOffset: u64,
    marker: u32,
) callconv(.c) void;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: true
pub const vkCreateRenderPass2 = fn (
    device: VkDevice,
    pCreateInfo: *const VkRenderPassCreateInfo2,
    pAllocator: ?*const VkAllocationCallbacks,
    pRenderPass: *VkRenderPass,
) callconv(.c) VkResult;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: outside
// Command buffer levels: primary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdBeginRenderPass2 = fn (
    commandBuffer: VkCommandBuffer,
    pRenderPassBegin: *const VkRenderPassBeginInfo,
    pSubpassBeginInfo: *const VkSubpassBeginInfo,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: inside
// Command buffer levels: primary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdNextSubpass2 = fn (
    commandBuffer: VkCommandBuffer,
    pSubpassBeginInfo: *const VkSubpassBeginInfo,
    pSubpassEndInfo: *const VkSubpassEndInfo,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: inside
// Command buffer levels: primary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdEndRenderPass2 = fn (
    commandBuffer: VkCommandBuffer,
    pSubpassEndInfo: *const VkSubpassEndInfo,
) callconv(.c) void;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetSemaphoreCounterValue = fn (
    device: VkDevice,
    semaphore: VkSemaphore,
    pValue: *u64,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS,VK_TIMEOUT
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkWaitSemaphores = fn (
    device: VkDevice,
    pWaitInfo: *const VkSemaphoreWaitInfo,
    timeout: u64,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkSignalSemaphore = fn (
    device: VkDevice,
    pSignalInfo: *const VkSemaphoreSignalInfo,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_INVALID_EXTERNAL_HANDLE_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetAndroidHardwareBufferPropertiesANDROID = fn (
    device: VkDevice,
    buffer: *const AHardwareBuffer,
    pProperties: *VkAndroidHardwareBufferPropertiesANDROID,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetMemoryAndroidHardwareBufferANDROID = fn (
    device: VkDevice,
    pInfo: *const VkMemoryGetAndroidHardwareBufferInfoANDROID,
    pBuffer: **AHardwareBuffer,
) callconv(.c) VkResult;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: inside
// Command buffer levels: primary,secondary
// Conditional rendering: true
// Can be used without queues: false
pub const vkCmdDrawIndirectCount = fn (
    commandBuffer: VkCommandBuffer,
    buffer: VkBuffer,
    offset: u64,
    countBuffer: VkBuffer,
    countBufferOffset: u64,
    maxDrawCount: u32,
    stride: u32,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: inside
// Command buffer levels: primary,secondary
// Conditional rendering: true
// Can be used without queues: false
pub const vkCmdDrawIndexedIndirectCount = fn (
    commandBuffer: VkCommandBuffer,
    buffer: VkBuffer,
    offset: u64,
    countBuffer: VkBuffer,
    countBufferOffset: u64,
    maxDrawCount: u32,
    stride: u32,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT,VK_QUEUE_TRANSFER_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetCheckpointNV = fn (
    commandBuffer: VkCommandBuffer,
    pCheckpointMarker: *const anyopaque,
) callconv(.c) void;
// Can be used without queues: false
pub const vkGetQueueCheckpointDataNV = fn (
    queue: VkQueue,
    pCheckpointDataCount: *u32,
    // Length expression: pCheckpointDataCount
    pCheckpointData: ?[*]VkCheckpointDataNV,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdBindTransformFeedbackBuffersEXT = fn (
    commandBuffer: VkCommandBuffer,
    firstBinding: u32,
    bindingCount: u32,
    // Length expression: bindingCount
    pBuffers: [*]const VkBuffer,
    // Length expression: bindingCount
    pOffsets: [*]const u64,
    // Length expression: bindingCount
    pSizes: ?[*]const u64,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: inside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdBeginTransformFeedbackEXT = fn (
    commandBuffer: VkCommandBuffer,
    firstCounterBuffer: u32,
    counterBufferCount: u32,
    // Length expression: counterBufferCount
    pCounterBuffers: [*]const VkBuffer,
    // Length expression: counterBufferCount
    pCounterBufferOffsets: ?[*]const u64,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: inside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdEndTransformFeedbackEXT = fn (
    commandBuffer: VkCommandBuffer,
    firstCounterBuffer: u32,
    counterBufferCount: u32,
    // Length expression: counterBufferCount
    pCounterBuffers: [*]const VkBuffer,
    // Length expression: counterBufferCount
    pCounterBufferOffsets: ?[*]const u64,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT,VK_QUEUE_VIDEO_DECODE_BIT_KHR,VK_QUEUE_VIDEO_ENCODE_BIT_KHR
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdBeginQueryIndexedEXT = fn (
    commandBuffer: VkCommandBuffer,
    queryPool: VkQueryPool,
    query: u32,
    flags: VkQueryControlFlags,
    index: u32,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT,VK_QUEUE_VIDEO_DECODE_BIT_KHR,VK_QUEUE_VIDEO_ENCODE_BIT_KHR
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdEndQueryIndexedEXT = fn (
    commandBuffer: VkCommandBuffer,
    queryPool: VkQueryPool,
    query: u32,
    index: u32,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: inside
// Command buffer levels: primary,secondary
// Conditional rendering: true
// Can be used without queues: false
pub const vkCmdDrawIndirectByteCountEXT = fn (
    commandBuffer: VkCommandBuffer,
    instanceCount: u32,
    firstInstance: u32,
    counterBuffer: VkBuffer,
    counterBufferOffset: u64,
    counterOffset: u32,
    vertexStride: u32,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetExclusiveScissorNV = fn (
    commandBuffer: VkCommandBuffer,
    firstExclusiveScissor: u32,
    exclusiveScissorCount: u32,
    // Length expression: exclusiveScissorCount
    pExclusiveScissors: [*]const VkRect2D,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetExclusiveScissorEnableNV = fn (
    commandBuffer: VkCommandBuffer,
    firstExclusiveScissor: u32,
    exclusiveScissorCount: u32,
    // Length expression: exclusiveScissorCount
    pExclusiveScissorEnables: [*]const u32,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdBindShadingRateImageNV = fn (
    commandBuffer: VkCommandBuffer,
    imageView: VkImageView,
    imageLayout: VkImageLayout,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetViewportShadingRatePaletteNV = fn (
    commandBuffer: VkCommandBuffer,
    firstViewport: u32,
    viewportCount: u32,
    // Length expression: viewportCount
    pShadingRatePalettes: [*]const VkShadingRatePaletteNV,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetCoarseSampleOrderNV = fn (
    commandBuffer: VkCommandBuffer,
    sampleOrderType: VkCoarseSampleOrderTypeNV,
    customSampleOrderCount: u32,
    // Length expression: customSampleOrderCount
    pCustomSampleOrders: [*]const VkCoarseSampleOrderCustomNV,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: inside
// Command buffer levels: primary,secondary
// Conditional rendering: true
// Can be used without queues: false
pub const vkCmdDrawMeshTasksNV = fn (
    commandBuffer: VkCommandBuffer,
    taskCount: u32,
    firstTask: u32,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: inside
// Command buffer levels: primary,secondary
// Conditional rendering: true
// Can be used without queues: false
pub const vkCmdDrawMeshTasksIndirectNV = fn (
    commandBuffer: VkCommandBuffer,
    buffer: VkBuffer,
    offset: u64,
    drawCount: u32,
    stride: u32,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: inside
// Command buffer levels: primary,secondary
// Conditional rendering: true
// Can be used without queues: false
pub const vkCmdDrawMeshTasksIndirectCountNV = fn (
    commandBuffer: VkCommandBuffer,
    buffer: VkBuffer,
    offset: u64,
    countBuffer: VkBuffer,
    countBufferOffset: u64,
    maxDrawCount: u32,
    stride: u32,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: inside
// Command buffer levels: primary,secondary
// Conditional rendering: true
// Can be used without queues: false
pub const vkCmdDrawMeshTasksEXT = fn (
    commandBuffer: VkCommandBuffer,
    groupCountX: u32,
    groupCountY: u32,
    groupCountZ: u32,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: inside
// Command buffer levels: primary,secondary
// Conditional rendering: true
// Can be used without queues: false
pub const vkCmdDrawMeshTasksIndirectEXT = fn (
    commandBuffer: VkCommandBuffer,
    buffer: VkBuffer,
    offset: u64,
    drawCount: u32,
    stride: u32,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: inside
// Command buffer levels: primary,secondary
// Conditional rendering: true
// Can be used without queues: false
pub const vkCmdDrawMeshTasksIndirectCountEXT = fn (
    commandBuffer: VkCommandBuffer,
    buffer: VkBuffer,
    offset: u64,
    countBuffer: VkBuffer,
    countBufferOffset: u64,
    maxDrawCount: u32,
    stride: u32,
) callconv(.c) void;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCompileDeferredNV = fn (
    device: VkDevice,
    pipeline: VkPipeline,
    shader: u32,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateAccelerationStructureNV = fn (
    device: VkDevice,
    pCreateInfo: *const VkAccelerationStructureCreateInfoNV,
    pAllocator: ?*const VkAllocationCallbacks,
    pAccelerationStructure: *VkAccelerationStructureNV,
) callconv(.c) VkResult;
// Queues: VK_QUEUE_COMPUTE_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdBindInvocationMaskHUAWEI = fn (
    commandBuffer: VkCommandBuffer,
    imageView: VkImageView,
    imageLayout: VkImageLayout,
) callconv(.c) void;
// Can be used without queues: false
pub const vkDestroyAccelerationStructureKHR = fn (
    device: VkDevice,
    accelerationStructure: VkAccelerationStructureKHR,
    pAllocator: ?*const VkAllocationCallbacks,
) callconv(.c) void;
// Can be used without queues: false
pub const vkDestroyAccelerationStructureNV = fn (
    device: VkDevice,
    accelerationStructure: VkAccelerationStructureNV,
    pAllocator: ?*const VkAllocationCallbacks,
) callconv(.c) void;
// Can be used without queues: false
pub const vkGetAccelerationStructureMemoryRequirementsNV = fn (
    device: VkDevice,
    pInfo: *const VkAccelerationStructureMemoryRequirementsInfoNV,
    pMemoryRequirements: *VkMemoryRequirements2,
) callconv(.c) void;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkBindAccelerationStructureMemoryNV = fn (
    device: VkDevice,
    bindInfoCount: u32,
    // Length expression: bindInfoCount
    pBindInfos: [*]const VkBindAccelerationStructureMemoryInfoNV,
) callconv(.c) VkResult;
// Queues: VK_QUEUE_COMPUTE_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdCopyAccelerationStructureNV = fn (
    commandBuffer: VkCommandBuffer,
    dst: VkAccelerationStructureNV,
    src: VkAccelerationStructureNV,
    mode: VkCopyAccelerationStructureModeKHR,
) callconv(.c) void;
// Queues: VK_QUEUE_COMPUTE_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdCopyAccelerationStructureKHR = fn (
    commandBuffer: VkCommandBuffer,
    pInfo: *const VkCopyAccelerationStructureInfoKHR,
) callconv(.c) void;
// Success codes: VK_SUCCESS,VK_OPERATION_DEFERRED_KHR,VK_OPERATION_NOT_DEFERRED_KHR
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCopyAccelerationStructureKHR = fn (
    device: VkDevice,
    deferredOperation: VkDeferredOperationKHR,
    pInfo: *const VkCopyAccelerationStructureInfoKHR,
) callconv(.c) VkResult;
// Queues: VK_QUEUE_COMPUTE_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdCopyAccelerationStructureToMemoryKHR = fn (
    commandBuffer: VkCommandBuffer,
    pInfo: *const VkCopyAccelerationStructureToMemoryInfoKHR,
) callconv(.c) void;
// Success codes: VK_SUCCESS,VK_OPERATION_DEFERRED_KHR,VK_OPERATION_NOT_DEFERRED_KHR
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCopyAccelerationStructureToMemoryKHR = fn (
    device: VkDevice,
    deferredOperation: VkDeferredOperationKHR,
    pInfo: *const VkCopyAccelerationStructureToMemoryInfoKHR,
) callconv(.c) VkResult;
// Queues: VK_QUEUE_COMPUTE_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdCopyMemoryToAccelerationStructureKHR = fn (
    commandBuffer: VkCommandBuffer,
    pInfo: *const VkCopyMemoryToAccelerationStructureInfoKHR,
) callconv(.c) void;
// Success codes: VK_SUCCESS,VK_OPERATION_DEFERRED_KHR,VK_OPERATION_NOT_DEFERRED_KHR
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCopyMemoryToAccelerationStructureKHR = fn (
    device: VkDevice,
    deferredOperation: VkDeferredOperationKHR,
    pInfo: *const VkCopyMemoryToAccelerationStructureInfoKHR,
) callconv(.c) VkResult;
// Queues: VK_QUEUE_COMPUTE_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdWriteAccelerationStructuresPropertiesKHR = fn (
    commandBuffer: VkCommandBuffer,
    accelerationStructureCount: u32,
    // Length expression: accelerationStructureCount
    pAccelerationStructures: [*]const VkAccelerationStructureKHR,
    queryType: VkQueryType,
    queryPool: VkQueryPool,
    firstQuery: u32,
) callconv(.c) void;
// Queues: VK_QUEUE_COMPUTE_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdWriteAccelerationStructuresPropertiesNV = fn (
    commandBuffer: VkCommandBuffer,
    accelerationStructureCount: u32,
    // Length expression: accelerationStructureCount
    pAccelerationStructures: [*]const VkAccelerationStructureNV,
    queryType: VkQueryType,
    queryPool: VkQueryPool,
    firstQuery: u32,
) callconv(.c) void;
// Queues: VK_QUEUE_COMPUTE_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdBuildAccelerationStructureNV = fn (
    commandBuffer: VkCommandBuffer,
    pInfo: *const VkAccelerationStructureInfoNV,
    instanceData: VkBuffer,
    instanceOffset: u64,
    update: u32,
    dst: VkAccelerationStructureNV,
    src: VkAccelerationStructureNV,
    scratch: VkBuffer,
    scratchOffset: u64,
) callconv(.c) void;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkWriteAccelerationStructuresPropertiesKHR = fn (
    device: VkDevice,
    accelerationStructureCount: u32,
    // Length expression: accelerationStructureCount
    pAccelerationStructures: [*]const VkAccelerationStructureKHR,
    queryType: VkQueryType,
    dataSize: u64,
    // Length expression: dataSize
    pData: *anyopaque,
    stride: u64,
) callconv(.c) VkResult;
// Queues: VK_QUEUE_COMPUTE_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdTraceRaysKHR = fn (
    commandBuffer: VkCommandBuffer,
    pRaygenShaderBindingTable: *const VkStridedDeviceAddressRegionKHR,
    pMissShaderBindingTable: *const VkStridedDeviceAddressRegionKHR,
    pHitShaderBindingTable: *const VkStridedDeviceAddressRegionKHR,
    pCallableShaderBindingTable: *const VkStridedDeviceAddressRegionKHR,
    width: u32,
    height: u32,
    depth: u32,
) callconv(.c) void;
// Queues: VK_QUEUE_COMPUTE_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdTraceRaysNV = fn (
    commandBuffer: VkCommandBuffer,
    raygenShaderBindingTableBuffer: VkBuffer,
    raygenShaderBindingOffset: u64,
    missShaderBindingTableBuffer: VkBuffer,
    missShaderBindingOffset: u64,
    missShaderBindingStride: u64,
    hitShaderBindingTableBuffer: VkBuffer,
    hitShaderBindingOffset: u64,
    hitShaderBindingStride: u64,
    callableShaderBindingTableBuffer: VkBuffer,
    callableShaderBindingOffset: u64,
    callableShaderBindingStride: u64,
    width: u32,
    height: u32,
    depth: u32,
) callconv(.c) void;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetRayTracingShaderGroupHandlesKHR = fn (
    device: VkDevice,
    pipeline: VkPipeline,
    firstGroup: u32,
    groupCount: u32,
    dataSize: u64,
    // Length expression: dataSize
    pData: *anyopaque,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetRayTracingCaptureReplayShaderGroupHandlesKHR = fn (
    device: VkDevice,
    pipeline: VkPipeline,
    firstGroup: u32,
    groupCount: u32,
    dataSize: u64,
    // Length expression: dataSize
    pData: *anyopaque,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetAccelerationStructureHandleNV = fn (
    device: VkDevice,
    accelerationStructure: VkAccelerationStructureNV,
    dataSize: u64,
    // Length expression: dataSize
    pData: *anyopaque,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS,VK_PIPELINE_COMPILE_REQUIRED_EXT
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INVALID_SHADER_NV,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: true
pub const vkCreateRayTracingPipelinesNV = fn (
    device: VkDevice,
    pipelineCache: VkPipelineCache,
    createInfoCount: u32,
    // Length expression: createInfoCount
    pCreateInfos: [*]const VkRayTracingPipelineCreateInfoNV,
    pAllocator: ?*const VkAllocationCallbacks,
    // Length expression: createInfoCount
    pPipelines: [*]VkPipeline,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS,VK_OPERATION_DEFERRED_KHR,VK_OPERATION_NOT_DEFERRED_KHR,VK_PIPELINE_COMPILE_REQUIRED_EXT
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: true
pub const vkCreateRayTracingPipelinesKHR = fn (
    device: VkDevice,
    deferredOperation: VkDeferredOperationKHR,
    pipelineCache: VkPipelineCache,
    createInfoCount: u32,
    // Length expression: createInfoCount
    pCreateInfos: [*]const VkRayTracingPipelineCreateInfoKHR,
    pAllocator: ?*const VkAllocationCallbacks,
    // Length expression: createInfoCount
    pPipelines: [*]VkPipeline,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetPhysicalDeviceCooperativeMatrixPropertiesNV = fn (
    physicalDevice: VkPhysicalDevice,
    pPropertyCount: *u32,
    // Length expression: pPropertyCount
    pProperties: ?[*]VkCooperativeMatrixPropertiesNV,
) callconv(.c) VkResult;
// Queues: VK_QUEUE_COMPUTE_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdTraceRaysIndirectKHR = fn (
    commandBuffer: VkCommandBuffer,
    pRaygenShaderBindingTable: *const VkStridedDeviceAddressRegionKHR,
    pMissShaderBindingTable: *const VkStridedDeviceAddressRegionKHR,
    pHitShaderBindingTable: *const VkStridedDeviceAddressRegionKHR,
    pCallableShaderBindingTable: *const VkStridedDeviceAddressRegionKHR,
    indirectDeviceAddress: u64,
) callconv(.c) void;
// Queues: VK_QUEUE_COMPUTE_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdTraceRaysIndirect2KHR = fn (
    commandBuffer: VkCommandBuffer,
    indirectDeviceAddress: u64,
) callconv(.c) void;
// Can be used without queues: false
pub const vkGetClusterAccelerationStructureBuildSizesNV = fn (
    device: VkDevice,
    pInfo: *const VkClusterAccelerationStructureInputInfoNV,
    pSizeInfo: *VkAccelerationStructureBuildSizesInfoKHR,
) callconv(.c) void;
// Queues: VK_QUEUE_COMPUTE_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdBuildClusterAccelerationStructureIndirectNV = fn (
    commandBuffer: VkCommandBuffer,
    pCommandInfos: *const VkClusterAccelerationStructureCommandsInfoNV,
) callconv(.c) void;
// Can be used without queues: false
pub const vkGetDeviceAccelerationStructureCompatibilityKHR = fn (
    device: VkDevice,
    pVersionInfo: *const VkAccelerationStructureVersionInfoKHR,
    pCompatibility: *VkAccelerationStructureCompatibilityKHR,
) callconv(.c) void;
// Can be used without queues: false
pub const vkGetRayTracingShaderGroupStackSizeKHR = fn (
    device: VkDevice,
    pipeline: VkPipeline,
    group: u32,
    groupShader: VkShaderGroupShaderKHR,
) callconv(.c) u64;
// Queues: VK_QUEUE_COMPUTE_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetRayTracingPipelineStackSizeKHR = fn (
    commandBuffer: VkCommandBuffer,
    pipelineStackSize: u32,
) callconv(.c) void;
// Can be used without queues: false
pub const vkGetImageViewHandleNVX = fn (
    device: VkDevice,
    pInfo: *const VkImageViewHandleInfoNVX,
) callconv(.c) u32;
// Can be used without queues: false
pub const vkGetImageViewHandle64NVX = fn (
    device: VkDevice,
    pInfo: *const VkImageViewHandleInfoNVX,
) callconv(.c) u64;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetImageViewAddressNVX = fn (
    device: VkDevice,
    imageView: VkImageView,
    pProperties: *VkImageViewAddressPropertiesNVX,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetPhysicalDeviceSurfacePresentModes2EXT = fn (
    physicalDevice: VkPhysicalDevice,
    pSurfaceInfo: *const VkPhysicalDeviceSurfaceInfo2KHR,
    pPresentModeCount: *u32,
    // Length expression: pPresentModeCount
    pPresentModes: ?[*]VkPresentModeKHR,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetDeviceGroupSurfacePresentModes2EXT = fn (
    device: VkDevice,
    pSurfaceInfo: *const VkPhysicalDeviceSurfaceInfo2KHR,
    pModes: *VkDeviceGroupPresentModeFlagsKHR,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkAcquireFullScreenExclusiveModeEXT = fn (
    device: VkDevice,
    swapchain: VkSwapchainKHR,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkReleaseFullScreenExclusiveModeEXT = fn (
    device: VkDevice,
    swapchain: VkSwapchainKHR,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR = fn (
    physicalDevice: VkPhysicalDevice,
    queueFamilyIndex: u32,
    pCounterCount: *u32,
    // Length expression: pCounterCount
    pCounters: ?[*]VkPerformanceCounterKHR,
    // Length expression: pCounterCount
    pCounterDescriptions: ?[*]VkPerformanceCounterDescriptionKHR,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR = fn (
    physicalDevice: VkPhysicalDevice,
    pPerformanceQueryCreateInfo: *const VkQueryPoolPerformanceCreateInfoKHR,
    pNumPasses: *u32,
) callconv(.c) void;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_TIMEOUT,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkAcquireProfilingLockKHR = fn (
    device: VkDevice,
    pInfo: *const VkAcquireProfilingLockInfoKHR,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkReleaseProfilingLockKHR = fn (
    device: VkDevice,
) callconv(.c) void;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetImageDrmFormatModifierPropertiesEXT = fn (
    device: VkDevice,
    image: VkImage,
    pProperties: *VkImageDrmFormatModifierPropertiesEXT,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkGetBufferOpaqueCaptureAddress = fn (
    device: VkDevice,
    pInfo: *const VkBufferDeviceAddressInfo,
) callconv(.c) u64;
// Can be used without queues: false
pub const vkGetBufferDeviceAddress = fn (
    device: VkDevice,
    pInfo: *const VkBufferDeviceAddressInfo,
) callconv(.c) u64;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateHeadlessSurfaceEXT = fn (
    instance: VkInstance,
    pCreateInfo: *const VkHeadlessSurfaceCreateInfoEXT,
    pAllocator: ?*const VkAllocationCallbacks,
    pSurface: *VkSurfaceKHR,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV = fn (
    physicalDevice: VkPhysicalDevice,
    pCombinationCount: *u32,
    // Length expression: pCombinationCount
    pCombinations: ?[*]VkFramebufferMixedSamplesCombinationNV,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkInitializePerformanceApiINTEL = fn (
    device: VkDevice,
    pInitializeInfo: *const VkInitializePerformanceApiInfoINTEL,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkUninitializePerformanceApiINTEL = fn (
    device: VkDevice,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT,VK_QUEUE_TRANSFER_BIT
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetPerformanceMarkerINTEL = fn (
    commandBuffer: VkCommandBuffer,
    pMarkerInfo: *const VkPerformanceMarkerInfoINTEL,
) callconv(.c) VkResult;
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT,VK_QUEUE_TRANSFER_BIT
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetPerformanceStreamMarkerINTEL = fn (
    commandBuffer: VkCommandBuffer,
    pMarkerInfo: *const VkPerformanceStreamMarkerInfoINTEL,
) callconv(.c) VkResult;
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT,VK_QUEUE_TRANSFER_BIT
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetPerformanceOverrideINTEL = fn (
    commandBuffer: VkCommandBuffer,
    pOverrideInfo: *const VkPerformanceOverrideInfoINTEL,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkAcquirePerformanceConfigurationINTEL = fn (
    device: VkDevice,
    pAcquireInfo: *const VkPerformanceConfigurationAcquireInfoINTEL,
    pConfiguration: *VkPerformanceConfigurationINTEL,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkReleasePerformanceConfigurationINTEL = fn (
    device: VkDevice,
    configuration: VkPerformanceConfigurationINTEL,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkQueueSetPerformanceConfigurationINTEL = fn (
    queue: VkQueue,
    configuration: VkPerformanceConfigurationINTEL,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetPerformanceParameterINTEL = fn (
    device: VkDevice,
    parameter: VkPerformanceParameterTypeINTEL,
    pValue: *VkPerformanceValueINTEL,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkGetDeviceMemoryOpaqueCaptureAddress = fn (
    device: VkDevice,
    pInfo: *const VkDeviceMemoryOpaqueCaptureAddressInfo,
) callconv(.c) u64;
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetPipelineExecutablePropertiesKHR = fn (
    device: VkDevice,
    pPipelineInfo: *const VkPipelineInfoKHR,
    pExecutableCount: *u32,
    // Length expression: pExecutableCount
    pProperties: ?[*]VkPipelineExecutablePropertiesKHR,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetPipelineExecutableStatisticsKHR = fn (
    device: VkDevice,
    pExecutableInfo: *const VkPipelineExecutableInfoKHR,
    pStatisticCount: *u32,
    // Length expression: pStatisticCount
    pStatistics: ?[*]VkPipelineExecutableStatisticKHR,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetPipelineExecutableInternalRepresentationsKHR = fn (
    device: VkDevice,
    pExecutableInfo: *const VkPipelineExecutableInfoKHR,
    pInternalRepresentationCount: *u32,
    // Length expression: pInternalRepresentationCount
    pInternalRepresentations: ?[*]VkPipelineExecutableInternalRepresentationKHR,
) callconv(.c) VkResult;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetLineStipple = fn (
    commandBuffer: VkCommandBuffer,
    lineStippleFactor: u32,
    lineStipplePattern: u16,
) callconv(.c) void;
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetFaultData = fn (
    device: VkDevice,
    faultQueryBehavior: VkFaultQueryBehavior,
    pUnrecordedFaults: *u32,
    pFaultCount: *u32,
    // Length expression: pFaultCount
    pFaults: ?[*]VkFaultData,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetPhysicalDeviceToolProperties = fn (
    physicalDevice: VkPhysicalDevice,
    pToolCount: *u32,
    // Length expression: pToolCount
    pToolProperties: ?[*]VkPhysicalDeviceToolProperties,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateAccelerationStructureKHR = fn (
    device: VkDevice,
    pCreateInfo: *const VkAccelerationStructureCreateInfoKHR,
    pAllocator: ?*const VkAllocationCallbacks,
    pAccelerationStructure: *VkAccelerationStructureKHR,
) callconv(.c) VkResult;
// Queues: VK_QUEUE_COMPUTE_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdBuildAccelerationStructuresKHR = fn (
    commandBuffer: VkCommandBuffer,
    infoCount: u32,
    // Length expression: infoCount
    pInfos: [*]const VkAccelerationStructureBuildGeometryInfoKHR,
    // Length expression: infoCount
    ppBuildRangeInfos: [*]const *const VkAccelerationStructureBuildRangeInfoKHR,
) callconv(.c) void;
// Queues: VK_QUEUE_COMPUTE_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdBuildAccelerationStructuresIndirectKHR = fn (
    commandBuffer: VkCommandBuffer,
    infoCount: u32,
    // Length expression: infoCount
    pInfos: [*]const VkAccelerationStructureBuildGeometryInfoKHR,
    // Length expression: infoCount
    pIndirectDeviceAddresses: [*]const u64,
    // Length expression: infoCount
    pIndirectStrides: [*]const u32,
    // Length expression: infoCount
    ppMaxPrimitiveCounts: [*]const *const u32,
) callconv(.c) void;
// Success codes: VK_SUCCESS,VK_OPERATION_DEFERRED_KHR,VK_OPERATION_NOT_DEFERRED_KHR
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkBuildAccelerationStructuresKHR = fn (
    device: VkDevice,
    deferredOperation: VkDeferredOperationKHR,
    infoCount: u32,
    // Length expression: infoCount
    pInfos: [*]const VkAccelerationStructureBuildGeometryInfoKHR,
    // Length expression: infoCount
    ppBuildRangeInfos: [*]const *const VkAccelerationStructureBuildRangeInfoKHR,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkGetAccelerationStructureDeviceAddressKHR = fn (
    device: VkDevice,
    pInfo: *const VkAccelerationStructureDeviceAddressInfoKHR,
) callconv(.c) u64;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateDeferredOperationKHR = fn (
    device: VkDevice,
    pAllocator: ?*const VkAllocationCallbacks,
    pDeferredOperation: *VkDeferredOperationKHR,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkDestroyDeferredOperationKHR = fn (
    device: VkDevice,
    operation: VkDeferredOperationKHR,
    pAllocator: ?*const VkAllocationCallbacks,
) callconv(.c) void;
// Can be used without queues: false
pub const vkGetDeferredOperationMaxConcurrencyKHR = fn (
    device: VkDevice,
    operation: VkDeferredOperationKHR,
) callconv(.c) u32;
// Success codes: VK_SUCCESS,VK_NOT_READY
// Error codes: VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetDeferredOperationResultKHR = fn (
    device: VkDevice,
    operation: VkDeferredOperationKHR,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS,VK_THREAD_DONE_KHR,VK_THREAD_IDLE_KHR
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkDeferredOperationJoinKHR = fn (
    device: VkDevice,
    operation: VkDeferredOperationKHR,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkGetPipelineIndirectMemoryRequirementsNV = fn (
    device: VkDevice,
    pCreateInfo: *const VkComputePipelineCreateInfo,
    pMemoryRequirements: *VkMemoryRequirements2,
) callconv(.c) void;
// Can be used without queues: false
pub const vkGetPipelineIndirectDeviceAddressNV = fn (
    device: VkDevice,
    pInfo: *const VkPipelineIndirectDeviceAddressInfoNV,
) callconv(.c) u64;
// Can be used without queues: false
pub const vkAntiLagUpdateAMD = fn (
    device: VkDevice,
    pData: *const VkAntiLagDataAMD,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetCullMode = fn (
    commandBuffer: VkCommandBuffer,
    cullMode: VkCullModeFlags,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetFrontFace = fn (
    commandBuffer: VkCommandBuffer,
    frontFace: VkFrontFace,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetPrimitiveTopology = fn (
    commandBuffer: VkCommandBuffer,
    primitiveTopology: VkPrimitiveTopology,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetViewportWithCount = fn (
    commandBuffer: VkCommandBuffer,
    viewportCount: u32,
    // Length expression: viewportCount
    pViewports: [*]const VkViewport,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetScissorWithCount = fn (
    commandBuffer: VkCommandBuffer,
    scissorCount: u32,
    // Length expression: scissorCount
    pScissors: [*]const VkRect2D,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdBindIndexBuffer2 = fn (
    commandBuffer: VkCommandBuffer,
    buffer: VkBuffer,
    offset: u64,
    size: u64,
    indexType: VkIndexType,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdBindVertexBuffers2 = fn (
    commandBuffer: VkCommandBuffer,
    firstBinding: u32,
    bindingCount: u32,
    // Length expression: bindingCount
    pBuffers: [*]const VkBuffer,
    // Length expression: bindingCount
    pOffsets: [*]const u64,
    // Length expression: bindingCount
    pSizes: ?[*]const u64,
    // Length expression: bindingCount
    pStrides: ?[*]const u64,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetDepthTestEnable = fn (
    commandBuffer: VkCommandBuffer,
    depthTestEnable: u32,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetDepthWriteEnable = fn (
    commandBuffer: VkCommandBuffer,
    depthWriteEnable: u32,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetDepthCompareOp = fn (
    commandBuffer: VkCommandBuffer,
    depthCompareOp: VkCompareOp,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetDepthBoundsTestEnable = fn (
    commandBuffer: VkCommandBuffer,
    depthBoundsTestEnable: u32,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetStencilTestEnable = fn (
    commandBuffer: VkCommandBuffer,
    stencilTestEnable: u32,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetStencilOp = fn (
    commandBuffer: VkCommandBuffer,
    faceMask: VkStencilFaceFlags,
    failOp: VkStencilOp,
    passOp: VkStencilOp,
    depthFailOp: VkStencilOp,
    compareOp: VkCompareOp,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetPatchControlPointsEXT = fn (
    commandBuffer: VkCommandBuffer,
    patchControlPoints: u32,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetRasterizerDiscardEnable = fn (
    commandBuffer: VkCommandBuffer,
    rasterizerDiscardEnable: u32,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetDepthBiasEnable = fn (
    commandBuffer: VkCommandBuffer,
    depthBiasEnable: u32,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetLogicOpEXT = fn (
    commandBuffer: VkCommandBuffer,
    logicOp: VkLogicOp,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetPrimitiveRestartEnable = fn (
    commandBuffer: VkCommandBuffer,
    primitiveRestartEnable: u32,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetTessellationDomainOriginEXT = fn (
    commandBuffer: VkCommandBuffer,
    domainOrigin: VkTessellationDomainOrigin,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetDepthClampEnableEXT = fn (
    commandBuffer: VkCommandBuffer,
    depthClampEnable: u32,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetPolygonModeEXT = fn (
    commandBuffer: VkCommandBuffer,
    polygonMode: VkPolygonMode,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetRasterizationSamplesEXT = fn (
    commandBuffer: VkCommandBuffer,
    rasterizationSamples: VkSampleCountFlags,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetSampleMaskEXT = fn (
    commandBuffer: VkCommandBuffer,
    samples: VkSampleCountFlags,
    // Length expression: (samples + 31) / 32
    pSampleMask: ?[*]const u32,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetAlphaToCoverageEnableEXT = fn (
    commandBuffer: VkCommandBuffer,
    alphaToCoverageEnable: u32,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetAlphaToOneEnableEXT = fn (
    commandBuffer: VkCommandBuffer,
    alphaToOneEnable: u32,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetLogicOpEnableEXT = fn (
    commandBuffer: VkCommandBuffer,
    logicOpEnable: u32,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetColorBlendEnableEXT = fn (
    commandBuffer: VkCommandBuffer,
    firstAttachment: u32,
    attachmentCount: u32,
    // Length expression: attachmentCount
    pColorBlendEnables: [*]const u32,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetColorBlendEquationEXT = fn (
    commandBuffer: VkCommandBuffer,
    firstAttachment: u32,
    attachmentCount: u32,
    // Length expression: attachmentCount
    pColorBlendEquations: [*]const VkColorBlendEquationEXT,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetColorWriteMaskEXT = fn (
    commandBuffer: VkCommandBuffer,
    firstAttachment: u32,
    attachmentCount: u32,
    // Length expression: attachmentCount
    pColorWriteMasks: [*]const VkColorComponentFlags,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetRasterizationStreamEXT = fn (
    commandBuffer: VkCommandBuffer,
    rasterizationStream: u32,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetConservativeRasterizationModeEXT = fn (
    commandBuffer: VkCommandBuffer,
    conservativeRasterizationMode: VkConservativeRasterizationModeEXT,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetExtraPrimitiveOverestimationSizeEXT = fn (
    commandBuffer: VkCommandBuffer,
    extraPrimitiveOverestimationSize: f32,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetDepthClipEnableEXT = fn (
    commandBuffer: VkCommandBuffer,
    depthClipEnable: u32,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetSampleLocationsEnableEXT = fn (
    commandBuffer: VkCommandBuffer,
    sampleLocationsEnable: u32,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetColorBlendAdvancedEXT = fn (
    commandBuffer: VkCommandBuffer,
    firstAttachment: u32,
    attachmentCount: u32,
    // Length expression: attachmentCount
    pColorBlendAdvanced: [*]const VkColorBlendAdvancedEXT,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetProvokingVertexModeEXT = fn (
    commandBuffer: VkCommandBuffer,
    provokingVertexMode: VkProvokingVertexModeEXT,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetLineRasterizationModeEXT = fn (
    commandBuffer: VkCommandBuffer,
    lineRasterizationMode: VkLineRasterizationMode,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetLineStippleEnableEXT = fn (
    commandBuffer: VkCommandBuffer,
    stippledLineEnable: u32,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetDepthClipNegativeOneToOneEXT = fn (
    commandBuffer: VkCommandBuffer,
    negativeOneToOne: u32,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetViewportWScalingEnableNV = fn (
    commandBuffer: VkCommandBuffer,
    viewportWScalingEnable: u32,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetViewportSwizzleNV = fn (
    commandBuffer: VkCommandBuffer,
    firstViewport: u32,
    viewportCount: u32,
    // Length expression: viewportCount
    pViewportSwizzles: [*]const VkViewportSwizzleNV,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetCoverageToColorEnableNV = fn (
    commandBuffer: VkCommandBuffer,
    coverageToColorEnable: u32,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetCoverageToColorLocationNV = fn (
    commandBuffer: VkCommandBuffer,
    coverageToColorLocation: u32,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetCoverageModulationModeNV = fn (
    commandBuffer: VkCommandBuffer,
    coverageModulationMode: VkCoverageModulationModeNV,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetCoverageModulationTableEnableNV = fn (
    commandBuffer: VkCommandBuffer,
    coverageModulationTableEnable: u32,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetCoverageModulationTableNV = fn (
    commandBuffer: VkCommandBuffer,
    coverageModulationTableCount: u32,
    // Length expression: coverageModulationTableCount
    pCoverageModulationTable: [*]const f32,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetShadingRateImageEnableNV = fn (
    commandBuffer: VkCommandBuffer,
    shadingRateImageEnable: u32,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetCoverageReductionModeNV = fn (
    commandBuffer: VkCommandBuffer,
    coverageReductionMode: VkCoverageReductionModeNV,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetRepresentativeFragmentTestEnableNV = fn (
    commandBuffer: VkCommandBuffer,
    representativeFragmentTestEnable: u32,
) callconv(.c) void;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreatePrivateDataSlot = fn (
    device: VkDevice,
    pCreateInfo: *const VkPrivateDataSlotCreateInfo,
    pAllocator: ?*const VkAllocationCallbacks,
    pPrivateDataSlot: *VkPrivateDataSlot,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkDestroyPrivateDataSlot = fn (
    device: VkDevice,
    privateDataSlot: VkPrivateDataSlot,
    pAllocator: ?*const VkAllocationCallbacks,
) callconv(.c) void;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkSetPrivateData = fn (
    device: VkDevice,
    objectType: VkObjectType,
    objectHandle: u64,
    privateDataSlot: VkPrivateDataSlot,
    data: u64,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkGetPrivateData = fn (
    device: VkDevice,
    objectType: VkObjectType,
    objectHandle: u64,
    privateDataSlot: VkPrivateDataSlot,
    pData: *u64,
) callconv(.c) void;
// Queues: VK_QUEUE_TRANSFER_BIT,VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdCopyBuffer2 = fn (
    commandBuffer: VkCommandBuffer,
    pCopyBufferInfo: *const VkCopyBufferInfo2,
) callconv(.c) void;
// Queues: VK_QUEUE_TRANSFER_BIT,VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdCopyImage2 = fn (
    commandBuffer: VkCommandBuffer,
    pCopyImageInfo: *const VkCopyImageInfo2,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdBlitImage2 = fn (
    commandBuffer: VkCommandBuffer,
    pBlitImageInfo: *const VkBlitImageInfo2,
) callconv(.c) void;
// Queues: VK_QUEUE_TRANSFER_BIT,VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdCopyBufferToImage2 = fn (
    commandBuffer: VkCommandBuffer,
    pCopyBufferToImageInfo: *const VkCopyBufferToImageInfo2,
) callconv(.c) void;
// Queues: VK_QUEUE_TRANSFER_BIT,VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdCopyImageToBuffer2 = fn (
    commandBuffer: VkCommandBuffer,
    pCopyImageToBufferInfo: *const VkCopyImageToBufferInfo2,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdResolveImage2 = fn (
    commandBuffer: VkCommandBuffer,
    pResolveImageInfo: *const VkResolveImageInfo2,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT,VK_QUEUE_TRANSFER_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdRefreshObjectsKHR = fn (
    commandBuffer: VkCommandBuffer,
    pRefreshObjects: *const VkRefreshObjectListKHR,
) callconv(.c) void;
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetPhysicalDeviceRefreshableObjectTypesKHR = fn (
    physicalDevice: VkPhysicalDevice,
    pRefreshableObjectTypeCount: *u32,
    // Length expression: pRefreshableObjectTypeCount
    pRefreshableObjectTypes: ?[*]VkObjectType,
) callconv(.c) VkResult;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetFragmentShadingRateKHR = fn (
    commandBuffer: VkCommandBuffer,
    pFragmentSize: *const VkExtent2D,
    combinerOps: *const [2]VkFragmentShadingRateCombinerOpKHR,
) callconv(.c) void;
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetPhysicalDeviceFragmentShadingRatesKHR = fn (
    physicalDevice: VkPhysicalDevice,
    pFragmentShadingRateCount: *u32,
    // Length expression: pFragmentShadingRateCount
    pFragmentShadingRates: ?[*]VkPhysicalDeviceFragmentShadingRateKHR,
) callconv(.c) VkResult;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetFragmentShadingRateEnumNV = fn (
    commandBuffer: VkCommandBuffer,
    shadingRate: VkFragmentShadingRateNV,
    combinerOps: *const [2]VkFragmentShadingRateCombinerOpKHR,
) callconv(.c) void;
// Can be used without queues: false
pub const vkGetAccelerationStructureBuildSizesKHR = fn (
    device: VkDevice,
    buildType: VkAccelerationStructureBuildTypeKHR,
    pBuildInfo: *const VkAccelerationStructureBuildGeometryInfoKHR,
    // Length expression: pBuildInfo-&gt;geometryCount
    pMaxPrimitiveCounts: ?[*]const u32,
    pSizeInfo: *VkAccelerationStructureBuildSizesInfoKHR,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetVertexInputEXT = fn (
    commandBuffer: VkCommandBuffer,
    vertexBindingDescriptionCount: u32,
    // Length expression: vertexBindingDescriptionCount
    pVertexBindingDescriptions: [*]const VkVertexInputBindingDescription2EXT,
    vertexAttributeDescriptionCount: u32,
    // Length expression: vertexAttributeDescriptionCount
    pVertexAttributeDescriptions: [*]const VkVertexInputAttributeDescription2EXT,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetColorWriteEnableEXT = fn (
    commandBuffer: VkCommandBuffer,
    attachmentCount: u32,
    // Length expression: attachmentCount
    pColorWriteEnables: [*]const u32,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT,VK_QUEUE_VIDEO_DECODE_BIT_KHR,VK_QUEUE_VIDEO_ENCODE_BIT_KHR
// Render pass: outside
// Video conding: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetEvent2 = fn (
    commandBuffer: VkCommandBuffer,
    event: VkEvent,
    pDependencyInfo: *const VkDependencyInfo,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT,VK_QUEUE_VIDEO_DECODE_BIT_KHR,VK_QUEUE_VIDEO_ENCODE_BIT_KHR
// Render pass: outside
// Video conding: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdResetEvent2 = fn (
    commandBuffer: VkCommandBuffer,
    event: VkEvent,
    stageMask: VkPipelineStageFlags2,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT,VK_QUEUE_VIDEO_DECODE_BIT_KHR,VK_QUEUE_VIDEO_ENCODE_BIT_KHR
// Render pass: both
// Video conding: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdWaitEvents2 = fn (
    commandBuffer: VkCommandBuffer,
    eventCount: u32,
    // Length expression: eventCount
    pEvents: [*]const VkEvent,
    // Length expression: eventCount
    pDependencyInfos: [*]const VkDependencyInfo,
) callconv(.c) void;
// Queues: VK_QUEUE_TRANSFER_BIT,VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT,VK_QUEUE_VIDEO_DECODE_BIT_KHR,VK_QUEUE_VIDEO_ENCODE_BIT_KHR
// Render pass: both
// Video conding: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdPipelineBarrier2 = fn (
    commandBuffer: VkCommandBuffer,
    pDependencyInfo: *const VkDependencyInfo,
) callconv(.c) void;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkQueueSubmit2 = fn (
    queue: VkQueue,
    submitCount: u32,
    // Length expression: submitCount
    pSubmits: [*]const VkSubmitInfo2,
    fence: VkFence,
) callconv(.c) VkResult;
// Queues: VK_QUEUE_TRANSFER_BIT,VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT,VK_QUEUE_VIDEO_DECODE_BIT_KHR,VK_QUEUE_VIDEO_ENCODE_BIT_KHR
// Render pass: both
// Video conding: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdWriteTimestamp2 = fn (
    commandBuffer: VkCommandBuffer,
    stage: VkPipelineStageFlags2,
    queryPool: VkQueryPool,
    query: u32,
) callconv(.c) void;
// Queues: VK_QUEUE_TRANSFER_BIT,VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdWriteBufferMarker2AMD = fn (
    commandBuffer: VkCommandBuffer,
    stage: VkPipelineStageFlags2,
    dstBuffer: VkBuffer,
    dstOffset: u64,
    marker: u32,
) callconv(.c) void;
// Can be used without queues: false
pub const vkGetQueueCheckpointData2NV = fn (
    queue: VkQueue,
    pCheckpointDataCount: *u32,
    // Length expression: pCheckpointDataCount
    pCheckpointData: ?[*]VkCheckpointData2NV,
) callconv(.c) void;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_MEMORY_MAP_FAILED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCopyMemoryToImage = fn (
    device: VkDevice,
    pCopyMemoryToImageInfo: *const VkCopyMemoryToImageInfo,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_MEMORY_MAP_FAILED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCopyImageToMemory = fn (
    device: VkDevice,
    pCopyImageToMemoryInfo: *const VkCopyImageToMemoryInfo,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_MEMORY_MAP_FAILED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCopyImageToImage = fn (
    device: VkDevice,
    pCopyImageToImageInfo: *const VkCopyImageToImageInfo,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_MEMORY_MAP_FAILED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkTransitionImageLayout = fn (
    device: VkDevice,
    transitionCount: u32,
    // Length expression: transitionCount
    pTransitions: [*]const VkHostImageLayoutTransitionInfo,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkGetCommandPoolMemoryConsumption = fn (
    device: VkDevice,
    commandPool: VkCommandPool,
    commandBuffer: VkCommandBuffer,
    pConsumption: *VkCommandPoolMemoryConsumption,
) callconv(.c) void;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_VIDEO_PROFILE_OPERATION_NOT_SUPPORTED_KHR,VK_ERROR_VIDEO_PROFILE_FORMAT_NOT_SUPPORTED_KHR,VK_ERROR_VIDEO_PICTURE_LAYOUT_NOT_SUPPORTED_KHR,VK_ERROR_VIDEO_PROFILE_CODEC_NOT_SUPPORTED_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetPhysicalDeviceVideoCapabilitiesKHR = fn (
    physicalDevice: VkPhysicalDevice,
    pVideoProfile: *const VkVideoProfileInfoKHR,
    pCapabilities: *VkVideoCapabilitiesKHR,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_IMAGE_USAGE_NOT_SUPPORTED_KHR,VK_ERROR_VIDEO_PROFILE_OPERATION_NOT_SUPPORTED_KHR,VK_ERROR_VIDEO_PROFILE_FORMAT_NOT_SUPPORTED_KHR,VK_ERROR_VIDEO_PICTURE_LAYOUT_NOT_SUPPORTED_KHR,VK_ERROR_VIDEO_PROFILE_CODEC_NOT_SUPPORTED_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetPhysicalDeviceVideoFormatPropertiesKHR = fn (
    physicalDevice: VkPhysicalDevice,
    pVideoFormatInfo: *const VkPhysicalDeviceVideoFormatInfoKHR,
    pVideoFormatPropertyCount: *u32,
    // Length expression: pVideoFormatPropertyCount
    pVideoFormatProperties: ?[*]VkVideoFormatPropertiesKHR,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_VIDEO_PROFILE_OPERATION_NOT_SUPPORTED_KHR,VK_ERROR_VIDEO_PROFILE_FORMAT_NOT_SUPPORTED_KHR,VK_ERROR_VIDEO_PICTURE_LAYOUT_NOT_SUPPORTED_KHR,VK_ERROR_VIDEO_PROFILE_CODEC_NOT_SUPPORTED_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR = fn (
    physicalDevice: VkPhysicalDevice,
    pQualityLevelInfo: *const VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR,
    pQualityLevelProperties: *VkVideoEncodeQualityLevelPropertiesKHR,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_VIDEO_STD_VERSION_NOT_SUPPORTED_KHR,VK_ERROR_INVALID_VIDEO_STD_PARAMETERS_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateVideoSessionKHR = fn (
    device: VkDevice,
    pCreateInfo: *const VkVideoSessionCreateInfoKHR,
    pAllocator: ?*const VkAllocationCallbacks,
    pVideoSession: *VkVideoSessionKHR,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkDestroyVideoSessionKHR = fn (
    device: VkDevice,
    videoSession: VkVideoSessionKHR,
    pAllocator: ?*const VkAllocationCallbacks,
) callconv(.c) void;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_INVALID_VIDEO_STD_PARAMETERS_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateVideoSessionParametersKHR = fn (
    device: VkDevice,
    pCreateInfo: *const VkVideoSessionParametersCreateInfoKHR,
    pAllocator: ?*const VkAllocationCallbacks,
    pVideoSessionParameters: *VkVideoSessionParametersKHR,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INVALID_VIDEO_STD_PARAMETERS_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkUpdateVideoSessionParametersKHR = fn (
    device: VkDevice,
    videoSessionParameters: VkVideoSessionParametersKHR,
    pUpdateInfo: *const VkVideoSessionParametersUpdateInfoKHR,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetEncodedVideoSessionParametersKHR = fn (
    device: VkDevice,
    pVideoSessionParametersInfo: *const VkVideoEncodeSessionParametersGetInfoKHR,
    pFeedbackInfo: ?*VkVideoEncodeSessionParametersFeedbackInfoKHR,
    pDataSize: *u64,
    // Length expression: pDataSize
    pData: ?*anyopaque,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkDestroyVideoSessionParametersKHR = fn (
    device: VkDevice,
    videoSessionParameters: VkVideoSessionParametersKHR,
    pAllocator: ?*const VkAllocationCallbacks,
) callconv(.c) void;
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetVideoSessionMemoryRequirementsKHR = fn (
    device: VkDevice,
    videoSession: VkVideoSessionKHR,
    pMemoryRequirementsCount: *u32,
    // Length expression: pMemoryRequirementsCount
    pMemoryRequirements: ?[*]VkVideoSessionMemoryRequirementsKHR,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkBindVideoSessionMemoryKHR = fn (
    device: VkDevice,
    videoSession: VkVideoSessionKHR,
    bindSessionMemoryInfoCount: u32,
    // Length expression: bindSessionMemoryInfoCount
    pBindSessionMemoryInfos: [*]const VkBindVideoSessionMemoryInfoKHR,
) callconv(.c) VkResult;
// Queues: VK_QUEUE_VIDEO_DECODE_BIT_KHR
// Render pass: outside
// Video conding: inside
// Command buffer levels: primary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdDecodeVideoKHR = fn (
    commandBuffer: VkCommandBuffer,
    pDecodeInfo: *const VkVideoDecodeInfoKHR,
) callconv(.c) void;
// Queues: VK_QUEUE_VIDEO_DECODE_BIT_KHR,VK_QUEUE_VIDEO_ENCODE_BIT_KHR
// Render pass: outside
// Video conding: outside
// Command buffer levels: primary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdBeginVideoCodingKHR = fn (
    commandBuffer: VkCommandBuffer,
    pBeginInfo: *const VkVideoBeginCodingInfoKHR,
) callconv(.c) void;
// Queues: VK_QUEUE_VIDEO_DECODE_BIT_KHR,VK_QUEUE_VIDEO_ENCODE_BIT_KHR
// Render pass: outside
// Video conding: inside
// Command buffer levels: primary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdControlVideoCodingKHR = fn (
    commandBuffer: VkCommandBuffer,
    pCodingControlInfo: *const VkVideoCodingControlInfoKHR,
) callconv(.c) void;
// Queues: VK_QUEUE_VIDEO_DECODE_BIT_KHR,VK_QUEUE_VIDEO_ENCODE_BIT_KHR
// Render pass: outside
// Video conding: inside
// Command buffer levels: primary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdEndVideoCodingKHR = fn (
    commandBuffer: VkCommandBuffer,
    pEndCodingInfo: *const VkVideoEndCodingInfoKHR,
) callconv(.c) void;
// Queues: VK_QUEUE_VIDEO_ENCODE_BIT_KHR
// Render pass: outside
// Video conding: inside
// Command buffer levels: primary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdEncodeVideoKHR = fn (
    commandBuffer: VkCommandBuffer,
    pEncodeInfo: *const VkVideoEncodeInfoKHR,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdDecompressMemoryNV = fn (
    commandBuffer: VkCommandBuffer,
    decompressRegionCount: u32,
    // Length expression: decompressRegionCount
    pDecompressMemoryRegions: [*]const VkDecompressMemoryRegionNV,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdDecompressMemoryIndirectCountNV = fn (
    commandBuffer: VkCommandBuffer,
    indirectCommandsAddress: u64,
    indirectCommandsCountAddress: u64,
    stride: u32,
) callconv(.c) void;
// Can be used without queues: false
pub const vkGetPartitionedAccelerationStructuresBuildSizesNV = fn (
    device: VkDevice,
    pInfo: *const VkPartitionedAccelerationStructureInstancesInputNV,
    pSizeInfo: *VkAccelerationStructureBuildSizesInfoKHR,
) callconv(.c) void;
// Queues: VK_QUEUE_COMPUTE_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdBuildPartitionedAccelerationStructuresNV = fn (
    commandBuffer: VkCommandBuffer,
    pBuildInfo: *const VkBuildPartitionedAccelerationStructureInfoNV,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdDecompressMemoryEXT = fn (
    commandBuffer: VkCommandBuffer,
    pDecompressMemoryInfoEXT: *const VkDecompressMemoryInfoEXT,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdDecompressMemoryIndirectCountEXT = fn (
    commandBuffer: VkCommandBuffer,
    decompressionMethod: VkMemoryDecompressionMethodFlagsEXT,
    indirectCommandsAddress: u64,
    indirectCommandsCountAddress: u64,
    maxDecompressionCount: u32,
    stride: u32,
) callconv(.c) void;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateCuModuleNVX = fn (
    device: VkDevice,
    pCreateInfo: *const VkCuModuleCreateInfoNVX,
    pAllocator: ?*const VkAllocationCallbacks,
    pModule: *VkCuModuleNVX,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateCuFunctionNVX = fn (
    device: VkDevice,
    pCreateInfo: *const VkCuFunctionCreateInfoNVX,
    pAllocator: ?*const VkAllocationCallbacks,
    pFunction: *VkCuFunctionNVX,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkDestroyCuModuleNVX = fn (
    device: VkDevice,
    module: VkCuModuleNVX,
    pAllocator: ?*const VkAllocationCallbacks,
) callconv(.c) void;
// Can be used without queues: false
pub const vkDestroyCuFunctionNVX = fn (
    device: VkDevice,
    function: VkCuFunctionNVX,
    pAllocator: ?*const VkAllocationCallbacks,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdCuLaunchKernelNVX = fn (
    commandBuffer: VkCommandBuffer,
    pLaunchInfo: *const VkCuLaunchInfoNVX,
) callconv(.c) void;
// Can be used without queues: false
pub const vkGetDescriptorSetLayoutSizeEXT = fn (
    device: VkDevice,
    layout: VkDescriptorSetLayout,
    pLayoutSizeInBytes: *u64,
) callconv(.c) void;
// Can be used without queues: false
pub const vkGetDescriptorSetLayoutBindingOffsetEXT = fn (
    device: VkDevice,
    layout: VkDescriptorSetLayout,
    binding: u32,
    pOffset: *u64,
) callconv(.c) void;
// Can be used without queues: false
pub const vkGetDescriptorEXT = fn (
    device: VkDevice,
    pDescriptorInfo: *const VkDescriptorGetInfoEXT,
    dataSize: u64,
    // Length expression: dataSize
    pDescriptor: *anyopaque,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT,VK_QUEUE_DATA_GRAPH_BIT_ARM
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdBindDescriptorBuffersEXT = fn (
    commandBuffer: VkCommandBuffer,
    bufferCount: u32,
    // Length expression: bufferCount
    pBindingInfos: [*]const VkDescriptorBufferBindingInfoEXT,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT,VK_QUEUE_DATA_GRAPH_BIT_ARM
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetDescriptorBufferOffsetsEXT = fn (
    commandBuffer: VkCommandBuffer,
    pipelineBindPoint: VkPipelineBindPoint,
    layout: VkPipelineLayout,
    firstSet: u32,
    setCount: u32,
    // Length expression: setCount
    pBufferIndices: [*]const u32,
    // Length expression: setCount
    pOffsets: [*]const u64,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdBindDescriptorBufferEmbeddedSamplersEXT = fn (
    commandBuffer: VkCommandBuffer,
    pipelineBindPoint: VkPipelineBindPoint,
    layout: VkPipelineLayout,
    set: u32,
) callconv(.c) void;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetBufferOpaqueCaptureDescriptorDataEXT = fn (
    device: VkDevice,
    pInfo: *const VkBufferCaptureDescriptorDataInfoEXT,
    pData: *anyopaque,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetImageOpaqueCaptureDescriptorDataEXT = fn (
    device: VkDevice,
    pInfo: *const VkImageCaptureDescriptorDataInfoEXT,
    pData: *anyopaque,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetImageViewOpaqueCaptureDescriptorDataEXT = fn (
    device: VkDevice,
    pInfo: *const VkImageViewCaptureDescriptorDataInfoEXT,
    pData: *anyopaque,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetSamplerOpaqueCaptureDescriptorDataEXT = fn (
    device: VkDevice,
    pInfo: *const VkSamplerCaptureDescriptorDataInfoEXT,
    pData: *anyopaque,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT = fn (
    device: VkDevice,
    pInfo: *const VkAccelerationStructureCaptureDescriptorDataInfoEXT,
    pData: *anyopaque,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkSetDeviceMemoryPriorityEXT = fn (
    device: VkDevice,
    memory: VkDeviceMemory,
    priority: f32,
) callconv(.c) void;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkAcquireDrmDisplayEXT = fn (
    physicalDevice: VkPhysicalDevice,
    drmFd: i32,
    display: VkDisplayKHR,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetDrmDisplayEXT = fn (
    physicalDevice: VkPhysicalDevice,
    drmFd: i32,
    connectorId: u32,
    display: *VkDisplayKHR,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS,VK_TIMEOUT,VK_SUBOPTIMAL_KHR
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_OUT_OF_DATE_KHR,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkWaitForPresent2KHR = fn (
    device: VkDevice,
    swapchain: VkSwapchainKHR,
    pPresentWait2Info: *const VkPresentWait2InfoKHR,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS,VK_TIMEOUT,VK_SUBOPTIMAL_KHR
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_OUT_OF_DATE_KHR,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkWaitForPresentKHR = fn (
    device: VkDevice,
    swapchain: VkSwapchainKHR,
    presentId: u64,
    timeout: u64,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_INVALID_EXTERNAL_HANDLE,VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateBufferCollectionFUCHSIA = fn (
    device: VkDevice,
    pCreateInfo: *const VkBufferCollectionCreateInfoFUCHSIA,
    pAllocator: ?*const VkAllocationCallbacks,
    pCollection: *VkBufferCollectionFUCHSIA,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_FORMAT_NOT_SUPPORTED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkSetBufferCollectionBufferConstraintsFUCHSIA = fn (
    device: VkDevice,
    collection: VkBufferCollectionFUCHSIA,
    pBufferConstraintsInfo: *const VkBufferConstraintsInfoFUCHSIA,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_FORMAT_NOT_SUPPORTED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkSetBufferCollectionImageConstraintsFUCHSIA = fn (
    device: VkDevice,
    collection: VkBufferCollectionFUCHSIA,
    pImageConstraintsInfo: *const VkImageConstraintsInfoFUCHSIA,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkDestroyBufferCollectionFUCHSIA = fn (
    device: VkDevice,
    collection: VkBufferCollectionFUCHSIA,
    pAllocator: ?*const VkAllocationCallbacks,
) callconv(.c) void;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetBufferCollectionPropertiesFUCHSIA = fn (
    device: VkDevice,
    collection: VkBufferCollectionFUCHSIA,
    pProperties: *VkBufferCollectionPropertiesFUCHSIA,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateCudaModuleNV = fn (
    device: VkDevice,
    pCreateInfo: *const VkCudaModuleCreateInfoNV,
    pAllocator: ?*const VkAllocationCallbacks,
    pModule: *VkCudaModuleNV,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetCudaModuleCacheNV = fn (
    device: VkDevice,
    module: VkCudaModuleNV,
    pCacheSize: *u64,
    // Length expression: pCacheSize
    pCacheData: ?*anyopaque,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateCudaFunctionNV = fn (
    device: VkDevice,
    pCreateInfo: *const VkCudaFunctionCreateInfoNV,
    pAllocator: ?*const VkAllocationCallbacks,
    pFunction: *VkCudaFunctionNV,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkDestroyCudaModuleNV = fn (
    device: VkDevice,
    module: VkCudaModuleNV,
    pAllocator: ?*const VkAllocationCallbacks,
) callconv(.c) void;
// Can be used without queues: false
pub const vkDestroyCudaFunctionNV = fn (
    device: VkDevice,
    function: VkCudaFunctionNV,
    pAllocator: ?*const VkAllocationCallbacks,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdCudaLaunchKernelNV = fn (
    commandBuffer: VkCommandBuffer,
    pLaunchInfo: *const VkCudaLaunchInfoNV,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdBeginRendering = fn (
    commandBuffer: VkCommandBuffer,
    pRenderingInfo: *const VkRenderingInfo,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: inside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdEndRendering = fn (
    commandBuffer: VkCommandBuffer,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: inside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdEndRendering2KHR = fn (
    commandBuffer: VkCommandBuffer,
    pRenderingEndInfo: ?*const VkRenderingEndInfoKHR,
) callconv(.c) void;
// Can be used without queues: false
pub const vkGetDescriptorSetLayoutHostMappingInfoVALVE = fn (
    device: VkDevice,
    pBindingReference: *const VkDescriptorSetBindingReferenceVALVE,
    pHostMapping: *VkDescriptorSetLayoutHostMappingInfoVALVE,
) callconv(.c) void;
// Can be used without queues: false
pub const vkGetDescriptorSetHostMappingVALVE = fn (
    device: VkDevice,
    descriptorSet: VkDescriptorSet,
    ppData: **anyopaque,
) callconv(.c) void;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateMicromapEXT = fn (
    device: VkDevice,
    pCreateInfo: *const VkMicromapCreateInfoEXT,
    pAllocator: ?*const VkAllocationCallbacks,
    pMicromap: *VkMicromapEXT,
) callconv(.c) VkResult;
// Queues: VK_QUEUE_COMPUTE_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdBuildMicromapsEXT = fn (
    commandBuffer: VkCommandBuffer,
    infoCount: u32,
    // Length expression: infoCount
    pInfos: [*]const VkMicromapBuildInfoEXT,
) callconv(.c) void;
// Success codes: VK_SUCCESS,VK_OPERATION_DEFERRED_KHR,VK_OPERATION_NOT_DEFERRED_KHR
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkBuildMicromapsEXT = fn (
    device: VkDevice,
    deferredOperation: VkDeferredOperationKHR,
    infoCount: u32,
    // Length expression: infoCount
    pInfos: [*]const VkMicromapBuildInfoEXT,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkDestroyMicromapEXT = fn (
    device: VkDevice,
    micromap: VkMicromapEXT,
    pAllocator: ?*const VkAllocationCallbacks,
) callconv(.c) void;
// Queues: VK_QUEUE_COMPUTE_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdCopyMicromapEXT = fn (
    commandBuffer: VkCommandBuffer,
    pInfo: *const VkCopyMicromapInfoEXT,
) callconv(.c) void;
// Success codes: VK_SUCCESS,VK_OPERATION_DEFERRED_KHR,VK_OPERATION_NOT_DEFERRED_KHR
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCopyMicromapEXT = fn (
    device: VkDevice,
    deferredOperation: VkDeferredOperationKHR,
    pInfo: *const VkCopyMicromapInfoEXT,
) callconv(.c) VkResult;
// Queues: VK_QUEUE_COMPUTE_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdCopyMicromapToMemoryEXT = fn (
    commandBuffer: VkCommandBuffer,
    pInfo: *const VkCopyMicromapToMemoryInfoEXT,
) callconv(.c) void;
// Success codes: VK_SUCCESS,VK_OPERATION_DEFERRED_KHR,VK_OPERATION_NOT_DEFERRED_KHR
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCopyMicromapToMemoryEXT = fn (
    device: VkDevice,
    deferredOperation: VkDeferredOperationKHR,
    pInfo: *const VkCopyMicromapToMemoryInfoEXT,
) callconv(.c) VkResult;
// Queues: VK_QUEUE_COMPUTE_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdCopyMemoryToMicromapEXT = fn (
    commandBuffer: VkCommandBuffer,
    pInfo: *const VkCopyMemoryToMicromapInfoEXT,
) callconv(.c) void;
// Success codes: VK_SUCCESS,VK_OPERATION_DEFERRED_KHR,VK_OPERATION_NOT_DEFERRED_KHR
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCopyMemoryToMicromapEXT = fn (
    device: VkDevice,
    deferredOperation: VkDeferredOperationKHR,
    pInfo: *const VkCopyMemoryToMicromapInfoEXT,
) callconv(.c) VkResult;
// Queues: VK_QUEUE_COMPUTE_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdWriteMicromapsPropertiesEXT = fn (
    commandBuffer: VkCommandBuffer,
    micromapCount: u32,
    // Length expression: micromapCount
    pMicromaps: [*]const VkMicromapEXT,
    queryType: VkQueryType,
    queryPool: VkQueryPool,
    firstQuery: u32,
) callconv(.c) void;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkWriteMicromapsPropertiesEXT = fn (
    device: VkDevice,
    micromapCount: u32,
    // Length expression: micromapCount
    pMicromaps: [*]const VkMicromapEXT,
    queryType: VkQueryType,
    dataSize: u64,
    // Length expression: dataSize
    pData: *anyopaque,
    stride: u64,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkGetDeviceMicromapCompatibilityEXT = fn (
    device: VkDevice,
    pVersionInfo: *const VkMicromapVersionInfoEXT,
    pCompatibility: *VkAccelerationStructureCompatibilityKHR,
) callconv(.c) void;
// Can be used without queues: false
pub const vkGetMicromapBuildSizesEXT = fn (
    device: VkDevice,
    buildType: VkAccelerationStructureBuildTypeKHR,
    pBuildInfo: *const VkMicromapBuildInfoEXT,
    pSizeInfo: *VkMicromapBuildSizesInfoEXT,
) callconv(.c) void;
// Can be used without queues: false
pub const vkGetShaderModuleIdentifierEXT = fn (
    device: VkDevice,
    shaderModule: VkShaderModule,
    pIdentifier: *VkShaderModuleIdentifierEXT,
) callconv(.c) void;
// Can be used without queues: false
pub const vkGetShaderModuleCreateInfoIdentifierEXT = fn (
    device: VkDevice,
    pCreateInfo: *const VkShaderModuleCreateInfo,
    pIdentifier: *VkShaderModuleIdentifierEXT,
) callconv(.c) void;
// Can be used without queues: false
pub const vkGetImageSubresourceLayout2 = fn (
    device: VkDevice,
    image: VkImage,
    pSubresource: *const VkImageSubresource2,
    pLayout: *VkSubresourceLayout2,
) callconv(.c) void;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetPipelinePropertiesEXT = fn (
    device: VkDevice,
    pPipelineInfo: *const VkPipelineInfoKHR,
    // valid structs: VkPipelinePropertiesIdentifierEXT
    pPipelineProperties: *VkBaseOutStructure,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkExportMetalObjectsEXT = fn (
    device: VkDevice,
    pMetalObjectsInfo: *VkExportMetalObjectsInfoEXT,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdBindTileMemoryQCOM = fn (
    commandBuffer: VkCommandBuffer,
    pTileMemoryBindInfo: ?*const VkTileMemoryBindInfoQCOM,
) callconv(.c) void;
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetFramebufferTilePropertiesQCOM = fn (
    device: VkDevice,
    framebuffer: VkFramebuffer,
    pPropertiesCount: *u32,
    // Length expression: pPropertiesCount
    pProperties: ?[*]VkTilePropertiesQCOM,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetDynamicRenderingTilePropertiesQCOM = fn (
    device: VkDevice,
    pRenderingInfo: *const VkRenderingInfo,
    pProperties: *VkTilePropertiesQCOM,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_EXTENSION_NOT_PRESENT,VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_FORMAT_NOT_SUPPORTED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetPhysicalDeviceOpticalFlowImageFormatsNV = fn (
    physicalDevice: VkPhysicalDevice,
    pOpticalFlowImageFormatInfo: *const VkOpticalFlowImageFormatInfoNV,
    pFormatCount: *u32,
    // Length expression: pFormatCount
    pImageFormatProperties: ?[*]VkOpticalFlowImageFormatPropertiesNV,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateOpticalFlowSessionNV = fn (
    device: VkDevice,
    pCreateInfo: *const VkOpticalFlowSessionCreateInfoNV,
    pAllocator: ?*const VkAllocationCallbacks,
    pSession: *VkOpticalFlowSessionNV,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkDestroyOpticalFlowSessionNV = fn (
    device: VkDevice,
    session: VkOpticalFlowSessionNV,
    pAllocator: ?*const VkAllocationCallbacks,
) callconv(.c) void;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkBindOpticalFlowSessionImageNV = fn (
    device: VkDevice,
    session: VkOpticalFlowSessionNV,
    bindingPoint: VkOpticalFlowSessionBindingPointNV,
    view: VkImageView,
    layout: VkImageLayout,
) callconv(.c) VkResult;
// Queues: VK_QUEUE_OPTICAL_FLOW_BIT_NV
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdOpticalFlowExecuteNV = fn (
    commandBuffer: VkCommandBuffer,
    session: VkOpticalFlowSessionNV,
    pExecuteInfo: *const VkOpticalFlowExecuteInfoNV,
) callconv(.c) void;
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetDeviceFaultInfoEXT = fn (
    device: VkDevice,
    pFaultCounts: *VkDeviceFaultCountsEXT,
    pFaultInfo: ?*VkDeviceFaultInfoEXT,
) callconv(.c) VkResult;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetDepthBias2EXT = fn (
    commandBuffer: VkCommandBuffer,
    pDepthBiasInfo: *const VkDepthBiasInfoEXT,
) callconv(.c) void;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkReleaseSwapchainImagesKHR = fn (
    device: VkDevice,
    pReleaseInfo: *const VkReleaseSwapchainImagesInfoKHR,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkGetDeviceImageSubresourceLayout = fn (
    device: VkDevice,
    pInfo: *const VkDeviceImageSubresourceInfo,
    pLayout: *VkSubresourceLayout2,
) callconv(.c) void;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_MEMORY_MAP_FAILED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkMapMemory2 = fn (
    device: VkDevice,
    pMemoryMapInfo: *const VkMemoryMapInfo,
    ppData: **anyopaque,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_MEMORY_MAP_FAILED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkUnmapMemory2 = fn (
    device: VkDevice,
    pMemoryUnmapInfo: *const VkMemoryUnmapInfo,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS,VK_INCOMPATIBLE_SHADER_BINARY_EXT
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: true
pub const vkCreateShadersEXT = fn (
    device: VkDevice,
    createInfoCount: u32,
    // Length expression: createInfoCount
    pCreateInfos: [*]const VkShaderCreateInfoEXT,
    pAllocator: ?*const VkAllocationCallbacks,
    // Length expression: createInfoCount
    pShaders: [*]VkShaderEXT,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkDestroyShaderEXT = fn (
    device: VkDevice,
    shader: VkShaderEXT,
    pAllocator: ?*const VkAllocationCallbacks,
) callconv(.c) void;
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetShaderBinaryDataEXT = fn (
    device: VkDevice,
    shader: VkShaderEXT,
    pDataSize: *u64,
    // Length expression: pDataSize
    pData: ?*anyopaque,
) callconv(.c) VkResult;
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdBindShadersEXT = fn (
    commandBuffer: VkCommandBuffer,
    stageCount: u32,
    // Length expression: stageCount
    pStages: [*]const VkShaderStageFlags,
    // Length expression: stageCount
    pShaders: [*]const VkShaderEXT,
) callconv(.c) void;
// Success codes: VK_SUCCESS,VK_NOT_READY
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkSetSwapchainPresentTimingQueueSizeEXT = fn (
    device: VkDevice,
    swapchain: VkSwapchainKHR,
    size: u32,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS,VK_NOT_READY
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetSwapchainTimingPropertiesEXT = fn (
    device: VkDevice,
    swapchain: VkSwapchainKHR,
    pSwapchainTimingProperties: *VkSwapchainTimingPropertiesEXT,
    pSwapchainTimingPropertiesCounter: ?*u64,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetSwapchainTimeDomainPropertiesEXT = fn (
    device: VkDevice,
    swapchain: VkSwapchainKHR,
    pSwapchainTimeDomainProperties: *VkSwapchainTimeDomainPropertiesEXT,
    pTimeDomainsCounter: ?*u64,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_DEVICE_LOST,VK_ERROR_OUT_OF_DATE_KHR,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetPastPresentationTimingEXT = fn (
    device: VkDevice,
    pPastPresentationTimingInfo: *const VkPastPresentationTimingInfoEXT,
    pPastPresentationTimingProperties: *VkPastPresentationTimingPropertiesEXT,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_INVALID_EXTERNAL_HANDLE_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetScreenBufferPropertiesQNX = fn (
    device: VkDevice,
    buffer: *const _screen_buffer,
    pProperties: *VkScreenBufferPropertiesQNX,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR = fn (
    physicalDevice: VkPhysicalDevice,
    pPropertyCount: *u32,
    // Length expression: pPropertyCount
    pProperties: ?[*]VkCooperativeMatrixPropertiesKHR,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetExecutionGraphPipelineScratchSizeAMDX = fn (
    device: VkDevice,
    executionGraph: VkPipeline,
    pSizeInfo: *VkExecutionGraphPipelineScratchSizeAMDX,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetExecutionGraphPipelineNodeIndexAMDX = fn (
    device: VkDevice,
    executionGraph: VkPipeline,
    pNodeInfo: *const VkPipelineShaderStageNodeCreateInfoAMDX,
    pNodeIndex: *u32,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS,VK_PIPELINE_COMPILE_REQUIRED_EXT
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: true
pub const vkCreateExecutionGraphPipelinesAMDX = fn (
    device: VkDevice,
    pipelineCache: VkPipelineCache,
    createInfoCount: u32,
    // Length expression: createInfoCount
    pCreateInfos: [*]const VkExecutionGraphPipelineCreateInfoAMDX,
    pAllocator: ?*const VkAllocationCallbacks,
    // Length expression: createInfoCount
    pPipelines: [*]VkPipeline,
) callconv(.c) VkResult;
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT
// Render pass: both
// Command buffer levels: primary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdInitializeGraphScratchMemoryAMDX = fn (
    commandBuffer: VkCommandBuffer,
    executionGraph: VkPipeline,
    scratch: u64,
    scratchSize: u64,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT
// Render pass: both
// Command buffer levels: primary
// Conditional rendering: true
// Can be used without queues: false
pub const vkCmdDispatchGraphAMDX = fn (
    commandBuffer: VkCommandBuffer,
    scratch: u64,
    scratchSize: u64,
    pCountInfo: *const VkDispatchGraphCountInfoAMDX,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT
// Render pass: both
// Command buffer levels: primary
// Conditional rendering: true
// Can be used without queues: false
pub const vkCmdDispatchGraphIndirectAMDX = fn (
    commandBuffer: VkCommandBuffer,
    scratch: u64,
    scratchSize: u64,
    pCountInfo: *const VkDispatchGraphCountInfoAMDX,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT
// Render pass: both
// Command buffer levels: primary
// Conditional rendering: true
// Can be used without queues: false
pub const vkCmdDispatchGraphIndirectCountAMDX = fn (
    commandBuffer: VkCommandBuffer,
    scratch: u64,
    scratchSize: u64,
    countInfo: u64,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdBindDescriptorSets2 = fn (
    commandBuffer: VkCommandBuffer,
    pBindDescriptorSetsInfo: *const VkBindDescriptorSetsInfo,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdPushConstants2 = fn (
    commandBuffer: VkCommandBuffer,
    pPushConstantsInfo: *const VkPushConstantsInfo,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdPushDescriptorSet2 = fn (
    commandBuffer: VkCommandBuffer,
    pPushDescriptorSetInfo: *const VkPushDescriptorSetInfo,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdPushDescriptorSetWithTemplate2 = fn (
    commandBuffer: VkCommandBuffer,
    pPushDescriptorSetWithTemplateInfo: *const VkPushDescriptorSetWithTemplateInfo,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT,VK_QUEUE_DATA_GRAPH_BIT_ARM
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetDescriptorBufferOffsets2EXT = fn (
    commandBuffer: VkCommandBuffer,
    pSetDescriptorBufferOffsetsInfo: *const VkSetDescriptorBufferOffsetsInfoEXT,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdBindDescriptorBufferEmbeddedSamplers2EXT = fn (
    commandBuffer: VkCommandBuffer,
    pBindDescriptorBufferEmbeddedSamplersInfo: *const VkBindDescriptorBufferEmbeddedSamplersInfoEXT,
) callconv(.c) void;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkSetLatencySleepModeNV = fn (
    device: VkDevice,
    swapchain: VkSwapchainKHR,
    pSleepModeInfo: *const VkLatencySleepModeInfoNV,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkLatencySleepNV = fn (
    device: VkDevice,
    swapchain: VkSwapchainKHR,
    pSleepInfo: *const VkLatencySleepInfoNV,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkSetLatencyMarkerNV = fn (
    device: VkDevice,
    swapchain: VkSwapchainKHR,
    pLatencyMarkerInfo: *const VkSetLatencyMarkerInfoNV,
) callconv(.c) void;
// Can be used without queues: false
pub const vkGetLatencyTimingsNV = fn (
    device: VkDevice,
    swapchain: VkSwapchainKHR,
    pLatencyMarkerInfo: *VkGetLatencyMarkerInfoNV,
) callconv(.c) void;
// Can be used without queues: false
pub const vkQueueNotifyOutOfBandNV = fn (
    queue: VkQueue,
    pQueueTypeInfo: *const VkOutOfBandQueueTypeInfoNV,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: inside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetRenderingAttachmentLocations = fn (
    commandBuffer: VkCommandBuffer,
    pLocationInfo: *const VkRenderingAttachmentLocationInfo,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: inside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetRenderingInputAttachmentIndices = fn (
    commandBuffer: VkCommandBuffer,
    pInputAttachmentIndexInfo: *const VkRenderingInputAttachmentIndexInfo,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetDepthClampRangeEXT = fn (
    commandBuffer: VkCommandBuffer,
    depthClampMode: VkDepthClampModeEXT,
    pDepthClampRange: ?*const VkDepthClampRangeEXT,
) callconv(.c) void;
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV = fn (
    physicalDevice: VkPhysicalDevice,
    pPropertyCount: *u32,
    // Length expression: pPropertyCount
    pProperties: ?[*]VkCooperativeMatrixFlexibleDimensionsPropertiesNV,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetMemoryMetalHandleEXT = fn (
    device: VkDevice,
    pGetMetalHandleInfo: *const VkMemoryGetMetalHandleInfoEXT,
    pHandle: **anyopaque,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_INVALID_EXTERNAL_HANDLE,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetMemoryMetalHandlePropertiesEXT = fn (
    device: VkDevice,
    handleType: VkExternalMemoryHandleTypeFlags,
    pHandle: *const anyopaque,
    pMemoryMetalHandleProperties: *VkMemoryMetalHandlePropertiesEXT,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetPhysicalDeviceCooperativeVectorPropertiesNV = fn (
    physicalDevice: VkPhysicalDevice,
    pPropertyCount: *u32,
    // Length expression: pPropertyCount
    pProperties: ?[*]VkCooperativeVectorPropertiesNV,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkConvertCooperativeVectorMatrixNV = fn (
    device: VkDevice,
    pInfo: *const VkConvertCooperativeVectorMatrixInfoNV,
) callconv(.c) VkResult;
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdConvertCooperativeVectorMatrixNV = fn (
    commandBuffer: VkCommandBuffer,
    infoCount: u32,
    // Length expression: infoCount
    pInfos: [*]const VkConvertCooperativeVectorMatrixInfoNV,
) callconv(.c) void;
// Queues: VK_QUEUE_COMPUTE_BIT
// Render pass: inside
// Command buffer levels: primary,secondary
// Conditional rendering: true
// Can be used without queues: false
pub const vkCmdDispatchTileQCOM = fn (
    commandBuffer: VkCommandBuffer,
    pDispatchTileInfo: *const VkDispatchTileInfoQCOM,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT
// Render pass: inside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdBeginPerTileExecutionQCOM = fn (
    commandBuffer: VkCommandBuffer,
    pPerTileBeginInfo: *const VkPerTileBeginInfoQCOM,
) callconv(.c) void;
// Queues: VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT
// Render pass: inside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdEndPerTileExecutionQCOM = fn (
    commandBuffer: VkCommandBuffer,
    pPerTileEndInfo: *const VkPerTileEndInfoQCOM,
) callconv(.c) void;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateExternalComputeQueueNV = fn (
    device: VkDevice,
    pCreateInfo: *const VkExternalComputeQueueCreateInfoNV,
    pAllocator: ?*const VkAllocationCallbacks,
    pExternalQueue: *VkExternalComputeQueueNV,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkDestroyExternalComputeQueueNV = fn (
    device: VkDevice,
    externalQueue: VkExternalComputeQueueNV,
    pAllocator: ?*const VkAllocationCallbacks,
) callconv(.c) void;
// Can be used without queues: false
pub const vkGetExternalComputeQueueDataNV = fn (
    externalQueue: VkExternalComputeQueueNV,
    params: *VkExternalComputeQueueDataParamsNV,
    pData: *anyopaque,
) callconv(.c) void;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateTensorARM = fn (
    device: VkDevice,
    pCreateInfo: *const VkTensorCreateInfoARM,
    pAllocator: ?*const VkAllocationCallbacks,
    pTensor: *VkTensorARM,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkDestroyTensorARM = fn (
    device: VkDevice,
    tensor: VkTensorARM,
    pAllocator: ?*const VkAllocationCallbacks,
) callconv(.c) void;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateTensorViewARM = fn (
    device: VkDevice,
    pCreateInfo: *const VkTensorViewCreateInfoARM,
    pAllocator: ?*const VkAllocationCallbacks,
    pView: *VkTensorViewARM,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkDestroyTensorViewARM = fn (
    device: VkDevice,
    tensorView: VkTensorViewARM,
    pAllocator: ?*const VkAllocationCallbacks,
) callconv(.c) void;
// Can be used without queues: false
pub const vkGetTensorMemoryRequirementsARM = fn (
    device: VkDevice,
    pInfo: *const VkTensorMemoryRequirementsInfoARM,
    pMemoryRequirements: *VkMemoryRequirements2,
) callconv(.c) void;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkBindTensorMemoryARM = fn (
    device: VkDevice,
    bindInfoCount: u32,
    // Length expression: bindInfoCount
    pBindInfos: [*]const VkBindTensorMemoryInfoARM,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkGetDeviceTensorMemoryRequirementsARM = fn (
    device: VkDevice,
    pInfo: *const VkDeviceTensorMemoryRequirementsARM,
    pMemoryRequirements: *VkMemoryRequirements2,
) callconv(.c) void;
// Queues: VK_QUEUE_TRANSFER_BIT,VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdCopyTensorARM = fn (
    commandBuffer: VkCommandBuffer,
    pCopyTensorInfo: *const VkCopyTensorInfoARM,
) callconv(.c) void;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetTensorOpaqueCaptureDescriptorDataARM = fn (
    device: VkDevice,
    pInfo: *const VkTensorCaptureDescriptorDataInfoARM,
    pData: *anyopaque,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetTensorViewOpaqueCaptureDescriptorDataARM = fn (
    device: VkDevice,
    pInfo: *const VkTensorViewCaptureDescriptorDataInfoARM,
    pData: *anyopaque,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkGetPhysicalDeviceExternalTensorPropertiesARM = fn (
    physicalDevice: VkPhysicalDevice,
    pExternalTensorInfo: *const VkPhysicalDeviceExternalTensorInfoARM,
    pExternalTensorProperties: *VkExternalTensorPropertiesARM,
) callconv(.c) void;
// Success codes: VK_SUCCESS,VK_PIPELINE_COMPILE_REQUIRED_EXT
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateDataGraphPipelinesARM = fn (
    device: VkDevice,
    deferredOperation: VkDeferredOperationKHR,
    pipelineCache: VkPipelineCache,
    createInfoCount: u32,
    // Length expression: createInfoCount
    pCreateInfos: [*]const VkDataGraphPipelineCreateInfoARM,
    pAllocator: ?*const VkAllocationCallbacks,
    // Length expression: createInfoCount
    pPipelines: [*]VkPipeline,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkCreateDataGraphPipelineSessionARM = fn (
    device: VkDevice,
    pCreateInfo: *const VkDataGraphPipelineSessionCreateInfoARM,
    pAllocator: ?*const VkAllocationCallbacks,
    pSession: *VkDataGraphPipelineSessionARM,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetDataGraphPipelineSessionBindPointRequirementsARM = fn (
    device: VkDevice,
    pInfo: *const VkDataGraphPipelineSessionBindPointRequirementsInfoARM,
    pBindPointRequirementCount: *u32,
    // Length expression: pBindPointRequirementCount
    pBindPointRequirements: ?[*]VkDataGraphPipelineSessionBindPointRequirementARM,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkGetDataGraphPipelineSessionMemoryRequirementsARM = fn (
    device: VkDevice,
    pInfo: *const VkDataGraphPipelineSessionMemoryRequirementsInfoARM,
    pMemoryRequirements: *VkMemoryRequirements2,
) callconv(.c) void;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkBindDataGraphPipelineSessionMemoryARM = fn (
    device: VkDevice,
    bindInfoCount: u32,
    // Length expression: bindInfoCount
    pBindInfos: [*]const VkBindDataGraphPipelineSessionMemoryInfoARM,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkDestroyDataGraphPipelineSessionARM = fn (
    device: VkDevice,
    session: VkDataGraphPipelineSessionARM,
    pAllocator: ?*const VkAllocationCallbacks,
) callconv(.c) void;
// Queues: VK_QUEUE_DATA_GRAPH_BIT_ARM
// Render pass: outside
// Command buffer levels: primary,secondary
// Conditional rendering: true
// Can be used without queues: false
pub const vkCmdDispatchDataGraphARM = fn (
    commandBuffer: VkCommandBuffer,
    session: VkDataGraphPipelineSessionARM,
    pInfo: ?*const VkDataGraphPipelineDispatchInfoARM,
) callconv(.c) void;
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetDataGraphPipelineAvailablePropertiesARM = fn (
    device: VkDevice,
    pPipelineInfo: *const VkDataGraphPipelineInfoARM,
    pPropertiesCount: *u32,
    // Length expression: pPropertiesCount
    pProperties: ?[*]VkDataGraphPipelinePropertyARM,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetDataGraphPipelinePropertiesARM = fn (
    device: VkDevice,
    pPipelineInfo: *const VkDataGraphPipelineInfoARM,
    propertiesCount: u32,
    // Length expression: propertiesCount
    pProperties: [*]VkDataGraphPipelinePropertyQueryResultARM,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetPhysicalDeviceQueueFamilyDataGraphPropertiesARM = fn (
    physicalDevice: VkPhysicalDevice,
    queueFamilyIndex: u32,
    pQueueFamilyDataGraphPropertyCount: *u32,
    // Length expression: pQueueFamilyDataGraphPropertyCount
    pQueueFamilyDataGraphProperties: ?[*]VkQueueFamilyDataGraphPropertiesARM,
) callconv(.c) VkResult;
// Can be used without queues: false
pub const vkGetPhysicalDeviceQueueFamilyDataGraphProcessingEnginePropertiesARM = fn (
    physicalDevice: VkPhysicalDevice,
    pQueueFamilyDataGraphProcessingEngineInfo: *const VkPhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARM,
    pQueueFamilyDataGraphProcessingEngineProperties: *VkQueueFamilyDataGraphProcessingEnginePropertiesARM,
) callconv(.c) void;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INVALID_EXTERNAL_HANDLE_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetNativeBufferPropertiesOHOS = fn (
    device: VkDevice,
    buffer: *const OH_NativeBuffer,
    pProperties: *VkNativeBufferPropertiesOHOS,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetMemoryNativeBufferOHOS = fn (
    device: VkDevice,
    pInfo: *const VkMemoryGetNativeBufferInfoOHOS,
    pBuffer: **OH_NativeBuffer,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkGetSwapchainGrallocUsageOHOS = fn (
    device: VkDevice,
    format: VkFormat,
    imageUsage: VkImageUsageFlags,
    grallocUsage: *u64,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkAcquireImageOHOS = fn (
    device: VkDevice,
    image: VkImage,
    nativeFenceFd: i32,
    semaphore: VkSemaphore,
    fence: VkFence,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS
// Error codes: VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkQueueSignalReleaseImageOHOS = fn (
    queue: VkQueue,
    waitSemaphoreCount: u32,
    // Length expression: waitSemaphoreCount
    pWaitSemaphores: [*]const VkSemaphore,
    image: VkImage,
    pNativeFenceFd: *i32,
) callconv(.c) VkResult;
// Success codes: VK_SUCCESS,VK_INCOMPLETE
// Error codes: VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED
// Can be used without queues: false
pub const vkEnumeratePhysicalDeviceQueueFamilyPerformanceCountersByRegionARM = fn (
    physicalDevice: VkPhysicalDevice,
    queueFamilyIndex: u32,
    pCounterCount: *u32,
    // Length expression: pCounterCount
    pCounters: ?[*]VkPerformanceCounterARM,
    // Length expression: pCounterCount
    pCounterDescriptions: ?[*]VkPerformanceCounterDescriptionARM,
) callconv(.c) VkResult;
// Queues: VK_QUEUE_COMPUTE_BIT
// Render pass: both
// Command buffer levels: primary,secondary
// Conditional rendering: false
// Can be used without queues: false
pub const vkCmdSetComputeOccupancyPriorityNV = fn (
    commandBuffer: VkCommandBuffer,
    pParameters: *const VkComputeOccupancyPriorityParametersNV,
) callconv(.c) void;
// Can be used without queues: false
pub const vkInternalAllocationNotification = fn (
    pUserData: *anyopaque,
    size: u64,
    allocationType: VkInternalAllocationType,
    allocationScope: VkSystemAllocationScope,
) callconv(.c) void;
// Can be used without queues: false
pub const vkInternalFreeNotification = fn (
    pUserData: *anyopaque,
    size: u64,
    allocationType: VkInternalAllocationType,
    allocationScope: VkSystemAllocationScope,
) callconv(.c) void;
// Can be used without queues: false
pub const vkReallocationFunction = fn (
    pUserData: *anyopaque,
    pOriginal: *anyopaque,
    size: u64,
    alignment: u64,
    allocationScope: VkSystemAllocationScope,
) callconv(.c) ?[*]u8;
// Can be used without queues: false
pub const vkAllocationFunction = fn (
    pUserData: *anyopaque,
    size: u64,
    alignment: u64,
    allocationScope: VkSystemAllocationScope,
) callconv(.c) ?[*]u8;
// Can be used without queues: false
pub const vkFreeFunction = fn (
    pUserData: *anyopaque,
    pMemory: *anyopaque,
) callconv(.c) void;
// Can be used without queues: false
pub const vkVoidFunction = fn (
    pUserData: *anyopaque,
    pMemory: *anyopaque,
) callconv(.c) void;
// Can be used without queues: false
pub const vkDebugReportCallbackEXT = fn (
    flags: VkDebugReportFlagsEXT,
    objectType: VkDebugReportObjectTypeEXT,
    object: u64,
    location: u64,
    messageCode: i32,
    pLayerPrefix: *const u8,
    pMessage: *const u8,
    pUserData: *anyopaque,
) callconv(.c) u32;
// Can be used without queues: false
pub const vkDebugUtilsMessengerCallbackEXT = fn (
    messageSeverity: VkDebugUtilsMessageSeverityFlagsEXT,
    messageTypes: VkDebugUtilsMessageTypeFlagsEXT,
    pCallbackData: *const VkDebugUtilsMessengerCallbackDataEXT,
    pUserData: *anyopaque,
) callconv(.c) u32;
// Can be used without queues: false
pub const vkFaultCallbackFunction = fn (
    unrecordedFaults: u32,
    faultCount: u32,
    pFaults: *const anyopaque,
) callconv(.c) void;
// Can be used without queues: false
pub const vkDeviceMemoryReportCallbackEXT = fn (
    pCallbackData: *const VkDeviceMemoryReportCallbackDataEXT,
    pUserData: *const anyopaque,
) callconv(.c) void;
// Can be used without queues: false
pub const vkGetInstanceProcAddrLUNARG = fn (
    instance: VkInstance,
    pName: *const u8,
) callconv(.c) ?*const vkVoidFunction;

// Aliases
pub const char = u8;
pub const uint8_t = u8;
pub const uint16_t = u16;
pub const int32_t = i32;
pub const uint32_t = u32;
pub const int64_t = i64;
pub const size_t = u64;
pub const uint64_t = u64;
pub const float = f32;
pub const double = f64;
pub const u8_slice = [*]u8;
pub const VkSampleMask = u32;
pub const VkBool32 = u32;
pub const VkFlags = u32;
pub const VkFlags64 = u64;
pub const VkDeviceSize = u64;
pub const VkDeviceAddress = u64;
pub const VkRemoteAddressNV = *anyopaque;
pub const VkDescriptorUpdateTemplateKHR = VkDescriptorUpdateTemplate;
pub const VkSamplerYcbcrConversionKHR = VkSamplerYcbcrConversion;
pub const VkPrivateDataSlotEXT = VkPrivateDataSlot;
pub const VkFramebufferCreateFlagBits = VkFramebufferCreateFlags;
pub const VkQueryPoolCreateFlagBits = VkQueryPoolCreateFlags;
pub const VkRenderPassCreateFlagBits = VkRenderPassCreateFlags;
pub const VkSamplerCreateFlagBits = VkSamplerCreateFlags;
pub const VkPipelineLayoutCreateFlagBits = VkPipelineLayoutCreateFlags;
pub const VkPipelineCacheCreateFlagBits = VkPipelineCacheCreateFlags;
pub const VkPipelineDepthStencilStateCreateFlagBits = VkPipelineDepthStencilStateCreateFlags;
pub const VkPipelineColorBlendStateCreateFlagBits = VkPipelineColorBlendStateCreateFlags;
pub const VkPipelineShaderStageCreateFlagBits = VkPipelineShaderStageCreateFlags;
pub const VkDescriptorSetLayoutCreateFlagBits = VkDescriptorSetLayoutCreateFlags;
pub const VkInstanceCreateFlagBits = VkInstanceCreateFlags;
pub const VkDeviceQueueCreateFlagBits = VkDeviceQueueCreateFlags;
pub const VkQueueFlagBits = VkQueueFlags;
pub const VkMemoryPropertyFlagBits = VkMemoryPropertyFlags;
pub const VkMemoryHeapFlagBits = VkMemoryHeapFlags;
pub const VkAccessFlagBits = VkAccessFlags;
pub const VkBufferUsageFlagBits = VkBufferUsageFlags;
pub const VkBufferCreateFlagBits = VkBufferCreateFlags;
pub const VkShaderStageFlagBits = VkShaderStageFlags;
pub const VkImageUsageFlagBits = VkImageUsageFlags;
pub const VkImageCreateFlagBits = VkImageCreateFlags;
pub const VkImageViewCreateFlagBits = VkImageViewCreateFlags;
pub const VkPipelineCreateFlagBits = VkPipelineCreateFlags;
pub const VkColorComponentFlagBits = VkColorComponentFlags;
pub const VkFenceCreateFlagBits = VkFenceCreateFlags;
pub const VkFormatFeatureFlagBits = VkFormatFeatureFlags;
pub const VkQueryControlFlagBits = VkQueryControlFlags;
pub const VkQueryResultFlagBits = VkQueryResultFlags;
pub const VkEventCreateFlagBits = VkEventCreateFlags;
pub const VkCommandPoolCreateFlagBits = VkCommandPoolCreateFlags;
pub const VkCommandPoolResetFlagBits = VkCommandPoolResetFlags;
pub const VkCommandBufferResetFlagBits = VkCommandBufferResetFlags;
pub const VkCommandBufferUsageFlagBits = VkCommandBufferUsageFlags;
pub const VkQueryPipelineStatisticFlagBits = VkQueryPipelineStatisticFlags;
pub const VkMemoryMapFlagBits = VkMemoryMapFlags;
pub const VkMemoryUnmapFlagBits = VkMemoryUnmapFlags;
pub const VkImageAspectFlagBits = VkImageAspectFlags;
pub const VkSparseMemoryBindFlagBits = VkSparseMemoryBindFlags;
pub const VkSparseImageFormatFlagBits = VkSparseImageFormatFlags;
pub const VkSubpassDescriptionFlagBits = VkSubpassDescriptionFlags;
pub const VkPipelineStageFlagBits = VkPipelineStageFlags;
pub const VkSampleCountFlagBits = VkSampleCountFlags;
pub const VkAttachmentDescriptionFlagBits = VkAttachmentDescriptionFlags;
pub const VkStencilFaceFlagBits = VkStencilFaceFlags;
pub const VkCullModeFlagBits = VkCullModeFlags;
pub const VkDescriptorPoolCreateFlagBits = VkDescriptorPoolCreateFlags;
pub const VkDependencyFlagBits = VkDependencyFlags;
pub const VkSubgroupFeatureFlagBits = VkSubgroupFeatureFlags;
pub const VkIndirectCommandsLayoutUsageFlagBitsNV = VkIndirectCommandsLayoutUsageFlagsNV;
pub const VkIndirectStateFlagBitsNV = VkIndirectStateFlagsNV;
pub const VkGeometryFlagBitsKHR = VkGeometryFlagsKHR;
pub const VkGeometryInstanceFlagBitsKHR = VkGeometryInstanceFlagsKHR;
pub const VkClusterAccelerationStructureGeometryFlagBitsNV = VkClusterAccelerationStructureGeometryFlagsNV;
pub const VkClusterAccelerationStructureClusterFlagBitsNV = VkClusterAccelerationStructureClusterFlagsNV;
pub const VkClusterAccelerationStructureAddressResolutionFlagBitsNV = VkClusterAccelerationStructureAddressResolutionFlagsNV;
pub const VkBuildAccelerationStructureFlagBitsKHR = VkBuildAccelerationStructureFlagsKHR;
pub const VkAccelerationStructureCreateFlagBitsKHR = VkAccelerationStructureCreateFlagsKHR;
pub const VkPipelineCreationFeedbackFlagBits = VkPipelineCreationFeedbackFlags;
pub const VkPerformanceCounterDescriptionFlagBitsKHR = VkPerformanceCounterDescriptionFlagsKHR;
pub const VkAcquireProfilingLockFlagBitsKHR = VkAcquireProfilingLockFlagsKHR;
pub const VkSemaphoreWaitFlagBits = VkSemaphoreWaitFlags;
pub const VkPipelineCompilerControlFlagBitsAMD = VkPipelineCompilerControlFlagsAMD;
pub const VkShaderCorePropertiesFlagBitsAMD = VkShaderCorePropertiesFlagsAMD;
pub const VkDeviceDiagnosticsConfigFlagBitsNV = VkDeviceDiagnosticsConfigFlagsNV;
pub const VkRefreshObjectFlagBitsKHR = VkRefreshObjectFlagsKHR;
pub const VkAccessFlagBits2 = VkAccessFlags2;
pub const VkPipelineStageFlagBits2 = VkPipelineStageFlags2;
pub const VkFormatFeatureFlagBits2 = VkFormatFeatureFlags2;
pub const VkRenderingFlagBits = VkRenderingFlags;
pub const VkMemoryDecompressionMethodFlagBitsEXT = VkMemoryDecompressionMethodFlagsEXT;
pub const VkBuildMicromapFlagBitsEXT = VkBuildMicromapFlagsEXT;
pub const VkMicromapCreateFlagBitsEXT = VkMicromapCreateFlagsEXT;
pub const VkIndirectCommandsLayoutUsageFlagBitsEXT = VkIndirectCommandsLayoutUsageFlagsEXT;
pub const VkIndirectCommandsInputModeFlagBitsEXT = VkIndirectCommandsInputModeFlagsEXT;
pub const VkPipelineCreateFlagBits2 = VkPipelineCreateFlags2;
pub const VkBufferUsageFlagBits2 = VkBufferUsageFlags2;
pub const VkAddressCopyFlagBitsKHR = VkAddressCopyFlagsKHR;
pub const VkTensorCreateFlagBitsARM = VkTensorCreateFlagsARM;
pub const VkTensorUsageFlagBitsARM = VkTensorUsageFlagsARM;
pub const VkTensorViewCreateFlagBitsARM = VkTensorViewCreateFlagsARM;
pub const VkDataGraphPipelineSessionCreateFlagBitsARM = VkDataGraphPipelineSessionCreateFlagsARM;
pub const VkDataGraphPipelineDispatchFlagBitsARM = VkDataGraphPipelineDispatchFlagsARM;
pub const VkVideoEncodeRgbModelConversionFlagBitsVALVE = VkVideoEncodeRgbModelConversionFlagsVALVE;
pub const VkVideoEncodeRgbRangeCompressionFlagBitsVALVE = VkVideoEncodeRgbRangeCompressionFlagsVALVE;
pub const VkVideoEncodeRgbChromaOffsetFlagBitsVALVE = VkVideoEncodeRgbChromaOffsetFlagsVALVE;
pub const VkCompositeAlphaFlagBitsKHR = VkCompositeAlphaFlagsKHR;
pub const VkDisplayPlaneAlphaFlagBitsKHR = VkDisplayPlaneAlphaFlagsKHR;
pub const VkSurfaceTransformFlagBitsKHR = VkSurfaceTransformFlagsKHR;
pub const VkSwapchainCreateFlagBitsKHR = VkSwapchainCreateFlagsKHR;
pub const VkPeerMemoryFeatureFlagBits = VkPeerMemoryFeatureFlags;
pub const VkMemoryAllocateFlagBits = VkMemoryAllocateFlags;
pub const VkDeviceGroupPresentModeFlagBitsKHR = VkDeviceGroupPresentModeFlagsKHR;
pub const VkDebugReportFlagBitsEXT = VkDebugReportFlagsEXT;
pub const VkExternalMemoryHandleTypeFlagBitsNV = VkExternalMemoryHandleTypeFlagsNV;
pub const VkClusterAccelerationStructureIndexFormatFlagBitsNV = VkClusterAccelerationStructureIndexFormatFlagsNV;
pub const VkExternalMemoryFeatureFlagBitsNV = VkExternalMemoryFeatureFlagsNV;
pub const VkExternalMemoryHandleTypeFlagBits = VkExternalMemoryHandleTypeFlags;
pub const VkExternalMemoryFeatureFlagBits = VkExternalMemoryFeatureFlags;
pub const VkExternalSemaphoreHandleTypeFlagBits = VkExternalSemaphoreHandleTypeFlags;
pub const VkExternalSemaphoreFeatureFlagBits = VkExternalSemaphoreFeatureFlags;
pub const VkSemaphoreImportFlagBits = VkSemaphoreImportFlags;
pub const VkExternalFenceHandleTypeFlagBits = VkExternalFenceHandleTypeFlags;
pub const VkExternalFenceFeatureFlagBits = VkExternalFenceFeatureFlags;
pub const VkFenceImportFlagBits = VkFenceImportFlags;
pub const VkSurfaceCounterFlagBitsEXT = VkSurfaceCounterFlagsEXT;
pub const VkDebugUtilsMessageSeverityFlagBitsEXT = VkDebugUtilsMessageSeverityFlagsEXT;
pub const VkDebugUtilsMessageTypeFlagBitsEXT = VkDebugUtilsMessageTypeFlagsEXT;
pub const VkDescriptorBindingFlagBits = VkDescriptorBindingFlags;
pub const VkConditionalRenderingFlagBitsEXT = VkConditionalRenderingFlagsEXT;
pub const VkResolveModeFlagBits = VkResolveModeFlags;
pub const VkSwapchainImageUsageFlagBitsANDROID = VkSwapchainImageUsageFlagsANDROID;
pub const VkToolPurposeFlagBits = VkToolPurposeFlags;
pub const VkSubmitFlagBits = VkSubmitFlags;
pub const VkHostImageCopyFlagBits = VkHostImageCopyFlags;
pub const VkPartitionedAccelerationStructureInstanceFlagBitsNV = VkPartitionedAccelerationStructureInstanceFlagsNV;
pub const VkImageConstraintsInfoFlagBitsFUCHSIA = VkImageConstraintsInfoFlagsFUCHSIA;
pub const VkGraphicsPipelineLibraryFlagBitsEXT = VkGraphicsPipelineLibraryFlagsEXT;
pub const VkImageCompressionFlagBitsEXT = VkImageCompressionFlagsEXT;
pub const VkImageCompressionFixedRateFlagBitsEXT = VkImageCompressionFixedRateFlagsEXT;
pub const VkExportMetalObjectTypeFlagBitsEXT = VkExportMetalObjectTypeFlagsEXT;
pub const VkRenderingAttachmentFlagBitsKHR = VkRenderingAttachmentFlagsKHR;
pub const VkResolveImageFlagBitsKHR = VkResolveImageFlagsKHR;
pub const VkDeviceAddressBindingFlagBitsEXT = VkDeviceAddressBindingFlagsEXT;
pub const VkOpticalFlowGridSizeFlagBitsNV = VkOpticalFlowGridSizeFlagsNV;
pub const VkOpticalFlowUsageFlagBitsNV = VkOpticalFlowUsageFlagsNV;
pub const VkOpticalFlowSessionCreateFlagBitsNV = VkOpticalFlowSessionCreateFlagsNV;
pub const VkOpticalFlowExecuteFlagBitsNV = VkOpticalFlowExecuteFlagsNV;
pub const VkFrameBoundaryFlagBitsEXT = VkFrameBoundaryFlagsEXT;
pub const VkPresentScalingFlagBitsKHR = VkPresentScalingFlagsKHR;
pub const VkPresentGravityFlagBitsKHR = VkPresentGravityFlagsKHR;
pub const VkShaderCreateFlagBitsEXT = VkShaderCreateFlagsEXT;
pub const VkTileShadingRenderPassFlagBitsQCOM = VkTileShadingRenderPassFlagsQCOM;
pub const VkPhysicalDeviceSchedulingControlsFlagBitsARM = VkPhysicalDeviceSchedulingControlsFlagsARM;
pub const VkPresentStageFlagBitsEXT = VkPresentStageFlagsEXT;
pub const VkPastPresentationTimingFlagBitsEXT = VkPastPresentationTimingFlagsEXT;
pub const VkPresentTimingInfoFlagBitsEXT = VkPresentTimingInfoFlagsEXT;
pub const VkSwapchainImageUsageFlagBitsOHOS = VkSwapchainImageUsageFlagsOHOS;
pub const VkVideoCodecOperationFlagBitsKHR = VkVideoCodecOperationFlagsKHR;
pub const VkVideoCapabilityFlagBitsKHR = VkVideoCapabilityFlagsKHR;
pub const VkVideoSessionCreateFlagBitsKHR = VkVideoSessionCreateFlagsKHR;
pub const VkVideoSessionParametersCreateFlagBitsKHR = VkVideoSessionParametersCreateFlagsKHR;
pub const VkVideoCodingControlFlagBitsKHR = VkVideoCodingControlFlagsKHR;
pub const VkVideoDecodeUsageFlagBitsKHR = VkVideoDecodeUsageFlagsKHR;
pub const VkVideoDecodeCapabilityFlagBitsKHR = VkVideoDecodeCapabilityFlagsKHR;
pub const VkVideoDecodeH264PictureLayoutFlagBitsKHR = VkVideoDecodeH264PictureLayoutFlagsKHR;
pub const VkVideoEncodeFlagBitsKHR = VkVideoEncodeFlagsKHR;
pub const VkVideoEncodeUsageFlagBitsKHR = VkVideoEncodeUsageFlagsKHR;
pub const VkVideoEncodeContentFlagBitsKHR = VkVideoEncodeContentFlagsKHR;
pub const VkVideoEncodeCapabilityFlagBitsKHR = VkVideoEncodeCapabilityFlagsKHR;
pub const VkVideoEncodeFeedbackFlagBitsKHR = VkVideoEncodeFeedbackFlagsKHR;
pub const VkVideoEncodeRateControlModeFlagBitsKHR = VkVideoEncodeRateControlModeFlagsKHR;
pub const VkVideoEncodeIntraRefreshModeFlagBitsKHR = VkVideoEncodeIntraRefreshModeFlagsKHR;
pub const VkVideoChromaSubsamplingFlagBitsKHR = VkVideoChromaSubsamplingFlagsKHR;
pub const VkVideoComponentBitDepthFlagBitsKHR = VkVideoComponentBitDepthFlagsKHR;
pub const VkVideoEncodeH264CapabilityFlagBitsKHR = VkVideoEncodeH264CapabilityFlagsKHR;
pub const VkVideoEncodeH264StdFlagBitsKHR = VkVideoEncodeH264StdFlagsKHR;
pub const VkVideoEncodeH264RateControlFlagBitsKHR = VkVideoEncodeH264RateControlFlagsKHR;
pub const VkVideoEncodeH265CapabilityFlagBitsKHR = VkVideoEncodeH265CapabilityFlagsKHR;
pub const VkVideoEncodeH265StdFlagBitsKHR = VkVideoEncodeH265StdFlagsKHR;
pub const VkVideoEncodeH265RateControlFlagBitsKHR = VkVideoEncodeH265RateControlFlagsKHR;
pub const VkVideoEncodeH265CtbSizeFlagBitsKHR = VkVideoEncodeH265CtbSizeFlagsKHR;
pub const VkVideoEncodeH265TransformBlockSizeFlagBitsKHR = VkVideoEncodeH265TransformBlockSizeFlagsKHR;
pub const VkVideoEncodeAV1CapabilityFlagBitsKHR = VkVideoEncodeAV1CapabilityFlagsKHR;
pub const VkVideoEncodeAV1StdFlagBitsKHR = VkVideoEncodeAV1StdFlagsKHR;
pub const VkVideoEncodeAV1RateControlFlagBitsKHR = VkVideoEncodeAV1RateControlFlagsKHR;
pub const VkVideoEncodeAV1SuperblockSizeFlagBitsKHR = VkVideoEncodeAV1SuperblockSizeFlagsKHR;
pub const VkAccessFlagBits3KHR = VkAccessFlags3KHR;
pub const VkRayTracingInvocationReorderModeNV = VkRayTracingInvocationReorderModeEXT;
pub const VkPrivateDataSlotCreateFlagBitsEXT = VkPrivateDataSlotCreateFlagBits;
pub const VkDescriptorUpdateTemplateTypeKHR = VkDescriptorUpdateTemplateType;
pub const VkPointClippingBehaviorKHR = VkPointClippingBehavior;
pub const VkQueueGlobalPriorityKHR = VkQueueGlobalPriority;
pub const VkQueueGlobalPriorityEXT = VkQueueGlobalPriority;
pub const VkTimeDomainEXT = VkTimeDomainKHR;
pub const VkResolveModeFlagBitsKHR = VkResolveModeFlags;
pub const VkDescriptorBindingFlagBitsEXT = VkDescriptorBindingFlags;
pub const VkSemaphoreTypeKHR = VkSemaphoreType;
pub const VkGeometryFlagBitsNV = VkGeometryFlagsKHR;
pub const VkGeometryInstanceFlagBitsNV = VkGeometryInstanceFlagsKHR;
pub const VkBuildAccelerationStructureFlagBitsNV = VkBuildAccelerationStructureFlagsKHR;
pub const VkCopyAccelerationStructureModeNV = VkCopyAccelerationStructureModeKHR;
pub const VkAccelerationStructureTypeNV = VkAccelerationStructureTypeKHR;
pub const VkGeometryTypeNV = VkGeometryTypeKHR;
pub const VkRayTracingShaderGroupTypeNV = VkRayTracingShaderGroupTypeKHR;
pub const VkPipelineCreationFeedbackFlagBitsEXT = VkPipelineCreationFeedbackFlags;
pub const VkSemaphoreWaitFlagBitsKHR = VkSemaphoreWaitFlags;
pub const VkLineRasterizationModeKHR = VkLineRasterizationMode;
pub const VkLineRasterizationModeEXT = VkLineRasterizationMode;
pub const VkToolPurposeFlagBitsEXT = VkToolPurposeFlags;
pub const VkAccessFlagBits2KHR = VkAccessFlags2;
pub const VkPipelineStageFlagBits2KHR = VkPipelineStageFlags2;
pub const VkHostImageCopyFlagBitsEXT = VkHostImageCopyFlags;
pub const VkFormatFeatureFlagBits2KHR = VkFormatFeatureFlags2;
pub const VkRenderingFlagBitsKHR = VkRenderingFlags;
pub const VkPipelineRobustnessBufferBehaviorEXT = VkPipelineRobustnessBufferBehavior;
pub const VkPipelineRobustnessImageBehaviorEXT = VkPipelineRobustnessImageBehavior;
pub const VkMemoryDecompressionMethodFlagBitsNV = VkMemoryDecompressionMethodFlagsEXT;
pub const VkPipelineCreateFlagBits2KHR = VkPipelineCreateFlags2;
pub const VkBufferUsageFlagBits2KHR = VkBufferUsageFlags2;
pub const VkScopeNV = VkScopeKHR;
pub const VkComponentTypeNV = VkComponentTypeKHR;
pub const VkExternalMemoryHandleTypeFlagBitsKHR = VkExternalMemoryHandleTypeFlags;
pub const VkExternalMemoryFeatureFlagBitsKHR = VkExternalMemoryFeatureFlags;
pub const VkExternalSemaphoreHandleTypeFlagBitsKHR = VkExternalSemaphoreHandleTypeFlags;
pub const VkExternalSemaphoreFeatureFlagBitsKHR = VkExternalSemaphoreFeatureFlags;
pub const VkSemaphoreImportFlagBitsKHR = VkSemaphoreImportFlags;
pub const VkExternalFenceHandleTypeFlagBitsKHR = VkExternalFenceHandleTypeFlags;
pub const VkExternalFenceFeatureFlagBitsKHR = VkExternalFenceFeatureFlags;
pub const VkFenceImportFlagBitsKHR = VkFenceImportFlags;
pub const VkPeerMemoryFeatureFlagBitsKHR = VkPeerMemoryFeatureFlags;
pub const VkMemoryAllocateFlagBitsKHR = VkMemoryAllocateFlags;
pub const VkTessellationDomainOriginKHR = VkTessellationDomainOrigin;
pub const VkSamplerYcbcrModelConversionKHR = VkSamplerYcbcrModelConversion;
pub const VkSamplerYcbcrRangeKHR = VkSamplerYcbcrRange;
pub const VkChromaLocationKHR = VkChromaLocation;
pub const VkSamplerReductionModeEXT = VkSamplerReductionMode;
pub const VkShaderFloatControlsIndependenceKHR = VkShaderFloatControlsIndependence;
pub const VkSubmitFlagBitsKHR = VkSubmitFlags;
pub const VkPresentScalingFlagBitsEXT = VkPresentScalingFlagsKHR;
pub const VkPresentGravityFlagBitsEXT = VkPresentGravityFlagsKHR;
pub const VkMemoryUnmapFlagBitsKHR = VkMemoryUnmapFlags;
pub const VkDriverIdKHR = VkDriverId;
pub const PFN_vkAllocationFunction = *const vkAllocationFunction;
pub const PFN_vkReallocationFunction = *const vkReallocationFunction;
pub const PFN_vkFreeFunction = *const vkFreeFunction;
pub const PFN_vkInternalAllocationNotification = *const vkInternalAllocationNotification;
pub const PFN_vkInternalFreeNotification = *const vkInternalFreeNotification;
pub const VkBufferUsageFlags2CreateInfoKHR = VkBufferUsageFlags2CreateInfo;
pub const VkCopyMemoryIndirectCommandNV = VkCopyMemoryIndirectCommandKHR;
pub const VkCopyMemoryToImageIndirectCommandNV = VkCopyMemoryToImageIndirectCommandKHR;
pub const VkPipelineCreateFlags2CreateInfoKHR = VkPipelineCreateFlags2CreateInfo;
pub const PFN_vkDebugReportCallbackEXT = *const vkDebugReportCallbackEXT;
pub const VkPhysicalDeviceExternalSciBufFeaturesNV = VkPhysicalDeviceExternalMemorySciBufFeaturesNV;
pub const VkDevicePrivateDataCreateInfoEXT = VkDevicePrivateDataCreateInfo;
pub const VkPrivateDataSlotCreateInfoEXT = VkPrivateDataSlotCreateInfo;
pub const VkPhysicalDevicePrivateDataFeaturesEXT = VkPhysicalDevicePrivateDataFeatures;
pub const VkPhysicalDeviceFeatures2KHR = VkPhysicalDeviceFeatures2;
pub const VkPhysicalDeviceProperties2KHR = VkPhysicalDeviceProperties2;
pub const VkFormatProperties2KHR = VkFormatProperties2;
pub const VkImageFormatProperties2KHR = VkImageFormatProperties2;
pub const VkPhysicalDeviceImageFormatInfo2KHR = VkPhysicalDeviceImageFormatInfo2;
pub const VkQueueFamilyProperties2KHR = VkQueueFamilyProperties2;
pub const VkPhysicalDeviceMemoryProperties2KHR = VkPhysicalDeviceMemoryProperties2;
pub const VkSparseImageFormatProperties2KHR = VkSparseImageFormatProperties2;
pub const VkPhysicalDeviceSparseImageFormatInfo2KHR = VkPhysicalDeviceSparseImageFormatInfo2;
pub const VkPhysicalDevicePushDescriptorPropertiesKHR = VkPhysicalDevicePushDescriptorProperties;
pub const VkConformanceVersionKHR = VkConformanceVersion;
pub const VkPhysicalDeviceDriverPropertiesKHR = VkPhysicalDeviceDriverProperties;
pub const VkPhysicalDeviceVariablePointersFeaturesKHR = VkPhysicalDeviceVariablePointersFeatures;
pub const VkPhysicalDeviceVariablePointerFeaturesKHR = VkPhysicalDeviceVariablePointersFeatures;
pub const VkPhysicalDeviceVariablePointerFeatures = VkPhysicalDeviceVariablePointersFeatures;
pub const VkExternalMemoryPropertiesKHR = VkExternalMemoryProperties;
pub const VkPhysicalDeviceExternalImageFormatInfoKHR = VkPhysicalDeviceExternalImageFormatInfo;
pub const VkExternalImageFormatPropertiesKHR = VkExternalImageFormatProperties;
pub const VkPhysicalDeviceExternalBufferInfoKHR = VkPhysicalDeviceExternalBufferInfo;
pub const VkExternalBufferPropertiesKHR = VkExternalBufferProperties;
pub const VkPhysicalDeviceIDPropertiesKHR = VkPhysicalDeviceIDProperties;
pub const VkExternalMemoryImageCreateInfoKHR = VkExternalMemoryImageCreateInfo;
pub const VkExternalMemoryBufferCreateInfoKHR = VkExternalMemoryBufferCreateInfo;
pub const VkExportMemoryAllocateInfoKHR = VkExportMemoryAllocateInfo;
pub const VkPhysicalDeviceExternalSemaphoreInfoKHR = VkPhysicalDeviceExternalSemaphoreInfo;
pub const VkExternalSemaphorePropertiesKHR = VkExternalSemaphoreProperties;
pub const VkExportSemaphoreCreateInfoKHR = VkExportSemaphoreCreateInfo;
pub const VkPhysicalDeviceExternalFenceInfoKHR = VkPhysicalDeviceExternalFenceInfo;
pub const VkExternalFencePropertiesKHR = VkExternalFenceProperties;
pub const VkExportFenceCreateInfoKHR = VkExportFenceCreateInfo;
pub const VkPhysicalDeviceMultiviewFeaturesKHR = VkPhysicalDeviceMultiviewFeatures;
pub const VkPhysicalDeviceMultiviewPropertiesKHR = VkPhysicalDeviceMultiviewProperties;
pub const VkRenderPassMultiviewCreateInfoKHR = VkRenderPassMultiviewCreateInfo;
pub const VkPhysicalDeviceGroupPropertiesKHR = VkPhysicalDeviceGroupProperties;
pub const VkMemoryAllocateFlagsInfoKHR = VkMemoryAllocateFlagsInfo;
pub const VkBindBufferMemoryInfoKHR = VkBindBufferMemoryInfo;
pub const VkBindBufferMemoryDeviceGroupInfoKHR = VkBindBufferMemoryDeviceGroupInfo;
pub const VkBindImageMemoryInfoKHR = VkBindImageMemoryInfo;
pub const VkBindImageMemoryDeviceGroupInfoKHR = VkBindImageMemoryDeviceGroupInfo;
pub const VkDeviceGroupRenderPassBeginInfoKHR = VkDeviceGroupRenderPassBeginInfo;
pub const VkDeviceGroupCommandBufferBeginInfoKHR = VkDeviceGroupCommandBufferBeginInfo;
pub const VkDeviceGroupSubmitInfoKHR = VkDeviceGroupSubmitInfo;
pub const VkDeviceGroupBindSparseInfoKHR = VkDeviceGroupBindSparseInfo;
pub const VkDeviceGroupDeviceCreateInfoKHR = VkDeviceGroupDeviceCreateInfo;
pub const VkDescriptorUpdateTemplateEntryKHR = VkDescriptorUpdateTemplateEntry;
pub const VkDescriptorUpdateTemplateCreateInfoKHR = VkDescriptorUpdateTemplateCreateInfo;
pub const VkInputAttachmentAspectReferenceKHR = VkInputAttachmentAspectReference;
pub const VkRenderPassInputAttachmentAspectCreateInfoKHR = VkRenderPassInputAttachmentAspectCreateInfo;
pub const VkPhysicalDevice16BitStorageFeaturesKHR = VkPhysicalDevice16BitStorageFeatures;
pub const VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR = VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures;
pub const VkBufferMemoryRequirementsInfo2KHR = VkBufferMemoryRequirementsInfo2;
pub const VkDeviceBufferMemoryRequirementsKHR = VkDeviceBufferMemoryRequirements;
pub const VkImageMemoryRequirementsInfo2KHR = VkImageMemoryRequirementsInfo2;
pub const VkImageSparseMemoryRequirementsInfo2KHR = VkImageSparseMemoryRequirementsInfo2;
pub const VkDeviceImageMemoryRequirementsKHR = VkDeviceImageMemoryRequirements;
pub const VkMemoryRequirements2KHR = VkMemoryRequirements2;
pub const VkSparseImageMemoryRequirements2KHR = VkSparseImageMemoryRequirements2;
pub const VkPhysicalDevicePointClippingPropertiesKHR = VkPhysicalDevicePointClippingProperties;
pub const VkMemoryDedicatedRequirementsKHR = VkMemoryDedicatedRequirements;
pub const VkMemoryDedicatedAllocateInfoKHR = VkMemoryDedicatedAllocateInfo;
pub const VkImageViewUsageCreateInfoKHR = VkImageViewUsageCreateInfo;
pub const VkPipelineTessellationDomainOriginStateCreateInfoKHR = VkPipelineTessellationDomainOriginStateCreateInfo;
pub const VkSamplerYcbcrConversionInfoKHR = VkSamplerYcbcrConversionInfo;
pub const VkSamplerYcbcrConversionCreateInfoKHR = VkSamplerYcbcrConversionCreateInfo;
pub const VkBindImagePlaneMemoryInfoKHR = VkBindImagePlaneMemoryInfo;
pub const VkImagePlaneMemoryRequirementsInfoKHR = VkImagePlaneMemoryRequirementsInfo;
pub const VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR = VkPhysicalDeviceSamplerYcbcrConversionFeatures;
pub const VkSamplerYcbcrConversionImageFormatPropertiesKHR = VkSamplerYcbcrConversionImageFormatProperties;
pub const VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT = VkPhysicalDeviceSamplerFilterMinmaxProperties;
pub const VkSamplerReductionModeCreateInfoEXT = VkSamplerReductionModeCreateInfo;
pub const VkPhysicalDeviceInlineUniformBlockFeaturesEXT = VkPhysicalDeviceInlineUniformBlockFeatures;
pub const VkPhysicalDeviceInlineUniformBlockPropertiesEXT = VkPhysicalDeviceInlineUniformBlockProperties;
pub const VkWriteDescriptorSetInlineUniformBlockEXT = VkWriteDescriptorSetInlineUniformBlock;
pub const VkDescriptorPoolInlineUniformBlockCreateInfoEXT = VkDescriptorPoolInlineUniformBlockCreateInfo;
pub const VkImageFormatListCreateInfoKHR = VkImageFormatListCreateInfo;
pub const VkPhysicalDeviceMaintenance3PropertiesKHR = VkPhysicalDeviceMaintenance3Properties;
pub const VkPhysicalDeviceMaintenance4FeaturesKHR = VkPhysicalDeviceMaintenance4Features;
pub const VkPhysicalDeviceMaintenance4PropertiesKHR = VkPhysicalDeviceMaintenance4Properties;
pub const VkPhysicalDeviceMaintenance5FeaturesKHR = VkPhysicalDeviceMaintenance5Features;
pub const VkPhysicalDeviceMaintenance5PropertiesKHR = VkPhysicalDeviceMaintenance5Properties;
pub const VkPhysicalDeviceMaintenance6FeaturesKHR = VkPhysicalDeviceMaintenance6Features;
pub const VkPhysicalDeviceMaintenance6PropertiesKHR = VkPhysicalDeviceMaintenance6Properties;
pub const VkRenderingAreaInfoKHR = VkRenderingAreaInfo;
pub const VkDescriptorSetLayoutSupportKHR = VkDescriptorSetLayoutSupport;
pub const VkPhysicalDeviceShaderDrawParameterFeatures = VkPhysicalDeviceShaderDrawParametersFeatures;
pub const VkPhysicalDeviceShaderFloat16Int8FeaturesKHR = VkPhysicalDeviceShaderFloat16Int8Features;
pub const VkPhysicalDeviceFloat16Int8FeaturesKHR = VkPhysicalDeviceShaderFloat16Int8Features;
pub const VkPhysicalDeviceFloatControlsPropertiesKHR = VkPhysicalDeviceFloatControlsProperties;
pub const VkPhysicalDeviceHostQueryResetFeaturesEXT = VkPhysicalDeviceHostQueryResetFeatures;
pub const VkDeviceQueueGlobalPriorityCreateInfoKHR = VkDeviceQueueGlobalPriorityCreateInfo;
pub const VkDeviceQueueGlobalPriorityCreateInfoEXT = VkDeviceQueueGlobalPriorityCreateInfo;
pub const VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR = VkPhysicalDeviceGlobalPriorityQueryFeatures;
pub const VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT = VkPhysicalDeviceGlobalPriorityQueryFeatures;
pub const VkQueueFamilyGlobalPriorityPropertiesKHR = VkQueueFamilyGlobalPriorityProperties;
pub const VkQueueFamilyGlobalPriorityPropertiesEXT = VkQueueFamilyGlobalPriorityProperties;
pub const PFN_vkDebugUtilsMessengerCallbackEXT = *const vkDebugUtilsMessengerCallbackEXT;
pub const PFN_vkDeviceMemoryReportCallbackEXT = *const vkDeviceMemoryReportCallbackEXT;
pub const VkCalibratedTimestampInfoEXT = VkCalibratedTimestampInfoKHR;
pub const VkPhysicalDeviceDescriptorIndexingFeaturesEXT = VkPhysicalDeviceDescriptorIndexingFeatures;
pub const VkPhysicalDeviceDescriptorIndexingPropertiesEXT = VkPhysicalDeviceDescriptorIndexingProperties;
pub const VkDescriptorSetLayoutBindingFlagsCreateInfoEXT = VkDescriptorSetLayoutBindingFlagsCreateInfo;
pub const VkDescriptorSetVariableDescriptorCountAllocateInfoEXT = VkDescriptorSetVariableDescriptorCountAllocateInfo;
pub const VkDescriptorSetVariableDescriptorCountLayoutSupportEXT = VkDescriptorSetVariableDescriptorCountLayoutSupport;
pub const VkAttachmentDescription2KHR = VkAttachmentDescription2;
pub const VkAttachmentReference2KHR = VkAttachmentReference2;
pub const VkSubpassDescription2KHR = VkSubpassDescription2;
pub const VkSubpassDependency2KHR = VkSubpassDependency2;
pub const VkRenderPassCreateInfo2KHR = VkRenderPassCreateInfo2;
pub const VkSubpassBeginInfoKHR = VkSubpassBeginInfo;
pub const VkSubpassEndInfoKHR = VkSubpassEndInfo;
pub const VkPhysicalDeviceTimelineSemaphoreFeaturesKHR = VkPhysicalDeviceTimelineSemaphoreFeatures;
pub const VkPhysicalDeviceTimelineSemaphorePropertiesKHR = VkPhysicalDeviceTimelineSemaphoreProperties;
pub const VkSemaphoreTypeCreateInfoKHR = VkSemaphoreTypeCreateInfo;
pub const VkTimelineSemaphoreSubmitInfoKHR = VkTimelineSemaphoreSubmitInfo;
pub const VkSemaphoreWaitInfoKHR = VkSemaphoreWaitInfo;
pub const VkSemaphoreSignalInfoKHR = VkSemaphoreSignalInfo;
pub const VkVertexInputBindingDivisorDescriptionKHR = VkVertexInputBindingDivisorDescription;
pub const VkVertexInputBindingDivisorDescriptionEXT = VkVertexInputBindingDivisorDescription;
pub const VkPipelineVertexInputDivisorStateCreateInfoKHR = VkPipelineVertexInputDivisorStateCreateInfo;
pub const VkPipelineVertexInputDivisorStateCreateInfoEXT = VkPipelineVertexInputDivisorStateCreateInfo;
pub const VkPhysicalDeviceVertexAttributeDivisorPropertiesKHR = VkPhysicalDeviceVertexAttributeDivisorProperties;
pub const VkPhysicalDevice8BitStorageFeaturesKHR = VkPhysicalDevice8BitStorageFeatures;
pub const VkPhysicalDeviceVulkanMemoryModelFeaturesKHR = VkPhysicalDeviceVulkanMemoryModelFeatures;
pub const VkPhysicalDeviceShaderAtomicInt64FeaturesKHR = VkPhysicalDeviceShaderAtomicInt64Features;
pub const VkPhysicalDeviceVertexAttributeDivisorFeaturesKHR = VkPhysicalDeviceVertexAttributeDivisorFeatures;
pub const VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT = VkPhysicalDeviceVertexAttributeDivisorFeatures;
pub const VkPhysicalDeviceDepthStencilResolvePropertiesKHR = VkPhysicalDeviceDepthStencilResolveProperties;
pub const VkSubpassDescriptionDepthStencilResolveKHR = VkSubpassDescriptionDepthStencilResolve;
pub const VkPhysicalDeviceComputeShaderDerivativesFeaturesNV = VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR;
pub const VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV = VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR;
pub const VkPhysicalDeviceCopyMemoryIndirectPropertiesNV = VkPhysicalDeviceCopyMemoryIndirectPropertiesKHR;
pub const VkPhysicalDeviceMemoryDecompressionFeaturesNV = VkPhysicalDeviceMemoryDecompressionFeaturesEXT;
pub const VkPhysicalDeviceMemoryDecompressionPropertiesNV = VkPhysicalDeviceMemoryDecompressionPropertiesEXT;
pub const VkImageStencilUsageCreateInfoEXT = VkImageStencilUsageCreateInfo;
pub const VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM = VkPhysicalDeviceFragmentDensityMapOffsetFeaturesEXT;
pub const VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM = VkPhysicalDeviceFragmentDensityMapOffsetPropertiesEXT;
pub const VkSubpassFragmentDensityMapOffsetEndInfoQCOM = VkRenderPassFragmentDensityMapOffsetEndInfoEXT;
pub const VkPhysicalDeviceScalarBlockLayoutFeaturesEXT = VkPhysicalDeviceScalarBlockLayoutFeatures;
pub const VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR = VkPhysicalDeviceUniformBufferStandardLayoutFeatures;
pub const VkPhysicalDeviceBufferDeviceAddressFeaturesKHR = VkPhysicalDeviceBufferDeviceAddressFeatures;
pub const VkPhysicalDeviceBufferAddressFeaturesEXT = VkPhysicalDeviceBufferDeviceAddressFeaturesEXT;
pub const VkBufferDeviceAddressInfoKHR = VkBufferDeviceAddressInfo;
pub const VkBufferDeviceAddressInfoEXT = VkBufferDeviceAddressInfo;
pub const VkBufferOpaqueCaptureAddressCreateInfoKHR = VkBufferOpaqueCaptureAddressCreateInfo;
pub const VkPhysicalDeviceImagelessFramebufferFeaturesKHR = VkPhysicalDeviceImagelessFramebufferFeatures;
pub const VkFramebufferAttachmentsCreateInfoKHR = VkFramebufferAttachmentsCreateInfo;
pub const VkFramebufferAttachmentImageInfoKHR = VkFramebufferAttachmentImageInfo;
pub const VkRenderPassAttachmentBeginInfoKHR = VkRenderPassAttachmentBeginInfo;
pub const VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT = VkPhysicalDeviceTextureCompressionASTCHDRFeatures;
pub const VkPipelineCreationFeedbackEXT = VkPipelineCreationFeedback;
pub const VkPipelineCreationFeedbackCreateInfoEXT = VkPipelineCreationFeedbackCreateInfo;
pub const VkQueryPoolCreateInfoINTEL = VkQueryPoolPerformanceQueryCreateInfoINTEL;
pub const VkPhysicalDeviceIndexTypeUint8FeaturesKHR = VkPhysicalDeviceIndexTypeUint8Features;
pub const VkPhysicalDeviceIndexTypeUint8FeaturesEXT = VkPhysicalDeviceIndexTypeUint8Features;
pub const VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR = VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures;
pub const VkAttachmentReferenceStencilLayoutKHR = VkAttachmentReferenceStencilLayout;
pub const VkAttachmentDescriptionStencilLayoutKHR = VkAttachmentDescriptionStencilLayout;
pub const VkPipelineInfoEXT = VkPipelineInfoKHR;
pub const VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT = VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures;
pub const VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT = VkPhysicalDeviceTexelBufferAlignmentProperties;
pub const VkPhysicalDeviceSubgroupSizeControlFeaturesEXT = VkPhysicalDeviceSubgroupSizeControlFeatures;
pub const VkPhysicalDeviceSubgroupSizeControlPropertiesEXT = VkPhysicalDeviceSubgroupSizeControlProperties;
pub const VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT = VkPipelineShaderStageRequiredSubgroupSizeCreateInfo;
pub const VkShaderRequiredSubgroupSizeCreateInfoEXT = VkPipelineShaderStageRequiredSubgroupSizeCreateInfo;
pub const VkMemoryOpaqueCaptureAddressAllocateInfoKHR = VkMemoryOpaqueCaptureAddressAllocateInfo;
pub const VkDeviceMemoryOpaqueCaptureAddressInfoKHR = VkDeviceMemoryOpaqueCaptureAddressInfo;
pub const VkPhysicalDeviceLineRasterizationFeaturesKHR = VkPhysicalDeviceLineRasterizationFeatures;
pub const VkPhysicalDeviceLineRasterizationFeaturesEXT = VkPhysicalDeviceLineRasterizationFeatures;
pub const VkPhysicalDeviceLineRasterizationPropertiesKHR = VkPhysicalDeviceLineRasterizationProperties;
pub const VkPhysicalDeviceLineRasterizationPropertiesEXT = VkPhysicalDeviceLineRasterizationProperties;
pub const VkPipelineRasterizationLineStateCreateInfoKHR = VkPipelineRasterizationLineStateCreateInfo;
pub const VkPipelineRasterizationLineStateCreateInfoEXT = VkPipelineRasterizationLineStateCreateInfo;
pub const VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT = VkPhysicalDevicePipelineCreationCacheControlFeatures;
pub const PFN_vkFaultCallbackFunction = *const vkFaultCallbackFunction;
pub const VkPhysicalDeviceToolPropertiesEXT = VkPhysicalDeviceToolProperties;
pub const VkAabbPositionsNV = VkAabbPositionsKHR;
pub const VkTransformMatrixNV = VkTransformMatrixKHR;
pub const VkAccelerationStructureInstanceNV = VkAccelerationStructureInstanceKHR;
pub const VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR = VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures;
pub const VkPhysicalDeviceRobustness2FeaturesEXT = VkPhysicalDeviceRobustness2FeaturesKHR;
pub const VkPhysicalDeviceRobustness2PropertiesEXT = VkPhysicalDeviceRobustness2PropertiesKHR;
pub const VkPhysicalDeviceImageRobustnessFeaturesEXT = VkPhysicalDeviceImageRobustnessFeatures;
pub const VkBufferCopy2KHR = VkBufferCopy2;
pub const VkImageCopy2KHR = VkImageCopy2;
pub const VkImageBlit2KHR = VkImageBlit2;
pub const VkBufferImageCopy2KHR = VkBufferImageCopy2;
pub const VkImageResolve2KHR = VkImageResolve2;
pub const VkCopyBufferInfo2KHR = VkCopyBufferInfo2;
pub const VkCopyImageInfo2KHR = VkCopyImageInfo2;
pub const VkBlitImageInfo2KHR = VkBlitImageInfo2;
pub const VkCopyBufferToImageInfo2KHR = VkCopyBufferToImageInfo2;
pub const VkCopyImageToBufferInfo2KHR = VkCopyImageToBufferInfo2;
pub const VkResolveImageInfo2KHR = VkResolveImageInfo2;
pub const VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR = VkPhysicalDeviceShaderTerminateInvocationFeatures;
pub const VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE = VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT;
pub const VkMutableDescriptorTypeListVALVE = VkMutableDescriptorTypeListEXT;
pub const VkMutableDescriptorTypeCreateInfoVALVE = VkMutableDescriptorTypeCreateInfoEXT;
pub const VkMemoryBarrier2KHR = VkMemoryBarrier2;
pub const VkImageMemoryBarrier2KHR = VkImageMemoryBarrier2;
pub const VkBufferMemoryBarrier2KHR = VkBufferMemoryBarrier2;
pub const VkDependencyInfoKHR = VkDependencyInfo;
pub const VkSemaphoreSubmitInfoKHR = VkSemaphoreSubmitInfo;
pub const VkCommandBufferSubmitInfoKHR = VkCommandBufferSubmitInfo;
pub const VkSubmitInfo2KHR = VkSubmitInfo2;
pub const VkPhysicalDeviceSynchronization2FeaturesKHR = VkPhysicalDeviceSynchronization2Features;
pub const VkPhysicalDeviceHostImageCopyFeaturesEXT = VkPhysicalDeviceHostImageCopyFeatures;
pub const VkPhysicalDeviceHostImageCopyPropertiesEXT = VkPhysicalDeviceHostImageCopyProperties;
pub const VkMemoryToImageCopyEXT = VkMemoryToImageCopy;
pub const VkImageToMemoryCopyEXT = VkImageToMemoryCopy;
pub const VkCopyMemoryToImageInfoEXT = VkCopyMemoryToImageInfo;
pub const VkCopyImageToMemoryInfoEXT = VkCopyImageToMemoryInfo;
pub const VkCopyImageToImageInfoEXT = VkCopyImageToImageInfo;
pub const VkHostImageLayoutTransitionInfoEXT = VkHostImageLayoutTransitionInfo;
pub const VkSubresourceHostMemcpySizeEXT = VkSubresourceHostMemcpySize;
pub const VkHostImageCopyDevicePerformanceQueryEXT = VkHostImageCopyDevicePerformanceQuery;
pub const VkPhysicalDevicePipelineProtectedAccessFeaturesEXT = VkPhysicalDevicePipelineProtectedAccessFeatures;
pub const VkPhysicalDeviceShaderIntegerDotProductFeaturesKHR = VkPhysicalDeviceShaderIntegerDotProductFeatures;
pub const VkPhysicalDeviceShaderIntegerDotProductPropertiesKHR = VkPhysicalDeviceShaderIntegerDotProductProperties;
pub const VkFormatProperties3KHR = VkFormatProperties3;
pub const VkPipelineRenderingCreateInfoKHR = VkPipelineRenderingCreateInfo;
pub const VkRenderingInfoKHR = VkRenderingInfo;
pub const VkRenderingEndInfoEXT = VkRenderingEndInfoKHR;
pub const VkRenderingAttachmentInfoKHR = VkRenderingAttachmentInfo;
pub const VkPhysicalDeviceDynamicRenderingFeaturesKHR = VkPhysicalDeviceDynamicRenderingFeatures;
pub const VkCommandBufferInheritanceRenderingInfoKHR = VkCommandBufferInheritanceRenderingInfo;
pub const VkAttachmentSampleCountInfoNV = VkAttachmentSampleCountInfoAMD;
pub const VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesARM = VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT;
pub const VkImageSubresource2KHR = VkImageSubresource2;
pub const VkImageSubresource2EXT = VkImageSubresource2;
pub const VkSubresourceLayout2KHR = VkSubresourceLayout2;
pub const VkSubresourceLayout2EXT = VkSubresourceLayout2;
pub const VkPhysicalDevicePipelineRobustnessFeaturesEXT = VkPhysicalDevicePipelineRobustnessFeatures;
pub const VkPipelineRobustnessCreateInfoEXT = VkPipelineRobustnessCreateInfo;
pub const VkPhysicalDevicePipelineRobustnessPropertiesEXT = VkPhysicalDevicePipelineRobustnessProperties;
pub const VkPhysicalDeviceDepthClampZeroOneFeaturesEXT = VkPhysicalDeviceDepthClampZeroOneFeaturesKHR;
pub const VkSurfacePresentModeEXT = VkSurfacePresentModeKHR;
pub const VkSurfacePresentScalingCapabilitiesEXT = VkSurfacePresentScalingCapabilitiesKHR;
pub const VkSurfacePresentModeCompatibilityEXT = VkSurfacePresentModeCompatibilityKHR;
pub const VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT = VkPhysicalDeviceSwapchainMaintenance1FeaturesKHR;
pub const VkSwapchainPresentFenceInfoEXT = VkSwapchainPresentFenceInfoKHR;
pub const VkSwapchainPresentModesCreateInfoEXT = VkSwapchainPresentModesCreateInfoKHR;
pub const VkSwapchainPresentModeInfoEXT = VkSwapchainPresentModeInfoKHR;
pub const VkSwapchainPresentScalingCreateInfoEXT = VkSwapchainPresentScalingCreateInfoKHR;
pub const VkReleaseSwapchainImagesInfoEXT = VkReleaseSwapchainImagesInfoKHR;
pub const PFN_vkGetInstanceProcAddrLUNARG = *const vkGetInstanceProcAddrLUNARG;
pub const VkDeviceImageSubresourceInfoKHR = VkDeviceImageSubresourceInfo;
pub const VkMemoryMapInfoKHR = VkMemoryMapInfo;
pub const VkMemoryUnmapInfoKHR = VkMemoryUnmapInfo;
pub const VkBindMemoryStatusKHR = VkBindMemoryStatus;
pub const VkBindDescriptorSetsInfoKHR = VkBindDescriptorSetsInfo;
pub const VkPushConstantsInfoKHR = VkPushConstantsInfo;
pub const VkPushDescriptorSetInfoKHR = VkPushDescriptorSetInfo;
pub const VkPushDescriptorSetWithTemplateInfoKHR = VkPushDescriptorSetWithTemplateInfo;
pub const VkPhysicalDeviceShaderSubgroupRotateFeaturesKHR = VkPhysicalDeviceShaderSubgroupRotateFeatures;
pub const VkPhysicalDeviceShaderExpectAssumeFeaturesKHR = VkPhysicalDeviceShaderExpectAssumeFeatures;
pub const VkPhysicalDeviceShaderFloatControls2FeaturesKHR = VkPhysicalDeviceShaderFloatControls2Features;
pub const VkPhysicalDeviceDynamicRenderingLocalReadFeaturesKHR = VkPhysicalDeviceDynamicRenderingLocalReadFeatures;
pub const VkRenderingAttachmentLocationInfoKHR = VkRenderingAttachmentLocationInfo;
pub const VkRenderingInputAttachmentIndexInfoKHR = VkRenderingInputAttachmentIndexInfo;
pub const VkPhysicalDevicePresentModeFifoLatestReadyFeaturesEXT = VkPhysicalDevicePresentModeFifoLatestReadyFeaturesKHR;
pub const PFN_vkCreateInstance = *const vkCreateInstance;
pub const PFN_vkDestroyInstance = *const vkDestroyInstance;
pub const PFN_vkEnumeratePhysicalDevices = *const vkEnumeratePhysicalDevices;
pub const PFN_vkVoidFunction = *const vkVoidFunction;
pub const PFN_vkGetDeviceProcAddr = *const vkGetDeviceProcAddr;
pub const PFN_vkGetInstanceProcAddr = *const vkGetInstanceProcAddr;
pub const PFN_vkGetPhysicalDeviceProperties = *const vkGetPhysicalDeviceProperties;
pub const PFN_vkGetPhysicalDeviceQueueFamilyProperties = *const vkGetPhysicalDeviceQueueFamilyProperties;
pub const PFN_vkGetPhysicalDeviceMemoryProperties = *const vkGetPhysicalDeviceMemoryProperties;
pub const PFN_vkGetPhysicalDeviceFeatures = *const vkGetPhysicalDeviceFeatures;
pub const PFN_vkGetPhysicalDeviceFormatProperties = *const vkGetPhysicalDeviceFormatProperties;
pub const PFN_vkGetPhysicalDeviceImageFormatProperties = *const vkGetPhysicalDeviceImageFormatProperties;
pub const PFN_vkCreateDevice = *const vkCreateDevice;
pub const PFN_vkDestroyDevice = *const vkDestroyDevice;
pub const PFN_vkEnumerateInstanceVersion = *const vkEnumerateInstanceVersion;
pub const PFN_vkEnumerateInstanceLayerProperties = *const vkEnumerateInstanceLayerProperties;
pub const PFN_vkEnumerateInstanceExtensionProperties = *const vkEnumerateInstanceExtensionProperties;
pub const PFN_vkEnumerateDeviceLayerProperties = *const vkEnumerateDeviceLayerProperties;
pub const PFN_vkEnumerateDeviceExtensionProperties = *const vkEnumerateDeviceExtensionProperties;
pub const PFN_vkGetDeviceQueue = *const vkGetDeviceQueue;
pub const PFN_vkQueueSubmit = *const vkQueueSubmit;
pub const PFN_vkQueueWaitIdle = *const vkQueueWaitIdle;
pub const PFN_vkDeviceWaitIdle = *const vkDeviceWaitIdle;
pub const PFN_vkAllocateMemory = *const vkAllocateMemory;
pub const PFN_vkFreeMemory = *const vkFreeMemory;
pub const PFN_vkMapMemory = *const vkMapMemory;
pub const PFN_vkUnmapMemory = *const vkUnmapMemory;
pub const PFN_vkFlushMappedMemoryRanges = *const vkFlushMappedMemoryRanges;
pub const PFN_vkInvalidateMappedMemoryRanges = *const vkInvalidateMappedMemoryRanges;
pub const PFN_vkGetDeviceMemoryCommitment = *const vkGetDeviceMemoryCommitment;
pub const PFN_vkGetBufferMemoryRequirements = *const vkGetBufferMemoryRequirements;
pub const PFN_vkBindBufferMemory = *const vkBindBufferMemory;
pub const PFN_vkGetImageMemoryRequirements = *const vkGetImageMemoryRequirements;
pub const PFN_vkBindImageMemory = *const vkBindImageMemory;
pub const PFN_vkGetImageSparseMemoryRequirements = *const vkGetImageSparseMemoryRequirements;
pub const PFN_vkGetPhysicalDeviceSparseImageFormatProperties = *const vkGetPhysicalDeviceSparseImageFormatProperties;
pub const PFN_vkQueueBindSparse = *const vkQueueBindSparse;
pub const PFN_vkCreateFence = *const vkCreateFence;
pub const PFN_vkDestroyFence = *const vkDestroyFence;
pub const PFN_vkResetFences = *const vkResetFences;
pub const PFN_vkGetFenceStatus = *const vkGetFenceStatus;
pub const PFN_vkWaitForFences = *const vkWaitForFences;
pub const PFN_vkCreateSemaphore = *const vkCreateSemaphore;
pub const PFN_vkDestroySemaphore = *const vkDestroySemaphore;
pub const PFN_vkCreateEvent = *const vkCreateEvent;
pub const PFN_vkDestroyEvent = *const vkDestroyEvent;
pub const PFN_vkGetEventStatus = *const vkGetEventStatus;
pub const PFN_vkSetEvent = *const vkSetEvent;
pub const PFN_vkResetEvent = *const vkResetEvent;
pub const PFN_vkCreateQueryPool = *const vkCreateQueryPool;
pub const PFN_vkDestroyQueryPool = *const vkDestroyQueryPool;
pub const PFN_vkGetQueryPoolResults = *const vkGetQueryPoolResults;
pub const PFN_vkResetQueryPool = *const vkResetQueryPool;
pub const vkResetQueryPoolEXT = vkResetQueryPool;
pub const PFN_vkCreateBuffer = *const vkCreateBuffer;
pub const PFN_vkDestroyBuffer = *const vkDestroyBuffer;
pub const PFN_vkCreateBufferView = *const vkCreateBufferView;
pub const PFN_vkDestroyBufferView = *const vkDestroyBufferView;
pub const PFN_vkCreateImage = *const vkCreateImage;
pub const PFN_vkDestroyImage = *const vkDestroyImage;
pub const PFN_vkGetImageSubresourceLayout = *const vkGetImageSubresourceLayout;
pub const PFN_vkCreateImageView = *const vkCreateImageView;
pub const PFN_vkDestroyImageView = *const vkDestroyImageView;
pub const PFN_vkCreateShaderModule = *const vkCreateShaderModule;
pub const PFN_vkDestroyShaderModule = *const vkDestroyShaderModule;
pub const PFN_vkCreatePipelineCache = *const vkCreatePipelineCache;
pub const PFN_vkDestroyPipelineCache = *const vkDestroyPipelineCache;
pub const PFN_vkGetPipelineCacheData = *const vkGetPipelineCacheData;
pub const PFN_vkMergePipelineCaches = *const vkMergePipelineCaches;
pub const PFN_vkCreatePipelineBinariesKHR = *const vkCreatePipelineBinariesKHR;
pub const PFN_vkDestroyPipelineBinaryKHR = *const vkDestroyPipelineBinaryKHR;
pub const PFN_vkGetPipelineKeyKHR = *const vkGetPipelineKeyKHR;
pub const PFN_vkGetPipelineBinaryDataKHR = *const vkGetPipelineBinaryDataKHR;
pub const PFN_vkReleaseCapturedPipelineDataKHR = *const vkReleaseCapturedPipelineDataKHR;
pub const PFN_vkCreateGraphicsPipelines = *const vkCreateGraphicsPipelines;
pub const PFN_vkCreateComputePipelines = *const vkCreateComputePipelines;
pub const PFN_vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI = *const vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI;
pub const PFN_vkDestroyPipeline = *const vkDestroyPipeline;
pub const PFN_vkCreatePipelineLayout = *const vkCreatePipelineLayout;
pub const PFN_vkDestroyPipelineLayout = *const vkDestroyPipelineLayout;
pub const PFN_vkCreateSampler = *const vkCreateSampler;
pub const PFN_vkDestroySampler = *const vkDestroySampler;
pub const PFN_vkCreateDescriptorSetLayout = *const vkCreateDescriptorSetLayout;
pub const PFN_vkDestroyDescriptorSetLayout = *const vkDestroyDescriptorSetLayout;
pub const PFN_vkCreateDescriptorPool = *const vkCreateDescriptorPool;
pub const PFN_vkDestroyDescriptorPool = *const vkDestroyDescriptorPool;
pub const PFN_vkResetDescriptorPool = *const vkResetDescriptorPool;
pub const PFN_vkAllocateDescriptorSets = *const vkAllocateDescriptorSets;
pub const PFN_vkFreeDescriptorSets = *const vkFreeDescriptorSets;
pub const PFN_vkUpdateDescriptorSets = *const vkUpdateDescriptorSets;
pub const PFN_vkCreateFramebuffer = *const vkCreateFramebuffer;
pub const PFN_vkDestroyFramebuffer = *const vkDestroyFramebuffer;
pub const PFN_vkCreateRenderPass = *const vkCreateRenderPass;
pub const PFN_vkDestroyRenderPass = *const vkDestroyRenderPass;
pub const PFN_vkGetRenderAreaGranularity = *const vkGetRenderAreaGranularity;
pub const PFN_vkGetRenderingAreaGranularity = *const vkGetRenderingAreaGranularity;
pub const vkGetRenderingAreaGranularityKHR = vkGetRenderingAreaGranularity;
pub const PFN_vkCreateCommandPool = *const vkCreateCommandPool;
pub const PFN_vkDestroyCommandPool = *const vkDestroyCommandPool;
pub const PFN_vkResetCommandPool = *const vkResetCommandPool;
pub const PFN_vkAllocateCommandBuffers = *const vkAllocateCommandBuffers;
pub const PFN_vkFreeCommandBuffers = *const vkFreeCommandBuffers;
pub const PFN_vkBeginCommandBuffer = *const vkBeginCommandBuffer;
pub const PFN_vkEndCommandBuffer = *const vkEndCommandBuffer;
pub const PFN_vkResetCommandBuffer = *const vkResetCommandBuffer;
pub const PFN_vkCmdBindPipeline = *const vkCmdBindPipeline;
pub const PFN_vkCmdSetAttachmentFeedbackLoopEnableEXT = *const vkCmdSetAttachmentFeedbackLoopEnableEXT;
pub const PFN_vkCmdSetViewport = *const vkCmdSetViewport;
pub const PFN_vkCmdSetScissor = *const vkCmdSetScissor;
pub const PFN_vkCmdSetLineWidth = *const vkCmdSetLineWidth;
pub const PFN_vkCmdSetDepthBias = *const vkCmdSetDepthBias;
pub const PFN_vkCmdSetBlendConstants = *const vkCmdSetBlendConstants;
pub const PFN_vkCmdSetDepthBounds = *const vkCmdSetDepthBounds;
pub const PFN_vkCmdSetStencilCompareMask = *const vkCmdSetStencilCompareMask;
pub const PFN_vkCmdSetStencilWriteMask = *const vkCmdSetStencilWriteMask;
pub const PFN_vkCmdSetStencilReference = *const vkCmdSetStencilReference;
pub const PFN_vkCmdBindDescriptorSets = *const vkCmdBindDescriptorSets;
pub const PFN_vkCmdBindIndexBuffer = *const vkCmdBindIndexBuffer;
pub const PFN_vkCmdBindVertexBuffers = *const vkCmdBindVertexBuffers;
pub const PFN_vkCmdDraw = *const vkCmdDraw;
pub const PFN_vkCmdDrawIndexed = *const vkCmdDrawIndexed;
pub const PFN_vkCmdDrawMultiEXT = *const vkCmdDrawMultiEXT;
pub const PFN_vkCmdDrawMultiIndexedEXT = *const vkCmdDrawMultiIndexedEXT;
pub const PFN_vkCmdDrawIndirect = *const vkCmdDrawIndirect;
pub const PFN_vkCmdDrawIndexedIndirect = *const vkCmdDrawIndexedIndirect;
pub const PFN_vkCmdDispatch = *const vkCmdDispatch;
pub const PFN_vkCmdDispatchIndirect = *const vkCmdDispatchIndirect;
pub const PFN_vkCmdSubpassShadingHUAWEI = *const vkCmdSubpassShadingHUAWEI;
pub const PFN_vkCmdDrawClusterHUAWEI = *const vkCmdDrawClusterHUAWEI;
pub const PFN_vkCmdDrawClusterIndirectHUAWEI = *const vkCmdDrawClusterIndirectHUAWEI;
pub const PFN_vkCmdUpdatePipelineIndirectBufferNV = *const vkCmdUpdatePipelineIndirectBufferNV;
pub const PFN_vkCmdCopyBuffer = *const vkCmdCopyBuffer;
pub const PFN_vkCmdCopyImage = *const vkCmdCopyImage;
pub const PFN_vkCmdBlitImage = *const vkCmdBlitImage;
pub const PFN_vkCmdCopyBufferToImage = *const vkCmdCopyBufferToImage;
pub const PFN_vkCmdCopyImageToBuffer = *const vkCmdCopyImageToBuffer;
pub const PFN_vkCmdCopyMemoryIndirectNV = *const vkCmdCopyMemoryIndirectNV;
pub const PFN_vkCmdCopyMemoryIndirectKHR = *const vkCmdCopyMemoryIndirectKHR;
pub const PFN_vkCmdCopyMemoryToImageIndirectNV = *const vkCmdCopyMemoryToImageIndirectNV;
pub const PFN_vkCmdCopyMemoryToImageIndirectKHR = *const vkCmdCopyMemoryToImageIndirectKHR;
pub const PFN_vkCmdUpdateBuffer = *const vkCmdUpdateBuffer;
pub const PFN_vkCmdFillBuffer = *const vkCmdFillBuffer;
pub const PFN_vkCmdClearColorImage = *const vkCmdClearColorImage;
pub const PFN_vkCmdClearDepthStencilImage = *const vkCmdClearDepthStencilImage;
pub const PFN_vkCmdClearAttachments = *const vkCmdClearAttachments;
pub const PFN_vkCmdResolveImage = *const vkCmdResolveImage;
pub const PFN_vkCmdSetEvent = *const vkCmdSetEvent;
pub const PFN_vkCmdResetEvent = *const vkCmdResetEvent;
pub const PFN_vkCmdWaitEvents = *const vkCmdWaitEvents;
pub const PFN_vkCmdPipelineBarrier = *const vkCmdPipelineBarrier;
pub const PFN_vkCmdBeginQuery = *const vkCmdBeginQuery;
pub const PFN_vkCmdEndQuery = *const vkCmdEndQuery;
pub const PFN_vkCmdBeginConditionalRenderingEXT = *const vkCmdBeginConditionalRenderingEXT;
pub const PFN_vkCmdEndConditionalRenderingEXT = *const vkCmdEndConditionalRenderingEXT;
pub const PFN_vkCmdBeginCustomResolveEXT = *const vkCmdBeginCustomResolveEXT;
pub const PFN_vkCmdResetQueryPool = *const vkCmdResetQueryPool;
pub const PFN_vkCmdWriteTimestamp = *const vkCmdWriteTimestamp;
pub const PFN_vkCmdCopyQueryPoolResults = *const vkCmdCopyQueryPoolResults;
pub const PFN_vkCmdPushConstants = *const vkCmdPushConstants;
pub const PFN_vkCmdBeginRenderPass = *const vkCmdBeginRenderPass;
pub const PFN_vkCmdNextSubpass = *const vkCmdNextSubpass;
pub const PFN_vkCmdEndRenderPass = *const vkCmdEndRenderPass;
pub const PFN_vkCmdExecuteCommands = *const vkCmdExecuteCommands;
pub const PFN_vkCreateAndroidSurfaceKHR = *const vkCreateAndroidSurfaceKHR;
pub const PFN_vkCreateSurfaceOHOS = *const vkCreateSurfaceOHOS;
pub const PFN_vkGetPhysicalDeviceDisplayPropertiesKHR = *const vkGetPhysicalDeviceDisplayPropertiesKHR;
pub const PFN_vkGetPhysicalDeviceDisplayPlanePropertiesKHR = *const vkGetPhysicalDeviceDisplayPlanePropertiesKHR;
pub const PFN_vkGetDisplayPlaneSupportedDisplaysKHR = *const vkGetDisplayPlaneSupportedDisplaysKHR;
pub const PFN_vkGetDisplayModePropertiesKHR = *const vkGetDisplayModePropertiesKHR;
pub const PFN_vkCreateDisplayModeKHR = *const vkCreateDisplayModeKHR;
pub const PFN_vkGetDisplayPlaneCapabilitiesKHR = *const vkGetDisplayPlaneCapabilitiesKHR;
pub const PFN_vkCreateDisplayPlaneSurfaceKHR = *const vkCreateDisplayPlaneSurfaceKHR;
pub const PFN_vkCreateSharedSwapchainsKHR = *const vkCreateSharedSwapchainsKHR;
pub const PFN_vkDestroySurfaceKHR = *const vkDestroySurfaceKHR;
pub const PFN_vkGetPhysicalDeviceSurfaceSupportKHR = *const vkGetPhysicalDeviceSurfaceSupportKHR;
pub const PFN_vkGetPhysicalDeviceSurfaceCapabilitiesKHR = *const vkGetPhysicalDeviceSurfaceCapabilitiesKHR;
pub const PFN_vkGetPhysicalDeviceSurfaceFormatsKHR = *const vkGetPhysicalDeviceSurfaceFormatsKHR;
pub const PFN_vkGetPhysicalDeviceSurfacePresentModesKHR = *const vkGetPhysicalDeviceSurfacePresentModesKHR;
pub const PFN_vkCreateSwapchainKHR = *const vkCreateSwapchainKHR;
pub const PFN_vkDestroySwapchainKHR = *const vkDestroySwapchainKHR;
pub const PFN_vkGetSwapchainImagesKHR = *const vkGetSwapchainImagesKHR;
pub const PFN_vkAcquireNextImageKHR = *const vkAcquireNextImageKHR;
pub const PFN_vkQueuePresentKHR = *const vkQueuePresentKHR;
pub const PFN_vkCreateViSurfaceNN = *const vkCreateViSurfaceNN;
pub const PFN_vkCreateWaylandSurfaceKHR = *const vkCreateWaylandSurfaceKHR;
pub const PFN_vkGetPhysicalDeviceWaylandPresentationSupportKHR = *const vkGetPhysicalDeviceWaylandPresentationSupportKHR;
pub const PFN_vkCreateWin32SurfaceKHR = *const vkCreateWin32SurfaceKHR;
pub const PFN_vkGetPhysicalDeviceWin32PresentationSupportKHR = *const vkGetPhysicalDeviceWin32PresentationSupportKHR;
pub const PFN_vkCreateXlibSurfaceKHR = *const vkCreateXlibSurfaceKHR;
pub const PFN_vkGetPhysicalDeviceXlibPresentationSupportKHR = *const vkGetPhysicalDeviceXlibPresentationSupportKHR;
pub const PFN_vkCreateXcbSurfaceKHR = *const vkCreateXcbSurfaceKHR;
pub const PFN_vkGetPhysicalDeviceXcbPresentationSupportKHR = *const vkGetPhysicalDeviceXcbPresentationSupportKHR;
pub const PFN_vkCreateDirectFBSurfaceEXT = *const vkCreateDirectFBSurfaceEXT;
pub const PFN_vkGetPhysicalDeviceDirectFBPresentationSupportEXT = *const vkGetPhysicalDeviceDirectFBPresentationSupportEXT;
pub const PFN_vkCreateImagePipeSurfaceFUCHSIA = *const vkCreateImagePipeSurfaceFUCHSIA;
pub const PFN_vkCreateStreamDescriptorSurfaceGGP = *const vkCreateStreamDescriptorSurfaceGGP;
pub const PFN_vkCreateScreenSurfaceQNX = *const vkCreateScreenSurfaceQNX;
pub const PFN_vkGetPhysicalDeviceScreenPresentationSupportQNX = *const vkGetPhysicalDeviceScreenPresentationSupportQNX;
pub const PFN_vkCreateDebugReportCallbackEXT = *const vkCreateDebugReportCallbackEXT;
pub const PFN_vkDestroyDebugReportCallbackEXT = *const vkDestroyDebugReportCallbackEXT;
pub const PFN_vkDebugReportMessageEXT = *const vkDebugReportMessageEXT;
pub const PFN_vkDebugMarkerSetObjectNameEXT = *const vkDebugMarkerSetObjectNameEXT;
pub const PFN_vkDebugMarkerSetObjectTagEXT = *const vkDebugMarkerSetObjectTagEXT;
pub const PFN_vkCmdDebugMarkerBeginEXT = *const vkCmdDebugMarkerBeginEXT;
pub const PFN_vkCmdDebugMarkerEndEXT = *const vkCmdDebugMarkerEndEXT;
pub const PFN_vkCmdDebugMarkerInsertEXT = *const vkCmdDebugMarkerInsertEXT;
pub const PFN_vkGetPhysicalDeviceExternalImageFormatPropertiesNV = *const vkGetPhysicalDeviceExternalImageFormatPropertiesNV;
pub const PFN_vkGetMemoryWin32HandleNV = *const vkGetMemoryWin32HandleNV;
pub const PFN_vkCmdExecuteGeneratedCommandsNV = *const vkCmdExecuteGeneratedCommandsNV;
pub const PFN_vkCmdPreprocessGeneratedCommandsNV = *const vkCmdPreprocessGeneratedCommandsNV;
pub const PFN_vkCmdBindPipelineShaderGroupNV = *const vkCmdBindPipelineShaderGroupNV;
pub const PFN_vkGetGeneratedCommandsMemoryRequirementsNV = *const vkGetGeneratedCommandsMemoryRequirementsNV;
pub const PFN_vkCreateIndirectCommandsLayoutNV = *const vkCreateIndirectCommandsLayoutNV;
pub const PFN_vkDestroyIndirectCommandsLayoutNV = *const vkDestroyIndirectCommandsLayoutNV;
pub const PFN_vkCmdExecuteGeneratedCommandsEXT = *const vkCmdExecuteGeneratedCommandsEXT;
pub const PFN_vkCmdPreprocessGeneratedCommandsEXT = *const vkCmdPreprocessGeneratedCommandsEXT;
pub const PFN_vkGetGeneratedCommandsMemoryRequirementsEXT = *const vkGetGeneratedCommandsMemoryRequirementsEXT;
pub const PFN_vkCreateIndirectCommandsLayoutEXT = *const vkCreateIndirectCommandsLayoutEXT;
pub const PFN_vkDestroyIndirectCommandsLayoutEXT = *const vkDestroyIndirectCommandsLayoutEXT;
pub const PFN_vkCreateIndirectExecutionSetEXT = *const vkCreateIndirectExecutionSetEXT;
pub const PFN_vkDestroyIndirectExecutionSetEXT = *const vkDestroyIndirectExecutionSetEXT;
pub const PFN_vkUpdateIndirectExecutionSetPipelineEXT = *const vkUpdateIndirectExecutionSetPipelineEXT;
pub const PFN_vkUpdateIndirectExecutionSetShaderEXT = *const vkUpdateIndirectExecutionSetShaderEXT;
pub const PFN_vkGetPhysicalDeviceFeatures2 = *const vkGetPhysicalDeviceFeatures2;
pub const vkGetPhysicalDeviceFeatures2KHR = vkGetPhysicalDeviceFeatures2;
pub const PFN_vkGetPhysicalDeviceProperties2 = *const vkGetPhysicalDeviceProperties2;
pub const vkGetPhysicalDeviceProperties2KHR = vkGetPhysicalDeviceProperties2;
pub const PFN_vkGetPhysicalDeviceFormatProperties2 = *const vkGetPhysicalDeviceFormatProperties2;
pub const vkGetPhysicalDeviceFormatProperties2KHR = vkGetPhysicalDeviceFormatProperties2;
pub const PFN_vkGetPhysicalDeviceImageFormatProperties2 = *const vkGetPhysicalDeviceImageFormatProperties2;
pub const vkGetPhysicalDeviceImageFormatProperties2KHR = vkGetPhysicalDeviceImageFormatProperties2;
pub const PFN_vkGetPhysicalDeviceQueueFamilyProperties2 = *const vkGetPhysicalDeviceQueueFamilyProperties2;
pub const vkGetPhysicalDeviceQueueFamilyProperties2KHR = vkGetPhysicalDeviceQueueFamilyProperties2;
pub const PFN_vkGetPhysicalDeviceMemoryProperties2 = *const vkGetPhysicalDeviceMemoryProperties2;
pub const vkGetPhysicalDeviceMemoryProperties2KHR = vkGetPhysicalDeviceMemoryProperties2;
pub const PFN_vkGetPhysicalDeviceSparseImageFormatProperties2 = *const vkGetPhysicalDeviceSparseImageFormatProperties2;
pub const vkGetPhysicalDeviceSparseImageFormatProperties2KHR = vkGetPhysicalDeviceSparseImageFormatProperties2;
pub const PFN_vkCmdPushDescriptorSet = *const vkCmdPushDescriptorSet;
pub const vkCmdPushDescriptorSetKHR = vkCmdPushDescriptorSet;
pub const PFN_vkTrimCommandPool = *const vkTrimCommandPool;
pub const vkTrimCommandPoolKHR = vkTrimCommandPool;
pub const PFN_vkGetPhysicalDeviceExternalBufferProperties = *const vkGetPhysicalDeviceExternalBufferProperties;
pub const vkGetPhysicalDeviceExternalBufferPropertiesKHR = vkGetPhysicalDeviceExternalBufferProperties;
pub const PFN_vkGetMemoryWin32HandleKHR = *const vkGetMemoryWin32HandleKHR;
pub const PFN_vkGetMemoryWin32HandlePropertiesKHR = *const vkGetMemoryWin32HandlePropertiesKHR;
pub const PFN_vkGetMemoryFdKHR = *const vkGetMemoryFdKHR;
pub const PFN_vkGetMemoryFdPropertiesKHR = *const vkGetMemoryFdPropertiesKHR;
pub const PFN_vkGetMemoryZirconHandleFUCHSIA = *const vkGetMemoryZirconHandleFUCHSIA;
pub const PFN_vkGetMemoryZirconHandlePropertiesFUCHSIA = *const vkGetMemoryZirconHandlePropertiesFUCHSIA;
pub const PFN_vkGetMemoryRemoteAddressNV = *const vkGetMemoryRemoteAddressNV;
pub const PFN_vkGetMemorySciBufNV = *const vkGetMemorySciBufNV;
pub const PFN_vkGetPhysicalDeviceExternalMemorySciBufPropertiesNV = *const vkGetPhysicalDeviceExternalMemorySciBufPropertiesNV;
pub const PFN_vkGetPhysicalDeviceSciBufAttributesNV = *const vkGetPhysicalDeviceSciBufAttributesNV;
pub const PFN_vkGetPhysicalDeviceExternalSemaphoreProperties = *const vkGetPhysicalDeviceExternalSemaphoreProperties;
pub const vkGetPhysicalDeviceExternalSemaphorePropertiesKHR = vkGetPhysicalDeviceExternalSemaphoreProperties;
pub const PFN_vkGetSemaphoreWin32HandleKHR = *const vkGetSemaphoreWin32HandleKHR;
pub const PFN_vkImportSemaphoreWin32HandleKHR = *const vkImportSemaphoreWin32HandleKHR;
pub const PFN_vkGetSemaphoreFdKHR = *const vkGetSemaphoreFdKHR;
pub const PFN_vkImportSemaphoreFdKHR = *const vkImportSemaphoreFdKHR;
pub const PFN_vkGetSemaphoreZirconHandleFUCHSIA = *const vkGetSemaphoreZirconHandleFUCHSIA;
pub const PFN_vkImportSemaphoreZirconHandleFUCHSIA = *const vkImportSemaphoreZirconHandleFUCHSIA;
pub const PFN_vkGetPhysicalDeviceExternalFenceProperties = *const vkGetPhysicalDeviceExternalFenceProperties;
pub const vkGetPhysicalDeviceExternalFencePropertiesKHR = vkGetPhysicalDeviceExternalFenceProperties;
pub const PFN_vkGetFenceWin32HandleKHR = *const vkGetFenceWin32HandleKHR;
pub const PFN_vkImportFenceWin32HandleKHR = *const vkImportFenceWin32HandleKHR;
pub const PFN_vkGetFenceFdKHR = *const vkGetFenceFdKHR;
pub const PFN_vkImportFenceFdKHR = *const vkImportFenceFdKHR;
pub const PFN_vkGetFenceSciSyncFenceNV = *const vkGetFenceSciSyncFenceNV;
pub const PFN_vkGetFenceSciSyncObjNV = *const vkGetFenceSciSyncObjNV;
pub const PFN_vkImportFenceSciSyncFenceNV = *const vkImportFenceSciSyncFenceNV;
pub const PFN_vkImportFenceSciSyncObjNV = *const vkImportFenceSciSyncObjNV;
pub const PFN_vkGetSemaphoreSciSyncObjNV = *const vkGetSemaphoreSciSyncObjNV;
pub const PFN_vkImportSemaphoreSciSyncObjNV = *const vkImportSemaphoreSciSyncObjNV;
pub const PFN_vkGetPhysicalDeviceSciSyncAttributesNV = *const vkGetPhysicalDeviceSciSyncAttributesNV;
pub const PFN_vkCreateSemaphoreSciSyncPoolNV = *const vkCreateSemaphoreSciSyncPoolNV;
pub const PFN_vkDestroySemaphoreSciSyncPoolNV = *const vkDestroySemaphoreSciSyncPoolNV;
pub const PFN_vkReleaseDisplayEXT = *const vkReleaseDisplayEXT;
pub const PFN_vkAcquireXlibDisplayEXT = *const vkAcquireXlibDisplayEXT;
pub const PFN_vkGetRandROutputDisplayEXT = *const vkGetRandROutputDisplayEXT;
pub const PFN_vkAcquireWinrtDisplayNV = *const vkAcquireWinrtDisplayNV;
pub const PFN_vkGetWinrtDisplayNV = *const vkGetWinrtDisplayNV;
pub const PFN_vkDisplayPowerControlEXT = *const vkDisplayPowerControlEXT;
pub const PFN_vkRegisterDeviceEventEXT = *const vkRegisterDeviceEventEXT;
pub const PFN_vkRegisterDisplayEventEXT = *const vkRegisterDisplayEventEXT;
pub const PFN_vkGetSwapchainCounterEXT = *const vkGetSwapchainCounterEXT;
pub const PFN_vkGetPhysicalDeviceSurfaceCapabilities2EXT = *const vkGetPhysicalDeviceSurfaceCapabilities2EXT;
pub const PFN_vkEnumeratePhysicalDeviceGroups = *const vkEnumeratePhysicalDeviceGroups;
pub const vkEnumeratePhysicalDeviceGroupsKHR = vkEnumeratePhysicalDeviceGroups;
pub const PFN_vkGetDeviceGroupPeerMemoryFeatures = *const vkGetDeviceGroupPeerMemoryFeatures;
pub const vkGetDeviceGroupPeerMemoryFeaturesKHR = vkGetDeviceGroupPeerMemoryFeatures;
pub const PFN_vkBindBufferMemory2 = *const vkBindBufferMemory2;
pub const vkBindBufferMemory2KHR = vkBindBufferMemory2;
pub const PFN_vkBindImageMemory2 = *const vkBindImageMemory2;
pub const vkBindImageMemory2KHR = vkBindImageMemory2;
pub const PFN_vkCmdSetDeviceMask = *const vkCmdSetDeviceMask;
pub const vkCmdSetDeviceMaskKHR = vkCmdSetDeviceMask;
pub const PFN_vkGetDeviceGroupPresentCapabilitiesKHR = *const vkGetDeviceGroupPresentCapabilitiesKHR;
pub const PFN_vkGetDeviceGroupSurfacePresentModesKHR = *const vkGetDeviceGroupSurfacePresentModesKHR;
pub const PFN_vkAcquireNextImage2KHR = *const vkAcquireNextImage2KHR;
pub const PFN_vkCmdDispatchBase = *const vkCmdDispatchBase;
pub const vkCmdDispatchBaseKHR = vkCmdDispatchBase;
pub const PFN_vkGetPhysicalDevicePresentRectanglesKHR = *const vkGetPhysicalDevicePresentRectanglesKHR;
pub const PFN_vkCreateDescriptorUpdateTemplate = *const vkCreateDescriptorUpdateTemplate;
pub const vkCreateDescriptorUpdateTemplateKHR = vkCreateDescriptorUpdateTemplate;
pub const PFN_vkDestroyDescriptorUpdateTemplate = *const vkDestroyDescriptorUpdateTemplate;
pub const vkDestroyDescriptorUpdateTemplateKHR = vkDestroyDescriptorUpdateTemplate;
pub const PFN_vkUpdateDescriptorSetWithTemplate = *const vkUpdateDescriptorSetWithTemplate;
pub const vkUpdateDescriptorSetWithTemplateKHR = vkUpdateDescriptorSetWithTemplate;
pub const PFN_vkCmdPushDescriptorSetWithTemplate = *const vkCmdPushDescriptorSetWithTemplate;
pub const vkCmdPushDescriptorSetWithTemplateKHR = vkCmdPushDescriptorSetWithTemplate;
pub const PFN_vkSetHdrMetadataEXT = *const vkSetHdrMetadataEXT;
pub const PFN_vkGetSwapchainStatusKHR = *const vkGetSwapchainStatusKHR;
pub const PFN_vkGetRefreshCycleDurationGOOGLE = *const vkGetRefreshCycleDurationGOOGLE;
pub const PFN_vkGetPastPresentationTimingGOOGLE = *const vkGetPastPresentationTimingGOOGLE;
pub const PFN_vkCreateIOSSurfaceMVK = *const vkCreateIOSSurfaceMVK;
pub const PFN_vkCreateMacOSSurfaceMVK = *const vkCreateMacOSSurfaceMVK;
pub const PFN_vkCreateMetalSurfaceEXT = *const vkCreateMetalSurfaceEXT;
pub const PFN_vkCmdSetViewportWScalingNV = *const vkCmdSetViewportWScalingNV;
pub const PFN_vkCmdSetDiscardRectangleEXT = *const vkCmdSetDiscardRectangleEXT;
pub const PFN_vkCmdSetDiscardRectangleEnableEXT = *const vkCmdSetDiscardRectangleEnableEXT;
pub const PFN_vkCmdSetDiscardRectangleModeEXT = *const vkCmdSetDiscardRectangleModeEXT;
pub const PFN_vkCmdSetSampleLocationsEXT = *const vkCmdSetSampleLocationsEXT;
pub const PFN_vkGetPhysicalDeviceMultisamplePropertiesEXT = *const vkGetPhysicalDeviceMultisamplePropertiesEXT;
pub const PFN_vkGetPhysicalDeviceSurfaceCapabilities2KHR = *const vkGetPhysicalDeviceSurfaceCapabilities2KHR;
pub const PFN_vkGetPhysicalDeviceSurfaceFormats2KHR = *const vkGetPhysicalDeviceSurfaceFormats2KHR;
pub const PFN_vkGetPhysicalDeviceDisplayProperties2KHR = *const vkGetPhysicalDeviceDisplayProperties2KHR;
pub const PFN_vkGetPhysicalDeviceDisplayPlaneProperties2KHR = *const vkGetPhysicalDeviceDisplayPlaneProperties2KHR;
pub const PFN_vkGetDisplayModeProperties2KHR = *const vkGetDisplayModeProperties2KHR;
pub const PFN_vkGetDisplayPlaneCapabilities2KHR = *const vkGetDisplayPlaneCapabilities2KHR;
pub const PFN_vkGetBufferMemoryRequirements2 = *const vkGetBufferMemoryRequirements2;
pub const vkGetBufferMemoryRequirements2KHR = vkGetBufferMemoryRequirements2;
pub const PFN_vkGetImageMemoryRequirements2 = *const vkGetImageMemoryRequirements2;
pub const vkGetImageMemoryRequirements2KHR = vkGetImageMemoryRequirements2;
pub const PFN_vkGetImageSparseMemoryRequirements2 = *const vkGetImageSparseMemoryRequirements2;
pub const vkGetImageSparseMemoryRequirements2KHR = vkGetImageSparseMemoryRequirements2;
pub const PFN_vkGetDeviceBufferMemoryRequirements = *const vkGetDeviceBufferMemoryRequirements;
pub const vkGetDeviceBufferMemoryRequirementsKHR = vkGetDeviceBufferMemoryRequirements;
pub const PFN_vkGetDeviceImageMemoryRequirements = *const vkGetDeviceImageMemoryRequirements;
pub const vkGetDeviceImageMemoryRequirementsKHR = vkGetDeviceImageMemoryRequirements;
pub const PFN_vkGetDeviceImageSparseMemoryRequirements = *const vkGetDeviceImageSparseMemoryRequirements;
pub const vkGetDeviceImageSparseMemoryRequirementsKHR = vkGetDeviceImageSparseMemoryRequirements;
pub const PFN_vkCreateSamplerYcbcrConversion = *const vkCreateSamplerYcbcrConversion;
pub const vkCreateSamplerYcbcrConversionKHR = vkCreateSamplerYcbcrConversion;
pub const PFN_vkDestroySamplerYcbcrConversion = *const vkDestroySamplerYcbcrConversion;
pub const vkDestroySamplerYcbcrConversionKHR = vkDestroySamplerYcbcrConversion;
pub const PFN_vkGetDeviceQueue2 = *const vkGetDeviceQueue2;
pub const PFN_vkCreateValidationCacheEXT = *const vkCreateValidationCacheEXT;
pub const PFN_vkDestroyValidationCacheEXT = *const vkDestroyValidationCacheEXT;
pub const PFN_vkGetValidationCacheDataEXT = *const vkGetValidationCacheDataEXT;
pub const PFN_vkMergeValidationCachesEXT = *const vkMergeValidationCachesEXT;
pub const PFN_vkGetDescriptorSetLayoutSupport = *const vkGetDescriptorSetLayoutSupport;
pub const vkGetDescriptorSetLayoutSupportKHR = vkGetDescriptorSetLayoutSupport;
pub const PFN_vkGetSwapchainGrallocUsageANDROID = *const vkGetSwapchainGrallocUsageANDROID;
pub const PFN_vkGetSwapchainGrallocUsage2ANDROID = *const vkGetSwapchainGrallocUsage2ANDROID;
pub const PFN_vkAcquireImageANDROID = *const vkAcquireImageANDROID;
pub const PFN_vkQueueSignalReleaseImageANDROID = *const vkQueueSignalReleaseImageANDROID;
pub const PFN_vkGetShaderInfoAMD = *const vkGetShaderInfoAMD;
pub const PFN_vkSetLocalDimmingAMD = *const vkSetLocalDimmingAMD;
pub const PFN_vkGetPhysicalDeviceCalibrateableTimeDomainsKHR = *const vkGetPhysicalDeviceCalibrateableTimeDomainsKHR;
pub const vkGetPhysicalDeviceCalibrateableTimeDomainsEXT = vkGetPhysicalDeviceCalibrateableTimeDomainsKHR;
pub const PFN_vkGetCalibratedTimestampsKHR = *const vkGetCalibratedTimestampsKHR;
pub const vkGetCalibratedTimestampsEXT = vkGetCalibratedTimestampsKHR;
pub const PFN_vkSetDebugUtilsObjectNameEXT = *const vkSetDebugUtilsObjectNameEXT;
pub const PFN_vkSetDebugUtilsObjectTagEXT = *const vkSetDebugUtilsObjectTagEXT;
pub const PFN_vkQueueBeginDebugUtilsLabelEXT = *const vkQueueBeginDebugUtilsLabelEXT;
pub const PFN_vkQueueEndDebugUtilsLabelEXT = *const vkQueueEndDebugUtilsLabelEXT;
pub const PFN_vkQueueInsertDebugUtilsLabelEXT = *const vkQueueInsertDebugUtilsLabelEXT;
pub const PFN_vkCmdBeginDebugUtilsLabelEXT = *const vkCmdBeginDebugUtilsLabelEXT;
pub const PFN_vkCmdEndDebugUtilsLabelEXT = *const vkCmdEndDebugUtilsLabelEXT;
pub const PFN_vkCmdInsertDebugUtilsLabelEXT = *const vkCmdInsertDebugUtilsLabelEXT;
pub const PFN_vkCreateDebugUtilsMessengerEXT = *const vkCreateDebugUtilsMessengerEXT;
pub const PFN_vkDestroyDebugUtilsMessengerEXT = *const vkDestroyDebugUtilsMessengerEXT;
pub const PFN_vkSubmitDebugUtilsMessageEXT = *const vkSubmitDebugUtilsMessageEXT;
pub const PFN_vkGetMemoryHostPointerPropertiesEXT = *const vkGetMemoryHostPointerPropertiesEXT;
pub const PFN_vkCmdWriteBufferMarkerAMD = *const vkCmdWriteBufferMarkerAMD;
pub const PFN_vkCreateRenderPass2 = *const vkCreateRenderPass2;
pub const vkCreateRenderPass2KHR = vkCreateRenderPass2;
pub const PFN_vkCmdBeginRenderPass2 = *const vkCmdBeginRenderPass2;
pub const vkCmdBeginRenderPass2KHR = vkCmdBeginRenderPass2;
pub const PFN_vkCmdNextSubpass2 = *const vkCmdNextSubpass2;
pub const vkCmdNextSubpass2KHR = vkCmdNextSubpass2;
pub const PFN_vkCmdEndRenderPass2 = *const vkCmdEndRenderPass2;
pub const vkCmdEndRenderPass2KHR = vkCmdEndRenderPass2;
pub const PFN_vkGetSemaphoreCounterValue = *const vkGetSemaphoreCounterValue;
pub const vkGetSemaphoreCounterValueKHR = vkGetSemaphoreCounterValue;
pub const PFN_vkWaitSemaphores = *const vkWaitSemaphores;
pub const vkWaitSemaphoresKHR = vkWaitSemaphores;
pub const PFN_vkSignalSemaphore = *const vkSignalSemaphore;
pub const vkSignalSemaphoreKHR = vkSignalSemaphore;
pub const PFN_vkGetAndroidHardwareBufferPropertiesANDROID = *const vkGetAndroidHardwareBufferPropertiesANDROID;
pub const PFN_vkGetMemoryAndroidHardwareBufferANDROID = *const vkGetMemoryAndroidHardwareBufferANDROID;
pub const PFN_vkCmdDrawIndirectCount = *const vkCmdDrawIndirectCount;
pub const vkCmdDrawIndirectCountKHR = vkCmdDrawIndirectCount;
pub const vkCmdDrawIndirectCountAMD = vkCmdDrawIndirectCount;
pub const PFN_vkCmdDrawIndexedIndirectCount = *const vkCmdDrawIndexedIndirectCount;
pub const vkCmdDrawIndexedIndirectCountKHR = vkCmdDrawIndexedIndirectCount;
pub const vkCmdDrawIndexedIndirectCountAMD = vkCmdDrawIndexedIndirectCount;
pub const PFN_vkCmdSetCheckpointNV = *const vkCmdSetCheckpointNV;
pub const PFN_vkGetQueueCheckpointDataNV = *const vkGetQueueCheckpointDataNV;
pub const PFN_vkCmdBindTransformFeedbackBuffersEXT = *const vkCmdBindTransformFeedbackBuffersEXT;
pub const PFN_vkCmdBeginTransformFeedbackEXT = *const vkCmdBeginTransformFeedbackEXT;
pub const PFN_vkCmdEndTransformFeedbackEXT = *const vkCmdEndTransformFeedbackEXT;
pub const PFN_vkCmdBeginQueryIndexedEXT = *const vkCmdBeginQueryIndexedEXT;
pub const PFN_vkCmdEndQueryIndexedEXT = *const vkCmdEndQueryIndexedEXT;
pub const PFN_vkCmdDrawIndirectByteCountEXT = *const vkCmdDrawIndirectByteCountEXT;
pub const PFN_vkCmdSetExclusiveScissorNV = *const vkCmdSetExclusiveScissorNV;
pub const PFN_vkCmdSetExclusiveScissorEnableNV = *const vkCmdSetExclusiveScissorEnableNV;
pub const PFN_vkCmdBindShadingRateImageNV = *const vkCmdBindShadingRateImageNV;
pub const PFN_vkCmdSetViewportShadingRatePaletteNV = *const vkCmdSetViewportShadingRatePaletteNV;
pub const PFN_vkCmdSetCoarseSampleOrderNV = *const vkCmdSetCoarseSampleOrderNV;
pub const PFN_vkCmdDrawMeshTasksNV = *const vkCmdDrawMeshTasksNV;
pub const PFN_vkCmdDrawMeshTasksIndirectNV = *const vkCmdDrawMeshTasksIndirectNV;
pub const PFN_vkCmdDrawMeshTasksIndirectCountNV = *const vkCmdDrawMeshTasksIndirectCountNV;
pub const PFN_vkCmdDrawMeshTasksEXT = *const vkCmdDrawMeshTasksEXT;
pub const PFN_vkCmdDrawMeshTasksIndirectEXT = *const vkCmdDrawMeshTasksIndirectEXT;
pub const PFN_vkCmdDrawMeshTasksIndirectCountEXT = *const vkCmdDrawMeshTasksIndirectCountEXT;
pub const PFN_vkCompileDeferredNV = *const vkCompileDeferredNV;
pub const PFN_vkCreateAccelerationStructureNV = *const vkCreateAccelerationStructureNV;
pub const PFN_vkCmdBindInvocationMaskHUAWEI = *const vkCmdBindInvocationMaskHUAWEI;
pub const PFN_vkDestroyAccelerationStructureKHR = *const vkDestroyAccelerationStructureKHR;
pub const PFN_vkDestroyAccelerationStructureNV = *const vkDestroyAccelerationStructureNV;
pub const PFN_vkGetAccelerationStructureMemoryRequirementsNV = *const vkGetAccelerationStructureMemoryRequirementsNV;
pub const PFN_vkBindAccelerationStructureMemoryNV = *const vkBindAccelerationStructureMemoryNV;
pub const PFN_vkCmdCopyAccelerationStructureNV = *const vkCmdCopyAccelerationStructureNV;
pub const PFN_vkCmdCopyAccelerationStructureKHR = *const vkCmdCopyAccelerationStructureKHR;
pub const PFN_vkCopyAccelerationStructureKHR = *const vkCopyAccelerationStructureKHR;
pub const PFN_vkCmdCopyAccelerationStructureToMemoryKHR = *const vkCmdCopyAccelerationStructureToMemoryKHR;
pub const PFN_vkCopyAccelerationStructureToMemoryKHR = *const vkCopyAccelerationStructureToMemoryKHR;
pub const PFN_vkCmdCopyMemoryToAccelerationStructureKHR = *const vkCmdCopyMemoryToAccelerationStructureKHR;
pub const PFN_vkCopyMemoryToAccelerationStructureKHR = *const vkCopyMemoryToAccelerationStructureKHR;
pub const PFN_vkCmdWriteAccelerationStructuresPropertiesKHR = *const vkCmdWriteAccelerationStructuresPropertiesKHR;
pub const PFN_vkCmdWriteAccelerationStructuresPropertiesNV = *const vkCmdWriteAccelerationStructuresPropertiesNV;
pub const PFN_vkCmdBuildAccelerationStructureNV = *const vkCmdBuildAccelerationStructureNV;
pub const PFN_vkWriteAccelerationStructuresPropertiesKHR = *const vkWriteAccelerationStructuresPropertiesKHR;
pub const PFN_vkCmdTraceRaysKHR = *const vkCmdTraceRaysKHR;
pub const PFN_vkCmdTraceRaysNV = *const vkCmdTraceRaysNV;
pub const PFN_vkGetRayTracingShaderGroupHandlesKHR = *const vkGetRayTracingShaderGroupHandlesKHR;
pub const vkGetRayTracingShaderGroupHandlesNV = vkGetRayTracingShaderGroupHandlesKHR;
pub const PFN_vkGetRayTracingCaptureReplayShaderGroupHandlesKHR = *const vkGetRayTracingCaptureReplayShaderGroupHandlesKHR;
pub const PFN_vkGetAccelerationStructureHandleNV = *const vkGetAccelerationStructureHandleNV;
pub const PFN_vkCreateRayTracingPipelinesNV = *const vkCreateRayTracingPipelinesNV;
pub const PFN_vkCreateRayTracingPipelinesKHR = *const vkCreateRayTracingPipelinesKHR;
pub const PFN_vkGetPhysicalDeviceCooperativeMatrixPropertiesNV = *const vkGetPhysicalDeviceCooperativeMatrixPropertiesNV;
pub const PFN_vkCmdTraceRaysIndirectKHR = *const vkCmdTraceRaysIndirectKHR;
pub const PFN_vkCmdTraceRaysIndirect2KHR = *const vkCmdTraceRaysIndirect2KHR;
pub const PFN_vkGetClusterAccelerationStructureBuildSizesNV = *const vkGetClusterAccelerationStructureBuildSizesNV;
pub const PFN_vkCmdBuildClusterAccelerationStructureIndirectNV = *const vkCmdBuildClusterAccelerationStructureIndirectNV;
pub const PFN_vkGetDeviceAccelerationStructureCompatibilityKHR = *const vkGetDeviceAccelerationStructureCompatibilityKHR;
pub const PFN_vkGetRayTracingShaderGroupStackSizeKHR = *const vkGetRayTracingShaderGroupStackSizeKHR;
pub const PFN_vkCmdSetRayTracingPipelineStackSizeKHR = *const vkCmdSetRayTracingPipelineStackSizeKHR;
pub const PFN_vkGetImageViewHandleNVX = *const vkGetImageViewHandleNVX;
pub const PFN_vkGetImageViewHandle64NVX = *const vkGetImageViewHandle64NVX;
pub const PFN_vkGetImageViewAddressNVX = *const vkGetImageViewAddressNVX;
pub const PFN_vkGetPhysicalDeviceSurfacePresentModes2EXT = *const vkGetPhysicalDeviceSurfacePresentModes2EXT;
pub const PFN_vkGetDeviceGroupSurfacePresentModes2EXT = *const vkGetDeviceGroupSurfacePresentModes2EXT;
pub const PFN_vkAcquireFullScreenExclusiveModeEXT = *const vkAcquireFullScreenExclusiveModeEXT;
pub const PFN_vkReleaseFullScreenExclusiveModeEXT = *const vkReleaseFullScreenExclusiveModeEXT;
pub const PFN_vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR = *const vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR;
pub const PFN_vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR = *const vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR;
pub const PFN_vkAcquireProfilingLockKHR = *const vkAcquireProfilingLockKHR;
pub const PFN_vkReleaseProfilingLockKHR = *const vkReleaseProfilingLockKHR;
pub const PFN_vkGetImageDrmFormatModifierPropertiesEXT = *const vkGetImageDrmFormatModifierPropertiesEXT;
pub const PFN_vkGetBufferOpaqueCaptureAddress = *const vkGetBufferOpaqueCaptureAddress;
pub const vkGetBufferOpaqueCaptureAddressKHR = vkGetBufferOpaqueCaptureAddress;
pub const PFN_vkGetBufferDeviceAddress = *const vkGetBufferDeviceAddress;
pub const vkGetBufferDeviceAddressKHR = vkGetBufferDeviceAddress;
pub const vkGetBufferDeviceAddressEXT = vkGetBufferDeviceAddress;
pub const PFN_vkCreateHeadlessSurfaceEXT = *const vkCreateHeadlessSurfaceEXT;
pub const PFN_vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV = *const vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV;
pub const PFN_vkInitializePerformanceApiINTEL = *const vkInitializePerformanceApiINTEL;
pub const PFN_vkUninitializePerformanceApiINTEL = *const vkUninitializePerformanceApiINTEL;
pub const PFN_vkCmdSetPerformanceMarkerINTEL = *const vkCmdSetPerformanceMarkerINTEL;
pub const PFN_vkCmdSetPerformanceStreamMarkerINTEL = *const vkCmdSetPerformanceStreamMarkerINTEL;
pub const PFN_vkCmdSetPerformanceOverrideINTEL = *const vkCmdSetPerformanceOverrideINTEL;
pub const PFN_vkAcquirePerformanceConfigurationINTEL = *const vkAcquirePerformanceConfigurationINTEL;
pub const PFN_vkReleasePerformanceConfigurationINTEL = *const vkReleasePerformanceConfigurationINTEL;
pub const PFN_vkQueueSetPerformanceConfigurationINTEL = *const vkQueueSetPerformanceConfigurationINTEL;
pub const PFN_vkGetPerformanceParameterINTEL = *const vkGetPerformanceParameterINTEL;
pub const PFN_vkGetDeviceMemoryOpaqueCaptureAddress = *const vkGetDeviceMemoryOpaqueCaptureAddress;
pub const vkGetDeviceMemoryOpaqueCaptureAddressKHR = vkGetDeviceMemoryOpaqueCaptureAddress;
pub const PFN_vkGetPipelineExecutablePropertiesKHR = *const vkGetPipelineExecutablePropertiesKHR;
pub const PFN_vkGetPipelineExecutableStatisticsKHR = *const vkGetPipelineExecutableStatisticsKHR;
pub const PFN_vkGetPipelineExecutableInternalRepresentationsKHR = *const vkGetPipelineExecutableInternalRepresentationsKHR;
pub const PFN_vkCmdSetLineStipple = *const vkCmdSetLineStipple;
pub const vkCmdSetLineStippleKHR = vkCmdSetLineStipple;
pub const vkCmdSetLineStippleEXT = vkCmdSetLineStipple;
pub const PFN_vkGetFaultData = *const vkGetFaultData;
pub const PFN_vkGetPhysicalDeviceToolProperties = *const vkGetPhysicalDeviceToolProperties;
pub const vkGetPhysicalDeviceToolPropertiesEXT = vkGetPhysicalDeviceToolProperties;
pub const PFN_vkCreateAccelerationStructureKHR = *const vkCreateAccelerationStructureKHR;
pub const PFN_vkCmdBuildAccelerationStructuresKHR = *const vkCmdBuildAccelerationStructuresKHR;
pub const PFN_vkCmdBuildAccelerationStructuresIndirectKHR = *const vkCmdBuildAccelerationStructuresIndirectKHR;
pub const PFN_vkBuildAccelerationStructuresKHR = *const vkBuildAccelerationStructuresKHR;
pub const PFN_vkGetAccelerationStructureDeviceAddressKHR = *const vkGetAccelerationStructureDeviceAddressKHR;
pub const PFN_vkCreateDeferredOperationKHR = *const vkCreateDeferredOperationKHR;
pub const PFN_vkDestroyDeferredOperationKHR = *const vkDestroyDeferredOperationKHR;
pub const PFN_vkGetDeferredOperationMaxConcurrencyKHR = *const vkGetDeferredOperationMaxConcurrencyKHR;
pub const PFN_vkGetDeferredOperationResultKHR = *const vkGetDeferredOperationResultKHR;
pub const PFN_vkDeferredOperationJoinKHR = *const vkDeferredOperationJoinKHR;
pub const PFN_vkGetPipelineIndirectMemoryRequirementsNV = *const vkGetPipelineIndirectMemoryRequirementsNV;
pub const PFN_vkGetPipelineIndirectDeviceAddressNV = *const vkGetPipelineIndirectDeviceAddressNV;
pub const PFN_vkAntiLagUpdateAMD = *const vkAntiLagUpdateAMD;
pub const PFN_vkCmdSetCullMode = *const vkCmdSetCullMode;
pub const vkCmdSetCullModeEXT = vkCmdSetCullMode;
pub const PFN_vkCmdSetFrontFace = *const vkCmdSetFrontFace;
pub const vkCmdSetFrontFaceEXT = vkCmdSetFrontFace;
pub const PFN_vkCmdSetPrimitiveTopology = *const vkCmdSetPrimitiveTopology;
pub const vkCmdSetPrimitiveTopologyEXT = vkCmdSetPrimitiveTopology;
pub const PFN_vkCmdSetViewportWithCount = *const vkCmdSetViewportWithCount;
pub const vkCmdSetViewportWithCountEXT = vkCmdSetViewportWithCount;
pub const PFN_vkCmdSetScissorWithCount = *const vkCmdSetScissorWithCount;
pub const vkCmdSetScissorWithCountEXT = vkCmdSetScissorWithCount;
pub const PFN_vkCmdBindIndexBuffer2 = *const vkCmdBindIndexBuffer2;
pub const vkCmdBindIndexBuffer2KHR = vkCmdBindIndexBuffer2;
pub const PFN_vkCmdBindVertexBuffers2 = *const vkCmdBindVertexBuffers2;
pub const vkCmdBindVertexBuffers2EXT = vkCmdBindVertexBuffers2;
pub const PFN_vkCmdSetDepthTestEnable = *const vkCmdSetDepthTestEnable;
pub const vkCmdSetDepthTestEnableEXT = vkCmdSetDepthTestEnable;
pub const PFN_vkCmdSetDepthWriteEnable = *const vkCmdSetDepthWriteEnable;
pub const vkCmdSetDepthWriteEnableEXT = vkCmdSetDepthWriteEnable;
pub const PFN_vkCmdSetDepthCompareOp = *const vkCmdSetDepthCompareOp;
pub const vkCmdSetDepthCompareOpEXT = vkCmdSetDepthCompareOp;
pub const PFN_vkCmdSetDepthBoundsTestEnable = *const vkCmdSetDepthBoundsTestEnable;
pub const vkCmdSetDepthBoundsTestEnableEXT = vkCmdSetDepthBoundsTestEnable;
pub const PFN_vkCmdSetStencilTestEnable = *const vkCmdSetStencilTestEnable;
pub const vkCmdSetStencilTestEnableEXT = vkCmdSetStencilTestEnable;
pub const PFN_vkCmdSetStencilOp = *const vkCmdSetStencilOp;
pub const vkCmdSetStencilOpEXT = vkCmdSetStencilOp;
pub const PFN_vkCmdSetPatchControlPointsEXT = *const vkCmdSetPatchControlPointsEXT;
pub const PFN_vkCmdSetRasterizerDiscardEnable = *const vkCmdSetRasterizerDiscardEnable;
pub const vkCmdSetRasterizerDiscardEnableEXT = vkCmdSetRasterizerDiscardEnable;
pub const PFN_vkCmdSetDepthBiasEnable = *const vkCmdSetDepthBiasEnable;
pub const vkCmdSetDepthBiasEnableEXT = vkCmdSetDepthBiasEnable;
pub const PFN_vkCmdSetLogicOpEXT = *const vkCmdSetLogicOpEXT;
pub const PFN_vkCmdSetPrimitiveRestartEnable = *const vkCmdSetPrimitiveRestartEnable;
pub const vkCmdSetPrimitiveRestartEnableEXT = vkCmdSetPrimitiveRestartEnable;
pub const PFN_vkCmdSetTessellationDomainOriginEXT = *const vkCmdSetTessellationDomainOriginEXT;
pub const PFN_vkCmdSetDepthClampEnableEXT = *const vkCmdSetDepthClampEnableEXT;
pub const PFN_vkCmdSetPolygonModeEXT = *const vkCmdSetPolygonModeEXT;
pub const PFN_vkCmdSetRasterizationSamplesEXT = *const vkCmdSetRasterizationSamplesEXT;
pub const PFN_vkCmdSetSampleMaskEXT = *const vkCmdSetSampleMaskEXT;
pub const PFN_vkCmdSetAlphaToCoverageEnableEXT = *const vkCmdSetAlphaToCoverageEnableEXT;
pub const PFN_vkCmdSetAlphaToOneEnableEXT = *const vkCmdSetAlphaToOneEnableEXT;
pub const PFN_vkCmdSetLogicOpEnableEXT = *const vkCmdSetLogicOpEnableEXT;
pub const PFN_vkCmdSetColorBlendEnableEXT = *const vkCmdSetColorBlendEnableEXT;
pub const PFN_vkCmdSetColorBlendEquationEXT = *const vkCmdSetColorBlendEquationEXT;
pub const PFN_vkCmdSetColorWriteMaskEXT = *const vkCmdSetColorWriteMaskEXT;
pub const PFN_vkCmdSetRasterizationStreamEXT = *const vkCmdSetRasterizationStreamEXT;
pub const PFN_vkCmdSetConservativeRasterizationModeEXT = *const vkCmdSetConservativeRasterizationModeEXT;
pub const PFN_vkCmdSetExtraPrimitiveOverestimationSizeEXT = *const vkCmdSetExtraPrimitiveOverestimationSizeEXT;
pub const PFN_vkCmdSetDepthClipEnableEXT = *const vkCmdSetDepthClipEnableEXT;
pub const PFN_vkCmdSetSampleLocationsEnableEXT = *const vkCmdSetSampleLocationsEnableEXT;
pub const PFN_vkCmdSetColorBlendAdvancedEXT = *const vkCmdSetColorBlendAdvancedEXT;
pub const PFN_vkCmdSetProvokingVertexModeEXT = *const vkCmdSetProvokingVertexModeEXT;
pub const PFN_vkCmdSetLineRasterizationModeEXT = *const vkCmdSetLineRasterizationModeEXT;
pub const PFN_vkCmdSetLineStippleEnableEXT = *const vkCmdSetLineStippleEnableEXT;
pub const PFN_vkCmdSetDepthClipNegativeOneToOneEXT = *const vkCmdSetDepthClipNegativeOneToOneEXT;
pub const PFN_vkCmdSetViewportWScalingEnableNV = *const vkCmdSetViewportWScalingEnableNV;
pub const PFN_vkCmdSetViewportSwizzleNV = *const vkCmdSetViewportSwizzleNV;
pub const PFN_vkCmdSetCoverageToColorEnableNV = *const vkCmdSetCoverageToColorEnableNV;
pub const PFN_vkCmdSetCoverageToColorLocationNV = *const vkCmdSetCoverageToColorLocationNV;
pub const PFN_vkCmdSetCoverageModulationModeNV = *const vkCmdSetCoverageModulationModeNV;
pub const PFN_vkCmdSetCoverageModulationTableEnableNV = *const vkCmdSetCoverageModulationTableEnableNV;
pub const PFN_vkCmdSetCoverageModulationTableNV = *const vkCmdSetCoverageModulationTableNV;
pub const PFN_vkCmdSetShadingRateImageEnableNV = *const vkCmdSetShadingRateImageEnableNV;
pub const PFN_vkCmdSetCoverageReductionModeNV = *const vkCmdSetCoverageReductionModeNV;
pub const PFN_vkCmdSetRepresentativeFragmentTestEnableNV = *const vkCmdSetRepresentativeFragmentTestEnableNV;
pub const PFN_vkCreatePrivateDataSlot = *const vkCreatePrivateDataSlot;
pub const vkCreatePrivateDataSlotEXT = vkCreatePrivateDataSlot;
pub const PFN_vkDestroyPrivateDataSlot = *const vkDestroyPrivateDataSlot;
pub const vkDestroyPrivateDataSlotEXT = vkDestroyPrivateDataSlot;
pub const PFN_vkSetPrivateData = *const vkSetPrivateData;
pub const vkSetPrivateDataEXT = vkSetPrivateData;
pub const PFN_vkGetPrivateData = *const vkGetPrivateData;
pub const vkGetPrivateDataEXT = vkGetPrivateData;
pub const PFN_vkCmdCopyBuffer2 = *const vkCmdCopyBuffer2;
pub const vkCmdCopyBuffer2KHR = vkCmdCopyBuffer2;
pub const PFN_vkCmdCopyImage2 = *const vkCmdCopyImage2;
pub const vkCmdCopyImage2KHR = vkCmdCopyImage2;
pub const PFN_vkCmdBlitImage2 = *const vkCmdBlitImage2;
pub const vkCmdBlitImage2KHR = vkCmdBlitImage2;
pub const PFN_vkCmdCopyBufferToImage2 = *const vkCmdCopyBufferToImage2;
pub const vkCmdCopyBufferToImage2KHR = vkCmdCopyBufferToImage2;
pub const PFN_vkCmdCopyImageToBuffer2 = *const vkCmdCopyImageToBuffer2;
pub const vkCmdCopyImageToBuffer2KHR = vkCmdCopyImageToBuffer2;
pub const PFN_vkCmdResolveImage2 = *const vkCmdResolveImage2;
pub const vkCmdResolveImage2KHR = vkCmdResolveImage2;
pub const PFN_vkCmdRefreshObjectsKHR = *const vkCmdRefreshObjectsKHR;
pub const PFN_vkGetPhysicalDeviceRefreshableObjectTypesKHR = *const vkGetPhysicalDeviceRefreshableObjectTypesKHR;
pub const PFN_vkCmdSetFragmentShadingRateKHR = *const vkCmdSetFragmentShadingRateKHR;
pub const PFN_vkGetPhysicalDeviceFragmentShadingRatesKHR = *const vkGetPhysicalDeviceFragmentShadingRatesKHR;
pub const PFN_vkCmdSetFragmentShadingRateEnumNV = *const vkCmdSetFragmentShadingRateEnumNV;
pub const PFN_vkGetAccelerationStructureBuildSizesKHR = *const vkGetAccelerationStructureBuildSizesKHR;
pub const PFN_vkCmdSetVertexInputEXT = *const vkCmdSetVertexInputEXT;
pub const PFN_vkCmdSetColorWriteEnableEXT = *const vkCmdSetColorWriteEnableEXT;
pub const PFN_vkCmdSetEvent2 = *const vkCmdSetEvent2;
pub const vkCmdSetEvent2KHR = vkCmdSetEvent2;
pub const PFN_vkCmdResetEvent2 = *const vkCmdResetEvent2;
pub const vkCmdResetEvent2KHR = vkCmdResetEvent2;
pub const PFN_vkCmdWaitEvents2 = *const vkCmdWaitEvents2;
pub const vkCmdWaitEvents2KHR = vkCmdWaitEvents2;
pub const PFN_vkCmdPipelineBarrier2 = *const vkCmdPipelineBarrier2;
pub const vkCmdPipelineBarrier2KHR = vkCmdPipelineBarrier2;
pub const PFN_vkQueueSubmit2 = *const vkQueueSubmit2;
pub const vkQueueSubmit2KHR = vkQueueSubmit2;
pub const PFN_vkCmdWriteTimestamp2 = *const vkCmdWriteTimestamp2;
pub const vkCmdWriteTimestamp2KHR = vkCmdWriteTimestamp2;
pub const PFN_vkCmdWriteBufferMarker2AMD = *const vkCmdWriteBufferMarker2AMD;
pub const PFN_vkGetQueueCheckpointData2NV = *const vkGetQueueCheckpointData2NV;
pub const PFN_vkCopyMemoryToImage = *const vkCopyMemoryToImage;
pub const vkCopyMemoryToImageEXT = vkCopyMemoryToImage;
pub const PFN_vkCopyImageToMemory = *const vkCopyImageToMemory;
pub const vkCopyImageToMemoryEXT = vkCopyImageToMemory;
pub const PFN_vkCopyImageToImage = *const vkCopyImageToImage;
pub const vkCopyImageToImageEXT = vkCopyImageToImage;
pub const PFN_vkTransitionImageLayout = *const vkTransitionImageLayout;
pub const vkTransitionImageLayoutEXT = vkTransitionImageLayout;
pub const PFN_vkGetCommandPoolMemoryConsumption = *const vkGetCommandPoolMemoryConsumption;
pub const PFN_vkGetPhysicalDeviceVideoCapabilitiesKHR = *const vkGetPhysicalDeviceVideoCapabilitiesKHR;
pub const PFN_vkGetPhysicalDeviceVideoFormatPropertiesKHR = *const vkGetPhysicalDeviceVideoFormatPropertiesKHR;
pub const PFN_vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR = *const vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR;
pub const PFN_vkCreateVideoSessionKHR = *const vkCreateVideoSessionKHR;
pub const PFN_vkDestroyVideoSessionKHR = *const vkDestroyVideoSessionKHR;
pub const PFN_vkCreateVideoSessionParametersKHR = *const vkCreateVideoSessionParametersKHR;
pub const PFN_vkUpdateVideoSessionParametersKHR = *const vkUpdateVideoSessionParametersKHR;
pub const PFN_vkGetEncodedVideoSessionParametersKHR = *const vkGetEncodedVideoSessionParametersKHR;
pub const PFN_vkDestroyVideoSessionParametersKHR = *const vkDestroyVideoSessionParametersKHR;
pub const PFN_vkGetVideoSessionMemoryRequirementsKHR = *const vkGetVideoSessionMemoryRequirementsKHR;
pub const PFN_vkBindVideoSessionMemoryKHR = *const vkBindVideoSessionMemoryKHR;
pub const PFN_vkCmdDecodeVideoKHR = *const vkCmdDecodeVideoKHR;
pub const PFN_vkCmdBeginVideoCodingKHR = *const vkCmdBeginVideoCodingKHR;
pub const PFN_vkCmdControlVideoCodingKHR = *const vkCmdControlVideoCodingKHR;
pub const PFN_vkCmdEndVideoCodingKHR = *const vkCmdEndVideoCodingKHR;
pub const PFN_vkCmdEncodeVideoKHR = *const vkCmdEncodeVideoKHR;
pub const PFN_vkCmdDecompressMemoryNV = *const vkCmdDecompressMemoryNV;
pub const PFN_vkCmdDecompressMemoryIndirectCountNV = *const vkCmdDecompressMemoryIndirectCountNV;
pub const PFN_vkGetPartitionedAccelerationStructuresBuildSizesNV = *const vkGetPartitionedAccelerationStructuresBuildSizesNV;
pub const PFN_vkCmdBuildPartitionedAccelerationStructuresNV = *const vkCmdBuildPartitionedAccelerationStructuresNV;
pub const PFN_vkCmdDecompressMemoryEXT = *const vkCmdDecompressMemoryEXT;
pub const PFN_vkCmdDecompressMemoryIndirectCountEXT = *const vkCmdDecompressMemoryIndirectCountEXT;
pub const PFN_vkCreateCuModuleNVX = *const vkCreateCuModuleNVX;
pub const PFN_vkCreateCuFunctionNVX = *const vkCreateCuFunctionNVX;
pub const PFN_vkDestroyCuModuleNVX = *const vkDestroyCuModuleNVX;
pub const PFN_vkDestroyCuFunctionNVX = *const vkDestroyCuFunctionNVX;
pub const PFN_vkCmdCuLaunchKernelNVX = *const vkCmdCuLaunchKernelNVX;
pub const PFN_vkGetDescriptorSetLayoutSizeEXT = *const vkGetDescriptorSetLayoutSizeEXT;
pub const PFN_vkGetDescriptorSetLayoutBindingOffsetEXT = *const vkGetDescriptorSetLayoutBindingOffsetEXT;
pub const PFN_vkGetDescriptorEXT = *const vkGetDescriptorEXT;
pub const PFN_vkCmdBindDescriptorBuffersEXT = *const vkCmdBindDescriptorBuffersEXT;
pub const PFN_vkCmdSetDescriptorBufferOffsetsEXT = *const vkCmdSetDescriptorBufferOffsetsEXT;
pub const PFN_vkCmdBindDescriptorBufferEmbeddedSamplersEXT = *const vkCmdBindDescriptorBufferEmbeddedSamplersEXT;
pub const PFN_vkGetBufferOpaqueCaptureDescriptorDataEXT = *const vkGetBufferOpaqueCaptureDescriptorDataEXT;
pub const PFN_vkGetImageOpaqueCaptureDescriptorDataEXT = *const vkGetImageOpaqueCaptureDescriptorDataEXT;
pub const PFN_vkGetImageViewOpaqueCaptureDescriptorDataEXT = *const vkGetImageViewOpaqueCaptureDescriptorDataEXT;
pub const PFN_vkGetSamplerOpaqueCaptureDescriptorDataEXT = *const vkGetSamplerOpaqueCaptureDescriptorDataEXT;
pub const PFN_vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT = *const vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT;
pub const PFN_vkSetDeviceMemoryPriorityEXT = *const vkSetDeviceMemoryPriorityEXT;
pub const PFN_vkAcquireDrmDisplayEXT = *const vkAcquireDrmDisplayEXT;
pub const PFN_vkGetDrmDisplayEXT = *const vkGetDrmDisplayEXT;
pub const PFN_vkWaitForPresent2KHR = *const vkWaitForPresent2KHR;
pub const PFN_vkWaitForPresentKHR = *const vkWaitForPresentKHR;
pub const PFN_vkCreateBufferCollectionFUCHSIA = *const vkCreateBufferCollectionFUCHSIA;
pub const PFN_vkSetBufferCollectionBufferConstraintsFUCHSIA = *const vkSetBufferCollectionBufferConstraintsFUCHSIA;
pub const PFN_vkSetBufferCollectionImageConstraintsFUCHSIA = *const vkSetBufferCollectionImageConstraintsFUCHSIA;
pub const PFN_vkDestroyBufferCollectionFUCHSIA = *const vkDestroyBufferCollectionFUCHSIA;
pub const PFN_vkGetBufferCollectionPropertiesFUCHSIA = *const vkGetBufferCollectionPropertiesFUCHSIA;
pub const PFN_vkCreateCudaModuleNV = *const vkCreateCudaModuleNV;
pub const PFN_vkGetCudaModuleCacheNV = *const vkGetCudaModuleCacheNV;
pub const PFN_vkCreateCudaFunctionNV = *const vkCreateCudaFunctionNV;
pub const PFN_vkDestroyCudaModuleNV = *const vkDestroyCudaModuleNV;
pub const PFN_vkDestroyCudaFunctionNV = *const vkDestroyCudaFunctionNV;
pub const PFN_vkCmdCudaLaunchKernelNV = *const vkCmdCudaLaunchKernelNV;
pub const PFN_vkCmdBeginRendering = *const vkCmdBeginRendering;
pub const vkCmdBeginRenderingKHR = vkCmdBeginRendering;
pub const PFN_vkCmdEndRendering = *const vkCmdEndRendering;
pub const PFN_vkCmdEndRendering2KHR = *const vkCmdEndRendering2KHR;
pub const vkCmdEndRendering2EXT = vkCmdEndRendering2KHR;
pub const vkCmdEndRenderingKHR = vkCmdEndRendering;
pub const PFN_vkGetDescriptorSetLayoutHostMappingInfoVALVE = *const vkGetDescriptorSetLayoutHostMappingInfoVALVE;
pub const PFN_vkGetDescriptorSetHostMappingVALVE = *const vkGetDescriptorSetHostMappingVALVE;
pub const PFN_vkCreateMicromapEXT = *const vkCreateMicromapEXT;
pub const PFN_vkCmdBuildMicromapsEXT = *const vkCmdBuildMicromapsEXT;
pub const PFN_vkBuildMicromapsEXT = *const vkBuildMicromapsEXT;
pub const PFN_vkDestroyMicromapEXT = *const vkDestroyMicromapEXT;
pub const PFN_vkCmdCopyMicromapEXT = *const vkCmdCopyMicromapEXT;
pub const PFN_vkCopyMicromapEXT = *const vkCopyMicromapEXT;
pub const PFN_vkCmdCopyMicromapToMemoryEXT = *const vkCmdCopyMicromapToMemoryEXT;
pub const PFN_vkCopyMicromapToMemoryEXT = *const vkCopyMicromapToMemoryEXT;
pub const PFN_vkCmdCopyMemoryToMicromapEXT = *const vkCmdCopyMemoryToMicromapEXT;
pub const PFN_vkCopyMemoryToMicromapEXT = *const vkCopyMemoryToMicromapEXT;
pub const PFN_vkCmdWriteMicromapsPropertiesEXT = *const vkCmdWriteMicromapsPropertiesEXT;
pub const PFN_vkWriteMicromapsPropertiesEXT = *const vkWriteMicromapsPropertiesEXT;
pub const PFN_vkGetDeviceMicromapCompatibilityEXT = *const vkGetDeviceMicromapCompatibilityEXT;
pub const PFN_vkGetMicromapBuildSizesEXT = *const vkGetMicromapBuildSizesEXT;
pub const PFN_vkGetShaderModuleIdentifierEXT = *const vkGetShaderModuleIdentifierEXT;
pub const PFN_vkGetShaderModuleCreateInfoIdentifierEXT = *const vkGetShaderModuleCreateInfoIdentifierEXT;
pub const PFN_vkGetImageSubresourceLayout2 = *const vkGetImageSubresourceLayout2;
pub const vkGetImageSubresourceLayout2KHR = vkGetImageSubresourceLayout2;
pub const vkGetImageSubresourceLayout2EXT = vkGetImageSubresourceLayout2;
pub const PFN_vkGetPipelinePropertiesEXT = *const vkGetPipelinePropertiesEXT;
pub const PFN_vkExportMetalObjectsEXT = *const vkExportMetalObjectsEXT;
pub const PFN_vkCmdBindTileMemoryQCOM = *const vkCmdBindTileMemoryQCOM;
pub const PFN_vkGetFramebufferTilePropertiesQCOM = *const vkGetFramebufferTilePropertiesQCOM;
pub const PFN_vkGetDynamicRenderingTilePropertiesQCOM = *const vkGetDynamicRenderingTilePropertiesQCOM;
pub const PFN_vkGetPhysicalDeviceOpticalFlowImageFormatsNV = *const vkGetPhysicalDeviceOpticalFlowImageFormatsNV;
pub const PFN_vkCreateOpticalFlowSessionNV = *const vkCreateOpticalFlowSessionNV;
pub const PFN_vkDestroyOpticalFlowSessionNV = *const vkDestroyOpticalFlowSessionNV;
pub const PFN_vkBindOpticalFlowSessionImageNV = *const vkBindOpticalFlowSessionImageNV;
pub const PFN_vkCmdOpticalFlowExecuteNV = *const vkCmdOpticalFlowExecuteNV;
pub const PFN_vkGetDeviceFaultInfoEXT = *const vkGetDeviceFaultInfoEXT;
pub const PFN_vkCmdSetDepthBias2EXT = *const vkCmdSetDepthBias2EXT;
pub const PFN_vkReleaseSwapchainImagesKHR = *const vkReleaseSwapchainImagesKHR;
pub const vkReleaseSwapchainImagesEXT = vkReleaseSwapchainImagesKHR;
pub const PFN_vkGetDeviceImageSubresourceLayout = *const vkGetDeviceImageSubresourceLayout;
pub const vkGetDeviceImageSubresourceLayoutKHR = vkGetDeviceImageSubresourceLayout;
pub const PFN_vkMapMemory2 = *const vkMapMemory2;
pub const vkMapMemory2KHR = vkMapMemory2;
pub const PFN_vkUnmapMemory2 = *const vkUnmapMemory2;
pub const vkUnmapMemory2KHR = vkUnmapMemory2;
pub const PFN_vkCreateShadersEXT = *const vkCreateShadersEXT;
pub const PFN_vkDestroyShaderEXT = *const vkDestroyShaderEXT;
pub const PFN_vkGetShaderBinaryDataEXT = *const vkGetShaderBinaryDataEXT;
pub const PFN_vkCmdBindShadersEXT = *const vkCmdBindShadersEXT;
pub const PFN_vkSetSwapchainPresentTimingQueueSizeEXT = *const vkSetSwapchainPresentTimingQueueSizeEXT;
pub const PFN_vkGetSwapchainTimingPropertiesEXT = *const vkGetSwapchainTimingPropertiesEXT;
pub const PFN_vkGetSwapchainTimeDomainPropertiesEXT = *const vkGetSwapchainTimeDomainPropertiesEXT;
pub const PFN_vkGetPastPresentationTimingEXT = *const vkGetPastPresentationTimingEXT;
pub const PFN_vkGetScreenBufferPropertiesQNX = *const vkGetScreenBufferPropertiesQNX;
pub const PFN_vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR = *const vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR;
pub const PFN_vkGetExecutionGraphPipelineScratchSizeAMDX = *const vkGetExecutionGraphPipelineScratchSizeAMDX;
pub const PFN_vkGetExecutionGraphPipelineNodeIndexAMDX = *const vkGetExecutionGraphPipelineNodeIndexAMDX;
pub const PFN_vkCreateExecutionGraphPipelinesAMDX = *const vkCreateExecutionGraphPipelinesAMDX;
pub const PFN_vkCmdInitializeGraphScratchMemoryAMDX = *const vkCmdInitializeGraphScratchMemoryAMDX;
pub const PFN_vkCmdDispatchGraphAMDX = *const vkCmdDispatchGraphAMDX;
pub const PFN_vkCmdDispatchGraphIndirectAMDX = *const vkCmdDispatchGraphIndirectAMDX;
pub const PFN_vkCmdDispatchGraphIndirectCountAMDX = *const vkCmdDispatchGraphIndirectCountAMDX;
pub const PFN_vkCmdBindDescriptorSets2 = *const vkCmdBindDescriptorSets2;
pub const vkCmdBindDescriptorSets2KHR = vkCmdBindDescriptorSets2;
pub const PFN_vkCmdPushConstants2 = *const vkCmdPushConstants2;
pub const vkCmdPushConstants2KHR = vkCmdPushConstants2;
pub const PFN_vkCmdPushDescriptorSet2 = *const vkCmdPushDescriptorSet2;
pub const vkCmdPushDescriptorSet2KHR = vkCmdPushDescriptorSet2;
pub const PFN_vkCmdPushDescriptorSetWithTemplate2 = *const vkCmdPushDescriptorSetWithTemplate2;
pub const vkCmdPushDescriptorSetWithTemplate2KHR = vkCmdPushDescriptorSetWithTemplate2;
pub const PFN_vkCmdSetDescriptorBufferOffsets2EXT = *const vkCmdSetDescriptorBufferOffsets2EXT;
pub const PFN_vkCmdBindDescriptorBufferEmbeddedSamplers2EXT = *const vkCmdBindDescriptorBufferEmbeddedSamplers2EXT;
pub const PFN_vkSetLatencySleepModeNV = *const vkSetLatencySleepModeNV;
pub const PFN_vkLatencySleepNV = *const vkLatencySleepNV;
pub const PFN_vkSetLatencyMarkerNV = *const vkSetLatencyMarkerNV;
pub const PFN_vkGetLatencyTimingsNV = *const vkGetLatencyTimingsNV;
pub const PFN_vkQueueNotifyOutOfBandNV = *const vkQueueNotifyOutOfBandNV;
pub const PFN_vkCmdSetRenderingAttachmentLocations = *const vkCmdSetRenderingAttachmentLocations;
pub const vkCmdSetRenderingAttachmentLocationsKHR = vkCmdSetRenderingAttachmentLocations;
pub const PFN_vkCmdSetRenderingInputAttachmentIndices = *const vkCmdSetRenderingInputAttachmentIndices;
pub const vkCmdSetRenderingInputAttachmentIndicesKHR = vkCmdSetRenderingInputAttachmentIndices;
pub const PFN_vkCmdSetDepthClampRangeEXT = *const vkCmdSetDepthClampRangeEXT;
pub const PFN_vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV = *const vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV;
pub const PFN_vkGetMemoryMetalHandleEXT = *const vkGetMemoryMetalHandleEXT;
pub const PFN_vkGetMemoryMetalHandlePropertiesEXT = *const vkGetMemoryMetalHandlePropertiesEXT;
pub const PFN_vkGetPhysicalDeviceCooperativeVectorPropertiesNV = *const vkGetPhysicalDeviceCooperativeVectorPropertiesNV;
pub const PFN_vkConvertCooperativeVectorMatrixNV = *const vkConvertCooperativeVectorMatrixNV;
pub const PFN_vkCmdConvertCooperativeVectorMatrixNV = *const vkCmdConvertCooperativeVectorMatrixNV;
pub const PFN_vkCmdDispatchTileQCOM = *const vkCmdDispatchTileQCOM;
pub const PFN_vkCmdBeginPerTileExecutionQCOM = *const vkCmdBeginPerTileExecutionQCOM;
pub const PFN_vkCmdEndPerTileExecutionQCOM = *const vkCmdEndPerTileExecutionQCOM;
pub const PFN_vkCreateExternalComputeQueueNV = *const vkCreateExternalComputeQueueNV;
pub const PFN_vkDestroyExternalComputeQueueNV = *const vkDestroyExternalComputeQueueNV;
pub const PFN_vkGetExternalComputeQueueDataNV = *const vkGetExternalComputeQueueDataNV;
pub const PFN_vkCreateTensorARM = *const vkCreateTensorARM;
pub const PFN_vkDestroyTensorARM = *const vkDestroyTensorARM;
pub const PFN_vkCreateTensorViewARM = *const vkCreateTensorViewARM;
pub const PFN_vkDestroyTensorViewARM = *const vkDestroyTensorViewARM;
pub const PFN_vkGetTensorMemoryRequirementsARM = *const vkGetTensorMemoryRequirementsARM;
pub const PFN_vkBindTensorMemoryARM = *const vkBindTensorMemoryARM;
pub const PFN_vkGetDeviceTensorMemoryRequirementsARM = *const vkGetDeviceTensorMemoryRequirementsARM;
pub const PFN_vkCmdCopyTensorARM = *const vkCmdCopyTensorARM;
pub const PFN_vkGetTensorOpaqueCaptureDescriptorDataARM = *const vkGetTensorOpaqueCaptureDescriptorDataARM;
pub const PFN_vkGetTensorViewOpaqueCaptureDescriptorDataARM = *const vkGetTensorViewOpaqueCaptureDescriptorDataARM;
pub const PFN_vkGetPhysicalDeviceExternalTensorPropertiesARM = *const vkGetPhysicalDeviceExternalTensorPropertiesARM;
pub const PFN_vkCreateDataGraphPipelinesARM = *const vkCreateDataGraphPipelinesARM;
pub const PFN_vkCreateDataGraphPipelineSessionARM = *const vkCreateDataGraphPipelineSessionARM;
pub const PFN_vkGetDataGraphPipelineSessionBindPointRequirementsARM = *const vkGetDataGraphPipelineSessionBindPointRequirementsARM;
pub const PFN_vkGetDataGraphPipelineSessionMemoryRequirementsARM = *const vkGetDataGraphPipelineSessionMemoryRequirementsARM;
pub const PFN_vkBindDataGraphPipelineSessionMemoryARM = *const vkBindDataGraphPipelineSessionMemoryARM;
pub const PFN_vkDestroyDataGraphPipelineSessionARM = *const vkDestroyDataGraphPipelineSessionARM;
pub const PFN_vkCmdDispatchDataGraphARM = *const vkCmdDispatchDataGraphARM;
pub const PFN_vkGetDataGraphPipelineAvailablePropertiesARM = *const vkGetDataGraphPipelineAvailablePropertiesARM;
pub const PFN_vkGetDataGraphPipelinePropertiesARM = *const vkGetDataGraphPipelinePropertiesARM;
pub const PFN_vkGetPhysicalDeviceQueueFamilyDataGraphPropertiesARM = *const vkGetPhysicalDeviceQueueFamilyDataGraphPropertiesARM;
pub const PFN_vkGetPhysicalDeviceQueueFamilyDataGraphProcessingEnginePropertiesARM = *const vkGetPhysicalDeviceQueueFamilyDataGraphProcessingEnginePropertiesARM;
pub const PFN_vkGetNativeBufferPropertiesOHOS = *const vkGetNativeBufferPropertiesOHOS;
pub const PFN_vkGetMemoryNativeBufferOHOS = *const vkGetMemoryNativeBufferOHOS;
pub const PFN_vkGetSwapchainGrallocUsageOHOS = *const vkGetSwapchainGrallocUsageOHOS;
pub const PFN_vkAcquireImageOHOS = *const vkAcquireImageOHOS;
pub const PFN_vkQueueSignalReleaseImageOHOS = *const vkQueueSignalReleaseImageOHOS;
pub const PFN_vkEnumeratePhysicalDeviceQueueFamilyPerformanceCountersByRegionARM = *const vkEnumeratePhysicalDeviceQueueFamilyPerformanceCountersByRegionARM;
pub const PFN_vkCmdSetComputeOccupancyPriorityNV = *const vkCmdSetComputeOccupancyPriorityNV;

// Unknown types
pub const VkPrivateDataSlotCreateFlagBits = if (@hasDecl(@import("root"), "VkPrivateDataSlotCreateFlagBits")) @import("root").VkPrivateDataSlotCreateFlagBits else blk: {
    break :blk struct {};
};
pub const ANativeWindow = if (@hasDecl(@import("root"), "ANativeWindow")) @import("root").ANativeWindow else blk: {
    break :blk struct {};
};
pub const wl_display = if (@hasDecl(@import("root"), "wl_display")) @import("root").wl_display else blk: {
    break :blk struct {};
};
pub const wl_surface = if (@hasDecl(@import("root"), "wl_surface")) @import("root").wl_surface else blk: {
    break :blk struct {};
};
pub const HINSTANCE = if (@hasDecl(@import("root"), "HINSTANCE")) @import("root").HINSTANCE else blk: {
    break :blk struct {};
};
pub const HWND = if (@hasDecl(@import("root"), "HWND")) @import("root").HWND else blk: {
    break :blk struct {};
};
pub const Display = if (@hasDecl(@import("root"), "Display")) @import("root").Display else blk: {
    break :blk struct {};
};
pub const Window = if (@hasDecl(@import("root"), "Window")) @import("root").Window else blk: {
    break :blk struct {};
};
pub const xcb_connection_t = if (@hasDecl(@import("root"), "xcb_connection_t")) @import("root").xcb_connection_t else blk: {
    break :blk struct {};
};
pub const xcb_window_t = if (@hasDecl(@import("root"), "xcb_window_t")) @import("root").xcb_window_t else blk: {
    break :blk struct {};
};
pub const IDirectFB = if (@hasDecl(@import("root"), "IDirectFB")) @import("root").IDirectFB else blk: {
    break :blk struct {};
};
pub const IDirectFBSurface = if (@hasDecl(@import("root"), "IDirectFBSurface")) @import("root").IDirectFBSurface else blk: {
    break :blk struct {};
};
pub const zx_handle_t = if (@hasDecl(@import("root"), "zx_handle_t")) @import("root").zx_handle_t else blk: {
    break :blk struct {};
};
pub const GgpStreamDescriptor = if (@hasDecl(@import("root"), "GgpStreamDescriptor")) @import("root").GgpStreamDescriptor else blk: {
    break :blk struct {};
};
pub const _screen_context = if (@hasDecl(@import("root"), "_screen_context")) @import("root")._screen_context else blk: {
    break :blk struct {};
};
pub const _screen_window = if (@hasDecl(@import("root"), "_screen_window")) @import("root")._screen_window else blk: {
    break :blk struct {};
};
pub const HANDLE = if (@hasDecl(@import("root"), "HANDLE")) @import("root").HANDLE else blk: {
    break :blk struct {};
};
pub const SECURITY_ATTRIBUTES = if (@hasDecl(@import("root"), "SECURITY_ATTRIBUTES")) @import("root").SECURITY_ATTRIBUTES else blk: {
    break :blk struct {};
};
pub const DWORD = if (@hasDecl(@import("root"), "DWORD")) @import("root").DWORD else blk: {
    break :blk struct {};
};
pub const NvSciBufAttrList = if (@hasDecl(@import("root"), "NvSciBufAttrList")) @import("root").NvSciBufAttrList else blk: {
    break :blk struct {};
};
pub const NvSciBufObj = if (@hasDecl(@import("root"), "NvSciBufObj")) @import("root").NvSciBufObj else blk: {
    break :blk struct {};
};
pub const LPCWSTR = if (@hasDecl(@import("root"), "LPCWSTR")) @import("root").LPCWSTR else blk: {
    break :blk struct {};
};
pub const int = if (@hasDecl(@import("root"), "int")) @import("root").int else blk: {
    break :blk struct {};
};
pub const NvSciSyncAttrList = if (@hasDecl(@import("root"), "NvSciSyncAttrList")) @import("root").NvSciSyncAttrList else blk: {
    break :blk struct {};
};
pub const NvSciSyncObj = if (@hasDecl(@import("root"), "NvSciSyncObj")) @import("root").NvSciSyncObj else blk: {
    break :blk struct {};
};
pub const NvSciSyncFence = if (@hasDecl(@import("root"), "NvSciSyncFence")) @import("root").NvSciSyncFence else blk: {
    break :blk struct {};
};
pub const CAMetalLayer = if (@hasDecl(@import("root"), "CAMetalLayer")) @import("root").CAMetalLayer else blk: {
    break :blk struct {};
};
pub const AHardwareBuffer = if (@hasDecl(@import("root"), "AHardwareBuffer")) @import("root").AHardwareBuffer else blk: {
    break :blk struct {};
};
pub const VkBuildAccelerationStructureFlagsNV = if (@hasDecl(@import("root"), "VkBuildAccelerationStructureFlagsNV")) @import("root").VkBuildAccelerationStructureFlagsNV else blk: {
    break :blk struct {};
};
pub const GgpFrameToken = if (@hasDecl(@import("root"), "GgpFrameToken")) @import("root").GgpFrameToken else blk: {
    break :blk struct {};
};
pub const HMONITOR = if (@hasDecl(@import("root"), "HMONITOR")) @import("root").HMONITOR else blk: {
    break :blk struct {};
};
pub const StdVideoH264ProfileIdc = if (@hasDecl(@import("root"), "StdVideoH264ProfileIdc")) @import("root").StdVideoH264ProfileIdc else blk: {
    break :blk struct {};
};
pub const StdVideoH264LevelIdc = if (@hasDecl(@import("root"), "StdVideoH264LevelIdc")) @import("root").StdVideoH264LevelIdc else blk: {
    break :blk struct {};
};
pub const StdVideoH264SequenceParameterSet = if (@hasDecl(@import("root"), "StdVideoH264SequenceParameterSet")) @import("root").StdVideoH264SequenceParameterSet else blk: {
    break :blk struct {};
};
pub const StdVideoH264PictureParameterSet = if (@hasDecl(@import("root"), "StdVideoH264PictureParameterSet")) @import("root").StdVideoH264PictureParameterSet else blk: {
    break :blk struct {};
};
pub const StdVideoDecodeH264PictureInfo = if (@hasDecl(@import("root"), "StdVideoDecodeH264PictureInfo")) @import("root").StdVideoDecodeH264PictureInfo else blk: {
    break :blk struct {};
};
pub const StdVideoDecodeH264ReferenceInfo = if (@hasDecl(@import("root"), "StdVideoDecodeH264ReferenceInfo")) @import("root").StdVideoDecodeH264ReferenceInfo else blk: {
    break :blk struct {};
};
pub const StdVideoH265ProfileIdc = if (@hasDecl(@import("root"), "StdVideoH265ProfileIdc")) @import("root").StdVideoH265ProfileIdc else blk: {
    break :blk struct {};
};
pub const StdVideoH265LevelIdc = if (@hasDecl(@import("root"), "StdVideoH265LevelIdc")) @import("root").StdVideoH265LevelIdc else blk: {
    break :blk struct {};
};
pub const StdVideoH265VideoParameterSet = if (@hasDecl(@import("root"), "StdVideoH265VideoParameterSet")) @import("root").StdVideoH265VideoParameterSet else blk: {
    break :blk struct {};
};
pub const StdVideoH265SequenceParameterSet = if (@hasDecl(@import("root"), "StdVideoH265SequenceParameterSet")) @import("root").StdVideoH265SequenceParameterSet else blk: {
    break :blk struct {};
};
pub const StdVideoH265PictureParameterSet = if (@hasDecl(@import("root"), "StdVideoH265PictureParameterSet")) @import("root").StdVideoH265PictureParameterSet else blk: {
    break :blk struct {};
};
pub const StdVideoDecodeH265PictureInfo = if (@hasDecl(@import("root"), "StdVideoDecodeH265PictureInfo")) @import("root").StdVideoDecodeH265PictureInfo else blk: {
    break :blk struct {};
};
pub const StdVideoDecodeH265ReferenceInfo = if (@hasDecl(@import("root"), "StdVideoDecodeH265ReferenceInfo")) @import("root").StdVideoDecodeH265ReferenceInfo else blk: {
    break :blk struct {};
};
pub const StdVideoVP9Profile = if (@hasDecl(@import("root"), "StdVideoVP9Profile")) @import("root").StdVideoVP9Profile else blk: {
    break :blk struct {};
};
pub const StdVideoVP9Level = if (@hasDecl(@import("root"), "StdVideoVP9Level")) @import("root").StdVideoVP9Level else blk: {
    break :blk struct {};
};
pub const StdVideoDecodeVP9PictureInfo = if (@hasDecl(@import("root"), "StdVideoDecodeVP9PictureInfo")) @import("root").StdVideoDecodeVP9PictureInfo else blk: {
    break :blk struct {};
};
pub const StdVideoAV1Profile = if (@hasDecl(@import("root"), "StdVideoAV1Profile")) @import("root").StdVideoAV1Profile else blk: {
    break :blk struct {};
};
pub const StdVideoAV1Level = if (@hasDecl(@import("root"), "StdVideoAV1Level")) @import("root").StdVideoAV1Level else blk: {
    break :blk struct {};
};
pub const StdVideoAV1SequenceHeader = if (@hasDecl(@import("root"), "StdVideoAV1SequenceHeader")) @import("root").StdVideoAV1SequenceHeader else blk: {
    break :blk struct {};
};
pub const StdVideoDecodeAV1PictureInfo = if (@hasDecl(@import("root"), "StdVideoDecodeAV1PictureInfo")) @import("root").StdVideoDecodeAV1PictureInfo else blk: {
    break :blk struct {};
};
pub const StdVideoDecodeAV1ReferenceInfo = if (@hasDecl(@import("root"), "StdVideoDecodeAV1ReferenceInfo")) @import("root").StdVideoDecodeAV1ReferenceInfo else blk: {
    break :blk struct {};
};
pub const StdVideoEncodeH264ReferenceInfo = if (@hasDecl(@import("root"), "StdVideoEncodeH264ReferenceInfo")) @import("root").StdVideoEncodeH264ReferenceInfo else blk: {
    break :blk struct {};
};
pub const StdVideoEncodeH264PictureInfo = if (@hasDecl(@import("root"), "StdVideoEncodeH264PictureInfo")) @import("root").StdVideoEncodeH264PictureInfo else blk: {
    break :blk struct {};
};
pub const StdVideoEncodeH264SliceHeader = if (@hasDecl(@import("root"), "StdVideoEncodeH264SliceHeader")) @import("root").StdVideoEncodeH264SliceHeader else blk: {
    break :blk struct {};
};
pub const StdVideoEncodeH265PictureInfo = if (@hasDecl(@import("root"), "StdVideoEncodeH265PictureInfo")) @import("root").StdVideoEncodeH265PictureInfo else blk: {
    break :blk struct {};
};
pub const StdVideoEncodeH265SliceSegmentHeader = if (@hasDecl(@import("root"), "StdVideoEncodeH265SliceSegmentHeader")) @import("root").StdVideoEncodeH265SliceSegmentHeader else blk: {
    break :blk struct {};
};
pub const StdVideoEncodeH265ReferenceInfo = if (@hasDecl(@import("root"), "StdVideoEncodeH265ReferenceInfo")) @import("root").StdVideoEncodeH265ReferenceInfo else blk: {
    break :blk struct {};
};
pub const StdVideoEncodeAV1DecoderModelInfo = if (@hasDecl(@import("root"), "StdVideoEncodeAV1DecoderModelInfo")) @import("root").StdVideoEncodeAV1DecoderModelInfo else blk: {
    break :blk struct {};
};
pub const StdVideoEncodeAV1OperatingPointInfo = if (@hasDecl(@import("root"), "StdVideoEncodeAV1OperatingPointInfo")) @import("root").StdVideoEncodeAV1OperatingPointInfo else blk: {
    break :blk struct {};
};
pub const StdVideoEncodeAV1ReferenceInfo = if (@hasDecl(@import("root"), "StdVideoEncodeAV1ReferenceInfo")) @import("root").StdVideoEncodeAV1ReferenceInfo else blk: {
    break :blk struct {};
};
pub const StdVideoEncodeAV1PictureInfo = if (@hasDecl(@import("root"), "StdVideoEncodeAV1PictureInfo")) @import("root").StdVideoEncodeAV1PictureInfo else blk: {
    break :blk struct {};
};
pub const MTLDevice_id = if (@hasDecl(@import("root"), "MTLDevice_id")) @import("root").MTLDevice_id else blk: {
    break :blk struct {};
};
pub const MTLCommandQueue_id = if (@hasDecl(@import("root"), "MTLCommandQueue_id")) @import("root").MTLCommandQueue_id else blk: {
    break :blk struct {};
};
pub const MTLBuffer_id = if (@hasDecl(@import("root"), "MTLBuffer_id")) @import("root").MTLBuffer_id else blk: {
    break :blk struct {};
};
pub const MTLTexture_id = if (@hasDecl(@import("root"), "MTLTexture_id")) @import("root").MTLTexture_id else blk: {
    break :blk struct {};
};
pub const IOSurfaceRef = if (@hasDecl(@import("root"), "IOSurfaceRef")) @import("root").IOSurfaceRef else blk: {
    break :blk struct {};
};
pub const MTLSharedEvent_id = if (@hasDecl(@import("root"), "MTLSharedEvent_id")) @import("root").MTLSharedEvent_id else blk: {
    break :blk struct {};
};
pub const VkMemoryDecompressionMethodFlagsNV = if (@hasDecl(@import("root"), "VkMemoryDecompressionMethodFlagsNV")) @import("root").VkMemoryDecompressionMethodFlagsNV else blk: {
    break :blk struct {};
};
pub const _screen_buffer = if (@hasDecl(@import("root"), "_screen_buffer")) @import("root")._screen_buffer else blk: {
    break :blk struct {};
};
pub const OHNativeWindow = if (@hasDecl(@import("root"), "OHNativeWindow")) @import("root").OHNativeWindow else blk: {
    break :blk struct {};
};
pub const VkPipelineCreateFlags2KHR = if (@hasDecl(@import("root"), "VkPipelineCreateFlags2KHR")) @import("root").VkPipelineCreateFlags2KHR else blk: {
    break :blk struct {};
};
pub const OHBufferHandle = if (@hasDecl(@import("root"), "OHBufferHandle")) @import("root").OHBufferHandle else blk: {
    break :blk struct {};
};
pub const OH_NativeBuffer = if (@hasDecl(@import("root"), "OH_NativeBuffer")) @import("root").OH_NativeBuffer else blk: {
    break :blk struct {};
};
pub const VisualID = if (@hasDecl(@import("root"), "VisualID")) @import("root").VisualID else blk: {
    break :blk struct {};
};
pub const xcb_visualid_t = if (@hasDecl(@import("root"), "xcb_visualid_t")) @import("root").xcb_visualid_t else blk: {
    break :blk struct {};
};
pub const RROutput = if (@hasDecl(@import("root"), "RROutput")) @import("root").RROutput else blk: {
    break :blk struct {};
};

// Extensions
pub const VK_KHR_surface_name = "VK_KHR_surface";
// Extension: VK_KHR_surface
// Number: 1
// Type: instance
// Author: KHR
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_SURFACE_SPEC_VERSION
//             Negative: false
//             Value: 25
//         Enum:
//             Name: VK_KHR_SURFACE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_surface&quot;
//         Enum:
//             Name: VK_ERROR_SURFACE_LOST_KHR
//             Negative: true
//             Extends: VkResult
//             Offset: 0
//         Enum:
//             Name: VK_ERROR_NATIVE_WINDOW_IN_USE_KHR
//             Negative: true
//             Extends: VkResult
//             Offset: 1
//         Enum:
//             Name: VK_OBJECT_TYPE_SURFACE_KHR
//             Negative: false
//             Extends: VkObjectType
//             Offset: 0
//         Type:
//             Name: VkSurfaceKHR
//         Type:
//             Name: VkSurfaceTransformFlagBitsKHR
//         Type:
//             Name: VkPresentModeKHR
//         Type:
//             Name: VkColorSpaceKHR
//         Type:
//             Name: VkCompositeAlphaFlagBitsKHR
//         Type:
//             Name: VkCompositeAlphaFlagsKHR
//         Type:
//             Name: VkSurfaceCapabilitiesKHR
//         Type:
//             Name: VkSurfaceFormatKHR
//         Command:
//             Name: vkDestroySurfaceKHR
//         Command:
//             Name: vkGetPhysicalDeviceSurfaceSupportKHR
//         Command:
//             Name: vkGetPhysicalDeviceSurfaceCapabilitiesKHR
//         Command:
//             Name: vkGetPhysicalDeviceSurfaceFormatsKHR
//         Command:
//             Name: vkGetPhysicalDeviceSurfacePresentModesKHR
pub const VK_KHR_swapchain_name = "VK_KHR_swapchain";
// Extension: VK_KHR_swapchain
// Number: 2
// Type: device
// Author: KHR
// Depends: VK_KHR_surface
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_SWAPCHAIN_SPEC_VERSION
//             Negative: false
//             Value: 70
//         Enum:
//             Name: VK_KHR_SWAPCHAIN_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_swapchain&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PRESENT_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_IMAGE_LAYOUT_PRESENT_SRC_KHR
//             Negative: false
//             Extends: VkImageLayout
//             Offset: 2
//         Enum:
//             Name: VK_SUBOPTIMAL_KHR
//             Negative: false
//             Extends: VkResult
//             Offset: 3
//         Enum:
//             Name: VK_ERROR_OUT_OF_DATE_KHR
//             Negative: true
//             Extends: VkResult
//             Offset: 4
//         Enum:
//             Name: VK_OBJECT_TYPE_SWAPCHAIN_KHR
//             Negative: false
//             Extends: VkObjectType
//             Offset: 0
//         Type:
//             Name: VkSwapchainCreateFlagBitsKHR
//         Type:
//             Name: VkSwapchainCreateFlagsKHR
//         Type:
//             Name: VkSwapchainCreateInfoKHR
//         Type:
//             Name: VkSwapchainKHR
//         Type:
//             Name: VkPresentInfoKHR
//         Command:
//             Name: vkCreateSwapchainKHR
//         Command:
//             Name: vkDestroySwapchainKHR
//         Command:
//             Name: vkGetSwapchainImagesKHR
//         Command:
//             Name: vkAcquireNextImageKHR
//         Command:
//             Name: vkQueuePresentKHR
//     Depends: VK_VERSION_1_1
//         Comment:
//             This duplicates definitions in VK_KHR_device_group below
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Extnumber: 61
//             Offset: 7
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Extnumber: 61
//             Offset: 8
//         Enum:
//             Name: VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Extnumber: 61
//             Offset: 9
//         Enum:
//             Name: VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Extnumber: 61
//             Offset: 10
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Extnumber: 61
//             Offset: 11
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Extnumber: 61
//             Offset: 12
//         Enum:
//             Name: VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR
//             Negative: false
//             Bitpos: 0
//             Extends: VkSwapchainCreateFlagBitsKHR
//             Comment:
//                 Allow images with VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT
//         Type:
//             Name: VkImageSwapchainCreateInfoKHR
//         Type:
//             Name: VkBindImageMemorySwapchainInfoKHR
//         Type:
//             Name: VkAcquireNextImageInfoKHR
//         Type:
//             Name: VkDeviceGroupPresentModeFlagBitsKHR
//         Type:
//             Name: VkDeviceGroupPresentModeFlagsKHR
//         Type:
//             Name: VkDeviceGroupPresentCapabilitiesKHR
//         Type:
//             Name: VkDeviceGroupPresentInfoKHR
//         Type:
//             Name: VkDeviceGroupSwapchainCreateInfoKHR
//         Command:
//             Name: vkGetDeviceGroupPresentCapabilitiesKHR
//         Command:
//             Name: vkGetDeviceGroupSurfacePresentModesKHR
//         Command:
//             Name: vkGetPhysicalDevicePresentRectanglesKHR
//         Command:
//             Name: vkAcquireNextImage2KHR
//         Enum:
//             Name: VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR
//             Negative: false
//             Bitpos: 1
//             Extends: VkSwapchainCreateFlagBitsKHR
//             Comment:
//                 Swapchain is protected
pub const VK_KHR_display_name = "VK_KHR_display";
// Extension: VK_KHR_display
// Number: 3
// Type: instance
// Author: KHR
// Depends: VK_KHR_surface
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_DISPLAY_SPEC_VERSION
//             Negative: false
//             Value: 23
//         Enum:
//             Name: VK_KHR_DISPLAY_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_display&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_OBJECT_TYPE_DISPLAY_KHR
//             Negative: false
//             Extends: VkObjectType
//             Offset: 0
//         Enum:
//             Name: VK_OBJECT_TYPE_DISPLAY_MODE_KHR
//             Negative: false
//             Extends: VkObjectType
//             Offset: 1
//         Type:
//             Name: VkDisplayKHR
//         Type:
//             Name: VkDisplayModeCreateFlagsKHR
//         Type:
//             Name: VkDisplayModeCreateInfoKHR
//         Type:
//             Name: VkDisplayModeKHR
//         Type:
//             Name: VkDisplayModeParametersKHR
//         Type:
//             Name: VkDisplayModePropertiesKHR
//         Type:
//             Name: VkDisplayPlaneAlphaFlagBitsKHR
//         Type:
//             Name: VkDisplayPlaneAlphaFlagsKHR
//         Type:
//             Name: VkDisplayPlaneCapabilitiesKHR
//         Type:
//             Name: VkDisplayPlanePropertiesKHR
//         Type:
//             Name: VkDisplayPropertiesKHR
//         Type:
//             Name: VkDisplaySurfaceCreateFlagsKHR
//         Type:
//             Name: VkDisplaySurfaceCreateInfoKHR
//         Type:
//             Name: VkSurfaceTransformFlagsKHR
//         Command:
//             Name: vkGetPhysicalDeviceDisplayPropertiesKHR
//         Command:
//             Name: vkGetPhysicalDeviceDisplayPlanePropertiesKHR
//         Command:
//             Name: vkGetDisplayPlaneSupportedDisplaysKHR
//         Command:
//             Name: vkGetDisplayModePropertiesKHR
//         Command:
//             Name: vkCreateDisplayModeKHR
//         Command:
//             Name: vkGetDisplayPlaneCapabilitiesKHR
//         Command:
//             Name: vkCreateDisplayPlaneSurfaceKHR
pub const VK_KHR_display_swapchain_name = "VK_KHR_display_swapchain";
// Extension: VK_KHR_display_swapchain
// Number: 4
// Type: device
// Author: KHR
// Depends: VK_KHR_swapchain+VK_KHR_display
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_DISPLAY_SWAPCHAIN_SPEC_VERSION
//             Negative: false
//             Value: 10
//         Enum:
//             Name: VK_KHR_DISPLAY_SWAPCHAIN_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_display_swapchain&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_ERROR_INCOMPATIBLE_DISPLAY_KHR
//             Negative: true
//             Extends: VkResult
//             Offset: 1
//         Type:
//             Name: VkDisplayPresentInfoKHR
//         Command:
//             Name: vkCreateSharedSwapchainsKHR
pub const VK_KHR_xlib_surface_name = "VK_KHR_xlib_surface";
// Extension: VK_KHR_xlib_surface
// Number: 5
// Type: instance
// Author: KHR
// Depends: VK_KHR_surface
// Platform: xlib
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_XLIB_SURFACE_SPEC_VERSION
//             Negative: false
//             Value: 6
//         Enum:
//             Name: VK_KHR_XLIB_SURFACE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_xlib_surface&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkXlibSurfaceCreateFlagsKHR
//         Type:
//             Name: VkXlibSurfaceCreateInfoKHR
//         Command:
//             Name: vkCreateXlibSurfaceKHR
//         Command:
//             Name: vkGetPhysicalDeviceXlibPresentationSupportKHR
pub const VK_KHR_xcb_surface_name = "VK_KHR_xcb_surface";
// Extension: VK_KHR_xcb_surface
// Number: 6
// Type: instance
// Author: KHR
// Depends: VK_KHR_surface
// Platform: xcb
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_XCB_SURFACE_SPEC_VERSION
//             Negative: false
//             Value: 6
//         Enum:
//             Name: VK_KHR_XCB_SURFACE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_xcb_surface&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkXcbSurfaceCreateFlagsKHR
//         Type:
//             Name: VkXcbSurfaceCreateInfoKHR
//         Command:
//             Name: vkCreateXcbSurfaceKHR
//         Command:
//             Name: vkGetPhysicalDeviceXcbPresentationSupportKHR
pub const VK_KHR_wayland_surface_name = "VK_KHR_wayland_surface";
// Extension: VK_KHR_wayland_surface
// Number: 7
// Type: instance
// Author: KHR
// Depends: VK_KHR_surface
// Platform: wayland
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_WAYLAND_SURFACE_SPEC_VERSION
//             Negative: false
//             Value: 6
//         Enum:
//             Name: VK_KHR_WAYLAND_SURFACE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_wayland_surface&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkWaylandSurfaceCreateFlagsKHR
//         Type:
//             Name: VkWaylandSurfaceCreateInfoKHR
//         Command:
//             Name: vkCreateWaylandSurfaceKHR
//         Command:
//             Name: vkGetPhysicalDeviceWaylandPresentationSupportKHR
pub const VK_KHR_mir_surface_name = "VK_KHR_mir_surface";
// Extension: VK_KHR_mir_surface
// Number: 8
// Type: instance
// Author: KHR
// Depends: VK_KHR_surface
// Supported: disabled
// Comment:
//     Extension permanently disabled. Extension number should not be reused
// Unlocks:
//         Enum:
//             Name: VK_KHR_MIR_SURFACE_SPEC_VERSION
//             Negative: false
//             Value: 4
//         Enum:
//             Name: VK_KHR_MIR_SURFACE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_mir_surface&quot;
pub const VK_KHR_android_surface_name = "VK_KHR_android_surface";
// Extension: VK_KHR_android_surface
// Number: 9
// Type: instance
// Author: KHR
// Depends: VK_KHR_surface
// Platform: android
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_ANDROID_SURFACE_SPEC_VERSION
//             Negative: false
//             Value: 6
//         Enum:
//             Name: VK_KHR_ANDROID_SURFACE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_android_surface&quot;
//         Type:
//             Name: ANativeWindow
//         Enum:
//             Name: VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkAndroidSurfaceCreateFlagsKHR
//         Type:
//             Name: VkAndroidSurfaceCreateInfoKHR
//         Command:
//             Name: vkCreateAndroidSurfaceKHR
pub const VK_KHR_win32_surface_name = "VK_KHR_win32_surface";
// Extension: VK_KHR_win32_surface
// Number: 10
// Type: instance
// Author: KHR
// Depends: VK_KHR_surface
// Platform: win32
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_WIN32_SURFACE_SPEC_VERSION
//             Negative: false
//             Value: 6
//         Enum:
//             Name: VK_KHR_WIN32_SURFACE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_win32_surface&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkWin32SurfaceCreateFlagsKHR
//         Type:
//             Name: VkWin32SurfaceCreateInfoKHR
//         Command:
//             Name: vkCreateWin32SurfaceKHR
//         Command:
//             Name: vkGetPhysicalDeviceWin32PresentationSupportKHR
pub const VK_ANDROID_native_buffer_name = "VK_ANDROID_native_buffer";
// Extension: VK_ANDROID_native_buffer
// Number: 11
// Type: device
// Author: ANDROID
// Platform: android
// Supported: disabled
// Unlocks:
//         Comment:
//             VK_ANDROID_native_buffer is used between the Android Vulkan loader and drivers to implement the WSI extensions. It is not exposed to applications and uses types that are not part of Android's stable public API, so it is left disabled to keep it out of the standard Vulkan headers.
//         Enum:
//             Name: VK_ANDROID_NATIVE_BUFFER_SPEC_VERSION
//             Negative: false
//             Value: 8
//         Enum:
//             Name: VK_ANDROID_NATIVE_BUFFER_NUMBER
//             Negative: false
//             Value: 11
//         Enum:
//             Name: VK_ANDROID_NATIVE_BUFFER_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_ANDROID_native_buffer&quot;
//         Enum:
//             Name: VK_ANDROID_NATIVE_BUFFER_NAME
//             Negative: false
//             Alias: VK_ANDROID_NATIVE_BUFFER_EXTENSION_NAME
//         Enum:
//             Name: VK_STRUCTURE_TYPE_NATIVE_BUFFER_ANDROID
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SWAPCHAIN_IMAGE_CREATE_INFO_ANDROID
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENTATION_PROPERTIES_ANDROID
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Type:
//             Name: VkNativeBufferANDROID
//         Type:
//             Name: VkSwapchainImageCreateInfoANDROID
//         Type:
//             Name: VkPhysicalDevicePresentationPropertiesANDROID
//         Type:
//             Name: VkNativeBufferUsage2ANDROID
//         Type:
//             Name: VkSwapchainImageUsageFlagBitsANDROID
//         Type:
//             Name: VkSwapchainImageUsageFlagsANDROID
//         Command:
//             Name: vkGetSwapchainGrallocUsageANDROID
//         Command:
//             Name: vkAcquireImageANDROID
//         Command:
//             Name: vkQueueSignalReleaseImageANDROID
//         Command:
//             Name: vkGetSwapchainGrallocUsage2ANDROID
pub const VK_EXT_debug_report_name = "VK_EXT_debug_report";
// Extension: VK_EXT_debug_report
// Number: 12
// Type: instance
// Author: GOOGLE
// Supported: supported
// Deprecated by: VK_EXT_debug_utils
// Unlocks:
//         Enum:
//             Name: VK_EXT_DEBUG_REPORT_SPEC_VERSION
//             Negative: false
//             Value: 10
//         Enum:
//             Name: VK_EXT_DEBUG_REPORT_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_debug_report&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DEBUG_REPORT_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT
//         Enum:
//             Name: VK_ERROR_VALIDATION_FAILED_EXT
//             Negative: false
//             Extends: VkResult
//             Alias: VK_ERROR_VALIDATION_FAILED
//         Enum:
//             Name: VK_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT
//             Negative: false
//             Extends: VkObjectType
//             Offset: 0
//         Type:
//             Name: VkDebugReportCallbackEXT
//         Type:
//             Name: PFN_vkDebugReportCallbackEXT
//         Type:
//             Name: VkDebugReportFlagBitsEXT
//         Type:
//             Name: VkDebugReportFlagsEXT
//         Type:
//             Name: VkDebugReportObjectTypeEXT
//         Type:
//             Name: VkDebugReportCallbackCreateInfoEXT
//         Command:
//             Name: vkCreateDebugReportCallbackEXT
//         Command:
//             Name: vkDestroyDebugReportCallbackEXT
//         Command:
//             Name: vkDebugReportMessageEXT
//     Depends: VK_VERSION_1_1
//         Comment:
//             This duplicates definitions in other extensions, below
//         Enum:
//             Name: VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT
//             Negative: false
//             Extends: VkDebugReportObjectTypeEXT
//             Extnumber: 157
//             Offset: 0
//         Enum:
//             Name: VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_EXT
//             Negative: false
//             Extends: VkDebugReportObjectTypeEXT
//             Extnumber: 86
//             Offset: 0
pub const VK_NV_glsl_shader_name = "VK_NV_glsl_shader";
// Extension: VK_NV_glsl_shader
// Number: 13
// Type: device
// Author: NV
// Supported: supported
// Deprecated by: 
// Unlocks:
//         Enum:
//             Name: VK_NV_GLSL_SHADER_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_NV_GLSL_SHADER_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_glsl_shader&quot;
//         Enum:
//             Name: VK_ERROR_INVALID_SHADER_NV
//             Negative: true
//             Extends: VkResult
//             Offset: 0
pub const VK_EXT_depth_range_unrestricted_name = "VK_EXT_depth_range_unrestricted";
// Extension: VK_EXT_depth_range_unrestricted
// Number: 14
// Type: device
// Author: NV
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_DEPTH_RANGE_UNRESTRICTED_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_DEPTH_RANGE_UNRESTRICTED_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_depth_range_unrestricted&quot;
pub const VK_KHR_sampler_mirror_clamp_to_edge_name = "VK_KHR_sampler_mirror_clamp_to_edge";
// Extension: VK_KHR_sampler_mirror_clamp_to_edge
// Number: 15
// Type: device
// Author: KHR
// Supported: supported
// Promoted to: VK_VERSION_1_2
// Unlocks:
//         Enum:
//             Name: VK_KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE_SPEC_VERSION
//             Negative: false
//             Value: 3
//         Enum:
//             Name: VK_KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_sampler_mirror_clamp_to_edge&quot;
//         Enum:
//             Name: VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE
//             Negative: false
//             Value: 4
//             Extends: VkSamplerAddressMode
//             Comment:
//                 Note that this defines what was previously a core enum, and so uses the 'value' attribute rather than 'offset', and does not have a suffix. This is a special case, and should not be repeated
//         Enum:
//             Name: VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE_KHR
//             Negative: false
//             Extends: VkSamplerAddressMode
//             Alias: VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE
//             Comment:
//                 Introduced for consistency with extension suffixing rules
pub const VK_IMG_filter_cubic_name = "VK_IMG_filter_cubic";
// Extension: VK_IMG_filter_cubic
// Number: 16
// Type: device
// Author: IMG
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_IMG_FILTER_CUBIC_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_IMG_FILTER_CUBIC_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_IMG_filter_cubic&quot;
//         Enum:
//             Name: VK_FILTER_CUBIC_IMG
//             Negative: false
//             Extends: VkFilter
//             Alias: VK_FILTER_CUBIC_EXT
//         Enum:
//             Name: VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG
//             Negative: false
//             Extends: VkFormatFeatureFlagBits
//             Alias: VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT
//             Comment:
//                 Format can be filtered with VK_FILTER_CUBIC_IMG when being sampled
pub const VK_AMD_extension_17_name = "VK_AMD_extension_17";
// Extension: VK_AMD_extension_17
// Number: 17
// Type: invalid
// Author: AMD
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_AMD_EXTENSION_17_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_AMD_EXTENSION_17_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_extension_17&quot;
pub const VK_AMD_extension_18_name = "VK_AMD_extension_18";
// Extension: VK_AMD_extension_18
// Number: 18
// Type: invalid
// Author: AMD
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_AMD_EXTENSION_18_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_AMD_EXTENSION_18_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_extension_18&quot;
pub const VK_AMD_rasterization_order_name = "VK_AMD_rasterization_order";
// Extension: VK_AMD_rasterization_order
// Number: 19
// Type: device
// Author: AMD
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_AMD_RASTERIZATION_ORDER_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_AMD_RASTERIZATION_ORDER_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_rasterization_order&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkRasterizationOrderAMD
//         Type:
//             Name: VkPipelineRasterizationStateRasterizationOrderAMD
pub const VK_AMD_extension_20_name = "VK_AMD_extension_20";
// Extension: VK_AMD_extension_20
// Number: 20
// Type: invalid
// Author: AMD
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_AMD_EXTENSION_20_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_AMD_EXTENSION_20_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_extension_20&quot;
pub const VK_AMD_shader_trinary_minmax_name = "VK_AMD_shader_trinary_minmax";
// Extension: VK_AMD_shader_trinary_minmax
// Number: 21
// Type: device
// Author: AMD
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_AMD_SHADER_TRINARY_MINMAX_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_AMD_SHADER_TRINARY_MINMAX_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_shader_trinary_minmax&quot;
pub const VK_AMD_shader_explicit_vertex_parameter_name = "VK_AMD_shader_explicit_vertex_parameter";
// Extension: VK_AMD_shader_explicit_vertex_parameter
// Number: 22
// Type: device
// Author: AMD
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_AMD_SHADER_EXPLICIT_VERTEX_PARAMETER_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_AMD_SHADER_EXPLICIT_VERTEX_PARAMETER_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_shader_explicit_vertex_parameter&quot;
pub const VK_EXT_debug_marker_name = "VK_EXT_debug_marker";
// Extension: VK_EXT_debug_marker
// Number: 23
// Type: device
// Author: Baldur Karlsson
// Depends: VK_EXT_debug_report
// Supported: supported
// Promoted to: VK_EXT_debug_utils
// Unlocks:
//         Enum:
//             Name: VK_EXT_DEBUG_MARKER_SPEC_VERSION
//             Negative: false
//             Value: 4
//         Enum:
//             Name: VK_EXT_DEBUG_MARKER_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_debug_marker&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Type:
//             Name: VkDebugReportObjectTypeEXT
//         Type:
//             Name: VkDebugMarkerObjectNameInfoEXT
//         Type:
//             Name: VkDebugMarkerObjectTagInfoEXT
//         Type:
//             Name: VkDebugMarkerMarkerInfoEXT
//         Command:
//             Name: vkDebugMarkerSetObjectTagEXT
//         Command:
//             Name: vkDebugMarkerSetObjectNameEXT
//         Command:
//             Name: vkCmdDebugMarkerBeginEXT
//         Command:
//             Name: vkCmdDebugMarkerEndEXT
//         Command:
//             Name: vkCmdDebugMarkerInsertEXT
pub const VK_KHR_video_queue_name = "VK_KHR_video_queue";
// Extension: VK_KHR_video_queue
// Number: 24
// Type: device
// Author: KHR
// Depends: (VK_VERSION_1_1+VK_KHR_synchronization2),VK_VERSION_1_3
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_VIDEO_QUEUE_SPEC_VERSION
//             Negative: false
//             Value: 8
//         Enum:
//             Name: VK_KHR_VIDEO_QUEUE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_video_queue&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_PROFILE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_CAPABILITIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_PICTURE_RESOURCE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_SESSION_MEMORY_REQUIREMENTS_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Enum:
//             Name: VK_STRUCTURE_TYPE_BIND_VIDEO_SESSION_MEMORY_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 4
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_SESSION_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 5
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 6
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_UPDATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 7
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_BEGIN_CODING_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 8
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_END_CODING_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 9
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_CODING_CONTROL_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 10
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_REFERENCE_SLOT_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 11
//         Enum:
//             Name: VK_STRUCTURE_TYPE_QUEUE_FAMILY_VIDEO_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 12
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 13
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_FORMAT_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 14
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_FORMAT_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 15
//         Enum:
//             Name: VK_STRUCTURE_TYPE_QUEUE_FAMILY_QUERY_RESULT_STATUS_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 16
//         Enum:
//             Name: VK_OBJECT_TYPE_VIDEO_SESSION_KHR
//             Negative: false
//             Extends: VkObjectType
//             Offset: 0
//             Comment:
//                 VkVideoSessionKHR
//         Enum:
//             Name: VK_OBJECT_TYPE_VIDEO_SESSION_PARAMETERS_KHR
//             Negative: false
//             Extends: VkObjectType
//             Offset: 1
//             Comment:
//                 VkVideoSessionParametersKHR
//         Enum:
//             Name: VK_QUERY_TYPE_RESULT_STATUS_ONLY_KHR
//             Negative: false
//             Extends: VkQueryType
//             Offset: 0
//         Enum:
//             Name: VK_QUERY_RESULT_WITH_STATUS_BIT_KHR
//             Negative: false
//             Bitpos: 4
//             Extends: VkQueryResultFlagBits
//         Enum:
//             Name: VK_ERROR_IMAGE_USAGE_NOT_SUPPORTED_KHR
//             Negative: true
//             Extends: VkResult
//             Offset: 0
//         Enum:
//             Name: VK_ERROR_VIDEO_PICTURE_LAYOUT_NOT_SUPPORTED_KHR
//             Negative: true
//             Extends: VkResult
//             Offset: 1
//         Enum:
//             Name: VK_ERROR_VIDEO_PROFILE_OPERATION_NOT_SUPPORTED_KHR
//             Negative: true
//             Extends: VkResult
//             Offset: 2
//         Enum:
//             Name: VK_ERROR_VIDEO_PROFILE_FORMAT_NOT_SUPPORTED_KHR
//             Negative: true
//             Extends: VkResult
//             Offset: 3
//         Enum:
//             Name: VK_ERROR_VIDEO_PROFILE_CODEC_NOT_SUPPORTED_KHR
//             Negative: true
//             Extends: VkResult
//             Offset: 4
//         Enum:
//             Name: VK_ERROR_VIDEO_STD_VERSION_NOT_SUPPORTED_KHR
//             Negative: true
//             Extends: VkResult
//             Offset: 5
//         Type:
//             Name: VkVideoSessionKHR
//         Type:
//             Name: VkVideoSessionParametersKHR
//         Type:
//             Name: VkVideoCodecOperationFlagBitsKHR
//         Type:
//             Name: VkVideoCodecOperationFlagsKHR
//         Type:
//             Name: VkVideoChromaSubsamplingFlagBitsKHR
//         Type:
//             Name: VkVideoChromaSubsamplingFlagsKHR
//         Type:
//             Name: VkVideoComponentBitDepthFlagBitsKHR
//         Type:
//             Name: VkVideoComponentBitDepthFlagsKHR
//         Type:
//             Name: VkVideoCapabilityFlagBitsKHR
//         Type:
//             Name: VkVideoCapabilityFlagsKHR
//         Type:
//             Name: VkVideoSessionCreateFlagBitsKHR
//         Type:
//             Name: VkVideoSessionCreateFlagsKHR
//         Type:
//             Name: VkVideoSessionParametersCreateFlagsKHR
//         Type:
//             Name: VkVideoBeginCodingFlagsKHR
//         Type:
//             Name: VkVideoEndCodingFlagsKHR
//         Type:
//             Name: VkVideoCodingControlFlagBitsKHR
//         Type:
//             Name: VkVideoCodingControlFlagsKHR
//         Type:
//             Name: VkQueueFamilyQueryResultStatusPropertiesKHR
//         Type:
//             Name: VkQueryResultStatusKHR
//         Type:
//             Name: VkQueueFamilyVideoPropertiesKHR
//         Type:
//             Name: VkVideoProfileInfoKHR
//         Type:
//             Name: VkVideoProfileListInfoKHR
//         Type:
//             Name: VkVideoCapabilitiesKHR
//         Type:
//             Name: VkPhysicalDeviceVideoFormatInfoKHR
//         Type:
//             Name: VkVideoFormatPropertiesKHR
//         Type:
//             Name: VkVideoPictureResourceInfoKHR
//         Type:
//             Name: VkVideoReferenceSlotInfoKHR
//         Type:
//             Name: VkVideoSessionMemoryRequirementsKHR
//         Type:
//             Name: VkBindVideoSessionMemoryInfoKHR
//         Type:
//             Name: VkVideoSessionCreateInfoKHR
//         Type:
//             Name: VkVideoSessionParametersCreateInfoKHR
//         Type:
//             Name: VkVideoSessionParametersUpdateInfoKHR
//         Type:
//             Name: VkVideoBeginCodingInfoKHR
//         Type:
//             Name: VkVideoEndCodingInfoKHR
//         Type:
//             Name: VkVideoCodingControlInfoKHR
//         Command:
//             Name: vkGetPhysicalDeviceVideoCapabilitiesKHR
//         Command:
//             Name: vkGetPhysicalDeviceVideoFormatPropertiesKHR
//         Command:
//             Name: vkCreateVideoSessionKHR
//         Command:
//             Name: vkDestroyVideoSessionKHR
//         Command:
//             Name: vkGetVideoSessionMemoryRequirementsKHR
//         Command:
//             Name: vkBindVideoSessionMemoryKHR
//         Command:
//             Name: vkCreateVideoSessionParametersKHR
//         Command:
//             Name: vkUpdateVideoSessionParametersKHR
//         Command:
//             Name: vkDestroyVideoSessionParametersKHR
//         Command:
//             Name: vkCmdBeginVideoCodingKHR
//         Command:
//             Name: vkCmdEndVideoCodingKHR
//         Command:
//             Name: vkCmdControlVideoCodingKHR
pub const VK_KHR_video_decode_queue_name = "VK_KHR_video_decode_queue";
// Extension: VK_KHR_video_decode_queue
// Number: 25
// Type: device
// Author: KHR
// Depends: VK_KHR_video_queue+(VK_KHR_synchronization2,VK_VERSION_1_3)
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_VIDEO_DECODE_QUEUE_SPEC_VERSION
//             Negative: false
//             Value: 8
//         Enum:
//             Name: VK_KHR_VIDEO_DECODE_QUEUE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_video_decode_queue&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_DECODE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_DECODE_CAPABILITIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_DECODE_USAGE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_QUEUE_VIDEO_DECODE_BIT_KHR
//             Negative: false
//             Bitpos: 5
//             Extends: VkQueueFlagBits
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_VIDEO_DECODE_BIT_KHR
//             Negative: false
//             Bitpos: 26
//             Extends: VkPipelineStageFlagBits2
//         Enum:
//             Name: VK_ACCESS_2_VIDEO_DECODE_READ_BIT_KHR
//             Negative: false
//             Bitpos: 35
//             Extends: VkAccessFlagBits2
//         Enum:
//             Name: VK_ACCESS_2_VIDEO_DECODE_WRITE_BIT_KHR
//             Negative: false
//             Bitpos: 36
//             Extends: VkAccessFlagBits2
//         Enum:
//             Name: VK_BUFFER_USAGE_VIDEO_DECODE_SRC_BIT_KHR
//             Negative: false
//             Bitpos: 13
//             Extends: VkBufferUsageFlagBits
//         Enum:
//             Name: VK_BUFFER_USAGE_VIDEO_DECODE_DST_BIT_KHR
//             Negative: false
//             Bitpos: 14
//             Extends: VkBufferUsageFlagBits
//         Enum:
//             Name: VK_IMAGE_USAGE_VIDEO_DECODE_DST_BIT_KHR
//             Negative: false
//             Bitpos: 10
//             Extends: VkImageUsageFlagBits
//         Enum:
//             Name: VK_IMAGE_USAGE_VIDEO_DECODE_SRC_BIT_KHR
//             Negative: false
//             Bitpos: 11
//             Extends: VkImageUsageFlagBits
//         Enum:
//             Name: VK_IMAGE_USAGE_VIDEO_DECODE_DPB_BIT_KHR
//             Negative: false
//             Bitpos: 12
//             Extends: VkImageUsageFlagBits
//         Enum:
//             Name: VK_FORMAT_FEATURE_VIDEO_DECODE_OUTPUT_BIT_KHR
//             Negative: false
//             Bitpos: 25
//             Extends: VkFormatFeatureFlagBits
//         Enum:
//             Name: VK_FORMAT_FEATURE_VIDEO_DECODE_DPB_BIT_KHR
//             Negative: false
//             Bitpos: 26
//             Extends: VkFormatFeatureFlagBits
//         Enum:
//             Name: VK_IMAGE_LAYOUT_VIDEO_DECODE_DST_KHR
//             Negative: false
//             Extends: VkImageLayout
//             Offset: 0
//         Enum:
//             Name: VK_IMAGE_LAYOUT_VIDEO_DECODE_SRC_KHR
//             Negative: false
//             Extends: VkImageLayout
//             Offset: 1
//         Enum:
//             Name: VK_IMAGE_LAYOUT_VIDEO_DECODE_DPB_KHR
//             Negative: false
//             Extends: VkImageLayout
//             Offset: 2
//         Type:
//             Name: VkVideoDecodeCapabilityFlagBitsKHR
//         Type:
//             Name: VkVideoDecodeCapabilityFlagsKHR
//         Type:
//             Name: VkVideoDecodeCapabilitiesKHR
//         Type:
//             Name: VkVideoDecodeUsageFlagBitsKHR
//         Type:
//             Name: VkVideoDecodeUsageFlagsKHR
//         Type:
//             Name: VkVideoDecodeUsageInfoKHR
//         Type:
//             Name: VkVideoDecodeFlagsKHR
//         Type:
//             Name: VkVideoDecodeInfoKHR
//         Command:
//             Name: vkCmdDecodeVideoKHR
//     Depends: VK_KHR_format_feature_flags2,VK_VERSION_1_3
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_VIDEO_DECODE_OUTPUT_BIT_KHR
//             Negative: false
//             Bitpos: 25
//             Extends: VkFormatFeatureFlagBits2
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_VIDEO_DECODE_DPB_BIT_KHR
//             Negative: false
//             Bitpos: 26
//             Extends: VkFormatFeatureFlagBits2
pub const VK_AMD_gcn_shader_name = "VK_AMD_gcn_shader";
// Extension: VK_AMD_gcn_shader
// Number: 26
// Type: device
// Author: AMD
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_AMD_GCN_SHADER_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_AMD_GCN_SHADER_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_gcn_shader&quot;
pub const VK_NV_dedicated_allocation_name = "VK_NV_dedicated_allocation";
// Extension: VK_NV_dedicated_allocation
// Number: 27
// Type: device
// Author: NV
// Supported: supported
// Deprecated by: VK_KHR_dedicated_allocation
// Unlocks:
//         Enum:
//             Name: VK_NV_DEDICATED_ALLOCATION_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_NV_DEDICATED_ALLOCATION_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_dedicated_allocation&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Type:
//             Name: VkDedicatedAllocationImageCreateInfoNV
//         Type:
//             Name: VkDedicatedAllocationBufferCreateInfoNV
//         Type:
//             Name: VkDedicatedAllocationMemoryAllocateInfoNV
pub const VK_EXT_extension_28_name = "VK_EXT_extension_28";
// Extension: VK_EXT_extension_28
// Number: 28
// Type: invalid
// Author: NV
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_28_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_28_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_28&quot;
pub const VK_EXT_transform_feedback_name = "VK_EXT_transform_feedback";
// Extension: VK_EXT_transform_feedback
// Number: 29
// Type: device
// Author: NV
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_TRANSFORM_FEEDBACK_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_TRANSFORM_FEEDBACK_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_transform_feedback&quot;
//         Command:
//             Name: vkCmdBindTransformFeedbackBuffersEXT
//         Command:
//             Name: vkCmdBeginTransformFeedbackEXT
//         Command:
//             Name: vkCmdEndTransformFeedbackEXT
//         Command:
//             Name: vkCmdBeginQueryIndexedEXT
//         Command:
//             Name: vkCmdEndQueryIndexedEXT
//         Command:
//             Name: vkCmdDrawIndirectByteCountEXT
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT
//             Negative: false
//             Extends: VkQueryType
//             Offset: 4
//         Enum:
//             Name: VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT
//             Negative: false
//             Bitpos: 11
//             Extends: VkBufferUsageFlagBits
//         Enum:
//             Name: VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT
//             Negative: false
//             Bitpos: 12
//             Extends: VkBufferUsageFlagBits
//         Enum:
//             Name: VK_ACCESS_TRANSFORM_FEEDBACK_WRITE_BIT_EXT
//             Negative: false
//             Bitpos: 25
//             Extends: VkAccessFlagBits
//         Enum:
//             Name: VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT
//             Negative: false
//             Bitpos: 26
//             Extends: VkAccessFlagBits
//         Enum:
//             Name: VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT
//             Negative: false
//             Bitpos: 27
//             Extends: VkAccessFlagBits
//         Enum:
//             Name: VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT
//             Negative: false
//             Bitpos: 24
//             Extends: VkPipelineStageFlagBits
//         Type:
//             Name: VkPhysicalDeviceTransformFeedbackFeaturesEXT
//         Type:
//             Name: VkPhysicalDeviceTransformFeedbackPropertiesEXT
//         Type:
//             Name: VkPipelineRasterizationStateStreamCreateInfoEXT
//         Type:
//             Name: VkPipelineRasterizationStateStreamCreateFlagsEXT
//         Feature:
//             Name: transformFeedback
//             Struct: VkPhysicalDeviceTransformFeedbackFeaturesEXT
pub const VK_NVX_binary_import_name = "VK_NVX_binary_import";
// Extension: VK_NVX_binary_import
// Number: 30
// Type: device
// Author: NVX
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NVX_BINARY_IMPORT_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_NVX_BINARY_IMPORT_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NVX_binary_import&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_CU_MODULE_CREATE_INFO_NVX
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_CU_FUNCTION_CREATE_INFO_NVX
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_CU_LAUNCH_INFO_NVX
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_CU_MODULE_TEXTURING_MODE_CREATE_INFO_NVX
//             Negative: false
//             Extends: VkStructureType
//             Offset: 4
//         Enum:
//             Name: VK_OBJECT_TYPE_CU_MODULE_NVX
//             Negative: false
//             Extends: VkObjectType
//             Offset: 0
//         Enum:
//             Name: VK_OBJECT_TYPE_CU_FUNCTION_NVX
//             Negative: false
//             Extends: VkObjectType
//             Offset: 1
//         Type:
//             Name: VkCuModuleNVX
//         Type:
//             Name: VkCuFunctionNVX
//         Type:
//             Name: VkCuModuleCreateInfoNVX
//         Type:
//             Name: VkCuModuleTexturingModeCreateInfoNVX
//         Type:
//             Name: VkCuFunctionCreateInfoNVX
//         Type:
//             Name: VkCuLaunchInfoNVX
//         Command:
//             Name: vkCreateCuModuleNVX
//         Command:
//             Name: vkCreateCuFunctionNVX
//         Command:
//             Name: vkDestroyCuModuleNVX
//         Command:
//             Name: vkDestroyCuFunctionNVX
//         Command:
//             Name: vkCmdCuLaunchKernelNVX
//     Depends: VK_EXT_debug_report
//         Enum:
//             Name: VK_DEBUG_REPORT_OBJECT_TYPE_CU_MODULE_NVX_EXT
//             Negative: false
//             Extends: VkDebugReportObjectTypeEXT
//             Offset: 0
//         Enum:
//             Name: VK_DEBUG_REPORT_OBJECT_TYPE_CU_FUNCTION_NVX_EXT
//             Negative: false
//             Extends: VkDebugReportObjectTypeEXT
//             Offset: 1
pub const VK_NVX_image_view_handle_name = "VK_NVX_image_view_handle";
// Extension: VK_NVX_image_view_handle
// Number: 31
// Type: device
// Author: NVX
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NVX_IMAGE_VIEW_HANDLE_SPEC_VERSION
//             Negative: false
//             Value: 3
//         Enum:
//             Name: VK_NVX_IMAGE_VIEW_HANDLE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NVX_image_view_handle&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMAGE_VIEW_HANDLE_INFO_NVX
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMAGE_VIEW_ADDRESS_PROPERTIES_NVX
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Type:
//             Name: VkImageViewHandleInfoNVX
//         Type:
//             Name: VkImageViewAddressPropertiesNVX
//         Command:
//             Name: vkGetImageViewHandleNVX
//         Command:
//             Name: vkGetImageViewHandle64NVX
//         Command:
//             Name: vkGetImageViewAddressNVX
pub const VK_AMD_extension_32_name = "VK_AMD_extension_32";
// Extension: VK_AMD_extension_32
// Number: 32
// Type: invalid
// Author: AMD
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_AMD_EXTENSION_32_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_AMD_EXTENSION_32_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_extension_32&quot;
pub const VK_AMD_extension_33_name = "VK_AMD_extension_33";
// Extension: VK_AMD_extension_33
// Number: 33
// Type: invalid
// Author: AMD
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_AMD_EXTENSION_33_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_AMD_EXTENSION_33_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_extension_33&quot;
pub const VK_AMD_draw_indirect_count_name = "VK_AMD_draw_indirect_count";
// Extension: VK_AMD_draw_indirect_count
// Number: 34
// Type: device
// Author: AMD
// Supported: supported
// Promoted to: VK_KHR_draw_indirect_count
// Unlocks:
//         Enum:
//             Name: VK_AMD_DRAW_INDIRECT_COUNT_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_AMD_DRAW_INDIRECT_COUNT_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_draw_indirect_count&quot;
//         Command:
//             Name: vkCmdDrawIndirectCountAMD
//         Command:
//             Name: vkCmdDrawIndexedIndirectCountAMD
pub const VK_AMD_extension_35_name = "VK_AMD_extension_35";
// Extension: VK_AMD_extension_35
// Number: 35
// Type: invalid
// Author: AMD
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_AMD_EXTENSION_35_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_AMD_EXTENSION_35_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_extension_35&quot;
pub const VK_AMD_negative_viewport_height_name = "VK_AMD_negative_viewport_height";
// Extension: VK_AMD_negative_viewport_height
// Number: 36
// Type: device
// Author: AMD
// Supported: supported
// Obsoleted by: VK_KHR_maintenance1
// Unlocks:
//         Enum:
//             Name: VK_AMD_NEGATIVE_VIEWPORT_HEIGHT_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_AMD_NEGATIVE_VIEWPORT_HEIGHT_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_negative_viewport_height&quot;
pub const VK_AMD_gpu_shader_half_float_name = "VK_AMD_gpu_shader_half_float";
// Extension: VK_AMD_gpu_shader_half_float
// Number: 37
// Type: device
// Author: AMD
// Supported: supported
// Deprecated by: VK_KHR_shader_float16_int8
// Unlocks:
//         Enum:
//             Name: VK_AMD_GPU_SHADER_HALF_FLOAT_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_AMD_GPU_SHADER_HALF_FLOAT_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_gpu_shader_half_float&quot;
pub const VK_AMD_shader_ballot_name = "VK_AMD_shader_ballot";
// Extension: VK_AMD_shader_ballot
// Number: 38
// Type: device
// Author: AMD
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_AMD_SHADER_BALLOT_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_AMD_SHADER_BALLOT_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_shader_ballot&quot;
pub const VK_KHR_video_encode_h264_name = "VK_KHR_video_encode_h264";
// Extension: VK_KHR_video_encode_h264
// Number: 39
// Type: device
// Author: KHR
// Depends: VK_KHR_video_encode_queue
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_VIDEO_ENCODE_H264_SPEC_VERSION
//             Negative: false
//             Value: 14
//         Enum:
//             Name: VK_KHR_VIDEO_ENCODE_H264_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_video_encode_h264&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_CAPABILITIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PICTURE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_DPB_SLOT_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 4
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_NALU_SLICE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 5
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_GOP_REMAINING_FRAME_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 6
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PROFILE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 7
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 8
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_LAYER_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 9
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 10
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_QUALITY_LEVEL_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 11
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_GET_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 12
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_FEEDBACK_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 13
//         Enum:
//             Name: VK_VIDEO_CODEC_OPERATION_ENCODE_H264_BIT_KHR
//             Negative: false
//             Bitpos: 16
//             Extends: VkVideoCodecOperationFlagBitsKHR
//         Type:
//             Name: VkVideoEncodeH264CapabilityFlagBitsKHR
//         Type:
//             Name: VkVideoEncodeH264CapabilityFlagsKHR
//         Type:
//             Name: VkVideoEncodeH264StdFlagBitsKHR
//         Type:
//             Name: VkVideoEncodeH264StdFlagsKHR
//         Type:
//             Name: VkVideoEncodeH264CapabilitiesKHR
//         Type:
//             Name: VkVideoEncodeH264QualityLevelPropertiesKHR
//         Type:
//             Name: VkVideoEncodeH264SessionCreateInfoKHR
//         Type:
//             Name: VkVideoEncodeH264SessionParametersCreateInfoKHR
//         Type:
//             Name: VkVideoEncodeH264SessionParametersAddInfoKHR
//         Type:
//             Name: VkVideoEncodeH264SessionParametersGetInfoKHR
//         Type:
//             Name: VkVideoEncodeH264SessionParametersFeedbackInfoKHR
//         Type:
//             Name: VkVideoEncodeH264PictureInfoKHR
//         Type:
//             Name: VkVideoEncodeH264DpbSlotInfoKHR
//         Type:
//             Name: VkVideoEncodeH264NaluSliceInfoKHR
//         Type:
//             Name: VkVideoEncodeH264ProfileInfoKHR
//         Type:
//             Name: VkVideoEncodeH264RateControlInfoKHR
//         Type:
//             Name: VkVideoEncodeH264RateControlFlagBitsKHR
//         Type:
//             Name: VkVideoEncodeH264RateControlFlagsKHR
//         Type:
//             Name: VkVideoEncodeH264RateControlLayerInfoKHR
//         Type:
//             Name: VkVideoEncodeH264QpKHR
//         Type:
//             Name: VkVideoEncodeH264FrameSizeKHR
//         Type:
//             Name: VkVideoEncodeH264GopRemainingFrameInfoKHR
pub const VK_KHR_video_encode_h265_name = "VK_KHR_video_encode_h265";
// Extension: VK_KHR_video_encode_h265
// Number: 40
// Type: device
// Author: KHR
// Depends: VK_KHR_video_encode_queue
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_VIDEO_ENCODE_H265_SPEC_VERSION
//             Negative: false
//             Value: 14
//         Enum:
//             Name: VK_KHR_VIDEO_ENCODE_H265_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_video_encode_h265&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_CAPABILITIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PICTURE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_DPB_SLOT_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 4
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_NALU_SLICE_SEGMENT_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 5
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_GOP_REMAINING_FRAME_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 6
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PROFILE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 7
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 9
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_LAYER_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 10
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 11
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_QUALITY_LEVEL_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 12
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_GET_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 13
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_FEEDBACK_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 14
//         Enum:
//             Name: VK_VIDEO_CODEC_OPERATION_ENCODE_H265_BIT_KHR
//             Negative: false
//             Bitpos: 17
//             Extends: VkVideoCodecOperationFlagBitsKHR
//         Type:
//             Name: VkVideoEncodeH265CapabilityFlagBitsKHR
//         Type:
//             Name: VkVideoEncodeH265CapabilityFlagsKHR
//         Type:
//             Name: VkVideoEncodeH265StdFlagBitsKHR
//         Type:
//             Name: VkVideoEncodeH265StdFlagsKHR
//         Type:
//             Name: VkVideoEncodeH265CtbSizeFlagBitsKHR
//         Type:
//             Name: VkVideoEncodeH265CtbSizeFlagsKHR
//         Type:
//             Name: VkVideoEncodeH265TransformBlockSizeFlagBitsKHR
//         Type:
//             Name: VkVideoEncodeH265TransformBlockSizeFlagsKHR
//         Type:
//             Name: VkVideoEncodeH265CapabilitiesKHR
//         Type:
//             Name: VkVideoEncodeH265SessionCreateInfoKHR
//         Type:
//             Name: VkVideoEncodeH265QualityLevelPropertiesKHR
//         Type:
//             Name: VkVideoEncodeH265SessionParametersCreateInfoKHR
//         Type:
//             Name: VkVideoEncodeH265SessionParametersAddInfoKHR
//         Type:
//             Name: VkVideoEncodeH265SessionParametersGetInfoKHR
//         Type:
//             Name: VkVideoEncodeH265SessionParametersFeedbackInfoKHR
//         Type:
//             Name: VkVideoEncodeH265PictureInfoKHR
//         Type:
//             Name: VkVideoEncodeH265DpbSlotInfoKHR
//         Type:
//             Name: VkVideoEncodeH265NaluSliceSegmentInfoKHR
//         Type:
//             Name: VkVideoEncodeH265ProfileInfoKHR
//         Type:
//             Name: VkVideoEncodeH265RateControlInfoKHR
//         Type:
//             Name: VkVideoEncodeH265RateControlFlagBitsKHR
//         Type:
//             Name: VkVideoEncodeH265RateControlFlagsKHR
//         Type:
//             Name: VkVideoEncodeH265RateControlLayerInfoKHR
//         Type:
//             Name: VkVideoEncodeH265QpKHR
//         Type:
//             Name: VkVideoEncodeH265FrameSizeKHR
//         Type:
//             Name: VkVideoEncodeH265GopRemainingFrameInfoKHR
pub const VK_KHR_video_decode_h264_name = "VK_KHR_video_decode_h264";
// Extension: VK_KHR_video_decode_h264
// Number: 41
// Type: device
// Author: KHR
// Depends: VK_KHR_video_decode_queue
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_VIDEO_DECODE_H264_SPEC_VERSION
//             Negative: false
//             Value: 9
//         Enum:
//             Name: VK_KHR_VIDEO_DECODE_H264_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_video_decode_h264&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_CAPABILITIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PICTURE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PROFILE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 4
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 5
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_DPB_SLOT_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 6
//         Enum:
//             Name: VK_VIDEO_CODEC_OPERATION_DECODE_H264_BIT_KHR
//             Negative: false
//             Bitpos: 0
//             Extends: VkVideoCodecOperationFlagBitsKHR
//         Type:
//             Name: VkVideoDecodeH264PictureLayoutFlagBitsKHR
//         Type:
//             Name: VkVideoDecodeH264PictureLayoutFlagsKHR
//         Type:
//             Name: VkVideoDecodeH264ProfileInfoKHR
//         Type:
//             Name: VkVideoDecodeH264CapabilitiesKHR
//         Type:
//             Name: VkVideoDecodeH264SessionParametersCreateInfoKHR
//         Type:
//             Name: VkVideoDecodeH264SessionParametersAddInfoKHR
//         Type:
//             Name: VkVideoDecodeH264PictureInfoKHR
//         Type:
//             Name: VkVideoDecodeH264DpbSlotInfoKHR
pub const VK_AMD_texture_gather_bias_lod_name = "VK_AMD_texture_gather_bias_lod";
// Extension: VK_AMD_texture_gather_bias_lod
// Number: 42
// Type: device
// Author: AMD
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_AMD_TEXTURE_GATHER_BIAS_LOD_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_AMD_TEXTURE_GATHER_BIAS_LOD_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_texture_gather_bias_lod&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkTextureLODGatherFormatPropertiesAMD
pub const VK_AMD_shader_info_name = "VK_AMD_shader_info";
// Extension: VK_AMD_shader_info
// Number: 43
// Type: device
// Author: AMD
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_AMD_SHADER_INFO_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_AMD_SHADER_INFO_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_shader_info&quot;
//         Type:
//             Name: VkShaderInfoTypeAMD
//         Type:
//             Name: VkShaderResourceUsageAMD
//         Type:
//             Name: VkShaderStatisticsInfoAMD
//         Command:
//             Name: vkGetShaderInfoAMD
pub const VK_AMD_extension_44_name = "VK_AMD_extension_44";
// Extension: VK_AMD_extension_44
// Number: 44
// Type: invalid
// Author: AMD
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_AMD_EXTENSION_44_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_AMD_EXTENSION_44_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_extension_44&quot;
pub const VK_KHR_dynamic_rendering_name = "VK_KHR_dynamic_rendering";
// Extension: VK_KHR_dynamic_rendering
// Number: 45
// Type: device
// Author: KHR
// Depends: ((VK_KHR_get_physical_device_properties2,VK_VERSION_1_1)+VK_KHR_depth_stencil_resolve),VK_VERSION_1_2
// Supported: supported
// Promoted to: VK_VERSION_1_3
// Unlocks:
//         Enum:
//             Name: VK_KHR_DYNAMIC_RENDERING_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_DYNAMIC_RENDERING_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_dynamic_rendering&quot;
//         Command:
//             Name: vkCmdBeginRenderingKHR
//         Command:
//             Name: vkCmdEndRenderingKHR
//         Enum:
//             Name: VK_STRUCTURE_TYPE_RENDERING_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_RENDERING_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES
//         Enum:
//             Name: VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO
//         Enum:
//             Name: VK_ATTACHMENT_STORE_OP_NONE_KHR
//             Negative: false
//             Extends: VkAttachmentStoreOp
//             Alias: VK_ATTACHMENT_STORE_OP_NONE
//         Enum:
//             Name: VK_RENDERING_CONTENTS_SECONDARY_COMMAND_BUFFERS_BIT_KHR
//             Negative: false
//             Extends: VkRenderingFlagBits
//             Alias: VK_RENDERING_CONTENTS_SECONDARY_COMMAND_BUFFERS_BIT
//         Enum:
//             Name: VK_RENDERING_SUSPENDING_BIT_KHR
//             Negative: false
//             Extends: VkRenderingFlagBits
//             Alias: VK_RENDERING_SUSPENDING_BIT
//         Enum:
//             Name: VK_RENDERING_RESUMING_BIT_KHR
//             Negative: false
//             Extends: VkRenderingFlagBits
//             Alias: VK_RENDERING_RESUMING_BIT
//         Type:
//             Name: VkRenderingInfoKHR
//         Type:
//             Name: VkRenderingAttachmentInfoKHR
//         Type:
//             Name: VkPipelineRenderingCreateInfoKHR
//         Type:
//             Name: VkPhysicalDeviceDynamicRenderingFeaturesKHR
//         Type:
//             Name: VkCommandBufferInheritanceRenderingInfoKHR
//         Type:
//             Name: VkRenderingFlagsKHR
//         Type:
//             Name: VkRenderingFlagBitsKHR
//         Feature:
//             Name: dynamicRendering
//             Struct: VkPhysicalDeviceDynamicRenderingFeaturesKHR
pub const VK_AMD_extension_46_name = "VK_AMD_extension_46";
// Extension: VK_AMD_extension_46
// Number: 46
// Type: invalid
// Author: AMD
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_AMD_EXTENSION_46_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_AMD_EXTENSION_46_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_extension_46&quot;
pub const VK_AMD_shader_image_load_store_lod_name = "VK_AMD_shader_image_load_store_lod";
// Extension: VK_AMD_shader_image_load_store_lod
// Number: 47
// Type: device
// Author: AMD
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_AMD_SHADER_IMAGE_LOAD_STORE_LOD_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_AMD_SHADER_IMAGE_LOAD_STORE_LOD_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_shader_image_load_store_lod&quot;
pub const VK_NVX_extension_48_name = "VK_NVX_extension_48";
// Extension: VK_NVX_extension_48
// Number: 48
// Type: invalid
// Author: NVX
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_NVX_EXTENSION_48_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_NVX_EXTENSION_48_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NVX_extension_48&quot;
pub const VK_GOOGLE_extension_49_name = "VK_GOOGLE_extension_49";
// Extension: VK_GOOGLE_extension_49
// Number: 49
// Type: invalid
// Author: GOOGLE
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_GOOGLE_EXTENSION_49_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_GOOGLE_EXTENSION_49_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_GOOGLE_extension_49&quot;
pub const VK_GGP_stream_descriptor_surface_name = "VK_GGP_stream_descriptor_surface";
// Extension: VK_GGP_stream_descriptor_surface
// Number: 50
// Type: instance
// Author: GGP
// Depends: VK_KHR_surface
// Platform: ggp
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_GGP_STREAM_DESCRIPTOR_SURFACE_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_GGP_STREAM_DESCRIPTOR_SURFACE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_GGP_stream_descriptor_surface&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_STREAM_DESCRIPTOR_SURFACE_CREATE_INFO_GGP
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkStreamDescriptorSurfaceCreateFlagsGGP
//         Type:
//             Name: VkStreamDescriptorSurfaceCreateInfoGGP
//         Command:
//             Name: vkCreateStreamDescriptorSurfaceGGP
pub const VK_NV_corner_sampled_image_name = "VK_NV_corner_sampled_image";
// Extension: VK_NV_corner_sampled_image
// Number: 51
// Type: device
// Author: NV
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NV_CORNER_SAMPLED_IMAGE_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_NV_CORNER_SAMPLED_IMAGE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_corner_sampled_image&quot;
//         Enum:
//             Name: VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV
//             Negative: false
//             Bitpos: 13
//             Extends: VkImageCreateFlagBits
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceCornerSampledImageFeaturesNV
//         Feature:
//             Name: cornerSampledImage
//             Struct: VkPhysicalDeviceCornerSampledImageFeaturesNV
pub const VK_NV_private_vendor_info_name = "VK_NV_private_vendor_info";
// Extension: VK_NV_private_vendor_info
// Number: 52
// Type: device
// Author: NV
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NV_PRIVATE_VENDOR_INFO_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_NV_PRIVATE_VENDOR_INFO_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_private_vendor_info&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PRIVATE_VENDOR_INFO_PLACEHOLDER_OFFSET_0_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
pub const VK_NV_extension_53_name = "VK_NV_extension_53";
// Extension: VK_NV_extension_53
// Number: 53
// Type: invalid
// Author: NV
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_NV_EXTENSION_53_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_NV_EXTENSION_53_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_extension_53&quot;
pub const VK_KHR_multiview_name = "VK_KHR_multiview";
// Extension: VK_KHR_multiview
// Number: 54
// Type: device
// Author: KHR
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_1
// Unlocks:
//         Enum:
//             Name: VK_KHR_MULTIVIEW_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_MULTIVIEW_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_multiview&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES
//         Enum:
//             Name: VK_DEPENDENCY_VIEW_LOCAL_BIT_KHR
//             Negative: false
//             Extends: VkDependencyFlagBits
//             Alias: VK_DEPENDENCY_VIEW_LOCAL_BIT
//         Type:
//             Name: VkRenderPassMultiviewCreateInfoKHR
//         Type:
//             Name: VkPhysicalDeviceMultiviewFeaturesKHR
//         Type:
//             Name: VkPhysicalDeviceMultiviewPropertiesKHR
//         Feature:
//             Name: multiview
//             Struct: VkPhysicalDeviceMultiviewFeaturesKHR
pub const VK_IMG_format_pvrtc_name = "VK_IMG_format_pvrtc";
// Extension: VK_IMG_format_pvrtc
// Number: 55
// Type: device
// Author: IMG
// Supported: supported
// Deprecated by: 
// Unlocks:
//         Enum:
//             Name: VK_IMG_FORMAT_PVRTC_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_IMG_FORMAT_PVRTC_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_IMG_format_pvrtc&quot;
//         Enum:
//             Name: VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG
//             Negative: false
//             Extends: VkFormat
//             Offset: 0
//         Enum:
//             Name: VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG
//             Negative: false
//             Extends: VkFormat
//             Offset: 1
//         Enum:
//             Name: VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG
//             Negative: false
//             Extends: VkFormat
//             Offset: 2
//         Enum:
//             Name: VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG
//             Negative: false
//             Extends: VkFormat
//             Offset: 3
//         Enum:
//             Name: VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG
//             Negative: false
//             Extends: VkFormat
//             Offset: 4
//         Enum:
//             Name: VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG
//             Negative: false
//             Extends: VkFormat
//             Offset: 5
//         Enum:
//             Name: VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG
//             Negative: false
//             Extends: VkFormat
//             Offset: 6
//         Enum:
//             Name: VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG
//             Negative: false
//             Extends: VkFormat
//             Offset: 7
pub const VK_NV_external_memory_capabilities_name = "VK_NV_external_memory_capabilities";
// Extension: VK_NV_external_memory_capabilities
// Number: 56
// Type: instance
// Author: NV
// Supported: supported
// Deprecated by: VK_KHR_external_memory_capabilities
// Unlocks:
//         Enum:
//             Name: VK_NV_EXTERNAL_MEMORY_CAPABILITIES_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_NV_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_external_memory_capabilities&quot;
//         Type:
//             Name: VkExternalMemoryHandleTypeFlagsNV
//         Type:
//             Name: VkExternalMemoryHandleTypeFlagBitsNV
//         Type:
//             Name: VkExternalMemoryFeatureFlagsNV
//         Type:
//             Name: VkExternalMemoryFeatureFlagBitsNV
//         Type:
//             Name: VkExternalImageFormatPropertiesNV
//         Command:
//             Name: vkGetPhysicalDeviceExternalImageFormatPropertiesNV
pub const VK_NV_external_memory_name = "VK_NV_external_memory";
// Extension: VK_NV_external_memory
// Number: 57
// Type: device
// Author: NV
// Depends: VK_NV_external_memory_capabilities
// Supported: supported
// Deprecated by: VK_KHR_external_memory
// Unlocks:
//         Enum:
//             Name: VK_NV_EXTERNAL_MEMORY_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_NV_EXTERNAL_MEMORY_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_external_memory&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Type:
//             Name: VkExternalMemoryImageCreateInfoNV
//         Type:
//             Name: VkExportMemoryAllocateInfoNV
pub const VK_NV_external_memory_win32_name = "VK_NV_external_memory_win32";
// Extension: VK_NV_external_memory_win32
// Number: 58
// Type: device
// Author: NV
// Depends: VK_NV_external_memory
// Platform: win32
// Supported: supported
// Deprecated by: VK_KHR_external_memory_win32
// Unlocks:
//         Enum:
//             Name: VK_NV_EXTERNAL_MEMORY_WIN32_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_NV_EXTERNAL_MEMORY_WIN32_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_external_memory_win32&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Type:
//             Name: VkImportMemoryWin32HandleInfoNV
//         Type:
//             Name: VkExportMemoryWin32HandleInfoNV
//         Command:
//             Name: vkGetMemoryWin32HandleNV
pub const VK_NV_win32_keyed_mutex_name = "VK_NV_win32_keyed_mutex";
// Extension: VK_NV_win32_keyed_mutex
// Number: 59
// Type: device
// Author: NV
// Depends: VK_NV_external_memory_win32
// Platform: win32
// Supported: supported
// Promoted to: VK_KHR_win32_keyed_mutex
// Unlocks:
//         Enum:
//             Name: VK_NV_WIN32_KEYED_MUTEX_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_NV_WIN32_KEYED_MUTEX_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_win32_keyed_mutex&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkWin32KeyedMutexAcquireReleaseInfoNV
pub const VK_KHR_get_physical_device_properties2_name = "VK_KHR_get_physical_device_properties2";
// Extension: VK_KHR_get_physical_device_properties2
// Number: 60
// Type: instance
// Author: KHR
// Supported: supported
// Promoted to: VK_VERSION_1_1
// Unlocks:
//         Enum:
//             Name: VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_get_physical_device_properties2&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2
//         Type:
//             Name: VkPhysicalDeviceFeatures2KHR
//         Type:
//             Name: VkPhysicalDeviceProperties2KHR
//         Type:
//             Name: VkFormatProperties2KHR
//         Type:
//             Name: VkImageFormatProperties2KHR
//         Type:
//             Name: VkPhysicalDeviceImageFormatInfo2KHR
//         Type:
//             Name: VkQueueFamilyProperties2KHR
//         Type:
//             Name: VkPhysicalDeviceMemoryProperties2KHR
//         Type:
//             Name: VkSparseImageFormatProperties2KHR
//         Type:
//             Name: VkPhysicalDeviceSparseImageFormatInfo2KHR
//         Command:
//             Name: vkGetPhysicalDeviceFeatures2KHR
//         Command:
//             Name: vkGetPhysicalDeviceProperties2KHR
//         Command:
//             Name: vkGetPhysicalDeviceFormatProperties2KHR
//         Command:
//             Name: vkGetPhysicalDeviceImageFormatProperties2KHR
//         Command:
//             Name: vkGetPhysicalDeviceQueueFamilyProperties2KHR
//         Command:
//             Name: vkGetPhysicalDeviceMemoryProperties2KHR
//         Command:
//             Name: vkGetPhysicalDeviceSparseImageFormatProperties2KHR
pub const VK_KHR_device_group_name = "VK_KHR_device_group";
// Extension: VK_KHR_device_group
// Number: 61
// Type: device
// Author: KHR
// Depends: VK_KHR_device_group_creation
// Supported: supported
// Promoted to: VK_VERSION_1_1
// Unlocks:
//         Enum:
//             Name: VK_KHR_DEVICE_GROUP_SPEC_VERSION
//             Negative: false
//             Value: 4
//         Enum:
//             Name: VK_KHR_DEVICE_GROUP_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_device_group&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO
//         Type:
//             Name: VkPeerMemoryFeatureFlagsKHR
//         Type:
//             Name: VkPeerMemoryFeatureFlagBitsKHR
//         Enum:
//             Name: VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT_KHR
//             Negative: false
//             Extends: VkPeerMemoryFeatureFlagBits
//             Alias: VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT
//         Enum:
//             Name: VK_PEER_MEMORY_FEATURE_COPY_DST_BIT_KHR
//             Negative: false
//             Extends: VkPeerMemoryFeatureFlagBits
//             Alias: VK_PEER_MEMORY_FEATURE_COPY_DST_BIT
//         Enum:
//             Name: VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT_KHR
//             Negative: false
//             Extends: VkPeerMemoryFeatureFlagBits
//             Alias: VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT
//         Enum:
//             Name: VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT_KHR
//             Negative: false
//             Extends: VkPeerMemoryFeatureFlagBits
//             Alias: VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT
//         Type:
//             Name: VkMemoryAllocateFlagsKHR
//         Type:
//             Name: VkMemoryAllocateFlagBitsKHR
//         Enum:
//             Name: VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT_KHR
//             Negative: false
//             Extends: VkMemoryAllocateFlagBits
//             Alias: VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT
//         Type:
//             Name: VkMemoryAllocateFlagsInfoKHR
//         Type:
//             Name: VkDeviceGroupRenderPassBeginInfoKHR
//         Type:
//             Name: VkDeviceGroupCommandBufferBeginInfoKHR
//         Type:
//             Name: VkDeviceGroupSubmitInfoKHR
//         Type:
//             Name: VkDeviceGroupBindSparseInfoKHR
//         Command:
//             Name: vkGetDeviceGroupPeerMemoryFeaturesKHR
//         Command:
//             Name: vkCmdSetDeviceMaskKHR
//         Command:
//             Name: vkCmdDispatchBaseKHR
//         Enum:
//             Name: VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHR
//             Negative: false
//             Extends: VkPipelineCreateFlagBits
//             Alias: VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT
//         Enum:
//             Name: VK_PIPELINE_CREATE_DISPATCH_BASE_BIT_KHR
//             Negative: false
//             Extends: VkPipelineCreateFlagBits
//             Alias: VK_PIPELINE_CREATE_DISPATCH_BASE_BIT
//         Enum:
//             Name: VK_PIPELINE_CREATE_DISPATCH_BASE_KHR
//             Negative: false
//             Extends: VkPipelineCreateFlagBits
//             Alias: VK_PIPELINE_CREATE_DISPATCH_BASE_BIT
//         Enum:
//             Name: VK_DEPENDENCY_DEVICE_GROUP_BIT_KHR
//             Negative: false
//             Extends: VkDependencyFlagBits
//             Alias: VK_DEPENDENCY_DEVICE_GROUP_BIT
//     Depends: VK_KHR_bind_memory2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO
//         Type:
//             Name: VkBindBufferMemoryDeviceGroupInfoKHR
//         Type:
//             Name: VkBindImageMemoryDeviceGroupInfoKHR
//         Enum:
//             Name: VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR
//             Negative: false
//             Extends: VkImageCreateFlagBits
//             Alias: VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT
//     Depends: VK_KHR_surface
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 7
//         Type:
//             Name: VkDeviceGroupPresentModeFlagBitsKHR
//         Type:
//             Name: VkDeviceGroupPresentModeFlagsKHR
//         Type:
//             Name: VkDeviceGroupPresentCapabilitiesKHR
//         Command:
//             Name: vkGetDeviceGroupPresentCapabilitiesKHR
//         Command:
//             Name: vkGetDeviceGroupSurfacePresentModesKHR
//         Command:
//             Name: vkGetPhysicalDevicePresentRectanglesKHR
//     Depends: VK_KHR_swapchain
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 8
//         Enum:
//             Name: VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 9
//         Enum:
//             Name: VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 10
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 11
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 12
//         Enum:
//             Name: VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR
//             Negative: false
//             Bitpos: 0
//             Extends: VkSwapchainCreateFlagBitsKHR
//             Comment:
//                 Allow images with VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT
//         Type:
//             Name: VkImageSwapchainCreateInfoKHR
//         Type:
//             Name: VkBindImageMemorySwapchainInfoKHR
//         Type:
//             Name: VkAcquireNextImageInfoKHR
//         Type:
//             Name: VkDeviceGroupPresentInfoKHR
//         Type:
//             Name: VkDeviceGroupSwapchainCreateInfoKHR
//         Command:
//             Name: vkAcquireNextImage2KHR
pub const VK_EXT_validation_flags_name = "VK_EXT_validation_flags";
// Extension: VK_EXT_validation_flags
// Number: 62
// Type: instance
// Author: GOOGLE
// Supported: supported
// Deprecated by: VK_EXT_layer_settings
// Unlocks:
//         Enum:
//             Name: VK_EXT_VALIDATION_FLAGS_SPEC_VERSION
//             Negative: false
//             Value: 3
//         Enum:
//             Name: VK_EXT_VALIDATION_FLAGS_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_validation_flags&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkValidationFlagsEXT
//         Type:
//             Name: VkValidationCheckEXT
pub const VK_NN_vi_surface_name = "VK_NN_vi_surface";
// Extension: VK_NN_vi_surface
// Number: 63
// Type: instance
// Author: NN
// Depends: VK_KHR_surface
// Platform: vi
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NN_VI_SURFACE_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_NN_VI_SURFACE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NN_vi_surface&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkViSurfaceCreateFlagsNN
//         Type:
//             Name: VkViSurfaceCreateInfoNN
//         Command:
//             Name: vkCreateViSurfaceNN
pub const VK_KHR_shader_draw_parameters_name = "VK_KHR_shader_draw_parameters";
// Extension: VK_KHR_shader_draw_parameters
// Number: 64
// Type: device
// Author: KHR
// Supported: supported
// Promoted to: VK_VERSION_1_1
// Unlocks:
//         Enum:
//             Name: VK_KHR_SHADER_DRAW_PARAMETERS_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_SHADER_DRAW_PARAMETERS_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_shader_draw_parameters&quot;
pub const VK_EXT_shader_subgroup_ballot_name = "VK_EXT_shader_subgroup_ballot";
// Extension: VK_EXT_shader_subgroup_ballot
// Number: 65
// Type: device
// Author: NV
// Supported: supported
// Deprecated by: VK_VERSION_1_2
// Unlocks:
//         Enum:
//             Name: VK_EXT_SHADER_SUBGROUP_BALLOT_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_SHADER_SUBGROUP_BALLOT_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_shader_subgroup_ballot&quot;
pub const VK_EXT_shader_subgroup_vote_name = "VK_EXT_shader_subgroup_vote";
// Extension: VK_EXT_shader_subgroup_vote
// Number: 66
// Type: device
// Author: NV
// Supported: supported
// Deprecated by: VK_VERSION_1_1
// Unlocks:
//         Enum:
//             Name: VK_EXT_SHADER_SUBGROUP_VOTE_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_SHADER_SUBGROUP_VOTE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_shader_subgroup_vote&quot;
pub const VK_EXT_texture_compression_astc_hdr_name = "VK_EXT_texture_compression_astc_hdr";
// Extension: VK_EXT_texture_compression_astc_hdr
// Number: 67
// Type: device
// Author: ARM
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_3
// Unlocks:
//         Enum:
//             Name: VK_EXT_TEXTURE_COMPRESSION_ASTC_HDR_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_TEXTURE_COMPRESSION_ASTC_HDR_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_texture_compression_astc_hdr&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES
//         Type:
//             Name: VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT
//         Enum:
//             Name: VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK_EXT
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK
//         Enum:
//             Name: VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK_EXT
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK
//         Enum:
//             Name: VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK_EXT
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK
//         Enum:
//             Name: VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK_EXT
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK
//         Enum:
//             Name: VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK_EXT
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK
//         Enum:
//             Name: VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK_EXT
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK
//         Enum:
//             Name: VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK_EXT
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK
//         Enum:
//             Name: VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK_EXT
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK
//         Enum:
//             Name: VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK_EXT
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK
//         Enum:
//             Name: VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK_EXT
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK
//         Enum:
//             Name: VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK_EXT
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK
//         Enum:
//             Name: VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK_EXT
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK
//         Enum:
//             Name: VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK_EXT
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK
//         Enum:
//             Name: VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK_EXT
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK
//         Feature:
//             Name: textureCompressionASTC_HDR
//             Struct: VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT
pub const VK_EXT_astc_decode_mode_name = "VK_EXT_astc_decode_mode";
// Extension: VK_EXT_astc_decode_mode
// Number: 68
// Type: device
// Author: ARM
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_ASTC_DECODE_MODE_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_ASTC_DECODE_MODE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_astc_decode_mode&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Type:
//             Name: VkImageViewASTCDecodeModeEXT
//         Type:
//             Name: VkPhysicalDeviceASTCDecodeFeaturesEXT
pub const VK_EXT_pipeline_robustness_name = "VK_EXT_pipeline_robustness";
// Extension: VK_EXT_pipeline_robustness
// Number: 69
// Type: device
// Author: IMG
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_4
// Unlocks:
//         Enum:
//             Name: VK_EXT_PIPELINE_ROBUSTNESS_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_PIPELINE_ROBUSTNESS_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_pipeline_robustness&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES
//         Enum:
//             Name: VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DEVICE_DEFAULT_EXT
//             Negative: false
//             Extends: VkPipelineRobustnessBufferBehavior
//             Alias: VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DEVICE_DEFAULT
//         Enum:
//             Name: VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DISABLED_EXT
//             Negative: false
//             Extends: VkPipelineRobustnessBufferBehavior
//             Alias: VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DISABLED
//         Enum:
//             Name: VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT
//             Negative: false
//             Extends: VkPipelineRobustnessBufferBehavior
//             Alias: VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS
//         Enum:
//             Name: VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT
//             Negative: false
//             Extends: VkPipelineRobustnessBufferBehavior
//             Alias: VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2
//         Enum:
//             Name: VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DEVICE_DEFAULT_EXT
//             Negative: false
//             Extends: VkPipelineRobustnessImageBehavior
//             Alias: VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DEVICE_DEFAULT
//         Enum:
//             Name: VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DISABLED_EXT
//             Negative: false
//             Extends: VkPipelineRobustnessImageBehavior
//             Alias: VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DISABLED
//         Enum:
//             Name: VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS_EXT
//             Negative: false
//             Extends: VkPipelineRobustnessImageBehavior
//             Alias: VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS
//         Enum:
//             Name: VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS_2_EXT
//             Negative: false
//             Extends: VkPipelineRobustnessImageBehavior
//             Alias: VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS_2
//         Type:
//             Name: VkPhysicalDevicePipelineRobustnessFeaturesEXT
//         Type:
//             Name: VkPhysicalDevicePipelineRobustnessPropertiesEXT
//         Type:
//             Name: VkPipelineRobustnessCreateInfoEXT
//         Type:
//             Name: VkPipelineRobustnessBufferBehaviorEXT
//         Type:
//             Name: VkPipelineRobustnessImageBehaviorEXT
//         Feature:
//             Name: pipelineRobustness
//             Struct: VkPhysicalDevicePipelineRobustnessFeaturesEXT
pub const VK_KHR_maintenance1_name = "VK_KHR_maintenance1";
// Extension: VK_KHR_maintenance1
// Number: 70
// Type: device
// Author: KHR
// Supported: supported
// Promoted to: VK_VERSION_1_1
// Unlocks:
//         Enum:
//             Name: VK_KHR_MAINTENANCE_1_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_KHR_MAINTENANCE_1_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_maintenance1&quot;
//         Enum:
//             Name: VK_KHR_MAINTENANCE1_SPEC_VERSION
//             Negative: false
//             Alias: VK_KHR_MAINTENANCE_1_SPEC_VERSION
//         Enum:
//             Name: VK_KHR_MAINTENANCE1_EXTENSION_NAME
//             Negative: false
//             Alias: VK_KHR_MAINTENANCE_1_EXTENSION_NAME
//         Enum:
//             Name: VK_ERROR_OUT_OF_POOL_MEMORY_KHR
//             Negative: false
//             Extends: VkResult
//             Alias: VK_ERROR_OUT_OF_POOL_MEMORY
//         Enum:
//             Name: VK_FORMAT_FEATURE_TRANSFER_SRC_BIT_KHR
//             Negative: false
//             Extends: VkFormatFeatureFlagBits
//             Alias: VK_FORMAT_FEATURE_TRANSFER_SRC_BIT
//         Enum:
//             Name: VK_FORMAT_FEATURE_TRANSFER_DST_BIT_KHR
//             Negative: false
//             Extends: VkFormatFeatureFlagBits
//             Alias: VK_FORMAT_FEATURE_TRANSFER_DST_BIT
//         Enum:
//             Name: VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT_KHR
//             Negative: false
//             Extends: VkImageCreateFlagBits
//             Alias: VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT
//         Type:
//             Name: VkCommandPoolTrimFlagsKHR
//         Command:
//             Name: vkTrimCommandPoolKHR
pub const VK_KHR_device_group_creation_name = "VK_KHR_device_group_creation";
// Extension: VK_KHR_device_group_creation
// Number: 71
// Type: instance
// Author: KHR
// Supported: supported
// Promoted to: VK_VERSION_1_1
// Unlocks:
//         Enum:
//             Name: VK_KHR_DEVICE_GROUP_CREATION_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_DEVICE_GROUP_CREATION_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_device_group_creation&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO
//         Enum:
//             Name: VK_MAX_DEVICE_GROUP_SIZE_KHR
//             Negative: false
//             Alias: VK_MAX_DEVICE_GROUP_SIZE
//         Type:
//             Name: VkPhysicalDeviceGroupPropertiesKHR
//         Type:
//             Name: VkDeviceGroupDeviceCreateInfoKHR
//         Command:
//             Name: vkEnumeratePhysicalDeviceGroupsKHR
//         Enum:
//             Name: VK_MEMORY_HEAP_MULTI_INSTANCE_BIT_KHR
//             Negative: false
//             Extends: VkMemoryHeapFlagBits
//             Alias: VK_MEMORY_HEAP_MULTI_INSTANCE_BIT
pub const VK_KHR_external_memory_capabilities_name = "VK_KHR_external_memory_capabilities";
// Extension: VK_KHR_external_memory_capabilities
// Number: 72
// Type: instance
// Author: KHR
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_1
// Unlocks:
//         Enum:
//             Name: VK_KHR_EXTERNAL_MEMORY_CAPABILITIES_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_external_memory_capabilities&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES
//         Enum:
//             Name: VK_LUID_SIZE_KHR
//             Negative: false
//             Alias: VK_LUID_SIZE
//         Type:
//             Name: VkExternalMemoryHandleTypeFlagsKHR
//         Type:
//             Name: VkExternalMemoryHandleTypeFlagBitsKHR
//         Enum:
//             Name: VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT_KHR
//             Negative: false
//             Extends: VkExternalMemoryHandleTypeFlagBits
//             Alias: VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT
//         Enum:
//             Name: VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR
//             Negative: false
//             Extends: VkExternalMemoryHandleTypeFlagBits
//             Alias: VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT
//         Enum:
//             Name: VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR
//             Negative: false
//             Extends: VkExternalMemoryHandleTypeFlagBits
//             Alias: VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT
//         Enum:
//             Name: VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT_KHR
//             Negative: false
//             Extends: VkExternalMemoryHandleTypeFlagBits
//             Alias: VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT
//         Enum:
//             Name: VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT_KHR
//             Negative: false
//             Extends: VkExternalMemoryHandleTypeFlagBits
//             Alias: VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT
//         Enum:
//             Name: VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT_KHR
//             Negative: false
//             Extends: VkExternalMemoryHandleTypeFlagBits
//             Alias: VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT
//         Enum:
//             Name: VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT_KHR
//             Negative: false
//             Extends: VkExternalMemoryHandleTypeFlagBits
//             Alias: VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT
//         Type:
//             Name: VkExternalMemoryFeatureFlagsKHR
//         Type:
//             Name: VkExternalMemoryFeatureFlagBitsKHR
//         Enum:
//             Name: VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_KHR
//             Negative: false
//             Extends: VkExternalMemoryFeatureFlagBits
//             Alias: VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT
//         Enum:
//             Name: VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_KHR
//             Negative: false
//             Extends: VkExternalMemoryFeatureFlagBits
//             Alias: VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT
//         Enum:
//             Name: VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_KHR
//             Negative: false
//             Extends: VkExternalMemoryFeatureFlagBits
//             Alias: VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT
//         Type:
//             Name: VkExternalMemoryPropertiesKHR
//         Type:
//             Name: VkPhysicalDeviceExternalImageFormatInfoKHR
//         Type:
//             Name: VkExternalImageFormatPropertiesKHR
//         Type:
//             Name: VkPhysicalDeviceExternalBufferInfoKHR
//         Type:
//             Name: VkExternalBufferPropertiesKHR
//         Type:
//             Name: VkPhysicalDeviceIDPropertiesKHR
//         Command:
//             Name: vkGetPhysicalDeviceExternalBufferPropertiesKHR
pub const VK_KHR_external_memory_name = "VK_KHR_external_memory";
// Extension: VK_KHR_external_memory
// Number: 73
// Type: device
// Author: KHR
// Depends: VK_KHR_external_memory_capabilities,VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_1
// Unlocks:
//         Enum:
//             Name: VK_KHR_EXTERNAL_MEMORY_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_EXTERNAL_MEMORY_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_external_memory&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO
//         Enum:
//             Name: VK_ERROR_INVALID_EXTERNAL_HANDLE_KHR
//             Negative: false
//             Extends: VkResult
//             Alias: VK_ERROR_INVALID_EXTERNAL_HANDLE
//         Enum:
//             Name: VK_QUEUE_FAMILY_EXTERNAL_KHR
//             Negative: false
//             Alias: VK_QUEUE_FAMILY_EXTERNAL
//         Type:
//             Name: VkExternalMemoryImageCreateInfoKHR
//         Type:
//             Name: VkExternalMemoryBufferCreateInfoKHR
//         Type:
//             Name: VkExportMemoryAllocateInfoKHR
pub const VK_KHR_external_memory_win32_name = "VK_KHR_external_memory_win32";
// Extension: VK_KHR_external_memory_win32
// Number: 74
// Type: device
// Author: KHR
// Depends: VK_KHR_external_memory,VK_VERSION_1_1
// Platform: win32
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_EXTERNAL_MEMORY_WIN32_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_EXTERNAL_MEMORY_WIN32_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_external_memory_win32&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Type:
//             Name: VkImportMemoryWin32HandleInfoKHR
//         Type:
//             Name: VkExportMemoryWin32HandleInfoKHR
//         Type:
//             Name: VkMemoryWin32HandlePropertiesKHR
//         Type:
//             Name: VkMemoryGetWin32HandleInfoKHR
//         Command:
//             Name: vkGetMemoryWin32HandleKHR
//         Command:
//             Name: vkGetMemoryWin32HandlePropertiesKHR
pub const VK_KHR_external_memory_fd_name = "VK_KHR_external_memory_fd";
// Extension: VK_KHR_external_memory_fd
// Number: 75
// Type: device
// Author: KHR
// Depends: VK_KHR_external_memory,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_EXTERNAL_MEMORY_FD_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_EXTERNAL_MEMORY_FD_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_external_memory_fd&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Type:
//             Name: VkImportMemoryFdInfoKHR
//         Type:
//             Name: VkMemoryFdPropertiesKHR
//         Type:
//             Name: VkMemoryGetFdInfoKHR
//         Command:
//             Name: vkGetMemoryFdKHR
//         Command:
//             Name: vkGetMemoryFdPropertiesKHR
pub const VK_KHR_win32_keyed_mutex_name = "VK_KHR_win32_keyed_mutex";
// Extension: VK_KHR_win32_keyed_mutex
// Number: 76
// Type: device
// Author: KHR
// Depends: VK_KHR_external_memory_win32
// Platform: win32
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_WIN32_KEYED_MUTEX_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_WIN32_KEYED_MUTEX_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_win32_keyed_mutex&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkWin32KeyedMutexAcquireReleaseInfoKHR
pub const VK_KHR_external_semaphore_capabilities_name = "VK_KHR_external_semaphore_capabilities";
// Extension: VK_KHR_external_semaphore_capabilities
// Number: 77
// Type: instance
// Author: KHR
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_1
// Unlocks:
//         Enum:
//             Name: VK_KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_external_semaphore_capabilities&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES
//         Enum:
//             Name: VK_LUID_SIZE_KHR
//             Negative: false
//         Type:
//             Name: VkExternalSemaphoreHandleTypeFlagsKHR
//         Type:
//             Name: VkExternalSemaphoreHandleTypeFlagBitsKHR
//         Enum:
//             Name: VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR
//             Negative: false
//             Extends: VkExternalSemaphoreHandleTypeFlagBits
//             Alias: VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT
//         Enum:
//             Name: VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR
//             Negative: false
//             Extends: VkExternalSemaphoreHandleTypeFlagBits
//             Alias: VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT
//         Enum:
//             Name: VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR
//             Negative: false
//             Extends: VkExternalSemaphoreHandleTypeFlagBits
//             Alias: VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT
//         Enum:
//             Name: VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT_KHR
//             Negative: false
//             Extends: VkExternalSemaphoreHandleTypeFlagBits
//             Alias: VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT
//         Enum:
//             Name: VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT_KHR
//             Negative: false
//             Extends: VkExternalSemaphoreHandleTypeFlagBits
//             Alias: VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT
//         Type:
//             Name: VkExternalSemaphoreFeatureFlagsKHR
//         Type:
//             Name: VkExternalSemaphoreFeatureFlagBitsKHR
//         Enum:
//             Name: VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT_KHR
//             Negative: false
//             Extends: VkExternalSemaphoreFeatureFlagBits
//             Alias: VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT
//         Enum:
//             Name: VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT_KHR
//             Negative: false
//             Extends: VkExternalSemaphoreFeatureFlagBits
//             Alias: VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT
//         Type:
//             Name: VkPhysicalDeviceExternalSemaphoreInfoKHR
//         Type:
//             Name: VkExternalSemaphorePropertiesKHR
//         Type:
//             Name: VkPhysicalDeviceIDPropertiesKHR
//         Command:
//             Name: vkGetPhysicalDeviceExternalSemaphorePropertiesKHR
pub const VK_KHR_external_semaphore_name = "VK_KHR_external_semaphore";
// Extension: VK_KHR_external_semaphore
// Number: 78
// Type: device
// Author: KHR
// Depends: VK_KHR_external_semaphore_capabilities
// Supported: supported
// Promoted to: VK_VERSION_1_1
// Unlocks:
//         Enum:
//             Name: VK_KHR_EXTERNAL_SEMAPHORE_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_EXTERNAL_SEMAPHORE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_external_semaphore&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO
//         Type:
//             Name: VkSemaphoreImportFlagsKHR
//         Type:
//             Name: VkSemaphoreImportFlagBitsKHR
//         Enum:
//             Name: VK_SEMAPHORE_IMPORT_TEMPORARY_BIT_KHR
//             Negative: false
//             Extends: VkSemaphoreImportFlagBits
//             Alias: VK_SEMAPHORE_IMPORT_TEMPORARY_BIT
//         Type:
//             Name: VkExportSemaphoreCreateInfoKHR
pub const VK_KHR_external_semaphore_win32_name = "VK_KHR_external_semaphore_win32";
// Extension: VK_KHR_external_semaphore_win32
// Number: 79
// Type: device
// Author: KHR
// Depends: VK_KHR_external_semaphore
// Platform: win32
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_EXTERNAL_SEMAPHORE_WIN32_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_EXTERNAL_SEMAPHORE_WIN32_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_external_semaphore_win32&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Type:
//             Name: VkImportSemaphoreWin32HandleInfoKHR
//         Type:
//             Name: VkExportSemaphoreWin32HandleInfoKHR
//         Type:
//             Name: VkD3D12FenceSubmitInfoKHR
//         Type:
//             Name: VkSemaphoreGetWin32HandleInfoKHR
//         Command:
//             Name: vkImportSemaphoreWin32HandleKHR
//         Command:
//             Name: vkGetSemaphoreWin32HandleKHR
pub const VK_KHR_external_semaphore_fd_name = "VK_KHR_external_semaphore_fd";
// Extension: VK_KHR_external_semaphore_fd
// Number: 80
// Type: device
// Author: KHR
// Depends: VK_KHR_external_semaphore,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_EXTERNAL_SEMAPHORE_FD_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_EXTERNAL_SEMAPHORE_FD_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_external_semaphore_fd&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Type:
//             Name: VkImportSemaphoreFdInfoKHR
//         Type:
//             Name: VkSemaphoreGetFdInfoKHR
//         Command:
//             Name: vkImportSemaphoreFdKHR
//         Command:
//             Name: vkGetSemaphoreFdKHR
pub const VK_KHR_push_descriptor_name = "VK_KHR_push_descriptor";
// Extension: VK_KHR_push_descriptor
// Number: 81
// Type: device
// Author: KHR
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_4
// Unlocks:
//         Enum:
//             Name: VK_KHR_PUSH_DESCRIPTOR_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_KHR_PUSH_DESCRIPTOR_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_push_descriptor&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES
//         Enum:
//             Name: VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR
//             Negative: false
//             Extends: VkDescriptorSetLayoutCreateFlagBits
//             Alias: VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT
//             Comment:
//                 Descriptors are pushed via flink:vkCmdPushDescriptorSet
//         Command:
//             Name: vkCmdPushDescriptorSetKHR
//         Type:
//             Name: VkPhysicalDevicePushDescriptorPropertiesKHR
//     Depends: VK_VERSION_1_1,VK_KHR_descriptor_update_template
//         Command:
//             Name: vkCmdPushDescriptorSetWithTemplateKHR
//         Enum:
//             Name: VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR
//             Negative: false
//             Extends: VkDescriptorUpdateTemplateType
//             Alias: VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS
//             Comment:
//                 Create descriptor update template for pushed descriptor updates
pub const VK_EXT_conditional_rendering_name = "VK_EXT_conditional_rendering";
// Extension: VK_EXT_conditional_rendering
// Number: 82
// Type: device
// Author: NV
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_CONDITIONAL_RENDERING_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_EXT_CONDITIONAL_RENDERING_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_conditional_rendering&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Type:
//             Name: VkConditionalRenderingFlagsEXT
//         Type:
//             Name: VkConditionalRenderingFlagBitsEXT
//         Enum:
//             Name: VK_ACCESS_CONDITIONAL_RENDERING_READ_BIT_EXT
//             Negative: false
//             Bitpos: 20
//             Extends: VkAccessFlagBits
//             Comment:
//                 read access flag for reading conditional rendering predicate
//         Enum:
//             Name: VK_BUFFER_USAGE_CONDITIONAL_RENDERING_BIT_EXT
//             Negative: false
//             Bitpos: 9
//             Extends: VkBufferUsageFlagBits
//             Comment:
//                 Specifies the buffer can be used as predicate in conditional rendering
//         Enum:
//             Name: VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT
//             Negative: false
//             Bitpos: 18
//             Extends: VkPipelineStageFlagBits
//             Comment:
//                 A pipeline stage for conditional rendering predicate fetch
//         Command:
//             Name: vkCmdBeginConditionalRenderingEXT
//         Command:
//             Name: vkCmdEndConditionalRenderingEXT
//         Type:
//             Name: VkConditionalRenderingBeginInfoEXT
//         Type:
//             Name: VkPhysicalDeviceConditionalRenderingFeaturesEXT
//         Type:
//             Name: VkCommandBufferInheritanceConditionalRenderingInfoEXT
//         Feature:
//             Name: conditionalRendering
//             Struct: VkPhysicalDeviceConditionalRenderingFeaturesEXT
pub const VK_KHR_shader_float16_int8_name = "VK_KHR_shader_float16_int8";
// Extension: VK_KHR_shader_float16_int8
// Number: 83
// Type: device
// Author: KHR
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_2
// Unlocks:
//         Enum:
//             Name: VK_KHR_SHADER_FLOAT16_INT8_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_SHADER_FLOAT16_INT8_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_shader_float16_int8&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT16_INT8_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES
//         Type:
//             Name: VkPhysicalDeviceShaderFloat16Int8FeaturesKHR
//         Type:
//             Name: VkPhysicalDeviceFloat16Int8FeaturesKHR
//         Feature:
//             Name: shaderFloat16,shaderInt8
//             Struct: VkPhysicalDeviceShaderFloat16Int8FeaturesKHR
pub const VK_KHR_16bit_storage_name = "VK_KHR_16bit_storage";
// Extension: VK_KHR_16bit_storage
// Number: 84
// Type: device
// Author: KHR
// Depends: (VK_KHR_get_physical_device_properties2+VK_KHR_storage_buffer_storage_class),VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_1
// Unlocks:
//         Enum:
//             Name: VK_KHR_16BIT_STORAGE_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_16BIT_STORAGE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_16bit_storage&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES
//         Type:
//             Name: VkPhysicalDevice16BitStorageFeaturesKHR
//         Feature:
//             Name: storageBuffer16BitAccess
//             Struct: VkPhysicalDevice16BitStorageFeaturesKHR
pub const VK_KHR_incremental_present_name = "VK_KHR_incremental_present";
// Extension: VK_KHR_incremental_present
// Number: 85
// Type: device
// Author: KHR
// Depends: VK_KHR_swapchain
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_INCREMENTAL_PRESENT_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_KHR_INCREMENTAL_PRESENT_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_incremental_present&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPresentRegionsKHR
//         Type:
//             Name: VkPresentRegionKHR
//         Type:
//             Name: VkRectLayerKHR
pub const VK_KHR_descriptor_update_template_name = "VK_KHR_descriptor_update_template";
// Extension: VK_KHR_descriptor_update_template
// Number: 86
// Type: device
// Author: KHR
// Supported: supported
// Promoted to: VK_VERSION_1_1
// Unlocks:
//         Enum:
//             Name: VK_KHR_DESCRIPTOR_UPDATE_TEMPLATE_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_DESCRIPTOR_UPDATE_TEMPLATE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_descriptor_update_template&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO
//         Enum:
//             Name: VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR
//             Negative: false
//             Extends: VkObjectType
//             Alias: VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE
//         Command:
//             Name: vkCreateDescriptorUpdateTemplateKHR
//         Command:
//             Name: vkDestroyDescriptorUpdateTemplateKHR
//         Command:
//             Name: vkUpdateDescriptorSetWithTemplateKHR
//         Type:
//             Name: VkDescriptorUpdateTemplateKHR
//         Type:
//             Name: VkDescriptorUpdateTemplateCreateFlagsKHR
//         Type:
//             Name: VkDescriptorUpdateTemplateTypeKHR
//         Type:
//             Name: VkDescriptorUpdateTemplateEntryKHR
//         Type:
//             Name: VkDescriptorUpdateTemplateCreateInfoKHR
//         Enum:
//             Name: VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET_KHR
//             Negative: false
//             Extends: VkDescriptorUpdateTemplateType
//             Alias: VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET
//     Depends: VK_KHR_push_descriptor
//         Command:
//             Name: vkCmdPushDescriptorSetWithTemplateKHR
//         Enum:
//             Name: VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR
//             Negative: false
//             Extends: VkDescriptorUpdateTemplateType
//             Alias: VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS
//             Comment:
//                 Create descriptor update template for pushed descriptor updates
//     Depends: VK_EXT_debug_report
//         Enum:
//             Name: VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR_EXT
//             Negative: false
//             Extends: VkDebugReportObjectTypeEXT
//             Alias: VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_EXT
pub const VK_NVX_device_generated_commands_name = "VK_NVX_device_generated_commands";
// Extension: VK_NVX_device_generated_commands
// Number: 87
// Type: device
// Author: NVX
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_NVX_DEVICE_GENERATED_COMMANDS_SPEC_VERSION
//             Negative: false
//             Value: 3
//         Enum:
//             Name: VK_NVX_DEVICE_GENERATED_COMMANDS_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NVX_device_generated_commands&quot;
pub const VK_NV_clip_space_w_scaling_name = "VK_NV_clip_space_w_scaling";
// Extension: VK_NV_clip_space_w_scaling
// Number: 88
// Type: device
// Author: NV
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NV_CLIP_SPACE_W_SCALING_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_NV_CLIP_SPACE_W_SCALING_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_clip_space_w_scaling&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV
//             Negative: false
//             Extends: VkDynamicState
//             Offset: 0
//         Type:
//             Name: VkViewportWScalingNV
//         Type:
//             Name: VkPipelineViewportWScalingStateCreateInfoNV
//         Command:
//             Name: vkCmdSetViewportWScalingNV
pub const VK_EXT_direct_mode_display_name = "VK_EXT_direct_mode_display";
// Extension: VK_EXT_direct_mode_display
// Number: 89
// Type: instance
// Author: NV
// Depends: VK_KHR_display
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_DIRECT_MODE_DISPLAY_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_DIRECT_MODE_DISPLAY_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_direct_mode_display&quot;
//         Command:
//             Name: vkReleaseDisplayEXT
pub const VK_EXT_acquire_xlib_display_name = "VK_EXT_acquire_xlib_display";
// Extension: VK_EXT_acquire_xlib_display
// Number: 90
// Type: instance
// Author: NV
// Depends: VK_EXT_direct_mode_display
// Platform: xlib_xrandr
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_ACQUIRE_XLIB_DISPLAY_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_ACQUIRE_XLIB_DISPLAY_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_acquire_xlib_display&quot;
//         Command:
//             Name: vkAcquireXlibDisplayEXT
//         Command:
//             Name: vkGetRandROutputDisplayEXT
pub const VK_EXT_display_surface_counter_name = "VK_EXT_display_surface_counter";
// Extension: VK_EXT_display_surface_counter
// Number: 91
// Type: instance
// Author: NV
// Depends: VK_KHR_display
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_DISPLAY_SURFACE_COUNTER_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_DISPLAY_SURFACE_COUNTER_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_display_surface_counter&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES2_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT
//         Type:
//             Name: VkSurfaceCounterFlagsEXT
//         Type:
//             Name: VkSurfaceCounterFlagBitsEXT
//         Type:
//             Name: VkSurfaceCapabilities2EXT
//         Command:
//             Name: vkGetPhysicalDeviceSurfaceCapabilities2EXT
pub const VK_EXT_display_control_name = "VK_EXT_display_control";
// Extension: VK_EXT_display_control
// Number: 92
// Type: device
// Author: NV
// Depends: VK_EXT_display_surface_counter+VK_KHR_swapchain
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_DISPLAY_CONTROL_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_DISPLAY_CONTROL_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_display_control&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Type:
//             Name: VkDisplayPowerStateEXT
//         Type:
//             Name: VkDeviceEventTypeEXT
//         Type:
//             Name: VkDisplayEventTypeEXT
//         Type:
//             Name: VkDisplayPowerInfoEXT
//         Type:
//             Name: VkDeviceEventInfoEXT
//         Type:
//             Name: VkDisplayEventInfoEXT
//         Type:
//             Name: VkSwapchainCounterCreateInfoEXT
//         Command:
//             Name: vkDisplayPowerControlEXT
//         Command:
//             Name: vkRegisterDeviceEventEXT
//         Command:
//             Name: vkRegisterDisplayEventEXT
//         Command:
//             Name: vkGetSwapchainCounterEXT
pub const VK_GOOGLE_display_timing_name = "VK_GOOGLE_display_timing";
// Extension: VK_GOOGLE_display_timing
// Number: 93
// Type: device
// Author: GOOGLE
// Depends: VK_KHR_swapchain
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_GOOGLE_DISPLAY_TIMING_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_GOOGLE_DISPLAY_TIMING_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_GOOGLE_display_timing&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkRefreshCycleDurationGOOGLE
//         Type:
//             Name: VkPastPresentationTimingGOOGLE
//         Type:
//             Name: VkPresentTimesInfoGOOGLE
//         Type:
//             Name: VkPresentTimeGOOGLE
//         Command:
//             Name: vkGetRefreshCycleDurationGOOGLE
//         Command:
//             Name: vkGetPastPresentationTimingGOOGLE
pub const VK_RESERVED_do_not_use_94_name = "VK_RESERVED_do_not_use_94";
// Extension: VK_RESERVED_do_not_use_94
// Number: 94
// Type: invalid
// Supported: disabled
// Comment:
//     Used for functionality subsumed into Vulkan 1.1 and not published as an extension
// Unlocks:
//         Enum:
//             Name: VK_RESERVED_DO_NOT_USE_94_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_RESERVED_DO_NOT_USE_94_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_RESERVED_do_not_use_94&quot;
pub const VK_NV_sample_mask_override_coverage_name = "VK_NV_sample_mask_override_coverage";
// Extension: VK_NV_sample_mask_override_coverage
// Number: 95
// Type: device
// Author: NV
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NV_SAMPLE_MASK_OVERRIDE_COVERAGE_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_NV_SAMPLE_MASK_OVERRIDE_COVERAGE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_sample_mask_override_coverage&quot;
//         Comment:
//             enum offset=0 was mistakenly used for the 1.1 core enum
//             VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES
//             (value=1000094000). Fortunately, no conflict resulted.
pub const VK_NV_geometry_shader_passthrough_name = "VK_NV_geometry_shader_passthrough";
// Extension: VK_NV_geometry_shader_passthrough
// Number: 96
// Type: device
// Author: NV
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NV_GEOMETRY_SHADER_PASSTHROUGH_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_NV_GEOMETRY_SHADER_PASSTHROUGH_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_geometry_shader_passthrough&quot;
pub const VK_NV_viewport_array2_name = "VK_NV_viewport_array2";
// Extension: VK_NV_viewport_array2
// Number: 97
// Type: device
// Author: NV
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NV_VIEWPORT_ARRAY_2_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_NV_VIEWPORT_ARRAY_2_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_viewport_array2&quot;
//         Enum:
//             Name: VK_NV_VIEWPORT_ARRAY2_SPEC_VERSION
//             Negative: false
//             Alias: VK_NV_VIEWPORT_ARRAY_2_SPEC_VERSION
//         Enum:
//             Name: VK_NV_VIEWPORT_ARRAY2_EXTENSION_NAME
//             Negative: false
//             Alias: VK_NV_VIEWPORT_ARRAY_2_EXTENSION_NAME
pub const VK_NVX_multiview_per_view_attributes_name = "VK_NVX_multiview_per_view_attributes";
// Extension: VK_NVX_multiview_per_view_attributes
// Number: 98
// Type: device
// Author: NVX
// Depends: VK_KHR_multiview,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NVX_MULTIVIEW_PER_VIEW_ATTRIBUTES_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_NVX_MULTIVIEW_PER_VIEW_ATTRIBUTES_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NVX_multiview_per_view_attributes&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX
//             Negative: false
//             Bitpos: 0
//             Extends: VkSubpassDescriptionFlagBits
//         Enum:
//             Name: VK_SUBPASS_DESCRIPTION_PER_VIEW_POSITION_X_ONLY_BIT_NVX
//             Negative: false
//             Bitpos: 1
//             Extends: VkSubpassDescriptionFlagBits
//         Type:
//             Name: VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX
//     Depends: VK_VERSION_1_3,VK_KHR_dynamic_rendering
//         Enum:
//             Name: VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_NVX
//             Negative: false
//             Extends: VkStructureType
//             Extnumber: 45
//             Offset: 9
//         Type:
//             Name: VkMultiviewPerViewAttributesInfoNVX
pub const VK_NV_viewport_swizzle_name = "VK_NV_viewport_swizzle";
// Extension: VK_NV_viewport_swizzle
// Number: 99
// Type: device
// Author: NV
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NV_VIEWPORT_SWIZZLE_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_NV_VIEWPORT_SWIZZLE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_viewport_swizzle&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkViewportSwizzleNV
//         Type:
//             Name: VkViewportCoordinateSwizzleNV
//         Type:
//             Name: VkPipelineViewportSwizzleStateCreateInfoNV
//         Type:
//             Name: VkPipelineViewportSwizzleStateCreateFlagsNV
pub const VK_EXT_discard_rectangles_name = "VK_EXT_discard_rectangles";
// Extension: VK_EXT_discard_rectangles
// Number: 100
// Type: device
// Author: NV
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_DISCARD_RECTANGLES_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_EXT_DISCARD_RECTANGLES_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_discard_rectangles&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT
//             Negative: false
//             Extends: VkDynamicState
//             Offset: 0
//         Enum:
//             Name: VK_DYNAMIC_STATE_DISCARD_RECTANGLE_ENABLE_EXT
//             Negative: false
//             Extends: VkDynamicState
//             Offset: 1
//         Enum:
//             Name: VK_DYNAMIC_STATE_DISCARD_RECTANGLE_MODE_EXT
//             Negative: false
//             Extends: VkDynamicState
//             Offset: 2
//         Type:
//             Name: VkPhysicalDeviceDiscardRectanglePropertiesEXT
//         Type:
//             Name: VkPipelineDiscardRectangleStateCreateInfoEXT
//         Type:
//             Name: VkPipelineDiscardRectangleStateCreateFlagsEXT
//         Type:
//             Name: VkDiscardRectangleModeEXT
//         Command:
//             Name: vkCmdSetDiscardRectangleEXT
//         Command:
//             Name: vkCmdSetDiscardRectangleEnableEXT
//         Command:
//             Name: vkCmdSetDiscardRectangleModeEXT
pub const VK_NV_extension_101_name = "VK_NV_extension_101";
// Extension: VK_NV_extension_101
// Number: 101
// Type: invalid
// Author: NV
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_NV_EXTENSION_101_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_NV_EXTENSION_101_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_extension_101&quot;
pub const VK_EXT_conservative_rasterization_name = "VK_EXT_conservative_rasterization";
// Extension: VK_EXT_conservative_rasterization
// Number: 102
// Type: device
// Author: NV
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_CONSERVATIVE_RASTERIZATION_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_CONSERVATIVE_RASTERIZATION_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_conservative_rasterization&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Type:
//             Name: VkPhysicalDeviceConservativeRasterizationPropertiesEXT
//         Type:
//             Name: VkPipelineRasterizationConservativeStateCreateInfoEXT
//         Type:
//             Name: VkPipelineRasterizationConservativeStateCreateFlagsEXT
//         Type:
//             Name: VkConservativeRasterizationModeEXT
pub const VK_EXT_depth_clip_enable_name = "VK_EXT_depth_clip_enable";
// Extension: VK_EXT_depth_clip_enable
// Number: 103
// Type: device
// Author: EXT
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_DEPTH_CLIP_ENABLE_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_DEPTH_CLIP_ENABLE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_depth_clip_enable&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Type:
//             Name: VkPhysicalDeviceDepthClipEnableFeaturesEXT
//         Type:
//             Name: VkPipelineRasterizationDepthClipStateCreateInfoEXT
//         Type:
//             Name: VkPipelineRasterizationDepthClipStateCreateFlagsEXT
//         Feature:
//             Name: depthClipEnable
//             Struct: VkPhysicalDeviceDepthClipEnableFeaturesEXT
pub const VK_NV_extension_104_name = "VK_NV_extension_104";
// Extension: VK_NV_extension_104
// Number: 104
// Type: invalid
// Author: NV
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_NV_EXTENSION_104_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_NV_EXTENSION_104_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_extension_104&quot;
//         Enum:
//             Name: VK_PRIVATE_DATA_SLOT_CREATE_RESERVED_0_BIT_NV
//             Negative: false
//             Bitpos: 0
//             Extends: VkPrivateDataSlotCreateFlagBits
pub const VK_EXT_swapchain_colorspace_name = "VK_EXT_swapchain_colorspace";
// Extension: VK_EXT_swapchain_colorspace
// Number: 105
// Type: instance
// Author: GOOGLE
// Depends: VK_KHR_surface
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_SWAPCHAIN_COLOR_SPACE_SPEC_VERSION
//             Negative: false
//             Value: 5
//         Enum:
//             Name: VK_EXT_SWAPCHAIN_COLOR_SPACE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_swapchain_colorspace&quot;
//         Enum:
//             Name: VK_COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT
//             Negative: false
//             Extends: VkColorSpaceKHR
//             Offset: 1
//         Enum:
//             Name: VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT
//             Negative: false
//             Extends: VkColorSpaceKHR
//             Offset: 2
//         Enum:
//             Name: VK_COLOR_SPACE_DISPLAY_P3_LINEAR_EXT
//             Negative: false
//             Extends: VkColorSpaceKHR
//             Offset: 3
//         Enum:
//             Name: VK_COLOR_SPACE_DCI_P3_NONLINEAR_EXT
//             Negative: false
//             Extends: VkColorSpaceKHR
//             Offset: 4
//         Enum:
//             Name: VK_COLOR_SPACE_BT709_LINEAR_EXT
//             Negative: false
//             Extends: VkColorSpaceKHR
//             Offset: 5
//         Enum:
//             Name: VK_COLOR_SPACE_BT709_NONLINEAR_EXT
//             Negative: false
//             Extends: VkColorSpaceKHR
//             Offset: 6
//         Enum:
//             Name: VK_COLOR_SPACE_BT2020_LINEAR_EXT
//             Negative: false
//             Extends: VkColorSpaceKHR
//             Offset: 7
//         Enum:
//             Name: VK_COLOR_SPACE_HDR10_ST2084_EXT
//             Negative: false
//             Extends: VkColorSpaceKHR
//             Offset: 8
//         Enum:
//             Name: VK_COLOR_SPACE_DOLBYVISION_EXT
//             Negative: false
//             Extends: VkColorSpaceKHR
//             Offset: 9
//         Enum:
//             Name: VK_COLOR_SPACE_HDR10_HLG_EXT
//             Negative: false
//             Extends: VkColorSpaceKHR
//             Offset: 10
//         Enum:
//             Name: VK_COLOR_SPACE_ADOBERGB_LINEAR_EXT
//             Negative: false
//             Extends: VkColorSpaceKHR
//             Offset: 11
//         Enum:
//             Name: VK_COLOR_SPACE_ADOBERGB_NONLINEAR_EXT
//             Negative: false
//             Extends: VkColorSpaceKHR
//             Offset: 12
//         Enum:
//             Name: VK_COLOR_SPACE_PASS_THROUGH_EXT
//             Negative: false
//             Extends: VkColorSpaceKHR
//             Offset: 13
//         Enum:
//             Name: VK_COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT
//             Negative: false
//             Extends: VkColorSpaceKHR
//             Offset: 14
//         Enum:
//             Name: VK_COLOR_SPACE_DCI_P3_LINEAR_EXT
//             Negative: false
//             Extends: VkColorSpaceKHR
//             Alias: VK_COLOR_SPACE_DISPLAY_P3_LINEAR_EXT
pub const VK_EXT_hdr_metadata_name = "VK_EXT_hdr_metadata";
// Extension: VK_EXT_hdr_metadata
// Number: 106
// Type: device
// Author: GOOGLE
// Depends: VK_KHR_swapchain
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_HDR_METADATA_SPEC_VERSION
//             Negative: false
//             Value: 3
//         Enum:
//             Name: VK_EXT_HDR_METADATA_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_hdr_metadata&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_HDR_METADATA_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkHdrMetadataEXT
//         Type:
//             Name: VkXYColorEXT
//         Command:
//             Name: vkSetHdrMetadataEXT
pub const VK_IMG_extension_107_name = "VK_IMG_extension_107";
// Extension: VK_IMG_extension_107
// Number: 107
// Type: invalid
// Author: IMG
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_IMG_EXTENSION_107_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_IMG_EXTENSION_107_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_IMG_extension_107&quot;
//         Enum:
//             Name: VK_BUFFER_CREATE_RESERVED_7_BIT_IMG
//             Negative: false
//             Bitpos: 7
//             Extends: VkBufferCreateFlagBits
//         Enum:
//             Name: VK_IMAGE_CREATE_RESERVED_21_BIT_IMG
//             Negative: false
//             Bitpos: 21
//             Extends: VkImageCreateFlagBits
//         Enum:
//             Name: VK_PIPELINE_CREATE_2_RESERVED_46_BIT_IMG
//             Negative: false
//             Bitpos: 46
//             Extends: VkPipelineCreateFlagBits2
//         Enum:
//             Name: VK_SHADER_CREATE_RESERVED_17_BIT_IMG
//             Negative: false
//             Bitpos: 17
//             Extends: VkShaderCreateFlagBitsEXT
//         Enum:
//             Name: VK_RENDERING_RESERVED_9_BIT_IMG
//             Negative: false
//             Bitpos: 9
//             Extends: VkRenderingFlagBits
//         Enum:
//             Name: VK_RENDER_PASS_CREATE_RESERVED_3_BIT_IMG
//             Negative: false
//             Bitpos: 3
//             Extends: VkRenderPassCreateFlagBits
pub const VK_IMG_extension_108_name = "VK_IMG_extension_108";
// Extension: VK_IMG_extension_108
// Number: 108
// Type: invalid
// Author: IMG
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_IMG_EXTENSION_108_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_IMG_EXTENSION_108_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_IMG_extension_108&quot;
pub const VK_KHR_imageless_framebuffer_name = "VK_KHR_imageless_framebuffer";
// Extension: VK_KHR_imageless_framebuffer
// Number: 109
// Type: device
// Author: KHR
// Depends: (((VK_KHR_get_physical_device_properties2+VK_KHR_maintenance2),VK_VERSION_1_1)+VK_KHR_image_format_list),VK_VERSION_1_2
// Supported: supported
// Promoted to: VK_VERSION_1_2
// Unlocks:
//         Enum:
//             Name: VK_KHR_IMAGELESS_FRAMEBUFFER_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_IMAGELESS_FRAMEBUFFER_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_imageless_framebuffer&quot;
//         Type:
//             Name: VkPhysicalDeviceImagelessFramebufferFeaturesKHR
//         Type:
//             Name: VkFramebufferAttachmentsCreateInfoKHR
//         Type:
//             Name: VkFramebufferAttachmentImageInfoKHR
//         Type:
//             Name: VkRenderPassAttachmentBeginInfoKHR
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES
//         Enum:
//             Name: VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO
//         Enum:
//             Name: VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT_KHR
//             Negative: false
//             Extends: VkFramebufferCreateFlagBits
//             Alias: VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT
//         Feature:
//             Name: imagelessFramebuffer
//             Struct: VkPhysicalDeviceImagelessFramebufferFeaturesKHR
pub const VK_KHR_create_renderpass2_name = "VK_KHR_create_renderpass2";
// Extension: VK_KHR_create_renderpass2
// Number: 110
// Type: device
// Author: KHR
// Depends: (VK_KHR_multiview+VK_KHR_maintenance2),VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_2
// Unlocks:
//         Enum:
//             Name: VK_KHR_CREATE_RENDERPASS_2_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_CREATE_RENDERPASS_2_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_create_renderpass2&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SUBPASS_END_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_SUBPASS_END_INFO
//         Command:
//             Name: vkCreateRenderPass2KHR
//         Command:
//             Name: vkCmdBeginRenderPass2KHR
//         Command:
//             Name: vkCmdNextSubpass2KHR
//         Command:
//             Name: vkCmdEndRenderPass2KHR
//         Type:
//             Name: VkRenderPassCreateInfo2KHR
//         Type:
//             Name: VkAttachmentDescription2KHR
//         Type:
//             Name: VkAttachmentReference2KHR
//         Type:
//             Name: VkSubpassDescription2KHR
//         Type:
//             Name: VkSubpassDependency2KHR
//         Type:
//             Name: VkSubpassBeginInfoKHR
//         Type:
//             Name: VkSubpassEndInfoKHR
pub const VK_IMG_relaxed_line_rasterization_name = "VK_IMG_relaxed_line_rasterization";
// Extension: VK_IMG_relaxed_line_rasterization
// Number: 111
// Type: device
// Author: IMG
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_IMG_RELAXED_LINE_RASTERIZATION_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_IMG_RELAXED_LINE_RASTERIZATION_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_IMG_relaxed_line_rasterization&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RELAXED_LINE_RASTERIZATION_FEATURES_IMG
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG
//         Feature:
//             Name: relaxedLineRasterization
//             Struct: VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG
pub const VK_KHR_shared_presentable_image_name = "VK_KHR_shared_presentable_image";
// Extension: VK_KHR_shared_presentable_image
// Number: 112
// Type: device
// Author: KHR
// Depends: VK_KHR_swapchain+VK_KHR_get_surface_capabilities2+(VK_KHR_get_physical_device_properties2,VK_VERSION_1_1)
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_SHARED_PRESENTABLE_IMAGE_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_SHARED_PRESENTABLE_IMAGE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_shared_presentable_image&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR
//             Negative: false
//             Extends: VkPresentModeKHR
//             Offset: 0
//         Enum:
//             Name: VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR
//             Negative: false
//             Extends: VkPresentModeKHR
//             Offset: 1
//         Enum:
//             Name: VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR
//             Negative: false
//             Extends: VkImageLayout
//             Offset: 0
//         Type:
//             Name: VkSharedPresentSurfaceCapabilitiesKHR
//         Command:
//             Name: vkGetSwapchainStatusKHR
pub const VK_KHR_external_fence_capabilities_name = "VK_KHR_external_fence_capabilities";
// Extension: VK_KHR_external_fence_capabilities
// Number: 113
// Type: instance
// Author: KHR
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_1
// Unlocks:
//         Enum:
//             Name: VK_KHR_EXTERNAL_FENCE_CAPABILITIES_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_EXTERNAL_FENCE_CAPABILITIES_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_external_fence_capabilities&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES
//         Enum:
//             Name: VK_LUID_SIZE_KHR
//             Negative: false
//         Type:
//             Name: VkExternalFenceHandleTypeFlagsKHR
//         Type:
//             Name: VkExternalFenceHandleTypeFlagBitsKHR
//         Enum:
//             Name: VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR
//             Negative: false
//             Extends: VkExternalFenceHandleTypeFlagBits
//             Alias: VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT
//         Enum:
//             Name: VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR
//             Negative: false
//             Extends: VkExternalFenceHandleTypeFlagBits
//             Alias: VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT
//         Enum:
//             Name: VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR
//             Negative: false
//             Extends: VkExternalFenceHandleTypeFlagBits
//             Alias: VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT
//         Enum:
//             Name: VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT_KHR
//             Negative: false
//             Extends: VkExternalFenceHandleTypeFlagBits
//             Alias: VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT
//         Type:
//             Name: VkExternalFenceFeatureFlagsKHR
//         Type:
//             Name: VkExternalFenceFeatureFlagBitsKHR
//         Enum:
//             Name: VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT_KHR
//             Negative: false
//             Extends: VkExternalFenceFeatureFlagBits
//             Alias: VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT
//         Enum:
//             Name: VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT_KHR
//             Negative: false
//             Extends: VkExternalFenceFeatureFlagBits
//             Alias: VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT
//         Type:
//             Name: VkPhysicalDeviceExternalFenceInfoKHR
//         Type:
//             Name: VkExternalFencePropertiesKHR
//         Type:
//             Name: VkPhysicalDeviceIDPropertiesKHR
//         Command:
//             Name: vkGetPhysicalDeviceExternalFencePropertiesKHR
pub const VK_KHR_external_fence_name = "VK_KHR_external_fence";
// Extension: VK_KHR_external_fence
// Number: 114
// Type: device
// Author: KHR
// Depends: VK_KHR_external_fence_capabilities
// Supported: supported
// Promoted to: VK_VERSION_1_1
// Unlocks:
//         Enum:
//             Name: VK_KHR_EXTERNAL_FENCE_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_EXTERNAL_FENCE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_external_fence&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO
//         Type:
//             Name: VkFenceImportFlagsKHR
//         Type:
//             Name: VkFenceImportFlagBitsKHR
//         Enum:
//             Name: VK_FENCE_IMPORT_TEMPORARY_BIT_KHR
//             Negative: false
//             Extends: VkFenceImportFlagBits
//             Alias: VK_FENCE_IMPORT_TEMPORARY_BIT
//         Type:
//             Name: VkExportFenceCreateInfoKHR
pub const VK_KHR_external_fence_win32_name = "VK_KHR_external_fence_win32";
// Extension: VK_KHR_external_fence_win32
// Number: 115
// Type: device
// Author: KHR
// Depends: VK_KHR_external_fence
// Platform: win32
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_EXTERNAL_FENCE_WIN32_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_EXTERNAL_FENCE_WIN32_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_external_fence_win32&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Type:
//             Name: VkImportFenceWin32HandleInfoKHR
//         Type:
//             Name: VkExportFenceWin32HandleInfoKHR
//         Type:
//             Name: VkFenceGetWin32HandleInfoKHR
//         Command:
//             Name: vkImportFenceWin32HandleKHR
//         Command:
//             Name: vkGetFenceWin32HandleKHR
pub const VK_KHR_external_fence_fd_name = "VK_KHR_external_fence_fd";
// Extension: VK_KHR_external_fence_fd
// Number: 116
// Type: device
// Author: KHR
// Depends: VK_KHR_external_fence,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_EXTERNAL_FENCE_FD_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_EXTERNAL_FENCE_FD_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_external_fence_fd&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Type:
//             Name: VkImportFenceFdInfoKHR
//         Type:
//             Name: VkFenceGetFdInfoKHR
//         Command:
//             Name: vkImportFenceFdKHR
//         Command:
//             Name: vkGetFenceFdKHR
pub const VK_KHR_performance_query_name = "VK_KHR_performance_query";
// Extension: VK_KHR_performance_query
// Number: 117
// Type: device
// Author: KHR
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_PERFORMANCE_QUERY_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_PERFORMANCE_QUERY_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_performance_query&quot;
//         Enum:
//             Name: VK_QUERY_TYPE_PERFORMANCE_QUERY_KHR
//             Negative: false
//             Extends: VkQueryType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Enum:
//             Name: VK_STRUCTURE_TYPE_ACQUIRE_PROFILING_LOCK_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 4
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 5
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_DESCRIPTION_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 6
//         Type:
//             Name: VkPhysicalDevicePerformanceQueryFeaturesKHR
//         Type:
//             Name: VkPhysicalDevicePerformanceQueryPropertiesKHR
//         Type:
//             Name: VkPerformanceCounterKHR
//         Type:
//             Name: VkPerformanceCounterDescriptionKHR
//         Type:
//             Name: VkPerformanceCounterDescriptionFlagsKHR
//         Type:
//             Name: VkPerformanceCounterDescriptionFlagBitsKHR
//         Type:
//             Name: VkQueryPoolPerformanceCreateInfoKHR
//         Type:
//             Name: VkPerformanceCounterScopeKHR
//         Type:
//             Name: VkPerformanceCounterStorageKHR
//         Type:
//             Name: VkPerformanceCounterUnitKHR
//         Type:
//             Name: VkPerformanceCounterResultKHR
//         Type:
//             Name: VkAcquireProfilingLockInfoKHR
//         Type:
//             Name: VkAcquireProfilingLockFlagsKHR
//         Type:
//             Name: VkAcquireProfilingLockFlagBitsKHR
//         Type:
//             Name: VkPerformanceQuerySubmitInfoKHR
//         Command:
//             Name: vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR
//         Command:
//             Name: vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR
//         Command:
//             Name: vkAcquireProfilingLockKHR
//         Command:
//             Name: vkReleaseProfilingLockKHR
//         Feature:
//             Name: performanceCounterQueryPools
//             Struct: VkPhysicalDevicePerformanceQueryFeaturesKHR
//     Depends: VKSC_VERSION_1_0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_RESERVATION_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 7
//         Type:
//             Name: VkPerformanceQueryReservationInfoKHR
pub const VK_KHR_maintenance2_name = "VK_KHR_maintenance2";
// Extension: VK_KHR_maintenance2
// Number: 118
// Type: device
// Author: KHR
// Supported: supported
// Promoted to: VK_VERSION_1_1
// Unlocks:
//         Enum:
//             Name: VK_KHR_MAINTENANCE_2_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_MAINTENANCE_2_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_maintenance2&quot;
//         Enum:
//             Name: VK_KHR_MAINTENANCE2_SPEC_VERSION
//             Negative: false
//             Alias: VK_KHR_MAINTENANCE_2_SPEC_VERSION
//         Enum:
//             Name: VK_KHR_MAINTENANCE2_EXTENSION_NAME
//             Negative: false
//             Alias: VK_KHR_MAINTENANCE_2_EXTENSION_NAME
//         Enum:
//             Name: VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT_KHR
//             Negative: false
//             Extends: VkImageCreateFlagBits
//             Alias: VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT
//         Enum:
//             Name: VK_IMAGE_CREATE_EXTENDED_USAGE_BIT_KHR
//             Negative: false
//             Extends: VkImageCreateFlagBits
//             Alias: VK_IMAGE_CREATE_EXTENDED_USAGE_BIT
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES
//         Enum:
//             Name: VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO
//         Enum:
//             Name: VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL_KHR
//             Negative: false
//             Extends: VkImageLayout
//             Alias: VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL
//         Enum:
//             Name: VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL_KHR
//             Negative: false
//             Extends: VkImageLayout
//             Alias: VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL
//         Type:
//             Name: VkPhysicalDevicePointClippingPropertiesKHR
//         Type:
//             Name: VkPointClippingBehaviorKHR
//         Enum:
//             Name: VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES_KHR
//             Negative: false
//             Extends: VkPointClippingBehavior
//             Alias: VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES
//         Enum:
//             Name: VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY_KHR
//             Negative: false
//             Extends: VkPointClippingBehavior
//             Alias: VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY
//         Type:
//             Name: VkRenderPassInputAttachmentAspectCreateInfoKHR
//         Type:
//             Name: VkInputAttachmentAspectReferenceKHR
//         Type:
//             Name: VkImageViewUsageCreateInfoKHR
//         Type:
//             Name: VkTessellationDomainOriginKHR
//         Enum:
//             Name: VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT_KHR
//             Negative: false
//             Extends: VkTessellationDomainOrigin
//             Alias: VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT
//         Enum:
//             Name: VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT_KHR
//             Negative: false
//             Extends: VkTessellationDomainOrigin
//             Alias: VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT
//         Type:
//             Name: VkPipelineTessellationDomainOriginStateCreateInfoKHR
pub const VK_KHR_extension_119_name = "VK_KHR_extension_119";
// Extension: VK_KHR_extension_119
// Number: 119
// Type: invalid
// Author: KHR
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_KHR_EXTENSION_119_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_KHR_EXTENSION_119_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_extension_119&quot;
pub const VK_KHR_get_surface_capabilities2_name = "VK_KHR_get_surface_capabilities2";
// Extension: VK_KHR_get_surface_capabilities2
// Number: 120
// Type: instance
// Author: KHR
// Depends: VK_KHR_surface
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_GET_SURFACE_CAPABILITIES_2_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_GET_SURFACE_CAPABILITIES_2_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_get_surface_capabilities2&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Type:
//             Name: VkPhysicalDeviceSurfaceInfo2KHR
//         Type:
//             Name: VkSurfaceCapabilities2KHR
//         Type:
//             Name: VkSurfaceFormat2KHR
//         Command:
//             Name: vkGetPhysicalDeviceSurfaceCapabilities2KHR
//         Command:
//             Name: vkGetPhysicalDeviceSurfaceFormats2KHR
pub const VK_KHR_variable_pointers_name = "VK_KHR_variable_pointers";
// Extension: VK_KHR_variable_pointers
// Number: 121
// Type: device
// Author: KHR
// Depends: (VK_KHR_get_physical_device_properties2+VK_KHR_storage_buffer_storage_class),VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_1
// Unlocks:
//         Enum:
//             Name: VK_KHR_VARIABLE_POINTERS_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_VARIABLE_POINTERS_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_variable_pointers&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES_KHR
//         Type:
//             Name: VkPhysicalDeviceVariablePointerFeaturesKHR
//         Type:
//             Name: VkPhysicalDeviceVariablePointersFeaturesKHR
//         Feature:
//             Name: variablePointersStorageBuffer
//             Struct: VkPhysicalDeviceVariablePointerFeaturesKHR
pub const VK_KHR_get_display_properties2_name = "VK_KHR_get_display_properties2";
// Extension: VK_KHR_get_display_properties2
// Number: 122
// Type: instance
// Author: KHR
// Depends: VK_KHR_display
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_GET_DISPLAY_PROPERTIES_2_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_GET_DISPLAY_PROPERTIES_2_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_get_display_properties2&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 4
//         Type:
//             Name: VkDisplayProperties2KHR
//         Type:
//             Name: VkDisplayPlaneProperties2KHR
//         Type:
//             Name: VkDisplayModeProperties2KHR
//         Type:
//             Name: VkDisplayPlaneInfo2KHR
//         Type:
//             Name: VkDisplayPlaneCapabilities2KHR
//         Command:
//             Name: vkGetPhysicalDeviceDisplayProperties2KHR
//         Command:
//             Name: vkGetPhysicalDeviceDisplayPlaneProperties2KHR
//         Command:
//             Name: vkGetDisplayModeProperties2KHR
//         Command:
//             Name: vkGetDisplayPlaneCapabilities2KHR
pub const VK_MVK_ios_surface_name = "VK_MVK_ios_surface";
// Extension: VK_MVK_ios_surface
// Number: 123
// Type: instance
// Author: MVK
// Depends: VK_KHR_surface
// Platform: ios
// Supported: supported
// Deprecated by: VK_EXT_metal_surface
// Unlocks:
//         Enum:
//             Name: VK_MVK_IOS_SURFACE_SPEC_VERSION
//             Negative: false
//             Value: 3
//         Enum:
//             Name: VK_MVK_IOS_SURFACE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_MVK_ios_surface&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkIOSSurfaceCreateFlagsMVK
//         Type:
//             Name: VkIOSSurfaceCreateInfoMVK
//         Command:
//             Name: vkCreateIOSSurfaceMVK
pub const VK_MVK_macos_surface_name = "VK_MVK_macos_surface";
// Extension: VK_MVK_macos_surface
// Number: 124
// Type: instance
// Author: MVK
// Depends: VK_KHR_surface
// Platform: macos
// Supported: supported
// Deprecated by: VK_EXT_metal_surface
// Unlocks:
//         Enum:
//             Name: VK_MVK_MACOS_SURFACE_SPEC_VERSION
//             Negative: false
//             Value: 3
//         Enum:
//             Name: VK_MVK_MACOS_SURFACE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_MVK_macos_surface&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkMacOSSurfaceCreateFlagsMVK
//         Type:
//             Name: VkMacOSSurfaceCreateInfoMVK
//         Command:
//             Name: vkCreateMacOSSurfaceMVK
pub const VK_MVK_moltenvk_name = "VK_MVK_moltenvk";
// Extension: VK_MVK_moltenvk
// Number: 125
// Type: instance
// Author: MVK
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_MVK_MOLTENVK_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_MVK_MOLTENVK_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_MVK_moltenvk&quot;
pub const VK_EXT_external_memory_dma_buf_name = "VK_EXT_external_memory_dma_buf";
// Extension: VK_EXT_external_memory_dma_buf
// Number: 126
// Type: device
// Author: EXT
// Depends: VK_KHR_external_memory_fd
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTERNAL_MEMORY_DMA_BUF_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_EXTERNAL_MEMORY_DMA_BUF_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_external_memory_dma_buf&quot;
//         Enum:
//             Name: VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT
//             Negative: false
//             Bitpos: 9
//             Extends: VkExternalMemoryHandleTypeFlagBits
pub const VK_EXT_queue_family_foreign_name = "VK_EXT_queue_family_foreign";
// Extension: VK_EXT_queue_family_foreign
// Number: 127
// Type: device
// Author: EXT
// Depends: VK_KHR_external_memory,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_QUEUE_FAMILY_FOREIGN_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_QUEUE_FAMILY_FOREIGN_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_queue_family_foreign&quot;
//         Enum:
//             Name: VK_QUEUE_FAMILY_FOREIGN_EXT
//             Negative: false
pub const VK_KHR_dedicated_allocation_name = "VK_KHR_dedicated_allocation";
// Extension: VK_KHR_dedicated_allocation
// Number: 128
// Type: device
// Author: KHR
// Depends: VK_KHR_get_memory_requirements2,VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_1
// Unlocks:
//         Enum:
//             Name: VK_KHR_DEDICATED_ALLOCATION_SPEC_VERSION
//             Negative: false
//             Value: 3
//         Enum:
//             Name: VK_KHR_DEDICATED_ALLOCATION_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_dedicated_allocation&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS
//         Enum:
//             Name: VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO
//         Type:
//             Name: VkMemoryDedicatedRequirementsKHR
//         Type:
//             Name: VkMemoryDedicatedAllocateInfoKHR
pub const VK_EXT_debug_utils_name = "VK_EXT_debug_utils";
// Extension: VK_EXT_debug_utils
// Number: 129
// Type: instance
// Author: EXT
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_DEBUG_UTILS_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_EXT_DEBUG_UTILS_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_debug_utils&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 4
//         Enum:
//             Name: VK_OBJECT_TYPE_DEBUG_UTILS_MESSENGER_EXT
//             Negative: false
//             Extends: VkObjectType
//             Offset: 0
//         Type:
//             Name: PFN_vkDebugUtilsMessengerCallbackEXT
//         Type:
//             Name: VkDebugUtilsLabelEXT
//         Type:
//             Name: VkDebugUtilsMessageSeverityFlagBitsEXT
//         Type:
//             Name: VkDebugUtilsMessageSeverityFlagsEXT
//         Type:
//             Name: VkDebugUtilsMessageTypeFlagBitsEXT
//         Type:
//             Name: VkDebugUtilsMessageTypeFlagsEXT
//         Type:
//             Name: VkDebugUtilsMessengerCallbackDataEXT
//         Type:
//             Name: VkDebugUtilsMessengerCallbackDataFlagsEXT
//         Type:
//             Name: VkDebugUtilsMessengerCreateFlagsEXT
//         Type:
//             Name: VkDebugUtilsMessengerCreateInfoEXT
//         Type:
//             Name: VkDebugUtilsMessengerEXT
//         Type:
//             Name: VkDebugUtilsObjectNameInfoEXT
//         Type:
//             Name: VkDebugUtilsObjectTagInfoEXT
//         Command:
//             Name: vkSetDebugUtilsObjectNameEXT
//         Command:
//             Name: vkSetDebugUtilsObjectTagEXT
//         Command:
//             Name: vkQueueBeginDebugUtilsLabelEXT
//         Command:
//             Name: vkQueueEndDebugUtilsLabelEXT
//         Command:
//             Name: vkQueueInsertDebugUtilsLabelEXT
//         Command:
//             Name: vkCmdBeginDebugUtilsLabelEXT
//         Command:
//             Name: vkCmdEndDebugUtilsLabelEXT
//         Command:
//             Name: vkCmdInsertDebugUtilsLabelEXT
//         Command:
//             Name: vkCreateDebugUtilsMessengerEXT
//         Command:
//             Name: vkDestroyDebugUtilsMessengerEXT
//         Command:
//             Name: vkSubmitDebugUtilsMessageEXT
pub const VK_ANDROID_external_memory_android_hardware_buffer_name = "VK_ANDROID_external_memory_android_hardware_buffer";
// Extension: VK_ANDROID_external_memory_android_hardware_buffer
// Number: 130
// Type: device
// Author: ANDROID
// Depends: ((VK_KHR_sampler_ycbcr_conversion+VK_KHR_external_memory+VK_KHR_dedicated_allocation),VK_VERSION_1_1)+VK_EXT_queue_family_foreign
// Platform: android
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_SPEC_VERSION
//             Negative: false
//             Value: 5
//         Enum:
//             Name: VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_ANDROID_external_memory_android_hardware_buffer&quot;
//         Enum:
//             Name: VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID
//             Negative: false
//             Bitpos: 10
//             Extends: VkExternalMemoryHandleTypeFlagBits
//         Enum:
//             Name: VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Enum:
//             Name: VK_STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID
//             Negative: false
//             Extends: VkStructureType
//             Offset: 4
//         Enum:
//             Name: VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID
//             Negative: false
//             Extends: VkStructureType
//             Offset: 5
//         Type:
//             Name: VkAndroidHardwareBufferUsageANDROID
//         Type:
//             Name: VkAndroidHardwareBufferPropertiesANDROID
//         Type:
//             Name: VkAndroidHardwareBufferFormatPropertiesANDROID
//         Type:
//             Name: VkImportAndroidHardwareBufferInfoANDROID
//         Type:
//             Name: VkMemoryGetAndroidHardwareBufferInfoANDROID
//         Type:
//             Name: VkExternalFormatANDROID
//         Command:
//             Name: vkGetAndroidHardwareBufferPropertiesANDROID
//         Command:
//             Name: vkGetMemoryAndroidHardwareBufferANDROID
//         Type:
//             Name: AHardwareBuffer
//     Depends: VK_KHR_format_feature_flags2,VK_VERSION_1_3
//         Type:
//             Name: VkAndroidHardwareBufferFormatProperties2ANDROID
//         Enum:
//             Name: VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_2_ANDROID
//             Negative: false
//             Extends: VkStructureType
//             Offset: 6
pub const VK_EXT_sampler_filter_minmax_name = "VK_EXT_sampler_filter_minmax";
// Extension: VK_EXT_sampler_filter_minmax
// Number: 131
// Type: device
// Author: NV
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_2
// Unlocks:
//         Enum:
//             Name: VK_EXT_SAMPLER_FILTER_MINMAX_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_EXT_SAMPLER_FILTER_MINMAX_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_sampler_filter_minmax&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO
//         Enum:
//             Name: VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT_EXT
//             Negative: false
//             Extends: VkFormatFeatureFlagBits
//             Alias: VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT
//         Enum:
//             Name: VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_EXT
//             Negative: false
//             Extends: VkSamplerReductionMode
//             Alias: VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE
//         Enum:
//             Name: VK_SAMPLER_REDUCTION_MODE_MIN_EXT
//             Negative: false
//             Extends: VkSamplerReductionMode
//             Alias: VK_SAMPLER_REDUCTION_MODE_MIN
//         Enum:
//             Name: VK_SAMPLER_REDUCTION_MODE_MAX_EXT
//             Negative: false
//             Extends: VkSamplerReductionMode
//             Alias: VK_SAMPLER_REDUCTION_MODE_MAX
//         Type:
//             Name: VkSamplerReductionModeEXT
//         Type:
//             Name: VkSamplerReductionModeCreateInfoEXT
//         Type:
//             Name: VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT
pub const VK_KHR_storage_buffer_storage_class_name = "VK_KHR_storage_buffer_storage_class";
// Extension: VK_KHR_storage_buffer_storage_class
// Number: 132
// Type: device
// Author: KHR
// Supported: supported
// Promoted to: VK_VERSION_1_1
// Unlocks:
//         Enum:
//             Name: VK_KHR_STORAGE_BUFFER_STORAGE_CLASS_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_STORAGE_BUFFER_STORAGE_CLASS_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_storage_buffer_storage_class&quot;
pub const VK_AMD_gpu_shader_int16_name = "VK_AMD_gpu_shader_int16";
// Extension: VK_AMD_gpu_shader_int16
// Number: 133
// Type: device
// Author: AMD
// Supported: supported
// Deprecated by: VK_KHR_shader_float16_int8
// Unlocks:
//         Enum:
//             Name: VK_AMD_GPU_SHADER_INT16_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_AMD_GPU_SHADER_INT16_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_gpu_shader_int16&quot;
pub const VK_AMD_extension_134_name = "VK_AMD_extension_134";
// Extension: VK_AMD_extension_134
// Number: 134
// Type: invalid
// Author: AMD
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_AMD_EXTENSION_134_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_AMD_EXTENSION_134_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_extension_134&quot;
pub const VK_AMDX_shader_enqueue_name = "VK_AMDX_shader_enqueue";
// Extension: VK_AMDX_shader_enqueue
// Number: 135
// Type: device
// Author: AMD
// Depends: ((VK_KHR_synchronization2+VK_KHR_spirv_1_4+VK_EXT_extended_dynamic_state),VK_VERSION_1_3)+VK_KHR_maintenance5+VK_KHR_pipeline_library
// Platform: provisional
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_AMDX_SHADER_ENQUEUE_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_AMDX_SHADER_ENQUEUE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMDX_shader_enqueue&quot;
//         Enum:
//             Name: VK_SHADER_INDEX_UNUSED_AMDX
//             Negative: false
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ENQUEUE_FEATURES_AMDX
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ENQUEUE_PROPERTIES_AMDX
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_EXECUTION_GRAPH_PIPELINE_SCRATCH_SIZE_AMDX
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_EXECUTION_GRAPH_PIPELINE_CREATE_INFO_AMDX
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_NODE_CREATE_INFO_AMDX
//             Negative: false
//             Extends: VkStructureType
//             Offset: 4
//         Enum:
//             Name: VK_BUFFER_USAGE_EXECUTION_GRAPH_SCRATCH_BIT_AMDX
//             Negative: false
//             Bitpos: 25
//             Extends: VkBufferUsageFlagBits
//         Enum:
//             Name: VK_PIPELINE_BIND_POINT_EXECUTION_GRAPH_AMDX
//             Negative: false
//             Extends: VkPipelineBindPoint
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceShaderEnqueueFeaturesAMDX
//         Type:
//             Name: VkPhysicalDeviceShaderEnqueuePropertiesAMDX
//         Type:
//             Name: VkExecutionGraphPipelineScratchSizeAMDX
//         Type:
//             Name: VkExecutionGraphPipelineCreateInfoAMDX
//         Type:
//             Name: VkDispatchGraphInfoAMDX
//         Type:
//             Name: VkDispatchGraphCountInfoAMDX
//         Type:
//             Name: VkPipelineShaderStageNodeCreateInfoAMDX
//         Type:
//             Name: VkDeviceOrHostAddressConstAMDX
//         Command:
//             Name: vkCreateExecutionGraphPipelinesAMDX
//         Command:
//             Name: vkGetExecutionGraphPipelineScratchSizeAMDX
//         Command:
//             Name: vkGetExecutionGraphPipelineNodeIndexAMDX
//         Command:
//             Name: vkCmdInitializeGraphScratchMemoryAMDX
//         Command:
//             Name: vkCmdDispatchGraphAMDX
//         Command:
//             Name: vkCmdDispatchGraphIndirectAMDX
//         Command:
//             Name: vkCmdDispatchGraphIndirectCountAMDX
//         Feature:
//             Name: shaderEnqueue
//             Struct: VkPhysicalDeviceShaderEnqueueFeaturesAMDX
//     Depends: VK_KHR_maintenance5,VK_VERSION_1_4
//         Enum:
//             Name: VK_BUFFER_USAGE_2_EXECUTION_GRAPH_SCRATCH_BIT_AMDX
//             Negative: false
//             Bitpos: 25
//             Extends: VkBufferUsageFlagBits2
//         Enum:
//             Name: VK_PIPELINE_CREATE_2_EXECUTION_GRAPH_BIT_AMDX
//             Negative: false
//             Bitpos: 32
//             Extends: VkPipelineCreateFlagBits2
//     Depends: VK_EXT_mesh_shader
//         Feature:
//             Name: shaderMeshEnqueue
//             Struct: VkPhysicalDeviceShaderEnqueueFeaturesAMDX
pub const VK_KHR_extension_136_name = "VK_KHR_extension_136";
// Extension: VK_KHR_extension_136
// Number: 136
// Type: device
// Author: KHR
// Depends: VK_KHR_maintenance5
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_KHR_EXTENSION_136_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_KHR_EXTENSION_136_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_extension_136&quot;
//         Enum:
//             Name: VK_BUFFER_USAGE_RESERVED_28_BIT_KHR
//             Negative: false
//             Bitpos: 28
//             Extends: VkBufferUsageFlagBits
//         Enum:
//             Name: VK_PIPELINE_CREATE_RESERVED_36_BIT_KHR
//             Negative: false
//             Bitpos: 36
//             Extends: VkPipelineCreateFlagBits2
//         Enum:
//             Name: VK_PIPELINE_CREATE_RESERVED_39_BIT_KHR
//             Negative: false
//             Bitpos: 39
//             Extends: VkPipelineCreateFlagBits2
//         Enum:
//             Name: VK_ACCESS_2_RESERVED_57_BIT_KHR
//             Negative: false
//             Bitpos: 57
//             Extends: VkAccessFlagBits2
//         Enum:
//             Name: VK_ACCESS_2_RESERVED_58_BIT_KHR
//             Negative: false
//             Bitpos: 58
//             Extends: VkAccessFlagBits2
//         Enum:
//             Name: VK_ACCESS_2_RESERVED_59_BIT_KHR
//             Negative: false
//             Bitpos: 59
//             Extends: VkAccessFlagBits2
//     Depends: VK_KHR_maintenance5,VK_VERSION_1_4
//         Enum:
//             Name: VK_BUFFER_USAGE_2_RESERVED_28_BIT_KHR
//             Negative: false
//             Bitpos: 28
//             Extends: VkBufferUsageFlagBits2
//     Depends: VK_EXT_shader_object
//         Enum:
//             Name: VK_SHADER_CREATE_RESERVED_10_BIT_KHR
//             Negative: false
//             Bitpos: 10
//             Extends: VkShaderCreateFlagBitsEXT
//         Enum:
//             Name: VK_SHADER_CREATE_RESERVED_11_BIT_KHR
//             Negative: false
//             Bitpos: 11
//             Extends: VkShaderCreateFlagBitsEXT
//     Depends: VK_ARM_tensors
//         Enum:
//             Name: VK_TENSOR_CREATE_RESERVED_3_BIT_ARM
//             Negative: false
//             Bitpos: 3
//             Extends: VkTensorCreateFlagBitsARM
pub const VK_AMD_mixed_attachment_samples_name = "VK_AMD_mixed_attachment_samples";
// Extension: VK_AMD_mixed_attachment_samples
// Number: 137
// Type: device
// Author: AMD
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_AMD_MIXED_ATTACHMENT_SAMPLES_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_AMD_MIXED_ATTACHMENT_SAMPLES_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_mixed_attachment_samples&quot;
//     Depends: VK_VERSION_1_3,VK_KHR_dynamic_rendering
//         Enum:
//             Name: VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD
//             Negative: false
//             Extends: VkStructureType
//             Extnumber: 45
//             Offset: 8
//         Type:
//             Name: VkAttachmentSampleCountInfoAMD
pub const VK_AMD_shader_fragment_mask_name = "VK_AMD_shader_fragment_mask";
// Extension: VK_AMD_shader_fragment_mask
// Number: 138
// Type: device
// Author: AMD
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_AMD_SHADER_FRAGMENT_MASK_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_AMD_SHADER_FRAGMENT_MASK_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_shader_fragment_mask&quot;
pub const VK_EXT_inline_uniform_block_name = "VK_EXT_inline_uniform_block";
// Extension: VK_EXT_inline_uniform_block
// Number: 139
// Type: device
// Author: EXT
// Depends: (VK_KHR_get_physical_device_properties2+VK_KHR_maintenance1),VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_3
// Unlocks:
//         Enum:
//             Name: VK_EXT_INLINE_UNIFORM_BLOCK_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_INLINE_UNIFORM_BLOCK_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_inline_uniform_block&quot;
//         Enum:
//             Name: VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT
//             Negative: false
//             Extends: VkDescriptorType
//             Alias: VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES
//         Enum:
//             Name: VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO
//         Type:
//             Name: VkPhysicalDeviceInlineUniformBlockFeaturesEXT
//         Type:
//             Name: VkPhysicalDeviceInlineUniformBlockPropertiesEXT
//         Type:
//             Name: VkWriteDescriptorSetInlineUniformBlockEXT
//         Type:
//             Name: VkDescriptorPoolInlineUniformBlockCreateInfoEXT
//         Feature:
//             Name: inlineUniformBlock
//             Struct: VkPhysicalDeviceInlineUniformBlockFeaturesEXT
//     Depends: VK_EXT_descriptor_indexing
//         Feature:
//             Name: descriptorBindingInlineUniformBlockUpdateAfterBind
//             Struct: VkPhysicalDeviceInlineUniformBlockFeatures
//     Depends: VK_VERSION_1_2+VkPhysicalDeviceVulkan12Features::descriptorIndexing
//         Feature:
//             Name: descriptorBindingInlineUniformBlockUpdateAfterBind
//             Struct: VkPhysicalDeviceInlineUniformBlockFeatures
pub const VK_AMD_extension_140_name = "VK_AMD_extension_140";
// Extension: VK_AMD_extension_140
// Number: 140
// Type: invalid
// Author: AMD
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_AMD_EXTENSION_140_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_AMD_EXTENSION_140_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_extension_140&quot;
pub const VK_EXT_shader_stencil_export_name = "VK_EXT_shader_stencil_export";
// Extension: VK_EXT_shader_stencil_export
// Number: 141
// Type: device
// Author: EXT
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_SHADER_STENCIL_EXPORT_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_SHADER_STENCIL_EXPORT_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_shader_stencil_export&quot;
pub const VK_KHR_shader_bfloat16_name = "VK_KHR_shader_bfloat16";
// Extension: VK_KHR_shader_bfloat16
// Number: 142
// Type: device
// Author: KHR
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_SHADER_BFLOAT16_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_SHADER_BFLOAT16_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_shader_bfloat16&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_BFLOAT16_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceShaderBfloat16FeaturesKHR
//         Feature:
//             Name: shaderBFloat16Type
//             Struct: VkPhysicalDeviceShaderBfloat16FeaturesKHR
//         Feature:
//             Name: shaderBFloat16CooperativeMatrix,shaderBFloat16DotProduct
//             Struct: VkPhysicalDeviceShaderBfloat16FeaturesKHR
//     Depends: VK_KHR_cooperative_matrix
//         Enum:
//             Name: VK_COMPONENT_TYPE_BFLOAT16_KHR
//             Negative: false
//             Extends: VkComponentTypeKHR
//             Offset: 0
pub const VK_AMD_extension_143_name = "VK_AMD_extension_143";
// Extension: VK_AMD_extension_143
// Number: 143
// Type: invalid
// Author: AMD
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_AMD_EXTENSION_143_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_AMD_EXTENSION_143_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_extension_143&quot;
pub const VK_EXT_sample_locations_name = "VK_EXT_sample_locations";
// Extension: VK_EXT_sample_locations
// Number: 144
// Type: device
// Author: AMD
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_SAMPLE_LOCATIONS_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_SAMPLE_LOCATIONS_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_sample_locations&quot;
//         Enum:
//             Name: VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT
//             Negative: false
//             Bitpos: 12
//             Extends: VkImageCreateFlagBits
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Enum:
//             Name: VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 4
//         Enum:
//             Name: VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT
//             Negative: false
//             Extends: VkDynamicState
//             Offset: 0
//         Type:
//             Name: VkSampleLocationEXT
//         Type:
//             Name: VkSampleLocationsInfoEXT
//         Type:
//             Name: VkAttachmentSampleLocationsEXT
//         Type:
//             Name: VkSubpassSampleLocationsEXT
//         Type:
//             Name: VkRenderPassSampleLocationsBeginInfoEXT
//         Type:
//             Name: VkPipelineSampleLocationsStateCreateInfoEXT
//         Type:
//             Name: VkPhysicalDeviceSampleLocationsPropertiesEXT
//         Type:
//             Name: VkMultisamplePropertiesEXT
//         Command:
//             Name: vkCmdSetSampleLocationsEXT
//         Command:
//             Name: vkGetPhysicalDeviceMultisamplePropertiesEXT
pub const VK_KHR_relaxed_block_layout_name = "VK_KHR_relaxed_block_layout";
// Extension: VK_KHR_relaxed_block_layout
// Number: 145
// Type: device
// Author: KHR
// Supported: supported
// Promoted to: VK_VERSION_1_1
// Unlocks:
//         Enum:
//             Name: VK_KHR_RELAXED_BLOCK_LAYOUT_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_RELAXED_BLOCK_LAYOUT_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_relaxed_block_layout&quot;
pub const VK_RESERVED_do_not_use_146_name = "VK_RESERVED_do_not_use_146";
// Extension: VK_RESERVED_do_not_use_146
// Number: 146
// Type: invalid
// Supported: disabled
// Comment:
//     Used for functionality subsumed into Vulkan 1.1 and not published as an extension
// Unlocks:
//         Enum:
//             Name: VK_RESERVED_DO_NOT_USE_146_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_RESERVED_DO_NOT_USE_146_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_RESERVED_do_not_use_146&quot;
pub const VK_KHR_get_memory_requirements2_name = "VK_KHR_get_memory_requirements2";
// Extension: VK_KHR_get_memory_requirements2
// Number: 147
// Type: device
// Author: KHR
// Supported: supported
// Promoted to: VK_VERSION_1_1
// Unlocks:
//         Enum:
//             Name: VK_KHR_GET_MEMORY_REQUIREMENTS_2_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_GET_MEMORY_REQUIREMENTS_2_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_get_memory_requirements2&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2
//         Type:
//             Name: VkBufferMemoryRequirementsInfo2KHR
//         Type:
//             Name: VkImageMemoryRequirementsInfo2KHR
//         Type:
//             Name: VkImageSparseMemoryRequirementsInfo2KHR
//         Type:
//             Name: VkMemoryRequirements2KHR
//         Type:
//             Name: VkSparseImageMemoryRequirements2KHR
//         Command:
//             Name: vkGetImageMemoryRequirements2KHR
//         Command:
//             Name: vkGetBufferMemoryRequirements2KHR
//         Command:
//             Name: vkGetImageSparseMemoryRequirements2KHR
pub const VK_KHR_image_format_list_name = "VK_KHR_image_format_list";
// Extension: VK_KHR_image_format_list
// Number: 148
// Type: device
// Author: KHR
// Supported: supported
// Promoted to: VK_VERSION_1_2
// Unlocks:
//         Enum:
//             Name: VK_KHR_IMAGE_FORMAT_LIST_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_IMAGE_FORMAT_LIST_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_image_format_list&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO
//         Type:
//             Name: VkImageFormatListCreateInfoKHR
pub const VK_EXT_blend_operation_advanced_name = "VK_EXT_blend_operation_advanced";
// Extension: VK_EXT_blend_operation_advanced
// Number: 149
// Type: device
// Author: NV
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_BLEND_OPERATION_ADVANCED_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_EXT_BLEND_OPERATION_ADVANCED_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_blend_operation_advanced&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Type:
//             Name: VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT
//         Type:
//             Name: VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT
//         Type:
//             Name: VkPipelineColorBlendAdvancedStateCreateInfoEXT
//         Type:
//             Name: VkBlendOverlapEXT
//         Enum:
//             Name: VK_BLEND_OP_ZERO_EXT
//             Negative: false
//             Extends: VkBlendOp
//             Offset: 0
//         Enum:
//             Name: VK_BLEND_OP_SRC_EXT
//             Negative: false
//             Extends: VkBlendOp
//             Offset: 1
//         Enum:
//             Name: VK_BLEND_OP_DST_EXT
//             Negative: false
//             Extends: VkBlendOp
//             Offset: 2
//         Enum:
//             Name: VK_BLEND_OP_SRC_OVER_EXT
//             Negative: false
//             Extends: VkBlendOp
//             Offset: 3
//         Enum:
//             Name: VK_BLEND_OP_DST_OVER_EXT
//             Negative: false
//             Extends: VkBlendOp
//             Offset: 4
//         Enum:
//             Name: VK_BLEND_OP_SRC_IN_EXT
//             Negative: false
//             Extends: VkBlendOp
//             Offset: 5
//         Enum:
//             Name: VK_BLEND_OP_DST_IN_EXT
//             Negative: false
//             Extends: VkBlendOp
//             Offset: 6
//         Enum:
//             Name: VK_BLEND_OP_SRC_OUT_EXT
//             Negative: false
//             Extends: VkBlendOp
//             Offset: 7
//         Enum:
//             Name: VK_BLEND_OP_DST_OUT_EXT
//             Negative: false
//             Extends: VkBlendOp
//             Offset: 8
//         Enum:
//             Name: VK_BLEND_OP_SRC_ATOP_EXT
//             Negative: false
//             Extends: VkBlendOp
//             Offset: 9
//         Enum:
//             Name: VK_BLEND_OP_DST_ATOP_EXT
//             Negative: false
//             Extends: VkBlendOp
//             Offset: 10
//         Enum:
//             Name: VK_BLEND_OP_XOR_EXT
//             Negative: false
//             Extends: VkBlendOp
//             Offset: 11
//         Enum:
//             Name: VK_BLEND_OP_MULTIPLY_EXT
//             Negative: false
//             Extends: VkBlendOp
//             Offset: 12
//         Enum:
//             Name: VK_BLEND_OP_SCREEN_EXT
//             Negative: false
//             Extends: VkBlendOp
//             Offset: 13
//         Enum:
//             Name: VK_BLEND_OP_OVERLAY_EXT
//             Negative: false
//             Extends: VkBlendOp
//             Offset: 14
//         Enum:
//             Name: VK_BLEND_OP_DARKEN_EXT
//             Negative: false
//             Extends: VkBlendOp
//             Offset: 15
//         Enum:
//             Name: VK_BLEND_OP_LIGHTEN_EXT
//             Negative: false
//             Extends: VkBlendOp
//             Offset: 16
//         Enum:
//             Name: VK_BLEND_OP_COLORDODGE_EXT
//             Negative: false
//             Extends: VkBlendOp
//             Offset: 17
//         Enum:
//             Name: VK_BLEND_OP_COLORBURN_EXT
//             Negative: false
//             Extends: VkBlendOp
//             Offset: 18
//         Enum:
//             Name: VK_BLEND_OP_HARDLIGHT_EXT
//             Negative: false
//             Extends: VkBlendOp
//             Offset: 19
//         Enum:
//             Name: VK_BLEND_OP_SOFTLIGHT_EXT
//             Negative: false
//             Extends: VkBlendOp
//             Offset: 20
//         Enum:
//             Name: VK_BLEND_OP_DIFFERENCE_EXT
//             Negative: false
//             Extends: VkBlendOp
//             Offset: 21
//         Enum:
//             Name: VK_BLEND_OP_EXCLUSION_EXT
//             Negative: false
//             Extends: VkBlendOp
//             Offset: 22
//         Enum:
//             Name: VK_BLEND_OP_INVERT_EXT
//             Negative: false
//             Extends: VkBlendOp
//             Offset: 23
//         Enum:
//             Name: VK_BLEND_OP_INVERT_RGB_EXT
//             Negative: false
//             Extends: VkBlendOp
//             Offset: 24
//         Enum:
//             Name: VK_BLEND_OP_LINEARDODGE_EXT
//             Negative: false
//             Extends: VkBlendOp
//             Offset: 25
//         Enum:
//             Name: VK_BLEND_OP_LINEARBURN_EXT
//             Negative: false
//             Extends: VkBlendOp
//             Offset: 26
//         Enum:
//             Name: VK_BLEND_OP_VIVIDLIGHT_EXT
//             Negative: false
//             Extends: VkBlendOp
//             Offset: 27
//         Enum:
//             Name: VK_BLEND_OP_LINEARLIGHT_EXT
//             Negative: false
//             Extends: VkBlendOp
//             Offset: 28
//         Enum:
//             Name: VK_BLEND_OP_PINLIGHT_EXT
//             Negative: false
//             Extends: VkBlendOp
//             Offset: 29
//         Enum:
//             Name: VK_BLEND_OP_HARDMIX_EXT
//             Negative: false
//             Extends: VkBlendOp
//             Offset: 30
//         Enum:
//             Name: VK_BLEND_OP_HSL_HUE_EXT
//             Negative: false
//             Extends: VkBlendOp
//             Offset: 31
//         Enum:
//             Name: VK_BLEND_OP_HSL_SATURATION_EXT
//             Negative: false
//             Extends: VkBlendOp
//             Offset: 32
//         Enum:
//             Name: VK_BLEND_OP_HSL_COLOR_EXT
//             Negative: false
//             Extends: VkBlendOp
//             Offset: 33
//         Enum:
//             Name: VK_BLEND_OP_HSL_LUMINOSITY_EXT
//             Negative: false
//             Extends: VkBlendOp
//             Offset: 34
//         Enum:
//             Name: VK_BLEND_OP_PLUS_EXT
//             Negative: false
//             Extends: VkBlendOp
//             Offset: 35
//         Enum:
//             Name: VK_BLEND_OP_PLUS_CLAMPED_EXT
//             Negative: false
//             Extends: VkBlendOp
//             Offset: 36
//         Enum:
//             Name: VK_BLEND_OP_PLUS_CLAMPED_ALPHA_EXT
//             Negative: false
//             Extends: VkBlendOp
//             Offset: 37
//         Enum:
//             Name: VK_BLEND_OP_PLUS_DARKER_EXT
//             Negative: false
//             Extends: VkBlendOp
//             Offset: 38
//         Enum:
//             Name: VK_BLEND_OP_MINUS_EXT
//             Negative: false
//             Extends: VkBlendOp
//             Offset: 39
//         Enum:
//             Name: VK_BLEND_OP_MINUS_CLAMPED_EXT
//             Negative: false
//             Extends: VkBlendOp
//             Offset: 40
//         Enum:
//             Name: VK_BLEND_OP_CONTRAST_EXT
//             Negative: false
//             Extends: VkBlendOp
//             Offset: 41
//         Enum:
//             Name: VK_BLEND_OP_INVERT_OVG_EXT
//             Negative: false
//             Extends: VkBlendOp
//             Offset: 42
//         Enum:
//             Name: VK_BLEND_OP_RED_EXT
//             Negative: false
//             Extends: VkBlendOp
//             Offset: 43
//         Enum:
//             Name: VK_BLEND_OP_GREEN_EXT
//             Negative: false
//             Extends: VkBlendOp
//             Offset: 44
//         Enum:
//             Name: VK_BLEND_OP_BLUE_EXT
//             Negative: false
//             Extends: VkBlendOp
//             Offset: 45
//         Enum:
//             Name: VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT
//             Negative: false
//             Bitpos: 19
//             Extends: VkAccessFlagBits
pub const VK_NV_fragment_coverage_to_color_name = "VK_NV_fragment_coverage_to_color";
// Extension: VK_NV_fragment_coverage_to_color
// Number: 150
// Type: device
// Author: NV
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NV_FRAGMENT_COVERAGE_TO_COLOR_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_NV_FRAGMENT_COVERAGE_TO_COLOR_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_fragment_coverage_to_color&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPipelineCoverageToColorStateCreateFlagsNV
//         Type:
//             Name: VkPipelineCoverageToColorStateCreateInfoNV
pub const VK_KHR_acceleration_structure_name = "VK_KHR_acceleration_structure";
// Extension: VK_KHR_acceleration_structure
// Number: 151
// Type: device
// Author: KHR
// Depends: ((VK_VERSION_1_1+VK_EXT_descriptor_indexing+VK_KHR_buffer_device_address),VK_VERSION_1_2)+VK_KHR_deferred_host_operations
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_ACCELERATION_STRUCTURE_SPEC_VERSION
//             Negative: false
//             Value: 13
//         Enum:
//             Name: VK_KHR_ACCELERATION_STRUCTURE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_acceleration_structure&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 7
//         Enum:
//             Name: VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_AABBS_DATA_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Enum:
//             Name: VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 4
//         Enum:
//             Name: VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 5
//         Enum:
//             Name: VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 6
//         Enum:
//             Name: VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_VERSION_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 9
//         Enum:
//             Name: VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 10
//         Enum:
//             Name: VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 11
//         Enum:
//             Name: VK_STRUCTURE_TYPE_COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 12
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 13
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 14
//         Enum:
//             Name: VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 17
//         Enum:
//             Name: VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 20
//         Enum:
//             Name: VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR
//             Negative: false
//             Bitpos: 25
//             Extends: VkPipelineStageFlagBits
//         Enum:
//             Name: VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR
//             Negative: false
//             Extends: VkDescriptorType
//             Offset: 0
//         Enum:
//             Name: VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR
//             Negative: false
//             Bitpos: 21
//             Extends: VkAccessFlagBits
//         Enum:
//             Name: VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_KHR
//             Negative: false
//             Bitpos: 22
//             Extends: VkAccessFlagBits
//         Enum:
//             Name: VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_KHR
//             Negative: false
//             Extends: VkQueryType
//             Offset: 0
//         Enum:
//             Name: VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_SIZE_KHR
//             Negative: false
//             Extends: VkQueryType
//             Offset: 1
//         Enum:
//             Name: VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_KHR
//             Negative: false
//             Extends: VkObjectType
//             Offset: 0
//         Enum:
//             Name: VK_INDEX_TYPE_NONE_KHR
//             Negative: false
//             Extends: VkIndexType
//             Extnumber: 166
//             Offset: 0
//         Enum:
//             Name: VK_FORMAT_FEATURE_ACCELERATION_STRUCTURE_VERTEX_BUFFER_BIT_KHR
//             Negative: false
//             Bitpos: 29
//             Extends: VkFormatFeatureFlagBits
//         Enum:
//             Name: VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR
//             Negative: false
//             Bitpos: 19
//             Extends: VkBufferUsageFlagBits
//         Enum:
//             Name: VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR
//             Negative: false
//             Bitpos: 20
//             Extends: VkBufferUsageFlagBits
//         Enum:
//             Name: VK_COPY_ACCELERATION_STRUCTURE_MODE_SERIALIZE_KHR
//             Negative: false
//             Value: 2
//             Extends: VkCopyAccelerationStructureModeKHR
//         Enum:
//             Name: VK_COPY_ACCELERATION_STRUCTURE_MODE_DESERIALIZE_KHR
//             Negative: false
//             Value: 3
//             Extends: VkCopyAccelerationStructureModeKHR
//         Type:
//             Name: VkAccelerationStructureTypeKHR
//         Type:
//             Name: VkDeviceOrHostAddressKHR
//         Type:
//             Name: VkDeviceOrHostAddressConstKHR
//         Type:
//             Name: VkAccelerationStructureBuildRangeInfoKHR
//         Type:
//             Name: VkAabbPositionsKHR
//         Type:
//             Name: VkAccelerationStructureGeometryTrianglesDataKHR
//         Type:
//             Name: VkTransformMatrixKHR
//         Type:
//             Name: VkAccelerationStructureBuildGeometryInfoKHR
//         Type:
//             Name: VkAccelerationStructureBuildTypeKHR
//         Type:
//             Name: VkAccelerationStructureGeometryAabbsDataKHR
//         Type:
//             Name: VkAccelerationStructureInstanceKHR
//         Type:
//             Name: VkAccelerationStructureGeometryInstancesDataKHR
//         Type:
//             Name: VkAccelerationStructureGeometryDataKHR
//         Type:
//             Name: VkAccelerationStructureGeometryKHR
//         Type:
//             Name: VkGeometryFlagsKHR
//         Type:
//             Name: VkGeometryInstanceFlagsKHR
//         Type:
//             Name: VkGeometryFlagBitsKHR
//         Type:
//             Name: VkGeometryInstanceFlagBitsKHR
//         Type:
//             Name: VkAccelerationStructureCreateInfoKHR
//         Type:
//             Name: VkAccelerationStructureKHR
//         Type:
//             Name: VkBuildAccelerationStructureFlagBitsKHR
//         Type:
//             Name: VkBuildAccelerationStructureFlagsKHR
//         Type:
//             Name: VkCopyAccelerationStructureModeKHR
//         Type:
//             Name: VkGeometryTypeKHR
//         Type:
//             Name: VkWriteDescriptorSetAccelerationStructureKHR
//         Type:
//             Name: VkPhysicalDeviceAccelerationStructureFeaturesKHR
//         Type:
//             Name: VkPhysicalDeviceAccelerationStructurePropertiesKHR
//         Type:
//             Name: VkAccelerationStructureDeviceAddressInfoKHR
//         Type:
//             Name: VkAccelerationStructureVersionInfoKHR
//         Type:
//             Name: VkCopyAccelerationStructureToMemoryInfoKHR
//         Type:
//             Name: VkCopyMemoryToAccelerationStructureInfoKHR
//         Type:
//             Name: VkCopyAccelerationStructureInfoKHR
//         Type:
//             Name: VkAccelerationStructureCompatibilityKHR
//         Type:
//             Name: VkAccelerationStructureCreateFlagBitsKHR
//         Type:
//             Name: VkAccelerationStructureCreateFlagsKHR
//         Type:
//             Name: VkBuildAccelerationStructureModeKHR
//         Type:
//             Name: VkAccelerationStructureBuildSizesInfoKHR
//         Command:
//             Name: vkCreateAccelerationStructureKHR
//         Command:
//             Name: vkDestroyAccelerationStructureKHR
//         Command:
//             Name: vkCmdBuildAccelerationStructuresKHR
//         Command:
//             Name: vkCmdBuildAccelerationStructuresIndirectKHR
//         Command:
//             Name: vkBuildAccelerationStructuresKHR
//         Command:
//             Name: vkCopyAccelerationStructureKHR
//         Command:
//             Name: vkCopyAccelerationStructureToMemoryKHR
//         Command:
//             Name: vkCopyMemoryToAccelerationStructureKHR
//         Command:
//             Name: vkWriteAccelerationStructuresPropertiesKHR
//         Command:
//             Name: vkCmdCopyAccelerationStructureKHR
//         Command:
//             Name: vkCmdCopyAccelerationStructureToMemoryKHR
//         Command:
//             Name: vkCmdCopyMemoryToAccelerationStructureKHR
//         Command:
//             Name: vkGetAccelerationStructureDeviceAddressKHR
//         Command:
//             Name: vkCmdWriteAccelerationStructuresPropertiesKHR
//         Command:
//             Name: vkGetDeviceAccelerationStructureCompatibilityKHR
//         Command:
//             Name: vkGetAccelerationStructureBuildSizesKHR
//         Feature:
//             Name: accelerationStructure
//             Struct: VkPhysicalDeviceAccelerationStructureFeaturesKHR
//         Feature:
//             Name: bufferDeviceAddress
//             Struct: VkPhysicalDeviceBufferDeviceAddressFeatures
//         Feature:
//             Name: descriptorBindingAccelerationStructureUpdateAfterBind
//             Struct: VkPhysicalDeviceAccelerationStructureFeaturesKHR
//     Depends: VK_KHR_format_feature_flags2,VK_VERSION_1_3
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_ACCELERATION_STRUCTURE_VERTEX_BUFFER_BIT_KHR
//             Negative: false
//             Bitpos: 29
//             Extends: VkFormatFeatureFlagBits2
//     Depends: VK_EXT_debug_report
//         Enum:
//             Name: VK_DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_KHR_EXT
//             Negative: false
//             Extends: VkDebugReportObjectTypeEXT
//             Offset: 0
//     Depends: VK_VERSION_1_2
//         Feature:
//             Name: descriptorIndexing
//             Struct: VkPhysicalDeviceVulkan12Features
pub const VK_KHR_ray_tracing_pipeline_name = "VK_KHR_ray_tracing_pipeline";
// Extension: VK_KHR_ray_tracing_pipeline
// Number: 348
// Type: device
// Author: KHR
// Depends: (VK_KHR_spirv_1_4,VK_VERSION_1_2)+VK_KHR_acceleration_structure
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_RAY_TRACING_PIPELINE_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_RAY_TRACING_PIPELINE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_ray_tracing_pipeline&quot;
//         Enum:
//             Name: VK_SHADER_UNUSED_KHR
//             Negative: false
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Extnumber: 151
//             Offset: 15
//         Enum:
//             Name: VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Extnumber: 151
//             Offset: 16
//         Enum:
//             Name: VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_INTERFACE_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Extnumber: 151
//             Offset: 18
//         Enum:
//             Name: VK_SHADER_STAGE_RAYGEN_BIT_KHR
//             Negative: false
//             Bitpos: 8
//             Extends: VkShaderStageFlagBits
//         Enum:
//             Name: VK_SHADER_STAGE_ANY_HIT_BIT_KHR
//             Negative: false
//             Bitpos: 9
//             Extends: VkShaderStageFlagBits
//         Enum:
//             Name: VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR
//             Negative: false
//             Bitpos: 10
//             Extends: VkShaderStageFlagBits
//         Enum:
//             Name: VK_SHADER_STAGE_MISS_BIT_KHR
//             Negative: false
//             Bitpos: 11
//             Extends: VkShaderStageFlagBits
//         Enum:
//             Name: VK_SHADER_STAGE_INTERSECTION_BIT_KHR
//             Negative: false
//             Bitpos: 12
//             Extends: VkShaderStageFlagBits
//         Enum:
//             Name: VK_SHADER_STAGE_CALLABLE_BIT_KHR
//             Negative: false
//             Bitpos: 13
//             Extends: VkShaderStageFlagBits
//         Enum:
//             Name: VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_KHR
//             Negative: false
//             Bitpos: 21
//             Extends: VkPipelineStageFlagBits
//         Enum:
//             Name: VK_BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR
//             Negative: false
//             Bitpos: 10
//             Extends: VkBufferUsageFlagBits
//         Enum:
//             Name: VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR
//             Negative: false
//             Extends: VkPipelineBindPoint
//             Extnumber: 166
//             Offset: 0
//         Enum:
//             Name: VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR
//             Negative: false
//             Bitpos: 14
//             Extends: VkPipelineCreateFlagBits
//         Enum:
//             Name: VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR
//             Negative: false
//             Bitpos: 15
//             Extends: VkPipelineCreateFlagBits
//         Enum:
//             Name: VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR
//             Negative: false
//             Bitpos: 16
//             Extends: VkPipelineCreateFlagBits
//         Enum:
//             Name: VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR
//             Negative: false
//             Bitpos: 17
//             Extends: VkPipelineCreateFlagBits
//         Enum:
//             Name: VK_PIPELINE_CREATE_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR
//             Negative: false
//             Bitpos: 12
//             Extends: VkPipelineCreateFlagBits
//         Enum:
//             Name: VK_PIPELINE_CREATE_RAY_TRACING_SKIP_AABBS_BIT_KHR
//             Negative: false
//             Bitpos: 13
//             Extends: VkPipelineCreateFlagBits
//         Enum:
//             Name: VK_PIPELINE_CREATE_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR
//             Negative: false
//             Bitpos: 19
//             Extends: VkPipelineCreateFlagBits
//         Enum:
//             Name: VK_DYNAMIC_STATE_RAY_TRACING_PIPELINE_STACK_SIZE_KHR
//             Negative: false
//             Extends: VkDynamicState
//             Offset: 0
//         Enum:
//             Name: VK_PIPELINE_CREATE_2_RAY_TRACING_SKIP_BUILT_IN_PRIMITIVES_BIT_KHR
//             Negative: false
//             Extends: VkPipelineCreateFlagBits2
//             Alias: VK_PIPELINE_CREATE_2_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR
//         Type:
//             Name: VkRayTracingShaderGroupCreateInfoKHR
//         Type:
//             Name: VkRayTracingShaderGroupTypeKHR
//         Type:
//             Name: VkRayTracingPipelineCreateInfoKHR
//         Type:
//             Name: VkPhysicalDeviceRayTracingPipelineFeaturesKHR
//         Type:
//             Name: VkPhysicalDeviceRayTracingPipelinePropertiesKHR
//         Type:
//             Name: VkStridedDeviceAddressRegionKHR
//         Type:
//             Name: VkTraceRaysIndirectCommandKHR
//         Type:
//             Name: VkRayTracingPipelineInterfaceCreateInfoKHR
//         Type:
//             Name: VkShaderGroupShaderKHR
//         Command:
//             Name: vkCmdTraceRaysKHR
//         Command:
//             Name: vkCreateRayTracingPipelinesKHR
//         Command:
//             Name: vkGetRayTracingShaderGroupHandlesKHR
//         Command:
//             Name: vkGetRayTracingCaptureReplayShaderGroupHandlesKHR
//         Command:
//             Name: vkCmdTraceRaysIndirectKHR
//         Command:
//             Name: vkGetRayTracingShaderGroupStackSizeKHR
//         Command:
//             Name: vkCmdSetRayTracingPipelineStackSizeKHR
//         Feature:
//             Name: rayTracingPipeline
//             Struct: VkPhysicalDeviceRayTracingPipelineFeaturesKHR
//         Feature:
//             Name: rayTracingPipelineTraceRaysIndirect
//             Struct: VkPhysicalDeviceRayTracingPipelineFeaturesKHR
//     Depends: VK_KHR_ray_query
//         Feature:
//             Name: rayTraversalPrimitiveCulling
//             Struct: VkPhysicalDeviceRayTracingPipelineFeaturesKHR
pub const VK_KHR_ray_query_name = "VK_KHR_ray_query";
// Extension: VK_KHR_ray_query
// Number: 349
// Type: device
// Author: KHR
// Depends: (VK_KHR_spirv_1_4,VK_VERSION_1_2)+VK_KHR_acceleration_structure
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_RAY_QUERY_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_RAY_QUERY_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_ray_query&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 13
//         Type:
//             Name: VkPhysicalDeviceRayQueryFeaturesKHR
//         Feature:
//             Name: rayQuery
//             Struct: VkPhysicalDeviceRayQueryFeaturesKHR
pub const VK_NV_extension_152_name = "VK_NV_extension_152";
// Extension: VK_NV_extension_152
// Number: 152
// Type: invalid
// Author: NV
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_NV_EXTENSION_152_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_NV_EXTENSION_152_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_extension_152&quot;
pub const VK_NV_framebuffer_mixed_samples_name = "VK_NV_framebuffer_mixed_samples";
// Extension: VK_NV_framebuffer_mixed_samples
// Number: 153
// Type: device
// Author: NV
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NV_FRAMEBUFFER_MIXED_SAMPLES_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_NV_FRAMEBUFFER_MIXED_SAMPLES_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_framebuffer_mixed_samples&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPipelineCoverageModulationStateCreateInfoNV
//         Type:
//             Name: VkPipelineCoverageModulationStateCreateFlagsNV
//         Type:
//             Name: VkCoverageModulationModeNV
//     Depends: VK_VERSION_1_3,VK_KHR_dynamic_rendering
//         Enum:
//             Name: VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD
//         Type:
//             Name: VkAttachmentSampleCountInfoNV
pub const VK_NV_fill_rectangle_name = "VK_NV_fill_rectangle";
// Extension: VK_NV_fill_rectangle
// Number: 154
// Type: device
// Author: NV
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NV_FILL_RECTANGLE_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_NV_FILL_RECTANGLE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_fill_rectangle&quot;
//         Enum:
//             Name: VK_POLYGON_MODE_FILL_RECTANGLE_NV
//             Negative: false
//             Extends: VkPolygonMode
//             Offset: 0
pub const VK_NV_shader_sm_builtins_name = "VK_NV_shader_sm_builtins";
// Extension: VK_NV_shader_sm_builtins
// Number: 155
// Type: device
// Author: NV
// Depends: VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NV_SHADER_SM_BUILTINS_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_NV_SHADER_SM_BUILTINS_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_shader_sm_builtins&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Type:
//             Name: VkPhysicalDeviceShaderSMBuiltinsPropertiesNV
//         Type:
//             Name: VkPhysicalDeviceShaderSMBuiltinsFeaturesNV
//         Feature:
//             Name: shaderSMBuiltins
//             Struct: VkPhysicalDeviceShaderSMBuiltinsFeaturesNV
pub const VK_EXT_post_depth_coverage_name = "VK_EXT_post_depth_coverage";
// Extension: VK_EXT_post_depth_coverage
// Number: 156
// Type: device
// Author: NV
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_POST_DEPTH_COVERAGE_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_POST_DEPTH_COVERAGE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_post_depth_coverage&quot;
pub const VK_KHR_sampler_ycbcr_conversion_name = "VK_KHR_sampler_ycbcr_conversion";
// Extension: VK_KHR_sampler_ycbcr_conversion
// Number: 157
// Type: device
// Author: KHR
// Depends: (VK_KHR_maintenance1+VK_KHR_bind_memory2+VK_KHR_get_memory_requirements2+VK_KHR_get_physical_device_properties2),VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_1
// Unlocks:
//         Enum:
//             Name: VK_KHR_SAMPLER_YCBCR_CONVERSION_SPEC_VERSION
//             Negative: false
//             Value: 14
//         Enum:
//             Name: VK_KHR_SAMPLER_YCBCR_CONVERSION_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_sampler_ycbcr_conversion&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES
//         Enum:
//             Name: VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR
//             Negative: false
//             Extends: VkObjectType
//             Alias: VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION
//         Enum:
//             Name: VK_FORMAT_G8B8G8R8_422_UNORM_KHR
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_G8B8G8R8_422_UNORM
//         Enum:
//             Name: VK_FORMAT_B8G8R8G8_422_UNORM_KHR
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_B8G8R8G8_422_UNORM
//         Enum:
//             Name: VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM_KHR
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM
//         Enum:
//             Name: VK_FORMAT_G8_B8R8_2PLANE_420_UNORM_KHR
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_G8_B8R8_2PLANE_420_UNORM
//         Enum:
//             Name: VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM_KHR
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM
//         Enum:
//             Name: VK_FORMAT_G8_B8R8_2PLANE_422_UNORM_KHR
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_G8_B8R8_2PLANE_422_UNORM
//         Enum:
//             Name: VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM_KHR
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM
//         Enum:
//             Name: VK_FORMAT_R10X6_UNORM_PACK16_KHR
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_R10X6_UNORM_PACK16
//         Enum:
//             Name: VK_FORMAT_R10X6G10X6_UNORM_2PACK16_KHR
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_R10X6G10X6_UNORM_2PACK16
//         Enum:
//             Name: VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16_KHR
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16
//         Enum:
//             Name: VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16_KHR
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16
//         Enum:
//             Name: VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16_KHR
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16
//         Enum:
//             Name: VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16_KHR
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16
//         Enum:
//             Name: VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16_KHR
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16
//         Enum:
//             Name: VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16_KHR
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16
//         Enum:
//             Name: VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16_KHR
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16
//         Enum:
//             Name: VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16_KHR
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16
//         Enum:
//             Name: VK_FORMAT_R12X4_UNORM_PACK16_KHR
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_R12X4_UNORM_PACK16
//         Enum:
//             Name: VK_FORMAT_R12X4G12X4_UNORM_2PACK16_KHR
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_R12X4G12X4_UNORM_2PACK16
//         Enum:
//             Name: VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16_KHR
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16
//         Enum:
//             Name: VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16_KHR
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16
//         Enum:
//             Name: VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16_KHR
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16
//         Enum:
//             Name: VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16_KHR
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16
//         Enum:
//             Name: VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16_KHR
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16
//         Enum:
//             Name: VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16_KHR
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16
//         Enum:
//             Name: VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16_KHR
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16
//         Enum:
//             Name: VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16_KHR
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16
//         Enum:
//             Name: VK_FORMAT_G16B16G16R16_422_UNORM_KHR
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_G16B16G16R16_422_UNORM
//         Enum:
//             Name: VK_FORMAT_B16G16R16G16_422_UNORM_KHR
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_B16G16R16G16_422_UNORM
//         Enum:
//             Name: VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM_KHR
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM
//         Enum:
//             Name: VK_FORMAT_G16_B16R16_2PLANE_420_UNORM_KHR
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_G16_B16R16_2PLANE_420_UNORM
//         Enum:
//             Name: VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM_KHR
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM
//         Enum:
//             Name: VK_FORMAT_G16_B16R16_2PLANE_422_UNORM_KHR
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_G16_B16R16_2PLANE_422_UNORM
//         Enum:
//             Name: VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM_KHR
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM
//         Enum:
//             Name: VK_IMAGE_ASPECT_PLANE_0_BIT_KHR
//             Negative: false
//             Extends: VkImageAspectFlagBits
//             Alias: VK_IMAGE_ASPECT_PLANE_0_BIT
//         Enum:
//             Name: VK_IMAGE_ASPECT_PLANE_1_BIT_KHR
//             Negative: false
//             Extends: VkImageAspectFlagBits
//             Alias: VK_IMAGE_ASPECT_PLANE_1_BIT
//         Enum:
//             Name: VK_IMAGE_ASPECT_PLANE_2_BIT_KHR
//             Negative: false
//             Extends: VkImageAspectFlagBits
//             Alias: VK_IMAGE_ASPECT_PLANE_2_BIT
//         Enum:
//             Name: VK_IMAGE_CREATE_DISJOINT_BIT_KHR
//             Negative: false
//             Extends: VkImageCreateFlagBits
//             Alias: VK_IMAGE_CREATE_DISJOINT_BIT
//         Enum:
//             Name: VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT_KHR
//             Negative: false
//             Extends: VkFormatFeatureFlagBits
//             Alias: VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT
//         Enum:
//             Name: VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR
//             Negative: false
//             Extends: VkFormatFeatureFlagBits
//             Alias: VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT
//         Enum:
//             Name: VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR
//             Negative: false
//             Extends: VkFormatFeatureFlagBits
//             Alias: VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT
//         Enum:
//             Name: VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR
//             Negative: false
//             Extends: VkFormatFeatureFlagBits
//             Alias: VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT
//         Enum:
//             Name: VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR
//             Negative: false
//             Extends: VkFormatFeatureFlagBits
//             Alias: VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT
//         Enum:
//             Name: VK_FORMAT_FEATURE_DISJOINT_BIT_KHR
//             Negative: false
//             Extends: VkFormatFeatureFlagBits
//             Alias: VK_FORMAT_FEATURE_DISJOINT_BIT
//         Enum:
//             Name: VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT_KHR
//             Negative: false
//             Extends: VkFormatFeatureFlagBits
//             Alias: VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT
//         Type:
//             Name: VkSamplerYcbcrConversionCreateInfoKHR
//         Type:
//             Name: VkSamplerYcbcrConversionInfoKHR
//         Type:
//             Name: VkBindImagePlaneMemoryInfoKHR
//         Type:
//             Name: VkImagePlaneMemoryRequirementsInfoKHR
//         Type:
//             Name: VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR
//         Type:
//             Name: VkSamplerYcbcrConversionImageFormatPropertiesKHR
//         Command:
//             Name: vkCreateSamplerYcbcrConversionKHR
//         Command:
//             Name: vkDestroySamplerYcbcrConversionKHR
//         Type:
//             Name: VkSamplerYcbcrConversionKHR
//         Type:
//             Name: VkSamplerYcbcrModelConversionKHR
//         Enum:
//             Name: VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY_KHR
//             Negative: false
//             Extends: VkSamplerYcbcrModelConversion
//             Alias: VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY
//         Enum:
//             Name: VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY_KHR
//             Negative: false
//             Extends: VkSamplerYcbcrModelConversion
//             Alias: VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY
//         Enum:
//             Name: VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709_KHR
//             Negative: false
//             Extends: VkSamplerYcbcrModelConversion
//             Alias: VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709
//         Enum:
//             Name: VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601_KHR
//             Negative: false
//             Extends: VkSamplerYcbcrModelConversion
//             Alias: VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601
//         Enum:
//             Name: VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020_KHR
//             Negative: false
//             Extends: VkSamplerYcbcrModelConversion
//             Alias: VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020
//         Type:
//             Name: VkSamplerYcbcrRangeKHR
//         Enum:
//             Name: VK_SAMPLER_YCBCR_RANGE_ITU_FULL_KHR
//             Negative: false
//             Extends: VkSamplerYcbcrRange
//             Alias: VK_SAMPLER_YCBCR_RANGE_ITU_FULL
//         Enum:
//             Name: VK_SAMPLER_YCBCR_RANGE_ITU_NARROW_KHR
//             Negative: false
//             Extends: VkSamplerYcbcrRange
//             Alias: VK_SAMPLER_YCBCR_RANGE_ITU_NARROW
//         Type:
//             Name: VkChromaLocationKHR
//         Enum:
//             Name: VK_CHROMA_LOCATION_COSITED_EVEN_KHR
//             Negative: false
//             Extends: VkChromaLocation
//             Alias: VK_CHROMA_LOCATION_COSITED_EVEN
//         Enum:
//             Name: VK_CHROMA_LOCATION_MIDPOINT_KHR
//             Negative: false
//             Extends: VkChromaLocation
//             Alias: VK_CHROMA_LOCATION_MIDPOINT
//         Feature:
//             Name: samplerYcbcrConversion
//             Struct: VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR
//     Depends: VK_EXT_debug_report
//         Enum:
//             Name: VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT
//             Negative: false
//             Extends: VkDebugReportObjectTypeEXT
//             Offset: 0
//         Enum:
//             Name: VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR_EXT
//             Negative: false
//             Extends: VkDebugReportObjectTypeEXT
//             Alias: VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT
pub const VK_KHR_bind_memory2_name = "VK_KHR_bind_memory2";
// Extension: VK_KHR_bind_memory2
// Number: 158
// Type: device
// Author: KHR
// Supported: supported
// Promoted to: VK_VERSION_1_1
// Unlocks:
//         Enum:
//             Name: VK_KHR_BIND_MEMORY_2_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_BIND_MEMORY_2_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_bind_memory2&quot;
//         Command:
//             Name: vkBindBufferMemory2KHR
//         Command:
//             Name: vkBindImageMemory2KHR
//         Enum:
//             Name: VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO
//         Enum:
//             Name: VK_IMAGE_CREATE_ALIAS_BIT_KHR
//             Negative: false
//             Extends: VkImageCreateFlagBits
//             Alias: VK_IMAGE_CREATE_ALIAS_BIT
//         Type:
//             Name: VkBindBufferMemoryInfoKHR
//         Type:
//             Name: VkBindImageMemoryInfoKHR
pub const VK_EXT_image_drm_format_modifier_name = "VK_EXT_image_drm_format_modifier";
// Extension: VK_EXT_image_drm_format_modifier
// Number: 159
// Type: device
// Author: EXT
// Depends: (((VK_KHR_bind_memory2+VK_KHR_get_physical_device_properties2+VK_KHR_sampler_ycbcr_conversion),VK_VERSION_1_1)+VK_KHR_image_format_list),VK_VERSION_1_2
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_IMAGE_DRM_FORMAT_MODIFIER_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_EXT_IMAGE_DRM_FORMAT_MODIFIER_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_image_drm_format_modifier&quot;
//         Enum:
//             Name: VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT
//             Negative: true
//             Extends: VkResult
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 4
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 5
//         Enum:
//             Name: VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT
//             Negative: false
//             Extends: VkImageTiling
//             Offset: 0
//         Enum:
//             Name: VK_IMAGE_ASPECT_MEMORY_PLANE_0_BIT_EXT
//             Negative: false
//             Bitpos: 7
//             Extends: VkImageAspectFlagBits
//         Enum:
//             Name: VK_IMAGE_ASPECT_MEMORY_PLANE_1_BIT_EXT
//             Negative: false
//             Bitpos: 8
//             Extends: VkImageAspectFlagBits
//         Enum:
//             Name: VK_IMAGE_ASPECT_MEMORY_PLANE_2_BIT_EXT
//             Negative: false
//             Bitpos: 9
//             Extends: VkImageAspectFlagBits
//         Enum:
//             Name: VK_IMAGE_ASPECT_MEMORY_PLANE_3_BIT_EXT
//             Negative: false
//             Bitpos: 10
//             Extends: VkImageAspectFlagBits
//         Type:
//             Name: VkDrmFormatModifierPropertiesListEXT
//         Type:
//             Name: VkDrmFormatModifierPropertiesEXT
//         Type:
//             Name: VkPhysicalDeviceImageDrmFormatModifierInfoEXT
//         Type:
//             Name: VkImageDrmFormatModifierListCreateInfoEXT
//         Type:
//             Name: VkImageDrmFormatModifierExplicitCreateInfoEXT
//         Type:
//             Name: VkImageDrmFormatModifierPropertiesEXT
//         Command:
//             Name: vkGetImageDrmFormatModifierPropertiesEXT
//     Depends: VK_KHR_format_feature_flags2,VK_VERSION_1_3
//         Type:
//             Name: VkDrmFormatModifierPropertiesList2EXT
//         Type:
//             Name: VkDrmFormatModifierProperties2EXT
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 6
pub const VK_EXT_extension_160_name = "VK_EXT_extension_160";
// Extension: VK_EXT_extension_160
// Number: 160
// Type: invalid
// Author: EXT
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_160_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_160_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_160&quot;
pub const VK_EXT_validation_cache_name = "VK_EXT_validation_cache";
// Extension: VK_EXT_validation_cache
// Number: 161
// Type: device
// Author: GOOGLE
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_VALIDATION_CACHE_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_VALIDATION_CACHE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_validation_cache&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_OBJECT_TYPE_VALIDATION_CACHE_EXT
//             Negative: false
//             Extends: VkObjectType
//             Offset: 0
//         Type:
//             Name: VkValidationCacheEXT
//         Type:
//             Name: VkValidationCacheCreateInfoEXT
//         Type:
//             Name: VkShaderModuleValidationCacheCreateInfoEXT
//         Type:
//             Name: VkValidationCacheHeaderVersionEXT
//         Type:
//             Name: VkValidationCacheCreateFlagsEXT
//         Command:
//             Name: vkCreateValidationCacheEXT
//         Command:
//             Name: vkDestroyValidationCacheEXT
//         Command:
//             Name: vkMergeValidationCachesEXT
//         Command:
//             Name: vkGetValidationCacheDataEXT
pub const VK_EXT_descriptor_indexing_name = "VK_EXT_descriptor_indexing";
// Extension: VK_EXT_descriptor_indexing
// Number: 162
// Type: device
// Author: NV
// Depends: (VK_KHR_get_physical_device_properties2+VK_KHR_maintenance3),VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_2
// Unlocks:
//         Enum:
//             Name: VK_EXT_DESCRIPTOR_INDEXING_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_EXT_DESCRIPTOR_INDEXING_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_descriptor_indexing&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT
//         Enum:
//             Name: VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT
//             Negative: false
//             Extends: VkDescriptorBindingFlagBits
//             Alias: VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT
//         Enum:
//             Name: VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT_EXT
//             Negative: false
//             Extends: VkDescriptorBindingFlagBits
//             Alias: VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT
//         Enum:
//             Name: VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT_EXT
//             Negative: false
//             Extends: VkDescriptorBindingFlagBits
//             Alias: VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT
//         Enum:
//             Name: VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT
//             Negative: false
//             Extends: VkDescriptorBindingFlagBits
//             Alias: VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT
//         Enum:
//             Name: VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT
//             Negative: false
//             Extends: VkDescriptorPoolCreateFlagBits
//             Alias: VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT
//         Enum:
//             Name: VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT
//             Negative: false
//             Extends: VkDescriptorSetLayoutCreateFlagBits
//             Alias: VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT
//         Enum:
//             Name: VK_ERROR_FRAGMENTATION_EXT
//             Negative: false
//             Extends: VkResult
//             Alias: VK_ERROR_FRAGMENTATION
//         Type:
//             Name: VkDescriptorSetLayoutBindingFlagsCreateInfoEXT
//         Type:
//             Name: VkPhysicalDeviceDescriptorIndexingFeaturesEXT
//         Type:
//             Name: VkPhysicalDeviceDescriptorIndexingPropertiesEXT
//         Type:
//             Name: VkDescriptorSetVariableDescriptorCountAllocateInfoEXT
//         Type:
//             Name: VkDescriptorSetVariableDescriptorCountLayoutSupportEXT
//         Type:
//             Name: VkDescriptorBindingFlagBitsEXT
//         Type:
//             Name: VkDescriptorBindingFlagsEXT
//         Feature:
//             Name: shaderSampledImageArrayDynamicIndexing
//             Struct: VkPhysicalDeviceFeatures
//         Feature:
//             Name: shaderStorageBufferArrayDynamicIndexing
//             Struct: VkPhysicalDeviceFeatures
//         Feature:
//             Name: shaderUniformTexelBufferArrayDynamicIndexing
//             Struct: VkPhysicalDeviceDescriptorIndexingFeaturesEXT
//         Feature:
//             Name: shaderStorageTexelBufferArrayDynamicIndexing
//             Struct: VkPhysicalDeviceDescriptorIndexingFeaturesEXT
//         Feature:
//             Name: shaderSampledImageArrayNonUniformIndexing
//             Struct: VkPhysicalDeviceDescriptorIndexingFeaturesEXT
//         Feature:
//             Name: shaderStorageBufferArrayNonUniformIndexing
//             Struct: VkPhysicalDeviceDescriptorIndexingFeaturesEXT
//         Feature:
//             Name: shaderUniformTexelBufferArrayNonUniformIndexing
//             Struct: VkPhysicalDeviceDescriptorIndexingFeaturesEXT
//         Feature:
//             Name: descriptorBindingSampledImageUpdateAfterBind
//             Struct: VkPhysicalDeviceDescriptorIndexingFeaturesEXT
//         Feature:
//             Name: descriptorBindingStorageImageUpdateAfterBind
//             Struct: VkPhysicalDeviceDescriptorIndexingFeaturesEXT
//         Feature:
//             Name: descriptorBindingStorageBufferUpdateAfterBind
//             Struct: VkPhysicalDeviceDescriptorIndexingFeaturesEXT
//         Feature:
//             Name: descriptorBindingUniformTexelBufferUpdateAfterBind
//             Struct: VkPhysicalDeviceDescriptorIndexingFeaturesEXT
//         Feature:
//             Name: descriptorBindingStorageTexelBufferUpdateAfterBind
//             Struct: VkPhysicalDeviceDescriptorIndexingFeaturesEXT
//         Feature:
//             Name: descriptorBindingUpdateUnusedWhilePending
//             Struct: VkPhysicalDeviceDescriptorIndexingFeaturesEXT
//         Feature:
//             Name: descriptorBindingPartiallyBound
//             Struct: VkPhysicalDeviceDescriptorIndexingFeaturesEXT
//         Feature:
//             Name: runtimeDescriptorArray
//             Struct: VkPhysicalDeviceDescriptorIndexingFeaturesEXT
pub const VK_EXT_shader_viewport_index_layer_name = "VK_EXT_shader_viewport_index_layer";
// Extension: VK_EXT_shader_viewport_index_layer
// Number: 163
// Type: device
// Author: NV
// Supported: supported
// Promoted to: VK_VERSION_1_2
// Unlocks:
//         Enum:
//             Name: VK_EXT_SHADER_VIEWPORT_INDEX_LAYER_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_SHADER_VIEWPORT_INDEX_LAYER_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_shader_viewport_index_layer&quot;
pub const VK_KHR_portability_subset_name = "VK_KHR_portability_subset";
// Extension: VK_KHR_portability_subset
// Number: 164
// Type: device
// Author: KHR
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Platform: provisional
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_PORTABILITY_SUBSET_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_PORTABILITY_SUBSET_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_portability_subset&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Type:
//             Name: VkPhysicalDevicePortabilitySubsetFeaturesKHR
//         Type:
//             Name: VkPhysicalDevicePortabilitySubsetPropertiesKHR
pub const VK_NV_shading_rate_image_name = "VK_NV_shading_rate_image";
// Extension: VK_NV_shading_rate_image
// Number: 165
// Type: device
// Author: NV
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NV_SHADING_RATE_IMAGE_SPEC_VERSION
//             Negative: false
//             Value: 3
//         Enum:
//             Name: VK_NV_SHADING_RATE_IMAGE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_shading_rate_image&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_IMAGE_LAYOUT_SHADING_RATE_OPTIMAL_NV
//             Negative: false
//             Extends: VkImageLayout
//             Alias: VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR
//         Enum:
//             Name: VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV
//             Negative: false
//             Extends: VkDynamicState
//             Offset: 4
//         Enum:
//             Name: VK_ACCESS_SHADING_RATE_IMAGE_READ_BIT_NV
//             Negative: false
//             Extends: VkAccessFlagBits
//             Alias: VK_ACCESS_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR
//         Enum:
//             Name: VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV
//             Negative: false
//             Extends: VkImageUsageFlagBits
//             Alias: VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR
//         Enum:
//             Name: VK_PIPELINE_STAGE_SHADING_RATE_IMAGE_BIT_NV
//             Negative: false
//             Extends: VkPipelineStageFlagBits
//             Alias: VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 5
//         Enum:
//             Name: VK_DYNAMIC_STATE_VIEWPORT_COARSE_SAMPLE_ORDER_NV
//             Negative: false
//             Extends: VkDynamicState
//             Offset: 6
//         Type:
//             Name: VkShadingRatePaletteEntryNV
//         Type:
//             Name: VkShadingRatePaletteNV
//         Type:
//             Name: VkPipelineViewportShadingRateImageStateCreateInfoNV
//         Type:
//             Name: VkPhysicalDeviceShadingRateImageFeaturesNV
//         Type:
//             Name: VkPhysicalDeviceShadingRateImagePropertiesNV
//         Type:
//             Name: VkCoarseSampleLocationNV
//         Type:
//             Name: VkCoarseSampleOrderCustomNV
//         Type:
//             Name: VkPipelineViewportCoarseSampleOrderStateCreateInfoNV
//         Type:
//             Name: VkCoarseSampleOrderTypeNV
//         Command:
//             Name: vkCmdBindShadingRateImageNV
//         Command:
//             Name: vkCmdSetViewportShadingRatePaletteNV
//         Command:
//             Name: vkCmdSetCoarseSampleOrderNV
//         Feature:
//             Name: shadingRateImage
//             Struct: VkPhysicalDeviceShadingRateImageFeaturesNV
pub const VK_NV_ray_tracing_name = "VK_NV_ray_tracing";
// Extension: VK_NV_ray_tracing
// Number: 166
// Type: device
// Author: NV
// Depends: (VK_KHR_get_physical_device_properties2+VK_KHR_get_memory_requirements2),VK_VERSION_1_1
// Supported: supported
// Deprecated by: VK_KHR_ray_tracing_pipeline
// Unlocks:
//         Enum:
//             Name: VK_NV_RAY_TRACING_SPEC_VERSION
//             Negative: false
//             Value: 3
//         Enum:
//             Name: VK_NV_RAY_TRACING_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_ray_tracing&quot;
//         Enum:
//             Name: VK_SHADER_UNUSED_NV
//             Negative: false
//             Alias: VK_SHADER_UNUSED_KHR
//         Enum:
//             Name: VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_GEOMETRY_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Enum:
//             Name: VK_STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 4
//         Enum:
//             Name: VK_STRUCTURE_TYPE_GEOMETRY_AABB_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 5
//         Enum:
//             Name: VK_STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 6
//         Enum:
//             Name: VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 7
//         Enum:
//             Name: VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 8
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 9
//         Enum:
//             Name: VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 11
//         Enum:
//             Name: VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 12
//         Enum:
//             Name: VK_SHADER_STAGE_RAYGEN_BIT_NV
//             Negative: false
//             Extends: VkShaderStageFlagBits
//             Alias: VK_SHADER_STAGE_RAYGEN_BIT_KHR
//         Enum:
//             Name: VK_SHADER_STAGE_ANY_HIT_BIT_NV
//             Negative: false
//             Extends: VkShaderStageFlagBits
//             Alias: VK_SHADER_STAGE_ANY_HIT_BIT_KHR
//         Enum:
//             Name: VK_SHADER_STAGE_CLOSEST_HIT_BIT_NV
//             Negative: false
//             Extends: VkShaderStageFlagBits
//             Alias: VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR
//         Enum:
//             Name: VK_SHADER_STAGE_MISS_BIT_NV
//             Negative: false
//             Extends: VkShaderStageFlagBits
//             Alias: VK_SHADER_STAGE_MISS_BIT_KHR
//         Enum:
//             Name: VK_SHADER_STAGE_INTERSECTION_BIT_NV
//             Negative: false
//             Extends: VkShaderStageFlagBits
//             Alias: VK_SHADER_STAGE_INTERSECTION_BIT_KHR
//         Enum:
//             Name: VK_SHADER_STAGE_CALLABLE_BIT_NV
//             Negative: false
//             Extends: VkShaderStageFlagBits
//             Alias: VK_SHADER_STAGE_CALLABLE_BIT_KHR
//         Enum:
//             Name: VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_NV
//             Negative: false
//             Extends: VkPipelineStageFlagBits
//             Alias: VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_KHR
//         Enum:
//             Name: VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_NV
//             Negative: false
//             Extends: VkPipelineStageFlagBits
//             Alias: VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR
//         Enum:
//             Name: VK_BUFFER_USAGE_RAY_TRACING_BIT_NV
//             Negative: false
//             Extends: VkBufferUsageFlagBits
//             Alias: VK_BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR
//         Enum:
//             Name: VK_PIPELINE_BIND_POINT_RAY_TRACING_NV
//             Negative: false
//             Extends: VkPipelineBindPoint
//             Alias: VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR
//         Enum:
//             Name: VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV
//             Negative: false
//             Extends: VkDescriptorType
//             Offset: 0
//         Enum:
//             Name: VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_NV
//             Negative: false
//             Extends: VkAccessFlagBits
//             Alias: VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR
//         Enum:
//             Name: VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_NV
//             Negative: false
//             Extends: VkAccessFlagBits
//             Alias: VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_KHR
//         Enum:
//             Name: VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_NV
//             Negative: false
//             Extends: VkQueryType
//             Offset: 0
//         Enum:
//             Name: VK_PIPELINE_CREATE_DEFER_COMPILE_BIT_NV
//             Negative: false
//             Bitpos: 5
//             Extends: VkPipelineCreateFlagBits
//         Enum:
//             Name: VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV
//             Negative: false
//             Extends: VkObjectType
//             Offset: 0
//         Enum:
//             Name: VK_INDEX_TYPE_NONE_NV
//             Negative: false
//             Extends: VkIndexType
//             Alias: VK_INDEX_TYPE_NONE_KHR
//         Type:
//             Name: VkRayTracingShaderGroupCreateInfoNV
//         Type:
//             Name: VkRayTracingShaderGroupTypeNV
//         Enum:
//             Name: VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_NV
//             Negative: false
//             Extends: VkRayTracingShaderGroupTypeKHR
//             Alias: VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR
//         Enum:
//             Name: VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_NV
//             Negative: false
//             Extends: VkRayTracingShaderGroupTypeKHR
//             Alias: VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_KHR
//         Enum:
//             Name: VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_NV
//             Negative: false
//             Extends: VkRayTracingShaderGroupTypeKHR
//             Alias: VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_KHR
//         Type:
//             Name: VkRayTracingPipelineCreateInfoNV
//         Type:
//             Name: VkGeometryTypeNV
//         Enum:
//             Name: VK_GEOMETRY_TYPE_TRIANGLES_NV
//             Negative: false
//             Extends: VkGeometryTypeKHR
//             Alias: VK_GEOMETRY_TYPE_TRIANGLES_KHR
//         Enum:
//             Name: VK_GEOMETRY_TYPE_AABBS_NV
//             Negative: false
//             Extends: VkGeometryTypeKHR
//             Alias: VK_GEOMETRY_TYPE_AABBS_KHR
//         Type:
//             Name: VkAccelerationStructureTypeNV
//         Enum:
//             Name: VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_NV
//             Negative: false
//             Extends: VkAccelerationStructureTypeKHR
//             Alias: VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR
//         Enum:
//             Name: VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_NV
//             Negative: false
//             Extends: VkAccelerationStructureTypeKHR
//             Alias: VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR
//         Type:
//             Name: VkGeometryTrianglesNV
//         Type:
//             Name: VkGeometryAABBNV
//         Type:
//             Name: VkGeometryDataNV
//         Type:
//             Name: VkGeometryNV
//         Type:
//             Name: VkGeometryFlagsNV
//         Type:
//             Name: VkGeometryFlagBitsNV
//         Enum:
//             Name: VK_GEOMETRY_OPAQUE_BIT_NV
//             Negative: false
//             Extends: VkGeometryFlagBitsKHR
//             Alias: VK_GEOMETRY_OPAQUE_BIT_KHR
//         Enum:
//             Name: VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_NV
//             Negative: false
//             Extends: VkGeometryFlagBitsKHR
//             Alias: VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_KHR
//         Type:
//             Name: VkGeometryInstanceFlagsNV
//         Type:
//             Name: VkGeometryInstanceFlagBitsNV
//         Enum:
//             Name: VK_GEOMETRY_INSTANCE_TRIANGLE_CULL_DISABLE_BIT_NV
//             Negative: false
//             Extends: VkGeometryInstanceFlagBitsKHR
//             Alias: VK_GEOMETRY_INSTANCE_TRIANGLE_FACING_CULL_DISABLE_BIT_KHR
//         Enum:
//             Name: VK_GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_NV
//             Negative: false
//             Extends: VkGeometryInstanceFlagBitsKHR
//             Alias: VK_GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_KHR
//         Enum:
//             Name: VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_NV
//             Negative: false
//             Extends: VkGeometryInstanceFlagBitsKHR
//             Alias: VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_KHR
//         Enum:
//             Name: VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_NV
//             Negative: false
//             Extends: VkGeometryInstanceFlagBitsKHR
//             Alias: VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_KHR
//         Type:
//             Name: VkAccelerationStructureInfoNV
//         Type:
//             Name: VkAccelerationStructureCreateInfoNV
//         Type:
//             Name: VkAccelerationStructureNV
//         Type:
//             Name: VkBuildAccelerationStructureFlagBitsNV
//         Enum:
//             Name: VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_NV
//             Negative: false
//             Extends: VkBuildAccelerationStructureFlagBitsKHR
//             Alias: VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_KHR
//         Enum:
//             Name: VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_NV
//             Negative: false
//             Extends: VkBuildAccelerationStructureFlagBitsKHR
//             Alias: VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_KHR
//         Enum:
//             Name: VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_NV
//             Negative: false
//             Extends: VkBuildAccelerationStructureFlagBitsKHR
//             Alias: VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_KHR
//         Enum:
//             Name: VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_NV
//             Negative: false
//             Extends: VkBuildAccelerationStructureFlagBitsKHR
//             Alias: VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_KHR
//         Enum:
//             Name: VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_NV
//             Negative: false
//             Extends: VkBuildAccelerationStructureFlagBitsKHR
//             Alias: VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_KHR
//         Type:
//             Name: VkBuildAccelerationStructureFlagsNV
//         Type:
//             Name: VkCopyAccelerationStructureModeNV
//         Enum:
//             Name: VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_NV
//             Negative: false
//             Extends: VkCopyAccelerationStructureModeKHR
//             Alias: VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_KHR
//         Enum:
//             Name: VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_NV
//             Negative: false
//             Extends: VkCopyAccelerationStructureModeKHR
//             Alias: VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_KHR
//         Type:
//             Name: VkBindAccelerationStructureMemoryInfoNV
//         Type:
//             Name: VkWriteDescriptorSetAccelerationStructureNV
//         Type:
//             Name: VkAccelerationStructureMemoryRequirementsInfoNV
//         Type:
//             Name: VkPhysicalDeviceRayTracingPropertiesNV
//         Type:
//             Name: VkAccelerationStructureMemoryRequirementsTypeNV
//         Type:
//             Name: VkTransformMatrixNV
//         Type:
//             Name: VkAabbPositionsNV
//         Type:
//             Name: VkAccelerationStructureInstanceNV
//         Command:
//             Name: vkCreateAccelerationStructureNV
//         Command:
//             Name: vkDestroyAccelerationStructureNV
//         Command:
//             Name: vkGetAccelerationStructureMemoryRequirementsNV
//         Command:
//             Name: vkBindAccelerationStructureMemoryNV
//         Command:
//             Name: vkCmdBuildAccelerationStructureNV
//         Command:
//             Name: vkCmdCopyAccelerationStructureNV
//         Command:
//             Name: vkCmdTraceRaysNV
//         Command:
//             Name: vkCreateRayTracingPipelinesNV
//         Command:
//             Name: vkGetRayTracingShaderGroupHandlesNV
//         Command:
//             Name: vkGetAccelerationStructureHandleNV
//         Command:
//             Name: vkCmdWriteAccelerationStructuresPropertiesNV
//         Command:
//             Name: vkCompileDeferredNV
//     Depends: VK_KHR_get_memory_requirements2,VK_VERSION_1_1
//         Type:
//             Name: VkMemoryRequirements2KHR
//     Depends: VK_EXT_debug_report
//         Enum:
//             Name: VK_DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV_EXT
//             Negative: false
//             Extends: VkDebugReportObjectTypeEXT
//             Offset: 0
pub const VK_NV_representative_fragment_test_name = "VK_NV_representative_fragment_test";
// Extension: VK_NV_representative_fragment_test
// Number: 167
// Type: device
// Author: NV
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NV_REPRESENTATIVE_FRAGMENT_TEST_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_NV_REPRESENTATIVE_FRAGMENT_TEST_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_representative_fragment_test&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Type:
//             Name: VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV
//         Type:
//             Name: VkPipelineRepresentativeFragmentTestStateCreateInfoNV
//         Feature:
//             Name: representativeFragmentTest
//             Struct: VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV
pub const VK_NV_extension_168_name = "VK_NV_extension_168";
// Extension: VK_NV_extension_168
// Number: 168
// Type: invalid
// Author: NV
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_NV_EXTENSION_168_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_NV_EXTENSION_168_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_extension_168&quot;
pub const VK_KHR_maintenance3_name = "VK_KHR_maintenance3";
// Extension: VK_KHR_maintenance3
// Number: 169
// Type: device
// Author: KHR
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_1
// Unlocks:
//         Enum:
//             Name: VK_KHR_MAINTENANCE_3_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_MAINTENANCE_3_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_maintenance3&quot;
//         Enum:
//             Name: VK_KHR_MAINTENANCE3_SPEC_VERSION
//             Negative: false
//             Alias: VK_KHR_MAINTENANCE_3_SPEC_VERSION
//         Enum:
//             Name: VK_KHR_MAINTENANCE3_EXTENSION_NAME
//             Negative: false
//             Alias: VK_KHR_MAINTENANCE_3_EXTENSION_NAME
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT
//         Type:
//             Name: VkPhysicalDeviceMaintenance3PropertiesKHR
//         Type:
//             Name: VkDescriptorSetLayoutSupportKHR
//         Command:
//             Name: vkGetDescriptorSetLayoutSupportKHR
pub const VK_KHR_draw_indirect_count_name = "VK_KHR_draw_indirect_count";
// Extension: VK_KHR_draw_indirect_count
// Number: 170
// Type: device
// Author: KHR
// Supported: supported
// Promoted to: VK_VERSION_1_2
// Unlocks:
//         Enum:
//             Name: VK_KHR_DRAW_INDIRECT_COUNT_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_DRAW_INDIRECT_COUNT_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_draw_indirect_count&quot;
//         Command:
//             Name: vkCmdDrawIndirectCountKHR
//         Command:
//             Name: vkCmdDrawIndexedIndirectCountKHR
pub const VK_EXT_filter_cubic_name = "VK_EXT_filter_cubic";
// Extension: VK_EXT_filter_cubic
// Number: 171
// Type: device
// Author: QCOM
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_FILTER_CUBIC_SPEC_VERSION
//             Negative: false
//             Value: 3
//         Enum:
//             Name: VK_EXT_FILTER_CUBIC_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_filter_cubic&quot;
//         Enum:
//             Name: VK_FILTER_CUBIC_EXT
//             Negative: false
//             Extends: VkFilter
//             Extnumber: 16
//             Offset: 0
//         Enum:
//             Name: VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT
//             Negative: false
//             Bitpos: 13
//             Extends: VkFormatFeatureFlagBits
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Type:
//             Name: VkPhysicalDeviceImageViewImageFormatInfoEXT
//         Type:
//             Name: VkFilterCubicImageViewImageFormatPropertiesEXT
pub const VK_QCOM_render_pass_shader_resolve_name = "VK_QCOM_render_pass_shader_resolve";
// Extension: VK_QCOM_render_pass_shader_resolve
// Number: 172
// Type: device
// Author: QCOM
// Supported: supported
// Promoted to: VK_EXT_custom_resolve
// Unlocks:
//         Enum:
//             Name: VK_QCOM_RENDER_PASS_SHADER_RESOLVE_SPEC_VERSION
//             Negative: false
//             Value: 4
//         Enum:
//             Name: VK_QCOM_RENDER_PASS_SHADER_RESOLVE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_QCOM_render_pass_shader_resolve&quot;
//         Enum:
//             Name: VK_SUBPASS_DESCRIPTION_FRAGMENT_REGION_BIT_QCOM
//             Negative: false
//             Extends: VkSubpassDescriptionFlagBits
//             Alias: VK_SUBPASS_DESCRIPTION_FRAGMENT_REGION_BIT_EXT
//         Enum:
//             Name: VK_SUBPASS_DESCRIPTION_SHADER_RESOLVE_BIT_QCOM
//             Negative: false
//             Extends: VkSubpassDescriptionFlagBits
//             Alias: VK_SUBPASS_DESCRIPTION_CUSTOM_RESOLVE_BIT_EXT
pub const VK_QCOM_extension_173_name = "VK_QCOM_extension_173";
// Extension: VK_QCOM_extension_173
// Number: 173
// Type: invalid
// Author: QCOM
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_QCOM_EXTENSION_173_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_QCOM_EXTENSION_173_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_QCOM_extension_173&quot;
pub const VK_QCOM_extension_174_name = "VK_QCOM_extension_174";
// Extension: VK_QCOM_extension_174
// Number: 174
// Type: invalid
// Author: QCOM
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_QCOM_EXTENSION_174_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_QCOM_EXTENSION_174_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_QCOM_extension_174&quot;
pub const VK_EXT_global_priority_name = "VK_EXT_global_priority";
// Extension: VK_EXT_global_priority
// Number: 175
// Type: device
// Author: EXT
// Supported: supported
// Promoted to: VK_KHR_global_priority
// Unlocks:
//         Enum:
//             Name: VK_EXT_GLOBAL_PRIORITY_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_EXT_GLOBAL_PRIORITY_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_global_priority&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO
//         Enum:
//             Name: VK_ERROR_NOT_PERMITTED_EXT
//             Negative: false
//             Extends: VkResult
//             Alias: VK_ERROR_NOT_PERMITTED
//         Enum:
//             Name: VK_QUEUE_GLOBAL_PRIORITY_LOW_EXT
//             Negative: false
//             Extends: VkQueueGlobalPriority
//             Alias: VK_QUEUE_GLOBAL_PRIORITY_LOW
//         Enum:
//             Name: VK_QUEUE_GLOBAL_PRIORITY_MEDIUM_EXT
//             Negative: false
//             Extends: VkQueueGlobalPriority
//             Alias: VK_QUEUE_GLOBAL_PRIORITY_MEDIUM
//         Enum:
//             Name: VK_QUEUE_GLOBAL_PRIORITY_HIGH_EXT
//             Negative: false
//             Extends: VkQueueGlobalPriority
//             Alias: VK_QUEUE_GLOBAL_PRIORITY_HIGH
//         Enum:
//             Name: VK_QUEUE_GLOBAL_PRIORITY_REALTIME_EXT
//             Negative: false
//             Extends: VkQueueGlobalPriority
//             Alias: VK_QUEUE_GLOBAL_PRIORITY_REALTIME
//         Type:
//             Name: VkDeviceQueueGlobalPriorityCreateInfoEXT
//         Type:
//             Name: VkQueueGlobalPriorityEXT
pub const VK_KHR_shader_subgroup_extended_types_name = "VK_KHR_shader_subgroup_extended_types";
// Extension: VK_KHR_shader_subgroup_extended_types
// Number: 176
// Type: device
// Author: KHR
// Depends: VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_2
// Unlocks:
//         Enum:
//             Name: VK_KHR_SHADER_SUBGROUP_EXTENDED_TYPES_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_SHADER_SUBGROUP_EXTENDED_TYPES_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_shader_subgroup_extended_types&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES
//         Type:
//             Name: VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR
//         Feature:
//             Name: shaderSubgroupExtendedTypes
//             Struct: VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR
pub const VK_EXT_extension_177_name = "VK_EXT_extension_177";
// Extension: VK_EXT_extension_177
// Number: 177
// Type: invalid
// Author: EXT
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_177_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_177_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_177&quot;
pub const VK_KHR_8bit_storage_name = "VK_KHR_8bit_storage";
// Extension: VK_KHR_8bit_storage
// Number: 178
// Type: device
// Author: KHR
// Depends: (VK_KHR_get_physical_device_properties2+VK_KHR_storage_buffer_storage_class),VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_2
// Unlocks:
//         Enum:
//             Name: VK_KHR_8BIT_STORAGE_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_8BIT_STORAGE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_8bit_storage&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES
//         Type:
//             Name: VkPhysicalDevice8BitStorageFeaturesKHR
//         Feature:
//             Name: storageBuffer8BitAccess
//             Struct: VkPhysicalDevice8BitStorageFeaturesKHR
pub const VK_EXT_external_memory_host_name = "VK_EXT_external_memory_host";
// Extension: VK_EXT_external_memory_host
// Number: 179
// Type: device
// Author: EXT
// Depends: VK_KHR_external_memory,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTERNAL_MEMORY_HOST_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_EXTERNAL_MEMORY_HOST_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_external_memory_host&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT
//             Negative: false
//             Bitpos: 7
//             Extends: VkExternalMemoryHandleTypeFlagBits
//         Enum:
//             Name: VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT
//             Negative: false
//             Bitpos: 8
//             Extends: VkExternalMemoryHandleTypeFlagBits
//         Type:
//             Name: VkImportMemoryHostPointerInfoEXT
//         Type:
//             Name: VkMemoryHostPointerPropertiesEXT
//         Type:
//             Name: VkPhysicalDeviceExternalMemoryHostPropertiesEXT
//         Command:
//             Name: vkGetMemoryHostPointerPropertiesEXT
pub const VK_AMD_buffer_marker_name = "VK_AMD_buffer_marker";
// Extension: VK_AMD_buffer_marker
// Number: 180
// Type: device
// Author: AMD
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_AMD_BUFFER_MARKER_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_AMD_BUFFER_MARKER_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_buffer_marker&quot;
//         Command:
//             Name: vkCmdWriteBufferMarkerAMD
//     Depends: VK_VERSION_1_3,VK_KHR_synchronization2
//         Command:
//             Name: vkCmdWriteBufferMarker2AMD
pub const VK_KHR_shader_atomic_int64_name = "VK_KHR_shader_atomic_int64";
// Extension: VK_KHR_shader_atomic_int64
// Number: 181
// Type: device
// Author: KHR
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_2
// Unlocks:
//         Enum:
//             Name: VK_KHR_SHADER_ATOMIC_INT64_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_SHADER_ATOMIC_INT64_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_shader_atomic_int64&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES
//         Type:
//             Name: VkPhysicalDeviceShaderAtomicInt64FeaturesKHR
//         Feature:
//             Name: shaderBufferInt64Atomics
//             Struct: VkPhysicalDeviceShaderAtomicInt64FeaturesKHR
pub const VK_KHR_shader_clock_name = "VK_KHR_shader_clock";
// Extension: VK_KHR_shader_clock
// Number: 182
// Type: device
// Author: KHR
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_SHADER_CLOCK_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_SHADER_CLOCK_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_shader_clock&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceShaderClockFeaturesKHR
//         Feature:
//             Name: shaderSubgroupClock
//             Struct: VkPhysicalDeviceShaderClockFeaturesKHR
pub const VK_AMD_extension_183_name = "VK_AMD_extension_183";
// Extension: VK_AMD_extension_183
// Number: 183
// Type: invalid
// Author: AMD
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_AMD_EXTENSION_183_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_AMD_EXTENSION_183_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_extension_183&quot;
pub const VK_AMD_pipeline_compiler_control_name = "VK_AMD_pipeline_compiler_control";
// Extension: VK_AMD_pipeline_compiler_control
// Number: 184
// Type: device
// Author: AMD
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_AMD_PIPELINE_COMPILER_CONTROL_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_AMD_PIPELINE_COMPILER_CONTROL_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_pipeline_compiler_control&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPipelineCompilerControlFlagBitsAMD
//         Type:
//             Name: VkPipelineCompilerControlFlagsAMD
//         Type:
//             Name: VkPipelineCompilerControlCreateInfoAMD
pub const VK_EXT_calibrated_timestamps_name = "VK_EXT_calibrated_timestamps";
// Extension: VK_EXT_calibrated_timestamps
// Number: 185
// Type: device
// Author: EXT
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_KHR_calibrated_timestamps
// Unlocks:
//         Enum:
//             Name: VK_EXT_CALIBRATED_TIMESTAMPS_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_EXT_CALIBRATED_TIMESTAMPS_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_calibrated_timestamps&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_KHR
//         Enum:
//             Name: VK_TIME_DOMAIN_DEVICE_EXT
//             Negative: false
//             Extends: VkTimeDomainKHR
//             Alias: VK_TIME_DOMAIN_DEVICE_KHR
//         Enum:
//             Name: VK_TIME_DOMAIN_CLOCK_MONOTONIC_EXT
//             Negative: false
//             Extends: VkTimeDomainKHR
//             Alias: VK_TIME_DOMAIN_CLOCK_MONOTONIC_KHR
//         Enum:
//             Name: VK_TIME_DOMAIN_CLOCK_MONOTONIC_RAW_EXT
//             Negative: false
//             Extends: VkTimeDomainKHR
//             Alias: VK_TIME_DOMAIN_CLOCK_MONOTONIC_RAW_KHR
//         Enum:
//             Name: VK_TIME_DOMAIN_QUERY_PERFORMANCE_COUNTER_EXT
//             Negative: false
//             Extends: VkTimeDomainKHR
//             Alias: VK_TIME_DOMAIN_QUERY_PERFORMANCE_COUNTER_KHR
//         Type:
//             Name: VkTimeDomainEXT
//         Type:
//             Name: VkCalibratedTimestampInfoEXT
//         Command:
//             Name: vkGetPhysicalDeviceCalibrateableTimeDomainsEXT
//         Command:
//             Name: vkGetCalibratedTimestampsEXT
pub const VK_AMD_shader_core_properties_name = "VK_AMD_shader_core_properties";
// Extension: VK_AMD_shader_core_properties
// Number: 186
// Type: device
// Author: AMD
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_AMD_SHADER_CORE_PROPERTIES_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_AMD_SHADER_CORE_PROPERTIES_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_shader_core_properties&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceShaderCorePropertiesAMD
pub const VK_AMD_extension_187_name = "VK_AMD_extension_187";
// Extension: VK_AMD_extension_187
// Number: 187
// Type: invalid
// Author: AMD
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_AMD_EXTENSION_187_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_AMD_EXTENSION_187_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_extension_187&quot;
pub const VK_KHR_video_decode_h265_name = "VK_KHR_video_decode_h265";
// Extension: VK_KHR_video_decode_h265
// Number: 188
// Type: device
// Author: KHR
// Depends: VK_KHR_video_decode_queue
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_VIDEO_DECODE_H265_SPEC_VERSION
//             Negative: false
//             Value: 8
//         Enum:
//             Name: VK_KHR_VIDEO_DECODE_H265_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_video_decode_h265&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_CAPABILITIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PROFILE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PICTURE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 4
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_DPB_SLOT_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 5
//         Enum:
//             Name: VK_VIDEO_CODEC_OPERATION_DECODE_H265_BIT_KHR
//             Negative: false
//             Bitpos: 1
//             Extends: VkVideoCodecOperationFlagBitsKHR
//         Type:
//             Name: VkVideoDecodeH265ProfileInfoKHR
//         Type:
//             Name: VkVideoDecodeH265CapabilitiesKHR
//         Type:
//             Name: VkVideoDecodeH265SessionParametersCreateInfoKHR
//         Type:
//             Name: VkVideoDecodeH265SessionParametersAddInfoKHR
//         Type:
//             Name: VkVideoDecodeH265PictureInfoKHR
//         Type:
//             Name: VkVideoDecodeH265DpbSlotInfoKHR
pub const VK_KHR_global_priority_name = "VK_KHR_global_priority";
// Extension: VK_KHR_global_priority
// Number: 189
// Type: device
// Author: KHR
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_4
// Unlocks:
//         Enum:
//             Name: VK_KHR_GLOBAL_PRIORITY_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_GLOBAL_PRIORITY_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_global_priority&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES
//         Enum:
//             Name: VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES
//         Enum:
//             Name: VK_ERROR_NOT_PERMITTED_KHR
//             Negative: false
//             Extends: VkResult
//             Alias: VK_ERROR_NOT_PERMITTED
//         Enum:
//             Name: VK_MAX_GLOBAL_PRIORITY_SIZE_KHR
//             Negative: false
//             Alias: VK_MAX_GLOBAL_PRIORITY_SIZE
//         Enum:
//             Name: VK_QUEUE_GLOBAL_PRIORITY_LOW_KHR
//             Negative: false
//             Extends: VkQueueGlobalPriority
//             Alias: VK_QUEUE_GLOBAL_PRIORITY_LOW
//         Enum:
//             Name: VK_QUEUE_GLOBAL_PRIORITY_MEDIUM_KHR
//             Negative: false
//             Extends: VkQueueGlobalPriority
//             Alias: VK_QUEUE_GLOBAL_PRIORITY_MEDIUM
//         Enum:
//             Name: VK_QUEUE_GLOBAL_PRIORITY_HIGH_KHR
//             Negative: false
//             Extends: VkQueueGlobalPriority
//             Alias: VK_QUEUE_GLOBAL_PRIORITY_HIGH
//         Enum:
//             Name: VK_QUEUE_GLOBAL_PRIORITY_REALTIME_KHR
//             Negative: false
//             Extends: VkQueueGlobalPriority
//             Alias: VK_QUEUE_GLOBAL_PRIORITY_REALTIME
//         Type:
//             Name: VkDeviceQueueGlobalPriorityCreateInfoKHR
//         Type:
//             Name: VkQueueGlobalPriorityKHR
//         Type:
//             Name: VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR
//         Type:
//             Name: VkQueueFamilyGlobalPriorityPropertiesKHR
//         Feature:
//             Name: globalPriorityQuery
//             Struct: VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR
pub const VK_AMD_memory_overallocation_behavior_name = "VK_AMD_memory_overallocation_behavior";
// Extension: VK_AMD_memory_overallocation_behavior
// Number: 190
// Type: device
// Author: AMD
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_AMD_MEMORY_OVERALLOCATION_BEHAVIOR_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_AMD_MEMORY_OVERALLOCATION_BEHAVIOR_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_memory_overallocation_behavior&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkMemoryOverallocationBehaviorAMD
//         Type:
//             Name: VkDeviceMemoryOverallocationCreateInfoAMD
pub const VK_EXT_vertex_attribute_divisor_name = "VK_EXT_vertex_attribute_divisor";
// Extension: VK_EXT_vertex_attribute_divisor
// Number: 191
// Type: device
// Author: NV
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_KHR_vertex_attribute_divisor
// Unlocks:
//         Enum:
//             Name: VK_EXT_VERTEX_ATTRIBUTE_DIVISOR_SPEC_VERSION
//             Negative: false
//             Value: 3
//         Enum:
//             Name: VK_EXT_VERTEX_ATTRIBUTE_DIVISOR_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_vertex_attribute_divisor&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES
//         Type:
//             Name: VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT
//         Type:
//             Name: VkVertexInputBindingDivisorDescriptionEXT
//         Type:
//             Name: VkPipelineVertexInputDivisorStateCreateInfoEXT
//         Type:
//             Name: VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT
//         Feature:
//             Name: vertexAttributeInstanceRateDivisor
//             Struct: VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT
pub const VK_GGP_frame_token_name = "VK_GGP_frame_token";
// Extension: VK_GGP_frame_token
// Number: 192
// Type: device
// Author: GGP
// Depends: VK_KHR_swapchain+VK_GGP_stream_descriptor_surface
// Platform: ggp
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_GGP_FRAME_TOKEN_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_GGP_FRAME_TOKEN_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_GGP_frame_token&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPresentFrameTokenGGP
pub const VK_EXT_pipeline_creation_feedback_name = "VK_EXT_pipeline_creation_feedback";
// Extension: VK_EXT_pipeline_creation_feedback
// Number: 193
// Type: device
// Author: GOOGLE
// Supported: supported
// Promoted to: VK_VERSION_1_3
// Unlocks:
//         Enum:
//             Name: VK_EXT_PIPELINE_CREATION_FEEDBACK_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_PIPELINE_CREATION_FEEDBACK_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_pipeline_creation_feedback&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO
//         Enum:
//             Name: VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT_EXT
//             Negative: false
//             Extends: VkPipelineCreationFeedbackFlagBits
//             Alias: VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT
//         Enum:
//             Name: VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT_EXT
//             Negative: false
//             Extends: VkPipelineCreationFeedbackFlagBits
//             Alias: VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT
//         Enum:
//             Name: VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT_EXT
//             Negative: false
//             Extends: VkPipelineCreationFeedbackFlagBits
//             Alias: VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT
//         Type:
//             Name: VkPipelineCreationFeedbackFlagBitsEXT
//         Type:
//             Name: VkPipelineCreationFeedbackFlagsEXT
//         Type:
//             Name: VkPipelineCreationFeedbackCreateInfoEXT
//         Type:
//             Name: VkPipelineCreationFeedbackEXT
pub const VK_GOOGLE_extension_194_name = "VK_GOOGLE_extension_194";
// Extension: VK_GOOGLE_extension_194
// Number: 194
// Type: invalid
// Author: GOOGLE
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_GOOGLE_EXTENSION_194_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_GOOGLE_EXTENSION_194_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_GOOGLE_extension_194&quot;
pub const VK_GOOGLE_extension_195_name = "VK_GOOGLE_extension_195";
// Extension: VK_GOOGLE_extension_195
// Number: 195
// Type: invalid
// Author: GOOGLE
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_GOOGLE_EXTENSION_195_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_GOOGLE_EXTENSION_195_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_GOOGLE_extension_195&quot;
pub const VK_GOOGLE_extension_196_name = "VK_GOOGLE_extension_196";
// Extension: VK_GOOGLE_extension_196
// Number: 196
// Type: invalid
// Author: GOOGLE
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_GOOGLE_EXTENSION_196_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_GOOGLE_EXTENSION_196_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_GOOGLE_extension_196&quot;
pub const VK_KHR_driver_properties_name = "VK_KHR_driver_properties";
// Extension: VK_KHR_driver_properties
// Number: 197
// Type: device
// Author: KHR
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_2
// Unlocks:
//         Enum:
//             Name: VK_KHR_DRIVER_PROPERTIES_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_DRIVER_PROPERTIES_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_driver_properties&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES
//         Enum:
//             Name: VK_MAX_DRIVER_NAME_SIZE_KHR
//             Negative: false
//             Alias: VK_MAX_DRIVER_NAME_SIZE
//         Enum:
//             Name: VK_MAX_DRIVER_INFO_SIZE_KHR
//             Negative: false
//             Alias: VK_MAX_DRIVER_INFO_SIZE
//         Type:
//             Name: VkDriverIdKHR
//         Enum:
//             Name: VK_DRIVER_ID_AMD_PROPRIETARY_KHR
//             Negative: false
//             Extends: VkDriverId
//             Alias: VK_DRIVER_ID_AMD_PROPRIETARY
//         Enum:
//             Name: VK_DRIVER_ID_AMD_OPEN_SOURCE_KHR
//             Negative: false
//             Extends: VkDriverId
//             Alias: VK_DRIVER_ID_AMD_OPEN_SOURCE
//         Enum:
//             Name: VK_DRIVER_ID_MESA_RADV_KHR
//             Negative: false
//             Extends: VkDriverId
//             Alias: VK_DRIVER_ID_MESA_RADV
//         Enum:
//             Name: VK_DRIVER_ID_NVIDIA_PROPRIETARY_KHR
//             Negative: false
//             Extends: VkDriverId
//             Alias: VK_DRIVER_ID_NVIDIA_PROPRIETARY
//         Enum:
//             Name: VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS_KHR
//             Negative: false
//             Extends: VkDriverId
//             Alias: VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS
//         Enum:
//             Name: VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA_KHR
//             Negative: false
//             Extends: VkDriverId
//             Alias: VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA
//         Enum:
//             Name: VK_DRIVER_ID_IMAGINATION_PROPRIETARY_KHR
//             Negative: false
//             Extends: VkDriverId
//             Alias: VK_DRIVER_ID_IMAGINATION_PROPRIETARY
//         Enum:
//             Name: VK_DRIVER_ID_QUALCOMM_PROPRIETARY_KHR
//             Negative: false
//             Extends: VkDriverId
//             Alias: VK_DRIVER_ID_QUALCOMM_PROPRIETARY
//         Enum:
//             Name: VK_DRIVER_ID_ARM_PROPRIETARY_KHR
//             Negative: false
//             Extends: VkDriverId
//             Alias: VK_DRIVER_ID_ARM_PROPRIETARY
//         Enum:
//             Name: VK_DRIVER_ID_GOOGLE_SWIFTSHADER_KHR
//             Negative: false
//             Extends: VkDriverId
//             Alias: VK_DRIVER_ID_GOOGLE_SWIFTSHADER
//         Enum:
//             Name: VK_DRIVER_ID_GGP_PROPRIETARY_KHR
//             Negative: false
//             Extends: VkDriverId
//             Alias: VK_DRIVER_ID_GGP_PROPRIETARY
//         Enum:
//             Name: VK_DRIVER_ID_BROADCOM_PROPRIETARY_KHR
//             Negative: false
//             Extends: VkDriverId
//             Alias: VK_DRIVER_ID_BROADCOM_PROPRIETARY
//         Type:
//             Name: VkConformanceVersionKHR
//         Type:
//             Name: VkPhysicalDeviceDriverPropertiesKHR
pub const VK_KHR_shader_float_controls_name = "VK_KHR_shader_float_controls";
// Extension: VK_KHR_shader_float_controls
// Number: 198
// Type: device
// Author: KHR
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_2
// Unlocks:
//         Enum:
//             Name: VK_KHR_SHADER_FLOAT_CONTROLS_SPEC_VERSION
//             Negative: false
//             Value: 4
//         Enum:
//             Name: VK_KHR_SHADER_FLOAT_CONTROLS_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_shader_float_controls&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES
//         Type:
//             Name: VkPhysicalDeviceFloatControlsPropertiesKHR
//         Type:
//             Name: VkShaderFloatControlsIndependenceKHR
//         Enum:
//             Name: VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY_KHR
//             Negative: false
//             Extends: VkShaderFloatControlsIndependence
//             Alias: VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY
//         Enum:
//             Name: VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL_KHR
//             Negative: false
//             Extends: VkShaderFloatControlsIndependence
//             Alias: VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL
//         Enum:
//             Name: VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE_KHR
//             Negative: false
//             Extends: VkShaderFloatControlsIndependence
//             Alias: VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE
pub const VK_NV_shader_subgroup_partitioned_name = "VK_NV_shader_subgroup_partitioned";
// Extension: VK_NV_shader_subgroup_partitioned
// Number: 199
// Type: device
// Author: NV
// Depends: VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NV_SHADER_SUBGROUP_PARTITIONED_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_NV_SHADER_SUBGROUP_PARTITIONED_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_shader_subgroup_partitioned&quot;
//         Enum:
//             Name: VK_SUBGROUP_FEATURE_PARTITIONED_BIT_NV
//             Negative: false
//             Bitpos: 8
//             Extends: VkSubgroupFeatureFlagBits
pub const VK_KHR_depth_stencil_resolve_name = "VK_KHR_depth_stencil_resolve";
// Extension: VK_KHR_depth_stencil_resolve
// Number: 200
// Type: device
// Author: KHR
// Depends: VK_KHR_create_renderpass2,VK_VERSION_1_2
// Supported: supported
// Promoted to: VK_VERSION_1_2
// Unlocks:
//         Enum:
//             Name: VK_KHR_DEPTH_STENCIL_RESOLVE_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_DEPTH_STENCIL_RESOLVE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_depth_stencil_resolve&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE
//         Type:
//             Name: VkSubpassDescriptionDepthStencilResolveKHR
//         Type:
//             Name: VkPhysicalDeviceDepthStencilResolvePropertiesKHR
//         Type:
//             Name: VkResolveModeFlagBitsKHR
//         Type:
//             Name: VkResolveModeFlagsKHR
//         Enum:
//             Name: VK_RESOLVE_MODE_NONE_KHR
//             Negative: false
//             Extends: VkResolveModeFlagBits
//             Alias: VK_RESOLVE_MODE_NONE
//         Enum:
//             Name: VK_RESOLVE_MODE_SAMPLE_ZERO_BIT_KHR
//             Negative: false
//             Extends: VkResolveModeFlagBits
//             Alias: VK_RESOLVE_MODE_SAMPLE_ZERO_BIT
//         Enum:
//             Name: VK_RESOLVE_MODE_AVERAGE_BIT_KHR
//             Negative: false
//             Extends: VkResolveModeFlagBits
//             Alias: VK_RESOLVE_MODE_AVERAGE_BIT
//         Enum:
//             Name: VK_RESOLVE_MODE_MIN_BIT_KHR
//             Negative: false
//             Extends: VkResolveModeFlagBits
//             Alias: VK_RESOLVE_MODE_MIN_BIT
//         Enum:
//             Name: VK_RESOLVE_MODE_MAX_BIT_KHR
//             Negative: false
//             Extends: VkResolveModeFlagBits
//             Alias: VK_RESOLVE_MODE_MAX_BIT
pub const VK_KHR_swapchain_mutable_format_name = "VK_KHR_swapchain_mutable_format";
// Extension: VK_KHR_swapchain_mutable_format
// Number: 201
// Type: device
// Author: KHR
// Depends: VK_KHR_swapchain+(VK_KHR_maintenance2,VK_VERSION_1_1)+(VK_KHR_image_format_list,VK_VERSION_1_2)
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_SWAPCHAIN_MUTABLE_FORMAT_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_SWAPCHAIN_MUTABLE_FORMAT_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_swapchain_mutable_format&quot;
//         Enum:
//             Name: VK_SWAPCHAIN_CREATE_MUTABLE_FORMAT_BIT_KHR
//             Negative: false
//             Bitpos: 2
//             Extends: VkSwapchainCreateFlagBitsKHR
pub const VK_NV_compute_shader_derivatives_name = "VK_NV_compute_shader_derivatives";
// Extension: VK_NV_compute_shader_derivatives
// Number: 202
// Type: device
// Author: NV
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_KHR_compute_shader_derivatives
// Unlocks:
//         Enum:
//             Name: VK_NV_COMPUTE_SHADER_DERIVATIVES_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_NV_COMPUTE_SHADER_DERIVATIVES_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_compute_shader_derivatives&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_KHR
//         Type:
//             Name: VkPhysicalDeviceComputeShaderDerivativesFeaturesNV
//         Feature:
//             Name: computeDerivativeGroupQuads,computeDerivativeGroupLinear
//             Struct: VkPhysicalDeviceComputeShaderDerivativesFeaturesNV
pub const VK_NV_mesh_shader_name = "VK_NV_mesh_shader";
// Extension: VK_NV_mesh_shader
// Number: 203
// Type: device
// Author: NV
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NV_MESH_SHADER_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_NV_MESH_SHADER_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_mesh_shader&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_SHADER_STAGE_TASK_BIT_NV
//             Negative: false
//             Extends: VkShaderStageFlagBits
//             Alias: VK_SHADER_STAGE_TASK_BIT_EXT
//         Enum:
//             Name: VK_SHADER_STAGE_MESH_BIT_NV
//             Negative: false
//             Extends: VkShaderStageFlagBits
//             Alias: VK_SHADER_STAGE_MESH_BIT_EXT
//         Enum:
//             Name: VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV
//             Negative: false
//             Extends: VkPipelineStageFlagBits
//             Alias: VK_PIPELINE_STAGE_TASK_SHADER_BIT_EXT
//         Enum:
//             Name: VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV
//             Negative: false
//             Extends: VkPipelineStageFlagBits
//             Alias: VK_PIPELINE_STAGE_MESH_SHADER_BIT_EXT
//         Command:
//             Name: vkCmdDrawMeshTasksNV
//         Command:
//             Name: vkCmdDrawMeshTasksIndirectNV
//         Type:
//             Name: VkPhysicalDeviceMeshShaderFeaturesNV
//         Type:
//             Name: VkPhysicalDeviceMeshShaderPropertiesNV
//         Type:
//             Name: VkDrawMeshTasksIndirectCommandNV
//         Feature:
//             Name: meshShader
//             Struct: VkPhysicalDeviceMeshShaderFeaturesNV
//     Depends: VK_VERSION_1_2,VK_KHR_draw_indirect_count,VK_AMD_draw_indirect_count
//         Command:
//             Name: vkCmdDrawMeshTasksIndirectCountNV
//     Depends: VK_EXT_device_generated_commands
//         Enum:
//             Name: VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_NV_EXT
//             Negative: false
//             Extends: VkIndirectCommandsTokenTypeEXT
//             Offset: 2
//         Enum:
//             Name: VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_COUNT_NV_EXT
//             Negative: false
//             Extends: VkIndirectCommandsTokenTypeEXT
//             Offset: 3
pub const VK_NV_fragment_shader_barycentric_name = "VK_NV_fragment_shader_barycentric";
// Extension: VK_NV_fragment_shader_barycentric
// Number: 204
// Type: device
// Author: NV
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_KHR_fragment_shader_barycentric
// Unlocks:
//         Enum:
//             Name: VK_NV_FRAGMENT_SHADER_BARYCENTRIC_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_NV_FRAGMENT_SHADER_BARYCENTRIC_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_fragment_shader_barycentric&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_NV
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR
//         Type:
//             Name: VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV
pub const VK_NV_shader_image_footprint_name = "VK_NV_shader_image_footprint";
// Extension: VK_NV_shader_image_footprint
// Number: 205
// Type: device
// Author: NV
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NV_SHADER_IMAGE_FOOTPRINT_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_NV_SHADER_IMAGE_FOOTPRINT_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_shader_image_footprint&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceShaderImageFootprintFeaturesNV
//         Feature:
//             Name: imageFootprint
//             Struct: VkPhysicalDeviceShaderImageFootprintFeaturesNV
pub const VK_NV_scissor_exclusive_name = "VK_NV_scissor_exclusive";
// Extension: VK_NV_scissor_exclusive
// Number: 206
// Type: device
// Author: NV
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NV_SCISSOR_EXCLUSIVE_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_NV_SCISSOR_EXCLUSIVE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_scissor_exclusive&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_ENABLE_NV
//             Negative: false
//             Extends: VkDynamicState
//             Offset: 0
//         Enum:
//             Name: VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_NV
//             Negative: false
//             Extends: VkDynamicState
//             Offset: 1
//         Type:
//             Name: VkPipelineViewportExclusiveScissorStateCreateInfoNV
//         Type:
//             Name: VkPhysicalDeviceExclusiveScissorFeaturesNV
//         Command:
//             Name: vkCmdSetExclusiveScissorEnableNV
//         Command:
//             Name: vkCmdSetExclusiveScissorNV
//         Feature:
//             Name: exclusiveScissor
//             Struct: VkPhysicalDeviceExclusiveScissorFeaturesNV
pub const VK_NV_device_diagnostic_checkpoints_name = "VK_NV_device_diagnostic_checkpoints";
// Extension: VK_NV_device_diagnostic_checkpoints
// Number: 207
// Type: device
// Author: NVIDIA
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NV_DEVICE_DIAGNOSTIC_CHECKPOINTS_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_NV_DEVICE_DIAGNOSTIC_CHECKPOINTS_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_device_diagnostic_checkpoints&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Type:
//             Name: VkQueueFamilyCheckpointPropertiesNV
//         Type:
//             Name: VkCheckpointDataNV
//         Command:
//             Name: vkCmdSetCheckpointNV
//         Command:
//             Name: vkGetQueueCheckpointDataNV
//     Depends: VK_VERSION_1_3,VK_KHR_synchronization2
//         Type:
//             Name: VkQueueFamilyCheckpointProperties2NV
//         Type:
//             Name: VkCheckpointData2NV
//         Command:
//             Name: vkGetQueueCheckpointData2NV
//         Enum:
//             Name: VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV
//             Negative: false
//             Extends: VkStructureType
//             Extnumber: 315
//             Offset: 8
//         Enum:
//             Name: VK_STRUCTURE_TYPE_CHECKPOINT_DATA_2_NV
//             Negative: false
//             Extends: VkStructureType
//             Extnumber: 315
//             Offset: 9
pub const VK_KHR_timeline_semaphore_name = "VK_KHR_timeline_semaphore";
// Extension: VK_KHR_timeline_semaphore
// Number: 208
// Type: device
// Author: KHR
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_2
// Unlocks:
//         Enum:
//             Name: VK_KHR_TIMELINE_SEMAPHORE_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_KHR_TIMELINE_SEMAPHORE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_timeline_semaphore&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO
//         Enum:
//             Name: VK_SEMAPHORE_TYPE_BINARY_KHR
//             Negative: false
//             Extends: VkSemaphoreType
//             Alias: VK_SEMAPHORE_TYPE_BINARY
//         Enum:
//             Name: VK_SEMAPHORE_TYPE_TIMELINE_KHR
//             Negative: false
//             Extends: VkSemaphoreType
//             Alias: VK_SEMAPHORE_TYPE_TIMELINE
//         Enum:
//             Name: VK_SEMAPHORE_WAIT_ANY_BIT_KHR
//             Negative: false
//             Extends: VkSemaphoreWaitFlagBits
//             Alias: VK_SEMAPHORE_WAIT_ANY_BIT
//         Type:
//             Name: VkSemaphoreTypeKHR
//         Type:
//             Name: VkPhysicalDeviceTimelineSemaphoreFeaturesKHR
//         Type:
//             Name: VkPhysicalDeviceTimelineSemaphorePropertiesKHR
//         Type:
//             Name: VkSemaphoreTypeCreateInfoKHR
//         Type:
//             Name: VkTimelineSemaphoreSubmitInfoKHR
//         Type:
//             Name: VkSemaphoreWaitFlagBitsKHR
//         Type:
//             Name: VkSemaphoreWaitFlagsKHR
//         Type:
//             Name: VkSemaphoreWaitInfoKHR
//         Type:
//             Name: VkSemaphoreSignalInfoKHR
//         Command:
//             Name: vkGetSemaphoreCounterValueKHR
//         Command:
//             Name: vkWaitSemaphoresKHR
//         Command:
//             Name: vkSignalSemaphoreKHR
//         Feature:
//             Name: timelineSemaphore
//             Struct: VkPhysicalDeviceTimelineSemaphoreFeaturesKHR
pub const VK_EXT_present_timing_name = "VK_EXT_present_timing";
// Extension: VK_EXT_present_timing
// Number: 209
// Type: device
// Author: EXT
// Depends: VK_KHR_swapchain+VK_KHR_present_id2+VK_KHR_get_surface_capabilities2+VK_KHR_calibrated_timestamps
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_PRESENT_TIMING_SPEC_VERSION
//             Negative: false
//             Value: 3
//         Enum:
//             Name: VK_EXT_PRESENT_TIMING_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_present_timing&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_TIMING_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SWAPCHAIN_TIMING_PROPERTIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SWAPCHAIN_TIME_DOMAIN_PROPERTIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PRESENT_TIMINGS_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PRESENT_TIMING_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 4
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PAST_PRESENTATION_TIMING_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 5
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PAST_PRESENTATION_TIMING_PROPERTIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 6
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PAST_PRESENTATION_TIMING_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 7
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PRESENT_TIMING_SURFACE_CAPABILITIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 8
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SWAPCHAIN_CALIBRATED_TIMESTAMP_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 9
//         Enum:
//             Name: VK_TIME_DOMAIN_PRESENT_STAGE_LOCAL_EXT
//             Negative: false
//             Extends: VkTimeDomainKHR
//             Offset: 0
//         Enum:
//             Name: VK_TIME_DOMAIN_SWAPCHAIN_LOCAL_EXT
//             Negative: false
//             Extends: VkTimeDomainKHR
//             Offset: 1
//         Enum:
//             Name: VK_ERROR_PRESENT_TIMING_QUEUE_FULL_EXT
//             Negative: true
//             Extends: VkResult
//             Offset: 0
//         Enum:
//             Name: VK_SWAPCHAIN_CREATE_PRESENT_TIMING_BIT_EXT
//             Negative: false
//             Bitpos: 9
//             Extends: VkSwapchainCreateFlagBitsKHR
//         Type:
//             Name: VkPhysicalDevicePresentTimingFeaturesEXT
//         Type:
//             Name: VkPresentTimingSurfaceCapabilitiesEXT
//         Type:
//             Name: VkSwapchainCalibratedTimestampInfoEXT
//         Type:
//             Name: VkSwapchainTimingPropertiesEXT
//         Type:
//             Name: VkSwapchainTimeDomainPropertiesEXT
//         Type:
//             Name: VkPastPresentationTimingInfoEXT
//         Type:
//             Name: VkPastPresentationTimingPropertiesEXT
//         Type:
//             Name: VkPastPresentationTimingEXT
//         Type:
//             Name: VkPresentTimingsInfoEXT
//         Type:
//             Name: VkPresentTimingInfoEXT
//         Type:
//             Name: VkPresentStageTimeEXT
//         Type:
//             Name: VkPresentStageFlagBitsEXT
//         Type:
//             Name: VkPresentStageFlagsEXT
//         Type:
//             Name: VkPresentTimingInfoFlagBitsEXT
//         Type:
//             Name: VkPresentTimingInfoFlagsEXT
//         Type:
//             Name: VkPastPresentationTimingFlagBitsEXT
//         Type:
//             Name: VkPastPresentationTimingFlagsEXT
//         Command:
//             Name: vkSetSwapchainPresentTimingQueueSizeEXT
//         Command:
//             Name: vkGetSwapchainTimingPropertiesEXT
//         Command:
//             Name: vkGetSwapchainTimeDomainPropertiesEXT
//         Command:
//             Name: vkGetPastPresentationTimingEXT
//         Feature:
//             Name: presentTiming
//             Struct: VkPhysicalDevicePresentTimingFeaturesEXT
pub const VK_INTEL_shader_integer_functions2_name = "VK_INTEL_shader_integer_functions2";
// Extension: VK_INTEL_shader_integer_functions2
// Number: 210
// Type: device
// Author: INTEL
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_INTEL_SHADER_INTEGER_FUNCTIONS_2_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_INTEL_SHADER_INTEGER_FUNCTIONS_2_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_INTEL_shader_integer_functions2&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL
//         Feature:
//             Name: shaderIntegerFunctions2
//             Struct: VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL
pub const VK_INTEL_performance_query_name = "VK_INTEL_performance_query";
// Extension: VK_INTEL_performance_query
// Number: 211
// Type: device
// Author: INTEL
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_INTEL_PERFORMANCE_QUERY_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_INTEL_PERFORMANCE_QUERY_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_INTEL_performance_query&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO_INTEL
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL
//         Enum:
//             Name: VK_STRUCTURE_TYPE_INITIALIZE_PERFORMANCE_API_INFO_INTEL
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PERFORMANCE_MARKER_INFO_INTEL
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PERFORMANCE_STREAM_MARKER_INFO_INTEL
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PERFORMANCE_OVERRIDE_INFO_INTEL
//             Negative: false
//             Extends: VkStructureType
//             Offset: 4
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL
//             Negative: false
//             Extends: VkStructureType
//             Offset: 5
//         Enum:
//             Name: VK_QUERY_TYPE_PERFORMANCE_QUERY_INTEL
//             Negative: false
//             Extends: VkQueryType
//             Offset: 0
//         Enum:
//             Name: VK_OBJECT_TYPE_PERFORMANCE_CONFIGURATION_INTEL
//             Negative: false
//             Extends: VkObjectType
//             Offset: 0
//         Type:
//             Name: VkPerformanceConfigurationTypeINTEL
//         Type:
//             Name: VkQueryPoolSamplingModeINTEL
//         Type:
//             Name: VkPerformanceOverrideTypeINTEL
//         Type:
//             Name: VkPerformanceParameterTypeINTEL
//         Type:
//             Name: VkPerformanceValueTypeINTEL
//         Type:
//             Name: VkPerformanceValueDataINTEL
//         Type:
//             Name: VkPerformanceValueINTEL
//         Type:
//             Name: VkInitializePerformanceApiInfoINTEL
//         Type:
//             Name: VkQueryPoolCreateInfoINTEL
//         Type:
//             Name: VkQueryPoolPerformanceQueryCreateInfoINTEL
//         Type:
//             Name: VkPerformanceMarkerInfoINTEL
//         Type:
//             Name: VkPerformanceStreamMarkerInfoINTEL
//         Type:
//             Name: VkPerformanceOverrideInfoINTEL
//         Type:
//             Name: VkPerformanceConfigurationAcquireInfoINTEL
//         Type:
//             Name: VkPerformanceConfigurationINTEL
//         Command:
//             Name: vkInitializePerformanceApiINTEL
//         Command:
//             Name: vkUninitializePerformanceApiINTEL
//         Command:
//             Name: vkCmdSetPerformanceMarkerINTEL
//         Command:
//             Name: vkCmdSetPerformanceStreamMarkerINTEL
//         Command:
//             Name: vkCmdSetPerformanceOverrideINTEL
//         Command:
//             Name: vkAcquirePerformanceConfigurationINTEL
//         Command:
//             Name: vkReleasePerformanceConfigurationINTEL
//         Command:
//             Name: vkQueueSetPerformanceConfigurationINTEL
//         Command:
//             Name: vkGetPerformanceParameterINTEL
pub const VK_KHR_vulkan_memory_model_name = "VK_KHR_vulkan_memory_model";
// Extension: VK_KHR_vulkan_memory_model
// Number: 212
// Type: device
// Author: KHR
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_2
// Unlocks:
//         Enum:
//             Name: VK_KHR_VULKAN_MEMORY_MODEL_SPEC_VERSION
//             Negative: false
//             Value: 3
//         Enum:
//             Name: VK_KHR_VULKAN_MEMORY_MODEL_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_vulkan_memory_model&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES
//         Type:
//             Name: VkPhysicalDeviceVulkanMemoryModelFeaturesKHR
//         Feature:
//             Name: vulkanMemoryModel
//             Struct: VkPhysicalDeviceVulkanMemoryModelFeaturesKHR
pub const VK_EXT_pci_bus_info_name = "VK_EXT_pci_bus_info";
// Extension: VK_EXT_pci_bus_info
// Number: 213
// Type: device
// Author: EXT
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_PCI_BUS_INFO_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_EXT_PCI_BUS_INFO_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_pci_bus_info&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDevicePCIBusInfoPropertiesEXT
pub const VK_AMD_display_native_hdr_name = "VK_AMD_display_native_hdr";
// Extension: VK_AMD_display_native_hdr
// Number: 214
// Type: device
// Author: AMD
// Depends: (VK_KHR_get_physical_device_properties2,VK_VERSION_1_1)+VK_KHR_get_surface_capabilities2+VK_KHR_swapchain
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_AMD_DISPLAY_NATIVE_HDR_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_AMD_DISPLAY_NATIVE_HDR_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_display_native_hdr&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_COLOR_SPACE_DISPLAY_NATIVE_AMD
//             Negative: false
//             Extends: VkColorSpaceKHR
//             Offset: 0
//         Type:
//             Name: VkDisplayNativeHdrSurfaceCapabilitiesAMD
//         Type:
//             Name: VkSwapchainDisplayNativeHdrCreateInfoAMD
//         Command:
//             Name: vkSetLocalDimmingAMD
pub const VK_FUCHSIA_imagepipe_surface_name = "VK_FUCHSIA_imagepipe_surface";
// Extension: VK_FUCHSIA_imagepipe_surface
// Number: 215
// Type: instance
// Author: FUCHSIA
// Depends: VK_KHR_surface
// Platform: fuchsia
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_FUCHSIA_IMAGEPIPE_SURFACE_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_FUCHSIA_IMAGEPIPE_SURFACE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_FUCHSIA_imagepipe_surface&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkImagePipeSurfaceCreateFlagsFUCHSIA
//         Type:
//             Name: VkImagePipeSurfaceCreateInfoFUCHSIA
//         Command:
//             Name: vkCreateImagePipeSurfaceFUCHSIA
pub const VK_KHR_shader_terminate_invocation_name = "VK_KHR_shader_terminate_invocation";
// Extension: VK_KHR_shader_terminate_invocation
// Number: 216
// Type: device
// Author: KHR
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_3
// Unlocks:
//         Enum:
//             Name: VK_KHR_SHADER_TERMINATE_INVOCATION_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_SHADER_TERMINATE_INVOCATION_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_shader_terminate_invocation&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES
//         Type:
//             Name: VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR
//         Feature:
//             Name: shaderTerminateInvocation
//             Struct: VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR
pub const VK_GOOGLE_extension_217_name = "VK_GOOGLE_extension_217";
// Extension: VK_GOOGLE_extension_217
// Number: 217
// Type: invalid
// Author: GOOGLE
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_GOOGLE_EXTENSION_217_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_GOOGLE_EXTENSION_217_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_GOOGLE_extension_217&quot;
pub const VK_EXT_metal_surface_name = "VK_EXT_metal_surface";
// Extension: VK_EXT_metal_surface
// Number: 218
// Type: instance
// Author: EXT
// Depends: VK_KHR_surface
// Platform: metal
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_METAL_SURFACE_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_METAL_SURFACE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_metal_surface&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_METAL_SURFACE_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkMetalSurfaceCreateFlagsEXT
//         Type:
//             Name: VkMetalSurfaceCreateInfoEXT
//         Command:
//             Name: vkCreateMetalSurfaceEXT
//         Type:
//             Name: CAMetalLayer
pub const VK_EXT_fragment_density_map_name = "VK_EXT_fragment_density_map";
// Extension: VK_EXT_fragment_density_map
// Number: 219
// Type: device
// Author: EXT
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_FRAGMENT_DENSITY_MAP_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_EXT_FRAGMENT_DENSITY_MAP_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_fragment_density_map&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT
//             Negative: false
//             Bitpos: 14
//             Extends: VkImageCreateFlagBits
//         Enum:
//             Name: VK_IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT
//             Negative: false
//             Extends: VkImageLayout
//             Offset: 0
//         Enum:
//             Name: VK_ACCESS_FRAGMENT_DENSITY_MAP_READ_BIT_EXT
//             Negative: false
//             Bitpos: 24
//             Extends: VkAccessFlagBits
//         Enum:
//             Name: VK_FORMAT_FEATURE_FRAGMENT_DENSITY_MAP_BIT_EXT
//             Negative: false
//             Bitpos: 24
//             Extends: VkFormatFeatureFlagBits
//         Enum:
//             Name: VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT
//             Negative: false
//             Bitpos: 9
//             Extends: VkImageUsageFlagBits
//         Enum:
//             Name: VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT
//             Negative: false
//             Bitpos: 0
//             Extends: VkImageViewCreateFlagBits
//         Enum:
//             Name: VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT
//             Negative: false
//             Bitpos: 23
//             Extends: VkPipelineStageFlagBits
//         Enum:
//             Name: VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT
//             Negative: false
//             Bitpos: 0
//             Extends: VkSamplerCreateFlagBits
//         Enum:
//             Name: VK_SAMPLER_CREATE_SUBSAMPLED_COARSE_RECONSTRUCTION_BIT_EXT
//             Negative: false
//             Bitpos: 1
//             Extends: VkSamplerCreateFlagBits
//         Type:
//             Name: VkPhysicalDeviceFragmentDensityMapFeaturesEXT
//         Type:
//             Name: VkPhysicalDeviceFragmentDensityMapPropertiesEXT
//         Type:
//             Name: VkRenderPassFragmentDensityMapCreateInfoEXT
//         Feature:
//             Name: fragmentDensityMap
//             Struct: VkPhysicalDeviceFragmentDensityMapFeaturesEXT
//     Depends: VK_KHR_format_feature_flags2,VK_VERSION_1_3
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_FRAGMENT_DENSITY_MAP_BIT_EXT
//             Negative: false
//             Bitpos: 24
//             Extends: VkFormatFeatureFlagBits2
//     Depends: VK_VERSION_1_3,VK_KHR_dynamic_rendering
//         Enum:
//             Name: VK_PIPELINE_CREATE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT
//             Negative: false
//             Bitpos: 22
//             Extends: VkPipelineCreateFlagBits
//         Enum:
//             Name: VK_PIPELINE_RASTERIZATION_STATE_CREATE_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT
//             Negative: false
//             Extends: VkPipelineCreateFlagBits
//             Alias: VK_PIPELINE_CREATE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT
//         Enum:
//             Name: VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Extnumber: 45
//             Offset: 7
//         Type:
//             Name: VkRenderingFragmentDensityMapAttachmentInfoEXT
pub const VK_EXT_extension_220_name = "VK_EXT_extension_220";
// Extension: VK_EXT_extension_220
// Number: 220
// Type: invalid
// Author: EXT
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_220_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_220_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_220&quot;
pub const VK_KHR_extension_221_name = "VK_KHR_extension_221";
// Extension: VK_KHR_extension_221
// Number: 221
// Type: invalid
// Author: KHR
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_KHR_EXTENSION_221_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_KHR_EXTENSION_221_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_extension_221&quot;
//         Enum:
//             Name: VK_RENDER_PASS_CREATE_RESERVED_0_BIT_KHR
//             Negative: false
//             Bitpos: 0
//             Extends: VkRenderPassCreateFlagBits
pub const VK_EXT_scalar_block_layout_name = "VK_EXT_scalar_block_layout";
// Extension: VK_EXT_scalar_block_layout
// Number: 222
// Type: device
// Author: EXT
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_2
// Unlocks:
//         Enum:
//             Name: VK_EXT_SCALAR_BLOCK_LAYOUT_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_SCALAR_BLOCK_LAYOUT_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_scalar_block_layout&quot;
//         Type:
//             Name: VkPhysicalDeviceScalarBlockLayoutFeaturesEXT
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES
//         Feature:
//             Name: scalarBlockLayout
//             Struct: VkPhysicalDeviceScalarBlockLayoutFeaturesEXT
pub const VK_EXT_extension_223_name = "VK_EXT_extension_223";
// Extension: VK_EXT_extension_223
// Number: 223
// Type: invalid
// Author: EXT
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_223_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_223_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_223&quot;
pub const VK_GOOGLE_hlsl_functionality1_name = "VK_GOOGLE_hlsl_functionality1";
// Extension: VK_GOOGLE_hlsl_functionality1
// Number: 224
// Type: device
// Author: GOOGLE
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_GOOGLE_HLSL_FUNCTIONALITY_1_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_GOOGLE_HLSL_FUNCTIONALITY_1_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_GOOGLE_hlsl_functionality1&quot;
//         Enum:
//             Name: VK_GOOGLE_HLSL_FUNCTIONALITY1_SPEC_VERSION
//             Negative: false
//             Alias: VK_GOOGLE_HLSL_FUNCTIONALITY_1_SPEC_VERSION
//         Enum:
//             Name: VK_GOOGLE_HLSL_FUNCTIONALITY1_EXTENSION_NAME
//             Negative: false
//             Alias: VK_GOOGLE_HLSL_FUNCTIONALITY_1_EXTENSION_NAME
pub const VK_GOOGLE_decorate_string_name = "VK_GOOGLE_decorate_string";
// Extension: VK_GOOGLE_decorate_string
// Number: 225
// Type: device
// Author: GOOGLE
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_GOOGLE_DECORATE_STRING_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_GOOGLE_DECORATE_STRING_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_GOOGLE_decorate_string&quot;
pub const VK_EXT_subgroup_size_control_name = "VK_EXT_subgroup_size_control";
// Extension: VK_EXT_subgroup_size_control
// Number: 226
// Type: device
// Author: EXT
// Depends: VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_3
// Unlocks:
//         Enum:
//             Name: VK_EXT_SUBGROUP_SIZE_CONTROL_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_EXT_SUBGROUP_SIZE_CONTROL_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_subgroup_size_control&quot;
//         Type:
//             Name: VkPhysicalDeviceSubgroupSizeControlFeaturesEXT
//         Type:
//             Name: VkPhysicalDeviceSubgroupSizeControlPropertiesEXT
//         Type:
//             Name: VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES
//         Enum:
//             Name: VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT
//             Negative: false
//             Extends: VkPipelineShaderStageCreateFlagBits
//             Alias: VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT
//         Enum:
//             Name: VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT
//             Negative: false
//             Extends: VkPipelineShaderStageCreateFlagBits
//             Alias: VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT
//         Feature:
//             Name: subgroupSizeControl
//             Struct: VkPhysicalDeviceSubgroupSizeControlFeatures
//         Feature:
//             Name: computeFullSubgroups
//             Struct: VkPhysicalDeviceSubgroupSizeControlFeatures
pub const VK_KHR_fragment_shading_rate_name = "VK_KHR_fragment_shading_rate";
// Extension: VK_KHR_fragment_shading_rate
// Number: 227
// Type: device
// Author: KHR
// Depends: ((VK_KHR_get_physical_device_properties2,VK_VERSION_1_1)+VK_KHR_create_renderpass2),VK_VERSION_1_2
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_FRAGMENT_SHADING_RATE_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_KHR_FRAGMENT_SHADING_RATE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_fragment_shading_rate&quot;
//         Type:
//             Name: VkFragmentShadingRateCombinerOpKHR
//         Type:
//             Name: VkFragmentShadingRateAttachmentInfoKHR
//         Type:
//             Name: VkPipelineFragmentShadingRateStateCreateInfoKHR
//         Type:
//             Name: VkPhysicalDeviceFragmentShadingRateFeaturesKHR
//         Type:
//             Name: VkPhysicalDeviceFragmentShadingRatePropertiesKHR
//         Type:
//             Name: VkPhysicalDeviceFragmentShadingRateKHR
//         Command:
//             Name: vkGetPhysicalDeviceFragmentShadingRatesKHR
//         Command:
//             Name: vkCmdSetFragmentShadingRateKHR
//         Enum:
//             Name: VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR
//             Negative: false
//             Extends: VkImageLayout
//             Extnumber: 165
//             Offset: 3
//         Enum:
//             Name: VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR
//             Negative: false
//             Extends: VkDynamicState
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 4
//         Enum:
//             Name: VK_ACCESS_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR
//             Negative: false
//             Bitpos: 23
//             Extends: VkAccessFlagBits
//         Enum:
//             Name: VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR
//             Negative: false
//             Bitpos: 8
//             Extends: VkImageUsageFlagBits
//         Enum:
//             Name: VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR
//             Negative: false
//             Bitpos: 22
//             Extends: VkPipelineStageFlagBits
//         Enum:
//             Name: VK_FORMAT_FEATURE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR
//             Negative: false
//             Bitpos: 30
//             Extends: VkFormatFeatureFlagBits
//         Feature:
//             Name: pipelineFragmentShadingRate
//             Struct: VkPhysicalDeviceFragmentShadingRateFeaturesKHR
//     Depends: VK_KHR_format_feature_flags2,VK_VERSION_1_3
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR
//             Negative: false
//             Bitpos: 30
//             Extends: VkFormatFeatureFlagBits2
//     Depends: VK_VERSION_1_3,VK_KHR_dynamic_rendering
//         Enum:
//             Name: VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Extnumber: 45
//             Offset: 6
//     Depends: VK_VERSION_1_3,VK_KHR_dynamic_rendering
//         Enum:
//             Name: VK_PIPELINE_CREATE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR
//             Negative: false
//             Bitpos: 21
//             Extends: VkPipelineCreateFlagBits
//         Enum:
//             Name: VK_PIPELINE_RASTERIZATION_STATE_CREATE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR
//             Negative: false
//             Extends: VkPipelineCreateFlagBits
//             Alias: VK_PIPELINE_CREATE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR
//         Type:
//             Name: VkRenderingFragmentShadingRateAttachmentInfoKHR
pub const VK_AMD_shader_core_properties2_name = "VK_AMD_shader_core_properties2";
// Extension: VK_AMD_shader_core_properties2
// Number: 228
// Type: device
// Author: AMD
// Depends: VK_AMD_shader_core_properties
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_AMD_SHADER_CORE_PROPERTIES_2_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_AMD_SHADER_CORE_PROPERTIES_2_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_shader_core_properties2&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceShaderCoreProperties2AMD
//         Type:
//             Name: VkShaderCorePropertiesFlagBitsAMD
//         Type:
//             Name: VkShaderCorePropertiesFlagsAMD
pub const VK_AMD_extension_229_name = "VK_AMD_extension_229";
// Extension: VK_AMD_extension_229
// Number: 229
// Type: invalid
// Author: AMD
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_AMD_EXTENSION_229_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_AMD_EXTENSION_229_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_extension_229&quot;
pub const VK_AMD_device_coherent_memory_name = "VK_AMD_device_coherent_memory";
// Extension: VK_AMD_device_coherent_memory
// Number: 230
// Type: device
// Author: AMD
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_AMD_DEVICE_COHERENT_MEMORY_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_AMD_DEVICE_COHERENT_MEMORY_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_device_coherent_memory&quot;
//         Enum:
//             Name: VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD
//             Negative: false
//             Bitpos: 6
//             Extends: VkMemoryPropertyFlagBits
//         Enum:
//             Name: VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD
//             Negative: false
//             Bitpos: 7
//             Extends: VkMemoryPropertyFlagBits
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceCoherentMemoryFeaturesAMD
//         Feature:
//             Name: deviceCoherentMemory
//             Struct: VkPhysicalDeviceCoherentMemoryFeaturesAMD
pub const VK_AMD_extension_231_name = "VK_AMD_extension_231";
// Extension: VK_AMD_extension_231
// Number: 231
// Type: invalid
// Author: AMD
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_AMD_EXTENSION_231_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_AMD_EXTENSION_231_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_extension_231&quot;
pub const VK_AMD_extension_232_name = "VK_AMD_extension_232";
// Extension: VK_AMD_extension_232
// Number: 232
// Type: invalid
// Author: AMD
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_AMD_EXTENSION_232_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_AMD_EXTENSION_232_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_extension_232&quot;
pub const VK_KHR_dynamic_rendering_local_read_name = "VK_KHR_dynamic_rendering_local_read";
// Extension: VK_KHR_dynamic_rendering_local_read
// Number: 233
// Type: device
// Author: AMD
// Depends: VK_KHR_dynamic_rendering,VK_VERSION_1_3
// Supported: supported
// Promoted to: VK_VERSION_1_4
// Unlocks:
//         Enum:
//             Name: VK_KHR_DYNAMIC_RENDERING_LOCAL_READ_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_DYNAMIC_RENDERING_LOCAL_READ_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_dynamic_rendering_local_read&quot;
//         Enum:
//             Name: VK_IMAGE_LAYOUT_RENDERING_LOCAL_READ_KHR
//             Negative: false
//             Extends: VkImageLayout
//             Alias: VK_IMAGE_LAYOUT_RENDERING_LOCAL_READ
//         Command:
//             Name: vkCmdSetRenderingAttachmentLocationsKHR
//         Command:
//             Name: vkCmdSetRenderingInputAttachmentIndicesKHR
//         Type:
//             Name: VkPhysicalDeviceDynamicRenderingLocalReadFeaturesKHR
//         Type:
//             Name: VkRenderingAttachmentLocationInfoKHR
//         Type:
//             Name: VkRenderingInputAttachmentIndexInfoKHR
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_LOCAL_READ_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_LOCAL_READ_FEATURES
//         Enum:
//             Name: VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_LOCATION_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_LOCATION_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_RENDERING_INPUT_ATTACHMENT_INDEX_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_RENDERING_INPUT_ATTACHMENT_INDEX_INFO
//         Feature:
//             Name: dynamicRenderingLocalRead
//             Struct: VkPhysicalDeviceDynamicRenderingLocalReadFeaturesKHR
pub const VK_AMD_extension_234_name = "VK_AMD_extension_234";
// Extension: VK_AMD_extension_234
// Number: 234
// Type: invalid
// Author: AMD
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_AMD_EXTENSION_234_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_AMD_EXTENSION_234_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_extension_234&quot;
pub const VK_EXT_shader_image_atomic_int64_name = "VK_EXT_shader_image_atomic_int64";
// Extension: VK_EXT_shader_image_atomic_int64
// Number: 235
// Type: device
// Author: EXT
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_SHADER_IMAGE_ATOMIC_INT64_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_SHADER_IMAGE_ATOMIC_INT64_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_shader_image_atomic_int64&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT
//         Feature:
//             Name: shaderInt64
//             Struct: VkPhysicalDeviceFeatures
//         Feature:
//             Name: shaderImageInt64Atomics
//             Struct: VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT
pub const VK_KHR_shader_quad_control_name = "VK_KHR_shader_quad_control";
// Extension: VK_KHR_shader_quad_control
// Number: 236
// Type: device
// Author: KHR
// Depends: ((VK_VERSION_1_1+VK_KHR_vulkan_memory_model),VK_VERSION_1_2)+VK_KHR_shader_maximal_reconvergence
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_SHADER_QUAD_CONTROL_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_SHADER_QUAD_CONTROL_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_shader_quad_control&quot;
//         Type:
//             Name: VkPhysicalDeviceShaderQuadControlFeaturesKHR
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_QUAD_CONTROL_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Feature:
//             Name: shaderQuadControl
//             Struct: VkPhysicalDeviceShaderQuadControlFeaturesKHR
pub const VK_KHR_spirv_1_4_name = "VK_KHR_spirv_1_4";
// Extension: VK_KHR_spirv_1_4
// Number: 237
// Type: device
// Author: KHR
// Depends: VK_VERSION_1_1+VK_KHR_shader_float_controls
// Supported: supported
// Promoted to: VK_VERSION_1_2
// Unlocks:
//         Enum:
//             Name: VK_KHR_SPIRV_1_4_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_SPIRV_1_4_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_spirv_1_4&quot;
pub const VK_EXT_memory_budget_name = "VK_EXT_memory_budget";
// Extension: VK_EXT_memory_budget
// Number: 238
// Type: device
// Author: EXT
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_MEMORY_BUDGET_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_MEMORY_BUDGET_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_memory_budget&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceMemoryBudgetPropertiesEXT
pub const VK_EXT_memory_priority_name = "VK_EXT_memory_priority";
// Extension: VK_EXT_memory_priority
// Number: 239
// Type: device
// Author: EXT
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_MEMORY_PRIORITY_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_MEMORY_PRIORITY_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_memory_priority&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Type:
//             Name: VkPhysicalDeviceMemoryPriorityFeaturesEXT
//         Type:
//             Name: VkMemoryPriorityAllocateInfoEXT
//         Feature:
//             Name: memoryPriority
//             Struct: VkPhysicalDeviceMemoryPriorityFeaturesEXT
pub const VK_KHR_surface_protected_capabilities_name = "VK_KHR_surface_protected_capabilities";
// Extension: VK_KHR_surface_protected_capabilities
// Number: 240
// Type: instance
// Author: KHR
// Depends: VK_VERSION_1_1+VK_KHR_get_surface_capabilities2
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_SURFACE_PROTECTED_CAPABILITIES_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_SURFACE_PROTECTED_CAPABILITIES_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_surface_protected_capabilities&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkSurfaceProtectedCapabilitiesKHR
pub const VK_NV_dedicated_allocation_image_aliasing_name = "VK_NV_dedicated_allocation_image_aliasing";
// Extension: VK_NV_dedicated_allocation_image_aliasing
// Number: 241
// Type: device
// Author: NVIDIA
// Depends: (VK_KHR_dedicated_allocation+VK_KHR_get_physical_device_properties2),VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NV_DEDICATED_ALLOCATION_IMAGE_ALIASING_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_NV_DEDICATED_ALLOCATION_IMAGE_ALIASING_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_dedicated_allocation_image_aliasing&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV
//         Feature:
//             Name: dedicatedAllocationImageAliasing
//             Struct: VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV
pub const VK_KHR_separate_depth_stencil_layouts_name = "VK_KHR_separate_depth_stencil_layouts";
// Extension: VK_KHR_separate_depth_stencil_layouts
// Number: 242
// Type: device
// Author: KHR
// Depends: ((VK_KHR_get_physical_device_properties2,VK_VERSION_1_1)+VK_KHR_create_renderpass2),VK_VERSION_1_2
// Supported: supported
// Promoted to: VK_VERSION_1_2
// Unlocks:
//         Enum:
//             Name: VK_KHR_SEPARATE_DEPTH_STENCIL_LAYOUTS_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_SEPARATE_DEPTH_STENCIL_LAYOUTS_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_separate_depth_stencil_layouts&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES
//         Enum:
//             Name: VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT
//         Enum:
//             Name: VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT
//         Enum:
//             Name: VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL_KHR
//             Negative: false
//             Extends: VkImageLayout
//             Alias: VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL
//         Enum:
//             Name: VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL_KHR
//             Negative: false
//             Extends: VkImageLayout
//             Alias: VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL
//         Enum:
//             Name: VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL_KHR
//             Negative: false
//             Extends: VkImageLayout
//             Alias: VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL
//         Enum:
//             Name: VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL_KHR
//             Negative: false
//             Extends: VkImageLayout
//             Alias: VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL
//         Type:
//             Name: VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR
//         Type:
//             Name: VkAttachmentReferenceStencilLayoutKHR
//         Type:
//             Name: VkAttachmentDescriptionStencilLayoutKHR
//         Feature:
//             Name: separateDepthStencilLayouts
//             Struct: VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR
pub const VK_INTEL_extension_243_name = "VK_INTEL_extension_243";
// Extension: VK_INTEL_extension_243
// Number: 243
// Type: invalid
// Author: INTEL
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_INTEL_EXTENSION_243_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_INTEL_EXTENSION_243_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_INTEL_extension_243&quot;
//         Enum:
//             Name: VK_ACCESS_2_RESERVED_46_BIT_INTEL
//             Negative: false
//             Bitpos: 46
//             Extends: VkAccessFlagBits2
pub const VK_MESA_extension_244_name = "VK_MESA_extension_244";
// Extension: VK_MESA_extension_244
// Number: 244
// Type: invalid
// Author: MESA
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_MESA_EXTENSION_244_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_MESA_EXTENSION_244_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_MESA_extension_244&quot;
pub const VK_EXT_buffer_device_address_name = "VK_EXT_buffer_device_address";
// Extension: VK_EXT_buffer_device_address
// Number: 245
// Type: device
// Author: NV
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Deprecated by: VK_KHR_buffer_device_address
// Unlocks:
//         Enum:
//             Name: VK_EXT_BUFFER_DEVICE_ADDRESS_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_EXT_BUFFER_DEVICE_ADDRESS_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_buffer_device_address&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_ADDRESS_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT
//         Enum:
//             Name: VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_EXT
//             Negative: false
//             Extends: VkBufferUsageFlagBits
//             Alias: VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT
//         Enum:
//             Name: VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT
//             Negative: false
//             Extends: VkBufferCreateFlagBits
//             Alias: VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT
//         Enum:
//             Name: VK_ERROR_INVALID_DEVICE_ADDRESS_EXT
//             Negative: false
//             Extends: VkResult
//             Alias: VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS
//         Type:
//             Name: VkPhysicalDeviceBufferAddressFeaturesEXT
//         Type:
//             Name: VkPhysicalDeviceBufferDeviceAddressFeaturesEXT
//         Type:
//             Name: VkBufferDeviceAddressInfoEXT
//         Type:
//             Name: VkBufferDeviceAddressCreateInfoEXT
//         Command:
//             Name: vkGetBufferDeviceAddressEXT
//         Feature:
//             Name: bufferDeviceAddress
//             Struct: VkPhysicalDeviceBufferDeviceAddressFeaturesEXT
pub const VK_EXT_tooling_info_name = "VK_EXT_tooling_info";
// Extension: VK_EXT_tooling_info
// Number: 246
// Type: device
// Author: EXT
// Supported: supported
// Promoted to: VK_VERSION_1_3
// Unlocks:
//         Enum:
//             Name: VK_EXT_TOOLING_INFO_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_TOOLING_INFO_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_tooling_info&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES
//         Enum:
//             Name: VK_TOOL_PURPOSE_VALIDATION_BIT_EXT
//             Negative: false
//             Extends: VkToolPurposeFlagBits
//             Alias: VK_TOOL_PURPOSE_VALIDATION_BIT
//         Enum:
//             Name: VK_TOOL_PURPOSE_PROFILING_BIT_EXT
//             Negative: false
//             Extends: VkToolPurposeFlagBits
//             Alias: VK_TOOL_PURPOSE_PROFILING_BIT
//         Enum:
//             Name: VK_TOOL_PURPOSE_TRACING_BIT_EXT
//             Negative: false
//             Extends: VkToolPurposeFlagBits
//             Alias: VK_TOOL_PURPOSE_TRACING_BIT
//         Enum:
//             Name: VK_TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT_EXT
//             Negative: false
//             Extends: VkToolPurposeFlagBits
//             Alias: VK_TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT
//         Enum:
//             Name: VK_TOOL_PURPOSE_MODIFYING_FEATURES_BIT_EXT
//             Negative: false
//             Extends: VkToolPurposeFlagBits
//             Alias: VK_TOOL_PURPOSE_MODIFYING_FEATURES_BIT
//         Type:
//             Name: VkToolPurposeFlagBitsEXT
//         Type:
//             Name: VkToolPurposeFlagsEXT
//         Type:
//             Name: VkPhysicalDeviceToolPropertiesEXT
//         Command:
//             Name: vkGetPhysicalDeviceToolPropertiesEXT
//     Depends: VK_EXT_debug_report
//         Enum:
//             Name: VK_TOOL_PURPOSE_DEBUG_REPORTING_BIT_EXT
//             Negative: false
//             Bitpos: 5
//             Extends: VkToolPurposeFlagBits
//     Depends: VK_EXT_debug_marker
//         Enum:
//             Name: VK_TOOL_PURPOSE_DEBUG_MARKERS_BIT_EXT
//             Negative: false
//             Bitpos: 6
//             Extends: VkToolPurposeFlagBits
//     Depends: VK_EXT_debug_utils
//         Enum:
//             Name: VK_TOOL_PURPOSE_DEBUG_REPORTING_BIT_EXT
//             Negative: false
//             Bitpos: 5
//             Extends: VkToolPurposeFlagBits
//         Enum:
//             Name: VK_TOOL_PURPOSE_DEBUG_MARKERS_BIT_EXT
//             Negative: false
//             Bitpos: 6
//             Extends: VkToolPurposeFlagBits
pub const VK_EXT_separate_stencil_usage_name = "VK_EXT_separate_stencil_usage";
// Extension: VK_EXT_separate_stencil_usage
// Number: 247
// Type: device
// Author: EXT
// Supported: supported
// Promoted to: VK_VERSION_1_2
// Unlocks:
//         Enum:
//             Name: VK_EXT_SEPARATE_STENCIL_USAGE_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_SEPARATE_STENCIL_USAGE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_separate_stencil_usage&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO
//         Type:
//             Name: VkImageStencilUsageCreateInfoEXT
pub const VK_EXT_validation_features_name = "VK_EXT_validation_features";
// Extension: VK_EXT_validation_features
// Number: 248
// Type: instance
// Author: LUNARG
// Supported: supported
// Deprecated by: VK_EXT_layer_settings
// Unlocks:
//         Enum:
//             Name: VK_EXT_VALIDATION_FEATURES_SPEC_VERSION
//             Negative: false
//             Value: 6
//         Enum:
//             Name: VK_EXT_VALIDATION_FEATURES_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_validation_features&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkValidationFeaturesEXT
//         Type:
//             Name: VkValidationFeatureEnableEXT
//         Type:
//             Name: VkValidationFeatureDisableEXT
pub const VK_KHR_present_wait_name = "VK_KHR_present_wait";
// Extension: VK_KHR_present_wait
// Number: 249
// Type: device
// Author: KHR
// Depends: VK_KHR_swapchain+VK_KHR_present_id
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_PRESENT_WAIT_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_PRESENT_WAIT_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_present_wait&quot;
//         Command:
//             Name: vkWaitForPresentKHR
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDevicePresentWaitFeaturesKHR
//         Feature:
//             Name: presentWait
//             Struct: VkPhysicalDevicePresentWaitFeaturesKHR
pub const VK_NV_cooperative_matrix_name = "VK_NV_cooperative_matrix";
// Extension: VK_NV_cooperative_matrix
// Number: 250
// Type: device
// Author: NV
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NV_COOPERATIVE_MATRIX_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_NV_COOPERATIVE_MATRIX_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_cooperative_matrix&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Type:
//             Name: VkCooperativeMatrixPropertiesNV
//         Type:
//             Name: VkScopeNV
//         Enum:
//             Name: VK_SCOPE_DEVICE_NV
//             Negative: false
//             Extends: VkScopeKHR
//             Alias: VK_SCOPE_DEVICE_KHR
//         Enum:
//             Name: VK_SCOPE_WORKGROUP_NV
//             Negative: false
//             Extends: VkScopeKHR
//             Alias: VK_SCOPE_WORKGROUP_KHR
//         Enum:
//             Name: VK_SCOPE_SUBGROUP_NV
//             Negative: false
//             Extends: VkScopeKHR
//             Alias: VK_SCOPE_SUBGROUP_KHR
//         Enum:
//             Name: VK_SCOPE_QUEUE_FAMILY_NV
//             Negative: false
//             Extends: VkScopeKHR
//             Alias: VK_SCOPE_QUEUE_FAMILY_KHR
//         Type:
//             Name: VkComponentTypeNV
//         Enum:
//             Name: VK_COMPONENT_TYPE_FLOAT16_NV
//             Negative: false
//             Extends: VkComponentTypeKHR
//             Alias: VK_COMPONENT_TYPE_FLOAT16_KHR
//         Enum:
//             Name: VK_COMPONENT_TYPE_FLOAT32_NV
//             Negative: false
//             Extends: VkComponentTypeKHR
//             Alias: VK_COMPONENT_TYPE_FLOAT32_KHR
//         Enum:
//             Name: VK_COMPONENT_TYPE_FLOAT64_NV
//             Negative: false
//             Extends: VkComponentTypeKHR
//             Alias: VK_COMPONENT_TYPE_FLOAT64_KHR
//         Enum:
//             Name: VK_COMPONENT_TYPE_SINT8_NV
//             Negative: false
//             Extends: VkComponentTypeKHR
//             Alias: VK_COMPONENT_TYPE_SINT8_KHR
//         Enum:
//             Name: VK_COMPONENT_TYPE_SINT16_NV
//             Negative: false
//             Extends: VkComponentTypeKHR
//             Alias: VK_COMPONENT_TYPE_SINT16_KHR
//         Enum:
//             Name: VK_COMPONENT_TYPE_SINT32_NV
//             Negative: false
//             Extends: VkComponentTypeKHR
//             Alias: VK_COMPONENT_TYPE_SINT32_KHR
//         Enum:
//             Name: VK_COMPONENT_TYPE_SINT64_NV
//             Negative: false
//             Extends: VkComponentTypeKHR
//             Alias: VK_COMPONENT_TYPE_SINT64_KHR
//         Enum:
//             Name: VK_COMPONENT_TYPE_UINT8_NV
//             Negative: false
//             Extends: VkComponentTypeKHR
//             Alias: VK_COMPONENT_TYPE_UINT8_KHR
//         Enum:
//             Name: VK_COMPONENT_TYPE_UINT16_NV
//             Negative: false
//             Extends: VkComponentTypeKHR
//             Alias: VK_COMPONENT_TYPE_UINT16_KHR
//         Enum:
//             Name: VK_COMPONENT_TYPE_UINT32_NV
//             Negative: false
//             Extends: VkComponentTypeKHR
//             Alias: VK_COMPONENT_TYPE_UINT32_KHR
//         Enum:
//             Name: VK_COMPONENT_TYPE_UINT64_NV
//             Negative: false
//             Extends: VkComponentTypeKHR
//             Alias: VK_COMPONENT_TYPE_UINT64_KHR
//         Type:
//             Name: VkPhysicalDeviceCooperativeMatrixFeaturesNV
//         Type:
//             Name: VkPhysicalDeviceCooperativeMatrixPropertiesNV
//         Command:
//             Name: vkGetPhysicalDeviceCooperativeMatrixPropertiesNV
//         Feature:
//             Name: cooperativeMatrix
//             Struct: VkPhysicalDeviceCooperativeMatrixFeaturesNV
pub const VK_NV_coverage_reduction_mode_name = "VK_NV_coverage_reduction_mode";
// Extension: VK_NV_coverage_reduction_mode
// Number: 251
// Type: device
// Author: NV
// Depends: VK_NV_framebuffer_mixed_samples+(VK_KHR_get_physical_device_properties2,VK_VERSION_1_1)
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NV_COVERAGE_REDUCTION_MODE_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_NV_COVERAGE_REDUCTION_MODE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_coverage_reduction_mode&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Type:
//             Name: VkPhysicalDeviceCoverageReductionModeFeaturesNV
//         Type:
//             Name: VkPipelineCoverageReductionStateCreateInfoNV
//         Type:
//             Name: VkPipelineCoverageReductionStateCreateFlagsNV
//         Type:
//             Name: VkCoverageReductionModeNV
//         Type:
//             Name: VkFramebufferMixedSamplesCombinationNV
//         Command:
//             Name: vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV
//         Feature:
//             Name: coverageReductionMode
//             Struct: VkPhysicalDeviceCoverageReductionModeFeaturesNV
pub const VK_EXT_fragment_shader_interlock_name = "VK_EXT_fragment_shader_interlock";
// Extension: VK_EXT_fragment_shader_interlock
// Number: 252
// Type: device
// Author: EXT
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_FRAGMENT_SHADER_INTERLOCK_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_FRAGMENT_SHADER_INTERLOCK_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_fragment_shader_interlock&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT
//         Feature:
//             Name: fragmentShaderSampleInterlock,fragmentShaderPixelInterlock,fragmentShaderShadingRateInterlock
//             Struct: VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT
pub const VK_EXT_ycbcr_image_arrays_name = "VK_EXT_ycbcr_image_arrays";
// Extension: VK_EXT_ycbcr_image_arrays
// Number: 253
// Type: device
// Author: EXT
// Depends: VK_KHR_sampler_ycbcr_conversion,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_YCBCR_IMAGE_ARRAYS_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_YCBCR_IMAGE_ARRAYS_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_ycbcr_image_arrays&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceYcbcrImageArraysFeaturesEXT
//         Feature:
//             Name: ycbcrImageArrays
//             Struct: VkPhysicalDeviceYcbcrImageArraysFeaturesEXT
pub const VK_KHR_uniform_buffer_standard_layout_name = "VK_KHR_uniform_buffer_standard_layout";
// Extension: VK_KHR_uniform_buffer_standard_layout
// Number: 254
// Type: device
// Author: KHR
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_2
// Unlocks:
//         Enum:
//             Name: VK_KHR_UNIFORM_BUFFER_STANDARD_LAYOUT_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_UNIFORM_BUFFER_STANDARD_LAYOUT_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_uniform_buffer_standard_layout&quot;
//         Type:
//             Name: VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES
//         Feature:
//             Name: uniformBufferStandardLayout
//             Struct: VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR
pub const VK_EXT_provoking_vertex_name = "VK_EXT_provoking_vertex";
// Extension: VK_EXT_provoking_vertex
// Number: 255
// Type: device
// Author: EXT
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_PROVOKING_VERTEX_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_PROVOKING_VERTEX_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_provoking_vertex&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Type:
//             Name: VkPhysicalDeviceProvokingVertexFeaturesEXT
//         Type:
//             Name: VkPhysicalDeviceProvokingVertexPropertiesEXT
//         Type:
//             Name: VkPipelineRasterizationProvokingVertexStateCreateInfoEXT
//         Type:
//             Name: VkProvokingVertexModeEXT
//         Feature:
//             Name: provokingVertexLast
//             Struct: VkPhysicalDeviceProvokingVertexFeaturesEXT
pub const VK_EXT_full_screen_exclusive_name = "VK_EXT_full_screen_exclusive";
// Extension: VK_EXT_full_screen_exclusive
// Number: 256
// Type: device
// Author: EXT
// Depends: (VK_KHR_get_physical_device_properties2,VK_VERSION_1_1)+VK_KHR_surface+VK_KHR_get_surface_capabilities2+VK_KHR_swapchain
// Platform: win32
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_FULL_SCREEN_EXCLUSIVE_SPEC_VERSION
//             Negative: false
//             Value: 4
//         Enum:
//             Name: VK_EXT_FULL_SCREEN_EXCLUSIVE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_full_screen_exclusive&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT
//             Negative: true
//             Extends: VkResult
//             Offset: 0
//         Type:
//             Name: VkFullScreenExclusiveEXT
//         Type:
//             Name: VkSurfaceFullScreenExclusiveInfoEXT
//         Type:
//             Name: VkSurfaceCapabilitiesFullScreenExclusiveEXT
//         Command:
//             Name: vkGetPhysicalDeviceSurfacePresentModes2EXT
//         Command:
//             Name: vkAcquireFullScreenExclusiveModeEXT
//         Command:
//             Name: vkReleaseFullScreenExclusiveModeEXT
//     Depends: VK_KHR_win32_surface
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Type:
//             Name: VkSurfaceFullScreenExclusiveWin32InfoEXT
//     Depends: VK_KHR_device_group,VK_VERSION_1_1
//         Command:
//             Name: vkGetDeviceGroupSurfacePresentModes2EXT
pub const VK_EXT_headless_surface_name = "VK_EXT_headless_surface";
// Extension: VK_EXT_headless_surface
// Number: 257
// Type: instance
// Author: EXT
// Depends: VK_KHR_surface
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_HEADLESS_SURFACE_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_HEADLESS_SURFACE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_headless_surface&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkHeadlessSurfaceCreateFlagsEXT
//         Type:
//             Name: VkHeadlessSurfaceCreateInfoEXT
//         Command:
//             Name: vkCreateHeadlessSurfaceEXT
pub const VK_KHR_buffer_device_address_name = "VK_KHR_buffer_device_address";
// Extension: VK_KHR_buffer_device_address
// Number: 258
// Type: device
// Author: KHR
// Depends: (VK_KHR_get_physical_device_properties2+VK_KHR_device_group),VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_2
// Unlocks:
//         Enum:
//             Name: VK_KHR_BUFFER_DEVICE_ADDRESS_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_BUFFER_DEVICE_ADDRESS_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_buffer_device_address&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES
//         Enum:
//             Name: VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO
//         Enum:
//             Name: VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_KHR
//             Negative: false
//             Extends: VkBufferUsageFlagBits
//             Alias: VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT
//         Enum:
//             Name: VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR
//             Negative: false
//             Extends: VkBufferCreateFlagBits
//             Alias: VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT
//         Enum:
//             Name: VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT_KHR
//             Negative: false
//             Extends: VkMemoryAllocateFlagBits
//             Alias: VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT
//         Enum:
//             Name: VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR
//             Negative: false
//             Extends: VkMemoryAllocateFlagBits
//             Alias: VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT
//         Enum:
//             Name: VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS_KHR
//             Negative: false
//             Extends: VkResult
//             Alias: VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS
//         Type:
//             Name: VkPhysicalDeviceBufferDeviceAddressFeaturesKHR
//         Type:
//             Name: VkBufferDeviceAddressInfoKHR
//         Type:
//             Name: VkBufferOpaqueCaptureAddressCreateInfoKHR
//         Type:
//             Name: VkMemoryOpaqueCaptureAddressAllocateInfoKHR
//         Type:
//             Name: VkDeviceMemoryOpaqueCaptureAddressInfoKHR
//         Command:
//             Name: vkGetBufferDeviceAddressKHR
//         Command:
//             Name: vkGetBufferOpaqueCaptureAddressKHR
//         Command:
//             Name: vkGetDeviceMemoryOpaqueCaptureAddressKHR
//         Feature:
//             Name: bufferDeviceAddress
//             Struct: VkPhysicalDeviceBufferDeviceAddressFeaturesKHR
pub const VK_EXT_extension_259_name = "VK_EXT_extension_259";
// Extension: VK_EXT_extension_259
// Number: 259
// Type: invalid
// Author: EXT
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_259_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_259_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_259&quot;
//     Depends: (VK_KHR_dynamic_rendering,VK_VERSION_1_3)+(VK_KHR_maintenance5,VK_VERSION_1_4)
//         Enum:
//             Name: VK_PIPELINE_CREATE_RESERVED_44_BIT_KHR
//             Negative: false
//             Bitpos: 44
//             Extends: VkPipelineCreateFlagBits2
//     Depends: VK_EXT_shader_object
//         Enum:
//             Name: VK_SHADER_CREATE_RESERVED_16_BIT_KHR
//             Negative: false
//             Bitpos: 16
//             Extends: VkShaderCreateFlagBitsEXT
pub const VK_EXT_line_rasterization_name = "VK_EXT_line_rasterization";
// Extension: VK_EXT_line_rasterization
// Number: 260
// Type: device
// Author: EXT
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_KHR_line_rasterization
// Unlocks:
//         Enum:
//             Name: VK_EXT_LINE_RASTERIZATION_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_LINE_RASTERIZATION_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_line_rasterization&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES
//         Enum:
//             Name: VK_DYNAMIC_STATE_LINE_STIPPLE_EXT
//             Negative: false
//             Extends: VkDynamicState
//             Alias: VK_DYNAMIC_STATE_LINE_STIPPLE
//         Enum:
//             Name: VK_LINE_RASTERIZATION_MODE_DEFAULT_EXT
//             Negative: false
//             Extends: VkLineRasterizationMode
//             Alias: VK_LINE_RASTERIZATION_MODE_DEFAULT
//         Enum:
//             Name: VK_LINE_RASTERIZATION_MODE_RECTANGULAR_EXT
//             Negative: false
//             Extends: VkLineRasterizationMode
//             Alias: VK_LINE_RASTERIZATION_MODE_RECTANGULAR
//         Enum:
//             Name: VK_LINE_RASTERIZATION_MODE_BRESENHAM_EXT
//             Negative: false
//             Extends: VkLineRasterizationMode
//             Alias: VK_LINE_RASTERIZATION_MODE_BRESENHAM
//         Enum:
//             Name: VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_EXT
//             Negative: false
//             Extends: VkLineRasterizationMode
//             Alias: VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH
//         Type:
//             Name: VkPhysicalDeviceLineRasterizationFeaturesEXT
//         Type:
//             Name: VkPhysicalDeviceLineRasterizationPropertiesEXT
//         Type:
//             Name: VkPipelineRasterizationLineStateCreateInfoEXT
//         Type:
//             Name: VkLineRasterizationModeEXT
//         Command:
//             Name: vkCmdSetLineStippleEXT
//         Feature:
//             Name: rectangularLines,bresenhamLines,smoothLines,stippledRectangularLines,stippledBresenhamLines,stippledSmoothLines
//             Struct: VkPhysicalDeviceLineRasterizationFeaturesEXT
pub const VK_EXT_shader_atomic_float_name = "VK_EXT_shader_atomic_float";
// Extension: VK_EXT_shader_atomic_float
// Number: 261
// Type: device
// Author: NV
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_SHADER_ATOMIC_FLOAT_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_SHADER_ATOMIC_FLOAT_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_shader_atomic_float&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceShaderAtomicFloatFeaturesEXT
//         Feature:
//             Name: shaderBufferFloat32Atomics,shaderBufferFloat32AtomicAdd,shaderBufferFloat64Atomics,shaderBufferFloat64AtomicAdd,shaderSharedFloat32Atomics,shaderSharedFloat32AtomicAdd,shaderSharedFloat64Atomics,shaderSharedFloat64AtomicAdd,shaderImageFloat32Atomics,shaderImageFloat32AtomicAdd
//             Struct: VkPhysicalDeviceShaderAtomicFloatFeaturesEXT
//     Depends: VkPhysicalDeviceShaderAtomicFloatFeaturesEXT::sparseImageFloat32Atomics
//         Feature:
//             Name: shaderImageFloat32Atomics
//             Struct: VkPhysicalDeviceShaderAtomicFloatFeaturesEXT
//     Depends: VkPhysicalDeviceShaderAtomicFloatFeaturesEXT::sparseImageFloat32AtomicAdd
//         Feature:
//             Name: shaderImageFloat32AtomicAdd
//             Struct: VkPhysicalDeviceShaderAtomicFloatFeaturesEXT
pub const VK_EXT_host_query_reset_name = "VK_EXT_host_query_reset";
// Extension: VK_EXT_host_query_reset
// Number: 262
// Type: device
// Author: EXT
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_2
// Unlocks:
//         Enum:
//             Name: VK_EXT_HOST_QUERY_RESET_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_HOST_QUERY_RESET_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_host_query_reset&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES
//         Type:
//             Name: VkPhysicalDeviceHostQueryResetFeaturesEXT
//         Command:
//             Name: vkResetQueryPoolEXT
//         Feature:
//             Name: hostQueryReset
//             Struct: VkPhysicalDeviceHostQueryResetFeaturesEXT
pub const VK_GGP_extension_263_name = "VK_GGP_extension_263";
// Extension: VK_GGP_extension_263
// Number: 263
// Type: invalid
// Author: GGP
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_GGP_EXTENSION_263_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_GGP_EXTENSION_263_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_GGP_extension_263&quot;
pub const VK_BRCM_extension_264_name = "VK_BRCM_extension_264";
// Extension: VK_BRCM_extension_264
// Number: 264
// Type: invalid
// Author: BRCM
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_BRCM_EXTENSION_264_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_BRCM_EXTENSION_264_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_BRCM_extension_264&quot;
pub const VK_BRCM_extension_265_name = "VK_BRCM_extension_265";
// Extension: VK_BRCM_extension_265
// Number: 265
// Type: invalid
// Author: BRCM
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_BRCM_EXTENSION_265_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_BRCM_EXTENSION_265_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_BRCM_extension_265&quot;
pub const VK_EXT_index_type_uint8_name = "VK_EXT_index_type_uint8";
// Extension: VK_EXT_index_type_uint8
// Number: 266
// Type: device
// Author: EXT
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_KHR_index_type_uint8
// Unlocks:
//         Enum:
//             Name: VK_EXT_INDEX_TYPE_UINT8_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_INDEX_TYPE_UINT8_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_index_type_uint8&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES
//         Enum:
//             Name: VK_INDEX_TYPE_UINT8_EXT
//             Negative: false
//             Extends: VkIndexType
//             Alias: VK_INDEX_TYPE_UINT8
//         Type:
//             Name: VkPhysicalDeviceIndexTypeUint8FeaturesEXT
//         Feature:
//             Name: indexTypeUint8
//             Struct: VkPhysicalDeviceIndexTypeUint8FeaturesEXT
pub const VK_EXT_extension_267_name = "VK_EXT_extension_267";
// Extension: VK_EXT_extension_267
// Number: 267
// Type: device
// Author: EXT
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_267_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_267_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_267&quot;
pub const VK_EXT_extended_dynamic_state_name = "VK_EXT_extended_dynamic_state";
// Extension: VK_EXT_extended_dynamic_state
// Number: 268
// Type: device
// Author: EXT
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_3
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENDED_DYNAMIC_STATE_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_EXTENDED_DYNAMIC_STATE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extended_dynamic_state&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//             Comment:
//                 Not promoted to 1.3
//         Enum:
//             Name: VK_DYNAMIC_STATE_CULL_MODE_EXT
//             Negative: false
//             Extends: VkDynamicState
//             Alias: VK_DYNAMIC_STATE_CULL_MODE
//         Enum:
//             Name: VK_DYNAMIC_STATE_FRONT_FACE_EXT
//             Negative: false
//             Extends: VkDynamicState
//             Alias: VK_DYNAMIC_STATE_FRONT_FACE
//         Enum:
//             Name: VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY_EXT
//             Negative: false
//             Extends: VkDynamicState
//             Alias: VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY
//         Enum:
//             Name: VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT_EXT
//             Negative: false
//             Extends: VkDynamicState
//             Alias: VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT
//         Enum:
//             Name: VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT_EXT
//             Negative: false
//             Extends: VkDynamicState
//             Alias: VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT
//         Enum:
//             Name: VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE_EXT
//             Negative: false
//             Extends: VkDynamicState
//             Alias: VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE
//         Enum:
//             Name: VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE_EXT
//             Negative: false
//             Extends: VkDynamicState
//             Alias: VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE
//         Enum:
//             Name: VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE_EXT
//             Negative: false
//             Extends: VkDynamicState
//             Alias: VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE
//         Enum:
//             Name: VK_DYNAMIC_STATE_DEPTH_COMPARE_OP_EXT
//             Negative: false
//             Extends: VkDynamicState
//             Alias: VK_DYNAMIC_STATE_DEPTH_COMPARE_OP
//         Enum:
//             Name: VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE_EXT
//             Negative: false
//             Extends: VkDynamicState
//             Alias: VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE
//         Enum:
//             Name: VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE_EXT
//             Negative: false
//             Extends: VkDynamicState
//             Alias: VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE
//         Enum:
//             Name: VK_DYNAMIC_STATE_STENCIL_OP_EXT
//             Negative: false
//             Extends: VkDynamicState
//             Alias: VK_DYNAMIC_STATE_STENCIL_OP
//         Type:
//             Name: VkPhysicalDeviceExtendedDynamicStateFeaturesEXT
//         Command:
//             Name: vkCmdSetCullModeEXT
//         Command:
//             Name: vkCmdSetFrontFaceEXT
//         Command:
//             Name: vkCmdSetPrimitiveTopologyEXT
//         Command:
//             Name: vkCmdSetViewportWithCountEXT
//         Command:
//             Name: vkCmdSetScissorWithCountEXT
//         Command:
//             Name: vkCmdBindVertexBuffers2EXT
//         Command:
//             Name: vkCmdSetDepthTestEnableEXT
//         Command:
//             Name: vkCmdSetDepthWriteEnableEXT
//         Command:
//             Name: vkCmdSetDepthCompareOpEXT
//         Command:
//             Name: vkCmdSetDepthBoundsTestEnableEXT
//         Command:
//             Name: vkCmdSetStencilTestEnableEXT
//         Command:
//             Name: vkCmdSetStencilOpEXT
//         Feature:
//             Name: extendedDynamicState
//             Struct: VkPhysicalDeviceExtendedDynamicStateFeaturesEXT
pub const VK_KHR_deferred_host_operations_name = "VK_KHR_deferred_host_operations";
// Extension: VK_KHR_deferred_host_operations
// Number: 269
// Type: device
// Author: KHR
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_DEFERRED_HOST_OPERATIONS_SPEC_VERSION
//             Negative: false
//             Value: 4
//         Enum:
//             Name: VK_KHR_DEFERRED_HOST_OPERATIONS_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_deferred_host_operations&quot;
//         Enum:
//             Name: VK_OBJECT_TYPE_DEFERRED_OPERATION_KHR
//             Negative: false
//             Extends: VkObjectType
//             Offset: 0
//         Type:
//             Name: VkDeferredOperationKHR
//         Command:
//             Name: vkCreateDeferredOperationKHR
//         Command:
//             Name: vkDestroyDeferredOperationKHR
//         Command:
//             Name: vkGetDeferredOperationMaxConcurrencyKHR
//         Command:
//             Name: vkGetDeferredOperationResultKHR
//         Command:
//             Name: vkDeferredOperationJoinKHR
//         Enum:
//             Name: VK_THREAD_IDLE_KHR
//             Negative: false
//             Extends: VkResult
//             Offset: 0
//         Enum:
//             Name: VK_THREAD_DONE_KHR
//             Negative: false
//             Extends: VkResult
//             Offset: 1
//         Enum:
//             Name: VK_OPERATION_DEFERRED_KHR
//             Negative: false
//             Extends: VkResult
//             Offset: 2
//         Enum:
//             Name: VK_OPERATION_NOT_DEFERRED_KHR
//             Negative: false
//             Extends: VkResult
//             Offset: 3
pub const VK_KHR_pipeline_executable_properties_name = "VK_KHR_pipeline_executable_properties";
// Extension: VK_KHR_pipeline_executable_properties
// Number: 270
// Type: device
// Author: KHR
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_PIPELINE_EXECUTABLE_PROPERTIES_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_PIPELINE_EXECUTABLE_PROPERTIES_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_pipeline_executable_properties&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PIPELINE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_STATISTIC_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 4
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 5
//         Enum:
//             Name: VK_PIPELINE_CREATE_CAPTURE_STATISTICS_BIT_KHR
//             Negative: false
//             Bitpos: 6
//             Extends: VkPipelineCreateFlagBits
//         Enum:
//             Name: VK_PIPELINE_CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR
//             Negative: false
//             Bitpos: 7
//             Extends: VkPipelineCreateFlagBits
//         Type:
//             Name: VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR
//         Type:
//             Name: VkPipelineInfoKHR
//         Type:
//             Name: VkPipelineExecutablePropertiesKHR
//         Type:
//             Name: VkPipelineExecutableInfoKHR
//         Type:
//             Name: VkPipelineExecutableStatisticFormatKHR
//         Type:
//             Name: VkPipelineExecutableStatisticValueKHR
//         Type:
//             Name: VkPipelineExecutableStatisticKHR
//         Type:
//             Name: VkPipelineExecutableInternalRepresentationKHR
//         Command:
//             Name: vkGetPipelineExecutablePropertiesKHR
//         Command:
//             Name: vkGetPipelineExecutableStatisticsKHR
//         Command:
//             Name: vkGetPipelineExecutableInternalRepresentationsKHR
//         Feature:
//             Name: pipelineExecutableInfo
//             Struct: VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR
pub const VK_EXT_host_image_copy_name = "VK_EXT_host_image_copy";
// Extension: VK_EXT_host_image_copy
// Number: 271
// Type: device
// Author: EXT
// Depends: ((VK_KHR_get_physical_device_properties2,VK_VERSION_1_1)+VK_KHR_copy_commands2+VK_KHR_format_feature_flags2),VK_VERSION_1_3
// Supported: supported
// Promoted to: VK_VERSION_1_4
// Unlocks:
//         Enum:
//             Name: VK_EXT_HOST_IMAGE_COPY_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_HOST_IMAGE_COPY_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_host_image_copy&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_PROPERTIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_PROPERTIES
//         Enum:
//             Name: VK_STRUCTURE_TYPE_MEMORY_TO_IMAGE_COPY_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_MEMORY_TO_IMAGE_COPY
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMAGE_TO_MEMORY_COPY_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_IMAGE_TO_MEMORY_COPY
//         Enum:
//             Name: VK_STRUCTURE_TYPE_COPY_IMAGE_TO_MEMORY_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_COPY_IMAGE_TO_MEMORY_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_COPY_MEMORY_TO_IMAGE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_COPY_MEMORY_TO_IMAGE_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_HOST_IMAGE_LAYOUT_TRANSITION_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_HOST_IMAGE_LAYOUT_TRANSITION_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_COPY_IMAGE_TO_IMAGE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_COPY_IMAGE_TO_IMAGE_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SUBRESOURCE_HOST_MEMCPY_SIZE_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_SUBRESOURCE_HOST_MEMCPY_SIZE
//         Enum:
//             Name: VK_STRUCTURE_TYPE_HOST_IMAGE_COPY_DEVICE_PERFORMANCE_QUERY_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_HOST_IMAGE_COPY_DEVICE_PERFORMANCE_QUERY
//         Enum:
//             Name: VK_IMAGE_USAGE_HOST_TRANSFER_BIT_EXT
//             Negative: false
//             Extends: VkImageUsageFlagBits
//             Alias: VK_IMAGE_USAGE_HOST_TRANSFER_BIT
//             Comment:
//                 Can be used with host image copies
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_HOST_IMAGE_TRANSFER_BIT_EXT
//             Negative: false
//             Extends: VkFormatFeatureFlagBits2
//             Alias: VK_FORMAT_FEATURE_2_HOST_IMAGE_TRANSFER_BIT
//             Comment:
//                 Host image copies are supported
//         Enum:
//             Name: VK_HOST_IMAGE_COPY_MEMCPY_BIT_EXT
//             Negative: false
//             Extends: VkHostImageCopyFlagBits
//             Alias: VK_HOST_IMAGE_COPY_MEMCPY_BIT
//         Enum:
//             Name: VK_HOST_IMAGE_COPY_MEMCPY_EXT
//             Negative: false
//             Extends: VkHostImageCopyFlagBits
//             Alias: VK_HOST_IMAGE_COPY_MEMCPY_BIT
//         Type:
//             Name: VkPhysicalDeviceHostImageCopyFeaturesEXT
//         Type:
//             Name: VkPhysicalDeviceHostImageCopyPropertiesEXT
//         Type:
//             Name: VkHostImageCopyFlagBitsEXT
//         Type:
//             Name: VkHostImageCopyFlagsEXT
//         Type:
//             Name: VkMemoryToImageCopyEXT
//         Type:
//             Name: VkImageToMemoryCopyEXT
//         Type:
//             Name: VkCopyMemoryToImageInfoEXT
//         Type:
//             Name: VkCopyImageToMemoryInfoEXT
//         Type:
//             Name: VkCopyImageToImageInfoEXT
//         Type:
//             Name: VkHostImageLayoutTransitionInfoEXT
//         Type:
//             Name: VkSubresourceHostMemcpySizeEXT
//         Type:
//             Name: VkHostImageCopyDevicePerformanceQueryEXT
//         Command:
//             Name: vkCopyMemoryToImageEXT
//         Command:
//             Name: vkCopyImageToMemoryEXT
//         Command:
//             Name: vkCopyImageToImageEXT
//         Command:
//             Name: vkTransitionImageLayoutEXT
//         Type:
//             Name: VkSubresourceLayout2EXT
//         Type:
//             Name: VkImageSubresource2EXT
//         Command:
//             Name: vkGetImageSubresourceLayout2EXT
//             Comment:
//                 Taken from VK_EXT_image_compression_control. VkStructureType enums defined in that extension
//         Feature:
//             Name: hostImageCopy
//             Struct: VkPhysicalDeviceHostImageCopyFeaturesEXT
pub const VK_KHR_map_memory2_name = "VK_KHR_map_memory2";
// Extension: VK_KHR_map_memory2
// Number: 272
// Type: device
// Author: KHR
// Supported: supported
// Promoted to: VK_VERSION_1_4
// Unlocks:
//         Enum:
//             Name: VK_KHR_MAP_MEMORY_2_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_MAP_MEMORY_2_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_map_memory2&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_MEMORY_MAP_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_MEMORY_MAP_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_MEMORY_UNMAP_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_MEMORY_UNMAP_INFO
//         Type:
//             Name: VkMemoryMapInfoKHR
//         Type:
//             Name: VkMemoryUnmapInfoKHR
//         Type:
//             Name: VkMemoryUnmapFlagBitsKHR
//         Type:
//             Name: VkMemoryUnmapFlagsKHR
//         Command:
//             Name: vkMapMemory2KHR
//         Command:
//             Name: vkUnmapMemory2KHR
pub const VK_EXT_map_memory_placed_name = "VK_EXT_map_memory_placed";
// Extension: VK_EXT_map_memory_placed
// Number: 273
// Type: device
// Author: EXT
// Depends: VK_KHR_map_memory2,VK_VERSION_1_4
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_MAP_MEMORY_PLACED_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_MAP_MEMORY_PLACED_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_map_memory_placed&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_PROPERTIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_MEMORY_MAP_PLACED_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_MEMORY_MAP_PLACED_BIT_EXT
//             Negative: false
//             Bitpos: 0
//             Extends: VkMemoryMapFlagBits
//         Enum:
//             Name: VK_MEMORY_UNMAP_RESERVE_BIT_EXT
//             Negative: false
//             Bitpos: 0
//             Extends: VkMemoryUnmapFlagBits
//         Type:
//             Name: VkPhysicalDeviceMapMemoryPlacedFeaturesEXT
//         Type:
//             Name: VkPhysicalDeviceMapMemoryPlacedPropertiesEXT
//         Type:
//             Name: VkMemoryMapPlacedInfoEXT
//         Feature:
//             Name: memoryMapPlaced
//             Struct: VkPhysicalDeviceMapMemoryPlacedFeaturesEXT
pub const VK_EXT_shader_atomic_float2_name = "VK_EXT_shader_atomic_float2";
// Extension: VK_EXT_shader_atomic_float2
// Number: 274
// Type: device
// Author: EXT
// Depends: VK_EXT_shader_atomic_float
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_SHADER_ATOMIC_FLOAT_2_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_SHADER_ATOMIC_FLOAT_2_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_shader_atomic_float2&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT
//         Feature:
//             Name: shaderBufferFloat16Atomics,shaderBufferFloat16AtomicAdd,shaderBufferFloat16AtomicMinMax,shaderBufferFloat32AtomicMinMax,shaderBufferFloat64AtomicMinMax,shaderSharedFloat16Atomics,shaderSharedFloat16AtomicAdd,shaderSharedFloat16AtomicMinMax,shaderSharedFloat32AtomicMinMax,shaderSharedFloat64AtomicMinMax,shaderImageFloat32AtomicMinMax
//             Struct: VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT
//     Depends: VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT::sparseImageFloat32AtomicMinMax
//         Feature:
//             Name: shaderImageFloat32AtomicMinMax
//             Struct: VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT
pub const VK_EXT_surface_maintenance1_name = "VK_EXT_surface_maintenance1";
// Extension: VK_EXT_surface_maintenance1
// Number: 275
// Type: instance
// Author: EXT
// Depends: VK_KHR_surface+VK_KHR_get_surface_capabilities2
// Supported: supported
// Promoted to: VK_KHR_surface_maintenance1
// Unlocks:
//         Enum:
//             Name: VK_EXT_SURFACE_MAINTENANCE_1_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_SURFACE_MAINTENANCE_1_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_surface_maintenance1&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_KHR
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SURFACE_PRESENT_SCALING_CAPABILITIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_SURFACE_PRESENT_SCALING_CAPABILITIES_KHR
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_COMPATIBILITY_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_COMPATIBILITY_KHR
//         Type:
//             Name: VkSurfacePresentModeEXT
//         Type:
//             Name: VkPresentScalingFlagBitsEXT
//         Type:
//             Name: VkPresentScalingFlagsEXT
//         Type:
//             Name: VkPresentGravityFlagBitsEXT
//         Type:
//             Name: VkPresentGravityFlagsEXT
//         Type:
//             Name: VkSurfacePresentScalingCapabilitiesEXT
//         Type:
//             Name: VkSurfacePresentModeCompatibilityEXT
pub const VK_EXT_swapchain_maintenance1_name = "VK_EXT_swapchain_maintenance1";
// Extension: VK_EXT_swapchain_maintenance1
// Number: 276
// Type: device
// Author: EXT
// Depends: VK_KHR_swapchain+VK_EXT_surface_maintenance1+(VK_KHR_get_physical_device_properties2,VK_VERSION_1_1)
// Supported: supported
// Promoted to: VK_KHR_swapchain_maintenance1
// Unlocks:
//         Enum:
//             Name: VK_EXT_SWAPCHAIN_MAINTENANCE_1_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_SWAPCHAIN_MAINTENANCE_1_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_swapchain_maintenance1&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_KHR
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_KHR
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODES_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODES_CREATE_INFO_KHR
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODE_INFO_KHR
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_SCALING_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_SCALING_CREATE_INFO_KHR
//         Enum:
//             Name: VK_STRUCTURE_TYPE_RELEASE_SWAPCHAIN_IMAGES_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_RELEASE_SWAPCHAIN_IMAGES_INFO_KHR
//         Enum:
//             Name: VK_SWAPCHAIN_CREATE_DEFERRED_MEMORY_ALLOCATION_BIT_EXT
//             Negative: false
//             Extends: VkSwapchainCreateFlagBitsKHR
//             Alias: VK_SWAPCHAIN_CREATE_DEFERRED_MEMORY_ALLOCATION_BIT_KHR
//         Type:
//             Name: VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT
//         Type:
//             Name: VkSwapchainPresentFenceInfoEXT
//         Type:
//             Name: VkSwapchainPresentModesCreateInfoEXT
//         Type:
//             Name: VkSwapchainPresentModeInfoEXT
//         Type:
//             Name: VkSwapchainPresentScalingCreateInfoEXT
//         Type:
//             Name: VkReleaseSwapchainImagesInfoEXT
//         Command:
//             Name: vkReleaseSwapchainImagesEXT
//         Feature:
//             Name: swapchainMaintenance1
//             Struct: VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT
pub const VK_EXT_shader_demote_to_helper_invocation_name = "VK_EXT_shader_demote_to_helper_invocation";
// Extension: VK_EXT_shader_demote_to_helper_invocation
// Number: 277
// Type: device
// Author: EXT
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_3
// Unlocks:
//         Enum:
//             Name: VK_EXT_SHADER_DEMOTE_TO_HELPER_INVOCATION_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_SHADER_DEMOTE_TO_HELPER_INVOCATION_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_shader_demote_to_helper_invocation&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES
//         Type:
//             Name: VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT
//         Feature:
//             Name: shaderDemoteToHelperInvocation
//             Struct: VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT
pub const VK_NV_device_generated_commands_name = "VK_NV_device_generated_commands";
// Extension: VK_NV_device_generated_commands
// Number: 278
// Type: device
// Author: NV
// Depends: (VK_VERSION_1_1+VK_KHR_buffer_device_address),VK_VERSION_1_2
// Supported: supported
// Unlocks:
//         Comment:
//             This extension requires buffer_device_address functionality.
//             VK_EXT_buffer_device_address is also acceptable, but since it is deprecated the KHR version is preferred.
//         Enum:
//             Name: VK_NV_DEVICE_GENERATED_COMMANDS_SPEC_VERSION
//             Negative: false
//             Value: 3
//         Enum:
//             Name: VK_NV_DEVICE_GENERATED_COMMANDS_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_device_generated_commands&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_GRAPHICS_SHADER_GROUP_CREATE_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Enum:
//             Name: VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 4
//         Enum:
//             Name: VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 5
//         Enum:
//             Name: VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 6
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 7
//         Enum:
//             Name: VK_PIPELINE_CREATE_INDIRECT_BINDABLE_BIT_NV
//             Negative: false
//             Bitpos: 18
//             Extends: VkPipelineCreateFlagBits
//         Enum:
//             Name: VK_PIPELINE_STAGE_COMMAND_PREPROCESS_BIT_NV
//             Negative: false
//             Extends: VkPipelineStageFlagBits
//             Alias: VK_PIPELINE_STAGE_COMMAND_PREPROCESS_BIT_EXT
//         Enum:
//             Name: VK_ACCESS_COMMAND_PREPROCESS_READ_BIT_NV
//             Negative: false
//             Extends: VkAccessFlagBits
//             Alias: VK_ACCESS_COMMAND_PREPROCESS_READ_BIT_EXT
//         Enum:
//             Name: VK_ACCESS_COMMAND_PREPROCESS_WRITE_BIT_NV
//             Negative: false
//             Extends: VkAccessFlagBits
//             Alias: VK_ACCESS_COMMAND_PREPROCESS_WRITE_BIT_EXT
//         Enum:
//             Name: VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NV
//             Negative: false
//             Extends: VkObjectType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV
//         Type:
//             Name: VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV
//         Type:
//             Name: VkGraphicsShaderGroupCreateInfoNV
//         Type:
//             Name: VkGraphicsPipelineShaderGroupsCreateInfoNV
//         Type:
//             Name: VkBindShaderGroupIndirectCommandNV
//         Type:
//             Name: VkBindIndexBufferIndirectCommandNV
//         Type:
//             Name: VkBindVertexBufferIndirectCommandNV
//         Type:
//             Name: VkSetStateFlagsIndirectCommandNV
//         Type:
//             Name: VkIndirectStateFlagBitsNV
//         Type:
//             Name: VkIndirectStateFlagsNV
//         Type:
//             Name: VkIndirectCommandsLayoutNV
//         Type:
//             Name: VkIndirectCommandsTokenTypeNV
//         Type:
//             Name: VkIndirectCommandsLayoutUsageFlagBitsNV
//         Type:
//             Name: VkIndirectCommandsLayoutUsageFlagsNV
//         Type:
//             Name: VkIndirectCommandsStreamNV
//         Type:
//             Name: VkIndirectCommandsLayoutTokenNV
//         Type:
//             Name: VkIndirectCommandsLayoutCreateInfoNV
//         Type:
//             Name: VkGeneratedCommandsInfoNV
//         Type:
//             Name: VkGeneratedCommandsMemoryRequirementsInfoNV
//         Command:
//             Name: vkGetGeneratedCommandsMemoryRequirementsNV
//         Command:
//             Name: vkCmdPreprocessGeneratedCommandsNV
//         Command:
//             Name: vkCmdExecuteGeneratedCommandsNV
//         Command:
//             Name: vkCmdBindPipelineShaderGroupNV
//         Command:
//             Name: vkCreateIndirectCommandsLayoutNV
//         Command:
//             Name: vkDestroyIndirectCommandsLayoutNV
//         Feature:
//             Name: deviceGeneratedCommands
//             Struct: VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV
pub const VK_NV_inherited_viewport_scissor_name = "VK_NV_inherited_viewport_scissor";
// Extension: VK_NV_inherited_viewport_scissor
// Number: 279
// Type: device
// Author: NV
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NV_INHERITED_VIEWPORT_SCISSOR_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_NV_INHERITED_VIEWPORT_SCISSOR_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_inherited_viewport_scissor&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_VIEWPORT_SCISSOR_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Type:
//             Name: VkPhysicalDeviceInheritedViewportScissorFeaturesNV
//         Type:
//             Name: VkCommandBufferInheritanceViewportScissorInfoNV
//         Feature:
//             Name: inheritedViewportScissor2D
//             Struct: VkPhysicalDeviceInheritedViewportScissorFeaturesNV
pub const VK_KHR_extension_280_name = "VK_KHR_extension_280";
// Extension: VK_KHR_extension_280
// Number: 280
// Type: device
// Author: KHR
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_KHR_EXTENSION_280_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_KHR_EXTENSION_280_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_extension_280&quot;
pub const VK_KHR_shader_integer_dot_product_name = "VK_KHR_shader_integer_dot_product";
// Extension: VK_KHR_shader_integer_dot_product
// Number: 281
// Type: device
// Author: KHR
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_3
// Unlocks:
//         Enum:
//             Name: VK_KHR_SHADER_INTEGER_DOT_PRODUCT_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_SHADER_INTEGER_DOT_PRODUCT_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_shader_integer_dot_product&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES
//         Type:
//             Name: VkPhysicalDeviceShaderIntegerDotProductFeaturesKHR
//         Type:
//             Name: VkPhysicalDeviceShaderIntegerDotProductPropertiesKHR
//         Feature:
//             Name: shaderIntegerDotProduct
//             Struct: VkPhysicalDeviceShaderIntegerDotProductFeaturesKHR
pub const VK_EXT_texel_buffer_alignment_name = "VK_EXT_texel_buffer_alignment";
// Extension: VK_EXT_texel_buffer_alignment
// Number: 282
// Type: device
// Author: EXT
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_3
// Unlocks:
//         Enum:
//             Name: VK_EXT_TEXEL_BUFFER_ALIGNMENT_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_TEXEL_BUFFER_ALIGNMENT_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_texel_buffer_alignment&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//             Comment:
//                 Not promoted to 1.3
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES
//         Type:
//             Name: VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT
//         Type:
//             Name: VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT
//         Feature:
//             Name: texelBufferAlignment
//             Struct: VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT
pub const VK_QCOM_render_pass_transform_name = "VK_QCOM_render_pass_transform";
// Extension: VK_QCOM_render_pass_transform
// Number: 283
// Type: device
// Author: QCOM
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_QCOM_RENDER_PASS_TRANSFORM_SPEC_VERSION
//             Negative: false
//             Value: 5
//         Enum:
//             Name: VK_QCOM_RENDER_PASS_TRANSFORM_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_QCOM_render_pass_transform&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_RENDER_PASS_CREATE_TRANSFORM_BIT_QCOM
//             Negative: false
//             Bitpos: 1
//             Extends: VkRenderPassCreateFlagBits
//         Type:
//             Name: VkRenderPassTransformBeginInfoQCOM
//         Type:
//             Name: VkCommandBufferInheritanceRenderPassTransformInfoQCOM
pub const VK_EXT_depth_bias_control_name = "VK_EXT_depth_bias_control";
// Extension: VK_EXT_depth_bias_control
// Number: 284
// Type: device
// Author: EXT
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_DEPTH_BIAS_CONTROL_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_DEPTH_BIAS_CONTROL_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_depth_bias_control&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_BIAS_CONTROL_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DEPTH_BIAS_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DEPTH_BIAS_REPRESENTATION_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Type:
//             Name: VkPhysicalDeviceDepthBiasControlFeaturesEXT
//         Type:
//             Name: VkDepthBiasInfoEXT
//         Type:
//             Name: VkDepthBiasRepresentationEXT
//         Type:
//             Name: VkDepthBiasRepresentationInfoEXT
//         Command:
//             Name: vkCmdSetDepthBias2EXT
//         Feature:
//             Name: depthBiasControl
//             Struct: VkPhysicalDeviceDepthBiasControlFeaturesEXT
pub const VK_EXT_device_memory_report_name = "VK_EXT_device_memory_report";
// Extension: VK_EXT_device_memory_report
// Number: 285
// Type: device
// Author: EXT
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_DEVICE_MEMORY_REPORT_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_EXT_DEVICE_MEMORY_REPORT_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_device_memory_report&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DEVICE_MEMORY_REPORT_CALLBACK_DATA_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Type:
//             Name: VkPhysicalDeviceDeviceMemoryReportFeaturesEXT
//         Type:
//             Name: VkDeviceDeviceMemoryReportCreateInfoEXT
//         Type:
//             Name: VkDeviceMemoryReportCallbackDataEXT
//         Type:
//             Name: VkDeviceMemoryReportFlagsEXT
//         Type:
//             Name: VkDeviceMemoryReportEventTypeEXT
//         Type:
//             Name: PFN_vkDeviceMemoryReportCallbackEXT
//         Feature:
//             Name: deviceMemoryReport
//             Struct: VkPhysicalDeviceDeviceMemoryReportFeaturesEXT
pub const VK_EXT_acquire_drm_display_name = "VK_EXT_acquire_drm_display";
// Extension: VK_EXT_acquire_drm_display
// Number: 286
// Type: instance
// Author: EXT
// Depends: VK_EXT_direct_mode_display
// Supported: supported
// Comment:
//     codespell:ignore devault
// Unlocks:
//         Enum:
//             Name: VK_EXT_ACQUIRE_DRM_DISPLAY_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_ACQUIRE_DRM_DISPLAY_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_acquire_drm_display&quot;
//         Command:
//             Name: vkAcquireDrmDisplayEXT
//         Command:
//             Name: vkGetDrmDisplayEXT
pub const VK_EXT_robustness2_name = "VK_EXT_robustness2";
// Extension: VK_EXT_robustness2
// Number: 287
// Type: device
// Author: EXT
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_KHR_robustness2
// Unlocks:
//         Enum:
//             Name: VK_EXT_ROBUSTNESS_2_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_ROBUSTNESS_2_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_robustness2&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_KHR
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_KHR
//         Type:
//             Name: VkPhysicalDeviceRobustness2FeaturesEXT
//         Type:
//             Name: VkPhysicalDeviceRobustness2PropertiesEXT
//         Feature:
//             Name: robustBufferAccess2,robustImageAccess2,nullDescriptor
//             Struct: VkPhysicalDeviceRobustness2FeaturesEXT
pub const VK_EXT_custom_border_color_name = "VK_EXT_custom_border_color";
// Extension: VK_EXT_custom_border_color
// Number: 288
// Type: device
// Author: EXT
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_CUSTOM_BORDER_COLOR_SPEC_VERSION
//             Negative: false
//             Value: 12
//         Enum:
//             Name: VK_EXT_CUSTOM_BORDER_COLOR_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_custom_border_color&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_BORDER_COLOR_FLOAT_CUSTOM_EXT
//             Negative: false
//             Extends: VkBorderColor
//             Offset: 3
//         Enum:
//             Name: VK_BORDER_COLOR_INT_CUSTOM_EXT
//             Negative: false
//             Extends: VkBorderColor
//             Offset: 4
//         Type:
//             Name: VkSamplerCustomBorderColorCreateInfoEXT
//         Type:
//             Name: VkPhysicalDeviceCustomBorderColorPropertiesEXT
//         Type:
//             Name: VkPhysicalDeviceCustomBorderColorFeaturesEXT
//         Feature:
//             Name: customBorderColors
//             Struct: VkPhysicalDeviceCustomBorderColorFeaturesEXT
pub const VK_EXT_extension_289_name = "VK_EXT_extension_289";
// Extension: VK_EXT_extension_289
// Number: 289
// Type: invalid
// Author: EXT
// Supported: disabled
// Unlocks:
//         Comment:
//             These enums are present only to inform downstream
//             consumers like KTX2. There is no actual Vulkan extension
//             corresponding to the enums.
//         Enum:
//             Name: VK_EXT_EXTENSION_289_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_289_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_289&quot;
//         Enum:
//             Name: VK_FORMAT_ASTC_3x3x3_UNORM_BLOCK_EXT
//             Negative: false
//             Extends: VkFormat
//             Extnumber: 289
//             Offset: 0
//         Enum:
//             Name: VK_FORMAT_ASTC_3x3x3_SRGB_BLOCK_EXT
//             Negative: false
//             Extends: VkFormat
//             Extnumber: 289
//             Offset: 1
//         Enum:
//             Name: VK_FORMAT_ASTC_3x3x3_SFLOAT_BLOCK_EXT
//             Negative: false
//             Extends: VkFormat
//             Extnumber: 289
//             Offset: 2
//         Enum:
//             Name: VK_FORMAT_ASTC_4x3x3_UNORM_BLOCK_EXT
//             Negative: false
//             Extends: VkFormat
//             Extnumber: 289
//             Offset: 3
//         Enum:
//             Name: VK_FORMAT_ASTC_4x3x3_SRGB_BLOCK_EXT
//             Negative: false
//             Extends: VkFormat
//             Extnumber: 289
//             Offset: 4
//         Enum:
//             Name: VK_FORMAT_ASTC_4x3x3_SFLOAT_BLOCK_EXT
//             Negative: false
//             Extends: VkFormat
//             Extnumber: 289
//             Offset: 5
//         Enum:
//             Name: VK_FORMAT_ASTC_4x4x3_UNORM_BLOCK_EXT
//             Negative: false
//             Extends: VkFormat
//             Extnumber: 289
//             Offset: 6
//         Enum:
//             Name: VK_FORMAT_ASTC_4x4x3_SRGB_BLOCK_EXT
//             Negative: false
//             Extends: VkFormat
//             Extnumber: 289
//             Offset: 7
//         Enum:
//             Name: VK_FORMAT_ASTC_4x4x3_SFLOAT_BLOCK_EXT
//             Negative: false
//             Extends: VkFormat
//             Extnumber: 289
//             Offset: 8
//         Enum:
//             Name: VK_FORMAT_ASTC_4x4x4_UNORM_BLOCK_EXT
//             Negative: false
//             Extends: VkFormat
//             Extnumber: 289
//             Offset: 9
//         Enum:
//             Name: VK_FORMAT_ASTC_4x4x4_SRGB_BLOCK_EXT
//             Negative: false
//             Extends: VkFormat
//             Extnumber: 289
//             Offset: 10
//         Enum:
//             Name: VK_FORMAT_ASTC_4x4x4_SFLOAT_BLOCK_EXT
//             Negative: false
//             Extends: VkFormat
//             Extnumber: 289
//             Offset: 11
//         Enum:
//             Name: VK_FORMAT_ASTC_5x4x4_UNORM_BLOCK_EXT
//             Negative: false
//             Extends: VkFormat
//             Extnumber: 289
//             Offset: 12
//         Enum:
//             Name: VK_FORMAT_ASTC_5x4x4_SRGB_BLOCK_EXT
//             Negative: false
//             Extends: VkFormat
//             Extnumber: 289
//             Offset: 13
//         Enum:
//             Name: VK_FORMAT_ASTC_5x4x4_SFLOAT_BLOCK_EXT
//             Negative: false
//             Extends: VkFormat
//             Extnumber: 289
//             Offset: 14
//         Enum:
//             Name: VK_FORMAT_ASTC_5x5x4_UNORM_BLOCK_EXT
//             Negative: false
//             Extends: VkFormat
//             Extnumber: 289
//             Offset: 15
//         Enum:
//             Name: VK_FORMAT_ASTC_5x5x4_SRGB_BLOCK_EXT
//             Negative: false
//             Extends: VkFormat
//             Extnumber: 289
//             Offset: 16
//         Enum:
//             Name: VK_FORMAT_ASTC_5x5x4_SFLOAT_BLOCK_EXT
//             Negative: false
//             Extends: VkFormat
//             Extnumber: 289
//             Offset: 17
//         Enum:
//             Name: VK_FORMAT_ASTC_5x5x5_UNORM_BLOCK_EXT
//             Negative: false
//             Extends: VkFormat
//             Extnumber: 289
//             Offset: 18
//         Enum:
//             Name: VK_FORMAT_ASTC_5x5x5_SRGB_BLOCK_EXT
//             Negative: false
//             Extends: VkFormat
//             Extnumber: 289
//             Offset: 19
//         Enum:
//             Name: VK_FORMAT_ASTC_5x5x5_SFLOAT_BLOCK_EXT
//             Negative: false
//             Extends: VkFormat
//             Extnumber: 289
//             Offset: 20
//         Enum:
//             Name: VK_FORMAT_ASTC_6x5x5_UNORM_BLOCK_EXT
//             Negative: false
//             Extends: VkFormat
//             Extnumber: 289
//             Offset: 21
//         Enum:
//             Name: VK_FORMAT_ASTC_6x5x5_SRGB_BLOCK_EXT
//             Negative: false
//             Extends: VkFormat
//             Extnumber: 289
//             Offset: 22
//         Enum:
//             Name: VK_FORMAT_ASTC_6x5x5_SFLOAT_BLOCK_EXT
//             Negative: false
//             Extends: VkFormat
//             Extnumber: 289
//             Offset: 23
//         Enum:
//             Name: VK_FORMAT_ASTC_6x6x5_UNORM_BLOCK_EXT
//             Negative: false
//             Extends: VkFormat
//             Extnumber: 289
//             Offset: 24
//         Enum:
//             Name: VK_FORMAT_ASTC_6x6x5_SRGB_BLOCK_EXT
//             Negative: false
//             Extends: VkFormat
//             Extnumber: 289
//             Offset: 25
//         Enum:
//             Name: VK_FORMAT_ASTC_6x6x5_SFLOAT_BLOCK_EXT
//             Negative: false
//             Extends: VkFormat
//             Extnumber: 289
//             Offset: 26
//         Enum:
//             Name: VK_FORMAT_ASTC_6x6x6_UNORM_BLOCK_EXT
//             Negative: false
//             Extends: VkFormat
//             Extnumber: 289
//             Offset: 27
//         Enum:
//             Name: VK_FORMAT_ASTC_6x6x6_SRGB_BLOCK_EXT
//             Negative: false
//             Extends: VkFormat
//             Extnumber: 289
//             Offset: 28
//         Enum:
//             Name: VK_FORMAT_ASTC_6x6x6_SFLOAT_BLOCK_EXT
//             Negative: false
//             Extends: VkFormat
//             Extnumber: 289
//             Offset: 29
pub const VK_GOOGLE_user_type_name = "VK_GOOGLE_user_type";
// Extension: VK_GOOGLE_user_type
// Number: 290
// Type: device
// Author: GOOGLE
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_GOOGLE_USER_TYPE_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_GOOGLE_USER_TYPE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_GOOGLE_user_type&quot;
pub const VK_KHR_pipeline_library_name = "VK_KHR_pipeline_library";
// Extension: VK_KHR_pipeline_library
// Number: 291
// Type: device
// Author: KHR
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_PIPELINE_LIBRARY_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_PIPELINE_LIBRARY_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_pipeline_library&quot;
//         Enum:
//             Name: VK_PIPELINE_CREATE_LIBRARY_BIT_KHR
//             Negative: false
//             Bitpos: 11
//             Extends: VkPipelineCreateFlagBits
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPipelineLibraryCreateInfoKHR
pub const VK_NV_extension_292_name = "VK_NV_extension_292";
// Extension: VK_NV_extension_292
// Number: 292
// Type: invalid
// Author: NV
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_NV_EXTENSION_292_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_NV_EXTENSION_292_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_extension_292&quot;
pub const VK_NV_present_barrier_name = "VK_NV_present_barrier";
// Extension: VK_NV_present_barrier
// Number: 293
// Type: device
// Author: NV
// Depends: (VK_KHR_get_physical_device_properties2,VK_VERSION_1_1)+VK_KHR_surface+VK_KHR_get_surface_capabilities2+VK_KHR_swapchain
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NV_PRESENT_BARRIER_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_NV_PRESENT_BARRIER_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_present_barrier&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_BARRIER_FEATURES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_BARRIER_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_BARRIER_CREATE_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Type:
//             Name: VkPhysicalDevicePresentBarrierFeaturesNV
//         Type:
//             Name: VkSurfaceCapabilitiesPresentBarrierNV
//         Type:
//             Name: VkSwapchainPresentBarrierCreateInfoNV
//         Feature:
//             Name: presentBarrier
//             Struct: VkPhysicalDevicePresentBarrierFeaturesNV
pub const VK_KHR_shader_non_semantic_info_name = "VK_KHR_shader_non_semantic_info";
// Extension: VK_KHR_shader_non_semantic_info
// Number: 294
// Type: device
// Author: KHR
// Supported: supported
// Promoted to: VK_VERSION_1_3
// Unlocks:
//         Enum:
//             Name: VK_KHR_SHADER_NON_SEMANTIC_INFO_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_SHADER_NON_SEMANTIC_INFO_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_shader_non_semantic_info&quot;
pub const VK_KHR_present_id_name = "VK_KHR_present_id";
// Extension: VK_KHR_present_id
// Number: 295
// Type: device
// Author: KHR
// Depends: VK_KHR_swapchain+VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_PRESENT_ID_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_PRESENT_ID_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_present_id&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PRESENT_ID_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPresentIdKHR
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Type:
//             Name: VkPhysicalDevicePresentIdFeaturesKHR
//         Feature:
//             Name: presentId
//             Struct: VkPhysicalDevicePresentIdFeaturesKHR
pub const VK_EXT_private_data_name = "VK_EXT_private_data";
// Extension: VK_EXT_private_data
// Number: 296
// Type: device
// Author: NV
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_3
// Unlocks:
//         Enum:
//             Name: VK_EXT_PRIVATE_DATA_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_PRIVATE_DATA_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_private_data&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO
//         Enum:
//             Name: VK_OBJECT_TYPE_PRIVATE_DATA_SLOT_EXT
//             Negative: false
//             Extends: VkObjectType
//             Alias: VK_OBJECT_TYPE_PRIVATE_DATA_SLOT
//         Type:
//             Name: VkPhysicalDevicePrivateDataFeaturesEXT
//         Type:
//             Name: VkDevicePrivateDataCreateInfoEXT
//         Type:
//             Name: VkPrivateDataSlotCreateInfoEXT
//         Type:
//             Name: VkPrivateDataSlotEXT
//         Type:
//             Name: VkPrivateDataSlotCreateFlagsEXT
//         Command:
//             Name: vkCreatePrivateDataSlotEXT
//         Command:
//             Name: vkDestroyPrivateDataSlotEXT
//         Command:
//             Name: vkSetPrivateDataEXT
//         Command:
//             Name: vkGetPrivateDataEXT
//         Feature:
//             Name: privateData
//             Struct: VkPhysicalDevicePrivateDataFeaturesEXT
pub const VK_KHR_extension_297_name = "VK_KHR_extension_297";
// Extension: VK_KHR_extension_297
// Number: 297
// Type: invalid
// Author: KHR
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_KHR_EXTENSION_297_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_KHR_EXTENSION_297_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_extension_297&quot;
//         Enum:
//             Name: VK_PIPELINE_SHADER_STAGE_CREATE_RESERVED_3_BIT_KHR
//             Negative: false
//             Bitpos: 3
//             Extends: VkPipelineShaderStageCreateFlagBits
pub const VK_EXT_pipeline_creation_cache_control_name = "VK_EXT_pipeline_creation_cache_control";
// Extension: VK_EXT_pipeline_creation_cache_control
// Number: 298
// Type: device
// Author: AMD
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_3
// Unlocks:
//         Enum:
//             Name: VK_EXT_PIPELINE_CREATION_CACHE_CONTROL_SPEC_VERSION
//             Negative: false
//             Value: 3
//         Enum:
//             Name: VK_EXT_PIPELINE_CREATION_CACHE_CONTROL_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_pipeline_creation_cache_control&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES
//         Enum:
//             Name: VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT_EXT
//             Negative: false
//             Extends: VkPipelineCreateFlagBits
//             Alias: VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT
//         Enum:
//             Name: VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT_EXT
//             Negative: false
//             Extends: VkPipelineCreateFlagBits
//             Alias: VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT
//         Enum:
//             Name: VK_PIPELINE_COMPILE_REQUIRED_EXT
//             Negative: false
//             Extends: VkResult
//             Alias: VK_PIPELINE_COMPILE_REQUIRED
//         Enum:
//             Name: VK_ERROR_PIPELINE_COMPILE_REQUIRED_EXT
//             Negative: false
//             Extends: VkResult
//             Alias: VK_PIPELINE_COMPILE_REQUIRED
//         Enum:
//             Name: VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT_EXT
//             Negative: false
//             Extends: VkPipelineCacheCreateFlagBits
//             Alias: VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT
//         Type:
//             Name: VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT
//         Type:
//             Name: VkPipelineCacheCreateFlagBits
//         Feature:
//             Name: pipelineCreationCacheControl
//             Struct: VkPhysicalDevicePipelineCreationCacheControlFeatures
pub const VK_KHR_extension_299_name = "VK_KHR_extension_299";
// Extension: VK_KHR_extension_299
// Number: 299
// Type: device
// Author: KHR
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_KHR_EXTENSION_299_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_KHR_EXTENSION_299_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_extension_299&quot;
pub const VK_KHR_video_encode_queue_name = "VK_KHR_video_encode_queue";
// Extension: VK_KHR_video_encode_queue
// Number: 300
// Type: device
// Author: KHR
// Depends: VK_KHR_video_queue+(VK_KHR_synchronization2,VK_VERSION_1_3)
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_VIDEO_ENCODE_QUEUE_SPEC_VERSION
//             Negative: false
//             Value: 12
//         Enum:
//             Name: VK_KHR_VIDEO_ENCODE_QUEUE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_video_encode_queue&quot;
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_VIDEO_ENCODE_BIT_KHR
//             Negative: false
//             Bitpos: 27
//             Extends: VkPipelineStageFlagBits2
//         Enum:
//             Name: VK_ACCESS_2_VIDEO_ENCODE_READ_BIT_KHR
//             Negative: false
//             Bitpos: 37
//             Extends: VkAccessFlagBits2
//         Enum:
//             Name: VK_ACCESS_2_VIDEO_ENCODE_WRITE_BIT_KHR
//             Negative: false
//             Bitpos: 38
//             Extends: VkAccessFlagBits2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_LAYER_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_CAPABILITIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_USAGE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 4
//         Enum:
//             Name: VK_STRUCTURE_TYPE_QUERY_POOL_VIDEO_ENCODE_FEEDBACK_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 5
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 6
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 7
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 8
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_GET_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 9
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_FEEDBACK_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 10
//         Enum:
//             Name: VK_QUEUE_VIDEO_ENCODE_BIT_KHR
//             Negative: false
//             Bitpos: 6
//             Extends: VkQueueFlagBits
//         Enum:
//             Name: VK_VIDEO_CODING_CONTROL_ENCODE_RATE_CONTROL_BIT_KHR
//             Negative: false
//             Bitpos: 1
//             Extends: VkVideoCodingControlFlagBitsKHR
//         Enum:
//             Name: VK_VIDEO_CODING_CONTROL_ENCODE_QUALITY_LEVEL_BIT_KHR
//             Negative: false
//             Bitpos: 2
//             Extends: VkVideoCodingControlFlagBitsKHR
//         Enum:
//             Name: VK_BUFFER_USAGE_VIDEO_ENCODE_DST_BIT_KHR
//             Negative: false
//             Bitpos: 15
//             Extends: VkBufferUsageFlagBits
//         Enum:
//             Name: VK_BUFFER_USAGE_VIDEO_ENCODE_SRC_BIT_KHR
//             Negative: false
//             Bitpos: 16
//             Extends: VkBufferUsageFlagBits
//         Enum:
//             Name: VK_IMAGE_USAGE_VIDEO_ENCODE_DST_BIT_KHR
//             Negative: false
//             Bitpos: 13
//             Extends: VkImageUsageFlagBits
//         Enum:
//             Name: VK_IMAGE_USAGE_VIDEO_ENCODE_SRC_BIT_KHR
//             Negative: false
//             Bitpos: 14
//             Extends: VkImageUsageFlagBits
//         Enum:
//             Name: VK_IMAGE_USAGE_VIDEO_ENCODE_DPB_BIT_KHR
//             Negative: false
//             Bitpos: 15
//             Extends: VkImageUsageFlagBits
//         Enum:
//             Name: VK_FORMAT_FEATURE_VIDEO_ENCODE_INPUT_BIT_KHR
//             Negative: false
//             Bitpos: 27
//             Extends: VkFormatFeatureFlagBits
//         Enum:
//             Name: VK_FORMAT_FEATURE_VIDEO_ENCODE_DPB_BIT_KHR
//             Negative: false
//             Bitpos: 28
//             Extends: VkFormatFeatureFlagBits
//         Enum:
//             Name: VK_VIDEO_SESSION_CREATE_ALLOW_ENCODE_PARAMETER_OPTIMIZATIONS_BIT_KHR
//             Negative: false
//             Bitpos: 1
//             Extends: VkVideoSessionCreateFlagBitsKHR
//         Enum:
//             Name: VK_IMAGE_LAYOUT_VIDEO_ENCODE_DST_KHR
//             Negative: false
//             Extends: VkImageLayout
//             Offset: 0
//         Enum:
//             Name: VK_IMAGE_LAYOUT_VIDEO_ENCODE_SRC_KHR
//             Negative: false
//             Extends: VkImageLayout
//             Offset: 1
//         Enum:
//             Name: VK_IMAGE_LAYOUT_VIDEO_ENCODE_DPB_KHR
//             Negative: false
//             Extends: VkImageLayout
//             Offset: 2
//         Enum:
//             Name: VK_QUERY_TYPE_VIDEO_ENCODE_FEEDBACK_KHR
//             Negative: false
//             Extends: VkQueryType
//             Offset: 0
//         Enum:
//             Name: VK_QUERY_RESULT_STATUS_INSUFFICIENT_BITSTREAM_BUFFER_RANGE_KHR
//             Negative: true
//             Extends: VkQueryResultStatusKHR
//             Offset: 0
//         Enum:
//             Name: VK_ERROR_INVALID_VIDEO_STD_PARAMETERS_KHR
//             Negative: true
//             Extends: VkResult
//             Offset: 0
//         Type:
//             Name: VkVideoEncodeFlagsKHR
//         Type:
//             Name: VkVideoEncodeInfoKHR
//         Type:
//             Name: VkVideoEncodeCapabilityFlagBitsKHR
//         Type:
//             Name: VkVideoEncodeCapabilityFlagsKHR
//         Type:
//             Name: VkVideoEncodeCapabilitiesKHR
//         Type:
//             Name: VkQueryPoolVideoEncodeFeedbackCreateInfoKHR
//         Type:
//             Name: VkVideoEncodeFeedbackFlagBitsKHR
//         Type:
//             Name: VkVideoEncodeFeedbackFlagsKHR
//         Type:
//             Name: VkVideoEncodeUsageFlagBitsKHR
//         Type:
//             Name: VkVideoEncodeUsageFlagsKHR
//         Type:
//             Name: VkVideoEncodeContentFlagBitsKHR
//         Type:
//             Name: VkVideoEncodeContentFlagsKHR
//         Type:
//             Name: VkVideoEncodeTuningModeKHR
//         Type:
//             Name: VkVideoEncodeUsageInfoKHR
//         Type:
//             Name: VkVideoEncodeRateControlFlagsKHR
//         Type:
//             Name: VkVideoEncodeRateControlModeFlagBitsKHR
//         Type:
//             Name: VkVideoEncodeRateControlModeFlagsKHR
//         Type:
//             Name: VkVideoEncodeRateControlInfoKHR
//         Type:
//             Name: VkVideoEncodeRateControlLayerInfoKHR
//         Type:
//             Name: VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR
//         Type:
//             Name: VkVideoEncodeQualityLevelPropertiesKHR
//         Type:
//             Name: VkVideoEncodeQualityLevelInfoKHR
//         Type:
//             Name: VkVideoEncodeSessionParametersGetInfoKHR
//         Type:
//             Name: VkVideoEncodeSessionParametersFeedbackInfoKHR
//         Command:
//             Name: vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR
//         Command:
//             Name: vkGetEncodedVideoSessionParametersKHR
//         Command:
//             Name: vkCmdEncodeVideoKHR
//     Depends: VK_KHR_format_feature_flags2,VK_VERSION_1_3
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_VIDEO_ENCODE_INPUT_BIT_KHR
//             Negative: false
//             Bitpos: 27
//             Extends: VkFormatFeatureFlagBits2
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_VIDEO_ENCODE_DPB_BIT_KHR
//             Negative: false
//             Bitpos: 28
//             Extends: VkFormatFeatureFlagBits2
pub const VK_NV_device_diagnostics_config_name = "VK_NV_device_diagnostics_config";
// Extension: VK_NV_device_diagnostics_config
// Number: 301
// Type: device
// Author: NV
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NV_DEVICE_DIAGNOSTICS_CONFIG_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_NV_DEVICE_DIAGNOSTICS_CONFIG_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_device_diagnostics_config&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Type:
//             Name: VkPhysicalDeviceDiagnosticsConfigFeaturesNV
//         Type:
//             Name: VkDeviceDiagnosticsConfigCreateInfoNV
//         Type:
//             Name: VkDeviceDiagnosticsConfigFlagsNV
//         Type:
//             Name: VkDeviceDiagnosticsConfigFlagBitsNV
//         Feature:
//             Name: diagnosticsConfig
//             Struct: VkPhysicalDeviceDiagnosticsConfigFeaturesNV
pub const VK_QCOM_render_pass_store_ops_name = "VK_QCOM_render_pass_store_ops";
// Extension: VK_QCOM_render_pass_store_ops
// Number: 302
// Type: device
// Author: QCOM
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_QCOM_RENDER_PASS_STORE_OPS_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_QCOM_RENDER_PASS_STORE_OPS_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_QCOM_render_pass_store_ops&quot;
//         Enum:
//             Name: VK_ATTACHMENT_STORE_OP_NONE_QCOM
//             Negative: false
//             Extends: VkAttachmentStoreOp
//             Alias: VK_ATTACHMENT_STORE_OP_NONE
pub const VK_QCOM_extension_303_name = "VK_QCOM_extension_303";
// Extension: VK_QCOM_extension_303
// Number: 303
// Type: invalid
// Author: QCOM
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_QCOM_EXTENSION_303_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_QCOM_EXTENSION_303_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_QCOM_extension_303&quot;
pub const VK_QCOM_extension_304_name = "VK_QCOM_extension_304";
// Extension: VK_QCOM_extension_304
// Number: 304
// Type: invalid
// Author: QCOM
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_QCOM_EXTENSION_304_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_QCOM_EXTENSION_304_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_QCOM_extension_304&quot;
pub const VK_QCOM_extension_305_name = "VK_QCOM_extension_305";
// Extension: VK_QCOM_extension_305
// Number: 305
// Type: invalid
// Author: QCOM
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_QCOM_EXTENSION_305_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_QCOM_EXTENSION_305_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_QCOM_extension_305&quot;
pub const VK_QCOM_extension_306_name = "VK_QCOM_extension_306";
// Extension: VK_QCOM_extension_306
// Number: 306
// Type: invalid
// Author: QCOM
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_QCOM_EXTENSION_306_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_QCOM_EXTENSION_306_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_QCOM_extension_306&quot;
pub const VK_QCOM_extension_307_name = "VK_QCOM_extension_307";
// Extension: VK_QCOM_extension_307
// Number: 307
// Type: invalid
// Author: QCOM
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_QCOM_EXTENSION_307_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_QCOM_EXTENSION_307_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_QCOM_extension_307&quot;
pub const VK_NV_cuda_kernel_launch_name = "VK_NV_cuda_kernel_launch";
// Extension: VK_NV_cuda_kernel_launch
// Number: 308
// Type: device
// Author: NV
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Platform: provisional
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NV_CUDA_KERNEL_LAUNCH_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_NV_CUDA_KERNEL_LAUNCH_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_cuda_kernel_launch&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_CUDA_MODULE_CREATE_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_CUDA_FUNCTION_CREATE_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_CUDA_LAUNCH_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUDA_KERNEL_LAUNCH_FEATURES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUDA_KERNEL_LAUNCH_PROPERTIES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 4
//         Enum:
//             Name: VK_OBJECT_TYPE_CUDA_MODULE_NV
//             Negative: false
//             Extends: VkObjectType
//             Offset: 0
//         Enum:
//             Name: VK_OBJECT_TYPE_CUDA_FUNCTION_NV
//             Negative: false
//             Extends: VkObjectType
//             Offset: 1
//         Type:
//             Name: VkCudaModuleNV
//         Type:
//             Name: VkCudaFunctionNV
//         Type:
//             Name: VkCudaModuleCreateInfoNV
//         Type:
//             Name: VkCudaFunctionCreateInfoNV
//         Type:
//             Name: VkCudaLaunchInfoNV
//         Type:
//             Name: VkPhysicalDeviceCudaKernelLaunchFeaturesNV
//         Type:
//             Name: VkPhysicalDeviceCudaKernelLaunchPropertiesNV
//         Command:
//             Name: vkCreateCudaModuleNV
//         Command:
//             Name: vkGetCudaModuleCacheNV
//         Command:
//             Name: vkCreateCudaFunctionNV
//         Command:
//             Name: vkDestroyCudaModuleNV
//         Command:
//             Name: vkDestroyCudaFunctionNV
//         Command:
//             Name: vkCmdCudaLaunchKernelNV
//         Feature:
//             Name: cudaKernelLaunchFeatures
//             Struct: VkPhysicalDeviceCudaKernelLaunchFeaturesNV
//     Depends: VK_EXT_debug_report
//         Enum:
//             Name: VK_DEBUG_REPORT_OBJECT_TYPE_CUDA_MODULE_NV_EXT
//             Negative: false
//             Extends: VkDebugReportObjectTypeEXT
//             Offset: 0
//         Enum:
//             Name: VK_DEBUG_REPORT_OBJECT_TYPE_CUDA_FUNCTION_NV_EXT
//             Negative: false
//             Extends: VkDebugReportObjectTypeEXT
//             Offset: 1
pub const VK_KHR_object_refresh_name = "VK_KHR_object_refresh";
// Extension: VK_KHR_object_refresh
// Number: 309
// Type: device
// Author: KHR
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_OBJECT_REFRESH_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_OBJECT_REFRESH_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_object_refresh&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_REFRESH_OBJECT_LIST_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkRefreshObjectListKHR
//         Type:
//             Name: VkRefreshObjectKHR
//         Type:
//             Name: VkRefreshObjectFlagBitsKHR
//         Type:
//             Name: VkRefreshObjectFlagsKHR
//         Command:
//             Name: vkCmdRefreshObjectsKHR
//         Command:
//             Name: vkGetPhysicalDeviceRefreshableObjectTypesKHR
pub const VK_QCOM_tile_shading_name = "VK_QCOM_tile_shading";
// Extension: VK_QCOM_tile_shading
// Number: 310
// Type: device
// Author: QCOM
// Depends: VK_QCOM_tile_properties,VK_KHR_get_physical_device_properties2
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_QCOM_TILE_SHADING_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_QCOM_TILE_SHADING_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_QCOM_tile_shading&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_SHADING_FEATURES_QCOM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_SHADING_PROPERTIES_QCOM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_RENDER_PASS_TILE_SHADING_CREATE_INFO_QCOM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PER_TILE_BEGIN_INFO_QCOM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PER_TILE_END_INFO_QCOM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 4
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DISPATCH_TILE_INFO_QCOM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 5
//         Enum:
//             Name: VK_ACCESS_2_SHADER_TILE_ATTACHMENT_READ_BIT_QCOM
//             Negative: false
//             Bitpos: 51
//             Extends: VkAccessFlagBits2
//         Enum:
//             Name: VK_ACCESS_2_SHADER_TILE_ATTACHMENT_WRITE_BIT_QCOM
//             Negative: false
//             Bitpos: 52
//             Extends: VkAccessFlagBits2
//         Enum:
//             Name: VK_SUBPASS_DESCRIPTION_TILE_SHADING_APRON_BIT_QCOM
//             Negative: false
//             Bitpos: 8
//             Extends: VkSubpassDescriptionFlagBits
//         Type:
//             Name: VkPhysicalDeviceTileShadingFeaturesQCOM
//         Type:
//             Name: VkPhysicalDeviceTileShadingPropertiesQCOM
//         Type:
//             Name: VkRenderPassTileShadingCreateInfoQCOM
//         Type:
//             Name: VkPerTileBeginInfoQCOM
//         Type:
//             Name: VkPerTileEndInfoQCOM
//         Type:
//             Name: VkDispatchTileInfoQCOM
//         Type:
//             Name: VkTileShadingRenderPassFlagsQCOM
//         Type:
//             Name: VkTileShadingRenderPassFlagBitsQCOM
//         Command:
//             Name: vkCmdDispatchTileQCOM
//         Command:
//             Name: vkCmdBeginPerTileExecutionQCOM
//         Command:
//             Name: vkCmdEndPerTileExecutionQCOM
//         Feature:
//             Name: tileShading
//             Struct: VkPhysicalDeviceTileShadingFeaturesQCOM
//         Feature:
//             Name: tileShadingFragmentStage
//             Struct: VkPhysicalDeviceTileShadingFeaturesQCOM
//         Feature:
//             Name: tileShadingPerTileDispatch
//             Struct: VkPhysicalDeviceTileShadingFeaturesQCOM
//         Feature:
//             Name: tileShadingAtomicOps
//             Struct: VkPhysicalDeviceTileShadingFeaturesQCOM
//         Feature:
//             Name: tileShadingColorAttachments
//             Struct: VkPhysicalDeviceTileShadingFeaturesQCOM
//         Feature:
//             Name: tileShadingPerTileDraw
//             Struct: VkPhysicalDeviceTileShadingFeaturesQCOM
//         Feature:
//             Name: tileShadingDepthAttachments
//             Struct: VkPhysicalDeviceTileShadingFeaturesQCOM
//         Feature:
//             Name: tileShadingStencilAttachments
//             Struct: VkPhysicalDeviceTileShadingFeaturesQCOM
//         Feature:
//             Name: tileShadingInputAttachments
//             Struct: VkPhysicalDeviceTileShadingFeaturesQCOM
//         Feature:
//             Name: tileShadingSampledAttachments
//             Struct: VkPhysicalDeviceTileShadingFeaturesQCOM
pub const VK_NV_low_latency_name = "VK_NV_low_latency";
// Extension: VK_NV_low_latency
// Number: 311
// Type: device
// Author: NV
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NV_LOW_LATENCY_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_NV_LOW_LATENCY_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_low_latency&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_QUERY_LOW_LATENCY_SUPPORT_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkQueryLowLatencySupportNV
pub const VK_EXT_metal_objects_name = "VK_EXT_metal_objects";
// Extension: VK_EXT_metal_objects
// Number: 312
// Type: device
// Author: EXT
// Platform: metal
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_METAL_OBJECTS_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_EXT_METAL_OBJECTS_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_metal_objects&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECTS_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_EXPORT_METAL_DEVICE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_EXPORT_METAL_COMMAND_QUEUE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Enum:
//             Name: VK_STRUCTURE_TYPE_EXPORT_METAL_BUFFER_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 4
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMPORT_METAL_BUFFER_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 5
//         Enum:
//             Name: VK_STRUCTURE_TYPE_EXPORT_METAL_TEXTURE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 6
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMPORT_METAL_TEXTURE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 7
//         Enum:
//             Name: VK_STRUCTURE_TYPE_EXPORT_METAL_IO_SURFACE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 8
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMPORT_METAL_IO_SURFACE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 9
//         Enum:
//             Name: VK_STRUCTURE_TYPE_EXPORT_METAL_SHARED_EVENT_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 10
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMPORT_METAL_SHARED_EVENT_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 11
//         Type:
//             Name: VkExportMetalObjectTypeFlagBitsEXT
//         Type:
//             Name: VkExportMetalObjectTypeFlagsEXT
//         Type:
//             Name: VkExportMetalObjectCreateInfoEXT
//         Type:
//             Name: VkExportMetalObjectsInfoEXT
//         Type:
//             Name: VkExportMetalDeviceInfoEXT
//         Type:
//             Name: VkExportMetalCommandQueueInfoEXT
//         Type:
//             Name: VkExportMetalBufferInfoEXT
//         Type:
//             Name: VkImportMetalBufferInfoEXT
//         Type:
//             Name: VkExportMetalTextureInfoEXT
//         Type:
//             Name: VkImportMetalTextureInfoEXT
//         Type:
//             Name: VkExportMetalIOSurfaceInfoEXT
//         Type:
//             Name: VkImportMetalIOSurfaceInfoEXT
//         Type:
//             Name: VkExportMetalSharedEventInfoEXT
//         Type:
//             Name: VkImportMetalSharedEventInfoEXT
//         Type:
//             Name: MTLDevice_id
//         Type:
//             Name: MTLCommandQueue_id
//         Type:
//             Name: MTLBuffer_id
//         Type:
//             Name: MTLTexture_id
//         Type:
//             Name: MTLSharedEvent_id
//         Type:
//             Name: IOSurfaceRef
//         Command:
//             Name: vkExportMetalObjectsEXT
pub const VK_EXT_extension_313_name = "VK_EXT_extension_313";
// Extension: VK_EXT_extension_313
// Number: 313
// Type: invalid
// Author: MVK
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_313_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_313_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_313&quot;
pub const VK_AMD_extension_314_name = "VK_AMD_extension_314";
// Extension: VK_AMD_extension_314
// Number: 314
// Type: invalid
// Author: AMD
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_AMD_EXTENSION_314_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_AMD_EXTENSION_314_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_extension_314&quot;
pub const VK_KHR_synchronization2_name = "VK_KHR_synchronization2";
// Extension: VK_KHR_synchronization2
// Number: 315
// Type: device
// Author: KHR
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_3
// Unlocks:
//         Enum:
//             Name: VK_KHR_SYNCHRONIZATION_2_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_SYNCHRONIZATION_2_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_synchronization2&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_MEMORY_BARRIER_2_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_MEMORY_BARRIER_2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DEPENDENCY_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_DEPENDENCY_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SUBMIT_INFO_2_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_SUBMIT_INFO_2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES
//         Enum:
//             Name: VK_EVENT_CREATE_DEVICE_ONLY_BIT_KHR
//             Negative: false
//             Extends: VkEventCreateFlagBits
//             Alias: VK_EVENT_CREATE_DEVICE_ONLY_BIT
//         Enum:
//             Name: VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL_KHR
//             Negative: false
//             Extends: VkImageLayout
//             Alias: VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL
//         Enum:
//             Name: VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL_KHR
//             Negative: false
//             Extends: VkImageLayout
//             Alias: VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL
//         Enum:
//             Name: VK_PIPELINE_STAGE_NONE_KHR
//             Negative: false
//             Extends: VkPipelineStageFlagBits
//             Alias: VK_PIPELINE_STAGE_NONE
//         Enum:
//             Name: VK_ACCESS_NONE_KHR
//             Negative: false
//             Extends: VkAccessFlagBits
//             Alias: VK_ACCESS_NONE
//         Enum:
//             Name: VK_ACCESS_2_NONE_KHR
//             Negative: false
//             Extends: VkAccessFlagBits2
//             Alias: VK_ACCESS_2_NONE
//         Enum:
//             Name: VK_ACCESS_2_INDIRECT_COMMAND_READ_BIT_KHR
//             Negative: false
//             Extends: VkAccessFlagBits2
//             Alias: VK_ACCESS_2_INDIRECT_COMMAND_READ_BIT
//         Enum:
//             Name: VK_ACCESS_2_INDEX_READ_BIT_KHR
//             Negative: false
//             Extends: VkAccessFlagBits2
//             Alias: VK_ACCESS_2_INDEX_READ_BIT
//         Enum:
//             Name: VK_ACCESS_2_VERTEX_ATTRIBUTE_READ_BIT_KHR
//             Negative: false
//             Extends: VkAccessFlagBits2
//             Alias: VK_ACCESS_2_VERTEX_ATTRIBUTE_READ_BIT
//         Enum:
//             Name: VK_ACCESS_2_UNIFORM_READ_BIT_KHR
//             Negative: false
//             Extends: VkAccessFlagBits2
//             Alias: VK_ACCESS_2_UNIFORM_READ_BIT
//         Enum:
//             Name: VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT_KHR
//             Negative: false
//             Extends: VkAccessFlagBits2
//             Alias: VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT
//         Enum:
//             Name: VK_ACCESS_2_SHADER_READ_BIT_KHR
//             Negative: false
//             Extends: VkAccessFlagBits2
//             Alias: VK_ACCESS_2_SHADER_READ_BIT
//         Enum:
//             Name: VK_ACCESS_2_SHADER_WRITE_BIT_KHR
//             Negative: false
//             Extends: VkAccessFlagBits2
//             Alias: VK_ACCESS_2_SHADER_WRITE_BIT
//         Enum:
//             Name: VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT_KHR
//             Negative: false
//             Extends: VkAccessFlagBits2
//             Alias: VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT
//         Enum:
//             Name: VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT_KHR
//             Negative: false
//             Extends: VkAccessFlagBits2
//             Alias: VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT
//         Enum:
//             Name: VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT_KHR
//             Negative: false
//             Extends: VkAccessFlagBits2
//             Alias: VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT
//         Enum:
//             Name: VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT_KHR
//             Negative: false
//             Extends: VkAccessFlagBits2
//             Alias: VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT
//         Enum:
//             Name: VK_ACCESS_2_TRANSFER_READ_BIT_KHR
//             Negative: false
//             Extends: VkAccessFlagBits2
//             Alias: VK_ACCESS_2_TRANSFER_READ_BIT
//         Enum:
//             Name: VK_ACCESS_2_TRANSFER_WRITE_BIT_KHR
//             Negative: false
//             Extends: VkAccessFlagBits2
//             Alias: VK_ACCESS_2_TRANSFER_WRITE_BIT
//         Enum:
//             Name: VK_ACCESS_2_HOST_READ_BIT_KHR
//             Negative: false
//             Extends: VkAccessFlagBits2
//             Alias: VK_ACCESS_2_HOST_READ_BIT
//         Enum:
//             Name: VK_ACCESS_2_HOST_WRITE_BIT_KHR
//             Negative: false
//             Extends: VkAccessFlagBits2
//             Alias: VK_ACCESS_2_HOST_WRITE_BIT
//         Enum:
//             Name: VK_ACCESS_2_MEMORY_READ_BIT_KHR
//             Negative: false
//             Extends: VkAccessFlagBits2
//             Alias: VK_ACCESS_2_MEMORY_READ_BIT
//         Enum:
//             Name: VK_ACCESS_2_MEMORY_WRITE_BIT_KHR
//             Negative: false
//             Extends: VkAccessFlagBits2
//             Alias: VK_ACCESS_2_MEMORY_WRITE_BIT
//         Enum:
//             Name: VK_ACCESS_2_SHADER_SAMPLED_READ_BIT_KHR
//             Negative: false
//             Extends: VkAccessFlagBits2
//             Alias: VK_ACCESS_2_SHADER_SAMPLED_READ_BIT
//         Enum:
//             Name: VK_ACCESS_2_SHADER_STORAGE_READ_BIT_KHR
//             Negative: false
//             Extends: VkAccessFlagBits2
//             Alias: VK_ACCESS_2_SHADER_STORAGE_READ_BIT
//         Enum:
//             Name: VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT_KHR
//             Negative: false
//             Extends: VkAccessFlagBits2
//             Alias: VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_NONE_KHR
//             Negative: false
//             Extends: VkPipelineStageFlagBits2
//             Alias: VK_PIPELINE_STAGE_2_NONE
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_TOP_OF_PIPE_BIT_KHR
//             Negative: false
//             Extends: VkPipelineStageFlagBits2
//             Alias: VK_PIPELINE_STAGE_2_TOP_OF_PIPE_BIT
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT_KHR
//             Negative: false
//             Extends: VkPipelineStageFlagBits2
//             Alias: VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT_KHR
//             Negative: false
//             Extends: VkPipelineStageFlagBits2
//             Alias: VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT_KHR
//             Negative: false
//             Extends: VkPipelineStageFlagBits2
//             Alias: VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT_KHR
//             Negative: false
//             Extends: VkPipelineStageFlagBits2
//             Alias: VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT_KHR
//             Negative: false
//             Extends: VkPipelineStageFlagBits2
//             Alias: VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT_KHR
//             Negative: false
//             Extends: VkPipelineStageFlagBits2
//             Alias: VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT_KHR
//             Negative: false
//             Extends: VkPipelineStageFlagBits2
//             Alias: VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT_KHR
//             Negative: false
//             Extends: VkPipelineStageFlagBits2
//             Alias: VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT_KHR
//             Negative: false
//             Extends: VkPipelineStageFlagBits2
//             Alias: VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT_KHR
//             Negative: false
//             Extends: VkPipelineStageFlagBits2
//             Alias: VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT_KHR
//             Negative: false
//             Extends: VkPipelineStageFlagBits2
//             Alias: VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT_KHR
//             Negative: false
//             Extends: VkPipelineStageFlagBits2
//             Alias: VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_TRANSFER_BIT_KHR
//             Negative: false
//             Extends: VkPipelineStageFlagBits2
//             Alias: VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_BOTTOM_OF_PIPE_BIT_KHR
//             Negative: false
//             Extends: VkPipelineStageFlagBits2
//             Alias: VK_PIPELINE_STAGE_2_BOTTOM_OF_PIPE_BIT
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_HOST_BIT_KHR
//             Negative: false
//             Extends: VkPipelineStageFlagBits2
//             Alias: VK_PIPELINE_STAGE_2_HOST_BIT
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT_KHR
//             Negative: false
//             Extends: VkPipelineStageFlagBits2
//             Alias: VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT_KHR
//             Negative: false
//             Extends: VkPipelineStageFlagBits2
//             Alias: VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_COPY_BIT_KHR
//             Negative: false
//             Extends: VkPipelineStageFlagBits2
//             Alias: VK_PIPELINE_STAGE_2_COPY_BIT
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_RESOLVE_BIT_KHR
//             Negative: false
//             Extends: VkPipelineStageFlagBits2
//             Alias: VK_PIPELINE_STAGE_2_RESOLVE_BIT
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_BLIT_BIT_KHR
//             Negative: false
//             Extends: VkPipelineStageFlagBits2
//             Alias: VK_PIPELINE_STAGE_2_BLIT_BIT
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_CLEAR_BIT_KHR
//             Negative: false
//             Extends: VkPipelineStageFlagBits2
//             Alias: VK_PIPELINE_STAGE_2_CLEAR_BIT
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT_KHR
//             Negative: false
//             Extends: VkPipelineStageFlagBits2
//             Alias: VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT_KHR
//             Negative: false
//             Extends: VkPipelineStageFlagBits2
//             Alias: VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_PRE_RASTERIZATION_SHADERS_BIT_KHR
//             Negative: false
//             Extends: VkPipelineStageFlagBits2
//             Alias: VK_PIPELINE_STAGE_2_PRE_RASTERIZATION_SHADERS_BIT
//         Enum:
//             Name: VK_SUBMIT_PROTECTED_BIT_KHR
//             Negative: false
//             Extends: VkSubmitFlagBits
//             Alias: VK_SUBMIT_PROTECTED_BIT
//         Type:
//             Name: VkFlags64
//         Type:
//             Name: VkPipelineStageFlags2KHR
//         Type:
//             Name: VkPipelineStageFlagBits2KHR
//         Type:
//             Name: VkAccessFlags2KHR
//         Type:
//             Name: VkAccessFlagBits2KHR
//         Type:
//             Name: VkMemoryBarrier2KHR
//         Type:
//             Name: VkBufferMemoryBarrier2KHR
//         Type:
//             Name: VkImageMemoryBarrier2KHR
//         Type:
//             Name: VkDependencyInfoKHR
//         Type:
//             Name: VkSubmitInfo2KHR
//         Type:
//             Name: VkSemaphoreSubmitInfoKHR
//         Type:
//             Name: VkCommandBufferSubmitInfoKHR
//         Type:
//             Name: VkSubmitFlagBitsKHR
//         Type:
//             Name: VkSubmitFlagsKHR
//         Type:
//             Name: VkPhysicalDeviceSynchronization2FeaturesKHR
//         Command:
//             Name: vkCmdSetEvent2KHR
//         Command:
//             Name: vkCmdResetEvent2KHR
//         Command:
//             Name: vkCmdWaitEvents2KHR
//         Command:
//             Name: vkCmdPipelineBarrier2KHR
//         Command:
//             Name: vkCmdWriteTimestamp2KHR
//         Command:
//             Name: vkQueueSubmit2KHR
//         Feature:
//             Name: synchronization2
//             Struct: VkPhysicalDeviceSynchronization2FeaturesKHR
//     Depends: VK_EXT_transform_feedback
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT
//             Negative: false
//             Bitpos: 24
//             Extends: VkPipelineStageFlagBits2
//         Enum:
//             Name: VK_ACCESS_2_TRANSFORM_FEEDBACK_WRITE_BIT_EXT
//             Negative: false
//             Bitpos: 25
//             Extends: VkAccessFlagBits2
//         Enum:
//             Name: VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT
//             Negative: false
//             Bitpos: 26
//             Extends: VkAccessFlagBits2
//         Enum:
//             Name: VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT
//             Negative: false
//             Bitpos: 27
//             Extends: VkAccessFlagBits2
//     Depends: VK_EXT_conditional_rendering
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT
//             Negative: false
//             Bitpos: 18
//             Extends: VkPipelineStageFlagBits2
//             Comment:
//                 A pipeline stage for conditional rendering predicate fetch
//         Enum:
//             Name: VK_ACCESS_2_CONDITIONAL_RENDERING_READ_BIT_EXT
//             Negative: false
//             Bitpos: 20
//             Extends: VkAccessFlagBits2
//             Comment:
//                 read access flag for reading conditional rendering predicate
//     Depends: VK_NV_device_generated_commands
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_NV
//             Negative: false
//             Extends: VkPipelineStageFlagBits2
//             Alias: VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_EXT
//         Enum:
//             Name: VK_ACCESS_2_COMMAND_PREPROCESS_READ_BIT_NV
//             Negative: false
//             Extends: VkAccessFlagBits2
//             Alias: VK_ACCESS_2_COMMAND_PREPROCESS_READ_BIT_EXT
//         Enum:
//             Name: VK_ACCESS_2_COMMAND_PREPROCESS_WRITE_BIT_NV
//             Negative: false
//             Extends: VkAccessFlagBits2
//             Alias: VK_ACCESS_2_COMMAND_PREPROCESS_WRITE_BIT_EXT
//     Depends: VK_EXT_device_generated_commands
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_EXT
//             Negative: false
//             Bitpos: 17
//             Extends: VkPipelineStageFlagBits2
//         Enum:
//             Name: VK_ACCESS_2_COMMAND_PREPROCESS_READ_BIT_EXT
//             Negative: false
//             Bitpos: 17
//             Extends: VkAccessFlagBits2
//         Enum:
//             Name: VK_ACCESS_2_COMMAND_PREPROCESS_WRITE_BIT_EXT
//             Negative: false
//             Bitpos: 18
//             Extends: VkAccessFlagBits2
//     Depends: VK_KHR_fragment_shading_rate
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR
//             Negative: false
//             Bitpos: 22
//             Extends: VkPipelineStageFlagBits2
//         Enum:
//             Name: VK_ACCESS_2_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR
//             Negative: false
//             Bitpos: 23
//             Extends: VkAccessFlagBits2
//     Depends: VK_NV_shading_rate_image
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_SHADING_RATE_IMAGE_BIT_NV
//             Negative: false
//             Extends: VkPipelineStageFlagBits2
//             Alias: VK_PIPELINE_STAGE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR
//         Enum:
//             Name: VK_ACCESS_2_SHADING_RATE_IMAGE_READ_BIT_NV
//             Negative: false
//             Extends: VkAccessFlagBits2
//             Alias: VK_ACCESS_2_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR
//     Depends: VK_KHR_acceleration_structure
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR
//             Negative: false
//             Bitpos: 25
//             Extends: VkPipelineStageFlagBits2
//         Enum:
//             Name: VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_KHR
//             Negative: false
//             Bitpos: 21
//             Extends: VkAccessFlagBits2
//         Enum:
//             Name: VK_ACCESS_2_ACCELERATION_STRUCTURE_WRITE_BIT_KHR
//             Negative: false
//             Bitpos: 22
//             Extends: VkAccessFlagBits2
//     Depends: VK_KHR_ray_tracing_pipeline
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR
//             Negative: false
//             Bitpos: 21
//             Extends: VkPipelineStageFlagBits2
//     Depends: VK_NV_ray_tracing
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_NV
//             Negative: false
//             Extends: VkPipelineStageFlagBits2
//             Alias: VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_NV
//             Negative: false
//             Extends: VkPipelineStageFlagBits2
//             Alias: VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR
//         Enum:
//             Name: VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_NV
//             Negative: false
//             Extends: VkAccessFlagBits2
//             Alias: VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_KHR
//         Enum:
//             Name: VK_ACCESS_2_ACCELERATION_STRUCTURE_WRITE_BIT_NV
//             Negative: false
//             Extends: VkAccessFlagBits2
//             Alias: VK_ACCESS_2_ACCELERATION_STRUCTURE_WRITE_BIT_KHR
//     Depends: VK_EXT_fragment_density_map
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_FRAGMENT_DENSITY_PROCESS_BIT_EXT
//             Negative: false
//             Bitpos: 23
//             Extends: VkPipelineStageFlagBits2
//         Enum:
//             Name: VK_ACCESS_2_FRAGMENT_DENSITY_MAP_READ_BIT_EXT
//             Negative: false
//             Bitpos: 24
//             Extends: VkAccessFlagBits2
//     Depends: VK_EXT_blend_operation_advanced
//         Enum:
//             Name: VK_ACCESS_2_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT
//             Negative: false
//             Bitpos: 19
//             Extends: VkAccessFlagBits2
//     Depends: VK_NV_mesh_shader
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_NV
//             Negative: false
//             Extends: VkPipelineStageFlagBits2
//             Alias: VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_EXT
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_NV
//             Negative: false
//             Extends: VkPipelineStageFlagBits2
//             Alias: VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_EXT
//     Depends: VK_EXT_mesh_shader
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_EXT
//             Negative: false
//             Bitpos: 19
//             Extends: VkPipelineStageFlagBits2
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_EXT
//             Negative: false
//             Bitpos: 20
//             Extends: VkPipelineStageFlagBits2
pub const VK_AMD_extension_316_name = "VK_AMD_extension_316";
// Extension: VK_AMD_extension_316
// Number: 316
// Type: invalid
// Author: AMD
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_AMD_EXTENSION_316_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_AMD_EXTENSION_316_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_extension_316&quot;
pub const VK_EXT_descriptor_buffer_name = "VK_EXT_descriptor_buffer";
// Extension: VK_EXT_descriptor_buffer
// Number: 317
// Type: device
// Author: EXT
// Depends: ((((VK_KHR_get_physical_device_properties2,VK_VERSION_1_1)+VK_KHR_buffer_device_address+VK_EXT_descriptor_indexing),VK_VERSION_1_2)+VK_KHR_synchronization2),VK_VERSION_1_3
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_DESCRIPTOR_BUFFER_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_DESCRIPTOR_BUFFER_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_descriptor_buffer&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_PROPERTIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_DENSITY_MAP_PROPERTIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DESCRIPTOR_ADDRESS_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DESCRIPTOR_GET_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 4
//         Enum:
//             Name: VK_STRUCTURE_TYPE_BUFFER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 5
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMAGE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 6
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMAGE_VIEW_CAPTURE_DESCRIPTOR_DATA_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 7
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SAMPLER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 8
//         Enum:
//             Name: VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 10
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 11
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_PUSH_DESCRIPTOR_BUFFER_HANDLE_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 12
//         Enum:
//             Name: VK_DESCRIPTOR_SET_LAYOUT_CREATE_DESCRIPTOR_BUFFER_BIT_EXT
//             Negative: false
//             Bitpos: 4
//             Extends: VkDescriptorSetLayoutCreateFlagBits
//         Enum:
//             Name: VK_DESCRIPTOR_SET_LAYOUT_CREATE_EMBEDDED_IMMUTABLE_SAMPLERS_BIT_EXT
//             Negative: false
//             Bitpos: 5
//             Extends: VkDescriptorSetLayoutCreateFlagBits
//         Enum:
//             Name: VK_BUFFER_USAGE_SAMPLER_DESCRIPTOR_BUFFER_BIT_EXT
//             Negative: false
//             Bitpos: 21
//             Extends: VkBufferUsageFlagBits
//         Enum:
//             Name: VK_BUFFER_USAGE_RESOURCE_DESCRIPTOR_BUFFER_BIT_EXT
//             Negative: false
//             Bitpos: 22
//             Extends: VkBufferUsageFlagBits
//         Enum:
//             Name: VK_BUFFER_USAGE_PUSH_DESCRIPTORS_DESCRIPTOR_BUFFER_BIT_EXT
//             Negative: false
//             Bitpos: 26
//             Extends: VkBufferUsageFlagBits
//         Enum:
//             Name: VK_BUFFER_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT
//             Negative: false
//             Bitpos: 5
//             Extends: VkBufferCreateFlagBits
//         Enum:
//             Name: VK_IMAGE_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT
//             Negative: false
//             Bitpos: 16
//             Extends: VkImageCreateFlagBits
//         Enum:
//             Name: VK_IMAGE_VIEW_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT
//             Negative: false
//             Bitpos: 2
//             Extends: VkImageViewCreateFlagBits
//         Enum:
//             Name: VK_SAMPLER_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT
//             Negative: false
//             Bitpos: 3
//             Extends: VkSamplerCreateFlagBits
//         Enum:
//             Name: VK_ACCELERATION_STRUCTURE_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT
//             Negative: false
//             Bitpos: 3
//             Extends: VkAccelerationStructureCreateFlagBitsKHR
//         Enum:
//             Name: VK_ACCESS_2_DESCRIPTOR_BUFFER_READ_BIT_EXT
//             Negative: false
//             Bitpos: 41
//             Extends: VkAccessFlagBits2
//         Enum:
//             Name: VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT
//             Negative: false
//             Bitpos: 29
//             Extends: VkPipelineCreateFlagBits
//         Type:
//             Name: VkPhysicalDeviceDescriptorBufferPropertiesEXT
//         Type:
//             Name: VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT
//         Type:
//             Name: VkPhysicalDeviceDescriptorBufferFeaturesEXT
//         Type:
//             Name: VkDescriptorAddressInfoEXT
//         Type:
//             Name: VkDescriptorBufferBindingInfoEXT
//         Type:
//             Name: VkDescriptorBufferBindingPushDescriptorBufferHandleEXT
//         Type:
//             Name: VkDescriptorDataEXT
//         Type:
//             Name: VkDescriptorGetInfoEXT
//         Type:
//             Name: VkBufferCaptureDescriptorDataInfoEXT
//         Type:
//             Name: VkImageCaptureDescriptorDataInfoEXT
//         Type:
//             Name: VkImageViewCaptureDescriptorDataInfoEXT
//         Type:
//             Name: VkSamplerCaptureDescriptorDataInfoEXT
//         Type:
//             Name: VkOpaqueCaptureDescriptorDataCreateInfoEXT
//         Command:
//             Name: vkGetDescriptorSetLayoutSizeEXT
//         Command:
//             Name: vkGetDescriptorSetLayoutBindingOffsetEXT
//         Command:
//             Name: vkGetDescriptorEXT
//         Command:
//             Name: vkCmdBindDescriptorBuffersEXT
//         Command:
//             Name: vkCmdSetDescriptorBufferOffsetsEXT
//         Command:
//             Name: vkCmdBindDescriptorBufferEmbeddedSamplersEXT
//         Command:
//             Name: vkGetBufferOpaqueCaptureDescriptorDataEXT
//         Command:
//             Name: vkGetImageOpaqueCaptureDescriptorDataEXT
//         Command:
//             Name: vkGetImageViewOpaqueCaptureDescriptorDataEXT
//         Command:
//             Name: vkGetSamplerOpaqueCaptureDescriptorDataEXT
//         Feature:
//             Name: descriptorBuffer
//             Struct: VkPhysicalDeviceDescriptorBufferFeaturesEXT
//     Depends: VK_KHR_acceleration_structure,VK_NV_ray_tracing
//         Enum:
//             Name: VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 9
//         Type:
//             Name: VkAccelerationStructureCaptureDescriptorDataInfoEXT
//         Command:
//             Name: vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT
pub const VK_AMD_extension_318_name = "VK_AMD_extension_318";
// Extension: VK_AMD_extension_318
// Number: 318
// Type: invalid
// Author: AMD
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_AMD_EXTENSION_318_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_AMD_EXTENSION_318_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_extension_318&quot;
pub const VK_AMD_extension_319_name = "VK_AMD_extension_319";
// Extension: VK_AMD_extension_319
// Number: 319
// Type: invalid
// Author: AMD
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_AMD_EXTENSION_319_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_AMD_EXTENSION_319_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_extension_319&quot;
//         Enum:
//             Name: VK_DESCRIPTOR_SET_LAYOUT_CREATE_RESERVED_3_BIT_AMD
//             Negative: false
//             Bitpos: 3
//             Extends: VkDescriptorSetLayoutCreateFlagBits
//         Enum:
//             Name: VK_PIPELINE_LAYOUT_CREATE_RESERVED_0_BIT_AMD
//             Negative: false
//             Bitpos: 0
//             Extends: VkPipelineLayoutCreateFlagBits
pub const VK_AMD_extension_320_name = "VK_AMD_extension_320";
// Extension: VK_AMD_extension_320
// Number: 320
// Type: invalid
// Author: AMD
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_AMD_EXTENSION_320_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_AMD_EXTENSION_320_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_extension_320&quot;
pub const VK_EXT_graphics_pipeline_library_name = "VK_EXT_graphics_pipeline_library";
// Extension: VK_EXT_graphics_pipeline_library
// Number: 321
// Type: device
// Author: AMD
// Depends: (VK_KHR_get_physical_device_properties2,VK_VERSION_1_1)+VK_KHR_pipeline_library
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_GRAPHICS_PIPELINE_LIBRARY_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_GRAPHICS_PIPELINE_LIBRARY_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_graphics_pipeline_library&quot;
//         Type:
//             Name: VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT
//         Type:
//             Name: VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT
//         Type:
//             Name: VkGraphicsPipelineLibraryCreateInfoEXT
//         Type:
//             Name: VkGraphicsPipelineLibraryFlagBitsEXT
//         Type:
//             Name: VkGraphicsPipelineLibraryFlagsEXT
//         Type:
//             Name: VkPipelineLayoutCreateFlagBits
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_PROPERTIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_LIBRARY_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_PIPELINE_CREATE_RETAIN_LINK_TIME_OPTIMIZATION_INFO_BIT_EXT
//             Negative: false
//             Bitpos: 23
//             Extends: VkPipelineCreateFlagBits
//         Enum:
//             Name: VK_PIPELINE_CREATE_LINK_TIME_OPTIMIZATION_BIT_EXT
//             Negative: false
//             Bitpos: 10
//             Extends: VkPipelineCreateFlagBits
//         Enum:
//             Name: VK_PIPELINE_LAYOUT_CREATE_INDEPENDENT_SETS_BIT_EXT
//             Negative: false
//             Bitpos: 1
//             Extends: VkPipelineLayoutCreateFlagBits
//         Feature:
//             Name: graphicsPipelineLibrary
//             Struct: VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT
pub const VK_AMD_shader_early_and_late_fragment_tests_name = "VK_AMD_shader_early_and_late_fragment_tests";
// Extension: VK_AMD_shader_early_and_late_fragment_tests
// Number: 322
// Type: device
// Author: EXT
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_AMD_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_AMD_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_shader_early_and_late_fragment_tests&quot;
//         Type:
//             Name: VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_FEATURES_AMD
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Feature:
//             Name: shaderEarlyAndLateFragmentTests
//             Struct: VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD
pub const VK_KHR_fragment_shader_barycentric_name = "VK_KHR_fragment_shader_barycentric";
// Extension: VK_KHR_fragment_shader_barycentric
// Number: 323
// Type: device
// Author: KHR
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_FRAGMENT_SHADER_BARYCENTRIC_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_FRAGMENT_SHADER_BARYCENTRIC_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_fragment_shader_barycentric&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Extnumber: 204
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR
//         Type:
//             Name: VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR
//         Feature:
//             Name: fragmentShaderBarycentric
//             Struct: VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR
pub const VK_KHR_shader_subgroup_uniform_control_flow_name = "VK_KHR_shader_subgroup_uniform_control_flow";
// Extension: VK_KHR_shader_subgroup_uniform_control_flow
// Number: 324
// Type: device
// Author: KHR
// Depends: VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_shader_subgroup_uniform_control_flow&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR
//         Feature:
//             Name: shaderSubgroupUniformControlFlow
//             Struct: VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR
pub const VK_KHR_extension_325_name = "VK_KHR_extension_325";
// Extension: VK_KHR_extension_325
// Number: 325
// Type: invalid
// Author: KHR
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_KHR_EXTENSION_325_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_KHR_EXTENSION_325_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_extension_325&quot;
pub const VK_KHR_zero_initialize_workgroup_memory_name = "VK_KHR_zero_initialize_workgroup_memory";
// Extension: VK_KHR_zero_initialize_workgroup_memory
// Number: 326
// Type: device
// Author: KHR
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_3
// Unlocks:
//         Enum:
//             Name: VK_KHR_ZERO_INITIALIZE_WORKGROUP_MEMORY_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_ZERO_INITIALIZE_WORKGROUP_MEMORY_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_zero_initialize_workgroup_memory&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES
//         Type:
//             Name: VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR
//         Feature:
//             Name: shaderZeroInitializeWorkgroupMemory
//             Struct: VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR
pub const VK_NV_fragment_shading_rate_enums_name = "VK_NV_fragment_shading_rate_enums";
// Extension: VK_NV_fragment_shading_rate_enums
// Number: 327
// Type: device
// Author: NV
// Depends: VK_KHR_fragment_shading_rate
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NV_FRAGMENT_SHADING_RATE_ENUMS_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_NV_FRAGMENT_SHADING_RATE_ENUMS_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_fragment_shading_rate_enums&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Type:
//             Name: VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV
//         Type:
//             Name: VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV
//         Type:
//             Name: VkPipelineFragmentShadingRateEnumStateCreateInfoNV
//         Type:
//             Name: VkFragmentShadingRateNV
//         Type:
//             Name: VkFragmentShadingRateTypeNV
//         Command:
//             Name: vkCmdSetFragmentShadingRateEnumNV
//         Feature:
//             Name: fragmentShadingRateEnums
//             Struct: VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV
pub const VK_NV_ray_tracing_motion_blur_name = "VK_NV_ray_tracing_motion_blur";
// Extension: VK_NV_ray_tracing_motion_blur
// Number: 328
// Type: device
// Author: NV
// Depends: VK_KHR_ray_tracing_pipeline
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NV_RAY_TRACING_MOTION_BLUR_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_NV_RAY_TRACING_MOTION_BLUR_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_ray_tracing_motion_blur&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_MOTION_TRIANGLES_DATA_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MOTION_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_BUILD_ACCELERATION_STRUCTURE_MOTION_BIT_NV
//             Negative: false
//             Bitpos: 5
//             Extends: VkBuildAccelerationStructureFlagBitsKHR
//         Enum:
//             Name: VK_ACCELERATION_STRUCTURE_CREATE_MOTION_BIT_NV
//             Negative: false
//             Bitpos: 2
//             Extends: VkAccelerationStructureCreateFlagBitsKHR
//         Enum:
//             Name: VK_PIPELINE_CREATE_RAY_TRACING_ALLOW_MOTION_BIT_NV
//             Negative: false
//             Bitpos: 20
//             Extends: VkPipelineCreateFlagBits
//         Type:
//             Name: VkAccelerationStructureGeometryMotionTrianglesDataNV
//         Type:
//             Name: VkAccelerationStructureMotionInfoNV
//         Type:
//             Name: VkAccelerationStructureMotionInstanceNV
//         Type:
//             Name: VkAccelerationStructureMotionInstanceDataNV
//         Type:
//             Name: VkAccelerationStructureMatrixMotionInstanceNV
//         Type:
//             Name: VkAccelerationStructureSRTMotionInstanceNV
//         Type:
//             Name: VkSRTDataNV
//         Type:
//             Name: VkAccelerationStructureMotionInstanceTypeNV
//         Type:
//             Name: VkPhysicalDeviceRayTracingMotionBlurFeaturesNV
//         Type:
//             Name: VkAccelerationStructureMotionInfoFlagsNV
//         Type:
//             Name: VkAccelerationStructureMotionInstanceFlagsNV
//         Feature:
//             Name: rayTracingMotionBlur
//             Struct: VkPhysicalDeviceRayTracingMotionBlurFeaturesNV
pub const VK_EXT_mesh_shader_name = "VK_EXT_mesh_shader";
// Extension: VK_EXT_mesh_shader
// Number: 329
// Type: device
// Author: EXT
// Depends: VK_KHR_spirv_1_4,VK_VERSION_1_2
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_MESH_SHADER_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_MESH_SHADER_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_mesh_shader&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_SHADER_STAGE_TASK_BIT_EXT
//             Negative: false
//             Bitpos: 6
//             Extends: VkShaderStageFlagBits
//         Enum:
//             Name: VK_SHADER_STAGE_MESH_BIT_EXT
//             Negative: false
//             Bitpos: 7
//             Extends: VkShaderStageFlagBits
//         Enum:
//             Name: VK_PIPELINE_STAGE_TASK_SHADER_BIT_EXT
//             Negative: false
//             Bitpos: 19
//             Extends: VkPipelineStageFlagBits
//         Enum:
//             Name: VK_PIPELINE_STAGE_MESH_SHADER_BIT_EXT
//             Negative: false
//             Bitpos: 20
//             Extends: VkPipelineStageFlagBits
//         Enum:
//             Name: VK_QUERY_TYPE_MESH_PRIMITIVES_GENERATED_EXT
//             Negative: false
//             Extends: VkQueryType
//             Offset: 0
//         Enum:
//             Name: VK_QUERY_PIPELINE_STATISTIC_TASK_SHADER_INVOCATIONS_BIT_EXT
//             Negative: false
//             Bitpos: 11
//             Extends: VkQueryPipelineStatisticFlagBits
//         Enum:
//             Name: VK_QUERY_PIPELINE_STATISTIC_MESH_SHADER_INVOCATIONS_BIT_EXT
//             Negative: false
//             Bitpos: 12
//             Extends: VkQueryPipelineStatisticFlagBits
//         Command:
//             Name: vkCmdDrawMeshTasksEXT
//         Command:
//             Name: vkCmdDrawMeshTasksIndirectEXT
//         Type:
//             Name: VkPhysicalDeviceMeshShaderFeaturesEXT
//         Type:
//             Name: VkPhysicalDeviceMeshShaderPropertiesEXT
//         Type:
//             Name: VkDrawMeshTasksIndirectCommandEXT
//         Feature:
//             Name: taskShader
//             Struct: VkPhysicalDeviceMeshShaderFeaturesEXT
//         Feature:
//             Name: meshShader
//             Struct: VkPhysicalDeviceMeshShaderFeaturesEXT
//     Depends: VK_VERSION_1_2,VK_KHR_draw_indirect_count,VK_AMD_draw_indirect_count
//         Command:
//             Name: vkCmdDrawMeshTasksIndirectCountEXT
//     Depends: VK_NV_device_generated_commands
//         Enum:
//             Name: VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_NV
//             Negative: false
//             Extends: VkIndirectCommandsTokenTypeNV
//             Offset: 0
//     Depends: VK_EXT_device_generated_commands
//         Enum:
//             Name: VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_EXT
//             Negative: false
//             Extends: VkIndirectCommandsTokenTypeEXT
//             Offset: 0
//         Enum:
//             Name: VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_COUNT_EXT
//             Negative: false
//             Extends: VkIndirectCommandsTokenTypeEXT
//             Offset: 1
//     Depends: VK_KHR_fragment_shading_rate+VkPhysicalDeviceMeshShaderFeaturesEXT::primitiveFragmentShadingRateMeshShader
//         Feature:
//             Name: primitiveFragmentShadingRate
//             Struct: VkPhysicalDeviceFragmentShadingRateFeaturesKHR
pub const VK_NV_extension_330_name = "VK_NV_extension_330";
// Extension: VK_NV_extension_330
// Number: 330
// Type: invalid
// Author: NV
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_NV_EXTENSION_330_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_NV_EXTENSION_330_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_extension_330&quot;
pub const VK_EXT_ycbcr_2plane_444_formats_name = "VK_EXT_ycbcr_2plane_444_formats";
// Extension: VK_EXT_ycbcr_2plane_444_formats
// Number: 331
// Type: device
// Author: EXT
// Depends: VK_KHR_sampler_ycbcr_conversion,VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_3
// Unlocks:
//         Comment:
//             VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT and
//             VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT
//             were not promoted to Vulkan 1.3.
//         Enum:
//             Name: VK_EXT_YCBCR_2PLANE_444_FORMATS_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_YCBCR_2PLANE_444_FORMATS_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_ycbcr_2plane_444_formats&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_FORMAT_G8_B8R8_2PLANE_444_UNORM_EXT
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_G8_B8R8_2PLANE_444_UNORM
//         Enum:
//             Name: VK_FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16_EXT
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16
//         Enum:
//             Name: VK_FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16_EXT
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16
//         Enum:
//             Name: VK_FORMAT_G16_B16R16_2PLANE_444_UNORM_EXT
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_G16_B16R16_2PLANE_444_UNORM
//         Type:
//             Name: VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT
//         Feature:
//             Name: ycbcr2plane444Formats
//             Struct: VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT
pub const VK_NV_extension_332_name = "VK_NV_extension_332";
// Extension: VK_NV_extension_332
// Number: 332
// Type: invalid
// Author: NV
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_NV_EXTENSION_332_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_NV_EXTENSION_332_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_extension_332&quot;
pub const VK_EXT_fragment_density_map2_name = "VK_EXT_fragment_density_map2";
// Extension: VK_EXT_fragment_density_map2
// Number: 333
// Type: device
// Author: EXT
// Depends: VK_EXT_fragment_density_map
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_FRAGMENT_DENSITY_MAP_2_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_FRAGMENT_DENSITY_MAP_2_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_fragment_density_map2&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DEFERRED_BIT_EXT
//             Negative: false
//             Bitpos: 1
//             Extends: VkImageViewCreateFlagBits
//         Type:
//             Name: VkPhysicalDeviceFragmentDensityMap2FeaturesEXT
//         Type:
//             Name: VkPhysicalDeviceFragmentDensityMap2PropertiesEXT
//         Feature:
//             Name: fragmentDensityMapDeferred
//             Struct: VkPhysicalDeviceFragmentDensityMap2FeaturesEXT
pub const VK_QCOM_rotated_copy_commands_name = "VK_QCOM_rotated_copy_commands";
// Extension: VK_QCOM_rotated_copy_commands
// Number: 334
// Type: device
// Author: QCOM
// Depends: VK_KHR_copy_commands2,VK_VERSION_1_3
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_QCOM_ROTATED_COPY_COMMANDS_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_QCOM_ROTATED_COPY_COMMANDS_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_QCOM_rotated_copy_commands&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkCopyCommandTransformInfoQCOM
pub const VK_KHR_extension_335_name = "VK_KHR_extension_335";
// Extension: VK_KHR_extension_335
// Number: 335
// Type: device
// Author: KHR
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_KHR_EXTENSION_335_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_KHR_EXTENSION_335_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_extension_335&quot;
pub const VK_EXT_image_robustness_name = "VK_EXT_image_robustness";
// Extension: VK_EXT_image_robustness
// Number: 336
// Type: device
// Author: EXT
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_3
// Unlocks:
//         Enum:
//             Name: VK_EXT_IMAGE_ROBUSTNESS_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_IMAGE_ROBUSTNESS_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_image_robustness&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES
//         Type:
//             Name: VkPhysicalDeviceImageRobustnessFeaturesEXT
//         Feature:
//             Name: robustImageAccess
//             Struct: VkPhysicalDeviceImageRobustnessFeaturesEXT
pub const VK_KHR_workgroup_memory_explicit_layout_name = "VK_KHR_workgroup_memory_explicit_layout";
// Extension: VK_KHR_workgroup_memory_explicit_layout
// Number: 337
// Type: device
// Author: KHR
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_workgroup_memory_explicit_layout&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR
//         Feature:
//             Name: workgroupMemoryExplicitLayout
//             Struct: VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR
pub const VK_KHR_copy_commands2_name = "VK_KHR_copy_commands2";
// Extension: VK_KHR_copy_commands2
// Number: 338
// Type: device
// Author: KHR
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_3
// Unlocks:
//         Enum:
//             Name: VK_KHR_COPY_COMMANDS_2_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_COPY_COMMANDS_2_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_copy_commands2&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_BUFFER_COPY_2_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_BUFFER_COPY_2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMAGE_COPY_2_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_IMAGE_COPY_2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMAGE_BLIT_2_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_IMAGE_BLIT_2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2
//         Type:
//             Name: VkCopyBufferInfo2KHR
//         Type:
//             Name: VkCopyImageInfo2KHR
//         Type:
//             Name: VkCopyBufferToImageInfo2KHR
//         Type:
//             Name: VkCopyImageToBufferInfo2KHR
//         Type:
//             Name: VkBlitImageInfo2KHR
//         Type:
//             Name: VkResolveImageInfo2KHR
//         Type:
//             Name: VkBufferCopy2KHR
//         Type:
//             Name: VkImageCopy2KHR
//         Type:
//             Name: VkImageBlit2KHR
//         Type:
//             Name: VkBufferImageCopy2KHR
//         Type:
//             Name: VkImageResolve2KHR
//         Command:
//             Name: vkCmdCopyBuffer2KHR
//         Command:
//             Name: vkCmdCopyImage2KHR
//         Command:
//             Name: vkCmdCopyBufferToImage2KHR
//         Command:
//             Name: vkCmdCopyImageToBuffer2KHR
//         Command:
//             Name: vkCmdBlitImage2KHR
//         Command:
//             Name: vkCmdResolveImage2KHR
pub const VK_EXT_image_compression_control_name = "VK_EXT_image_compression_control";
// Extension: VK_EXT_image_compression_control
// Number: 339
// Type: device
// Author: EXT
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_IMAGE_COMPRESSION_CONTROL_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_IMAGE_COMPRESSION_CONTROL_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_image_compression_control&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceImageCompressionControlFeaturesEXT
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Type:
//             Name: VkImageCompressionControlEXT
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2
//         Type:
//             Name: VkSubresourceLayout2EXT
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2
//         Type:
//             Name: VkImageSubresource2EXT
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 4
//         Type:
//             Name: VkImageCompressionPropertiesEXT
//         Type:
//             Name: VkImageCompressionFlagBitsEXT
//         Type:
//             Name: VkImageCompressionFlagsEXT
//         Type:
//             Name: VkImageCompressionFixedRateFlagBitsEXT
//         Type:
//             Name: VkImageCompressionFixedRateFlagsEXT
//         Enum:
//             Name: VK_ERROR_COMPRESSION_EXHAUSTED_EXT
//             Negative: true
//             Extends: VkResult
//             Offset: 0
//         Command:
//             Name: vkGetImageSubresourceLayout2EXT
//         Feature:
//             Name: imageCompressionControl
//             Struct: VkPhysicalDeviceImageCompressionControlFeaturesEXT
pub const VK_EXT_attachment_feedback_loop_layout_name = "VK_EXT_attachment_feedback_loop_layout";
// Extension: VK_EXT_attachment_feedback_loop_layout
// Number: 340
// Type: device
// Author: EXT
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_EXT_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_attachment_feedback_loop_layout&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT
//             Negative: false
//             Extends: VkImageLayout
//             Offset: 0
//         Enum:
//             Name: VK_IMAGE_USAGE_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT
//             Negative: false
//             Bitpos: 19
//             Extends: VkImageUsageFlagBits
//         Enum:
//             Name: VK_PIPELINE_CREATE_COLOR_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT
//             Negative: false
//             Bitpos: 25
//             Extends: VkPipelineCreateFlagBits
//         Enum:
//             Name: VK_PIPELINE_CREATE_DEPTH_STENCIL_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT
//             Negative: false
//             Bitpos: 26
//             Extends: VkPipelineCreateFlagBits
//         Enum:
//             Name: VK_DEPENDENCY_FEEDBACK_LOOP_BIT_EXT
//             Negative: false
//             Bitpos: 3
//             Extends: VkDependencyFlagBits
//             Comment:
//                 Dependency may be a feedback loop
//         Type:
//             Name: VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT
//         Feature:
//             Name: attachmentFeedbackLoopLayout
//             Struct: VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT
pub const VK_EXT_4444_formats_name = "VK_EXT_4444_formats";
// Extension: VK_EXT_4444_formats
// Number: 341
// Type: device
// Author: EXT
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_3
// Unlocks:
//         Comment:
//             VkPhysicalDevice4444FormatsFeaturesEXT and
//             VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT
//             were not promoted to Vulkan 1.3.
//         Enum:
//             Name: VK_EXT_4444_FORMATS_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_4444_FORMATS_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_4444_formats&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_FORMAT_A4R4G4B4_UNORM_PACK16_EXT
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_A4R4G4B4_UNORM_PACK16
//         Enum:
//             Name: VK_FORMAT_A4B4G4R4_UNORM_PACK16_EXT
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_A4B4G4R4_UNORM_PACK16
//         Type:
//             Name: VkPhysicalDevice4444FormatsFeaturesEXT
//         Feature:
//             Name: formatA4R4G4B4
//             Struct: VkPhysicalDevice4444FormatsFeaturesEXT
pub const VK_EXT_device_fault_name = "VK_EXT_device_fault";
// Extension: VK_EXT_device_fault
// Number: 342
// Type: device
// Author: EXT
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_DEVICE_FAULT_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_EXT_DEVICE_FAULT_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_device_fault&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FAULT_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DEVICE_FAULT_COUNTS_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DEVICE_FAULT_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Type:
//             Name: VkPhysicalDeviceFaultFeaturesEXT
//         Type:
//             Name: VkDeviceFaultCountsEXT
//         Type:
//             Name: VkDeviceFaultInfoEXT
//         Type:
//             Name: VkDeviceFaultAddressInfoEXT
//         Type:
//             Name: VkDeviceFaultAddressTypeEXT
//         Type:
//             Name: VkDeviceFaultVendorInfoEXT
//         Type:
//             Name: VkDeviceFaultVendorBinaryHeaderVersionEXT
//         Type:
//             Name: VkDeviceFaultVendorBinaryHeaderVersionOneEXT
//         Command:
//             Name: vkGetDeviceFaultInfoEXT
//         Feature:
//             Name: deviceFault
//             Struct: VkPhysicalDeviceFaultFeaturesEXT
pub const VK_ARM_rasterization_order_attachment_access_name = "VK_ARM_rasterization_order_attachment_access";
// Extension: VK_ARM_rasterization_order_attachment_access
// Number: 343
// Type: device
// Author: ARM
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_EXT_rasterization_order_attachment_access
// Unlocks:
//         Enum:
//             Name: VK_ARM_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_ARM_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_ARM_rasterization_order_attachment_access&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_ARM
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT
//         Type:
//             Name: VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesARM
//         Enum:
//             Name: VK_PIPELINE_COLOR_BLEND_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_BIT_ARM
//             Negative: false
//             Extends: VkPipelineColorBlendStateCreateFlagBits
//             Alias: VK_PIPELINE_COLOR_BLEND_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_BIT_EXT
//         Enum:
//             Name: VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_ARM
//             Negative: false
//             Extends: VkPipelineDepthStencilStateCreateFlagBits
//             Alias: VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_EXT
//         Enum:
//             Name: VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_ARM
//             Negative: false
//             Extends: VkPipelineDepthStencilStateCreateFlagBits
//             Alias: VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_EXT
//         Enum:
//             Name: VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_COLOR_ACCESS_BIT_ARM
//             Negative: false
//             Extends: VkSubpassDescriptionFlagBits
//             Alias: VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_COLOR_ACCESS_BIT_EXT
//         Enum:
//             Name: VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_ARM
//             Negative: false
//             Extends: VkSubpassDescriptionFlagBits
//             Alias: VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_EXT
//         Enum:
//             Name: VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_ARM
//             Negative: false
//             Extends: VkSubpassDescriptionFlagBits
//             Alias: VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_EXT
pub const VK_ARM_extension_344_name = "VK_ARM_extension_344";
// Extension: VK_ARM_extension_344
// Number: 344
// Type: invalid
// Author: ARM
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_ARM_EXTENSION_344_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_ARM_EXTENSION_344_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_ARM_extension_344&quot;
pub const VK_EXT_rgba10x6_formats_name = "VK_EXT_rgba10x6_formats";
// Extension: VK_EXT_rgba10x6_formats
// Number: 345
// Type: device
// Author: EXT
// Depends: VK_KHR_sampler_ycbcr_conversion,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_RGBA10X6_FORMATS_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_RGBA10X6_FORMATS_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_rgba10x6_formats&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT
//         Feature:
//             Name: formatRgba10x6WithoutYCbCrSampler
//             Struct: VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT
pub const VK_NV_acquire_winrt_display_name = "VK_NV_acquire_winrt_display";
// Extension: VK_NV_acquire_winrt_display
// Number: 346
// Type: device
// Author: NV
// Depends: VK_EXT_direct_mode_display
// Platform: win32
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NV_ACQUIRE_WINRT_DISPLAY_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_NV_ACQUIRE_WINRT_DISPLAY_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_acquire_winrt_display&quot;
//         Command:
//             Name: vkAcquireWinrtDisplayNV
//         Command:
//             Name: vkGetWinrtDisplayNV
pub const VK_EXT_directfb_surface_name = "VK_EXT_directfb_surface";
// Extension: VK_EXT_directfb_surface
// Number: 347
// Type: instance
// Author: EXT
// Depends: VK_KHR_surface
// Platform: directfb
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_DIRECTFB_SURFACE_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_DIRECTFB_SURFACE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_directfb_surface&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DIRECTFB_SURFACE_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkDirectFBSurfaceCreateFlagsEXT
//         Type:
//             Name: VkDirectFBSurfaceCreateInfoEXT
//         Command:
//             Name: vkCreateDirectFBSurfaceEXT
//         Command:
//             Name: vkGetPhysicalDeviceDirectFBPresentationSupportEXT
pub const VK_KHR_extension_350_name = "VK_KHR_extension_350";
// Extension: VK_KHR_extension_350
// Number: 350
// Type: device
// Author: KHR
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_KHR_EXTENSION_350_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_KHR_EXTENSION_350_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_extension_350&quot;
pub const VK_NV_extension_351_name = "VK_NV_extension_351";
// Extension: VK_NV_extension_351
// Number: 351
// Type: invalid
// Author: NV
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_NV_EXTENSION_351_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_NV_EXTENSION_351_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_extension_351&quot;
pub const VK_VALVE_mutable_descriptor_type_name = "VK_VALVE_mutable_descriptor_type";
// Extension: VK_VALVE_mutable_descriptor_type
// Number: 352
// Type: device
// Author: VALVE
// Depends: VK_KHR_maintenance3
// Supported: supported
// Promoted to: VK_EXT_mutable_descriptor_type
// Unlocks:
//         Enum:
//             Name: VK_VALVE_MUTABLE_DESCRIPTOR_TYPE_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_VALVE_MUTABLE_DESCRIPTOR_TYPE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_VALVE_mutable_descriptor_type&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_VALVE
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT
//         Enum:
//             Name: VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_VALVE
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT
//         Enum:
//             Name: VK_DESCRIPTOR_TYPE_MUTABLE_VALVE
//             Negative: false
//             Extends: VkDescriptorType
//             Alias: VK_DESCRIPTOR_TYPE_MUTABLE_EXT
//         Enum:
//             Name: VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_VALVE
//             Negative: false
//             Extends: VkDescriptorPoolCreateFlagBits
//             Alias: VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_EXT
//         Enum:
//             Name: VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_VALVE
//             Negative: false
//             Extends: VkDescriptorSetLayoutCreateFlagBits
//             Alias: VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_EXT
//         Type:
//             Name: VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE
//         Type:
//             Name: VkMutableDescriptorTypeListVALVE
//         Type:
//             Name: VkMutableDescriptorTypeCreateInfoVALVE
//         Feature:
//             Name: mutableDescriptorType
//             Struct: VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE
pub const VK_EXT_vertex_input_dynamic_state_name = "VK_EXT_vertex_input_dynamic_state";
// Extension: VK_EXT_vertex_input_dynamic_state
// Number: 353
// Type: device
// Author: EXT
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_VERTEX_INPUT_DYNAMIC_STATE_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_EXT_VERTEX_INPUT_DYNAMIC_STATE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_vertex_input_dynamic_state&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VERTEX_INPUT_BINDING_DESCRIPTION_2_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VERTEX_INPUT_ATTRIBUTE_DESCRIPTION_2_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_DYNAMIC_STATE_VERTEX_INPUT_EXT
//             Negative: false
//             Extends: VkDynamicState
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT
//         Type:
//             Name: VkVertexInputBindingDescription2EXT
//         Type:
//             Name: VkVertexInputAttributeDescription2EXT
//         Command:
//             Name: vkCmdSetVertexInputEXT
//         Feature:
//             Name: vertexInputDynamicState
//             Struct: VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT
pub const VK_EXT_physical_device_drm_name = "VK_EXT_physical_device_drm";
// Extension: VK_EXT_physical_device_drm
// Number: 354
// Type: device
// Author: EXT
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_PHYSICAL_DEVICE_DRM_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_PHYSICAL_DEVICE_DRM_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_physical_device_drm&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRM_PROPERTIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceDrmPropertiesEXT
pub const VK_EXT_device_address_binding_report_name = "VK_EXT_device_address_binding_report";
// Extension: VK_EXT_device_address_binding_report
// Number: 355
// Type: device
// Author: EXT
// Depends: (VK_KHR_get_physical_device_properties2,VK_VERSION_1_1)+VK_EXT_debug_utils
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_DEVICE_ADDRESS_BINDING_REPORT_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_DEVICE_ADDRESS_BINDING_REPORT_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_device_address_binding_report&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ADDRESS_BINDING_REPORT_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DEVICE_ADDRESS_BINDING_CALLBACK_DATA_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_DEBUG_UTILS_MESSAGE_TYPE_DEVICE_ADDRESS_BINDING_BIT_EXT
//             Negative: false
//             Bitpos: 3
//             Extends: VkDebugUtilsMessageTypeFlagBitsEXT
//         Type:
//             Name: VkPhysicalDeviceAddressBindingReportFeaturesEXT
//         Type:
//             Name: VkDeviceAddressBindingCallbackDataEXT
//         Type:
//             Name: VkDeviceAddressBindingFlagsEXT
//         Type:
//             Name: VkDeviceAddressBindingFlagBitsEXT
//         Type:
//             Name: VkDeviceAddressBindingTypeEXT
//         Feature:
//             Name: reportAddressBinding
//             Struct: VkPhysicalDeviceAddressBindingReportFeaturesEXT
pub const VK_EXT_depth_clip_control_name = "VK_EXT_depth_clip_control";
// Extension: VK_EXT_depth_clip_control
// Number: 356
// Type: device
// Author: EXT
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_DEPTH_CLIP_CONTROL_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_DEPTH_CLIP_CONTROL_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_depth_clip_control&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLIP_CONTROL_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Type:
//             Name: VkPhysicalDeviceDepthClipControlFeaturesEXT
//         Type:
//             Name: VkPipelineViewportDepthClipControlCreateInfoEXT
//         Feature:
//             Name: depthClipControl
//             Struct: VkPhysicalDeviceDepthClipControlFeaturesEXT
pub const VK_EXT_primitive_topology_list_restart_name = "VK_EXT_primitive_topology_list_restart";
// Extension: VK_EXT_primitive_topology_list_restart
// Number: 357
// Type: device
// Author: EXT
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_PRIMITIVE_TOPOLOGY_LIST_RESTART_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_PRIMITIVE_TOPOLOGY_LIST_RESTART_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_primitive_topology_list_restart&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT
//         Feature:
//             Name: primitiveTopologyListRestart
//             Struct: VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT
pub const VK_KHR_extension_358_name = "VK_KHR_extension_358";
// Extension: VK_KHR_extension_358
// Number: 358
// Type: invalid
// Author: KHR
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_KHR_EXTENSION_358_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_KHR_EXTENSION_358_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_extension_358&quot;
pub const VK_EXT_extension_359_name = "VK_EXT_extension_359";
// Extension: VK_EXT_extension_359
// Number: 359
// Type: invalid
// Author: EXT
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_359_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_359_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_359&quot;
pub const VK_EXT_extension_360_name = "VK_EXT_extension_360";
// Extension: VK_EXT_extension_360
// Number: 360
// Type: invalid
// Author: EXT
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_360_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_360_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_360&quot;
pub const VK_KHR_format_feature_flags2_name = "VK_KHR_format_feature_flags2";
// Extension: VK_KHR_format_feature_flags2
// Number: 361
// Type: device
// Author: KHR
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_3
// Unlocks:
//         Enum:
//             Name: VK_KHR_FORMAT_FEATURE_FLAGS_2_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_KHR_FORMAT_FEATURE_FLAGS_2_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_format_feature_flags2&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_BIT_KHR
//             Negative: false
//             Extends: VkFormatFeatureFlagBits2
//             Alias: VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_BIT
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_STORAGE_IMAGE_BIT_KHR
//             Negative: false
//             Extends: VkFormatFeatureFlagBits2
//             Alias: VK_FORMAT_FEATURE_2_STORAGE_IMAGE_BIT
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_STORAGE_IMAGE_ATOMIC_BIT_KHR
//             Negative: false
//             Extends: VkFormatFeatureFlagBits2
//             Alias: VK_FORMAT_FEATURE_2_STORAGE_IMAGE_ATOMIC_BIT
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_UNIFORM_TEXEL_BUFFER_BIT_KHR
//             Negative: false
//             Extends: VkFormatFeatureFlagBits2
//             Alias: VK_FORMAT_FEATURE_2_UNIFORM_TEXEL_BUFFER_BIT
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_BIT_KHR
//             Negative: false
//             Extends: VkFormatFeatureFlagBits2
//             Alias: VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_BIT
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_ATOMIC_BIT_KHR
//             Negative: false
//             Extends: VkFormatFeatureFlagBits2
//             Alias: VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_ATOMIC_BIT
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_VERTEX_BUFFER_BIT_KHR
//             Negative: false
//             Extends: VkFormatFeatureFlagBits2
//             Alias: VK_FORMAT_FEATURE_2_VERTEX_BUFFER_BIT
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BIT_KHR
//             Negative: false
//             Extends: VkFormatFeatureFlagBits2
//             Alias: VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BIT
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BLEND_BIT_KHR
//             Negative: false
//             Extends: VkFormatFeatureFlagBits2
//             Alias: VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BLEND_BIT
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_DEPTH_STENCIL_ATTACHMENT_BIT_KHR
//             Negative: false
//             Extends: VkFormatFeatureFlagBits2
//             Alias: VK_FORMAT_FEATURE_2_DEPTH_STENCIL_ATTACHMENT_BIT
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_BLIT_SRC_BIT_KHR
//             Negative: false
//             Extends: VkFormatFeatureFlagBits2
//             Alias: VK_FORMAT_FEATURE_2_BLIT_SRC_BIT
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_BLIT_DST_BIT_KHR
//             Negative: false
//             Extends: VkFormatFeatureFlagBits2
//             Alias: VK_FORMAT_FEATURE_2_BLIT_DST_BIT
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_LINEAR_BIT_KHR
//             Negative: false
//             Extends: VkFormatFeatureFlagBits2
//             Alias: VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_LINEAR_BIT
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_TRANSFER_SRC_BIT_KHR
//             Negative: false
//             Extends: VkFormatFeatureFlagBits2
//             Alias: VK_FORMAT_FEATURE_2_TRANSFER_SRC_BIT
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_TRANSFER_DST_BIT_KHR
//             Negative: false
//             Extends: VkFormatFeatureFlagBits2
//             Alias: VK_FORMAT_FEATURE_2_TRANSFER_DST_BIT
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_MIDPOINT_CHROMA_SAMPLES_BIT_KHR
//             Negative: false
//             Extends: VkFormatFeatureFlagBits2
//             Alias: VK_FORMAT_FEATURE_2_MIDPOINT_CHROMA_SAMPLES_BIT
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR
//             Negative: false
//             Extends: VkFormatFeatureFlagBits2
//             Alias: VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR
//             Negative: false
//             Extends: VkFormatFeatureFlagBits2
//             Alias: VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR
//             Negative: false
//             Extends: VkFormatFeatureFlagBits2
//             Alias: VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR
//             Negative: false
//             Extends: VkFormatFeatureFlagBits2
//             Alias: VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_DISJOINT_BIT_KHR
//             Negative: false
//             Extends: VkFormatFeatureFlagBits2
//             Alias: VK_FORMAT_FEATURE_2_DISJOINT_BIT
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_COSITED_CHROMA_SAMPLES_BIT_KHR
//             Negative: false
//             Extends: VkFormatFeatureFlagBits2
//             Alias: VK_FORMAT_FEATURE_2_COSITED_CHROMA_SAMPLES_BIT
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT_KHR
//             Negative: false
//             Extends: VkFormatFeatureFlagBits2
//             Alias: VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT_KHR
//             Negative: false
//             Extends: VkFormatFeatureFlagBits2
//             Alias: VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT_KHR
//             Negative: false
//             Extends: VkFormatFeatureFlagBits2
//             Alias: VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT
//         Type:
//             Name: VkFormatFeatureFlags2KHR
//         Type:
//             Name: VkFormatFeatureFlagBits2KHR
//         Type:
//             Name: VkFormatProperties3KHR
//     Depends: VK_VERSION_1_2,VK_EXT_sampler_filter_minmax
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_MINMAX_BIT_KHR
//             Negative: false
//             Extends: VkFormatFeatureFlagBits2
//             Alias: VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_MINMAX_BIT
//     Depends: VK_EXT_filter_cubic,VK_IMG_filter_cubic
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT
//             Negative: false
//             Extends: VkFormatFeatureFlagBits2
//             Alias: VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_CUBIC_BIT
pub const VK_EXT_present_mode_fifo_latest_ready_name = "VK_EXT_present_mode_fifo_latest_ready";
// Extension: VK_EXT_present_mode_fifo_latest_ready
// Number: 362
// Type: device
// Author: EXT
// Depends: VK_KHR_swapchain
// Supported: supported
// Promoted to: VK_KHR_present_mode_fifo_latest_ready
// Unlocks:
//         Enum:
//             Name: VK_EXT_PRESENT_MODE_FIFO_LATEST_READY_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_PRESENT_MODE_FIFO_LATEST_READY_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_present_mode_fifo_latest_ready&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_MODE_FIFO_LATEST_READY_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_MODE_FIFO_LATEST_READY_FEATURES_KHR
//         Enum:
//             Name: VK_PRESENT_MODE_FIFO_LATEST_READY_EXT
//             Negative: false
//             Extends: VkPresentModeKHR
//             Alias: VK_PRESENT_MODE_FIFO_LATEST_READY_KHR
//         Type:
//             Name: VkPhysicalDevicePresentModeFifoLatestReadyFeaturesEXT
//         Feature:
//             Name: presentModeFifoLatestReady
//             Struct: VkPhysicalDevicePresentModeFifoLatestReadyFeaturesEXT
pub const VK_EXT_extension_363_name = "VK_EXT_extension_363";
// Extension: VK_EXT_extension_363
// Number: 363
// Type: invalid
// Author: EXT
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_363_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_363_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_363&quot;
pub const VK_FUCHSIA_extension_364_name = "VK_FUCHSIA_extension_364";
// Extension: VK_FUCHSIA_extension_364
// Number: 364
// Type: invalid
// Author: FUCHSIA
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_FUCHSIA_EXTENSION_364_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_FUCHSIA_EXTENSION_364_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_FUCHSIA_extension_364&quot;
pub const VK_FUCHSIA_external_memory_name = "VK_FUCHSIA_external_memory";
// Extension: VK_FUCHSIA_external_memory
// Number: 365
// Type: device
// Author: FUCHSIA
// Depends: (VK_KHR_external_memory_capabilities+VK_KHR_external_memory),VK_VERSION_1_1
// Platform: fuchsia
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_FUCHSIA_EXTERNAL_MEMORY_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_FUCHSIA_EXTERNAL_MEMORY_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_FUCHSIA_external_memory&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMPORT_MEMORY_ZIRCON_HANDLE_INFO_FUCHSIA
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_MEMORY_ZIRCON_HANDLE_PROPERTIES_FUCHSIA
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_MEMORY_GET_ZIRCON_HANDLE_INFO_FUCHSIA
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_EXTERNAL_MEMORY_HANDLE_TYPE_ZIRCON_VMO_BIT_FUCHSIA
//             Negative: false
//             Bitpos: 11
//             Extends: VkExternalMemoryHandleTypeFlagBits
//         Type:
//             Name: VkImportMemoryZirconHandleInfoFUCHSIA
//         Type:
//             Name: VkMemoryZirconHandlePropertiesFUCHSIA
//         Type:
//             Name: VkMemoryGetZirconHandleInfoFUCHSIA
//         Command:
//             Name: vkGetMemoryZirconHandleFUCHSIA
//         Command:
//             Name: vkGetMemoryZirconHandlePropertiesFUCHSIA
pub const VK_FUCHSIA_external_semaphore_name = "VK_FUCHSIA_external_semaphore";
// Extension: VK_FUCHSIA_external_semaphore
// Number: 366
// Type: device
// Author: FUCHSIA
// Depends: VK_KHR_external_semaphore_capabilities+VK_KHR_external_semaphore
// Platform: fuchsia
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_FUCHSIA_EXTERNAL_SEMAPHORE_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_FUCHSIA_EXTERNAL_SEMAPHORE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_FUCHSIA_external_semaphore&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_ZIRCON_HANDLE_INFO_FUCHSIA
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SEMAPHORE_GET_ZIRCON_HANDLE_INFO_FUCHSIA
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_ZIRCON_EVENT_BIT_FUCHSIA
//             Negative: false
//             Bitpos: 7
//             Extends: VkExternalSemaphoreHandleTypeFlagBits
//         Type:
//             Name: VkImportSemaphoreZirconHandleInfoFUCHSIA
//         Type:
//             Name: VkSemaphoreGetZirconHandleInfoFUCHSIA
//         Command:
//             Name: vkImportSemaphoreZirconHandleFUCHSIA
//         Command:
//             Name: vkGetSemaphoreZirconHandleFUCHSIA
pub const VK_FUCHSIA_buffer_collection_name = "VK_FUCHSIA_buffer_collection";
// Extension: VK_FUCHSIA_buffer_collection
// Number: 367
// Type: device
// Author: FUCHSIA
// Depends: VK_FUCHSIA_external_memory+(VK_KHR_sampler_ycbcr_conversion,VK_VERSION_1_1)
// Platform: fuchsia
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_FUCHSIA_BUFFER_COLLECTION_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_FUCHSIA_BUFFER_COLLECTION_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_FUCHSIA_buffer_collection&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_BUFFER_COLLECTION_CREATE_INFO_FUCHSIA
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_OBJECT_TYPE_BUFFER_COLLECTION_FUCHSIA
//             Negative: false
//             Extends: VkObjectType
//             Offset: 0
//             Comment:
//                 VkBufferCollectionFUCHSIA
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMPORT_MEMORY_BUFFER_COLLECTION_FUCHSIA
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_BUFFER_COLLECTION_IMAGE_CREATE_INFO_FUCHSIA
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_BUFFER_COLLECTION_PROPERTIES_FUCHSIA
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Enum:
//             Name: VK_STRUCTURE_TYPE_BUFFER_CONSTRAINTS_INFO_FUCHSIA
//             Negative: false
//             Extends: VkStructureType
//             Offset: 4
//         Enum:
//             Name: VK_STRUCTURE_TYPE_BUFFER_COLLECTION_BUFFER_CREATE_INFO_FUCHSIA
//             Negative: false
//             Extends: VkStructureType
//             Offset: 5
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMAGE_CONSTRAINTS_INFO_FUCHSIA
//             Negative: false
//             Extends: VkStructureType
//             Offset: 6
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMAGE_FORMAT_CONSTRAINTS_INFO_FUCHSIA
//             Negative: false
//             Extends: VkStructureType
//             Offset: 7
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SYSMEM_COLOR_SPACE_FUCHSIA
//             Negative: false
//             Extends: VkStructureType
//             Offset: 8
//         Enum:
//             Name: VK_STRUCTURE_TYPE_BUFFER_COLLECTION_CONSTRAINTS_INFO_FUCHSIA
//             Negative: false
//             Extends: VkStructureType
//             Offset: 9
//         Type:
//             Name: VkBufferCollectionFUCHSIA
//         Type:
//             Name: VkBufferCollectionCreateInfoFUCHSIA
//         Type:
//             Name: VkImportMemoryBufferCollectionFUCHSIA
//         Type:
//             Name: VkBufferCollectionImageCreateInfoFUCHSIA
//         Type:
//             Name: VkBufferConstraintsInfoFUCHSIA
//         Type:
//             Name: VkBufferCollectionBufferCreateInfoFUCHSIA
//         Type:
//             Name: VkBufferCollectionPropertiesFUCHSIA
//         Type:
//             Name: VkImageFormatConstraintsFlagsFUCHSIA
//         Type:
//             Name: VkSysmemColorSpaceFUCHSIA
//         Type:
//             Name: VkImageConstraintsInfoFlagBitsFUCHSIA
//         Type:
//             Name: VkImageConstraintsInfoFlagsFUCHSIA
//         Type:
//             Name: VkImageConstraintsInfoFUCHSIA
//         Type:
//             Name: VkImageFormatConstraintsInfoFUCHSIA
//         Type:
//             Name: VkBufferCollectionConstraintsInfoFUCHSIA
//         Command:
//             Name: vkCreateBufferCollectionFUCHSIA
//         Command:
//             Name: vkSetBufferCollectionImageConstraintsFUCHSIA
//         Command:
//             Name: vkSetBufferCollectionBufferConstraintsFUCHSIA
//         Command:
//             Name: vkDestroyBufferCollectionFUCHSIA
//         Command:
//             Name: vkGetBufferCollectionPropertiesFUCHSIA
//     Depends: VK_EXT_debug_report
//         Enum:
//             Name: VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_COLLECTION_FUCHSIA_EXT
//             Negative: false
//             Extends: VkDebugReportObjectTypeEXT
//             Offset: 0
pub const VK_FUCHSIA_extension_368_name = "VK_FUCHSIA_extension_368";
// Extension: VK_FUCHSIA_extension_368
// Number: 368
// Type: invalid
// Author: FUCHSIA
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_FUCHSIA_EXTENSION_368_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_FUCHSIA_EXTENSION_368_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_FUCHSIA_extension_368&quot;
pub const VK_QCOM_extension_369_name = "VK_QCOM_extension_369";
// Extension: VK_QCOM_extension_369
// Number: 369
// Type: invalid
// Author: QCOM
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_QCOM_EXTENSION_369_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_QCOM_EXTENSION_369_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_QCOM_extension_369&quot;
//         Enum:
//             Name: VK_DESCRIPTOR_BINDING_RESERVED_4_BIT_QCOM
//             Negative: false
//             Bitpos: 4
//             Extends: VkDescriptorBindingFlagBits
pub const VK_HUAWEI_subpass_shading_name = "VK_HUAWEI_subpass_shading";
// Extension: VK_HUAWEI_subpass_shading
// Number: 370
// Type: device
// Author: HUAWEI
// Depends: ((VK_KHR_create_renderpass2,VK_VERSION_1_2)+VK_KHR_synchronization2),VK_VERSION_1_3
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_HUAWEI_SUBPASS_SHADING_SPEC_VERSION
//             Negative: false
//             Value: 3
//         Enum:
//             Name: VK_HUAWEI_SUBPASS_SHADING_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_HUAWEI_subpass_shading&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SUBPASS_SHADING_PIPELINE_CREATE_INFO_HUAWEI
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_PROPERTIES_HUAWEI
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_PIPELINE_BIND_POINT_SUBPASS_SHADING_HUAWEI
//             Negative: false
//             Extends: VkPipelineBindPoint
//             Extnumber: 370
//             Offset: 3
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_SUBPASS_SHADER_BIT_HUAWEI
//             Negative: false
//             Bitpos: 39
//             Extends: VkPipelineStageFlagBits2
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI
//             Negative: false
//             Extends: VkPipelineStageFlagBits2
//             Alias: VK_PIPELINE_STAGE_2_SUBPASS_SHADER_BIT_HUAWEI
//         Enum:
//             Name: VK_SHADER_STAGE_SUBPASS_SHADING_BIT_HUAWEI
//             Negative: false
//             Bitpos: 14
//             Extends: VkShaderStageFlagBits
//         Type:
//             Name: VkSubpassShadingPipelineCreateInfoHUAWEI
//         Type:
//             Name: VkPhysicalDeviceSubpassShadingFeaturesHUAWEI
//         Type:
//             Name: VkPhysicalDeviceSubpassShadingPropertiesHUAWEI
//         Command:
//             Name: vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI
//         Command:
//             Name: vkCmdSubpassShadingHUAWEI
//         Feature:
//             Name: subpassShading
//             Struct: VkPhysicalDeviceSubpassShadingFeaturesHUAWEI
pub const VK_HUAWEI_invocation_mask_name = "VK_HUAWEI_invocation_mask";
// Extension: VK_HUAWEI_invocation_mask
// Number: 371
// Type: device
// Author: Huawei
// Depends: VK_KHR_ray_tracing_pipeline+(VK_KHR_synchronization2,VK_VERSION_1_3)
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_HUAWEI_INVOCATION_MASK_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_HUAWEI_INVOCATION_MASK_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_HUAWEI_invocation_mask&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_ACCESS_2_INVOCATION_MASK_READ_BIT_HUAWEI
//             Negative: false
//             Bitpos: 39
//             Extends: VkAccessFlagBits2
//         Enum:
//             Name: VK_IMAGE_USAGE_INVOCATION_MASK_BIT_HUAWEI
//             Negative: false
//             Bitpos: 18
//             Extends: VkImageUsageFlagBits
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_INVOCATION_MASK_BIT_HUAWEI
//             Negative: false
//             Bitpos: 40
//             Extends: VkPipelineStageFlagBits2
//         Type:
//             Name: VkPhysicalDeviceInvocationMaskFeaturesHUAWEI
//         Command:
//             Name: vkCmdBindInvocationMaskHUAWEI
//         Feature:
//             Name: invocationMask
//             Struct: VkPhysicalDeviceInvocationMaskFeaturesHUAWEI
pub const VK_NV_external_memory_rdma_name = "VK_NV_external_memory_rdma";
// Extension: VK_NV_external_memory_rdma
// Number: 372
// Type: device
// Author: NV
// Depends: VK_KHR_external_memory,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NV_EXTERNAL_MEMORY_RDMA_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_NV_EXTERNAL_MEMORY_RDMA_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_external_memory_rdma&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_MEMORY_GET_REMOTE_ADDRESS_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_RDMA_FEATURES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_MEMORY_PROPERTY_RDMA_CAPABLE_BIT_NV
//             Negative: false
//             Bitpos: 8
//             Extends: VkMemoryPropertyFlagBits
//         Enum:
//             Name: VK_EXTERNAL_MEMORY_HANDLE_TYPE_RDMA_ADDRESS_BIT_NV
//             Negative: false
//             Bitpos: 12
//             Extends: VkExternalMemoryHandleTypeFlagBits
//         Type:
//             Name: VkRemoteAddressNV
//         Type:
//             Name: VkMemoryGetRemoteAddressInfoNV
//         Type:
//             Name: VkPhysicalDeviceExternalMemoryRDMAFeaturesNV
//         Command:
//             Name: vkGetMemoryRemoteAddressNV
//         Feature:
//             Name: externalMemoryRDMA
//             Struct: VkPhysicalDeviceExternalMemoryRDMAFeaturesNV
pub const VK_EXT_pipeline_properties_name = "VK_EXT_pipeline_properties";
// Extension: VK_EXT_pipeline_properties
// Number: 373
// Type: device
// Author: EXT
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_PIPELINE_PROPERTIES_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_PIPELINE_PROPERTIES_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_pipeline_properties&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PIPELINE_PROPERTIES_IDENTIFIER_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROPERTIES_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PIPELINE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PIPELINE_INFO_KHR
//         Type:
//             Name: VkPipelineInfoEXT
//         Type:
//             Name: VkPipelinePropertiesIdentifierEXT
//         Type:
//             Name: VkPhysicalDevicePipelinePropertiesFeaturesEXT
//         Command:
//             Name: vkGetPipelinePropertiesEXT
//         Feature:
//             Name: pipelinePropertiesIdentifier
//             Struct: VkPhysicalDevicePipelinePropertiesFeaturesEXT
pub const VK_NV_external_sci_sync_name = "VK_NV_external_sci_sync";
// Extension: VK_NV_external_sci_sync
// Number: 374
// Type: device
// Author: NV
// Depends: VK_VERSION_1_1
// Platform: sci
// Supported: supported
// Deprecated by: VK_NV_external_sci_sync2
// Unlocks:
//         Enum:
//             Name: VK_NV_EXTERNAL_SCI_SYNC_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_NV_EXTERNAL_SCI_SYNC_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_external_sci_sync&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMPORT_FENCE_SCI_SYNC_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_EXPORT_FENCE_SCI_SYNC_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_FENCE_GET_SCI_SYNC_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SCI_SYNC_ATTRIBUTES_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_SCI_SYNC_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 4
//         Enum:
//             Name: VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_SCI_SYNC_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 5
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SEMAPHORE_GET_SCI_SYNC_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 6
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SCI_SYNC_FEATURES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 7
//         Enum:
//             Name: VK_EXTERNAL_FENCE_HANDLE_TYPE_SCI_SYNC_OBJ_BIT_NV
//             Negative: false
//             Bitpos: 4
//             Extends: VkExternalFenceHandleTypeFlagBits
//         Enum:
//             Name: VK_EXTERNAL_FENCE_HANDLE_TYPE_SCI_SYNC_FENCE_BIT_NV
//             Negative: false
//             Bitpos: 5
//             Extends: VkExternalFenceHandleTypeFlagBits
//         Enum:
//             Name: VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SCI_SYNC_OBJ_BIT_NV
//             Negative: false
//             Bitpos: 5
//             Extends: VkExternalSemaphoreHandleTypeFlagBits
//         Type:
//             Name: VkSciSyncClientTypeNV
//         Type:
//             Name: VkSciSyncPrimitiveTypeNV
//         Type:
//             Name: VkExportFenceSciSyncInfoNV
//         Type:
//             Name: VkImportFenceSciSyncInfoNV
//         Type:
//             Name: VkFenceGetSciSyncInfoNV
//         Type:
//             Name: VkSciSyncAttributesInfoNV
//         Type:
//             Name: VkExportSemaphoreSciSyncInfoNV
//         Type:
//             Name: VkImportSemaphoreSciSyncInfoNV
//         Type:
//             Name: VkSemaphoreGetSciSyncInfoNV
//         Type:
//             Name: VkPhysicalDeviceExternalSciSyncFeaturesNV
//         Command:
//             Name: vkGetFenceSciSyncFenceNV
//         Command:
//             Name: vkGetFenceSciSyncObjNV
//         Command:
//             Name: vkImportFenceSciSyncFenceNV
//         Command:
//             Name: vkImportFenceSciSyncObjNV
//         Command:
//             Name: vkGetPhysicalDeviceSciSyncAttributesNV
//         Command:
//             Name: vkGetSemaphoreSciSyncObjNV
//         Command:
//             Name: vkImportSemaphoreSciSyncObjNV
//         Feature:
//             Name: sciSyncFence,sciSyncSemaphore
//             Struct: VkPhysicalDeviceExternalSciSyncFeaturesNV
//         Feature:
//             Name: sciSyncImport,sciSyncExport
//             Struct: VkPhysicalDeviceExternalSciSyncFeaturesNV
pub const VK_NV_external_memory_sci_buf_name = "VK_NV_external_memory_sci_buf";
// Extension: VK_NV_external_memory_sci_buf
// Number: 375
// Type: device
// Author: NV
// Depends: VK_VERSION_1_1
// Platform: sci
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NV_EXTERNAL_MEMORY_SCI_BUF_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_NV_EXTERNAL_MEMORY_SCI_BUF_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_external_memory_sci_buf&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMPORT_MEMORY_SCI_BUF_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_EXPORT_MEMORY_SCI_BUF_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_MEMORY_GET_SCI_BUF_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_MEMORY_SCI_BUF_PROPERTIES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_SCI_BUF_FEATURES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 4
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SCI_BUF_FEATURES_NV
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_SCI_BUF_FEATURES_NV
//         Enum:
//             Name: VK_EXTERNAL_MEMORY_HANDLE_TYPE_SCI_BUF_BIT_NV
//             Negative: false
//             Bitpos: 13
//             Extends: VkExternalMemoryHandleTypeFlagBits
//         Type:
//             Name: VkExportMemorySciBufInfoNV
//         Type:
//             Name: VkImportMemorySciBufInfoNV
//         Type:
//             Name: VkMemoryGetSciBufInfoNV
//         Type:
//             Name: VkMemorySciBufPropertiesNV
//         Type:
//             Name: VkPhysicalDeviceExternalMemorySciBufFeaturesNV
//         Type:
//             Name: VkPhysicalDeviceExternalSciBufFeaturesNV
//         Command:
//             Name: vkGetMemorySciBufNV
//         Command:
//             Name: vkGetPhysicalDeviceExternalMemorySciBufPropertiesNV
//         Command:
//             Name: vkGetPhysicalDeviceSciBufAttributesNV
//         Feature:
//             Name: sciBufImport,sciBufExport
//             Struct: VkPhysicalDeviceExternalSciBufFeaturesNV
pub const VK_EXT_frame_boundary_name = "VK_EXT_frame_boundary";
// Extension: VK_EXT_frame_boundary
// Number: 376
// Type: device
// Author: EXT
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_FRAME_BOUNDARY_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_FRAME_BOUNDARY_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_frame_boundary&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAME_BOUNDARY_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Type:
//             Name: VkPhysicalDeviceFrameBoundaryFeaturesEXT
//         Type:
//             Name: VkFrameBoundaryEXT
//         Type:
//             Name: VkFrameBoundaryFlagBitsEXT
//         Type:
//             Name: VkFrameBoundaryFlagsEXT
//         Feature:
//             Name: frameBoundary
//             Struct: VkPhysicalDeviceFrameBoundaryFeaturesEXT
pub const VK_EXT_multisampled_render_to_single_sampled_name = "VK_EXT_multisampled_render_to_single_sampled";
// Extension: VK_EXT_multisampled_render_to_single_sampled
// Number: 377
// Type: device
// Author: EXT
// Depends: (VK_KHR_create_renderpass2+VK_KHR_depth_stencil_resolve),VK_VERSION_1_2
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_multisampled_render_to_single_sampled&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SUBPASS_RESOLVE_PERFORMANCE_QUERY_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_IMAGE_CREATE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_BIT_EXT
//             Negative: false
//             Bitpos: 18
//             Extends: VkImageCreateFlagBits
//         Type:
//             Name: VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT
//         Type:
//             Name: VkSubpassResolvePerformanceQueryEXT
//         Type:
//             Name: VkMultisampledRenderToSingleSampledInfoEXT
//         Feature:
//             Name: multisampledRenderToSingleSampled
//             Struct: VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT
pub const VK_EXT_extended_dynamic_state2_name = "VK_EXT_extended_dynamic_state2";
// Extension: VK_EXT_extended_dynamic_state2
// Number: 378
// Type: device
// Author: EXT
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_3
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENDED_DYNAMIC_STATE_2_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_EXTENDED_DYNAMIC_STATE_2_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extended_dynamic_state2&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//             Comment:
//                 Not promoted to 1.3
//         Enum:
//             Name: VK_DYNAMIC_STATE_PATCH_CONTROL_POINTS_EXT
//             Negative: false
//             Extends: VkDynamicState
//             Offset: 0
//             Comment:
//                 Not promoted to 1.3
//         Enum:
//             Name: VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE_EXT
//             Negative: false
//             Extends: VkDynamicState
//             Alias: VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE
//         Enum:
//             Name: VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE_EXT
//             Negative: false
//             Extends: VkDynamicState
//             Alias: VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE
//         Enum:
//             Name: VK_DYNAMIC_STATE_LOGIC_OP_EXT
//             Negative: false
//             Extends: VkDynamicState
//             Offset: 3
//             Comment:
//                 Not promoted to 1.3
//         Enum:
//             Name: VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE_EXT
//             Negative: false
//             Extends: VkDynamicState
//             Alias: VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE
//         Type:
//             Name: VkPhysicalDeviceExtendedDynamicState2FeaturesEXT
//         Command:
//             Name: vkCmdSetPatchControlPointsEXT
//             Comment:
//                 Not promoted to 1.3
//         Command:
//             Name: vkCmdSetRasterizerDiscardEnableEXT
//         Command:
//             Name: vkCmdSetDepthBiasEnableEXT
//         Command:
//             Name: vkCmdSetLogicOpEXT
//             Comment:
//                 Not promoted to 1.3
//         Command:
//             Name: vkCmdSetPrimitiveRestartEnableEXT
//         Feature:
//             Name: extendedDynamicState2
//             Struct: VkPhysicalDeviceExtendedDynamicState2FeaturesEXT
pub const VK_QNX_screen_surface_name = "VK_QNX_screen_surface";
// Extension: VK_QNX_screen_surface
// Number: 379
// Type: instance
// Author: QNX
// Depends: VK_KHR_surface
// Platform: screen
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_QNX_SCREEN_SURFACE_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_QNX_SCREEN_SURFACE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_QNX_screen_surface&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SCREEN_SURFACE_CREATE_INFO_QNX
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkScreenSurfaceCreateFlagsQNX
//         Type:
//             Name: VkScreenSurfaceCreateInfoQNX
//         Command:
//             Name: vkCreateScreenSurfaceQNX
//         Command:
//             Name: vkGetPhysicalDeviceScreenPresentationSupportQNX
pub const VK_KHR_extension_380_name = "VK_KHR_extension_380";
// Extension: VK_KHR_extension_380
// Number: 380
// Type: invalid
// Author: KHR
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_KHR_EXTENSION_380_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_KHR_EXTENSION_380_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_extension_380&quot;
//         Enum:
//             Name: VK_SWAPCHAIN_CREATE_RESERVED_5_BIT_EXT
//             Negative: false
//             Bitpos: 5
//             Extends: VkSwapchainCreateFlagBitsKHR
pub const VK_KHR_extension_381_name = "VK_KHR_extension_381";
// Extension: VK_KHR_extension_381
// Number: 381
// Type: invalid
// Author: KHR
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_KHR_EXTENSION_381_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_KHR_EXTENSION_381_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_extension_381&quot;
pub const VK_EXT_color_write_enable_name = "VK_EXT_color_write_enable";
// Extension: VK_EXT_color_write_enable
// Number: 382
// Type: device
// Author: EXT
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_COLOR_WRITE_ENABLE_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_COLOR_WRITE_ENABLE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_color_write_enable&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PIPELINE_COLOR_WRITE_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT
//             Negative: false
//             Extends: VkDynamicState
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceColorWriteEnableFeaturesEXT
//         Type:
//             Name: VkPipelineColorWriteCreateInfoEXT
//         Command:
//             Name: vkCmdSetColorWriteEnableEXT
//         Feature:
//             Name: colorWriteEnable
//             Struct: VkPhysicalDeviceColorWriteEnableFeaturesEXT
pub const VK_EXT_primitives_generated_query_name = "VK_EXT_primitives_generated_query";
// Extension: VK_EXT_primitives_generated_query
// Number: 383
// Type: device
// Author: EXT
// Depends: VK_EXT_transform_feedback
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_PRIMITIVES_GENERATED_QUERY_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_PRIMITIVES_GENERATED_QUERY_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_primitives_generated_query&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT
//             Negative: false
//             Extends: VkQueryType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT
//         Feature:
//             Name: primitivesGeneratedQuery
//             Struct: VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT
pub const VK_EXT_extension_384_name = "VK_EXT_extension_384";
// Extension: VK_EXT_extension_384
// Number: 384
// Type: instance
// Author: EXT
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_384_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_384_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_384&quot;
pub const VK_MESA_extension_385_name = "VK_MESA_extension_385";
// Extension: VK_MESA_extension_385
// Number: 385
// Type: instance
// Author: MESA
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_MESA_EXTENSION_385_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_MESA_EXTENSION_385_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_MESA_extension_385&quot;
pub const VK_GOOGLE_extension_386_name = "VK_GOOGLE_extension_386";
// Extension: VK_GOOGLE_extension_386
// Number: 386
// Type: invalid
// Author: GOOGLE
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_GOOGLE_EXTENSION_386_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_GOOGLE_EXTENSION_386_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_GOOGLE_extension_386&quot;
pub const VK_KHR_ray_tracing_maintenance1_name = "VK_KHR_ray_tracing_maintenance1";
// Extension: VK_KHR_ray_tracing_maintenance1
// Number: 387
// Type: device
// Author: KHR
// Depends: VK_KHR_acceleration_structure
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_RAY_TRACING_MAINTENANCE_1_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_RAY_TRACING_MAINTENANCE_1_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_ray_tracing_maintenance1&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_BOTTOM_LEVEL_POINTERS_KHR
//             Negative: false
//             Extends: VkQueryType
//             Offset: 0
//         Enum:
//             Name: VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SIZE_KHR
//             Negative: false
//             Extends: VkQueryType
//             Offset: 1
//         Type:
//             Name: VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR
//         Feature:
//             Name: rayTracingMaintenance1
//             Struct: VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR
//     Depends: VK_KHR_synchronization2,VK_VERSION_1_3
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_COPY_BIT_KHR
//             Negative: false
//             Bitpos: 28
//             Extends: VkPipelineStageFlagBits2
//     Depends: (VK_KHR_synchronization2,VK_VERSION_1_3)+VK_KHR_ray_tracing_pipeline
//         Enum:
//             Name: VK_ACCESS_2_SHADER_BINDING_TABLE_READ_BIT_KHR
//             Negative: false
//             Bitpos: 40
//             Extends: VkAccessFlagBits2
//     Depends: VK_KHR_ray_tracing_pipeline
//         Type:
//             Name: VkTraceRaysIndirectCommand2KHR
//         Command:
//             Name: vkCmdTraceRaysIndirect2KHR
//     Depends: VK_EXT_device_generated_commands
//         Enum:
//             Name: VK_INDIRECT_COMMANDS_TOKEN_TYPE_TRACE_RAYS2_EXT
//             Negative: false
//             Extends: VkIndirectCommandsTokenTypeEXT
//             Offset: 4
pub const VK_KHR_shader_untyped_pointers_name = "VK_KHR_shader_untyped_pointers";
// Extension: VK_KHR_shader_untyped_pointers
// Number: 388
// Type: device
// Author: KHR
// Depends: VK_KHR_get_physical_device_properties2
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_SHADER_UNTYPED_POINTERS_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_SHADER_UNTYPED_POINTERS_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_shader_untyped_pointers&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_UNTYPED_POINTERS_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceShaderUntypedPointersFeaturesKHR
//         Feature:
//             Name: shaderUntypedPointers
//             Struct: VkPhysicalDeviceShaderUntypedPointersFeaturesKHR
pub const VK_EXT_global_priority_query_name = "VK_EXT_global_priority_query";
// Extension: VK_EXT_global_priority_query
// Number: 389
// Type: device
// Author: EXT
// Depends: VK_EXT_global_priority+(VK_KHR_get_physical_device_properties2,VK_VERSION_1_1)
// Supported: supported
// Promoted to: VK_KHR_global_priority
// Unlocks:
//         Enum:
//             Name: VK_EXT_GLOBAL_PRIORITY_QUERY_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_GLOBAL_PRIORITY_QUERY_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_global_priority_query&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES
//         Enum:
//             Name: VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES
//         Enum:
//             Name: VK_MAX_GLOBAL_PRIORITY_SIZE_EXT
//             Negative: false
//             Alias: VK_MAX_GLOBAL_PRIORITY_SIZE
//         Type:
//             Name: VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT
//         Type:
//             Name: VkQueueFamilyGlobalPriorityPropertiesEXT
//         Feature:
//             Name: globalPriorityQuery
//             Struct: VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT
pub const VK_EXT_extension_390_name = "VK_EXT_extension_390";
// Extension: VK_EXT_extension_390
// Number: 390
// Type: invalid
// Author: EXT
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_390_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_390_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_390&quot;
pub const VK_VALVE_video_encode_rgb_conversion_name = "VK_VALVE_video_encode_rgb_conversion";
// Extension: VK_VALVE_video_encode_rgb_conversion
// Number: 391
// Type: device
// Author: VALVE
// Depends: VK_KHR_video_encode_queue+(VK_KHR_sampler_ycbcr_conversion,VK_VERSION_1_1)
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_VALVE_VIDEO_ENCODE_RGB_CONVERSION_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_VALVE_VIDEO_ENCODE_RGB_CONVERSION_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_VALVE_video_encode_rgb_conversion&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_RGB_CONVERSION_FEATURES_VALVE
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_RGB_CONVERSION_CAPABILITIES_VALVE
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_PROFILE_RGB_CONVERSION_INFO_VALVE
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_RGB_CONVERSION_CREATE_INFO_VALVE
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Type:
//             Name: VkPhysicalDeviceVideoEncodeRgbConversionFeaturesVALVE
//         Type:
//             Name: VkVideoEncodeRgbConversionCapabilitiesVALVE
//         Type:
//             Name: VkVideoEncodeProfileRgbConversionInfoVALVE
//         Type:
//             Name: VkVideoEncodeSessionRgbConversionCreateInfoVALVE
//         Type:
//             Name: VkVideoEncodeRgbModelConversionFlagBitsVALVE
//         Type:
//             Name: VkVideoEncodeRgbModelConversionFlagsVALVE
//         Type:
//             Name: VkVideoEncodeRgbRangeCompressionFlagBitsVALVE
//         Type:
//             Name: VkVideoEncodeRgbRangeCompressionFlagsVALVE
//         Type:
//             Name: VkVideoEncodeRgbChromaOffsetFlagBitsVALVE
//         Type:
//             Name: VkVideoEncodeRgbChromaOffsetFlagsVALVE
//         Feature:
//             Name: videoEncodeRgbConversion
//             Struct: VkPhysicalDeviceVideoEncodeRgbConversionFeaturesVALVE
pub const VK_EXT_image_view_min_lod_name = "VK_EXT_image_view_min_lod";
// Extension: VK_EXT_image_view_min_lod
// Number: 392
// Type: device
// Author: EXT
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_IMAGE_VIEW_MIN_LOD_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_IMAGE_VIEW_MIN_LOD_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_image_view_min_lod&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMAGE_VIEW_MIN_LOD_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Type:
//             Name: VkPhysicalDeviceImageViewMinLodFeaturesEXT
//         Type:
//             Name: VkImageViewMinLodCreateInfoEXT
//         Feature:
//             Name: minLod
//             Struct: VkPhysicalDeviceImageViewMinLodFeaturesEXT
pub const VK_EXT_multi_draw_name = "VK_EXT_multi_draw";
// Extension: VK_EXT_multi_draw
// Number: 393
// Type: device
// Author: EXT
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_MULTI_DRAW_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_MULTI_DRAW_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_multi_draw&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Type:
//             Name: VkPhysicalDeviceMultiDrawFeaturesEXT
//         Type:
//             Name: VkPhysicalDeviceMultiDrawPropertiesEXT
//         Command:
//             Name: vkCmdDrawMultiEXT
//         Command:
//             Name: vkCmdDrawMultiIndexedEXT
//         Type:
//             Name: VkMultiDrawInfoEXT
//         Type:
//             Name: VkMultiDrawIndexedInfoEXT
//         Feature:
//             Name: multiDraw
//             Struct: VkPhysicalDeviceMultiDrawFeaturesEXT
pub const VK_EXT_image_2d_view_of_3d_name = "VK_EXT_image_2d_view_of_3d";
// Extension: VK_EXT_image_2d_view_of_3d
// Number: 394
// Type: device
// Author: EXT
// Depends: (VK_KHR_maintenance1+VK_KHR_get_physical_device_properties2),VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_IMAGE_2D_VIEW_OF_3D_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_IMAGE_2D_VIEW_OF_3D_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_image_2d_view_of_3d&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceImage2DViewOf3DFeaturesEXT
//         Enum:
//             Name: VK_IMAGE_CREATE_2D_VIEW_COMPATIBLE_BIT_EXT
//             Negative: false
//             Bitpos: 17
//             Extends: VkImageCreateFlagBits
//             Comment:
//                 Image is created with a layout where individual slices are capable of being used as 2D images
//         Feature:
//             Name: image2DViewOf3D
//             Struct: VkPhysicalDeviceImage2DViewOf3DFeaturesEXT
pub const VK_KHR_portability_enumeration_name = "VK_KHR_portability_enumeration";
// Extension: VK_KHR_portability_enumeration
// Number: 395
// Type: instance
// Author: KHR
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_PORTABILITY_ENUMERATION_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_PORTABILITY_ENUMERATION_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_portability_enumeration&quot;
//         Enum:
//             Name: VK_INSTANCE_CREATE_ENUMERATE_PORTABILITY_BIT_KHR
//             Negative: false
//             Bitpos: 0
//             Extends: VkInstanceCreateFlagBits
pub const VK_EXT_shader_tile_image_name = "VK_EXT_shader_tile_image";
// Extension: VK_EXT_shader_tile_image
// Number: 396
// Type: device
// Author: EXT
// Depends: VK_VERSION_1_3
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_SHADER_TILE_IMAGE_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_SHADER_TILE_IMAGE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_shader_tile_image&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_PROPERTIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Type:
//             Name: VkPhysicalDeviceShaderTileImageFeaturesEXT
//         Type:
//             Name: VkPhysicalDeviceShaderTileImagePropertiesEXT
//         Feature:
//             Name: shaderTileImageColorReadAccess
//             Struct: VkPhysicalDeviceShaderTileImageFeaturesEXT
pub const VK_EXT_opacity_micromap_name = "VK_EXT_opacity_micromap";
// Extension: VK_EXT_opacity_micromap
// Number: 397
// Type: device
// Author: EXT
// Depends: VK_KHR_acceleration_structure+(VK_KHR_synchronization2,VK_VERSION_1_3)
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_OPACITY_MICROMAP_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_EXT_OPACITY_MICROMAP_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_opacity_micromap&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_MICROMAP_BUILD_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_MICROMAP_VERSION_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_COPY_MICROMAP_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_COPY_MICROMAP_TO_MEMORY_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Enum:
//             Name: VK_STRUCTURE_TYPE_COPY_MEMORY_TO_MICROMAP_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 4
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 5
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_PROPERTIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 6
//         Enum:
//             Name: VK_STRUCTURE_TYPE_MICROMAP_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 7
//         Enum:
//             Name: VK_STRUCTURE_TYPE_MICROMAP_BUILD_SIZES_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 8
//         Enum:
//             Name: VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_OPACITY_MICROMAP_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 9
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_MICROMAP_BUILD_BIT_EXT
//             Negative: false
//             Bitpos: 30
//             Extends: VkPipelineStageFlagBits2
//         Enum:
//             Name: VK_ACCESS_2_MICROMAP_READ_BIT_EXT
//             Negative: false
//             Bitpos: 44
//             Extends: VkAccessFlagBits2
//         Enum:
//             Name: VK_ACCESS_2_MICROMAP_WRITE_BIT_EXT
//             Negative: false
//             Bitpos: 45
//             Extends: VkAccessFlagBits2
//         Enum:
//             Name: VK_QUERY_TYPE_MICROMAP_SERIALIZATION_SIZE_EXT
//             Negative: false
//             Extends: VkQueryType
//             Offset: 0
//         Enum:
//             Name: VK_QUERY_TYPE_MICROMAP_COMPACTED_SIZE_EXT
//             Negative: false
//             Extends: VkQueryType
//             Offset: 1
//         Enum:
//             Name: VK_OBJECT_TYPE_MICROMAP_EXT
//             Negative: false
//             Extends: VkObjectType
//             Offset: 0
//         Enum:
//             Name: VK_BUFFER_USAGE_MICROMAP_BUILD_INPUT_READ_ONLY_BIT_EXT
//             Negative: false
//             Bitpos: 23
//             Extends: VkBufferUsageFlagBits
//         Enum:
//             Name: VK_BUFFER_USAGE_MICROMAP_STORAGE_BIT_EXT
//             Negative: false
//             Bitpos: 24
//             Extends: VkBufferUsageFlagBits
//         Enum:
//             Name: VK_PIPELINE_CREATE_RAY_TRACING_OPACITY_MICROMAP_BIT_EXT
//             Negative: false
//             Bitpos: 24
//             Extends: VkPipelineCreateFlagBits
//         Enum:
//             Name: VK_GEOMETRY_INSTANCE_FORCE_OPACITY_MICROMAP_2_STATE_BIT_EXT
//             Negative: false
//             Bitpos: 4
//             Extends: VkGeometryInstanceFlagBitsKHR
//         Enum:
//             Name: VK_GEOMETRY_INSTANCE_FORCE_OPACITY_MICROMAP_2_STATE_EXT
//             Negative: false
//             Extends: VkGeometryInstanceFlagBitsKHR
//             Alias: VK_GEOMETRY_INSTANCE_FORCE_OPACITY_MICROMAP_2_STATE_BIT_EXT
//         Enum:
//             Name: VK_GEOMETRY_INSTANCE_DISABLE_OPACITY_MICROMAPS_BIT_EXT
//             Negative: false
//             Bitpos: 5
//             Extends: VkGeometryInstanceFlagBitsKHR
//         Enum:
//             Name: VK_GEOMETRY_INSTANCE_DISABLE_OPACITY_MICROMAPS_EXT
//             Negative: false
//             Extends: VkGeometryInstanceFlagBitsKHR
//             Alias: VK_GEOMETRY_INSTANCE_DISABLE_OPACITY_MICROMAPS_BIT_EXT
//         Enum:
//             Name: VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_UPDATE_BIT_EXT
//             Negative: false
//             Bitpos: 6
//             Extends: VkBuildAccelerationStructureFlagBitsKHR
//         Enum:
//             Name: VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_UPDATE_EXT
//             Negative: false
//             Extends: VkBuildAccelerationStructureFlagBitsKHR
//             Alias: VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_UPDATE_BIT_EXT
//         Enum:
//             Name: VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DISABLE_OPACITY_MICROMAPS_BIT_EXT
//             Negative: false
//             Bitpos: 7
//             Extends: VkBuildAccelerationStructureFlagBitsKHR
//         Enum:
//             Name: VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DISABLE_OPACITY_MICROMAPS_EXT
//             Negative: false
//             Extends: VkBuildAccelerationStructureFlagBitsKHR
//             Alias: VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DISABLE_OPACITY_MICROMAPS_BIT_EXT
//         Enum:
//             Name: VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_DATA_UPDATE_BIT_EXT
//             Negative: false
//             Bitpos: 8
//             Extends: VkBuildAccelerationStructureFlagBitsKHR
//         Enum:
//             Name: VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_DATA_UPDATE_EXT
//             Negative: false
//             Extends: VkBuildAccelerationStructureFlagBitsKHR
//             Alias: VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_DATA_UPDATE_BIT_EXT
//         Type:
//             Name: VkMicromapTypeEXT
//         Type:
//             Name: VkMicromapBuildInfoEXT
//         Type:
//             Name: VkMicromapUsageEXT
//         Type:
//             Name: VkMicromapCreateInfoEXT
//         Type:
//             Name: VkMicromapEXT
//         Type:
//             Name: VkBuildMicromapFlagBitsEXT
//         Type:
//             Name: VkBuildMicromapFlagsEXT
//         Type:
//             Name: VkCopyMicromapModeEXT
//         Type:
//             Name: VkPhysicalDeviceOpacityMicromapFeaturesEXT
//         Type:
//             Name: VkPhysicalDeviceOpacityMicromapPropertiesEXT
//         Type:
//             Name: VkMicromapVersionInfoEXT
//         Type:
//             Name: VkCopyMicromapToMemoryInfoEXT
//         Type:
//             Name: VkCopyMemoryToMicromapInfoEXT
//         Type:
//             Name: VkCopyMicromapInfoEXT
//         Type:
//             Name: VkMicromapCreateFlagBitsEXT
//         Type:
//             Name: VkMicromapCreateFlagsEXT
//         Type:
//             Name: VkBuildMicromapModeEXT
//         Type:
//             Name: VkMicromapBuildSizesInfoEXT
//         Type:
//             Name: VkOpacityMicromapFormatEXT
//         Type:
//             Name: VkAccelerationStructureTrianglesOpacityMicromapEXT
//         Type:
//             Name: VkMicromapTriangleEXT
//         Type:
//             Name: VkOpacityMicromapSpecialIndexEXT
//         Command:
//             Name: vkCreateMicromapEXT
//         Command:
//             Name: vkDestroyMicromapEXT
//         Command:
//             Name: vkCmdBuildMicromapsEXT
//         Command:
//             Name: vkBuildMicromapsEXT
//         Command:
//             Name: vkCopyMicromapEXT
//         Command:
//             Name: vkCopyMicromapToMemoryEXT
//         Command:
//             Name: vkCopyMemoryToMicromapEXT
//         Command:
//             Name: vkWriteMicromapsPropertiesEXT
//         Command:
//             Name: vkCmdCopyMicromapEXT
//         Command:
//             Name: vkCmdCopyMicromapToMemoryEXT
//         Command:
//             Name: vkCmdCopyMemoryToMicromapEXT
//         Command:
//             Name: vkCmdWriteMicromapsPropertiesEXT
//         Command:
//             Name: vkGetDeviceMicromapCompatibilityEXT
//         Command:
//             Name: vkGetMicromapBuildSizesEXT
//         Feature:
//             Name: micromap
//             Struct: VkPhysicalDeviceOpacityMicromapFeaturesEXT
pub const VK_NV_displacement_micromap_name = "VK_NV_displacement_micromap";
// Extension: VK_NV_displacement_micromap
// Number: 398
// Type: device
// Author: NV
// Depends: VK_EXT_opacity_micromap
// Platform: provisional
// Supported: supported
// Deprecated by: VK_NV_cluster_acceleration_structure
// Unlocks:
//         Enum:
//             Name: VK_NV_DISPLACEMENT_MICROMAP_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_NV_DISPLACEMENT_MICROMAP_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_displacement_micromap&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISPLACEMENT_MICROMAP_FEATURES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISPLACEMENT_MICROMAP_PROPERTIES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_DISPLACEMENT_MICROMAP_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_PIPELINE_CREATE_RAY_TRACING_DISPLACEMENT_MICROMAP_BIT_NV
//             Negative: false
//             Bitpos: 28
//             Extends: VkPipelineCreateFlagBits
//         Enum:
//             Name: VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DISPLACEMENT_MICROMAP_UPDATE_BIT_NV
//             Negative: false
//             Bitpos: 9
//             Extends: VkBuildAccelerationStructureFlagBitsKHR
//         Enum:
//             Name: VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DISPLACEMENT_MICROMAP_UPDATE_NV
//             Negative: false
//             Extends: VkBuildAccelerationStructureFlagBitsKHR
//             Alias: VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DISPLACEMENT_MICROMAP_UPDATE_BIT_NV
//         Enum:
//             Name: VK_MICROMAP_TYPE_DISPLACEMENT_MICROMAP_NV
//             Negative: false
//             Extends: VkMicromapTypeEXT
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceDisplacementMicromapFeaturesNV
//         Type:
//             Name: VkPhysicalDeviceDisplacementMicromapPropertiesNV
//         Type:
//             Name: VkAccelerationStructureTrianglesDisplacementMicromapNV
//         Type:
//             Name: VkDisplacementMicromapFormatNV
//         Feature:
//             Name: displacementMicromap
//             Struct: VkPhysicalDeviceDisplacementMicromapFeaturesNV
pub const VK_JUICE_extension_399_name = "VK_JUICE_extension_399";
// Extension: VK_JUICE_extension_399
// Number: 399
// Type: invalid
// Author: JUICE
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_JUICE_EXTENSION_399_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_JUICE_EXTENSION_399_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_JUICE_extension_399&quot;
pub const VK_JUICE_extension_400_name = "VK_JUICE_extension_400";
// Extension: VK_JUICE_extension_400
// Number: 400
// Type: invalid
// Author: JUICE
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_JUICE_EXTENSION_400_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_JUICE_EXTENSION_400_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_JUICE_extension_400&quot;
pub const VK_EXT_load_store_op_none_name = "VK_EXT_load_store_op_none";
// Extension: VK_EXT_load_store_op_none
// Number: 401
// Type: device
// Author: EXT
// Supported: supported
// Promoted to: VK_KHR_load_store_op_none
// Unlocks:
//         Enum:
//             Name: VK_EXT_LOAD_STORE_OP_NONE_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_LOAD_STORE_OP_NONE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_load_store_op_none&quot;
//         Enum:
//             Name: VK_ATTACHMENT_LOAD_OP_NONE_EXT
//             Negative: false
//             Extends: VkAttachmentLoadOp
//             Alias: VK_ATTACHMENT_LOAD_OP_NONE
//         Enum:
//             Name: VK_ATTACHMENT_STORE_OP_NONE_EXT
//             Negative: false
//             Extends: VkAttachmentStoreOp
//             Alias: VK_ATTACHMENT_STORE_OP_NONE
pub const VK_FB_extension_402_name = "VK_FB_extension_402";
// Extension: VK_FB_extension_402
// Number: 402
// Type: invalid
// Author: FB
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_FB_EXTENSION_402_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_FB_EXTENSION_402_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_FB_extension_402&quot;
pub const VK_FB_extension_403_name = "VK_FB_extension_403";
// Extension: VK_FB_extension_403
// Number: 403
// Type: invalid
// Author: FB
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_FB_EXTENSION_403_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_FB_EXTENSION_403_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_FB_extension_403&quot;
pub const VK_FB_extension_404_name = "VK_FB_extension_404";
// Extension: VK_FB_extension_404
// Number: 404
// Type: invalid
// Author: FB
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_FB_EXTENSION_404_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_FB_EXTENSION_404_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_FB_extension_404&quot;
pub const VK_HUAWEI_cluster_culling_shader_name = "VK_HUAWEI_cluster_culling_shader";
// Extension: VK_HUAWEI_cluster_culling_shader
// Number: 405
// Type: device
// Author: HUAWEI
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_HUAWEI_CLUSTER_CULLING_SHADER_SPEC_VERSION
//             Negative: false
//             Value: 3
//         Enum:
//             Name: VK_HUAWEI_CLUSTER_CULLING_SHADER_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_HUAWEI_cluster_culling_shader&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_FEATURES_HUAWEI
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_PROPERTIES_HUAWEI
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_VRS_FEATURES_HUAWEI
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_CLUSTER_CULLING_SHADER_BIT_HUAWEI
//             Negative: false
//             Bitpos: 41
//             Extends: VkPipelineStageFlagBits2
//         Enum:
//             Name: VK_SHADER_STAGE_CLUSTER_CULLING_BIT_HUAWEI
//             Negative: false
//             Bitpos: 19
//             Extends: VkShaderStageFlagBits
//         Enum:
//             Name: VK_QUERY_PIPELINE_STATISTIC_CLUSTER_CULLING_SHADER_INVOCATIONS_BIT_HUAWEI
//             Negative: false
//             Bitpos: 13
//             Extends: VkQueryPipelineStatisticFlagBits
//         Command:
//             Name: vkCmdDrawClusterHUAWEI
//         Command:
//             Name: vkCmdDrawClusterIndirectHUAWEI
//         Type:
//             Name: VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI
//         Type:
//             Name: VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI
//         Type:
//             Name: VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI
//         Feature:
//             Name: clustercullingShader
//             Struct: VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI
pub const VK_HUAWEI_extension_406_name = "VK_HUAWEI_extension_406";
// Extension: VK_HUAWEI_extension_406
// Number: 406
// Type: invalid
// Author: HUAWEI
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_HUAWEI_EXTENSION_406_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_HUAWEI_EXTENSION_406_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_HUAWEI_extension_406&quot;
pub const VK_GGP_extension_407_name = "VK_GGP_extension_407";
// Extension: VK_GGP_extension_407
// Number: 407
// Type: invalid
// Author: GGP
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_GGP_EXTENSION_407_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_GGP_EXTENSION_407_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_GGP_extension_407&quot;
pub const VK_GGP_extension_408_name = "VK_GGP_extension_408";
// Extension: VK_GGP_extension_408
// Number: 408
// Type: invalid
// Author: GGP
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_GGP_EXTENSION_408_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_GGP_EXTENSION_408_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_GGP_extension_408&quot;
pub const VK_GGP_extension_409_name = "VK_GGP_extension_409";
// Extension: VK_GGP_extension_409
// Number: 409
// Type: invalid
// Author: GGP
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_GGP_EXTENSION_409_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_GGP_EXTENSION_409_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_GGP_extension_409&quot;
pub const VK_GGP_extension_410_name = "VK_GGP_extension_410";
// Extension: VK_GGP_extension_410
// Number: 410
// Type: invalid
// Author: GGP
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_GGP_EXTENSION_410_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_GGP_EXTENSION_410_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_GGP_extension_410&quot;
pub const VK_GGP_extension_411_name = "VK_GGP_extension_411";
// Extension: VK_GGP_extension_411
// Number: 411
// Type: invalid
// Author: GGP
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_GGP_EXTENSION_411_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_GGP_EXTENSION_411_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_GGP_extension_411&quot;
pub const VK_EXT_border_color_swizzle_name = "VK_EXT_border_color_swizzle";
// Extension: VK_EXT_border_color_swizzle
// Number: 412
// Type: device
// Author: EXT
// Depends: VK_EXT_custom_border_color
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_BORDER_COLOR_SWIZZLE_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_BORDER_COLOR_SWIZZLE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_border_color_swizzle&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Type:
//             Name: VkPhysicalDeviceBorderColorSwizzleFeaturesEXT
//         Type:
//             Name: VkSamplerBorderColorComponentMappingCreateInfoEXT
//         Feature:
//             Name: borderColorSwizzle
//             Struct: VkPhysicalDeviceBorderColorSwizzleFeaturesEXT
pub const VK_EXT_pageable_device_local_memory_name = "VK_EXT_pageable_device_local_memory";
// Extension: VK_EXT_pageable_device_local_memory
// Number: 413
// Type: device
// Author: EXT
// Depends: VK_EXT_memory_priority
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_PAGEABLE_DEVICE_LOCAL_MEMORY_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_PAGEABLE_DEVICE_LOCAL_MEMORY_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_pageable_device_local_memory&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT
//         Command:
//             Name: vkSetDeviceMemoryPriorityEXT
//         Feature:
//             Name: pageableDeviceLocalMemory
//             Struct: VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT
pub const VK_KHR_maintenance4_name = "VK_KHR_maintenance4";
// Extension: VK_KHR_maintenance4
// Number: 414
// Type: device
// Author: KHR
// Depends: VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_3
// Unlocks:
//         Enum:
//             Name: VK_KHR_MAINTENANCE_4_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_KHR_MAINTENANCE_4_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_maintenance4&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS
//         Enum:
//             Name: VK_IMAGE_ASPECT_NONE_KHR
//             Negative: false
//             Extends: VkImageAspectFlagBits
//             Alias: VK_IMAGE_ASPECT_NONE
//         Type:
//             Name: VkPhysicalDeviceMaintenance4FeaturesKHR
//         Type:
//             Name: VkPhysicalDeviceMaintenance4PropertiesKHR
//         Type:
//             Name: VkDeviceBufferMemoryRequirementsKHR
//         Type:
//             Name: VkDeviceImageMemoryRequirementsKHR
//         Command:
//             Name: vkGetDeviceBufferMemoryRequirementsKHR
//         Command:
//             Name: vkGetDeviceImageMemoryRequirementsKHR
//         Command:
//             Name: vkGetDeviceImageSparseMemoryRequirementsKHR
//         Feature:
//             Name: maintenance4
//             Struct: VkPhysicalDeviceMaintenance4FeaturesKHR
pub const VK_HUAWEI_extension_415_name = "VK_HUAWEI_extension_415";
// Extension: VK_HUAWEI_extension_415
// Number: 415
// Type: invalid
// Author: HUAWEI
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_HUAWEI_EXTENSION_415_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_HUAWEI_EXTENSION_415_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_HUAWEI_extension_415&quot;
pub const VK_ARM_shader_core_properties_name = "VK_ARM_shader_core_properties";
// Extension: VK_ARM_shader_core_properties
// Number: 416
// Type: device
// Author: ARM
// Depends: VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_ARM_SHADER_CORE_PROPERTIES_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_ARM_SHADER_CORE_PROPERTIES_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_ARM_shader_core_properties&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceShaderCorePropertiesARM
pub const VK_KHR_shader_subgroup_rotate_name = "VK_KHR_shader_subgroup_rotate";
// Extension: VK_KHR_shader_subgroup_rotate
// Number: 417
// Type: device
// Author: KHR
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_4
// Unlocks:
//         Enum:
//             Name: VK_KHR_SHADER_SUBGROUP_ROTATE_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_KHR_SHADER_SUBGROUP_ROTATE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_shader_subgroup_rotate&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_ROTATE_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_ROTATE_FEATURES
//         Enum:
//             Name: VK_SUBGROUP_FEATURE_ROTATE_BIT_KHR
//             Negative: false
//             Extends: VkSubgroupFeatureFlagBits
//             Alias: VK_SUBGROUP_FEATURE_ROTATE_BIT
//         Enum:
//             Name: VK_SUBGROUP_FEATURE_ROTATE_CLUSTERED_BIT_KHR
//             Negative: false
//             Extends: VkSubgroupFeatureFlagBits
//             Alias: VK_SUBGROUP_FEATURE_ROTATE_CLUSTERED_BIT
//         Type:
//             Name: VkPhysicalDeviceShaderSubgroupRotateFeaturesKHR
//         Feature:
//             Name: shaderSubgroupRotate
//             Struct: VkPhysicalDeviceShaderSubgroupRotateFeaturesKHR
pub const VK_ARM_scheduling_controls_name = "VK_ARM_scheduling_controls";
// Extension: VK_ARM_scheduling_controls
// Number: 418
// Type: device
// Author: ARM
// Depends: VK_ARM_shader_core_builtins
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_ARM_SCHEDULING_CONTROLS_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_ARM_SCHEDULING_CONTROLS_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_ARM_scheduling_controls&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DEVICE_QUEUE_SHADER_CORE_CONTROL_CREATE_INFO_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_FEATURES_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_PROPERTIES_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Type:
//             Name: VkDeviceQueueShaderCoreControlCreateInfoARM
//         Type:
//             Name: VkPhysicalDeviceSchedulingControlsFeaturesARM
//         Type:
//             Name: VkPhysicalDeviceSchedulingControlsPropertiesARM
//         Type:
//             Name: VkPhysicalDeviceSchedulingControlsFlagsARM
//         Type:
//             Name: VkPhysicalDeviceSchedulingControlsFlagBitsARM
//         Feature:
//             Name: schedulingControls
//             Struct: VkPhysicalDeviceSchedulingControlsFeaturesARM
pub const VK_EXT_image_sliced_view_of_3d_name = "VK_EXT_image_sliced_view_of_3d";
// Extension: VK_EXT_image_sliced_view_of_3d
// Number: 419
// Type: device
// Author: EXT
// Depends: (VK_KHR_maintenance1+VK_KHR_get_physical_device_properties2),VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_IMAGE_SLICED_VIEW_OF_3D_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_IMAGE_SLICED_VIEW_OF_3D_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_image_sliced_view_of_3d&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_SLICED_VIEW_OF_3D_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMAGE_VIEW_SLICED_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_REMAINING_3D_SLICES_EXT
//             Negative: false
//         Type:
//             Name: VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT
//         Type:
//             Name: VkImageViewSlicedCreateInfoEXT
//         Feature:
//             Name: imageSlicedViewOf3D
//             Struct: VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT
pub const VK_EXT_extension_420_name = "VK_EXT_extension_420";
// Extension: VK_EXT_extension_420
// Number: 420
// Type: device
// Author: EXT
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_420_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_420_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_420&quot;
//         Enum:
//             Name: VK_SWAPCHAIN_CREATE_RESERVED_4_BIT_EXT
//             Negative: false
//             Bitpos: 4
//             Extends: VkSwapchainCreateFlagBitsKHR
pub const VK_VALVE_descriptor_set_host_mapping_name = "VK_VALVE_descriptor_set_host_mapping";
// Extension: VK_VALVE_descriptor_set_host_mapping
// Number: 421
// Type: device
// Author: VALVE
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_VALVE_DESCRIPTOR_SET_HOST_MAPPING_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_VALVE_DESCRIPTOR_SET_HOST_MAPPING_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_VALVE_descriptor_set_host_mapping&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DESCRIPTOR_SET_BINDING_REFERENCE_VALVE
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_HOST_MAPPING_INFO_VALVE
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Type:
//             Name: VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE
//         Type:
//             Name: VkDescriptorSetBindingReferenceVALVE
//         Type:
//             Name: VkDescriptorSetLayoutHostMappingInfoVALVE
//         Command:
//             Name: vkGetDescriptorSetLayoutHostMappingInfoVALVE
//         Command:
//             Name: vkGetDescriptorSetHostMappingVALVE
//         Feature:
//             Name: descriptorSetHostMapping
//             Struct: VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE
pub const VK_EXT_depth_clamp_zero_one_name = "VK_EXT_depth_clamp_zero_one";
// Extension: VK_EXT_depth_clamp_zero_one
// Number: 422
// Type: device
// Author: EXT
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_KHR_depth_clamp_zero_one
// Unlocks:
//         Enum:
//             Name: VK_EXT_DEPTH_CLAMP_ZERO_ONE_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_DEPTH_CLAMP_ZERO_ONE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_depth_clamp_zero_one&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_KHR
//         Type:
//             Name: VkPhysicalDeviceDepthClampZeroOneFeaturesEXT
//         Feature:
//             Name: depthClampZeroOne
//             Struct: VkPhysicalDeviceDepthClampZeroOneFeaturesEXT
pub const VK_EXT_non_seamless_cube_map_name = "VK_EXT_non_seamless_cube_map";
// Extension: VK_EXT_non_seamless_cube_map
// Number: 423
// Type: device
// Author: EXT
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_NON_SEAMLESS_CUBE_MAP_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_NON_SEAMLESS_CUBE_MAP_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_non_seamless_cube_map&quot;
//         Enum:
//             Name: VK_SAMPLER_CREATE_NON_SEAMLESS_CUBE_MAP_BIT_EXT
//             Negative: false
//             Bitpos: 2
//             Extends: VkSamplerCreateFlagBits
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT
//         Feature:
//             Name: nonSeamlessCubeMap
//             Struct: VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT
pub const VK_ARM_extension_424_name = "VK_ARM_extension_424";
// Extension: VK_ARM_extension_424
// Number: 424
// Type: invalid
// Author: ARM
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_ARM_EXTENSION_424_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_ARM_EXTENSION_424_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_ARM_extension_424&quot;
pub const VK_ARM_render_pass_striped_name = "VK_ARM_render_pass_striped";
// Extension: VK_ARM_render_pass_striped
// Number: 425
// Type: device
// Author: ARM
// Depends: ((VK_KHR_get_physical_device_properties2,VK_VERSION_1_1)+VK_KHR_synchronization2),VK_VERSION_1_3
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_ARM_RENDER_PASS_STRIPED_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_ARM_RENDER_PASS_STRIPED_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_ARM_render_pass_striped&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_FEATURES_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_PROPERTIES_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_BEGIN_INFO_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_INFO_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Enum:
//             Name: VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_SUBMIT_INFO_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 4
//         Type:
//             Name: VkPhysicalDeviceRenderPassStripedFeaturesARM
//         Type:
//             Name: VkPhysicalDeviceRenderPassStripedPropertiesARM
//         Type:
//             Name: VkRenderPassStripeBeginInfoARM
//         Type:
//             Name: VkRenderPassStripeInfoARM
//         Type:
//             Name: VkRenderPassStripeSubmitInfoARM
//         Feature:
//             Name: renderPassStriped
//             Struct: VkPhysicalDeviceRenderPassStripedFeaturesARM
pub const VK_QCOM_fragment_density_map_offset_name = "VK_QCOM_fragment_density_map_offset";
// Extension: VK_QCOM_fragment_density_map_offset
// Number: 426
// Type: device
// Author: QCOM
// Depends: (VK_KHR_get_physical_device_properties2,VK_VERSION_1_1)+VK_EXT_fragment_density_map
// Supported: supported
// Promoted to: VK_EXT_fragment_density_map_offset
// Unlocks:
//         Enum:
//             Name: VK_QCOM_FRAGMENT_DENSITY_MAP_OFFSET_SPEC_VERSION
//             Negative: false
//             Value: 3
//         Enum:
//             Name: VK_QCOM_FRAGMENT_DENSITY_MAP_OFFSET_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_QCOM_fragment_density_map_offset&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_QCOM
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_EXT
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_QCOM
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_EXT
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SUBPASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_QCOM
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_EXT
//         Enum:
//             Name: VK_IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_QCOM
//             Negative: false
//             Extends: VkImageCreateFlagBits
//             Alias: VK_IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_EXT
//         Type:
//             Name: VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM
//         Type:
//             Name: VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM
//         Type:
//             Name: VkSubpassFragmentDensityMapOffsetEndInfoQCOM
//         Feature:
//             Name: fragmentDensityMapOffset
//             Struct: VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM
pub const VK_NV_copy_memory_indirect_name = "VK_NV_copy_memory_indirect";
// Extension: VK_NV_copy_memory_indirect
// Number: 427
// Type: device
// Author: NV
// Depends: ((VK_KHR_get_physical_device_properties2,VK_VERSION_1_1)+VK_KHR_buffer_device_address),VK_VERSION_1_2
// Supported: supported
// Promoted to: VK_KHR_copy_memory_indirect
// Unlocks:
//         Enum:
//             Name: VK_NV_COPY_MEMORY_INDIRECT_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_NV_COPY_MEMORY_INDIRECT_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_copy_memory_indirect&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_FEATURES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_PROPERTIES_NV
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_PROPERTIES_KHR
//         Type:
//             Name: VkCopyMemoryIndirectCommandNV
//         Type:
//             Name: VkCopyMemoryToImageIndirectCommandNV
//         Type:
//             Name: VkPhysicalDeviceCopyMemoryIndirectFeaturesNV
//         Type:
//             Name: VkPhysicalDeviceCopyMemoryIndirectPropertiesNV
//         Command:
//             Name: vkCmdCopyMemoryIndirectNV
//         Command:
//             Name: vkCmdCopyMemoryToImageIndirectNV
//         Feature:
//             Name: indirectCopy
//             Struct: VkPhysicalDeviceCopyMemoryIndirectFeaturesNV
pub const VK_NV_memory_decompression_name = "VK_NV_memory_decompression";
// Extension: VK_NV_memory_decompression
// Number: 428
// Type: device
// Author: NV
// Depends: ((VK_KHR_get_physical_device_properties2,VK_VERSION_1_1)+VK_KHR_buffer_device_address),VK_VERSION_1_2
// Supported: supported
// Promoted to: VK_EXT_memory_decompression
// Unlocks:
//         Enum:
//             Name: VK_NV_MEMORY_DECOMPRESSION_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_NV_MEMORY_DECOMPRESSION_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_memory_decompression&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_FEATURES_NV
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_FEATURES_EXT
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_PROPERTIES_NV
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_PROPERTIES_EXT
//         Type:
//             Name: VkMemoryDecompressionMethodFlagBitsNV
//         Type:
//             Name: VkMemoryDecompressionMethodFlagsNV
//         Type:
//             Name: VkDecompressMemoryRegionNV
//         Type:
//             Name: VkPhysicalDeviceMemoryDecompressionFeaturesNV
//         Type:
//             Name: VkPhysicalDeviceMemoryDecompressionPropertiesNV
//         Command:
//             Name: vkCmdDecompressMemoryNV
//         Command:
//             Name: vkCmdDecompressMemoryIndirectCountNV
//         Feature:
//             Name: memoryDecompression
//             Struct: VkPhysicalDeviceMemoryDecompressionFeaturesNV
pub const VK_NV_device_generated_commands_compute_name = "VK_NV_device_generated_commands_compute";
// Extension: VK_NV_device_generated_commands_compute
// Number: 429
// Type: device
// Author: NV
// Depends: VK_NV_device_generated_commands
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NV_DEVICE_GENERATED_COMMANDS_COMPUTE_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_NV_DEVICE_GENERATED_COMMANDS_COMPUTE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_device_generated_commands_compute&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_COMPUTE_FEATURES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_INDIRECT_BUFFER_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PIPELINE_INDIRECT_DEVICE_ADDRESS_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_INDIRECT_COMMANDS_TOKEN_TYPE_PIPELINE_NV
//             Negative: false
//             Extends: VkIndirectCommandsTokenTypeNV
//             Offset: 3
//         Enum:
//             Name: VK_INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_NV
//             Negative: false
//             Extends: VkIndirectCommandsTokenTypeNV
//             Offset: 4
//         Enum:
//             Name: VK_DESCRIPTOR_SET_LAYOUT_CREATE_INDIRECT_BINDABLE_BIT_NV
//             Negative: false
//             Bitpos: 7
//             Extends: VkDescriptorSetLayoutCreateFlagBits
//         Type:
//             Name: VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV
//         Type:
//             Name: VkComputePipelineIndirectBufferInfoNV
//         Type:
//             Name: VkPipelineIndirectDeviceAddressInfoNV
//         Type:
//             Name: VkBindPipelineIndirectCommandNV
//         Command:
//             Name: vkGetPipelineIndirectMemoryRequirementsNV
//         Command:
//             Name: vkCmdUpdatePipelineIndirectBufferNV
//         Command:
//             Name: vkGetPipelineIndirectDeviceAddressNV
//         Feature:
//             Name: deviceGeneratedCompute
//             Struct: VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV
pub const VK_NV_ray_tracing_linear_swept_spheres_name = "VK_NV_ray_tracing_linear_swept_spheres";
// Extension: VK_NV_ray_tracing_linear_swept_spheres
// Number: 430
// Type: device
// Author: NV
// Depends: VK_KHR_ray_tracing_pipeline
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NV_RAY_TRACING_LINEAR_SWEPT_SPHERES_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_NV_RAY_TRACING_LINEAR_SWEPT_SPHERES_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_ray_tracing_linear_swept_spheres&quot;
//         Enum:
//             Name: VK_GEOMETRY_TYPE_SPHERES_NV
//             Negative: false
//             Extends: VkGeometryTypeKHR
//             Offset: 4
//         Enum:
//             Name: VK_GEOMETRY_TYPE_LINEAR_SWEPT_SPHERES_NV
//             Negative: false
//             Extends: VkGeometryTypeKHR
//             Offset: 5
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_LINEAR_SWEPT_SPHERES_FEATURES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 8
//         Enum:
//             Name: VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_LINEAR_SWEPT_SPHERES_DATA_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 9
//         Enum:
//             Name: VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_SPHERES_DATA_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 10
//         Enum:
//             Name: VK_PIPELINE_CREATE_2_RAY_TRACING_ALLOW_SPHERES_AND_LINEAR_SWEPT_SPHERES_BIT_NV
//             Negative: false
//             Bitpos: 33
//             Extends: VkPipelineCreateFlagBits2
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_ACCELERATION_STRUCTURE_RADIUS_BUFFER_BIT_NV
//             Negative: false
//             Bitpos: 51
//             Extends: VkFormatFeatureFlagBits2
//         Type:
//             Name: VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV
//         Type:
//             Name: VkAccelerationStructureGeometryLinearSweptSpheresDataNV
//         Type:
//             Name: VkAccelerationStructureGeometrySpheresDataNV
//         Type:
//             Name: VkRayTracingLssIndexingModeNV
//         Type:
//             Name: VkRayTracingLssPrimitiveEndCapsModeNV
//         Feature:
//             Name: spheres,linearSweptSpheres
//             Struct: VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV
pub const VK_NV_linear_color_attachment_name = "VK_NV_linear_color_attachment";
// Extension: VK_NV_linear_color_attachment
// Number: 431
// Type: device
// Author: NVIDIA
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NV_LINEAR_COLOR_ATTACHMENT_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_NV_LINEAR_COLOR_ATTACHMENT_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_linear_color_attachment&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINEAR_COLOR_ATTACHMENT_FEATURES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceLinearColorAttachmentFeaturesNV
//         Feature:
//             Name: linearColorAttachment
//             Struct: VkPhysicalDeviceLinearColorAttachmentFeaturesNV
//     Depends: VK_KHR_format_feature_flags2,VK_VERSION_1_3
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_LINEAR_COLOR_ATTACHMENT_BIT_NV
//             Negative: false
//             Bitpos: 38
//             Extends: VkFormatFeatureFlagBits2
//             Comment:
//                 Format support linear image as render target, it cannot be mixed with non linear attachment
pub const VK_NV_extension_432_name = "VK_NV_extension_432";
// Extension: VK_NV_extension_432
// Number: 432
// Type: invalid
// Author: NV
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_NV_EXTENSION_432_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_NV_EXTENSION_432_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_extension_432&quot;
pub const VK_NV_extension_433_name = "VK_NV_extension_433";
// Extension: VK_NV_extension_433
// Number: 433
// Type: invalid
// Author: NV
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_NV_EXTENSION_433_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_NV_EXTENSION_433_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_extension_433&quot;
pub const VK_GOOGLE_surfaceless_query_name = "VK_GOOGLE_surfaceless_query";
// Extension: VK_GOOGLE_surfaceless_query
// Number: 434
// Type: instance
// Author: GOOGLE
// Depends: VK_KHR_surface
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_GOOGLE_SURFACELESS_QUERY_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_GOOGLE_SURFACELESS_QUERY_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_GOOGLE_surfaceless_query&quot;
pub const VK_KHR_shader_maximal_reconvergence_name = "VK_KHR_shader_maximal_reconvergence";
// Extension: VK_KHR_shader_maximal_reconvergence
// Number: 435
// Type: device
// Author: KHR
// Depends: VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_SHADER_MAXIMAL_RECONVERGENCE_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_SHADER_MAXIMAL_RECONVERGENCE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_shader_maximal_reconvergence&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MAXIMAL_RECONVERGENCE_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR
//         Feature:
//             Name: shaderMaximalReconvergence
//             Struct: VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR
pub const VK_EXT_application_parameters_name = "VK_EXT_application_parameters";
// Extension: VK_EXT_application_parameters
// Number: 436
// Type: instance
// Author: EXT
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_APPLICATION_PARAMETERS_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_APPLICATION_PARAMETERS_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_application_parameters&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_APPLICATION_PARAMETERS_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkApplicationParametersEXT
pub const VK_EXT_extension_437_name = "VK_EXT_extension_437";
// Extension: VK_EXT_extension_437
// Number: 437
// Type: invalid
// Author: EXT
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_437_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_437_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_437&quot;
pub const VK_EXT_image_compression_control_swapchain_name = "VK_EXT_image_compression_control_swapchain";
// Extension: VK_EXT_image_compression_control_swapchain
// Number: 438
// Type: device
// Author: EXT
// Depends: VK_EXT_image_compression_control
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_image_compression_control_swapchain&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT
//         Feature:
//             Name: imageCompressionControlSwapchain
//             Struct: VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT
pub const VK_SEC_extension_439_name = "VK_SEC_extension_439";
// Extension: VK_SEC_extension_439
// Number: 439
// Type: invalid
// Author: SEC
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_SEC_EXTENSION_439_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_SEC_EXTENSION_439_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_SEC_extension_439&quot;
pub const VK_QCOM_extension_440_name = "VK_QCOM_extension_440";
// Extension: VK_QCOM_extension_440
// Number: 440
// Type: invalid
// Author: QCOM
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_QCOM_EXTENSION_440_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_QCOM_EXTENSION_440_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_QCOM_extension_440&quot;
//         Enum:
//             Name: VK_QUEUE_RESERVED_7_BIT_QCOM
//             Negative: false
//             Bitpos: 7
//             Extends: VkQueueFlagBits
//         Enum:
//             Name: VK_DEVICE_QUEUE_CREATE_RESERVED_1_BIT_QCOM
//             Negative: false
//             Bitpos: 1
//             Extends: VkDeviceQueueCreateFlagBits
pub const VK_QCOM_image_processing_name = "VK_QCOM_image_processing";
// Extension: VK_QCOM_image_processing
// Number: 441
// Type: device
// Author: QCOM
// Depends: VK_KHR_format_feature_flags2,VK_VERSION_1_3
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_QCOM_IMAGE_PROCESSING_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_QCOM_IMAGE_PROCESSING_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_QCOM_image_processing&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_FEATURES_QCOM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_PROPERTIES_QCOM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMAGE_VIEW_SAMPLE_WEIGHT_CREATE_INFO_QCOM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM
//             Negative: false
//             Bitpos: 4
//             Extends: VkSamplerCreateFlagBits
//         Enum:
//             Name: VK_IMAGE_USAGE_SAMPLE_WEIGHT_BIT_QCOM
//             Negative: false
//             Bitpos: 20
//             Extends: VkImageUsageFlagBits
//         Enum:
//             Name: VK_IMAGE_USAGE_SAMPLE_BLOCK_MATCH_BIT_QCOM
//             Negative: false
//             Bitpos: 21
//             Extends: VkImageUsageFlagBits
//         Enum:
//             Name: VK_DESCRIPTOR_TYPE_SAMPLE_WEIGHT_IMAGE_QCOM
//             Negative: false
//             Extends: VkDescriptorType
//             Offset: 0
//         Enum:
//             Name: VK_DESCRIPTOR_TYPE_BLOCK_MATCH_IMAGE_QCOM
//             Negative: false
//             Extends: VkDescriptorType
//             Offset: 1
//         Type:
//             Name: VkImageViewSampleWeightCreateInfoQCOM
//         Type:
//             Name: VkPhysicalDeviceImageProcessingFeaturesQCOM
//         Type:
//             Name: VkPhysicalDeviceImageProcessingPropertiesQCOM
//         Feature:
//             Name: textureSampleWeighted
//             Struct: VkPhysicalDeviceImageProcessingFeaturesQCOM
//         Feature:
//             Name: textureBlockMatch
//             Struct: VkPhysicalDeviceImageProcessingFeaturesQCOM
//         Feature:
//             Name: textureBoxFilter
//             Struct: VkPhysicalDeviceImageProcessingFeaturesQCOM
//     Depends: VK_KHR_format_feature_flags2,VK_VERSION_1_3
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_WEIGHT_IMAGE_BIT_QCOM
//             Negative: false
//             Bitpos: 34
//             Extends: VkFormatFeatureFlagBits2
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_WEIGHT_SAMPLED_IMAGE_BIT_QCOM
//             Negative: false
//             Bitpos: 35
//             Extends: VkFormatFeatureFlagBits2
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM
//             Negative: false
//             Bitpos: 36
//             Extends: VkFormatFeatureFlagBits2
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_BOX_FILTER_SAMPLED_BIT_QCOM
//             Negative: false
//             Bitpos: 37
//             Extends: VkFormatFeatureFlagBits2
pub const VK_COREAVI_extension_442_name = "VK_COREAVI_extension_442";
// Extension: VK_COREAVI_extension_442
// Number: 442
// Type: invalid
// Author: COREAVI
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_COREAVI_EXTENSION_442_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_COREAVI_EXTENSION_442_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_COREAVI_extension_442&quot;
pub const VK_COREAVI_extension_443_name = "VK_COREAVI_extension_443";
// Extension: VK_COREAVI_extension_443
// Number: 443
// Type: invalid
// Author: COREAVI
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_COREAVI_EXTENSION_443_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_COREAVI_EXTENSION_443_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_COREAVI_extension_443&quot;
pub const VK_COREAVI_extension_444_name = "VK_COREAVI_extension_444";
// Extension: VK_COREAVI_extension_444
// Number: 444
// Type: invalid
// Author: COREAVI
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_COREAVI_EXTENSION_444_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_COREAVI_EXTENSION_444_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_COREAVI_extension_444&quot;
//         Enum:
//             Name: VK_COMMAND_POOL_RESET_RESERVED_1_BIT_COREAVI
//             Negative: false
//             Bitpos: 1
//             Extends: VkCommandPoolResetFlagBits
pub const VK_COREAVI_extension_445_name = "VK_COREAVI_extension_445";
// Extension: VK_COREAVI_extension_445
// Number: 445
// Type: invalid
// Author: COREAVI
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_COREAVI_EXTENSION_445_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_COREAVI_EXTENSION_445_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_COREAVI_extension_445&quot;
pub const VK_COREAVI_extension_446_name = "VK_COREAVI_extension_446";
// Extension: VK_COREAVI_extension_446
// Number: 446
// Type: invalid
// Author: COREAVI
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_COREAVI_EXTENSION_446_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_COREAVI_EXTENSION_446_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_COREAVI_extension_446&quot;
//         Enum:
//             Name: VK_IMAGE_USAGE_RESERVED_24_BIT_COREAVI
//             Negative: false
//             Bitpos: 24
//             Extends: VkImageUsageFlagBits
pub const VK_COREAVI_extension_447_name = "VK_COREAVI_extension_447";
// Extension: VK_COREAVI_extension_447
// Number: 447
// Type: invalid
// Author: COREAVI
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_COREAVI_EXTENSION_447_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_COREAVI_EXTENSION_447_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_COREAVI_extension_447&quot;
pub const VK_SEC_extension_448_name = "VK_SEC_extension_448";
// Extension: VK_SEC_extension_448
// Number: 448
// Type: invalid
// Author: SEC
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_SEC_EXTENSION_448_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_SEC_EXTENSION_448_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_SEC_extension_448&quot;
pub const VK_SEC_extension_449_name = "VK_SEC_extension_449";
// Extension: VK_SEC_extension_449
// Number: 449
// Type: invalid
// Author: SEC
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_SEC_EXTENSION_449_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_SEC_EXTENSION_449_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_SEC_extension_449&quot;
pub const VK_SEC_extension_450_name = "VK_SEC_extension_450";
// Extension: VK_SEC_extension_450
// Number: 450
// Type: invalid
// Author: SEC
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_SEC_EXTENSION_450_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_SEC_EXTENSION_450_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_SEC_extension_450&quot;
pub const VK_SEC_extension_451_name = "VK_SEC_extension_451";
// Extension: VK_SEC_extension_451
// Number: 451
// Type: invalid
// Author: SEC
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_SEC_EXTENSION_451_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_SEC_EXTENSION_451_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_SEC_extension_451&quot;
pub const VK_EXT_nested_command_buffer_name = "VK_EXT_nested_command_buffer";
// Extension: VK_EXT_nested_command_buffer
// Number: 452
// Type: device
// Author: EXT
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_NESTED_COMMAND_BUFFER_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_NESTED_COMMAND_BUFFER_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_nested_command_buffer&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_PROPERTIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_SUBPASS_CONTENTS_INLINE_AND_SECONDARY_COMMAND_BUFFERS_EXT
//             Negative: false
//             Extends: VkSubpassContents
//             Alias: VK_SUBPASS_CONTENTS_INLINE_AND_SECONDARY_COMMAND_BUFFERS_KHR
//         Enum:
//             Name: VK_RENDERING_CONTENTS_INLINE_BIT_EXT
//             Negative: false
//             Extends: VkRenderingFlagBits
//             Alias: VK_RENDERING_CONTENTS_INLINE_BIT_KHR
//         Type:
//             Name: VkPhysicalDeviceNestedCommandBufferFeaturesEXT
//         Type:
//             Name: VkPhysicalDeviceNestedCommandBufferPropertiesEXT
//         Feature:
//             Name: nestedCommandBuffer
//             Struct: VkPhysicalDeviceNestedCommandBufferFeaturesEXT
pub const VK_OHOS_external_memory_name = "VK_OHOS_external_memory";
// Extension: VK_OHOS_external_memory
// Number: 453
// Type: device
// Author: HUAWEI
// Depends: ((VK_KHR_sampler_ycbcr_conversion+VK_KHR_external_memory+VK_KHR_dedicated_allocation),VK_VERSION_1_1)+VK_EXT_queue_family_foreign
// Platform: ohos
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_OHOS_EXTERNAL_MEMORY_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_OHOS_EXTERNAL_MEMORY_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_OHOS_external_memory&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_NATIVE_BUFFER_USAGE_OHOS
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_NATIVE_BUFFER_PROPERTIES_OHOS
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_NATIVE_BUFFER_FORMAT_PROPERTIES_OHOS
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMPORT_NATIVE_BUFFER_INFO_OHOS
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Enum:
//             Name: VK_STRUCTURE_TYPE_MEMORY_GET_NATIVE_BUFFER_INFO_OHOS
//             Negative: false
//             Extends: VkStructureType
//             Offset: 4
//         Enum:
//             Name: VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_OHOS
//             Negative: false
//             Extends: VkStructureType
//             Offset: 5
//         Type:
//             Name: VkNativeBufferUsageOHOS
//         Type:
//             Name: VkNativeBufferPropertiesOHOS
//         Type:
//             Name: VkNativeBufferFormatPropertiesOHOS
//         Type:
//             Name: VkImportNativeBufferInfoOHOS
//         Type:
//             Name: VkMemoryGetNativeBufferInfoOHOS
//         Type:
//             Name: VkExternalFormatOHOS
//         Type:
//             Name: OH_NativeBuffer
//         Enum:
//             Name: VK_EXTERNAL_MEMORY_HANDLE_TYPE_OH_NATIVE_BUFFER_BIT_OHOS
//             Negative: false
//             Bitpos: 15
//             Extends: VkExternalMemoryHandleTypeFlagBits
//         Command:
//             Name: vkGetNativeBufferPropertiesOHOS
//         Command:
//             Name: vkGetMemoryNativeBufferOHOS
pub const VK_EXT_external_memory_acquire_unmodified_name = "VK_EXT_external_memory_acquire_unmodified";
// Extension: VK_EXT_external_memory_acquire_unmodified
// Number: 454
// Type: device
// Author: EXT
// Depends: VK_KHR_external_memory,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_external_memory_acquire_unmodified&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkExternalMemoryAcquireUnmodifiedEXT
pub const VK_GOOGLE_extension_455_name = "VK_GOOGLE_extension_455";
// Extension: VK_GOOGLE_extension_455
// Number: 455
// Type: invalid
// Author: GOOGLE
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_GOOGLE_EXTENSION_455_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_GOOGLE_EXTENSION_455_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_GOOGLE_extension_455&quot;
pub const VK_EXT_extended_dynamic_state3_name = "VK_EXT_extended_dynamic_state3";
// Extension: VK_EXT_extended_dynamic_state3
// Number: 456
// Type: device
// Author: NV
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENDED_DYNAMIC_STATE_3_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_EXT_EXTENDED_DYNAMIC_STATE_3_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extended_dynamic_state3&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_PROPERTIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_DYNAMIC_STATE_DEPTH_CLAMP_ENABLE_EXT
//             Negative: false
//             Extends: VkDynamicState
//             Offset: 3
//         Enum:
//             Name: VK_DYNAMIC_STATE_POLYGON_MODE_EXT
//             Negative: false
//             Extends: VkDynamicState
//             Offset: 4
//         Enum:
//             Name: VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT
//             Negative: false
//             Extends: VkDynamicState
//             Offset: 5
//         Enum:
//             Name: VK_DYNAMIC_STATE_SAMPLE_MASK_EXT
//             Negative: false
//             Extends: VkDynamicState
//             Offset: 6
//         Enum:
//             Name: VK_DYNAMIC_STATE_ALPHA_TO_COVERAGE_ENABLE_EXT
//             Negative: false
//             Extends: VkDynamicState
//             Offset: 7
//         Enum:
//             Name: VK_DYNAMIC_STATE_ALPHA_TO_ONE_ENABLE_EXT
//             Negative: false
//             Extends: VkDynamicState
//             Offset: 8
//         Enum:
//             Name: VK_DYNAMIC_STATE_LOGIC_OP_ENABLE_EXT
//             Negative: false
//             Extends: VkDynamicState
//             Offset: 9
//         Enum:
//             Name: VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT
//             Negative: false
//             Extends: VkDynamicState
//             Offset: 10
//         Enum:
//             Name: VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT
//             Negative: false
//             Extends: VkDynamicState
//             Offset: 11
//         Enum:
//             Name: VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT
//             Negative: false
//             Extends: VkDynamicState
//             Offset: 12
//         Type:
//             Name: VkPhysicalDeviceExtendedDynamicState3FeaturesEXT
//         Type:
//             Name: VkPhysicalDeviceExtendedDynamicState3PropertiesEXT
//         Type:
//             Name: VkColorBlendEquationEXT
//         Type:
//             Name: VkColorBlendAdvancedEXT
//         Command:
//             Name: vkCmdSetDepthClampEnableEXT
//         Command:
//             Name: vkCmdSetPolygonModeEXT
//         Command:
//             Name: vkCmdSetRasterizationSamplesEXT
//         Command:
//             Name: vkCmdSetSampleMaskEXT
//         Command:
//             Name: vkCmdSetAlphaToCoverageEnableEXT
//         Command:
//             Name: vkCmdSetAlphaToOneEnableEXT
//         Command:
//             Name: vkCmdSetLogicOpEnableEXT
//         Command:
//             Name: vkCmdSetColorBlendEnableEXT
//         Command:
//             Name: vkCmdSetColorBlendEquationEXT
//         Command:
//             Name: vkCmdSetColorWriteMaskEXT
//     Depends: VK_KHR_maintenance2,VK_VERSION_1_1
//         Enum:
//             Name: VK_DYNAMIC_STATE_TESSELLATION_DOMAIN_ORIGIN_EXT
//             Negative: false
//             Extends: VkDynamicState
//             Offset: 2
//         Command:
//             Name: vkCmdSetTessellationDomainOriginEXT
//     Depends: VK_EXT_transform_feedback
//         Enum:
//             Name: VK_DYNAMIC_STATE_RASTERIZATION_STREAM_EXT
//             Negative: false
//             Extends: VkDynamicState
//             Offset: 13
//         Command:
//             Name: vkCmdSetRasterizationStreamEXT
//     Depends: VK_EXT_conservative_rasterization
//         Enum:
//             Name: VK_DYNAMIC_STATE_CONSERVATIVE_RASTERIZATION_MODE_EXT
//             Negative: false
//             Extends: VkDynamicState
//             Offset: 14
//         Enum:
//             Name: VK_DYNAMIC_STATE_EXTRA_PRIMITIVE_OVERESTIMATION_SIZE_EXT
//             Negative: false
//             Extends: VkDynamicState
//             Offset: 15
//         Command:
//             Name: vkCmdSetConservativeRasterizationModeEXT
//         Command:
//             Name: vkCmdSetExtraPrimitiveOverestimationSizeEXT
//     Depends: VK_EXT_depth_clip_enable
//         Enum:
//             Name: VK_DYNAMIC_STATE_DEPTH_CLIP_ENABLE_EXT
//             Negative: false
//             Extends: VkDynamicState
//             Offset: 16
//         Command:
//             Name: vkCmdSetDepthClipEnableEXT
//     Depends: VK_EXT_sample_locations
//         Enum:
//             Name: VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT
//             Negative: false
//             Extends: VkDynamicState
//             Offset: 17
//         Command:
//             Name: vkCmdSetSampleLocationsEnableEXT
//     Depends: VK_EXT_blend_operation_advanced
//         Enum:
//             Name: VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT
//             Negative: false
//             Extends: VkDynamicState
//             Offset: 18
//         Command:
//             Name: vkCmdSetColorBlendAdvancedEXT
//     Depends: VK_EXT_provoking_vertex
//         Enum:
//             Name: VK_DYNAMIC_STATE_PROVOKING_VERTEX_MODE_EXT
//             Negative: false
//             Extends: VkDynamicState
//             Offset: 19
//         Command:
//             Name: vkCmdSetProvokingVertexModeEXT
//     Depends: VK_EXT_line_rasterization
//         Enum:
//             Name: VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT
//             Negative: false
//             Extends: VkDynamicState
//             Offset: 20
//         Enum:
//             Name: VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT
//             Negative: false
//             Extends: VkDynamicState
//             Offset: 21
//         Command:
//             Name: vkCmdSetLineRasterizationModeEXT
//         Command:
//             Name: vkCmdSetLineStippleEnableEXT
//     Depends: VK_EXT_depth_clip_control
//         Enum:
//             Name: VK_DYNAMIC_STATE_DEPTH_CLIP_NEGATIVE_ONE_TO_ONE_EXT
//             Negative: false
//             Extends: VkDynamicState
//             Offset: 22
//         Command:
//             Name: vkCmdSetDepthClipNegativeOneToOneEXT
//     Depends: VK_NV_clip_space_w_scaling
//         Enum:
//             Name: VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_ENABLE_NV
//             Negative: false
//             Extends: VkDynamicState
//             Offset: 23
//         Command:
//             Name: vkCmdSetViewportWScalingEnableNV
//     Depends: VK_NV_viewport_swizzle
//         Enum:
//             Name: VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV
//             Negative: false
//             Extends: VkDynamicState
//             Offset: 24
//         Command:
//             Name: vkCmdSetViewportSwizzleNV
//     Depends: VK_NV_fragment_coverage_to_color
//         Enum:
//             Name: VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV
//             Negative: false
//             Extends: VkDynamicState
//             Offset: 25
//         Enum:
//             Name: VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_LOCATION_NV
//             Negative: false
//             Extends: VkDynamicState
//             Offset: 26
//         Command:
//             Name: vkCmdSetCoverageToColorEnableNV
//         Command:
//             Name: vkCmdSetCoverageToColorLocationNV
//     Depends: VK_NV_framebuffer_mixed_samples
//         Enum:
//             Name: VK_DYNAMIC_STATE_COVERAGE_MODULATION_MODE_NV
//             Negative: false
//             Extends: VkDynamicState
//             Offset: 27
//         Enum:
//             Name: VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_ENABLE_NV
//             Negative: false
//             Extends: VkDynamicState
//             Offset: 28
//         Enum:
//             Name: VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_NV
//             Negative: false
//             Extends: VkDynamicState
//             Offset: 29
//         Command:
//             Name: vkCmdSetCoverageModulationModeNV
//         Command:
//             Name: vkCmdSetCoverageModulationTableEnableNV
//         Command:
//             Name: vkCmdSetCoverageModulationTableNV
//     Depends: VK_NV_shading_rate_image
//         Enum:
//             Name: VK_DYNAMIC_STATE_SHADING_RATE_IMAGE_ENABLE_NV
//             Negative: false
//             Extends: VkDynamicState
//             Offset: 30
//         Command:
//             Name: vkCmdSetShadingRateImageEnableNV
//     Depends: VK_NV_representative_fragment_test
//         Enum:
//             Name: VK_DYNAMIC_STATE_REPRESENTATIVE_FRAGMENT_TEST_ENABLE_NV
//             Negative: false
//             Extends: VkDynamicState
//             Offset: 31
//         Command:
//             Name: vkCmdSetRepresentativeFragmentTestEnableNV
//     Depends: VK_NV_coverage_reduction_mode
//         Enum:
//             Name: VK_DYNAMIC_STATE_COVERAGE_REDUCTION_MODE_NV
//             Negative: false
//             Extends: VkDynamicState
//             Offset: 32
//         Command:
//             Name: vkCmdSetCoverageReductionModeNV
//     Depends: VkPhysicalDeviceExtendedDynamicState3FeaturesEXT::extendedDynamicState3TessellationDomainOrigin
//         Feature:
//             Name: tessellationShader
//             Struct: VkPhysicalDeviceFeatures
//     Depends: VkPhysicalDeviceExtendedDynamicState3FeaturesEXT::extendedDynamicState3DepthClampEnable
//         Feature:
//             Name: depthClamp
//             Struct: VkPhysicalDeviceFeatures
//     Depends: VkPhysicalDeviceExtendedDynamicState3FeaturesEXT::extendedDynamicState3PolygonMode
//         Feature:
//             Name: fillModeNonSolid
//             Struct: VkPhysicalDeviceFeatures
//     Depends: VkPhysicalDeviceExtendedDynamicState3FeaturesEXT::extendedDynamicState3AlphaToOneEnable
//         Feature:
//             Name: alphaToOne
//             Struct: VkPhysicalDeviceFeatures
//     Depends: VkPhysicalDeviceExtendedDynamicState3FeaturesEXT::extendedDynamicState3LogicOpEnable
//         Feature:
//             Name: logicOp
//             Struct: VkPhysicalDeviceFeatures
//     Depends: VK_EXT_transform_feedback+VkPhysicalDeviceExtendedDynamicState3FeaturesEXT::extendedDynamicState3RasterizationStream
//         Feature:
//             Name: geometryStreams
//             Struct: VkPhysicalDeviceTransformFeedbackFeaturesEXT
pub const VK_EXT_extension_457_name = "VK_EXT_extension_457";
// Extension: VK_EXT_extension_457
// Number: 457
// Type: invalid
// Author: RASTERGRID
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_457_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_457_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_457&quot;
pub const VK_EXT_extension_458_name = "VK_EXT_extension_458";
// Extension: VK_EXT_extension_458
// Number: 458
// Type: invalid
// Author: RASTERGRID
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_458_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_458_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_458&quot;
pub const VK_EXT_subpass_merge_feedback_name = "VK_EXT_subpass_merge_feedback";
// Extension: VK_EXT_subpass_merge_feedback
// Number: 459
// Type: device
// Author: EXT
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_SUBPASS_MERGE_FEEDBACK_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_EXT_SUBPASS_MERGE_FEEDBACK_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_subpass_merge_feedback&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_CONTROL_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_FEEDBACK_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_RENDER_PASS_SUBPASS_FEEDBACK_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Type:
//             Name: VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT
//         Type:
//             Name: VkRenderPassCreationControlEXT
//         Type:
//             Name: VkRenderPassCreationFeedbackInfoEXT
//         Type:
//             Name: VkRenderPassCreationFeedbackCreateInfoEXT
//         Type:
//             Name: VkRenderPassSubpassFeedbackInfoEXT
//         Type:
//             Name: VkRenderPassSubpassFeedbackCreateInfoEXT
//         Type:
//             Name: VkSubpassMergeStatusEXT
//         Feature:
//             Name: subpassMergeFeedback
//             Struct: VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT
pub const VK_LUNARG_direct_driver_loading_name = "VK_LUNARG_direct_driver_loading";
// Extension: VK_LUNARG_direct_driver_loading
// Number: 460
// Type: instance
// Author: LUNARG
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_LUNARG_DIRECT_DRIVER_LOADING_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_LUNARG_DIRECT_DRIVER_LOADING_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_LUNARG_direct_driver_loading&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_INFO_LUNARG
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_LIST_LUNARG
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Type:
//             Name: VkDirectDriverLoadingFlagsLUNARG
//         Type:
//             Name: VkDirectDriverLoadingModeLUNARG
//         Type:
//             Name: VkDirectDriverLoadingInfoLUNARG
//         Type:
//             Name: VkDirectDriverLoadingListLUNARG
//         Type:
//             Name: PFN_vkGetInstanceProcAddrLUNARG
pub const VK_ARM_tensors_name = "VK_ARM_tensors";
// Extension: VK_ARM_tensors
// Number: 461
// Type: device
// Author: ARM
// Depends: VK_VERSION_1_3
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_ARM_TENSORS_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_ARM_TENSORS_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_ARM_tensors&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_TENSOR_CREATE_INFO_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_TENSOR_VIEW_CREATE_INFO_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_BIND_TENSOR_MEMORY_INFO_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_TENSOR_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TENSOR_PROPERTIES_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 4
//         Enum:
//             Name: VK_STRUCTURE_TYPE_TENSOR_FORMAT_PROPERTIES_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 5
//         Enum:
//             Name: VK_STRUCTURE_TYPE_TENSOR_DESCRIPTION_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 6
//         Enum:
//             Name: VK_STRUCTURE_TYPE_TENSOR_MEMORY_REQUIREMENTS_INFO_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 7
//         Enum:
//             Name: VK_STRUCTURE_TYPE_TENSOR_MEMORY_BARRIER_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 8
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TENSOR_FEATURES_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 9
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DEVICE_TENSOR_MEMORY_REQUIREMENTS_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 10
//         Enum:
//             Name: VK_STRUCTURE_TYPE_COPY_TENSOR_INFO_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 11
//         Enum:
//             Name: VK_STRUCTURE_TYPE_TENSOR_COPY_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 12
//         Enum:
//             Name: VK_STRUCTURE_TYPE_TENSOR_DEPENDENCY_INFO_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 13
//         Enum:
//             Name: VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_TENSOR_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 14
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_TENSOR_INFO_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 15
//         Enum:
//             Name: VK_STRUCTURE_TYPE_EXTERNAL_TENSOR_PROPERTIES_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 16
//         Enum:
//             Name: VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_TENSOR_CREATE_INFO_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 17
//         Enum:
//             Name: VK_OBJECT_TYPE_TENSOR_ARM
//             Negative: false
//             Extends: VkObjectType
//             Offset: 0
//         Enum:
//             Name: VK_OBJECT_TYPE_TENSOR_VIEW_ARM
//             Negative: false
//             Extends: VkObjectType
//             Offset: 1
//         Enum:
//             Name: VK_DESCRIPTOR_TYPE_TENSOR_ARM
//             Negative: false
//             Extends: VkDescriptorType
//             Offset: 0
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_TENSOR_SHADER_BIT_ARM
//             Negative: false
//             Bitpos: 39
//             Extends: VkFormatFeatureFlagBits2
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_TENSOR_IMAGE_ALIASING_BIT_ARM
//             Negative: false
//             Bitpos: 43
//             Extends: VkFormatFeatureFlagBits2
//         Enum:
//             Name: VK_IMAGE_USAGE_TENSOR_ALIASING_BIT_ARM
//             Negative: false
//             Bitpos: 23
//             Extends: VkImageUsageFlagBits
//         Enum:
//             Name: VK_IMAGE_LAYOUT_TENSOR_ALIASING_ARM
//             Negative: false
//             Extends: VkImageLayout
//             Offset: 0
//         Enum:
//             Name: VK_FORMAT_R8_BOOL_ARM
//             Negative: false
//             Extends: VkFormat
//             Offset: 0
//         Type:
//             Name: VkTensorARM
//         Type:
//             Name: VkTensorViewARM
//         Type:
//             Name: VkTensorCreateFlagsARM
//         Type:
//             Name: VkTensorCreateFlagBitsARM
//         Type:
//             Name: VkTensorViewCreateFlagsARM
//         Type:
//             Name: VkTensorViewCreateFlagBitsARM
//         Type:
//             Name: VkTensorUsageFlagsARM
//         Type:
//             Name: VkTensorUsageFlagBitsARM
//         Type:
//             Name: VkTensorDescriptionARM
//         Type:
//             Name: VkTensorTilingARM
//         Type:
//             Name: VkTensorCreateInfoARM
//         Type:
//             Name: VkTensorViewCreateInfoARM
//         Type:
//             Name: VkTensorMemoryRequirementsInfoARM
//         Type:
//             Name: VkBindTensorMemoryInfoARM
//         Type:
//             Name: VkWriteDescriptorSetTensorARM
//         Type:
//             Name: VkTensorFormatPropertiesARM
//         Type:
//             Name: VkPhysicalDeviceTensorPropertiesARM
//         Type:
//             Name: VkTensorMemoryBarrierARM
//         Type:
//             Name: VkTensorDependencyInfoARM
//         Type:
//             Name: VkPhysicalDeviceTensorFeaturesARM
//         Type:
//             Name: VkDeviceTensorMemoryRequirementsARM
//         Type:
//             Name: VkCopyTensorInfoARM
//         Type:
//             Name: VkTensorCopyARM
//         Type:
//             Name: VkMemoryDedicatedAllocateInfoTensorARM
//         Type:
//             Name: VkPhysicalDeviceExternalTensorInfoARM
//         Type:
//             Name: VkExternalTensorPropertiesARM
//         Type:
//             Name: VkExternalMemoryTensorCreateInfoARM
//         Command:
//             Name: vkCreateTensorARM
//         Command:
//             Name: vkDestroyTensorARM
//         Command:
//             Name: vkCreateTensorViewARM
//         Command:
//             Name: vkDestroyTensorViewARM
//         Command:
//             Name: vkGetTensorMemoryRequirementsARM
//         Command:
//             Name: vkBindTensorMemoryARM
//         Command:
//             Name: vkGetDeviceTensorMemoryRequirementsARM
//         Command:
//             Name: vkCmdCopyTensorARM
//         Command:
//             Name: vkGetPhysicalDeviceExternalTensorPropertiesARM
//         Feature:
//             Name: tensors
//             Struct: VkPhysicalDeviceTensorFeaturesARM
//     Depends: VK_EXT_descriptor_buffer
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_TENSOR_FEATURES_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 18
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_TENSOR_PROPERTIES_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 19
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DESCRIPTOR_GET_TENSOR_INFO_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 20
//         Enum:
//             Name: VK_STRUCTURE_TYPE_TENSOR_CAPTURE_DESCRIPTOR_DATA_INFO_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 21
//         Enum:
//             Name: VK_STRUCTURE_TYPE_TENSOR_VIEW_CAPTURE_DESCRIPTOR_DATA_INFO_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 22
//         Enum:
//             Name: VK_TENSOR_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_ARM
//             Negative: false
//             Bitpos: 2
//             Extends: VkTensorCreateFlagBitsARM
//         Enum:
//             Name: VK_TENSOR_VIEW_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_ARM
//             Negative: false
//             Bitpos: 0
//             Extends: VkTensorViewCreateFlagBitsARM
//         Type:
//             Name: VkPhysicalDeviceDescriptorBufferTensorFeaturesARM
//         Type:
//             Name: VkPhysicalDeviceDescriptorBufferTensorPropertiesARM
//         Type:
//             Name: VkDescriptorGetTensorInfoARM
//         Type:
//             Name: VkTensorCaptureDescriptorDataInfoARM
//         Type:
//             Name: VkTensorViewCaptureDescriptorDataInfoARM
//         Command:
//             Name: vkGetTensorOpaqueCaptureDescriptorDataARM
//         Command:
//             Name: vkGetTensorViewOpaqueCaptureDescriptorDataARM
//     Depends: VK_EXT_frame_boundary
//         Enum:
//             Name: VK_STRUCTURE_TYPE_FRAME_BOUNDARY_TENSORS_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 23
//         Type:
//             Name: VkFrameBoundaryTensorsARM
pub const VK_EXT_extension_462_name = "VK_EXT_extension_462";
// Extension: VK_EXT_extension_462
// Number: 462
// Type: invalid
// Author: EXT
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_462_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_462_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_462&quot;
pub const VK_EXT_shader_module_identifier_name = "VK_EXT_shader_module_identifier";
// Extension: VK_EXT_shader_module_identifier
// Number: 463
// Type: device
// Author: EXT
// Depends: ((VK_KHR_get_physical_device_properties2,VK_VERSION_1_1)+VK_EXT_pipeline_creation_cache_control),VK_VERSION_1_3
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_SHADER_MODULE_IDENTIFIER_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_SHADER_MODULE_IDENTIFIER_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_shader_module_identifier&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_PROPERTIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_MODULE_IDENTIFIER_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SHADER_MODULE_IDENTIFIER_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Enum:
//             Name: VK_MAX_SHADER_MODULE_IDENTIFIER_SIZE_EXT
//             Negative: false
//         Type:
//             Name: VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT
//         Type:
//             Name: VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT
//         Type:
//             Name: VkPipelineShaderStageModuleIdentifierCreateInfoEXT
//         Type:
//             Name: VkShaderModuleIdentifierEXT
//         Command:
//             Name: vkGetShaderModuleIdentifierEXT
//         Command:
//             Name: vkGetShaderModuleCreateInfoIdentifierEXT
//         Feature:
//             Name: shaderModuleIdentifier
//             Struct: VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT
pub const VK_EXT_rasterization_order_attachment_access_name = "VK_EXT_rasterization_order_attachment_access";
// Extension: VK_EXT_rasterization_order_attachment_access
// Number: 464
// Type: device
// Author: ARM
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_rasterization_order_attachment_access&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Extnumber: 343
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT
//         Type:
//             Name: VkPipelineColorBlendStateCreateFlagBits
//         Type:
//             Name: VkPipelineDepthStencilStateCreateFlagBits
//         Enum:
//             Name: VK_PIPELINE_COLOR_BLEND_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_BIT_EXT
//             Negative: false
//             Bitpos: 0
//             Extends: VkPipelineColorBlendStateCreateFlagBits
//         Enum:
//             Name: VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_EXT
//             Negative: false
//             Bitpos: 0
//             Extends: VkPipelineDepthStencilStateCreateFlagBits
//         Enum:
//             Name: VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_EXT
//             Negative: false
//             Bitpos: 1
//             Extends: VkPipelineDepthStencilStateCreateFlagBits
//         Enum:
//             Name: VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_COLOR_ACCESS_BIT_EXT
//             Negative: false
//             Bitpos: 4
//             Extends: VkSubpassDescriptionFlagBits
//         Enum:
//             Name: VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_EXT
//             Negative: false
//             Bitpos: 5
//             Extends: VkSubpassDescriptionFlagBits
//         Enum:
//             Name: VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_EXT
//             Negative: false
//             Bitpos: 6
//             Extends: VkSubpassDescriptionFlagBits
pub const VK_NV_optical_flow_name = "VK_NV_optical_flow";
// Extension: VK_NV_optical_flow
// Number: 465
// Type: device
// Author: NV
// Depends: ((VK_KHR_get_physical_device_properties2,VK_VERSION_1_1)+VK_KHR_format_feature_flags2+VK_KHR_synchronization2),VK_VERSION_1_3
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NV_OPTICAL_FLOW_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_NV_OPTICAL_FLOW_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_optical_flow&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_FEATURES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_PROPERTIES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_PROPERTIES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Enum:
//             Name: VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 4
//         Enum:
//             Name: VK_STRUCTURE_TYPE_OPTICAL_FLOW_EXECUTE_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 5
//         Enum:
//             Name: VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_PRIVATE_DATA_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 10
//         Comment:
//             NV internal use only
//         Enum:
//             Name: VK_FORMAT_R16G16_SFIXED5_NV
//             Negative: false
//             Extends: VkFormat
//             Offset: 0
//         Enum:
//             Name: VK_FORMAT_R16G16_S10_5_NV
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_R16G16_SFIXED5_NV
//         Enum:
//             Name: VK_OBJECT_TYPE_OPTICAL_FLOW_SESSION_NV
//             Negative: false
//             Extends: VkObjectType
//             Offset: 0
//         Enum:
//             Name: VK_QUEUE_OPTICAL_FLOW_BIT_NV
//             Negative: false
//             Bitpos: 8
//             Extends: VkQueueFlagBits
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_OPTICAL_FLOW_BIT_NV
//             Negative: false
//             Bitpos: 29
//             Extends: VkPipelineStageFlagBits2
//         Enum:
//             Name: VK_ACCESS_2_OPTICAL_FLOW_READ_BIT_NV
//             Negative: false
//             Bitpos: 42
//             Extends: VkAccessFlagBits2
//         Enum:
//             Name: VK_ACCESS_2_OPTICAL_FLOW_WRITE_BIT_NV
//             Negative: false
//             Bitpos: 43
//             Extends: VkAccessFlagBits2
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_OPTICAL_FLOW_IMAGE_BIT_NV
//             Negative: false
//             Bitpos: 40
//             Extends: VkFormatFeatureFlagBits2
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_OPTICAL_FLOW_VECTOR_BIT_NV
//             Negative: false
//             Bitpos: 41
//             Extends: VkFormatFeatureFlagBits2
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_OPTICAL_FLOW_COST_BIT_NV
//             Negative: false
//             Bitpos: 42
//             Extends: VkFormatFeatureFlagBits2
//         Type:
//             Name: VkPhysicalDeviceOpticalFlowFeaturesNV
//         Type:
//             Name: VkPhysicalDeviceOpticalFlowPropertiesNV
//         Type:
//             Name: VkOpticalFlowUsageFlagBitsNV
//         Type:
//             Name: VkOpticalFlowUsageFlagsNV
//         Type:
//             Name: VkOpticalFlowImageFormatInfoNV
//         Type:
//             Name: VkOpticalFlowImageFormatPropertiesNV
//         Type:
//             Name: VkOpticalFlowGridSizeFlagBitsNV
//         Type:
//             Name: VkOpticalFlowGridSizeFlagsNV
//         Type:
//             Name: VkOpticalFlowPerformanceLevelNV
//         Type:
//             Name: VkOpticalFlowSessionBindingPointNV
//         Type:
//             Name: VkOpticalFlowSessionCreateFlagBitsNV
//         Type:
//             Name: VkOpticalFlowSessionCreateFlagsNV
//         Type:
//             Name: VkOpticalFlowExecuteFlagBitsNV
//         Type:
//             Name: VkOpticalFlowExecuteFlagsNV
//         Type:
//             Name: VkOpticalFlowSessionNV
//         Type:
//             Name: VkOpticalFlowSessionCreateInfoNV
//         Type:
//             Name: VkOpticalFlowSessionCreatePrivateDataInfoNV
//         Comment:
//             NV internal use only
//         Type:
//             Name: VkOpticalFlowExecuteInfoNV
//         Command:
//             Name: vkGetPhysicalDeviceOpticalFlowImageFormatsNV
//         Command:
//             Name: vkCreateOpticalFlowSessionNV
//         Command:
//             Name: vkDestroyOpticalFlowSessionNV
//         Command:
//             Name: vkBindOpticalFlowSessionImageNV
//         Command:
//             Name: vkCmdOpticalFlowExecuteNV
//         Feature:
//             Name: opticalFlow
//             Struct: VkPhysicalDeviceOpticalFlowFeaturesNV
pub const VK_EXT_legacy_dithering_name = "VK_EXT_legacy_dithering";
// Extension: VK_EXT_legacy_dithering
// Number: 466
// Type: device
// Author: EXT
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_LEGACY_DITHERING_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_EXT_LEGACY_DITHERING_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_legacy_dithering&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_SUBPASS_DESCRIPTION_ENABLE_LEGACY_DITHERING_BIT_EXT
//             Negative: false
//             Bitpos: 7
//             Extends: VkSubpassDescriptionFlagBits
//         Type:
//             Name: VkPhysicalDeviceLegacyDitheringFeaturesEXT
//         Feature:
//             Name: legacyDithering
//             Struct: VkPhysicalDeviceLegacyDitheringFeaturesEXT
//     Depends: (VK_KHR_dynamic_rendering,VK_VERSION_1_3)+(VK_KHR_maintenance5,VK_VERSION_1_4)
//         Enum:
//             Name: VK_RENDERING_ENABLE_LEGACY_DITHERING_BIT_EXT
//             Negative: false
//             Bitpos: 3
//             Extends: VkRenderingFlagBits
//         Enum:
//             Name: VK_PIPELINE_CREATE_2_ENABLE_LEGACY_DITHERING_BIT_EXT
//             Negative: false
//             Bitpos: 34
//             Extends: VkPipelineCreateFlagBits2
pub const VK_EXT_pipeline_protected_access_name = "VK_EXT_pipeline_protected_access";
// Extension: VK_EXT_pipeline_protected_access
// Number: 467
// Type: device
// Author: EXT
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_4
// Unlocks:
//         Enum:
//             Name: VK_EXT_PIPELINE_PROTECTED_ACCESS_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_PIPELINE_PROTECTED_ACCESS_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_pipeline_protected_access&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES
//         Enum:
//             Name: VK_PIPELINE_CREATE_NO_PROTECTED_ACCESS_BIT_EXT
//             Negative: false
//             Extends: VkPipelineCreateFlagBits
//             Alias: VK_PIPELINE_CREATE_NO_PROTECTED_ACCESS_BIT
//         Enum:
//             Name: VK_PIPELINE_CREATE_PROTECTED_ACCESS_ONLY_BIT_EXT
//             Negative: false
//             Extends: VkPipelineCreateFlagBits
//             Alias: VK_PIPELINE_CREATE_PROTECTED_ACCESS_ONLY_BIT
//         Type:
//             Name: VkPhysicalDevicePipelineProtectedAccessFeaturesEXT
//         Feature:
//             Name: pipelineProtectedAccess
//             Struct: VkPhysicalDevicePipelineProtectedAccessFeaturesEXT
pub const VK_EXT_extension_468_name = "VK_EXT_extension_468";
// Extension: VK_EXT_extension_468
// Number: 468
// Type: invalid
// Author: EXT
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_468_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_468_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_468&quot;
pub const VK_ANDROID_external_format_resolve_name = "VK_ANDROID_external_format_resolve";
// Extension: VK_ANDROID_external_format_resolve
// Number: 469
// Type: device
// Author: ANDROID
// Depends: VK_ANDROID_external_memory_android_hardware_buffer
// Platform: android
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_ANDROID_EXTERNAL_FORMAT_RESOLVE_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_ANDROID_EXTERNAL_FORMAT_RESOLVE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_ANDROID_external_format_resolve&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FORMAT_RESOLVE_FEATURES_ANDROID
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FORMAT_RESOLVE_PROPERTIES_ANDROID
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_RESOLVE_PROPERTIES_ANDROID
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Type:
//             Name: VkPhysicalDeviceExternalFormatResolveFeaturesANDROID
//         Type:
//             Name: VkPhysicalDeviceExternalFormatResolvePropertiesANDROID
//         Type:
//             Name: VkAndroidHardwareBufferFormatResolvePropertiesANDROID
//         Feature:
//             Name: externalFormatResolve
//             Struct: VkPhysicalDeviceExternalFormatResolveFeaturesANDROID
//     Depends: VK_KHR_dynamic_rendering,VK_VERSION_1_3
//         Enum:
//             Name: VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_BIT_ANDROID
//             Negative: false
//             Bitpos: 4
//             Extends: VkResolveModeFlagBits
//         Enum:
//             Name: VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID
//             Negative: false
//             Extends: VkResolveModeFlagBits
//             Alias: VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_BIT_ANDROID
pub const VK_AMD_extension_470_name = "VK_AMD_extension_470";
// Extension: VK_AMD_extension_470
// Number: 470
// Type: invalid
// Author: AMD
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_AMD_EXTENSION_470_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_AMD_EXTENSION_470_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_extension_470&quot;
pub const VK_KHR_maintenance5_name = "VK_KHR_maintenance5";
// Extension: VK_KHR_maintenance5
// Number: 471
// Type: device
// Author: KHR
// Depends: (VK_VERSION_1_1+VK_KHR_dynamic_rendering),VK_VERSION_1_3
// Supported: supported
// Promoted to: VK_VERSION_1_4
// Unlocks:
//         Enum:
//             Name: VK_KHR_MAINTENANCE_5_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_MAINTENANCE_5_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_maintenance5&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_PROPERTIES
//         Enum:
//             Name: VK_STRUCTURE_TYPE_RENDERING_AREA_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_RENDERING_AREA_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DEVICE_IMAGE_SUBRESOURCE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_DEVICE_IMAGE_SUBRESOURCE_INFO
//         Type:
//             Name: VkPhysicalDeviceMaintenance5FeaturesKHR
//         Type:
//             Name: VkPhysicalDeviceMaintenance5PropertiesKHR
//         Enum:
//             Name: VK_FORMAT_A1B5G5R5_UNORM_PACK16_KHR
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_A1B5G5R5_UNORM_PACK16
//         Enum:
//             Name: VK_FORMAT_A8_UNORM_KHR
//             Negative: false
//             Extends: VkFormat
//             Alias: VK_FORMAT_A8_UNORM
//         Command:
//             Name: vkCmdBindIndexBuffer2KHR
//         Command:
//             Name: vkGetRenderingAreaGranularityKHR
//         Type:
//             Name: VkRenderingAreaInfoKHR
//         Command:
//             Name: vkGetDeviceImageSubresourceLayoutKHR
//         Command:
//             Name: vkGetImageSubresourceLayout2KHR
//         Type:
//             Name: VkDeviceImageSubresourceInfoKHR
//         Type:
//             Name: VkImageSubresource2KHR
//         Type:
//             Name: VkSubresourceLayout2KHR
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2
//         Feature:
//             Name: maintenance5
//             Struct: VkPhysicalDeviceMaintenance5FeaturesKHR
//         Enum:
//             Name: VK_PIPELINE_CREATE_2_DISABLE_OPTIMIZATION_BIT_KHR
//             Negative: false
//             Extends: VkPipelineCreateFlagBits2
//             Alias: VK_PIPELINE_CREATE_2_DISABLE_OPTIMIZATION_BIT
//         Enum:
//             Name: VK_PIPELINE_CREATE_2_ALLOW_DERIVATIVES_BIT_KHR
//             Negative: false
//             Extends: VkPipelineCreateFlagBits2
//             Alias: VK_PIPELINE_CREATE_2_ALLOW_DERIVATIVES_BIT
//         Enum:
//             Name: VK_PIPELINE_CREATE_2_DERIVATIVE_BIT_KHR
//             Negative: false
//             Extends: VkPipelineCreateFlagBits2
//             Alias: VK_PIPELINE_CREATE_2_DERIVATIVE_BIT
//         Enum:
//             Name: VK_PIPELINE_CREATE_2_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHR
//             Negative: false
//             Extends: VkPipelineCreateFlagBits2
//             Alias: VK_PIPELINE_CREATE_2_VIEW_INDEX_FROM_DEVICE_INDEX_BIT
//         Enum:
//             Name: VK_PIPELINE_CREATE_2_DISPATCH_BASE_BIT_KHR
//             Negative: false
//             Extends: VkPipelineCreateFlagBits2
//             Alias: VK_PIPELINE_CREATE_2_DISPATCH_BASE_BIT
//         Enum:
//             Name: VK_BUFFER_USAGE_2_TRANSFER_SRC_BIT_KHR
//             Negative: false
//             Extends: VkBufferUsageFlagBits2
//             Alias: VK_BUFFER_USAGE_2_TRANSFER_SRC_BIT
//         Enum:
//             Name: VK_BUFFER_USAGE_2_TRANSFER_DST_BIT_KHR
//             Negative: false
//             Extends: VkBufferUsageFlagBits2
//             Alias: VK_BUFFER_USAGE_2_TRANSFER_DST_BIT
//         Enum:
//             Name: VK_BUFFER_USAGE_2_UNIFORM_TEXEL_BUFFER_BIT_KHR
//             Negative: false
//             Extends: VkBufferUsageFlagBits2
//             Alias: VK_BUFFER_USAGE_2_UNIFORM_TEXEL_BUFFER_BIT
//         Enum:
//             Name: VK_BUFFER_USAGE_2_STORAGE_TEXEL_BUFFER_BIT_KHR
//             Negative: false
//             Extends: VkBufferUsageFlagBits2
//             Alias: VK_BUFFER_USAGE_2_STORAGE_TEXEL_BUFFER_BIT
//         Enum:
//             Name: VK_BUFFER_USAGE_2_UNIFORM_BUFFER_BIT_KHR
//             Negative: false
//             Extends: VkBufferUsageFlagBits2
//             Alias: VK_BUFFER_USAGE_2_UNIFORM_BUFFER_BIT
//         Enum:
//             Name: VK_BUFFER_USAGE_2_STORAGE_BUFFER_BIT_KHR
//             Negative: false
//             Extends: VkBufferUsageFlagBits2
//             Alias: VK_BUFFER_USAGE_2_STORAGE_BUFFER_BIT
//         Enum:
//             Name: VK_BUFFER_USAGE_2_INDEX_BUFFER_BIT_KHR
//             Negative: false
//             Extends: VkBufferUsageFlagBits2
//             Alias: VK_BUFFER_USAGE_2_INDEX_BUFFER_BIT
//         Enum:
//             Name: VK_BUFFER_USAGE_2_VERTEX_BUFFER_BIT_KHR
//             Negative: false
//             Extends: VkBufferUsageFlagBits2
//             Alias: VK_BUFFER_USAGE_2_VERTEX_BUFFER_BIT
//         Enum:
//             Name: VK_BUFFER_USAGE_2_INDIRECT_BUFFER_BIT_KHR
//             Negative: false
//             Extends: VkBufferUsageFlagBits2
//             Alias: VK_BUFFER_USAGE_2_INDIRECT_BUFFER_BIT
//         Type:
//             Name: VkPipelineCreateFlags2KHR
//         Type:
//             Name: VkPipelineCreateFlagBits2KHR
//         Type:
//             Name: VkPipelineCreateFlags2CreateInfoKHR
//         Type:
//             Name: VkBufferUsageFlags2KHR
//         Type:
//             Name: VkBufferUsageFlagBits2KHR
//         Type:
//             Name: VkBufferUsageFlags2CreateInfoKHR
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO
//     Depends: VK_NV_ray_tracing
//         Enum:
//             Name: VK_PIPELINE_CREATE_2_DEFER_COMPILE_BIT_NV
//             Negative: false
//             Bitpos: 5
//             Extends: VkPipelineCreateFlagBits2
//     Depends: VK_KHR_pipeline_executable_properties
//         Enum:
//             Name: VK_PIPELINE_CREATE_2_CAPTURE_STATISTICS_BIT_KHR
//             Negative: false
//             Bitpos: 6
//             Extends: VkPipelineCreateFlagBits2
//         Enum:
//             Name: VK_PIPELINE_CREATE_2_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR
//             Negative: false
//             Bitpos: 7
//             Extends: VkPipelineCreateFlagBits2
//     Depends: VK_VERSION_1_3,VK_EXT_pipeline_creation_cache_control
//         Enum:
//             Name: VK_PIPELINE_CREATE_2_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT_KHR
//             Negative: false
//             Extends: VkPipelineCreateFlagBits2
//             Alias: VK_PIPELINE_CREATE_2_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT
//         Enum:
//             Name: VK_PIPELINE_CREATE_2_EARLY_RETURN_ON_FAILURE_BIT_KHR
//             Negative: false
//             Extends: VkPipelineCreateFlagBits2
//             Alias: VK_PIPELINE_CREATE_2_EARLY_RETURN_ON_FAILURE_BIT
//     Depends: VK_EXT_graphics_pipeline_library
//         Enum:
//             Name: VK_PIPELINE_CREATE_2_LINK_TIME_OPTIMIZATION_BIT_EXT
//             Negative: false
//             Bitpos: 10
//             Extends: VkPipelineCreateFlagBits2
//         Enum:
//             Name: VK_PIPELINE_CREATE_2_RETAIN_LINK_TIME_OPTIMIZATION_INFO_BIT_EXT
//             Negative: false
//             Bitpos: 23
//             Extends: VkPipelineCreateFlagBits2
//     Depends: VK_KHR_pipeline_library
//         Enum:
//             Name: VK_PIPELINE_CREATE_2_LIBRARY_BIT_KHR
//             Negative: false
//             Bitpos: 11
//             Extends: VkPipelineCreateFlagBits2
//     Depends: VK_KHR_ray_tracing_pipeline
//         Enum:
//             Name: VK_PIPELINE_CREATE_2_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR
//             Negative: false
//             Bitpos: 12
//             Extends: VkPipelineCreateFlagBits2
//         Enum:
//             Name: VK_PIPELINE_CREATE_2_RAY_TRACING_SKIP_AABBS_BIT_KHR
//             Negative: false
//             Bitpos: 13
//             Extends: VkPipelineCreateFlagBits2
//         Enum:
//             Name: VK_PIPELINE_CREATE_2_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR
//             Negative: false
//             Bitpos: 14
//             Extends: VkPipelineCreateFlagBits2
//         Enum:
//             Name: VK_PIPELINE_CREATE_2_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR
//             Negative: false
//             Bitpos: 15
//             Extends: VkPipelineCreateFlagBits2
//         Enum:
//             Name: VK_PIPELINE_CREATE_2_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR
//             Negative: false
//             Bitpos: 16
//             Extends: VkPipelineCreateFlagBits2
//         Enum:
//             Name: VK_PIPELINE_CREATE_2_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR
//             Negative: false
//             Bitpos: 17
//             Extends: VkPipelineCreateFlagBits2
//         Enum:
//             Name: VK_PIPELINE_CREATE_2_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR
//             Negative: false
//             Bitpos: 19
//             Extends: VkPipelineCreateFlagBits2
//     Depends: VK_NV_device_generated_commands
//         Enum:
//             Name: VK_PIPELINE_CREATE_2_INDIRECT_BINDABLE_BIT_NV
//             Negative: false
//             Bitpos: 18
//             Extends: VkPipelineCreateFlagBits2
//     Depends: VK_NV_ray_tracing_motion_blur
//         Enum:
//             Name: VK_PIPELINE_CREATE_2_RAY_TRACING_ALLOW_MOTION_BIT_NV
//             Negative: false
//             Bitpos: 20
//             Extends: VkPipelineCreateFlagBits2
//     Depends: (VK_KHR_dynamic_rendering,VK_VERSION_1_3)+VK_KHR_fragment_shading_rate
//         Enum:
//             Name: VK_PIPELINE_CREATE_2_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR
//             Negative: false
//             Bitpos: 21
//             Extends: VkPipelineCreateFlagBits2
//     Depends: (VK_KHR_dynamic_rendering,VK_VERSION_1_3)+VK_EXT_fragment_density_map
//         Enum:
//             Name: VK_PIPELINE_CREATE_2_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT
//             Negative: false
//             Bitpos: 22
//             Extends: VkPipelineCreateFlagBits2
//     Depends: VK_EXT_opacity_micromap
//         Enum:
//             Name: VK_PIPELINE_CREATE_2_RAY_TRACING_OPACITY_MICROMAP_BIT_EXT
//             Negative: false
//             Bitpos: 24
//             Extends: VkPipelineCreateFlagBits2
//     Depends: VK_EXT_attachment_feedback_loop_layout
//         Enum:
//             Name: VK_PIPELINE_CREATE_2_COLOR_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT
//             Negative: false
//             Bitpos: 25
//             Extends: VkPipelineCreateFlagBits2
//         Enum:
//             Name: VK_PIPELINE_CREATE_2_DEPTH_STENCIL_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT
//             Negative: false
//             Bitpos: 26
//             Extends: VkPipelineCreateFlagBits2
//     Depends: VK_VERSION_1_4,VK_EXT_pipeline_protected_access
//         Enum:
//             Name: VK_PIPELINE_CREATE_2_NO_PROTECTED_ACCESS_BIT_EXT
//             Negative: false
//             Extends: VkPipelineCreateFlagBits2
//             Alias: VK_PIPELINE_CREATE_2_NO_PROTECTED_ACCESS_BIT
//         Enum:
//             Name: VK_PIPELINE_CREATE_2_PROTECTED_ACCESS_ONLY_BIT_EXT
//             Negative: false
//             Extends: VkPipelineCreateFlagBits2
//             Alias: VK_PIPELINE_CREATE_2_PROTECTED_ACCESS_ONLY_BIT
//     Depends: VK_NV_displacement_micromap
//         Enum:
//             Name: VK_PIPELINE_CREATE_2_RAY_TRACING_DISPLACEMENT_MICROMAP_BIT_NV
//             Negative: false
//             Bitpos: 28
//             Extends: VkPipelineCreateFlagBits2
//     Depends: VK_EXT_descriptor_buffer
//         Enum:
//             Name: VK_PIPELINE_CREATE_2_DESCRIPTOR_BUFFER_BIT_EXT
//             Negative: false
//             Bitpos: 29
//             Extends: VkPipelineCreateFlagBits2
//     Depends: VK_EXT_conditional_rendering
//         Enum:
//             Name: VK_BUFFER_USAGE_2_CONDITIONAL_RENDERING_BIT_EXT
//             Negative: false
//             Bitpos: 9
//             Extends: VkBufferUsageFlagBits2
//     Depends: VK_KHR_ray_tracing_pipeline
//         Enum:
//             Name: VK_BUFFER_USAGE_2_SHADER_BINDING_TABLE_BIT_KHR
//             Negative: false
//             Bitpos: 10
//             Extends: VkBufferUsageFlagBits2
//     Depends: VK_NV_ray_tracing
//         Enum:
//             Name: VK_BUFFER_USAGE_2_RAY_TRACING_BIT_NV
//             Negative: false
//             Extends: VkBufferUsageFlagBits2
//             Alias: VK_BUFFER_USAGE_2_SHADER_BINDING_TABLE_BIT_KHR
//     Depends: VK_EXT_transform_feedback
//         Enum:
//             Name: VK_BUFFER_USAGE_2_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT
//             Negative: false
//             Bitpos: 11
//             Extends: VkBufferUsageFlagBits2
//         Enum:
//             Name: VK_BUFFER_USAGE_2_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT
//             Negative: false
//             Bitpos: 12
//             Extends: VkBufferUsageFlagBits2
//     Depends: VK_KHR_video_decode_queue
//         Enum:
//             Name: VK_BUFFER_USAGE_2_VIDEO_DECODE_SRC_BIT_KHR
//             Negative: false
//             Bitpos: 13
//             Extends: VkBufferUsageFlagBits2
//         Enum:
//             Name: VK_BUFFER_USAGE_2_VIDEO_DECODE_DST_BIT_KHR
//             Negative: false
//             Bitpos: 14
//             Extends: VkBufferUsageFlagBits2
//     Depends: VK_KHR_video_encode_queue
//         Enum:
//             Name: VK_BUFFER_USAGE_2_VIDEO_ENCODE_DST_BIT_KHR
//             Negative: false
//             Bitpos: 15
//             Extends: VkBufferUsageFlagBits2
//         Enum:
//             Name: VK_BUFFER_USAGE_2_VIDEO_ENCODE_SRC_BIT_KHR
//             Negative: false
//             Bitpos: 16
//             Extends: VkBufferUsageFlagBits2
//     Depends: VK_VERSION_1_2,VK_KHR_buffer_device_address,VK_EXT_buffer_device_address
//         Enum:
//             Name: VK_BUFFER_USAGE_2_SHADER_DEVICE_ADDRESS_BIT_KHR
//             Negative: false
//             Extends: VkBufferUsageFlagBits2
//             Alias: VK_BUFFER_USAGE_2_SHADER_DEVICE_ADDRESS_BIT
//     Depends: VK_KHR_acceleration_structure
//         Enum:
//             Name: VK_BUFFER_USAGE_2_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR
//             Negative: false
//             Bitpos: 19
//             Extends: VkBufferUsageFlagBits2
//         Enum:
//             Name: VK_BUFFER_USAGE_2_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR
//             Negative: false
//             Bitpos: 20
//             Extends: VkBufferUsageFlagBits2
//     Depends: VK_EXT_descriptor_buffer
//         Enum:
//             Name: VK_BUFFER_USAGE_2_SAMPLER_DESCRIPTOR_BUFFER_BIT_EXT
//             Negative: false
//             Bitpos: 21
//             Extends: VkBufferUsageFlagBits2
//         Enum:
//             Name: VK_BUFFER_USAGE_2_RESOURCE_DESCRIPTOR_BUFFER_BIT_EXT
//             Negative: false
//             Bitpos: 22
//             Extends: VkBufferUsageFlagBits2
//         Enum:
//             Name: VK_BUFFER_USAGE_2_PUSH_DESCRIPTORS_DESCRIPTOR_BUFFER_BIT_EXT
//             Negative: false
//             Bitpos: 26
//             Extends: VkBufferUsageFlagBits2
//     Depends: VK_EXT_opacity_micromap
//         Enum:
//             Name: VK_BUFFER_USAGE_2_MICROMAP_BUILD_INPUT_READ_ONLY_BIT_EXT
//             Negative: false
//             Bitpos: 23
//             Extends: VkBufferUsageFlagBits2
//         Enum:
//             Name: VK_BUFFER_USAGE_2_MICROMAP_STORAGE_BIT_EXT
//             Negative: false
//             Bitpos: 24
//             Extends: VkBufferUsageFlagBits2
//     Depends: VK_ARM_pipeline_opacity_micromap
//         Enum:
//             Name: VK_PIPELINE_CREATE_2_DISALLOW_OPACITY_MICROMAP_BIT_ARM
//             Negative: false
//             Bitpos: 37
//             Extends: VkPipelineCreateFlagBits2
pub const VK_AMD_extension_472_name = "VK_AMD_extension_472";
// Extension: VK_AMD_extension_472
// Number: 472
// Type: invalid
// Author: AMD
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_AMD_EXTENSION_472_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_AMD_EXTENSION_472_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_extension_472&quot;
pub const VK_AMD_extension_473_name = "VK_AMD_extension_473";
// Extension: VK_AMD_extension_473
// Number: 473
// Type: invalid
// Author: AMD
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_AMD_EXTENSION_473_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_AMD_EXTENSION_473_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_extension_473&quot;
pub const VK_AMD_extension_474_name = "VK_AMD_extension_474";
// Extension: VK_AMD_extension_474
// Number: 474
// Type: invalid
// Author: AMD
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_AMD_EXTENSION_474_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_AMD_EXTENSION_474_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_extension_474&quot;
pub const VK_AMD_extension_475_name = "VK_AMD_extension_475";
// Extension: VK_AMD_extension_475
// Number: 475
// Type: invalid
// Author: AMD
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_AMD_EXTENSION_475_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_AMD_EXTENSION_475_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_extension_475&quot;
pub const VK_AMD_extension_476_name = "VK_AMD_extension_476";
// Extension: VK_AMD_extension_476
// Number: 476
// Type: invalid
// Author: AMD
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_AMD_EXTENSION_476_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_AMD_EXTENSION_476_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_extension_476&quot;
pub const VK_AMD_anti_lag_name = "VK_AMD_anti_lag";
// Extension: VK_AMD_anti_lag
// Number: 477
// Type: device
// Author: AMD
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_AMD_ANTI_LAG_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_AMD_ANTI_LAG_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_anti_lag&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ANTI_LAG_FEATURES_AMD
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_ANTI_LAG_DATA_AMD
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_ANTI_LAG_PRESENTATION_INFO_AMD
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Type:
//             Name: VkPhysicalDeviceAntiLagFeaturesAMD
//         Type:
//             Name: VkAntiLagDataAMD
//         Type:
//             Name: VkAntiLagPresentationInfoAMD
//         Type:
//             Name: VkAntiLagModeAMD
//         Type:
//             Name: VkAntiLagStageAMD
//         Command:
//             Name: vkAntiLagUpdateAMD
//         Feature:
//             Name: antiLag
//             Struct: VkPhysicalDeviceAntiLagFeaturesAMD
pub const VK_AMD_extension_478_name = "VK_AMD_extension_478";
// Extension: VK_AMD_extension_478
// Number: 478
// Type: invalid
// Author: AMD
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_AMD_EXTENSION_478_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_AMD_EXTENSION_478_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_extension_478&quot;
pub const VK_AMDX_dense_geometry_format_name = "VK_AMDX_dense_geometry_format";
// Extension: VK_AMDX_dense_geometry_format
// Number: 479
// Type: device
// Author: AMD
// Depends: VK_KHR_acceleration_structure+(VK_KHR_maintenance5,VK_VERSION_1_4)
// Platform: provisional
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_AMDX_DENSE_GEOMETRY_FORMAT_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_AMDX_DENSE_GEOMETRY_FORMAT_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMDX_dense_geometry_format&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DENSE_GEOMETRY_FORMAT_FEATURES_AMDX
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DENSE_GEOMETRY_FORMAT_TRIANGLES_DATA_AMDX
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_GEOMETRY_TYPE_DENSE_GEOMETRY_FORMAT_TRIANGLES_AMDX
//             Negative: false
//             Extends: VkGeometryTypeKHR
//             Offset: 0
//         Enum:
//             Name: VK_BUFFER_USAGE_2_COMPRESSED_DATA_DGF1_BIT_AMDX
//             Negative: false
//             Bitpos: 33
//             Extends: VkBufferUsageFlagBits2
//         Type:
//             Name: VkPhysicalDeviceDenseGeometryFormatFeaturesAMDX
//         Type:
//             Name: VkAccelerationStructureDenseGeometryFormatTrianglesDataAMDX
//         Type:
//             Name: VkCompressedTriangleFormatAMDX
//         Enum:
//             Name: VK_COMPRESSED_TRIANGLE_FORMAT_DGF1_BYTE_ALIGNMENT_AMDX
//             Negative: false
//         Enum:
//             Name: VK_COMPRESSED_TRIANGLE_FORMAT_DGF1_BYTE_STRIDE_AMDX
//             Negative: false
//         Feature:
//             Name: denseGeometryFormat
//             Struct: VkPhysicalDeviceDenseGeometryFormatFeaturesAMDX
pub const VK_KHR_present_id2_name = "VK_KHR_present_id2";
// Extension: VK_KHR_present_id2
// Number: 480
// Type: device
// Author: KHR
// Depends: VK_KHR_get_surface_capabilities2+VK_KHR_surface+VK_KHR_swapchain
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_PRESENT_ID_2_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_PRESENT_ID_2_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_present_id2&quot;
//         Enum:
//             Name: VK_SWAPCHAIN_CREATE_PRESENT_ID_2_BIT_KHR
//             Negative: false
//             Bitpos: 6
//             Extends: VkSwapchainCreateFlagBitsKHR
//             Comment:
//                 Allow use of VK_KHR_present_id2 with this swapchain
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_ID_2_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PRESENT_ID_2_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_2_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Type:
//             Name: VkSurfaceCapabilitiesPresentId2KHR
//         Type:
//             Name: VkPresentId2KHR
//         Type:
//             Name: VkPhysicalDevicePresentId2FeaturesKHR
//         Feature:
//             Name: presentId2
//             Struct: VkPhysicalDevicePresentId2FeaturesKHR
pub const VK_KHR_present_wait2_name = "VK_KHR_present_wait2";
// Extension: VK_KHR_present_wait2
// Number: 481
// Type: device
// Author: KHR
// Depends: VK_KHR_get_surface_capabilities2+VK_KHR_surface+VK_KHR_swapchain+VK_KHR_present_id2
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_PRESENT_WAIT_2_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_PRESENT_WAIT_2_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_present_wait2&quot;
//         Enum:
//             Name: VK_SWAPCHAIN_CREATE_PRESENT_WAIT_2_BIT_KHR
//             Negative: false
//             Bitpos: 7
//             Extends: VkSwapchainCreateFlagBitsKHR
//             Comment:
//                 Allow use of VK_KHR_present_wait2 with this swapchain
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_WAIT_2_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_2_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PRESENT_WAIT_2_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Type:
//             Name: VkSurfaceCapabilitiesPresentWait2KHR
//         Type:
//             Name: VkPhysicalDevicePresentWait2FeaturesKHR
//         Type:
//             Name: VkPresentWait2InfoKHR
//         Command:
//             Name: vkWaitForPresent2KHR
//         Feature:
//             Name: presentWait2
//             Struct: VkPhysicalDevicePresentWait2FeaturesKHR
pub const VK_KHR_ray_tracing_position_fetch_name = "VK_KHR_ray_tracing_position_fetch";
// Extension: VK_KHR_ray_tracing_position_fetch
// Number: 482
// Type: device
// Author: KHR
// Depends: VK_KHR_acceleration_structure
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_RAY_TRACING_POSITION_FETCH_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_RAY_TRACING_POSITION_FETCH_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_ray_tracing_position_fetch&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_POSITION_FETCH_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DATA_ACCESS_BIT_KHR
//             Negative: false
//             Bitpos: 11
//             Extends: VkBuildAccelerationStructureFlagBitsKHR
//         Enum:
//             Name: VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DATA_ACCESS_KHR
//             Negative: false
//             Extends: VkBuildAccelerationStructureFlagBitsKHR
//             Alias: VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DATA_ACCESS_BIT_KHR
//         Type:
//             Name: VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR
//         Feature:
//             Name: rayTracingPositionFetch
//             Struct: VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR
pub const VK_EXT_shader_object_name = "VK_EXT_shader_object";
// Extension: VK_EXT_shader_object
// Number: 483
// Type: device
// Author: EXT
// Depends: ((VK_KHR_get_physical_device_properties2,VK_VERSION_1_1)+VK_KHR_dynamic_rendering),VK_VERSION_1_3
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_SHADER_OBJECT_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_SHADER_OBJECT_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_shader_object&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_PROPERTIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SHADER_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VERTEX_INPUT_BINDING_DESCRIPTION_2_EXT
//             Negative: false
//             Extends: VkStructureType
//             Extnumber: 353
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VERTEX_INPUT_ATTRIBUTE_DESCRIPTION_2_EXT
//             Negative: false
//             Extends: VkStructureType
//             Extnumber: 353
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SHADER_REQUIRED_SUBGROUP_SIZE_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO
//         Enum:
//             Name: VK_OBJECT_TYPE_SHADER_EXT
//             Negative: false
//             Extends: VkObjectType
//             Offset: 0
//         Enum:
//             Name: VK_INCOMPATIBLE_SHADER_BINARY_EXT
//             Negative: false
//             Extends: VkResult
//             Offset: 0
//         Enum:
//             Name: VK_ERROR_INCOMPATIBLE_SHADER_BINARY_EXT
//             Negative: false
//             Extends: VkResult
//             Alias: VK_INCOMPATIBLE_SHADER_BINARY_EXT
//         Type:
//             Name: VkShaderEXT
//         Type:
//             Name: VkShaderCreateFlagBitsEXT
//         Type:
//             Name: VkShaderCreateFlagsEXT
//         Type:
//             Name: VkShaderCodeTypeEXT
//         Type:
//             Name: VkPhysicalDeviceShaderObjectFeaturesEXT
//         Type:
//             Name: VkPhysicalDeviceShaderObjectPropertiesEXT
//         Type:
//             Name: VkShaderCreateInfoEXT
//         Type:
//             Name: VkShaderRequiredSubgroupSizeCreateInfoEXT
//         Type:
//             Name: VkVertexInputBindingDescription2EXT
//         Type:
//             Name: VkVertexInputAttributeDescription2EXT
//         Type:
//             Name: VkColorBlendEquationEXT
//         Type:
//             Name: VkColorBlendAdvancedEXT
//         Command:
//             Name: vkCreateShadersEXT
//         Command:
//             Name: vkDestroyShaderEXT
//         Command:
//             Name: vkGetShaderBinaryDataEXT
//         Command:
//             Name: vkCmdBindShadersEXT
//         Command:
//             Name: vkCmdSetCullModeEXT
//         Command:
//             Name: vkCmdSetFrontFaceEXT
//         Command:
//             Name: vkCmdSetPrimitiveTopologyEXT
//         Command:
//             Name: vkCmdSetViewportWithCountEXT
//         Command:
//             Name: vkCmdSetScissorWithCountEXT
//         Command:
//             Name: vkCmdBindVertexBuffers2EXT
//         Command:
//             Name: vkCmdSetDepthTestEnableEXT
//         Command:
//             Name: vkCmdSetDepthWriteEnableEXT
//         Command:
//             Name: vkCmdSetDepthCompareOpEXT
//         Command:
//             Name: vkCmdSetDepthBoundsTestEnableEXT
//         Command:
//             Name: vkCmdSetStencilTestEnableEXT
//         Command:
//             Name: vkCmdSetStencilOpEXT
//         Command:
//             Name: vkCmdSetVertexInputEXT
//         Command:
//             Name: vkCmdSetPatchControlPointsEXT
//         Command:
//             Name: vkCmdSetRasterizerDiscardEnableEXT
//         Command:
//             Name: vkCmdSetDepthBiasEnableEXT
//         Command:
//             Name: vkCmdSetLogicOpEXT
//         Command:
//             Name: vkCmdSetPrimitiveRestartEnableEXT
//         Command:
//             Name: vkCmdSetTessellationDomainOriginEXT
//         Command:
//             Name: vkCmdSetDepthClampEnableEXT
//         Command:
//             Name: vkCmdSetPolygonModeEXT
//         Command:
//             Name: vkCmdSetRasterizationSamplesEXT
//         Command:
//             Name: vkCmdSetSampleMaskEXT
//         Command:
//             Name: vkCmdSetAlphaToCoverageEnableEXT
//         Command:
//             Name: vkCmdSetAlphaToOneEnableEXT
//         Command:
//             Name: vkCmdSetLogicOpEnableEXT
//         Command:
//             Name: vkCmdSetColorBlendEnableEXT
//         Command:
//             Name: vkCmdSetColorBlendEquationEXT
//         Command:
//             Name: vkCmdSetColorWriteMaskEXT
//         Feature:
//             Name: shaderObject
//             Struct: VkPhysicalDeviceShaderObjectFeaturesEXT
//     Depends: VK_EXT_transform_feedback
//         Command:
//             Name: vkCmdSetRasterizationStreamEXT
//     Depends: VK_EXT_conservative_rasterization
//         Command:
//             Name: vkCmdSetConservativeRasterizationModeEXT
//         Command:
//             Name: vkCmdSetExtraPrimitiveOverestimationSizeEXT
//     Depends: VK_EXT_depth_clip_enable
//         Command:
//             Name: vkCmdSetDepthClipEnableEXT
//     Depends: VK_EXT_sample_locations
//         Command:
//             Name: vkCmdSetSampleLocationsEnableEXT
//     Depends: VK_EXT_blend_operation_advanced
//         Command:
//             Name: vkCmdSetColorBlendAdvancedEXT
//     Depends: VK_EXT_provoking_vertex
//         Command:
//             Name: vkCmdSetProvokingVertexModeEXT
//     Depends: VK_EXT_line_rasterization
//         Command:
//             Name: vkCmdSetLineRasterizationModeEXT
//         Command:
//             Name: vkCmdSetLineStippleEnableEXT
//     Depends: VK_EXT_depth_clip_control
//         Command:
//             Name: vkCmdSetDepthClipNegativeOneToOneEXT
//     Depends: VK_EXT_subgroup_size_control,VK_VERSION_1_3
//         Enum:
//             Name: VK_SHADER_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT
//             Negative: false
//             Bitpos: 1
//             Extends: VkShaderCreateFlagBitsEXT
//         Enum:
//             Name: VK_SHADER_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT
//             Negative: false
//             Bitpos: 2
//             Extends: VkShaderCreateFlagBitsEXT
//     Depends: VK_EXT_mesh_shader,VK_NV_mesh_shader
//         Enum:
//             Name: VK_SHADER_CREATE_NO_TASK_SHADER_BIT_EXT
//             Negative: false
//             Bitpos: 3
//             Extends: VkShaderCreateFlagBitsEXT
//     Depends: VK_KHR_device_group,VK_VERSION_1_1
//         Enum:
//             Name: VK_SHADER_CREATE_DISPATCH_BASE_BIT_EXT
//             Negative: false
//             Bitpos: 4
//             Extends: VkShaderCreateFlagBitsEXT
//     Depends: VK_KHR_fragment_shading_rate
//         Enum:
//             Name: VK_SHADER_CREATE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_EXT
//             Negative: false
//             Bitpos: 5
//             Extends: VkShaderCreateFlagBitsEXT
//     Depends: VK_EXT_fragment_density_map
//         Enum:
//             Name: VK_SHADER_CREATE_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT
//             Negative: false
//             Bitpos: 6
//             Extends: VkShaderCreateFlagBitsEXT
//     Depends: VK_NV_clip_space_w_scaling
//         Command:
//             Name: vkCmdSetViewportWScalingEnableNV
//     Depends: VK_NV_viewport_swizzle
//         Command:
//             Name: vkCmdSetViewportSwizzleNV
//     Depends: VK_NV_fragment_coverage_to_color
//         Command:
//             Name: vkCmdSetCoverageToColorEnableNV
//         Command:
//             Name: vkCmdSetCoverageToColorLocationNV
//     Depends: VK_NV_framebuffer_mixed_samples
//         Command:
//             Name: vkCmdSetCoverageModulationModeNV
//         Command:
//             Name: vkCmdSetCoverageModulationTableEnableNV
//         Command:
//             Name: vkCmdSetCoverageModulationTableNV
//     Depends: VK_NV_shading_rate_image
//         Command:
//             Name: vkCmdSetShadingRateImageEnableNV
//     Depends: VK_NV_representative_fragment_test
//         Command:
//             Name: vkCmdSetRepresentativeFragmentTestEnableNV
//     Depends: VK_NV_coverage_reduction_mode
//         Command:
//             Name: vkCmdSetCoverageReductionModeNV
//     Depends: VK_EXT_depth_clamp_control
//         Command:
//             Name: vkCmdSetDepthClampRangeEXT
pub const VK_KHR_pipeline_binary_name = "VK_KHR_pipeline_binary";
// Extension: VK_KHR_pipeline_binary
// Number: 484
// Type: device
// Author: KHR
// Depends: VK_KHR_maintenance5,VK_VERSION_1_4
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_PIPELINE_BINARY_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_PIPELINE_BINARY_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_pipeline_binary&quot;
//         Enum:
//             Name: VK_MAX_PIPELINE_BINARY_KEY_SIZE_KHR
//             Negative: false
//         Type:
//             Name: VkPhysicalDevicePipelineBinaryFeaturesKHR
//         Type:
//             Name: VkPhysicalDevicePipelineBinaryPropertiesKHR
//         Type:
//             Name: VkDevicePipelineBinaryInternalCacheControlKHR
//         Type:
//             Name: VkPipelineBinaryKHR
//         Type:
//             Name: VkPipelineBinaryKeyKHR
//         Type:
//             Name: VkPipelineBinaryDataKHR
//         Type:
//             Name: VkPipelineBinaryKeysAndDataKHR
//         Type:
//             Name: VkPipelineBinaryCreateInfoKHR
//         Type:
//             Name: VkPipelineBinaryInfoKHR
//         Type:
//             Name: VkReleaseCapturedPipelineDataInfoKHR
//         Type:
//             Name: VkPipelineBinaryDataInfoKHR
//         Type:
//             Name: VkPipelineCreateInfoKHR
//         Type:
//             Name: VkPipelineBinaryHandlesInfoKHR
//         Command:
//             Name: vkCreatePipelineBinariesKHR
//         Command:
//             Name: vkDestroyPipelineBinaryKHR
//         Command:
//             Name: vkGetPipelineKeyKHR
//         Command:
//             Name: vkGetPipelineBinaryDataKHR
//         Command:
//             Name: vkReleaseCapturedPipelineDataKHR
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PIPELINE_BINARY_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PIPELINE_BINARY_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PIPELINE_BINARY_KEY_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 4
//         Enum:
//             Name: VK_STRUCTURE_TYPE_RELEASE_CAPTURED_PIPELINE_DATA_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 5
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PIPELINE_BINARY_DATA_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 6
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PIPELINE_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 7
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DEVICE_PIPELINE_BINARY_INTERNAL_CACHE_CONTROL_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 8
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PIPELINE_BINARY_HANDLES_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 9
//         Enum:
//             Name: VK_OBJECT_TYPE_PIPELINE_BINARY_KHR
//             Negative: false
//             Extends: VkObjectType
//             Offset: 0
//         Enum:
//             Name: VK_PIPELINE_BINARY_MISSING_KHR
//             Negative: false
//             Extends: VkResult
//             Offset: 0
//         Enum:
//             Name: VK_ERROR_NOT_ENOUGH_SPACE_KHR
//             Negative: true
//             Extends: VkResult
//             Offset: 0
//         Enum:
//             Name: VK_PIPELINE_CREATE_2_CAPTURE_DATA_BIT_KHR
//             Negative: false
//             Bitpos: 31
//             Extends: VkPipelineCreateFlagBits2
//         Feature:
//             Name: pipelineBinaries
//             Struct: VkPhysicalDevicePipelineBinaryFeaturesKHR
pub const VK_QCOM_tile_properties_name = "VK_QCOM_tile_properties";
// Extension: VK_QCOM_tile_properties
// Number: 485
// Type: device
// Author: QCOM
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_QCOM_TILE_PROPERTIES_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_QCOM_TILE_PROPERTIES_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_QCOM_tile_properties&quot;
//         Command:
//             Name: vkGetFramebufferTilePropertiesQCOM
//         Command:
//             Name: vkGetDynamicRenderingTilePropertiesQCOM
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_PROPERTIES_FEATURES_QCOM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_TILE_PROPERTIES_QCOM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Type:
//             Name: VkPhysicalDeviceTilePropertiesFeaturesQCOM
//         Type:
//             Name: VkTilePropertiesQCOM
//         Feature:
//             Name: tileProperties
//             Struct: VkPhysicalDeviceTilePropertiesFeaturesQCOM
//     Depends: VK_KHR_dynamic_rendering,VK_VERSION_1_3
//         Type:
//             Name: VkRenderingInfoKHR
pub const VK_SEC_amigo_profiling_name = "VK_SEC_amigo_profiling";
// Extension: VK_SEC_amigo_profiling
// Number: 486
// Type: device
// Author: SEC
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_SEC_AMIGO_PROFILING_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_SEC_AMIGO_PROFILING_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_SEC_amigo_profiling&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_AMIGO_PROFILING_FEATURES_SEC
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_AMIGO_PROFILING_SUBMIT_INFO_SEC
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Type:
//             Name: VkPhysicalDeviceAmigoProfilingFeaturesSEC
//         Type:
//             Name: VkAmigoProfilingSubmitInfoSEC
//         Feature:
//             Name: amigoProfiling
//             Struct: VkPhysicalDeviceAmigoProfilingFeaturesSEC
pub const VK_KHR_surface_maintenance1_name = "VK_KHR_surface_maintenance1";
// Extension: VK_KHR_surface_maintenance1
// Number: 487
// Type: instance
// Author: KHR
// Depends: VK_KHR_surface,VK_KHR_get_surface_capabilities2
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_SURFACE_MAINTENANCE_1_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_SURFACE_MAINTENANCE_1_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_surface_maintenance1&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_KHR
//             Negative: false
//             Extends: VkStructureType
//             Extnumber: 275
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SURFACE_PRESENT_SCALING_CAPABILITIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Extnumber: 275
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_COMPATIBILITY_KHR
//             Negative: false
//             Extends: VkStructureType
//             Extnumber: 275
//             Offset: 2
//         Type:
//             Name: VkSurfacePresentModeKHR
//         Type:
//             Name: VkPresentScalingFlagBitsKHR
//         Type:
//             Name: VkPresentScalingFlagsKHR
//         Type:
//             Name: VkPresentGravityFlagBitsKHR
//         Type:
//             Name: VkPresentGravityFlagsKHR
//         Type:
//             Name: VkSurfacePresentScalingCapabilitiesKHR
//         Type:
//             Name: VkSurfacePresentModeCompatibilityKHR
pub const VK_KHR_swapchain_maintenance1_name = "VK_KHR_swapchain_maintenance1";
// Extension: VK_KHR_swapchain_maintenance1
// Number: 488
// Type: device
// Author: KHR
// Depends: VK_KHR_swapchain,VK_KHR_surface_maintenance1,VK_KHR_get_physical_device_properties2
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_SWAPCHAIN_MAINTENANCE_1_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_SWAPCHAIN_MAINTENANCE_1_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_swapchain_maintenance1&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Extnumber: 276
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Extnumber: 276
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODES_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Extnumber: 276
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Extnumber: 276
//             Offset: 3
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_SCALING_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Extnumber: 276
//             Offset: 4
//         Enum:
//             Name: VK_STRUCTURE_TYPE_RELEASE_SWAPCHAIN_IMAGES_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Extnumber: 276
//             Offset: 5
//         Enum:
//             Name: VK_SWAPCHAIN_CREATE_DEFERRED_MEMORY_ALLOCATION_BIT_KHR
//             Negative: false
//             Bitpos: 3
//             Extends: VkSwapchainCreateFlagBitsKHR
//         Type:
//             Name: VkPhysicalDeviceSwapchainMaintenance1FeaturesKHR
//         Type:
//             Name: VkSwapchainPresentFenceInfoKHR
//         Type:
//             Name: VkSwapchainPresentModesCreateInfoKHR
//         Type:
//             Name: VkSwapchainPresentModeInfoKHR
//         Type:
//             Name: VkSwapchainPresentScalingCreateInfoKHR
//         Type:
//             Name: VkReleaseSwapchainImagesInfoKHR
//         Command:
//             Name: vkReleaseSwapchainImagesKHR
//         Feature:
//             Name: swapchainMaintenance1
//             Struct: VkPhysicalDeviceSwapchainMaintenance1FeaturesKHR
pub const VK_QCOM_multiview_per_view_viewports_name = "VK_QCOM_multiview_per_view_viewports";
// Extension: VK_QCOM_multiview_per_view_viewports
// Number: 489
// Type: device
// Author: QCOM
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_QCOM_MULTIVIEW_PER_VIEW_VIEWPORTS_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_QCOM_MULTIVIEW_PER_VIEW_VIEWPORTS_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_QCOM_multiview_per_view_viewports&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_VIEWPORTS_FEATURES_QCOM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM
//         Feature:
//             Name: multiviewPerViewViewports
//             Struct: VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM
pub const VK_NV_external_sci_sync2_name = "VK_NV_external_sci_sync2";
// Extension: VK_NV_external_sci_sync2
// Number: 490
// Type: device
// Author: NV
// Depends: VK_VERSION_1_1
// Platform: sci
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NV_EXTERNAL_SCI_SYNC_2_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_NV_EXTERNAL_SCI_SYNC_2_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_external_sci_sync2&quot;
//         Enum:
//             Name: VK_OBJECT_TYPE_SEMAPHORE_SCI_SYNC_POOL_NV
//             Negative: false
//             Extends: VkObjectType
//             Offset: 0
//             Comment:
//                 VkSemaphoreSciSyncPoolNV
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SEMAPHORE_SCI_SYNC_POOL_CREATE_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SEMAPHORE_SCI_SYNC_CREATE_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SCI_SYNC_2_FEATURES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Type:
//             Name: VkSemaphoreSciSyncPoolNV
//         Type:
//             Name: VkPhysicalDeviceExternalSciSync2FeaturesNV
//         Type:
//             Name: VkSemaphoreSciSyncPoolCreateInfoNV
//         Type:
//             Name: VkSemaphoreSciSyncCreateInfoNV
//         Command:
//             Name: vkCreateSemaphoreSciSyncPoolNV
//         Command:
//             Name: vkDestroySemaphoreSciSyncPoolNV
//         Feature:
//             Name: sciSyncFence,sciSyncSemaphore2
//             Struct: VkPhysicalDeviceExternalSciSync2FeaturesNV
//         Feature:
//             Name: sciSyncImport,sciSyncExport
//             Struct: VkPhysicalDeviceExternalSciSync2FeaturesNV
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMPORT_FENCE_SCI_SYNC_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Extnumber: 374
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_EXPORT_FENCE_SCI_SYNC_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Extnumber: 374
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_FENCE_GET_SCI_SYNC_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Extnumber: 374
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SCI_SYNC_ATTRIBUTES_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Extnumber: 374
//             Offset: 3
//         Enum:
//             Name: VK_EXTERNAL_FENCE_HANDLE_TYPE_SCI_SYNC_OBJ_BIT_NV
//             Negative: false
//             Bitpos: 4
//             Extends: VkExternalFenceHandleTypeFlagBits
//         Enum:
//             Name: VK_EXTERNAL_FENCE_HANDLE_TYPE_SCI_SYNC_FENCE_BIT_NV
//             Negative: false
//             Bitpos: 5
//             Extends: VkExternalFenceHandleTypeFlagBits
//         Type:
//             Name: VkSciSyncClientTypeNV
//         Type:
//             Name: VkSciSyncPrimitiveTypeNV
//         Type:
//             Name: VkExportFenceSciSyncInfoNV
//         Type:
//             Name: VkImportFenceSciSyncInfoNV
//         Type:
//             Name: VkFenceGetSciSyncInfoNV
//         Type:
//             Name: VkSciSyncAttributesInfoNV
//         Command:
//             Name: vkGetFenceSciSyncFenceNV
//         Command:
//             Name: vkGetFenceSciSyncObjNV
//         Command:
//             Name: vkImportFenceSciSyncFenceNV
//         Command:
//             Name: vkImportFenceSciSyncObjNV
//         Command:
//             Name: vkGetPhysicalDeviceSciSyncAttributesNV
//     Depends: VKSC_VERSION_1_0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DEVICE_SEMAPHORE_SCI_SYNC_POOL_RESERVATION_CREATE_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Type:
//             Name: VkDeviceSemaphoreSciSyncPoolReservationCreateInfoNV
pub const VK_NV_ray_tracing_invocation_reorder_name = "VK_NV_ray_tracing_invocation_reorder";
// Extension: VK_NV_ray_tracing_invocation_reorder
// Number: 491
// Type: device
// Author: NV
// Depends: VK_KHR_ray_tracing_pipeline
// Supported: supported
// Promoted to: VK_EXT_ray_tracing_invocation_reorder
// Unlocks:
//         Enum:
//             Name: VK_NV_RAY_TRACING_INVOCATION_REORDER_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_NV_RAY_TRACING_INVOCATION_REORDER_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_ray_tracing_invocation_reorder&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_FEATURES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_PROPERTIES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Type:
//             Name: VkRayTracingInvocationReorderModeNV
//         Enum:
//             Name: VK_RAY_TRACING_INVOCATION_REORDER_MODE_NONE_NV
//             Negative: false
//             Extends: VkRayTracingInvocationReorderModeEXT
//             Alias: VK_RAY_TRACING_INVOCATION_REORDER_MODE_NONE_EXT
//         Enum:
//             Name: VK_RAY_TRACING_INVOCATION_REORDER_MODE_REORDER_NV
//             Negative: false
//             Extends: VkRayTracingInvocationReorderModeEXT
//             Alias: VK_RAY_TRACING_INVOCATION_REORDER_MODE_REORDER_EXT
//         Type:
//             Name: VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV
//         Type:
//             Name: VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV
//         Feature:
//             Name: rayTracingInvocationReorder
//             Struct: VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV
pub const VK_NV_cooperative_vector_name = "VK_NV_cooperative_vector";
// Extension: VK_NV_cooperative_vector
// Number: 492
// Type: device
// Author: NV
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NV_COOPERATIVE_VECTOR_SPEC_VERSION
//             Negative: false
//             Value: 4
//         Enum:
//             Name: VK_NV_COOPERATIVE_VECTOR_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_cooperative_vector&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_VECTOR_FEATURES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_VECTOR_PROPERTIES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_COOPERATIVE_VECTOR_PROPERTIES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_CONVERT_COOPERATIVE_VECTOR_MATRIX_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 4
//         Enum:
//             Name: VK_COMPONENT_TYPE_SINT8_PACKED_NV
//             Negative: false
//             Extends: VkComponentTypeKHR
//             Offset: 0
//         Enum:
//             Name: VK_COMPONENT_TYPE_UINT8_PACKED_NV
//             Negative: false
//             Extends: VkComponentTypeKHR
//             Offset: 1
//         Enum:
//             Name: VK_COMPONENT_TYPE_FLOAT_E4M3_NV
//             Negative: false
//             Extends: VkComponentTypeKHR
//             Alias: VK_COMPONENT_TYPE_FLOAT8_E4M3_EXT
//         Enum:
//             Name: VK_COMPONENT_TYPE_FLOAT_E5M2_NV
//             Negative: false
//             Extends: VkComponentTypeKHR
//             Alias: VK_COMPONENT_TYPE_FLOAT8_E5M2_EXT
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_CONVERT_COOPERATIVE_VECTOR_MATRIX_BIT_NV
//             Negative: false
//             Bitpos: 44
//             Extends: VkPipelineStageFlagBits2
//         Type:
//             Name: VkPhysicalDeviceCooperativeVectorPropertiesNV
//         Type:
//             Name: VkPhysicalDeviceCooperativeVectorFeaturesNV
//         Type:
//             Name: VkCooperativeVectorPropertiesNV
//         Type:
//             Name: VkConvertCooperativeVectorMatrixInfoNV
//         Type:
//             Name: VkCooperativeVectorMatrixLayoutNV
//         Type:
//             Name: VkComponentTypeKHR
//         Type:
//             Name: VkDeviceOrHostAddressKHR
//         Type:
//             Name: VkDeviceOrHostAddressConstKHR
//         Command:
//             Name: vkGetPhysicalDeviceCooperativeVectorPropertiesNV
//         Command:
//             Name: vkConvertCooperativeVectorMatrixNV
//         Command:
//             Name: vkCmdConvertCooperativeVectorMatrixNV
//         Feature:
//             Name: cooperativeVector
//             Struct: VkPhysicalDeviceCooperativeVectorFeaturesNV
pub const VK_NV_extended_sparse_address_space_name = "VK_NV_extended_sparse_address_space";
// Extension: VK_NV_extended_sparse_address_space
// Number: 493
// Type: device
// Author: NV
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NV_EXTENDED_SPARSE_ADDRESS_SPACE_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_NV_EXTENDED_SPARSE_ADDRESS_SPACE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_extended_sparse_address_space&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_FEATURES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_PROPERTIES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Type:
//             Name: VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV
//         Type:
//             Name: VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV
//         Feature:
//             Name: extendedSparseAddressSpace
//             Struct: VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV
pub const VK_NV_extension_494_name = "VK_NV_extension_494";
// Extension: VK_NV_extension_494
// Number: 494
// Type: invalid
// Author: NV
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_NV_EXTENSION_494_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_NV_EXTENSION_494_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_extension_494&quot;
pub const VK_EXT_mutable_descriptor_type_name = "VK_EXT_mutable_descriptor_type";
// Extension: VK_EXT_mutable_descriptor_type
// Number: 495
// Type: device
// Author: EXT
// Depends: VK_KHR_maintenance3,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_MUTABLE_DESCRIPTOR_TYPE_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_MUTABLE_DESCRIPTOR_TYPE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_mutable_descriptor_type&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Extnumber: 352
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Extnumber: 352
//             Offset: 2
//         Enum:
//             Name: VK_DESCRIPTOR_TYPE_MUTABLE_EXT
//             Negative: false
//             Extends: VkDescriptorType
//             Extnumber: 352
//             Offset: 0
//         Enum:
//             Name: VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_EXT
//             Negative: false
//             Bitpos: 2
//             Extends: VkDescriptorPoolCreateFlagBits
//         Enum:
//             Name: VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_EXT
//             Negative: false
//             Bitpos: 2
//             Extends: VkDescriptorSetLayoutCreateFlagBits
//         Type:
//             Name: VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT
//         Type:
//             Name: VkMutableDescriptorTypeListEXT
//         Type:
//             Name: VkMutableDescriptorTypeCreateInfoEXT
//         Feature:
//             Name: mutableDescriptorType
//             Struct: VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT
pub const VK_EXT_legacy_vertex_attributes_name = "VK_EXT_legacy_vertex_attributes";
// Extension: VK_EXT_legacy_vertex_attributes
// Number: 496
// Type: device
// Author: EXT
// Depends: VK_EXT_vertex_input_dynamic_state
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_LEGACY_VERTEX_ATTRIBUTES_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_LEGACY_VERTEX_ATTRIBUTES_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_legacy_vertex_attributes&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_PROPERTIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Type:
//             Name: VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT
//         Type:
//             Name: VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT
//         Feature:
//             Name: legacyVertexAttributes
//             Struct: VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT
pub const VK_EXT_layer_settings_name = "VK_EXT_layer_settings";
// Extension: VK_EXT_layer_settings
// Number: 497
// Type: instance
// Author: EXT
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_LAYER_SETTINGS_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_EXT_LAYER_SETTINGS_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_layer_settings&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_LAYER_SETTINGS_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkLayerSettingsCreateInfoEXT
//         Type:
//             Name: VkLayerSettingEXT
//         Type:
//             Name: VkLayerSettingTypeEXT
pub const VK_ARM_shader_core_builtins_name = "VK_ARM_shader_core_builtins";
// Extension: VK_ARM_shader_core_builtins
// Number: 498
// Type: device
// Author: ARM
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_ARM_SHADER_CORE_BUILTINS_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_ARM_SHADER_CORE_BUILTINS_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_ARM_shader_core_builtins&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_FEATURES_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_PROPERTIES_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Type:
//             Name: VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM
//         Type:
//             Name: VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM
//         Feature:
//             Name: shaderCoreBuiltins
//             Struct: VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM
pub const VK_EXT_pipeline_library_group_handles_name = "VK_EXT_pipeline_library_group_handles";
// Extension: VK_EXT_pipeline_library_group_handles
// Number: 499
// Type: device
// Author: EXT
// Depends: VK_KHR_ray_tracing_pipeline+VK_KHR_pipeline_library
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_PIPELINE_LIBRARY_GROUP_HANDLES_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_PIPELINE_LIBRARY_GROUP_HANDLES_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_pipeline_library_group_handles&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_LIBRARY_GROUP_HANDLES_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT
//         Feature:
//             Name: pipelineLibraryGroupHandles
//             Struct: VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT
pub const VK_EXT_dynamic_rendering_unused_attachments_name = "VK_EXT_dynamic_rendering_unused_attachments";
// Extension: VK_EXT_dynamic_rendering_unused_attachments
// Number: 500
// Type: device
// Author: EXT
// Depends: ((VK_KHR_get_physical_device_properties2,VK_VERSION_1_1)+VK_KHR_dynamic_rendering),VK_VERSION_1_3
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_dynamic_rendering_unused_attachments&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT
//         Feature:
//             Name: dynamicRenderingUnusedAttachments
//             Struct: VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT
pub const VK_EXT_extension_501_name = "VK_EXT_extension_501";
// Extension: VK_EXT_extension_501
// Number: 501
// Type: device
// Author: SEC
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_501_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_501_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_501&quot;
pub const VK_EXT_extension_502_name = "VK_EXT_extension_502";
// Extension: VK_EXT_extension_502
// Number: 502
// Type: device
// Author: HUAWEI
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_502_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_502_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_502&quot;
pub const VK_EXT_extension_503_name = "VK_EXT_extension_503";
// Extension: VK_EXT_extension_503
// Number: 503
// Type: device
// Author: HUAWEI
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_503_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_503_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_503&quot;
pub const VK_NV_extension_504_name = "VK_NV_extension_504";
// Extension: VK_NV_extension_504
// Number: 504
// Type: instance
// Author: NV
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_NV_EXTENSION_504_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_NV_EXTENSION_504_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_extension_504&quot;
pub const VK_EXT_extension_505_name = "VK_EXT_extension_505";
// Extension: VK_EXT_extension_505
// Number: 505
// Type: device
// Author: EXT
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_505_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_505_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_505&quot;
//         Enum:
//             Name: VK_DEVICE_QUEUE_CREATE_RESERVED_2_BIT_EXT
//             Negative: false
//             Bitpos: 2
//             Extends: VkDeviceQueueCreateFlagBits
pub const VK_NV_low_latency2_name = "VK_NV_low_latency2";
// Extension: VK_NV_low_latency2
// Number: 506
// Type: device
// Author: NV
// Depends: (VK_VERSION_1_2,VK_KHR_timeline_semaphore)+(VK_KHR_present_id,VK_KHR_present_id2)
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NV_LOW_LATENCY_2_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_NV_LOW_LATENCY_2_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_low_latency2&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_LATENCY_SLEEP_MODE_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_LATENCY_SLEEP_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SET_LATENCY_MARKER_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_GET_LATENCY_MARKER_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Enum:
//             Name: VK_STRUCTURE_TYPE_LATENCY_TIMINGS_FRAME_REPORT_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 4
//         Enum:
//             Name: VK_STRUCTURE_TYPE_LATENCY_SUBMISSION_PRESENT_ID_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 5
//         Enum:
//             Name: VK_STRUCTURE_TYPE_OUT_OF_BAND_QUEUE_TYPE_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 6
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SWAPCHAIN_LATENCY_CREATE_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 7
//         Enum:
//             Name: VK_STRUCTURE_TYPE_LATENCY_SURFACE_CAPABILITIES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 8
//         Type:
//             Name: VkLatencySleepModeInfoNV
//         Type:
//             Name: VkLatencySleepInfoNV
//         Type:
//             Name: VkSetLatencyMarkerInfoNV
//         Type:
//             Name: VkGetLatencyMarkerInfoNV
//         Type:
//             Name: VkLatencyTimingsFrameReportNV
//         Type:
//             Name: VkLatencyMarkerNV
//         Type:
//             Name: VkLatencySubmissionPresentIdNV
//         Type:
//             Name: VkSwapchainLatencyCreateInfoNV
//         Type:
//             Name: VkOutOfBandQueueTypeInfoNV
//         Type:
//             Name: VkOutOfBandQueueTypeNV
//         Type:
//             Name: VkLatencySurfaceCapabilitiesNV
//         Command:
//             Name: vkSetLatencySleepModeNV
//         Command:
//             Name: vkLatencySleepNV
//         Command:
//             Name: vkSetLatencyMarkerNV
//         Command:
//             Name: vkGetLatencyTimingsNV
//         Command:
//             Name: vkQueueNotifyOutOfBandNV
pub const VK_KHR_cooperative_matrix_name = "VK_KHR_cooperative_matrix";
// Extension: VK_KHR_cooperative_matrix
// Number: 507
// Type: device
// Author: KHR
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_COOPERATIVE_MATRIX_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_KHR_COOPERATIVE_MATRIX_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_cooperative_matrix&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Type:
//             Name: VkCooperativeMatrixPropertiesKHR
//         Type:
//             Name: VkScopeKHR
//         Type:
//             Name: VkComponentTypeKHR
//         Type:
//             Name: VkPhysicalDeviceCooperativeMatrixFeaturesKHR
//         Type:
//             Name: VkPhysicalDeviceCooperativeMatrixPropertiesKHR
//         Command:
//             Name: vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR
//         Feature:
//             Name: cooperativeMatrix
//             Struct: VkPhysicalDeviceCooperativeMatrixFeaturesKHR
pub const VK_ARM_data_graph_name = "VK_ARM_data_graph";
// Extension: VK_ARM_data_graph
// Number: 508
// Type: device
// Author: ARM
// Depends: VK_VERSION_1_3+VK_KHR_maintenance5+VK_KHR_deferred_host_operations
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_ARM_DATA_GRAPH_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_ARM_DATA_GRAPH_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_ARM_data_graph&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_CREATE_INFO_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_CREATE_INFO_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_RESOURCE_INFO_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_CONSTANT_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_MEMORY_REQUIREMENTS_INFO_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 4
//         Enum:
//             Name: VK_STRUCTURE_TYPE_BIND_DATA_GRAPH_PIPELINE_SESSION_MEMORY_INFO_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 5
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DATA_GRAPH_FEATURES_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 6
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SHADER_MODULE_CREATE_INFO_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 7
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_PROPERTY_QUERY_RESULT_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 8
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_INFO_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 9
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_COMPILER_CONTROL_CREATE_INFO_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 10
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_REQUIREMENTS_INFO_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 11
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_REQUIREMENT_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 12
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_IDENTIFIER_CREATE_INFO_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 13
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_DISPATCH_INFO_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 14
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DATA_GRAPH_PROCESSING_ENGINE_CREATE_INFO_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 16
//         Enum:
//             Name: VK_STRUCTURE_TYPE_QUEUE_FAMILY_DATA_GRAPH_PROCESSING_ENGINE_PROPERTIES_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 17
//         Enum:
//             Name: VK_STRUCTURE_TYPE_QUEUE_FAMILY_DATA_GRAPH_PROPERTIES_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 18
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_QUEUE_FAMILY_DATA_GRAPH_PROCESSING_ENGINE_INFO_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 19
//         Enum:
//             Name: VK_OBJECT_TYPE_DATA_GRAPH_PIPELINE_SESSION_ARM
//             Negative: false
//             Extends: VkObjectType
//             Offset: 0
//         Enum:
//             Name: VK_PIPELINE_BIND_POINT_DATA_GRAPH_ARM
//             Negative: false
//             Extends: VkPipelineBindPoint
//             Offset: 0
//         Enum:
//             Name: VK_QUEUE_DATA_GRAPH_BIT_ARM
//             Negative: false
//             Bitpos: 10
//             Extends: VkQueueFlagBits
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_DATA_GRAPH_BIT_ARM
//             Negative: false
//             Bitpos: 42
//             Extends: VkPipelineStageFlagBits2
//         Enum:
//             Name: VK_ACCESS_2_DATA_GRAPH_READ_BIT_ARM
//             Negative: false
//             Bitpos: 47
//             Extends: VkAccessFlagBits2
//         Enum:
//             Name: VK_ACCESS_2_DATA_GRAPH_WRITE_BIT_ARM
//             Negative: false
//             Bitpos: 48
//             Extends: VkAccessFlagBits2
//         Enum:
//             Name: VK_TENSOR_USAGE_DATA_GRAPH_BIT_ARM
//             Negative: false
//             Bitpos: 5
//             Extends: VkTensorUsageFlagBitsARM
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_TENSOR_DATA_GRAPH_BIT_ARM
//             Negative: false
//             Bitpos: 48
//             Extends: VkFormatFeatureFlagBits2
//         Enum:
//             Name: VK_BUFFER_USAGE_2_DATA_GRAPH_FOREIGN_DESCRIPTOR_BIT_ARM
//             Negative: false
//             Bitpos: 29
//             Extends: VkBufferUsageFlagBits2
//         Enum:
//             Name: VK_MAX_PHYSICAL_DEVICE_DATA_GRAPH_OPERATION_SET_NAME_SIZE_ARM
//             Negative: false
//         Type:
//             Name: VkPhysicalDeviceDataGraphFeaturesARM
//         Type:
//             Name: VkDataGraphPipelineSessionARM
//         Type:
//             Name: VkDataGraphPipelineSessionBindPointARM
//         Type:
//             Name: VkDataGraphPipelineSessionBindPointTypeARM
//         Type:
//             Name: VkDataGraphPipelineConstantARM
//         Type:
//             Name: VkDataGraphPipelineResourceInfoARM
//         Type:
//             Name: VkDataGraphPipelineCompilerControlCreateInfoARM
//         Type:
//             Name: VkDataGraphPipelineCreateInfoARM
//         Type:
//             Name: VkDataGraphPipelineShaderModuleCreateInfoARM
//         Type:
//             Name: VkDataGraphPipelineSessionCreateInfoARM
//         Type:
//             Name: VkDataGraphPipelineSessionCreateFlagsARM
//         Type:
//             Name: VkDataGraphPipelineSessionCreateFlagBitsARM
//         Type:
//             Name: VkDataGraphPipelineSessionBindPointRequirementsInfoARM
//         Type:
//             Name: VkDataGraphPipelineSessionBindPointRequirementARM
//         Type:
//             Name: VkDataGraphPipelineSessionMemoryRequirementsInfoARM
//         Type:
//             Name: VkBindDataGraphPipelineSessionMemoryInfoARM
//         Type:
//             Name: VkDataGraphPipelineInfoARM
//         Type:
//             Name: VkDataGraphPipelinePropertyQueryResultARM
//         Type:
//             Name: VkDataGraphPipelinePropertyARM
//         Type:
//             Name: VkDataGraphPipelineIdentifierCreateInfoARM
//         Type:
//             Name: VkDataGraphPipelineDispatchFlagsARM
//         Type:
//             Name: VkDataGraphPipelineDispatchFlagBitsARM
//         Type:
//             Name: VkDataGraphPipelineDispatchInfoARM
//         Type:
//             Name: VkPhysicalDeviceDataGraphProcessingEngineTypeARM
//         Type:
//             Name: VkPhysicalDeviceDataGraphOperationTypeARM
//         Type:
//             Name: VkPhysicalDeviceDataGraphProcessingEngineARM
//         Type:
//             Name: VkQueueFamilyDataGraphPropertiesARM
//         Type:
//             Name: VkDataGraphProcessingEngineCreateInfoARM
//         Type:
//             Name: VkPhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARM
//         Type:
//             Name: VkQueueFamilyDataGraphProcessingEnginePropertiesARM
//         Type:
//             Name: VkPhysicalDeviceDataGraphOperationSupportARM
//         Command:
//             Name: vkCreateDataGraphPipelinesARM
//         Command:
//             Name: vkCreateDataGraphPipelineSessionARM
//         Command:
//             Name: vkGetDataGraphPipelineSessionBindPointRequirementsARM
//         Command:
//             Name: vkGetDataGraphPipelineSessionMemoryRequirementsARM
//         Command:
//             Name: vkBindDataGraphPipelineSessionMemoryARM
//         Command:
//             Name: vkDestroyDataGraphPipelineSessionARM
//         Command:
//             Name: vkCmdDispatchDataGraphARM
//         Command:
//             Name: vkGetDataGraphPipelineAvailablePropertiesARM
//         Command:
//             Name: vkGetDataGraphPipelinePropertiesARM
//         Command:
//             Name: vkGetPhysicalDeviceQueueFamilyDataGraphPropertiesARM
//         Command:
//             Name: vkGetPhysicalDeviceQueueFamilyDataGraphProcessingEnginePropertiesARM
//         Feature:
//             Name: dataGraph
//             Struct: VkPhysicalDeviceDataGraphFeaturesARM
//     Depends: VK_ARM_tensors
//         Type:
//             Name: VkDataGraphPipelineConstantTensorSemiStructuredSparsityInfoARM
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_CONSTANT_TENSOR_SEMI_STRUCTURED_SPARSITY_INFO_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 15
pub const VK_EXT_extension_509_name = "VK_EXT_extension_509";
// Extension: VK_EXT_extension_509
// Number: 509
// Type: device
// Author: EXT
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_509_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_509_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_509&quot;
pub const VK_MESA_extension_510_name = "VK_MESA_extension_510";
// Extension: VK_MESA_extension_510
// Number: 510
// Type: device
// Author: MESA
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_MESA_EXTENSION_510_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_MESA_EXTENSION_510_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_MESA_extension_510&quot;
pub const VK_QCOM_multiview_per_view_render_areas_name = "VK_QCOM_multiview_per_view_render_areas";
// Extension: VK_QCOM_multiview_per_view_render_areas
// Number: 511
// Type: device
// Author: QCOM
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_QCOM_MULTIVIEW_PER_VIEW_RENDER_AREAS_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_QCOM_MULTIVIEW_PER_VIEW_RENDER_AREAS_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_QCOM_multiview_per_view_render_areas&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_RENDER_AREAS_FEATURES_QCOM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_RENDER_AREAS_RENDER_PASS_BEGIN_INFO_QCOM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Type:
//             Name: VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM
//         Type:
//             Name: VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM
//         Feature:
//             Name: multiviewPerViewRenderAreas
//             Struct: VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM
pub const VK_KHR_compute_shader_derivatives_name = "VK_KHR_compute_shader_derivatives";
// Extension: VK_KHR_compute_shader_derivatives
// Number: 512
// Type: device
// Author: KHR
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_COMPUTE_SHADER_DERIVATIVES_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_COMPUTE_SHADER_DERIVATIVES_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_compute_shader_derivatives&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Extnumber: 202
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR
//         Type:
//             Name: VkPhysicalDeviceComputeShaderDerivativesPropertiesKHR
//         Feature:
//             Name: computeDerivativeGroupLinear
//             Struct: VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR
pub const VK_KHR_video_decode_av1_name = "VK_KHR_video_decode_av1";
// Extension: VK_KHR_video_decode_av1
// Number: 513
// Type: device
// Author: KHR
// Depends: VK_KHR_video_decode_queue
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_VIDEO_DECODE_AV1_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_VIDEO_DECODE_AV1_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_video_decode_av1&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_CAPABILITIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_PICTURE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_PROFILE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_SESSION_PARAMETERS_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 4
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_DPB_SLOT_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 5
//         Enum:
//             Name: VK_VIDEO_CODEC_OPERATION_DECODE_AV1_BIT_KHR
//             Negative: false
//             Bitpos: 2
//             Extends: VkVideoCodecOperationFlagBitsKHR
//         Enum:
//             Name: VK_MAX_VIDEO_AV1_REFERENCES_PER_FRAME_KHR
//             Negative: false
//         Type:
//             Name: VkVideoDecodeAV1ProfileInfoKHR
//         Type:
//             Name: VkVideoDecodeAV1CapabilitiesKHR
//         Type:
//             Name: VkVideoDecodeAV1SessionParametersCreateInfoKHR
//         Type:
//             Name: VkVideoDecodeAV1PictureInfoKHR
//         Type:
//             Name: VkVideoDecodeAV1DpbSlotInfoKHR
pub const VK_KHR_video_encode_av1_name = "VK_KHR_video_encode_av1";
// Extension: VK_KHR_video_encode_av1
// Number: 514
// Type: device
// Author: KHR
// Depends: VK_KHR_video_encode_queue
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_VIDEO_ENCODE_AV1_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_VIDEO_ENCODE_AV1_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_video_encode_av1&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_CAPABILITIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_SESSION_PARAMETERS_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_PICTURE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_DPB_SLOT_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_AV1_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 4
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_PROFILE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 5
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_RATE_CONTROL_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 6
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_RATE_CONTROL_LAYER_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 7
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_QUALITY_LEVEL_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 8
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_SESSION_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 9
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_GOP_REMAINING_FRAME_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 10
//         Enum:
//             Name: VK_VIDEO_CODEC_OPERATION_ENCODE_AV1_BIT_KHR
//             Negative: false
//             Bitpos: 18
//             Extends: VkVideoCodecOperationFlagBitsKHR
//         Enum:
//             Name: VK_MAX_VIDEO_AV1_REFERENCES_PER_FRAME_KHR
//             Negative: false
//         Type:
//             Name: VkPhysicalDeviceVideoEncodeAV1FeaturesKHR
//         Type:
//             Name: VkVideoEncodeAV1PredictionModeKHR
//         Type:
//             Name: VkVideoEncodeAV1RateControlGroupKHR
//         Type:
//             Name: VkVideoEncodeAV1CapabilityFlagBitsKHR
//         Type:
//             Name: VkVideoEncodeAV1CapabilityFlagsKHR
//         Type:
//             Name: VkVideoEncodeAV1StdFlagBitsKHR
//         Type:
//             Name: VkVideoEncodeAV1StdFlagsKHR
//         Type:
//             Name: VkVideoEncodeAV1SuperblockSizeFlagBitsKHR
//         Type:
//             Name: VkVideoEncodeAV1SuperblockSizeFlagsKHR
//         Type:
//             Name: VkVideoEncodeAV1CapabilitiesKHR
//         Type:
//             Name: VkVideoEncodeAV1QualityLevelPropertiesKHR
//         Type:
//             Name: VkVideoEncodeAV1SessionCreateInfoKHR
//         Type:
//             Name: VkVideoEncodeAV1SessionParametersCreateInfoKHR
//         Type:
//             Name: VkVideoEncodeAV1PictureInfoKHR
//         Type:
//             Name: VkVideoEncodeAV1DpbSlotInfoKHR
//         Type:
//             Name: VkVideoEncodeAV1ProfileInfoKHR
//         Type:
//             Name: VkVideoEncodeAV1QIndexKHR
//         Type:
//             Name: VkVideoEncodeAV1FrameSizeKHR
//         Type:
//             Name: VkVideoEncodeAV1GopRemainingFrameInfoKHR
//         Type:
//             Name: VkVideoEncodeAV1RateControlInfoKHR
//         Type:
//             Name: VkVideoEncodeAV1RateControlFlagBitsKHR
//         Type:
//             Name: VkVideoEncodeAV1RateControlFlagsKHR
//         Type:
//             Name: VkVideoEncodeAV1RateControlLayerInfoKHR
//         Feature:
//             Name: videoEncodeAV1
//             Struct: VkPhysicalDeviceVideoEncodeAV1FeaturesKHR
pub const VK_KHR_video_decode_vp9_name = "VK_KHR_video_decode_vp9";
// Extension: VK_KHR_video_decode_vp9
// Number: 515
// Type: device
// Author: KHR
// Depends: VK_KHR_video_decode_queue
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_VIDEO_DECODE_VP9_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_VIDEO_DECODE_VP9_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_video_decode_vp9&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_DECODE_VP9_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_DECODE_VP9_CAPABILITIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_DECODE_VP9_PICTURE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_DECODE_VP9_PROFILE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Enum:
//             Name: VK_VIDEO_CODEC_OPERATION_DECODE_VP9_BIT_KHR
//             Negative: false
//             Bitpos: 3
//             Extends: VkVideoCodecOperationFlagBitsKHR
//         Enum:
//             Name: VK_MAX_VIDEO_VP9_REFERENCES_PER_FRAME_KHR
//             Negative: false
//         Type:
//             Name: VkPhysicalDeviceVideoDecodeVP9FeaturesKHR
//         Type:
//             Name: VkVideoDecodeVP9ProfileInfoKHR
//         Type:
//             Name: VkVideoDecodeVP9CapabilitiesKHR
//         Type:
//             Name: VkVideoDecodeVP9PictureInfoKHR
//         Feature:
//             Name: videoDecodeVP9
//             Struct: VkPhysicalDeviceVideoDecodeVP9FeaturesKHR
pub const VK_KHR_video_maintenance1_name = "VK_KHR_video_maintenance1";
// Extension: VK_KHR_video_maintenance1
// Number: 516
// Type: device
// Author: KHR
// Depends: VK_KHR_video_queue
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_VIDEO_MAINTENANCE_1_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_VIDEO_MAINTENANCE_1_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_video_maintenance1&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_1_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_INLINE_QUERY_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_IMAGE_CREATE_VIDEO_PROFILE_INDEPENDENT_BIT_KHR
//             Negative: false
//             Bitpos: 20
//             Extends: VkImageCreateFlagBits
//         Enum:
//             Name: VK_BUFFER_CREATE_VIDEO_PROFILE_INDEPENDENT_BIT_KHR
//             Negative: false
//             Bitpos: 6
//             Extends: VkBufferCreateFlagBits
//         Enum:
//             Name: VK_VIDEO_SESSION_CREATE_INLINE_QUERIES_BIT_KHR
//             Negative: false
//             Bitpos: 2
//             Extends: VkVideoSessionCreateFlagBitsKHR
//         Type:
//             Name: VkPhysicalDeviceVideoMaintenance1FeaturesKHR
//         Type:
//             Name: VkVideoInlineQueryInfoKHR
//         Feature:
//             Name: videoMaintenance1
//             Struct: VkPhysicalDeviceVideoMaintenance1FeaturesKHR
pub const VK_NV_per_stage_descriptor_set_name = "VK_NV_per_stage_descriptor_set";
// Extension: VK_NV_per_stage_descriptor_set
// Number: 517
// Type: device
// Author: NV
// Depends: VK_KHR_maintenance6,VK_VERSION_1_4
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NV_PER_STAGE_DESCRIPTOR_SET_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_NV_PER_STAGE_DESCRIPTOR_SET_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_per_stage_descriptor_set&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PER_STAGE_DESCRIPTOR_SET_FEATURES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_DESCRIPTOR_SET_LAYOUT_CREATE_PER_STAGE_BIT_NV
//             Negative: false
//             Bitpos: 6
//             Extends: VkDescriptorSetLayoutCreateFlagBits
//         Type:
//             Name: VkPhysicalDevicePerStageDescriptorSetFeaturesNV
//         Feature:
//             Name: perStageDescriptorSet
//             Struct: VkPhysicalDevicePerStageDescriptorSetFeaturesNV
pub const VK_MESA_extension_518_name = "VK_MESA_extension_518";
// Extension: VK_MESA_extension_518
// Number: 518
// Type: device
// Author: MESA
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_MESA_EXTENSION_518_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_MESA_EXTENSION_518_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_MESA_extension_518&quot;
pub const VK_QCOM_image_processing2_name = "VK_QCOM_image_processing2";
// Extension: VK_QCOM_image_processing2
// Number: 519
// Type: device
// Author: QCOM
// Depends: VK_QCOM_image_processing
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_QCOM_IMAGE_PROCESSING_2_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_QCOM_IMAGE_PROCESSING_2_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_QCOM_image_processing2&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_FEATURES_QCOM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_PROPERTIES_QCOM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SAMPLER_BLOCK_MATCH_WINDOW_CREATE_INFO_QCOM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Type:
//             Name: VkPhysicalDeviceImageProcessing2FeaturesQCOM
//         Type:
//             Name: VkPhysicalDeviceImageProcessing2PropertiesQCOM
//         Type:
//             Name: VkSamplerBlockMatchWindowCreateInfoQCOM
//         Type:
//             Name: VkBlockMatchWindowCompareModeQCOM
//         Feature:
//             Name: textureBlockMatch2
//             Struct: VkPhysicalDeviceImageProcessing2FeaturesQCOM
pub const VK_QCOM_filter_cubic_weights_name = "VK_QCOM_filter_cubic_weights";
// Extension: VK_QCOM_filter_cubic_weights
// Number: 520
// Type: device
// Author: QCOM
// Depends: VK_EXT_filter_cubic
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_QCOM_FILTER_CUBIC_WEIGHTS_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_QCOM_FILTER_CUBIC_WEIGHTS_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_QCOM_filter_cubic_weights&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SAMPLER_CUBIC_WEIGHTS_CREATE_INFO_QCOM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_WEIGHTS_FEATURES_QCOM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_BLIT_IMAGE_CUBIC_WEIGHTS_INFO_QCOM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Type:
//             Name: VkPhysicalDeviceCubicWeightsFeaturesQCOM
//         Type:
//             Name: VkSamplerCubicWeightsCreateInfoQCOM
//         Type:
//             Name: VkBlitImageCubicWeightsInfoQCOM
//         Type:
//             Name: VkCubicFilterWeightsQCOM
//         Feature:
//             Name: selectableCubicWeights
//             Struct: VkPhysicalDeviceCubicWeightsFeaturesQCOM
pub const VK_QCOM_ycbcr_degamma_name = "VK_QCOM_ycbcr_degamma";
// Extension: VK_QCOM_ycbcr_degamma
// Number: 521
// Type: device
// Author: QCOM
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_QCOM_YCBCR_DEGAMMA_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_QCOM_YCBCR_DEGAMMA_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_QCOM_ycbcr_degamma&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_DEGAMMA_FEATURES_QCOM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_YCBCR_DEGAMMA_CREATE_INFO_QCOM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Type:
//             Name: VkPhysicalDeviceYcbcrDegammaFeaturesQCOM
//         Type:
//             Name: VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM
//         Feature:
//             Name: ycbcrDegamma
//             Struct: VkPhysicalDeviceYcbcrDegammaFeaturesQCOM
pub const VK_QCOM_filter_cubic_clamp_name = "VK_QCOM_filter_cubic_clamp";
// Extension: VK_QCOM_filter_cubic_clamp
// Number: 522
// Type: device
// Author: QCOM
// Depends: (VK_EXT_filter_cubic)+(VK_VERSION_1_2,VK_EXT_sampler_filter_minmax)
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_QCOM_FILTER_CUBIC_CLAMP_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_QCOM_FILTER_CUBIC_CLAMP_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_QCOM_filter_cubic_clamp&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_CLAMP_FEATURES_QCOM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_RANGECLAMP_QCOM
//             Negative: false
//             Extends: VkSamplerReductionMode
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceCubicClampFeaturesQCOM
//         Feature:
//             Name: cubicRangeClamp
//             Struct: VkPhysicalDeviceCubicClampFeaturesQCOM
pub const VK_EXT_extension_523_name = "VK_EXT_extension_523";
// Extension: VK_EXT_extension_523
// Number: 523
// Type: invalid
// Author: EXT
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_523_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_523_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_523&quot;
pub const VK_EXT_extension_524_name = "VK_EXT_extension_524";
// Extension: VK_EXT_extension_524
// Number: 524
// Type: invalid
// Author: EXT
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_524_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_524_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_524&quot;
pub const VK_EXT_attachment_feedback_loop_dynamic_state_name = "VK_EXT_attachment_feedback_loop_dynamic_state";
// Extension: VK_EXT_attachment_feedback_loop_dynamic_state
// Number: 525
// Type: device
// Author: EXT
// Depends: (VK_KHR_get_physical_device_properties2,VK_VERSION_1_1)+VK_EXT_attachment_feedback_loop_layout
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_attachment_feedback_loop_dynamic_state&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT
//             Negative: false
//             Extends: VkDynamicState
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT
//         Command:
//             Name: vkCmdSetAttachmentFeedbackLoopEnableEXT
//         Feature:
//             Name: attachmentFeedbackLoopDynamicState
//             Struct: VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT
pub const VK_KHR_vertex_attribute_divisor_name = "VK_KHR_vertex_attribute_divisor";
// Extension: VK_KHR_vertex_attribute_divisor
// Number: 526
// Type: device
// Author: KHR
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_4
// Unlocks:
//         Enum:
//             Name: VK_KHR_VERTEX_ATTRIBUTE_DIVISOR_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_VERTEX_ATTRIBUTE_DIVISOR_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_vertex_attribute_divisor&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES
//         Type:
//             Name: VkPhysicalDeviceVertexAttributeDivisorPropertiesKHR
//         Type:
//             Name: VkVertexInputBindingDivisorDescriptionKHR
//         Type:
//             Name: VkPipelineVertexInputDivisorStateCreateInfoKHR
//         Type:
//             Name: VkPhysicalDeviceVertexAttributeDivisorFeaturesKHR
//         Feature:
//             Name: vertexAttributeInstanceRateDivisor
//             Struct: VkPhysicalDeviceVertexAttributeDivisorFeaturesKHR
pub const VK_KHR_load_store_op_none_name = "VK_KHR_load_store_op_none";
// Extension: VK_KHR_load_store_op_none
// Number: 527
// Type: device
// Author: KHR
// Supported: supported
// Promoted to: VK_VERSION_1_4
// Unlocks:
//         Enum:
//             Name: VK_KHR_LOAD_STORE_OP_NONE_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_LOAD_STORE_OP_NONE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_load_store_op_none&quot;
//         Enum:
//             Name: VK_ATTACHMENT_LOAD_OP_NONE_KHR
//             Negative: false
//             Extends: VkAttachmentLoadOp
//             Alias: VK_ATTACHMENT_LOAD_OP_NONE
//         Enum:
//             Name: VK_ATTACHMENT_STORE_OP_NONE_KHR
//             Negative: false
//             Extends: VkAttachmentStoreOp
//             Alias: VK_ATTACHMENT_STORE_OP_NONE
pub const VK_KHR_unified_image_layouts_name = "VK_KHR_unified_image_layouts";
// Extension: VK_KHR_unified_image_layouts
// Number: 528
// Type: device
// Author: KHR
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_UNIFIED_IMAGE_LAYOUTS_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_UNIFIED_IMAGE_LAYOUTS_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_unified_image_layouts&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFIED_IMAGE_LAYOUTS_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceUnifiedImageLayoutsFeaturesKHR
//         Feature:
//             Name: unifiedImageLayouts
//             Struct: VkPhysicalDeviceUnifiedImageLayoutsFeaturesKHR
//     Depends: VK_EXT_attachment_feedback_loop_layout+(VK_VERSION_1_3,VK_KHR_dynamic_rendering)
//         Enum:
//             Name: VK_STRUCTURE_TYPE_ATTACHMENT_FEEDBACK_LOOP_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Type:
//             Name: VkAttachmentFeedbackLoopInfoEXT
pub const VK_KHR_shader_float_controls2_name = "VK_KHR_shader_float_controls2";
// Extension: VK_KHR_shader_float_controls2
// Number: 529
// Type: device
// Author: KHR
// Depends: VK_VERSION_1_1+VK_KHR_shader_float_controls
// Supported: supported
// Promoted to: VK_VERSION_1_4
// Unlocks:
//         Enum:
//             Name: VK_KHR_SHADER_FLOAT_CONTROLS_2_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_SHADER_FLOAT_CONTROLS_2_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_shader_float_controls2&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT_CONTROLS_2_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT_CONTROLS_2_FEATURES
//         Type:
//             Name: VkPhysicalDeviceShaderFloatControls2FeaturesKHR
//         Feature:
//             Name: shaderFloatControls2
//             Struct: VkPhysicalDeviceShaderFloatControls2FeaturesKHR
pub const VK_QNX_external_memory_screen_buffer_name = "VK_QNX_external_memory_screen_buffer";
// Extension: VK_QNX_external_memory_screen_buffer
// Number: 530
// Type: device
// Author: QNX
// Depends: ((VK_KHR_sampler_ycbcr_conversion+VK_KHR_external_memory+VK_KHR_dedicated_allocation),VK_VERSION_1_1)+VK_EXT_queue_family_foreign
// Platform: screen
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_QNX_EXTERNAL_MEMORY_SCREEN_BUFFER_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_QNX_EXTERNAL_MEMORY_SCREEN_BUFFER_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_QNX_external_memory_screen_buffer&quot;
//         Enum:
//             Name: VK_EXTERNAL_MEMORY_HANDLE_TYPE_SCREEN_BUFFER_BIT_QNX
//             Negative: false
//             Bitpos: 14
//             Extends: VkExternalMemoryHandleTypeFlagBits
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SCREEN_BUFFER_PROPERTIES_QNX
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SCREEN_BUFFER_FORMAT_PROPERTIES_QNX
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMPORT_SCREEN_BUFFER_INFO_QNX
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_QNX
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_SCREEN_BUFFER_FEATURES_QNX
//             Negative: false
//             Extends: VkStructureType
//             Offset: 4
//         Type:
//             Name: VkScreenBufferPropertiesQNX
//         Type:
//             Name: VkScreenBufferFormatPropertiesQNX
//         Type:
//             Name: VkImportScreenBufferInfoQNX
//         Type:
//             Name: VkExternalFormatQNX
//         Type:
//             Name: VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX
//         Command:
//             Name: vkGetScreenBufferPropertiesQNX
//         Feature:
//             Name: screenBufferImport
//             Struct: VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX
pub const VK_MSFT_layered_driver_name = "VK_MSFT_layered_driver";
// Extension: VK_MSFT_layered_driver
// Number: 531
// Type: device
// Author: MSFT
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_MSFT_LAYERED_DRIVER_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_MSFT_LAYERED_DRIVER_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_MSFT_layered_driver&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_DRIVER_PROPERTIES_MSFT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkLayeredDriverUnderlyingApiMSFT
//         Type:
//             Name: VkPhysicalDeviceLayeredDriverPropertiesMSFT
pub const VK_KHR_extension_532_name = "VK_KHR_extension_532";
// Extension: VK_KHR_extension_532
// Number: 532
// Type: invalid
// Author: KHR
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_KHR_EXTENSION_532_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_KHR_EXTENSION_532_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_extension_532&quot;
pub const VK_EXT_extension_533_name = "VK_EXT_extension_533";
// Extension: VK_EXT_extension_533
// Number: 533
// Type: invalid
// Author: EXT
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_533_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_533_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_533&quot;
pub const VK_KHR_index_type_uint8_name = "VK_KHR_index_type_uint8";
// Extension: VK_KHR_index_type_uint8
// Number: 534
// Type: device
// Author: KHR
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_4
// Unlocks:
//         Enum:
//             Name: VK_KHR_INDEX_TYPE_UINT8_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_INDEX_TYPE_UINT8_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_index_type_uint8&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES
//         Enum:
//             Name: VK_INDEX_TYPE_UINT8_KHR
//             Negative: false
//             Extends: VkIndexType
//             Alias: VK_INDEX_TYPE_UINT8
//         Type:
//             Name: VkPhysicalDeviceIndexTypeUint8FeaturesKHR
//         Feature:
//             Name: indexTypeUint8
//             Struct: VkPhysicalDeviceIndexTypeUint8FeaturesKHR
pub const VK_KHR_line_rasterization_name = "VK_KHR_line_rasterization";
// Extension: VK_KHR_line_rasterization
// Number: 535
// Type: device
// Author: KHR
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_4
// Unlocks:
//         Enum:
//             Name: VK_KHR_LINE_RASTERIZATION_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_LINE_RASTERIZATION_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_line_rasterization&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES
//         Enum:
//             Name: VK_DYNAMIC_STATE_LINE_STIPPLE_KHR
//             Negative: false
//             Extends: VkDynamicState
//             Alias: VK_DYNAMIC_STATE_LINE_STIPPLE
//         Enum:
//             Name: VK_LINE_RASTERIZATION_MODE_DEFAULT_KHR
//             Negative: false
//             Extends: VkLineRasterizationMode
//             Alias: VK_LINE_RASTERIZATION_MODE_DEFAULT
//         Enum:
//             Name: VK_LINE_RASTERIZATION_MODE_RECTANGULAR_KHR
//             Negative: false
//             Extends: VkLineRasterizationMode
//             Alias: VK_LINE_RASTERIZATION_MODE_RECTANGULAR
//         Enum:
//             Name: VK_LINE_RASTERIZATION_MODE_BRESENHAM_KHR
//             Negative: false
//             Extends: VkLineRasterizationMode
//             Alias: VK_LINE_RASTERIZATION_MODE_BRESENHAM
//         Enum:
//             Name: VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_KHR
//             Negative: false
//             Extends: VkLineRasterizationMode
//             Alias: VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH
//         Type:
//             Name: VkPhysicalDeviceLineRasterizationFeaturesKHR
//         Type:
//             Name: VkPhysicalDeviceLineRasterizationPropertiesKHR
//         Type:
//             Name: VkPipelineRasterizationLineStateCreateInfoKHR
//         Type:
//             Name: VkLineRasterizationModeKHR
//         Command:
//             Name: vkCmdSetLineStippleKHR
//         Feature:
//             Name: rectangularLines,bresenhamLines,smoothLines,stippledRectangularLines,stippledBresenhamLines,stippledSmoothLines
//             Struct: VkPhysicalDeviceLineRasterizationFeaturesKHR
pub const VK_QCOM_extension_536_name = "VK_QCOM_extension_536";
// Extension: VK_QCOM_extension_536
// Number: 536
// Type: device
// Author: QCOM
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_QCOM_EXTENSION_536_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_QCOM_EXTENSION_536_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_QCOM_extension_536&quot;
pub const VK_EXT_extension_537_name = "VK_EXT_extension_537";
// Extension: VK_EXT_extension_537
// Number: 537
// Type: invalid
// Author: EXT
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_537_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_537_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_537&quot;
//         Enum:
//             Name: VK_QUEUE_RESERVED_12_BIT_EXT
//             Negative: false
//             Bitpos: 12
//             Extends: VkQueueFlagBits
//         Enum:
//             Name: VK_BUFFER_USAGE_2_RESERVED_34_BIT_EXT
//             Negative: false
//             Bitpos: 34
//             Extends: VkBufferUsageFlagBits2
//         Enum:
//             Name: VK_IMAGE_USAGE_RESERVED_28_BIT_EXT
//             Negative: false
//             Bitpos: 28
//             Extends: VkImageUsageFlagBits
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_RESERVED_60_BIT_EXT
//             Negative: false
//             Bitpos: 60
//             Extends: VkFormatFeatureFlagBits2
pub const VK_EXT_extension_538_name = "VK_EXT_extension_538";
// Extension: VK_EXT_extension_538
// Number: 538
// Type: invalid
// Author: EXT
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_538_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_538_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_538&quot;
pub const VK_EXT_extension_539_name = "VK_EXT_extension_539";
// Extension: VK_EXT_extension_539
// Number: 539
// Type: invalid
// Author: EXT
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_539_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_539_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_539&quot;
pub const VK_EXT_extension_540_name = "VK_EXT_extension_540";
// Extension: VK_EXT_extension_540
// Number: 540
// Type: invalid
// Author: EXT
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_540_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_540_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_540&quot;
pub const VK_EXT_extension_541_name = "VK_EXT_extension_541";
// Extension: VK_EXT_extension_541
// Number: 541
// Type: invalid
// Author: EXT
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_541_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_541_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_541&quot;
pub const VK_EXT_extension_542_name = "VK_EXT_extension_542";
// Extension: VK_EXT_extension_542
// Number: 542
// Type: invalid
// Author: EXT
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_542_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_542_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_542&quot;
pub const VK_EXT_extension_543_name = "VK_EXT_extension_543";
// Extension: VK_EXT_extension_543
// Number: 543
// Type: invalid
// Author: EXT
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_543_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_543_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_543&quot;
pub const VK_KHR_calibrated_timestamps_name = "VK_KHR_calibrated_timestamps";
// Extension: VK_KHR_calibrated_timestamps
// Number: 544
// Type: device
// Author: KHR
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_CALIBRATED_TIMESTAMPS_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_CALIBRATED_TIMESTAMPS_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_calibrated_timestamps&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Extnumber: 185
//             Offset: 0
//         Type:
//             Name: VkTimeDomainKHR
//         Type:
//             Name: VkCalibratedTimestampInfoKHR
//         Command:
//             Name: vkGetPhysicalDeviceCalibrateableTimeDomainsKHR
//         Command:
//             Name: vkGetCalibratedTimestampsKHR
pub const VK_KHR_shader_expect_assume_name = "VK_KHR_shader_expect_assume";
// Extension: VK_KHR_shader_expect_assume
// Number: 545
// Type: device
// Author: KHR
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_4
// Unlocks:
//         Enum:
//             Name: VK_KHR_SHADER_EXPECT_ASSUME_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_SHADER_EXPECT_ASSUME_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_shader_expect_assume&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EXPECT_ASSUME_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EXPECT_ASSUME_FEATURES
//         Type:
//             Name: VkPhysicalDeviceShaderExpectAssumeFeaturesKHR
//         Feature:
//             Name: shaderExpectAssume
//             Struct: VkPhysicalDeviceShaderExpectAssumeFeaturesKHR
pub const VK_KHR_maintenance6_name = "VK_KHR_maintenance6";
// Extension: VK_KHR_maintenance6
// Number: 546
// Type: device
// Author: KHR
// Depends: VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_VERSION_1_4
// Unlocks:
//         Enum:
//             Name: VK_KHR_MAINTENANCE_6_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_MAINTENANCE_6_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_maintenance6&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_FEATURES
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_PROPERTIES
//         Enum:
//             Name: VK_STRUCTURE_TYPE_BIND_MEMORY_STATUS_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_BIND_MEMORY_STATUS
//         Enum:
//             Name: VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_SETS_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_SETS_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PUSH_CONSTANTS_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PUSH_CONSTANTS_INFO
//         Type:
//             Name: VkPhysicalDeviceMaintenance6FeaturesKHR
//         Type:
//             Name: VkPhysicalDeviceMaintenance6PropertiesKHR
//         Type:
//             Name: VkBindMemoryStatusKHR
//         Type:
//             Name: VkBindDescriptorSetsInfoKHR
//         Type:
//             Name: VkPushConstantsInfoKHR
//         Command:
//             Name: vkCmdBindDescriptorSets2KHR
//         Command:
//             Name: vkCmdPushConstants2KHR
//         Feature:
//             Name: maintenance6
//             Struct: VkPhysicalDeviceMaintenance6FeaturesKHR
//     Depends: VK_KHR_push_descriptor
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_INFO
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_WITH_TEMPLATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_WITH_TEMPLATE_INFO
//         Type:
//             Name: VkPushDescriptorSetInfoKHR
//         Type:
//             Name: VkPushDescriptorSetWithTemplateInfoKHR
//         Command:
//             Name: vkCmdPushDescriptorSet2KHR
//         Command:
//             Name: vkCmdPushDescriptorSetWithTemplate2KHR
//     Depends: VK_EXT_descriptor_buffer
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SET_DESCRIPTOR_BUFFER_OFFSETS_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 7
//         Enum:
//             Name: VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_BUFFER_EMBEDDED_SAMPLERS_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 8
//         Type:
//             Name: VkSetDescriptorBufferOffsetsInfoEXT
//         Type:
//             Name: VkBindDescriptorBufferEmbeddedSamplersInfoEXT
//         Command:
//             Name: vkCmdSetDescriptorBufferOffsets2EXT
//         Command:
//             Name: vkCmdBindDescriptorBufferEmbeddedSamplers2EXT
pub const VK_NV_descriptor_pool_overallocation_name = "VK_NV_descriptor_pool_overallocation";
// Extension: VK_NV_descriptor_pool_overallocation
// Number: 547
// Type: device
// Author: NV
// Depends: VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NV_DESCRIPTOR_POOL_OVERALLOCATION_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_NV_DESCRIPTOR_POOL_OVERALLOCATION_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_descriptor_pool_overallocation&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_POOL_OVERALLOCATION_FEATURES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_DESCRIPTOR_POOL_CREATE_ALLOW_OVERALLOCATION_SETS_BIT_NV
//             Negative: false
//             Bitpos: 3
//             Extends: VkDescriptorPoolCreateFlagBits
//         Enum:
//             Name: VK_DESCRIPTOR_POOL_CREATE_ALLOW_OVERALLOCATION_POOLS_BIT_NV
//             Negative: false
//             Bitpos: 4
//             Extends: VkDescriptorPoolCreateFlagBits
//         Type:
//             Name: VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV
//         Feature:
//             Name: descriptorPoolOverallocation
//             Struct: VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV
pub const VK_QCOM_tile_memory_heap_name = "VK_QCOM_tile_memory_heap";
// Extension: VK_QCOM_tile_memory_heap
// Number: 548
// Type: device
// Author: QCOM
// Depends: (VK_KHR_get_memory_requirements2+VK_KHR_get_physical_device_properties2),VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_QCOM_TILE_MEMORY_HEAP_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_QCOM_TILE_MEMORY_HEAP_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_QCOM_tile_memory_heap&quot;
//         Enum:
//             Name: VK_MEMORY_HEAP_TILE_MEMORY_BIT_QCOM
//             Negative: false
//             Bitpos: 3
//             Extends: VkMemoryHeapFlagBits
//         Enum:
//             Name: VK_BUFFER_USAGE_TILE_MEMORY_BIT_QCOM
//             Negative: false
//             Bitpos: 27
//             Extends: VkBufferUsageFlagBits
//         Enum:
//             Name: VK_BUFFER_USAGE_2_TILE_MEMORY_BIT_QCOM
//             Negative: false
//             Bitpos: 27
//             Extends: VkBufferUsageFlagBits2
//         Enum:
//             Name: VK_IMAGE_USAGE_TILE_MEMORY_BIT_QCOM
//             Negative: false
//             Bitpos: 27
//             Extends: VkImageUsageFlagBits
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_MEMORY_HEAP_FEATURES_QCOM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_MEMORY_HEAP_PROPERTIES_QCOM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_TILE_MEMORY_REQUIREMENTS_QCOM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_TILE_MEMORY_BIND_INFO_QCOM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Type:
//             Name: VkPhysicalDeviceTileMemoryHeapFeaturesQCOM
//         Type:
//             Name: VkPhysicalDeviceTileMemoryHeapPropertiesQCOM
//         Type:
//             Name: VkTileMemoryRequirementsQCOM
//         Type:
//             Name: VkTileMemoryBindInfoQCOM
//         Command:
//             Name: vkCmdBindTileMemoryQCOM
//         Feature:
//             Name: tileMemoryHeap
//             Struct: VkPhysicalDeviceTileMemoryHeapFeaturesQCOM
//     Depends: VK_QCOM_tile_properties
//         Enum:
//             Name: VK_STRUCTURE_TYPE_TILE_MEMORY_SIZE_INFO_QCOM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 4
//         Type:
//             Name: VkTileMemorySizeInfoQCOM
pub const VK_NV_extension_549_name = "VK_NV_extension_549";
// Extension: VK_NV_extension_549
// Number: 549
// Type: invalid
// Author: NV
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_NV_EXTENSION_549_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_NV_EXTENSION_549_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_extension_549&quot;
pub const VK_KHR_copy_memory_indirect_name = "VK_KHR_copy_memory_indirect";
// Extension: VK_KHR_copy_memory_indirect
// Number: 550
// Type: device
// Author: KHR
// Depends: (VK_KHR_get_physical_device_properties2+VK_KHR_buffer_device_address),VK_VERSION_1_2
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_COPY_MEMORY_INDIRECT_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_COPY_MEMORY_INDIRECT_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_copy_memory_indirect&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Extnumber: 427
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_COPY_MEMORY_INDIRECT_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_COPY_MEMORY_TO_IMAGE_INDIRECT_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_COPY_INDIRECT_BIT_KHR
//             Negative: false
//             Bitpos: 46
//             Extends: VkPipelineStageFlagBits2
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_COPY_IMAGE_INDIRECT_DST_BIT_KHR
//             Negative: false
//             Bitpos: 59
//             Extends: VkFormatFeatureFlagBits2
//         Type:
//             Name: VkStridedDeviceAddressRangeKHR
//         Type:
//             Name: VkAddressCopyFlagBitsKHR
//         Type:
//             Name: VkAddressCopyFlagsKHR
//         Type:
//             Name: VkCopyMemoryIndirectCommandKHR
//         Type:
//             Name: VkCopyMemoryIndirectInfoKHR
//         Type:
//             Name: VkCopyMemoryToImageIndirectCommandKHR
//         Type:
//             Name: VkCopyMemoryToImageIndirectInfoKHR
//         Type:
//             Name: VkPhysicalDeviceCopyMemoryIndirectFeaturesKHR
//         Type:
//             Name: VkPhysicalDeviceCopyMemoryIndirectPropertiesKHR
//         Command:
//             Name: vkCmdCopyMemoryIndirectKHR
//         Command:
//             Name: vkCmdCopyMemoryToImageIndirectKHR
//         Feature:
//             Name: indirectMemoryCopy
//             Struct: VkPhysicalDeviceCopyMemoryIndirectFeaturesKHR
pub const VK_EXT_memory_decompression_name = "VK_EXT_memory_decompression";
// Extension: VK_EXT_memory_decompression
// Number: 551
// Type: device
// Author: EXT
// Depends: VK_KHR_get_physical_device_properties2+VK_KHR_buffer_device_address
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_MEMORY_DECOMPRESSION_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_MEMORY_DECOMPRESSION_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_memory_decompression&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Extnumber: 428
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_PROPERTIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Extnumber: 428
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DECOMPRESS_MEMORY_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_MEMORY_DECOMPRESSION_BIT_EXT
//             Negative: false
//             Bitpos: 45
//             Extends: VkPipelineStageFlagBits2
//         Enum:
//             Name: VK_ACCESS_2_MEMORY_DECOMPRESSION_READ_BIT_EXT
//             Negative: false
//             Bitpos: 55
//             Extends: VkAccessFlagBits2
//         Enum:
//             Name: VK_ACCESS_2_MEMORY_DECOMPRESSION_WRITE_BIT_EXT
//             Negative: false
//             Bitpos: 56
//             Extends: VkAccessFlagBits2
//         Enum:
//             Name: VK_BUFFER_USAGE_2_MEMORY_DECOMPRESSION_BIT_EXT
//             Negative: false
//             Bitpos: 32
//             Extends: VkBufferUsageFlagBits2
//         Type:
//             Name: VkMemoryDecompressionMethodFlagBitsEXT
//         Type:
//             Name: VkMemoryDecompressionMethodFlagsEXT
//         Type:
//             Name: VkDecompressMemoryInfoEXT
//         Type:
//             Name: VkDecompressMemoryRegionEXT
//         Type:
//             Name: VkPhysicalDeviceMemoryDecompressionFeaturesEXT
//         Type:
//             Name: VkPhysicalDeviceMemoryDecompressionPropertiesEXT
//         Command:
//             Name: vkCmdDecompressMemoryEXT
//         Command:
//             Name: vkCmdDecompressMemoryIndirectCountEXT
//         Feature:
//             Name: memoryDecompression
//             Struct: VkPhysicalDeviceMemoryDecompressionFeaturesEXT
pub const VK_NV_display_stereo_name = "VK_NV_display_stereo";
// Extension: VK_NV_display_stereo
// Number: 552
// Type: instance
// Author: NV
// Depends: VK_KHR_display+VK_KHR_get_display_properties2
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NV_DISPLAY_STEREO_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_NV_DISPLAY_STEREO_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_display_stereo&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DISPLAY_SURFACE_STEREO_CREATE_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DISPLAY_MODE_STEREO_PROPERTIES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Type:
//             Name: VkDisplaySurfaceStereoCreateInfoNV
//         Type:
//             Name: VkDisplaySurfaceStereoTypeNV
//         Type:
//             Name: VkDisplayModeStereoPropertiesNV
pub const VK_KHR_video_encode_intra_refresh_name = "VK_KHR_video_encode_intra_refresh";
// Extension: VK_KHR_video_encode_intra_refresh
// Number: 553
// Type: device
// Author: KHR
// Depends: VK_KHR_video_encode_queue
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_VIDEO_ENCODE_INTRA_REFRESH_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_VIDEO_ENCODE_INTRA_REFRESH_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_video_encode_intra_refresh&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_INTRA_REFRESH_CAPABILITIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_INTRA_REFRESH_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_INTRA_REFRESH_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_REFERENCE_INTRA_REFRESH_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_INTRA_REFRESH_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 4
//         Enum:
//             Name: VK_VIDEO_ENCODE_INTRA_REFRESH_BIT_KHR
//             Negative: false
//             Bitpos: 2
//             Extends: VkVideoEncodeFlagBitsKHR
//         Type:
//             Name: VkVideoEncodeIntraRefreshModeFlagsKHR
//         Type:
//             Name: VkVideoEncodeIntraRefreshModeFlagBitsKHR
//         Type:
//             Name: VkVideoEncodeIntraRefreshCapabilitiesKHR
//         Type:
//             Name: VkVideoEncodeSessionIntraRefreshCreateInfoKHR
//         Type:
//             Name: VkVideoEncodeIntraRefreshInfoKHR
//         Type:
//             Name: VkVideoReferenceIntraRefreshInfoKHR
//         Type:
//             Name: VkPhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR
//         Feature:
//             Name: videoEncodeIntraRefresh
//             Struct: VkPhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR
//     Depends: VK_KHR_video_encode_h264
//         Enum:
//             Name: VK_VIDEO_ENCODE_H264_CAPABILITY_B_PICTURE_INTRA_REFRESH_BIT_KHR
//             Negative: false
//             Bitpos: 10
//             Extends: VkVideoEncodeH264CapabilityFlagBitsKHR
//     Depends: VK_KHR_video_encode_h265
//         Enum:
//             Name: VK_VIDEO_ENCODE_H265_CAPABILITY_B_PICTURE_INTRA_REFRESH_BIT_KHR
//             Negative: false
//             Bitpos: 11
//             Extends: VkVideoEncodeH265CapabilityFlagBitsKHR
//     Depends: VK_KHR_video_encode_av1
//         Enum:
//             Name: VK_VIDEO_ENCODE_AV1_CAPABILITY_COMPOUND_PREDICTION_INTRA_REFRESH_BIT_KHR
//             Negative: false
//             Bitpos: 5
//             Extends: VkVideoEncodeAV1CapabilityFlagBitsKHR
pub const VK_KHR_video_encode_quantization_map_name = "VK_KHR_video_encode_quantization_map";
// Extension: VK_KHR_video_encode_quantization_map
// Number: 554
// Type: device
// Author: KHR
// Depends: VK_KHR_video_encode_queue+(VK_KHR_format_feature_flags2,VK_VERSION_1_3)
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_VIDEO_ENCODE_QUANTIZATION_MAP_SPEC_VERSION
//             Negative: false
//             Value: 2
//         Enum:
//             Name: VK_KHR_VIDEO_ENCODE_QUANTIZATION_MAP_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_video_encode_quantization_map&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_CAPABILITIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_FORMAT_QUANTIZATION_MAP_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_SESSION_PARAMETERS_CREATE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 5
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUANTIZATION_MAP_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 9
//         Enum:
//             Name: VK_VIDEO_ENCODE_CAPABILITY_QUANTIZATION_DELTA_MAP_BIT_KHR
//             Negative: false
//             Bitpos: 2
//             Extends: VkVideoEncodeCapabilityFlagBitsKHR
//         Enum:
//             Name: VK_VIDEO_ENCODE_CAPABILITY_EMPHASIS_MAP_BIT_KHR
//             Negative: false
//             Bitpos: 3
//             Extends: VkVideoEncodeCapabilityFlagBitsKHR
//         Enum:
//             Name: VK_VIDEO_SESSION_CREATE_ALLOW_ENCODE_QUANTIZATION_DELTA_MAP_BIT_KHR
//             Negative: false
//             Bitpos: 3
//             Extends: VkVideoSessionCreateFlagBitsKHR
//         Enum:
//             Name: VK_VIDEO_SESSION_CREATE_ALLOW_ENCODE_EMPHASIS_MAP_BIT_KHR
//             Negative: false
//             Bitpos: 4
//             Extends: VkVideoSessionCreateFlagBitsKHR
//         Enum:
//             Name: VK_VIDEO_SESSION_PARAMETERS_CREATE_QUANTIZATION_MAP_COMPATIBLE_BIT_KHR
//             Negative: false
//             Bitpos: 0
//             Extends: VkVideoSessionParametersCreateFlagBitsKHR
//         Enum:
//             Name: VK_VIDEO_ENCODE_WITH_QUANTIZATION_DELTA_MAP_BIT_KHR
//             Negative: false
//             Bitpos: 0
//             Extends: VkVideoEncodeFlagBitsKHR
//         Enum:
//             Name: VK_VIDEO_ENCODE_WITH_EMPHASIS_MAP_BIT_KHR
//             Negative: false
//             Bitpos: 1
//             Extends: VkVideoEncodeFlagBitsKHR
//         Enum:
//             Name: VK_IMAGE_USAGE_VIDEO_ENCODE_QUANTIZATION_DELTA_MAP_BIT_KHR
//             Negative: false
//             Bitpos: 25
//             Extends: VkImageUsageFlagBits
//         Enum:
//             Name: VK_IMAGE_USAGE_VIDEO_ENCODE_EMPHASIS_MAP_BIT_KHR
//             Negative: false
//             Bitpos: 26
//             Extends: VkImageUsageFlagBits
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_VIDEO_ENCODE_QUANTIZATION_DELTA_MAP_BIT_KHR
//             Negative: false
//             Bitpos: 49
//             Extends: VkFormatFeatureFlagBits2
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_VIDEO_ENCODE_EMPHASIS_MAP_BIT_KHR
//             Negative: false
//             Bitpos: 50
//             Extends: VkFormatFeatureFlagBits2
//         Enum:
//             Name: VK_IMAGE_LAYOUT_VIDEO_ENCODE_QUANTIZATION_MAP_KHR
//             Negative: false
//             Extends: VkImageLayout
//             Offset: 0
//         Type:
//             Name: VkVideoEncodeFlagBitsKHR
//         Type:
//             Name: VkVideoSessionParametersCreateFlagBitsKHR
//         Type:
//             Name: VkVideoEncodeQuantizationMapCapabilitiesKHR
//         Type:
//             Name: VkVideoFormatQuantizationMapPropertiesKHR
//         Type:
//             Name: VkVideoEncodeQuantizationMapInfoKHR
//         Type:
//             Name: VkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR
//         Type:
//             Name: VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR
//         Feature:
//             Name: videoEncodeQuantizationMap
//             Struct: VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR
//     Depends: VK_KHR_video_encode_h264
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_QUANTIZATION_MAP_CAPABILITIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Enum:
//             Name: VK_VIDEO_ENCODE_H264_CAPABILITY_MB_QP_DIFF_WRAPAROUND_BIT_KHR
//             Negative: false
//             Bitpos: 9
//             Extends: VkVideoEncodeH264CapabilityFlagBitsKHR
//         Type:
//             Name: VkVideoEncodeH264QuantizationMapCapabilitiesKHR
//     Depends: VK_KHR_video_encode_h265
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_QUANTIZATION_MAP_CAPABILITIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 4
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_FORMAT_H265_QUANTIZATION_MAP_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 6
//         Enum:
//             Name: VK_VIDEO_ENCODE_H265_CAPABILITY_CU_QP_DIFF_WRAPAROUND_BIT_KHR
//             Negative: false
//             Bitpos: 10
//             Extends: VkVideoEncodeH265CapabilityFlagBitsKHR
//         Type:
//             Name: VkVideoEncodeH265QuantizationMapCapabilitiesKHR
//         Type:
//             Name: VkVideoFormatH265QuantizationMapPropertiesKHR
//     Depends: VK_KHR_video_encode_av1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_QUANTIZATION_MAP_CAPABILITIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 7
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_FORMAT_AV1_QUANTIZATION_MAP_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 8
//         Type:
//             Name: VkVideoEncodeAV1QuantizationMapCapabilitiesKHR
//         Type:
//             Name: VkVideoFormatAV1QuantizationMapPropertiesKHR
pub const VK_IMG_extension_555_name = "VK_IMG_extension_555";
// Extension: VK_IMG_extension_555
// Number: 555
// Type: invalid
// Author: IMG
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_IMG_EXTENSION_555_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_IMG_EXTENSION_555_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_IMG_extension_555&quot;
pub const VK_NV_raw_access_chains_name = "VK_NV_raw_access_chains";
// Extension: VK_NV_raw_access_chains
// Number: 556
// Type: device
// Author: NV
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NV_RAW_ACCESS_CHAINS_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_NV_RAW_ACCESS_CHAINS_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_raw_access_chains&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAW_ACCESS_CHAINS_FEATURES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceRawAccessChainsFeaturesNV
//         Feature:
//             Name: shaderRawAccessChains
//             Struct: VkPhysicalDeviceRawAccessChainsFeaturesNV
pub const VK_NV_external_compute_queue_name = "VK_NV_external_compute_queue";
// Extension: VK_NV_external_compute_queue
// Number: 557
// Type: device
// Author: NV
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NV_EXTERNAL_COMPUTE_QUEUE_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_NV_EXTERNAL_COMPUTE_QUEUE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_external_compute_queue&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_EXTERNAL_COMPUTE_QUEUE_DEVICE_CREATE_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_EXTERNAL_COMPUTE_QUEUE_CREATE_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_EXTERNAL_COMPUTE_QUEUE_DATA_PARAMS_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_COMPUTE_QUEUE_PROPERTIES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Enum:
//             Name: VK_OBJECT_TYPE_EXTERNAL_COMPUTE_QUEUE_NV
//             Negative: false
//             Extends: VkObjectType
//             Offset: 0
//         Type:
//             Name: VkExternalComputeQueueNV
//         Type:
//             Name: VkExternalComputeQueueDeviceCreateInfoNV
//         Type:
//             Name: VkExternalComputeQueueCreateInfoNV
//         Type:
//             Name: VkExternalComputeQueueDataParamsNV
//         Type:
//             Name: VkPhysicalDeviceExternalComputeQueuePropertiesNV
//         Command:
//             Name: vkCreateExternalComputeQueueNV
//         Command:
//             Name: vkDestroyExternalComputeQueueNV
//         Command:
//             Name: vkGetExternalComputeQueueDataNV
pub const VK_KHR_extension_558_name = "VK_KHR_extension_558";
// Extension: VK_KHR_extension_558
// Number: 558
// Type: device
// Author: KHR
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_KHR_EXTENSION_558_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_KHR_EXTENSION_558_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_extension_558&quot;
pub const VK_KHR_shader_relaxed_extended_instruction_name = "VK_KHR_shader_relaxed_extended_instruction";
// Extension: VK_KHR_shader_relaxed_extended_instruction
// Number: 559
// Type: device
// Author: KHR
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_SHADER_RELAXED_EXTENDED_INSTRUCTION_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_SHADER_RELAXED_EXTENDED_INSTRUCTION_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_shader_relaxed_extended_instruction&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_RELAXED_EXTENDED_INSTRUCTION_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR
//         Feature:
//             Name: shaderRelaxedExtendedInstruction
//             Struct: VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR
pub const VK_NV_command_buffer_inheritance_name = "VK_NV_command_buffer_inheritance";
// Extension: VK_NV_command_buffer_inheritance
// Number: 560
// Type: device
// Author: NV
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NV_COMMAND_BUFFER_INHERITANCE_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_NV_COMMAND_BUFFER_INHERITANCE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_command_buffer_inheritance&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMMAND_BUFFER_INHERITANCE_FEATURES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceCommandBufferInheritanceFeaturesNV
//         Feature:
//             Name: commandBufferInheritance
//             Struct: VkPhysicalDeviceCommandBufferInheritanceFeaturesNV
pub const VK_EXT_extension_561_name = "VK_EXT_extension_561";
// Extension: VK_EXT_extension_561
// Number: 561
// Type: invalid
// Author: EXT
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_561_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_561_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_561&quot;
pub const VK_KHR_extension_562_name = "VK_KHR_extension_562";
// Extension: VK_KHR_extension_562
// Number: 562
// Type: invalid
// Author: KHR
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_KHR_EXTENSION_562_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_KHR_EXTENSION_562_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_extension_562&quot;
pub const VK_KHR_maintenance7_name = "VK_KHR_maintenance7";
// Extension: VK_KHR_maintenance7
// Number: 563
// Type: device
// Author: KHR
// Depends: VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_MAINTENANCE_7_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_MAINTENANCE_7_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_maintenance7&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_7_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_7_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_PROPERTIES_LIST_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_VULKAN_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 4
//         Enum:
//             Name: VK_SUBPASS_CONTENTS_INLINE_AND_SECONDARY_COMMAND_BUFFERS_KHR
//             Negative: false
//             Extends: VkSubpassContents
//             Extnumber: 452
//             Offset: 0
//         Enum:
//             Name: VK_RENDERING_CONTENTS_INLINE_BIT_KHR
//             Negative: false
//             Bitpos: 4
//             Extends: VkRenderingFlagBits
//             Comment:
//                 Promoted from extension 452
//         Type:
//             Name: VkPhysicalDeviceMaintenance7FeaturesKHR
//         Type:
//             Name: VkPhysicalDeviceMaintenance7PropertiesKHR
//         Type:
//             Name: VkPhysicalDeviceLayeredApiPropertiesListKHR
//         Type:
//             Name: VkPhysicalDeviceLayeredApiPropertiesKHR
//         Type:
//             Name: VkPhysicalDeviceLayeredApiKHR
//         Type:
//             Name: VkPhysicalDeviceLayeredApiVulkanPropertiesKHR
//         Feature:
//             Name: maintenance7
//             Struct: VkPhysicalDeviceMaintenance7FeaturesKHR
pub const VK_NV_shader_atomic_float16_vector_name = "VK_NV_shader_atomic_float16_vector";
// Extension: VK_NV_shader_atomic_float16_vector
// Number: 564
// Type: device
// Author: NV
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NV_SHADER_ATOMIC_FLOAT16_VECTOR_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_NV_SHADER_ATOMIC_FLOAT16_VECTOR_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_shader_atomic_float16_vector&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT16_VECTOR_FEATURES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV
//         Feature:
//             Name: shaderFloat16VectorAtomics
//             Struct: VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV
pub const VK_EXT_shader_replicated_composites_name = "VK_EXT_shader_replicated_composites";
// Extension: VK_EXT_shader_replicated_composites
// Number: 565
// Type: device
// Author: EXT
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_SHADER_REPLICATED_COMPOSITES_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_SHADER_REPLICATED_COMPOSITES_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_shader_replicated_composites&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_REPLICATED_COMPOSITES_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT
//         Feature:
//             Name: shaderReplicatedComposites
//             Struct: VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT
pub const VK_ARM_extension_566_name = "VK_ARM_extension_566";
// Extension: VK_ARM_extension_566
// Number: 566
// Type: invalid
// Author: ARM
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_ARM_EXTENSION_566_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_ARM_EXTENSION_566_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_ARM_extension_566&quot;
pub const VK_ARM_extension_567_name = "VK_ARM_extension_567";
// Extension: VK_ARM_extension_567
// Number: 567
// Type: invalid
// Author: ARM
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_ARM_EXTENSION_567_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_ARM_EXTENSION_567_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_ARM_extension_567&quot;
pub const VK_EXT_shader_float8_name = "VK_EXT_shader_float8";
// Extension: VK_EXT_shader_float8
// Number: 568
// Type: device
// Author: EXT
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_SHADER_FLOAT8_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_SHADER_FLOAT8_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_shader_float8&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT8_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceShaderFloat8FeaturesEXT
//         Feature:
//             Name: shaderFloat8
//             Struct: VkPhysicalDeviceShaderFloat8FeaturesEXT
//     Depends: VK_KHR_cooperative_matrix
//         Enum:
//             Name: VK_COMPONENT_TYPE_FLOAT8_E4M3_EXT
//             Negative: false
//             Extends: VkComponentTypeKHR
//             Extnumber: 492
//             Offset: 2
//         Enum:
//             Name: VK_COMPONENT_TYPE_FLOAT8_E5M2_EXT
//             Negative: false
//             Extends: VkComponentTypeKHR
//             Extnumber: 492
//             Offset: 3
pub const VK_NV_ray_tracing_validation_name = "VK_NV_ray_tracing_validation";
// Extension: VK_NV_ray_tracing_validation
// Number: 569
// Type: device
// Author: NV
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NV_RAY_TRACING_VALIDATION_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_NV_RAY_TRACING_VALIDATION_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_ray_tracing_validation&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_VALIDATION_FEATURES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceRayTracingValidationFeaturesNV
//         Feature:
//             Name: rayTracingValidation
//             Struct: VkPhysicalDeviceRayTracingValidationFeaturesNV
pub const VK_NV_cluster_acceleration_structure_name = "VK_NV_cluster_acceleration_structure";
// Extension: VK_NV_cluster_acceleration_structure
// Number: 570
// Type: device
// Author: NV
// Depends: VK_KHR_acceleration_structure
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NV_CLUSTER_ACCELERATION_STRUCTURE_SPEC_VERSION
//             Negative: false
//             Value: 4
//         Enum:
//             Name: VK_NV_CLUSTER_ACCELERATION_STRUCTURE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_cluster_acceleration_structure&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_ACCELERATION_STRUCTURE_FEATURES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_ACCELERATION_STRUCTURE_PROPERTIES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_CLUSTERS_BOTTOM_LEVEL_INPUT_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_TRIANGLE_CLUSTER_INPUT_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Enum:
//             Name: VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_MOVE_OBJECTS_INPUT_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 4
//         Enum:
//             Name: VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_INPUT_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 5
//         Enum:
//             Name: VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_COMMANDS_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 6
//         Enum:
//             Name: VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CLUSTER_ACCELERATION_STRUCTURE_CREATE_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 7
//         Enum:
//             Name: VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_CLUSTER_OPACITY_MICROMAPS_BIT_NV
//             Negative: false
//             Bitpos: 12
//             Extends: VkBuildAccelerationStructureFlagBitsKHR
//         Type:
//             Name: VkPhysicalDeviceClusterAccelerationStructureFeaturesNV
//         Type:
//             Name: VkPhysicalDeviceClusterAccelerationStructurePropertiesNV
//         Type:
//             Name: VkClusterAccelerationStructureClustersBottomLevelInputNV
//         Type:
//             Name: VkClusterAccelerationStructureTriangleClusterInputNV
//         Type:
//             Name: VkClusterAccelerationStructureMoveObjectsInputNV
//         Type:
//             Name: VkClusterAccelerationStructureOpInputNV
//         Type:
//             Name: VkClusterAccelerationStructureInputInfoNV
//         Type:
//             Name: VkClusterAccelerationStructureCommandsInfoNV
//         Type:
//             Name: VkStridedDeviceAddressNV
//         Type:
//             Name: VkClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV
//         Type:
//             Name: VkClusterAccelerationStructureClusterFlagsNV
//         Type:
//             Name: VkClusterAccelerationStructureClusterFlagBitsNV
//         Type:
//             Name: VkClusterAccelerationStructureGeometryFlagsNV
//         Type:
//             Name: VkClusterAccelerationStructureGeometryFlagBitsNV
//         Type:
//             Name: VkClusterAccelerationStructureAddressResolutionFlagsNV
//         Type:
//             Name: VkClusterAccelerationStructureAddressResolutionFlagBitsNV
//         Type:
//             Name: VkClusterAccelerationStructureMoveObjectsInfoNV
//         Type:
//             Name: VkClusterAccelerationStructureBuildClustersBottomLevelInfoNV
//         Type:
//             Name: VkClusterAccelerationStructureBuildTriangleClusterInfoNV
//         Type:
//             Name: VkClusterAccelerationStructureBuildTriangleClusterTemplateInfoNV
//         Type:
//             Name: VkClusterAccelerationStructureInstantiateClusterInfoNV
//         Type:
//             Name: VkClusterAccelerationStructureIndexFormatFlagBitsNV
//         Type:
//             Name: VkClusterAccelerationStructureIndexFormatFlagsNV
//         Type:
//             Name: VkClusterAccelerationStructureTypeNV
//         Type:
//             Name: VkClusterAccelerationStructureOpTypeNV
//         Type:
//             Name: VkClusterAccelerationStructureOpModeNV
//         Type:
//             Name: VkClusterAccelerationStructureGetTemplateIndicesInfoNV
//         Command:
//             Name: vkGetClusterAccelerationStructureBuildSizesNV
//         Command:
//             Name: vkCmdBuildClusterAccelerationStructureIndirectNV
//         Feature:
//             Name: clusterAccelerationStructure
//             Struct: VkPhysicalDeviceClusterAccelerationStructureFeaturesNV
//     Depends: VK_EXT_opacity_micromap
//         Enum:
//             Name: VK_OPACITY_MICROMAP_SPECIAL_INDEX_CLUSTER_GEOMETRY_DISABLE_OPACITY_MICROMAP_NV
//             Negative: false
//             Value: -5
//             Extends: VkOpacityMicromapSpecialIndexEXT
//     Depends: VK_KHR_ray_tracing_pipeline
//         Type:
//             Name: VkRayTracingPipelineClusterAccelerationStructureCreateInfoNV
pub const VK_NV_partitioned_acceleration_structure_name = "VK_NV_partitioned_acceleration_structure";
// Extension: VK_NV_partitioned_acceleration_structure
// Number: 571
// Type: device
// Author: NV
// Depends: VK_KHR_acceleration_structure
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NV_PARTITIONED_ACCELERATION_STRUCTURE_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_NV_PARTITIONED_ACCELERATION_STRUCTURE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_partitioned_acceleration_structure&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PARTITIONED_ACCELERATION_STRUCTURE_FEATURES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PARTITIONED_ACCELERATION_STRUCTURE_PROPERTIES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_PARTITIONED_ACCELERATION_STRUCTURE_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCES_INPUT_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Enum:
//             Name: VK_STRUCTURE_TYPE_BUILD_PARTITIONED_ACCELERATION_STRUCTURE_INFO_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 4
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PARTITIONED_ACCELERATION_STRUCTURE_FLAGS_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 5
//         Enum:
//             Name: VK_DESCRIPTOR_TYPE_PARTITIONED_ACCELERATION_STRUCTURE_NV
//             Negative: false
//             Extends: VkDescriptorType
//             Offset: 0
//         Enum:
//             Name: VK_PARTITIONED_ACCELERATION_STRUCTURE_PARTITION_INDEX_GLOBAL_NV
//             Negative: false
//         Type:
//             Name: VkPhysicalDevicePartitionedAccelerationStructureFeaturesNV
//         Type:
//             Name: VkPhysicalDevicePartitionedAccelerationStructurePropertiesNV
//         Type:
//             Name: VkPartitionedAccelerationStructureFlagsNV
//         Type:
//             Name: VkPartitionedAccelerationStructureOpTypeNV
//         Type:
//             Name: VkBuildPartitionedAccelerationStructureIndirectCommandNV
//         Type:
//             Name: VkPartitionedAccelerationStructureInstanceFlagsNV
//         Type:
//             Name: VkPartitionedAccelerationStructureInstanceFlagBitsNV
//         Type:
//             Name: VkPartitionedAccelerationStructureWriteInstanceDataNV
//         Type:
//             Name: VkPartitionedAccelerationStructureUpdateInstanceDataNV
//         Type:
//             Name: VkPartitionedAccelerationStructureWritePartitionTranslationDataNV
//         Type:
//             Name: VkWriteDescriptorSetPartitionedAccelerationStructureNV
//         Type:
//             Name: VkPartitionedAccelerationStructureInstancesInputNV
//         Type:
//             Name: VkBuildPartitionedAccelerationStructureInfoNV
//         Command:
//             Name: vkGetPartitionedAccelerationStructuresBuildSizesNV
//         Command:
//             Name: vkCmdBuildPartitionedAccelerationStructuresNV
//         Feature:
//             Name: partitionedAccelerationStructure
//             Struct: VkPhysicalDevicePartitionedAccelerationStructureFeaturesNV
pub const VK_NV_extension_572_name = "VK_NV_extension_572";
// Extension: VK_NV_extension_572
// Number: 572
// Type: invalid
// Author: NV
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_NV_EXTENSION_572_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_NV_EXTENSION_572_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_extension_572&quot;
pub const VK_EXT_device_generated_commands_name = "VK_EXT_device_generated_commands";
// Extension: VK_EXT_device_generated_commands
// Number: 573
// Type: device
// Author: EXT
// Depends: ((VK_KHR_buffer_device_address,VK_VERSION_1_2)+VK_KHR_maintenance5),VK_VERSION_1_3
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_DEVICE_GENERATED_COMMANDS_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_DEVICE_GENERATED_COMMANDS_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_device_generated_commands&quot;
//         Enum:
//             Name: VK_SHADER_CREATE_INDIRECT_BINDABLE_BIT_EXT
//             Negative: false
//             Bitpos: 7
//             Extends: VkShaderCreateFlagBitsEXT
//         Enum:
//             Name: VK_BUFFER_USAGE_2_PREPROCESS_BUFFER_BIT_EXT
//             Negative: false
//             Bitpos: 31
//             Extends: VkBufferUsageFlagBits2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Enum:
//             Name: VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 4
//         Enum:
//             Name: VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 6
//         Enum:
//             Name: VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 7
//         Enum:
//             Name: VK_STRUCTURE_TYPE_WRITE_INDIRECT_EXECUTION_SET_PIPELINE_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 8
//         Enum:
//             Name: VK_STRUCTURE_TYPE_WRITE_INDIRECT_EXECUTION_SET_SHADER_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 9
//         Enum:
//             Name: VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_PIPELINE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 10
//         Enum:
//             Name: VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_SHADER_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 11
//         Enum:
//             Name: VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_SHADER_LAYOUT_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 12
//         Enum:
//             Name: VK_STRUCTURE_TYPE_GENERATED_COMMANDS_PIPELINE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 13
//         Enum:
//             Name: VK_STRUCTURE_TYPE_GENERATED_COMMANDS_SHADER_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 14
//         Enum:
//             Name: VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_EXT
//             Negative: false
//             Extends: VkObjectType
//             Offset: 0
//         Enum:
//             Name: VK_OBJECT_TYPE_INDIRECT_EXECUTION_SET_EXT
//             Negative: false
//             Extends: VkObjectType
//             Offset: 1
//         Enum:
//             Name: VK_PIPELINE_CREATE_2_INDIRECT_BINDABLE_BIT_EXT
//             Negative: false
//             Bitpos: 38
//             Extends: VkPipelineCreateFlagBits2
//         Enum:
//             Name: VK_PIPELINE_STAGE_COMMAND_PREPROCESS_BIT_EXT
//             Negative: false
//             Bitpos: 17
//             Extends: VkPipelineStageFlagBits
//         Enum:
//             Name: VK_ACCESS_COMMAND_PREPROCESS_READ_BIT_EXT
//             Negative: false
//             Bitpos: 17
//             Extends: VkAccessFlagBits
//         Enum:
//             Name: VK_ACCESS_COMMAND_PREPROCESS_WRITE_BIT_EXT
//             Negative: false
//             Bitpos: 18
//             Extends: VkAccessFlagBits
//         Type:
//             Name: VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT
//         Type:
//             Name: VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT
//         Type:
//             Name: VkGeneratedCommandsMemoryRequirementsInfoEXT
//         Type:
//             Name: VkIndirectExecutionSetCreateInfoEXT
//         Type:
//             Name: VkIndirectExecutionSetInfoEXT
//         Type:
//             Name: VkIndirectExecutionSetPipelineInfoEXT
//         Type:
//             Name: VkIndirectExecutionSetShaderInfoEXT
//         Type:
//             Name: VkGeneratedCommandsInfoEXT
//         Type:
//             Name: VkWriteIndirectExecutionSetPipelineEXT
//         Type:
//             Name: VkIndirectCommandsLayoutCreateInfoEXT
//         Type:
//             Name: VkIndirectCommandsLayoutTokenEXT
//         Type:
//             Name: VkDrawIndirectCountIndirectCommandEXT
//         Type:
//             Name: VkIndirectCommandsVertexBufferTokenEXT
//         Type:
//             Name: VkBindVertexBufferIndirectCommandEXT
//         Type:
//             Name: VkIndirectCommandsIndexBufferTokenEXT
//         Type:
//             Name: VkBindIndexBufferIndirectCommandEXT
//         Type:
//             Name: VkIndirectCommandsPushConstantTokenEXT
//         Type:
//             Name: VkIndirectCommandsExecutionSetTokenEXT
//         Type:
//             Name: VkIndirectCommandsTokenDataEXT
//         Type:
//             Name: VkIndirectCommandsLayoutEXT
//         Type:
//             Name: VkIndirectExecutionSetEXT
//         Type:
//             Name: VkIndirectCommandsTokenTypeEXT
//         Type:
//             Name: VkIndirectExecutionSetInfoTypeEXT
//         Type:
//             Name: VkIndirectCommandsLayoutUsageFlagsEXT
//         Type:
//             Name: VkIndirectCommandsLayoutUsageFlagBitsEXT
//         Type:
//             Name: VkIndirectCommandsInputModeFlagsEXT
//         Type:
//             Name: VkIndirectCommandsInputModeFlagBitsEXT
//         Type:
//             Name: VkIndirectExecutionSetShaderLayoutInfoEXT
//         Type:
//             Name: VkGeneratedCommandsPipelineInfoEXT
//         Type:
//             Name: VkGeneratedCommandsShaderInfoEXT
//         Command:
//             Name: vkGetGeneratedCommandsMemoryRequirementsEXT
//         Command:
//             Name: vkCmdPreprocessGeneratedCommandsEXT
//         Command:
//             Name: vkCmdExecuteGeneratedCommandsEXT
//         Command:
//             Name: vkCreateIndirectCommandsLayoutEXT
//         Command:
//             Name: vkDestroyIndirectCommandsLayoutEXT
//         Command:
//             Name: vkCreateIndirectExecutionSetEXT
//         Command:
//             Name: vkDestroyIndirectExecutionSetEXT
//         Command:
//             Name: vkUpdateIndirectExecutionSetPipelineEXT
//         Command:
//             Name: vkUpdateIndirectExecutionSetShaderEXT
//         Feature:
//             Name: deviceGeneratedCommands
//             Struct: VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT
//     Depends: VK_EXT_shader_object
//         Type:
//             Name: VkWriteIndirectExecutionSetShaderEXT
pub const VK_KHR_extension_574_name = "VK_KHR_extension_574";
// Extension: VK_KHR_extension_574
// Number: 574
// Type: invalid
// Author: KHR
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_KHR_EXTENSION_574_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_KHR_EXTENSION_574_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_extension_574&quot;
pub const VK_KHR_maintenance8_name = "VK_KHR_maintenance8";
// Extension: VK_KHR_maintenance8
// Number: 575
// Type: device
// Author: KHR
// Depends: VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_MAINTENANCE_8_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_MAINTENANCE_8_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_maintenance8&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_8_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_PIPELINE_CACHE_CREATE_INTERNALLY_SYNCHRONIZED_MERGE_BIT_KHR
//             Negative: false
//             Bitpos: 3
//             Extends: VkPipelineCacheCreateFlagBits
//         Enum:
//             Name: VK_STRUCTURE_TYPE_MEMORY_BARRIER_ACCESS_FLAGS_3_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_DEPENDENCY_QUEUE_FAMILY_OWNERSHIP_TRANSFER_USE_ALL_STAGES_BIT_KHR
//             Negative: false
//             Bitpos: 5
//             Extends: VkDependencyFlagBits
//         Type:
//             Name: VkMemoryBarrierAccessFlags3KHR
//         Type:
//             Name: VkAccessFlagBits3KHR
//         Type:
//             Name: VkAccessFlags3KHR
//         Type:
//             Name: VkPipelineCacheCreateFlagBits
//         Type:
//             Name: VkPhysicalDeviceMaintenance8FeaturesKHR
//         Feature:
//             Name: maintenance8
//             Struct: VkPhysicalDeviceMaintenance8FeaturesKHR
pub const VK_MESA_image_alignment_control_name = "VK_MESA_image_alignment_control";
// Extension: VK_MESA_image_alignment_control
// Number: 576
// Type: device
// Author: MESA
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_MESA_IMAGE_ALIGNMENT_CONTROL_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_MESA_IMAGE_ALIGNMENT_CONTROL_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_MESA_image_alignment_control&quot;
//         Type:
//             Name: VkPhysicalDeviceImageAlignmentControlFeaturesMESA
//         Type:
//             Name: VkPhysicalDeviceImageAlignmentControlPropertiesMESA
//         Type:
//             Name: VkImageAlignmentControlCreateInfoMESA
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_FEATURES_MESA
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_PROPERTIES_MESA
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMAGE_ALIGNMENT_CONTROL_CREATE_INFO_MESA
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Feature:
//             Name: imageAlignmentControl
//             Struct: VkPhysicalDeviceImageAlignmentControlFeaturesMESA
pub const VK_HUAWEI_extension_577_name = "VK_HUAWEI_extension_577";
// Extension: VK_HUAWEI_extension_577
// Number: 577
// Type: invalid
// Author: HUAWEI
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_HUAWEI_EXTENSION_577_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_HUAWEI_EXTENSION_577_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_HUAWEI_extension_577&quot;
//         Enum:
//             Name: VK_PIPELINE_CREATE_2_RESERVED_35_BIT_KHR
//             Negative: false
//             Bitpos: 35
//             Extends: VkPipelineCreateFlagBits2
pub const VK_EXT_extension_578_name = "VK_EXT_extension_578";
// Extension: VK_EXT_extension_578
// Number: 578
// Type: invalid
// Author: EXT
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_578_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_578_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_578&quot;
pub const VK_EXT_extension_579_name = "VK_EXT_extension_579";
// Extension: VK_EXT_extension_579
// Number: 579
// Type: invalid
// Author: EXT
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_579_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_579_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_579&quot;
//         Enum:
//             Name: VK_SHADER_CREATE_RESERVED_8_BIT_EXT
//             Negative: false
//             Bitpos: 8
//             Extends: VkShaderCreateFlagBitsEXT
//         Enum:
//             Name: VK_SHADER_CREATE_RESERVED_9_BIT_EXT
//             Negative: false
//             Bitpos: 9
//             Extends: VkShaderCreateFlagBitsEXT
pub const VK_KHR_shader_fma_name = "VK_KHR_shader_fma";
// Extension: VK_KHR_shader_fma
// Number: 580
// Type: device
// Author: KHR
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_SHADER_FMA_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_SHADER_FMA_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_shader_fma&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FMA_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceShaderFmaFeaturesKHR
//         Feature:
//             Name: shaderFmaFloat32
//             Struct: VkPhysicalDeviceShaderFmaFeaturesKHR
pub const VK_NV_extension_581_name = "VK_NV_extension_581";
// Extension: VK_NV_extension_581
// Number: 581
// Type: invalid
// Author: NV
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_NV_EXTENSION_581_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_NV_EXTENSION_581_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_extension_581&quot;
pub const VK_EXT_ray_tracing_invocation_reorder_name = "VK_EXT_ray_tracing_invocation_reorder";
// Extension: VK_EXT_ray_tracing_invocation_reorder
// Number: 582
// Type: device
// Author: EXT
// Depends: VK_KHR_ray_tracing_pipeline
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_RAY_TRACING_INVOCATION_REORDER_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_RAY_TRACING_INVOCATION_REORDER_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_ray_tracing_invocation_reorder&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_PROPERTIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Type:
//             Name: VkRayTracingInvocationReorderModeEXT
//         Type:
//             Name: VkPhysicalDeviceRayTracingInvocationReorderPropertiesEXT
//         Type:
//             Name: VkPhysicalDeviceRayTracingInvocationReorderFeaturesEXT
//         Feature:
//             Name: rayTracingInvocationReorder
//             Struct: VkPhysicalDeviceRayTracingInvocationReorderFeaturesEXT
pub const VK_EXT_depth_clamp_control_name = "VK_EXT_depth_clamp_control";
// Extension: VK_EXT_depth_clamp_control
// Number: 583
// Type: device
// Author: EXT
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Comment:
//     codespell:ignore blok
// Unlocks:
//         Enum:
//             Name: VK_EXT_DEPTH_CLAMP_CONTROL_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_DEPTH_CLAMP_CONTROL_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_depth_clamp_control&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_CONTROL_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLAMP_CONTROL_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_DYNAMIC_STATE_DEPTH_CLAMP_RANGE_EXT
//             Negative: false
//             Extends: VkDynamicState
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceDepthClampControlFeaturesEXT
//         Type:
//             Name: VkPipelineViewportDepthClampControlCreateInfoEXT
//         Type:
//             Name: VkDepthClampModeEXT
//         Type:
//             Name: VkDepthClampRangeEXT
//         Command:
//             Name: vkCmdSetDepthClampRangeEXT
//         Feature:
//             Name: depthClampControl
//             Struct: VkPhysicalDeviceDepthClampControlFeaturesEXT
pub const VK_EXT_extension_584_name = "VK_EXT_extension_584";
// Extension: VK_EXT_extension_584
// Number: 584
// Type: invalid
// Author: EXT
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_584_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_584_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_584&quot;
pub const VK_KHR_maintenance9_name = "VK_KHR_maintenance9";
// Extension: VK_KHR_maintenance9
// Number: 585
// Type: device
// Author: KHR
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_MAINTENANCE_9_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_MAINTENANCE_9_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_maintenance9&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_9_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_9_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_QUEUE_FAMILY_OWNERSHIP_TRANSFER_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_DEPENDENCY_ASYMMETRIC_EVENT_BIT_KHR
//             Negative: false
//             Bitpos: 6
//             Extends: VkDependencyFlagBits
//         Enum:
//             Name: VK_QUERY_POOL_CREATE_RESET_BIT_KHR
//             Negative: false
//             Bitpos: 0
//             Extends: VkQueryPoolCreateFlagBits
//         Type:
//             Name: VkPhysicalDeviceMaintenance9FeaturesKHR
//         Type:
//             Name: VkPhysicalDeviceMaintenance9PropertiesKHR
//         Type:
//             Name: VkQueueFamilyOwnershipTransferPropertiesKHR
//         Type:
//             Name: VkDefaultVertexAttributeValueKHR
//         Feature:
//             Name: maintenance9
//             Struct: VkPhysicalDeviceMaintenance9FeaturesKHR
pub const VK_IMG_extension_586_name = "VK_IMG_extension_586";
// Extension: VK_IMG_extension_586
// Number: 586
// Type: invalid
// Author: IMG
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_IMG_EXTENSION_586_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_IMG_EXTENSION_586_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_IMG_extension_586&quot;
//         Enum:
//             Name: VK_DEPENDENCY_EXTENSION_586_BIT_IMG
//             Negative: false
//             Bitpos: 4
//             Extends: VkDependencyFlagBits
pub const VK_KHR_video_maintenance2_name = "VK_KHR_video_maintenance2";
// Extension: VK_KHR_video_maintenance2
// Number: 587
// Type: device
// Author: KHR
// Depends: VK_KHR_video_queue
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_VIDEO_MAINTENANCE_2_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_VIDEO_MAINTENANCE_2_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_video_maintenance2&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_2_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceVideoMaintenance2FeaturesKHR
//         Feature:
//             Name: videoMaintenance2
//             Struct: VkPhysicalDeviceVideoMaintenance2FeaturesKHR
//     Depends: VK_KHR_video_decode_queue
//         Enum:
//             Name: VK_VIDEO_SESSION_CREATE_INLINE_SESSION_PARAMETERS_BIT_KHR
//             Negative: false
//             Bitpos: 5
//             Extends: VkVideoSessionCreateFlagBitsKHR
//     Depends: VK_KHR_video_decode_h264
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_INLINE_SESSION_PARAMETERS_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Type:
//             Name: VkVideoDecodeH264InlineSessionParametersInfoKHR
//     Depends: VK_KHR_video_decode_h265
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_INLINE_SESSION_PARAMETERS_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Type:
//             Name: VkVideoDecodeH265InlineSessionParametersInfoKHR
//     Depends: VK_KHR_video_decode_av1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_INLINE_SESSION_PARAMETERS_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Type:
//             Name: VkVideoDecodeAV1InlineSessionParametersInfoKHR
pub const VK_OHOS_surface_name = "VK_OHOS_surface";
// Extension: VK_OHOS_surface
// Number: 588
// Type: instance
// Author: HUAWEI
// Depends: VK_KHR_surface
// Platform: ohos
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_OHOS_SURFACE_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_OHOS_SURFACE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_OHOS_surface&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SURFACE_CREATE_INFO_OHOS
//             Negative: false
//             Value: 1000685000
//             Extends: VkStructureType
//         Type:
//             Name: VkSurfaceCreateFlagsOHOS
//         Type:
//             Name: VkSurfaceCreateInfoOHOS
//         Type:
//             Name: OHNativeWindow
//         Command:
//             Name: vkCreateSurfaceOHOS
pub const VK_HUAWEI_extension_686_name = "VK_HUAWEI_extension_686";
// Extension: VK_HUAWEI_extension_686
// Number: 686
// Type: invalid
// Author: HUAWEI
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_HUAWEI_EXTENSION_686_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_HUAWEI_EXTENSION_686_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_HUAWEI_extension_686&quot;
pub const VK_OHOS_native_buffer_name = "VK_OHOS_native_buffer";
// Extension: VK_OHOS_native_buffer
// Number: 589
// Type: device
// Author: HUAWEI
// Platform: ohos
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_OHOS_NATIVE_BUFFER_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_OHOS_NATIVE_BUFFER_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_OHOS_native_buffer&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_NATIVE_BUFFER_OHOS
//             Negative: false
//             Extends: VkStructureType
//             Extnumber: 454
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SWAPCHAIN_IMAGE_CREATE_INFO_OHOS
//             Negative: false
//             Extends: VkStructureType
//             Extnumber: 454
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENTATION_PROPERTIES_OHOS
//             Negative: false
//             Extends: VkStructureType
//             Extnumber: 454
//             Offset: 3
//         Type:
//             Name: VkSwapchainImageUsageFlagBitsOHOS
//         Type:
//             Name: VkNativeBufferOHOS
//         Type:
//             Name: VkSwapchainImageCreateInfoOHOS
//         Type:
//             Name: VkPhysicalDevicePresentationPropertiesOHOS
//         Type:
//             Name: OHBufferHandle
//         Type:
//             Name: VkSwapchainImageUsageFlagsOHOS
//         Command:
//             Name: vkGetSwapchainGrallocUsageOHOS
//         Command:
//             Name: vkAcquireImageOHOS
//         Command:
//             Name: vkQueueSignalReleaseImageOHOS
pub const VK_HUAWEI_extension_590_name = "VK_HUAWEI_extension_590";
// Extension: VK_HUAWEI_extension_590
// Number: 590
// Type: invalid
// Author: HUAWEI
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_HUAWEI_EXTENSION_590_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_HUAWEI_EXTENSION_590_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_HUAWEI_extension_590&quot;
pub const VK_HUAWEI_hdr_vivid_name = "VK_HUAWEI_hdr_vivid";
// Extension: VK_HUAWEI_hdr_vivid
// Number: 591
// Type: device
// Author: HUAWEI
// Depends: (VK_KHR_get_physical_device_properties2,VK_VERSION_1_1)+VK_KHR_swapchain+VK_EXT_hdr_metadata
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_HUAWEI_HDR_VIVID_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_HUAWEI_HDR_VIVID_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_HUAWEI_hdr_vivid&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HDR_VIVID_FEATURES_HUAWEI
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_HDR_VIVID_DYNAMIC_METADATA_HUAWEI
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Type:
//             Name: VkPhysicalDeviceHdrVividFeaturesHUAWEI
//         Type:
//             Name: VkHdrVividDynamicMetadataHUAWEI
//         Feature:
//             Name: hdrVivid
//             Struct: VkPhysicalDeviceHdrVividFeaturesHUAWEI
pub const VK_NV_extension_592_name = "VK_NV_extension_592";
// Extension: VK_NV_extension_592
// Number: 592
// Type: invalid
// Author: NV
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_NV_EXTENSION_592_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_NV_EXTENSION_592_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_extension_592&quot;
pub const VK_NV_extension_593_name = "VK_NV_extension_593";
// Extension: VK_NV_extension_593
// Number: 593
// Type: invalid
// Author: NV
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_NV_EXTENSION_593_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_NV_EXTENSION_593_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_extension_593&quot;
pub const VK_NV_cooperative_matrix2_name = "VK_NV_cooperative_matrix2";
// Extension: VK_NV_cooperative_matrix2
// Number: 594
// Type: device
// Author: NV
// Depends: VK_KHR_cooperative_matrix
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NV_COOPERATIVE_MATRIX_2_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_NV_COOPERATIVE_MATRIX_2_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_cooperative_matrix2&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_2_FEATURES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_FLEXIBLE_DIMENSIONS_PROPERTIES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_2_PROPERTIES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Type:
//             Name: VkCooperativeMatrixFlexibleDimensionsPropertiesNV
//         Type:
//             Name: VkPhysicalDeviceCooperativeMatrix2FeaturesNV
//         Type:
//             Name: VkPhysicalDeviceCooperativeMatrix2PropertiesNV
//         Command:
//             Name: vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV
//         Feature:
//             Name: cooperativeMatrixWorkgroupScope,cooperativeMatrixFlexibleDimensions,cooperativeMatrixReductions,cooperativeMatrixConversions,cooperativeMatrixPerElementOperations,cooperativeMatrixTensorAddressing,cooperativeMatrixBlockLoads
//             Struct: VkPhysicalDeviceCooperativeMatrix2FeaturesNV
pub const VK_NV_extension_595_name = "VK_NV_extension_595";
// Extension: VK_NV_extension_595
// Number: 595
// Type: invalid
// Author: NV
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_NV_EXTENSION_595_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_NV_EXTENSION_595_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_extension_595&quot;
//         Enum:
//             Name: VK_SHADER_STAGE_RESERVED_15_BIT_NV
//             Negative: false
//             Bitpos: 15
//             Extends: VkShaderStageFlagBits
pub const VK_KHR_extension_596_name = "VK_KHR_extension_596";
// Extension: VK_KHR_extension_596
// Number: 596
// Type: invalid
// Author: KHR
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_KHR_EXTENSION_596_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_KHR_EXTENSION_596_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_extension_596&quot;
pub const VK_ARM_pipeline_opacity_micromap_name = "VK_ARM_pipeline_opacity_micromap";
// Extension: VK_ARM_pipeline_opacity_micromap
// Number: 597
// Type: device
// Author: ARM
// Depends: VK_EXT_opacity_micromap
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_ARM_PIPELINE_OPACITY_MICROMAP_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_ARM_PIPELINE_OPACITY_MICROMAP_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_ARM_pipeline_opacity_micromap&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_OPACITY_MICROMAP_FEATURES_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDevicePipelineOpacityMicromapFeaturesARM
//         Feature:
//             Name: pipelineOpacityMicromap
//             Struct: VkPhysicalDevicePipelineOpacityMicromapFeaturesARM
//         Enum:
//             Name: VK_PIPELINE_CREATE_2_DISALLOW_OPACITY_MICROMAP_BIT_ARM
//             Negative: false
//             Bitpos: 37
//             Extends: VkPipelineCreateFlagBits2
pub const VK_KHR_extension_598_name = "VK_KHR_extension_598";
// Extension: VK_KHR_extension_598
// Number: 598
// Type: device
// Author: KHR
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_KHR_EXTENSION_598_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_KHR_EXTENSION_598_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_extension_598&quot;
pub const VK_KHR_extension_599_name = "VK_KHR_extension_599";
// Extension: VK_KHR_extension_599
// Number: 599
// Type: device
// Author: KHR
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_KHR_EXTENSION_599_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_KHR_EXTENSION_599_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_extension_599&quot;
//         Enum:
//             Name: VK_VIDEO_ENCODE_FEEDBACK_RESERVED_3_BIT_KHR
//             Negative: false
//             Bitpos: 3
//             Extends: VkVideoEncodeFeedbackFlagBitsKHR
//         Enum:
//             Name: VK_VIDEO_ENCODE_FEEDBACK_RESERVED_4_BIT_KHR
//             Negative: false
//             Bitpos: 4
//             Extends: VkVideoEncodeFeedbackFlagBitsKHR
//         Enum:
//             Name: VK_VIDEO_ENCODE_FEEDBACK_RESERVED_5_BIT_KHR
//             Negative: false
//             Bitpos: 5
//             Extends: VkVideoEncodeFeedbackFlagBitsKHR
//         Enum:
//             Name: VK_VIDEO_ENCODE_FEEDBACK_RESERVED_6_BIT_KHR
//             Negative: false
//             Bitpos: 6
//             Extends: VkVideoEncodeFeedbackFlagBitsKHR
//         Enum:
//             Name: VK_VIDEO_ENCODE_FEEDBACK_RESERVED_7_BIT_KHR
//             Negative: false
//             Bitpos: 7
//             Extends: VkVideoEncodeFeedbackFlagBitsKHR
//         Enum:
//             Name: VK_VIDEO_ENCODE_FEEDBACK_RESERVED_8_BIT_KHR
//             Negative: false
//             Bitpos: 8
//             Extends: VkVideoEncodeFeedbackFlagBitsKHR
//         Enum:
//             Name: VK_VIDEO_ENCODE_FEEDBACK_RESERVED_9_BIT_KHR
//             Negative: false
//             Bitpos: 9
//             Extends: VkVideoEncodeFeedbackFlagBitsKHR
pub const VK_IMG_extension_600_name = "VK_IMG_extension_600";
// Extension: VK_IMG_extension_600
// Number: 600
// Type: invalid
// Author: IMG
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_IMG_EXTENSION_600_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_IMG_EXTENSION_600_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_IMG_extension_600&quot;
pub const VK_IMG_extension_601_name = "VK_IMG_extension_601";
// Extension: VK_IMG_extension_601
// Number: 601
// Type: invalid
// Author: IMG
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_IMG_EXTENSION_601_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_IMG_EXTENSION_601_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_IMG_extension_601&quot;
pub const VK_EXT_extension_602_name = "VK_EXT_extension_602";
// Extension: VK_EXT_extension_602
// Number: 602
// Type: invalid
// Author: KHR
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_602_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_602_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_602&quot;
pub const VK_EXT_external_memory_metal_name = "VK_EXT_external_memory_metal";
// Extension: VK_EXT_external_memory_metal
// Number: 603
// Type: device
// Author: EXT
// Depends: VK_KHR_external_memory,VK_VERSION_1_1
// Platform: metal
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTERNAL_MEMORY_METAL_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_EXTERNAL_MEMORY_METAL_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_external_memory_metal&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_IMPORT_MEMORY_METAL_HANDLE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_MEMORY_METAL_HANDLE_PROPERTIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_MEMORY_GET_METAL_HANDLE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLBUFFER_BIT_EXT
//             Negative: false
//             Bitpos: 16
//             Extends: VkExternalMemoryHandleTypeFlagBits
//         Enum:
//             Name: VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLTEXTURE_BIT_EXT
//             Negative: false
//             Bitpos: 17
//             Extends: VkExternalMemoryHandleTypeFlagBits
//         Enum:
//             Name: VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLHEAP_BIT_EXT
//             Negative: false
//             Bitpos: 18
//             Extends: VkExternalMemoryHandleTypeFlagBits
//         Type:
//             Name: VkImportMemoryMetalHandleInfoEXT
//         Type:
//             Name: VkMemoryMetalHandlePropertiesEXT
//         Type:
//             Name: VkMemoryGetMetalHandleInfoEXT
//         Command:
//             Name: vkGetMemoryMetalHandleEXT
//         Command:
//             Name: vkGetMemoryMetalHandlePropertiesEXT
pub const VK_EXT_extension_604_name = "VK_EXT_extension_604";
// Extension: VK_EXT_extension_604
// Number: 604
// Type: invalid
// Author: EXT
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_604_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_604_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_604&quot;
//         Enum:
//             Name: VK_WAYLAND_SURFACE_CREATE_DISABLE_COLOR_MANAGEMENT
//             Negative: false
//             Bitpos: 0
//             Extends: VkWaylandSurfaceCreateFlagBitsKHR
pub const VK_KHR_depth_clamp_zero_one_name = "VK_KHR_depth_clamp_zero_one";
// Extension: VK_KHR_depth_clamp_zero_one
// Number: 605
// Type: device
// Author: KHR
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_DEPTH_CLAMP_ZERO_ONE_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_DEPTH_CLAMP_ZERO_ONE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_depth_clamp_zero_one&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Extnumber: 422
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceDepthClampZeroOneFeaturesKHR
//         Feature:
//             Name: depthClampZeroOne
//             Struct: VkPhysicalDeviceDepthClampZeroOneFeaturesKHR
pub const VK_ARM_performance_counters_by_region_name = "VK_ARM_performance_counters_by_region";
// Extension: VK_ARM_performance_counters_by_region
// Number: 606
// Type: device
// Author: ARM
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_ARM_PERFORMANCE_COUNTERS_BY_REGION_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_ARM_PERFORMANCE_COUNTERS_BY_REGION_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_ARM_performance_counters_by_region&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_COUNTERS_BY_REGION_FEATURES_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_COUNTERS_BY_REGION_PROPERTIES_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_DESCRIPTION_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 3
//         Enum:
//             Name: VK_STRUCTURE_TYPE_RENDER_PASS_PERFORMANCE_COUNTERS_BY_REGION_BEGIN_INFO_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 4
//         Type:
//             Name: VkPhysicalDevicePerformanceCountersByRegionFeaturesARM
//         Type:
//             Name: VkPhysicalDevicePerformanceCountersByRegionPropertiesARM
//         Type:
//             Name: VkPerformanceCounterARM
//         Type:
//             Name: VkPerformanceCounterDescriptionARM
//         Type:
//             Name: VkRenderPassPerformanceCountersByRegionBeginInfoARM
//         Type:
//             Name: VkPerformanceCounterDescriptionFlagsARM
//         Command:
//             Name: vkEnumeratePhysicalDeviceQueueFamilyPerformanceCountersByRegionARM
//         Feature:
//             Name: performanceCountersByRegion
//             Struct: VkPhysicalDevicePerformanceCountersByRegionFeaturesARM
pub const VK_KHR_extension_607_name = "VK_KHR_extension_607";
// Extension: VK_KHR_extension_607
// Number: 607
// Type: invalid
// Author: ARM
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_KHR_EXTENSION_607_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_KHR_EXTENSION_607_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_extension_607&quot;
pub const VK_KHR_extension_608_name = "VK_KHR_extension_608";
// Extension: VK_KHR_extension_608
// Number: 608
// Type: invalid
// Author: ARM
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_KHR_EXTENSION_608_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_KHR_EXTENSION_608_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_extension_608&quot;
pub const VK_EXT_vertex_attribute_robustness_name = "VK_EXT_vertex_attribute_robustness";
// Extension: VK_EXT_vertex_attribute_robustness
// Number: 609
// Type: device
// Author: EXT
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Promoted to: VK_KHR_maintenance9
// Unlocks:
//         Enum:
//             Name: VK_EXT_VERTEX_ATTRIBUTE_ROBUSTNESS_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_VERTEX_ATTRIBUTE_ROBUSTNESS_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_vertex_attribute_robustness&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_ROBUSTNESS_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT
//         Feature:
//             Name: vertexAttributeRobustness
//             Struct: VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT
pub const VK_ARM_format_pack_name = "VK_ARM_format_pack";
// Extension: VK_ARM_format_pack
// Number: 610
// Type: device
// Author: ARM
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_ARM_FORMAT_PACK_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_ARM_FORMAT_PACK_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_ARM_format_pack&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FORMAT_PACK_FEATURES_ARM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceFormatPackFeaturesARM
//         Feature:
//             Name: formatPack
//             Struct: VkPhysicalDeviceFormatPackFeaturesARM
//         Enum:
//             Name: VK_FORMAT_R10X6_UINT_PACK16_ARM
//             Negative: false
//             Extends: VkFormat
//             Offset: 0
//         Enum:
//             Name: VK_FORMAT_R10X6G10X6_UINT_2PACK16_ARM
//             Negative: false
//             Extends: VkFormat
//             Offset: 1
//         Enum:
//             Name: VK_FORMAT_R10X6G10X6B10X6A10X6_UINT_4PACK16_ARM
//             Negative: false
//             Extends: VkFormat
//             Offset: 2
//         Enum:
//             Name: VK_FORMAT_R12X4_UINT_PACK16_ARM
//             Negative: false
//             Extends: VkFormat
//             Offset: 3
//         Enum:
//             Name: VK_FORMAT_R12X4G12X4_UINT_2PACK16_ARM
//             Negative: false
//             Extends: VkFormat
//             Offset: 4
//         Enum:
//             Name: VK_FORMAT_R12X4G12X4B12X4A12X4_UINT_4PACK16_ARM
//             Negative: false
//             Extends: VkFormat
//             Offset: 5
//         Enum:
//             Name: VK_FORMAT_R14X2_UINT_PACK16_ARM
//             Negative: false
//             Extends: VkFormat
//             Offset: 6
//         Enum:
//             Name: VK_FORMAT_R14X2G14X2_UINT_2PACK16_ARM
//             Negative: false
//             Extends: VkFormat
//             Offset: 7
//         Enum:
//             Name: VK_FORMAT_R14X2G14X2B14X2A14X2_UINT_4PACK16_ARM
//             Negative: false
//             Extends: VkFormat
//             Offset: 8
//         Enum:
//             Name: VK_FORMAT_R14X2_UNORM_PACK16_ARM
//             Negative: false
//             Extends: VkFormat
//             Offset: 9
//         Enum:
//             Name: VK_FORMAT_R14X2G14X2_UNORM_2PACK16_ARM
//             Negative: false
//             Extends: VkFormat
//             Offset: 10
//         Enum:
//             Name: VK_FORMAT_R14X2G14X2B14X2A14X2_UNORM_4PACK16_ARM
//             Negative: false
//             Extends: VkFormat
//             Offset: 11
//         Enum:
//             Name: VK_FORMAT_G14X2_B14X2R14X2_2PLANE_420_UNORM_3PACK16_ARM
//             Negative: false
//             Extends: VkFormat
//             Offset: 12
//         Enum:
//             Name: VK_FORMAT_G14X2_B14X2R14X2_2PLANE_422_UNORM_3PACK16_ARM
//             Negative: false
//             Extends: VkFormat
//             Offset: 13
pub const VK_NV_extension_611_name = "VK_NV_extension_611";
// Extension: VK_NV_extension_611
// Number: 611
// Type: invalid
// Author: NV
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_NV_EXTENSION_611_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_NV_EXTENSION_611_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_extension_611&quot;
pub const VK_VALVE_fragment_density_map_layered_name = "VK_VALVE_fragment_density_map_layered";
// Extension: VK_VALVE_fragment_density_map_layered
// Number: 612
// Type: device
// Author: VALVE
// Depends: (VK_KHR_maintenance5,VK_VERSION_1_4)+VK_EXT_fragment_density_map
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_VALVE_FRAGMENT_DENSITY_MAP_LAYERED_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_VALVE_FRAGMENT_DENSITY_MAP_LAYERED_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_VALVE_fragment_density_map_layered&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_LAYERED_FEATURES_VALVE
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_LAYERED_PROPERTIES_VALVE
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_DENSITY_MAP_LAYERED_CREATE_INFO_VALVE
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_RENDER_PASS_CREATE_PER_LAYER_FRAGMENT_DENSITY_BIT_VALVE
//             Negative: false
//             Bitpos: 2
//             Extends: VkRenderPassCreateFlagBits
//         Enum:
//             Name: VK_RENDERING_PER_LAYER_FRAGMENT_DENSITY_BIT_VALVE
//             Negative: false
//             Bitpos: 5
//             Extends: VkRenderingFlagBits
//         Enum:
//             Name: VK_PIPELINE_CREATE_2_PER_LAYER_FRAGMENT_DENSITY_BIT_VALVE
//             Negative: false
//             Bitpos: 40
//             Extends: VkPipelineCreateFlagBits2
//         Type:
//             Name: VkPhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE
//         Type:
//             Name: VkPhysicalDeviceFragmentDensityMapLayeredPropertiesVALVE
//         Type:
//             Name: VkPipelineFragmentDensityMapLayeredCreateInfoVALVE
//         Feature:
//             Name: fragmentDensityMapLayered
//             Struct: VkPhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE
pub const VK_KHR_robustness2_name = "VK_KHR_robustness2";
// Extension: VK_KHR_robustness2
// Number: 613
// Type: device
// Author: KHR
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_ROBUSTNESS_2_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_ROBUSTNESS_2_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_robustness2&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Extnumber: 287
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Extnumber: 287
//             Offset: 1
//         Type:
//             Name: VkPhysicalDeviceRobustness2FeaturesKHR
//         Type:
//             Name: VkPhysicalDeviceRobustness2PropertiesKHR
//         Feature:
//             Name: robustBufferAccess2,robustImageAccess2,nullDescriptor
//             Struct: VkPhysicalDeviceRobustness2FeaturesKHR
pub const VK_NV_present_metering_name = "VK_NV_present_metering";
// Extension: VK_NV_present_metering
// Number: 614
// Type: device
// Author: NV
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Platform: provisional
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NV_PRESENT_METERING_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_NV_PRESENT_METERING_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_present_metering&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_SET_PRESENT_CONFIG_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_METERING_FEATURES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Type:
//             Name: VkSetPresentConfigNV
//         Type:
//             Name: VkPhysicalDevicePresentMeteringFeaturesNV
//         Feature:
//             Name: presentMetering
//             Struct: VkPhysicalDevicePresentMeteringFeaturesNV
pub const VK_QCOM_extension_615_name = "VK_QCOM_extension_615";
// Extension: VK_QCOM_extension_615
// Number: 615
// Type: invalid
// Author: QCOM
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_QCOM_EXTENSION_615_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_QCOM_EXTENSION_615_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_QCOM_extension_615&quot;
pub const VK_EXT_extension_616_name = "VK_EXT_extension_616";
// Extension: VK_EXT_extension_616
// Number: 616
// Type: invalid
// Author: EXT
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_616_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_616_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_616&quot;
//         Enum:
//             Name: VK_INSTANCE_CREATE_RESERVED_616_BIT_EXT
//             Negative: false
//             Bitpos: 1
//             Extends: VkInstanceCreateFlagBits
pub const VK_EXT_extension_617_name = "VK_EXT_extension_617";
// Extension: VK_EXT_extension_617
// Number: 617
// Type: invalid
// Author: EXT
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_617_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_617_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_617&quot;
//         Enum:
//             Name: VK_SWAPCHAIN_CREATE_RESERVED_8_BIT_EXT
//             Negative: false
//             Bitpos: 8
//             Extends: VkSwapchainCreateFlagBitsKHR
pub const VK_EXT_extension_618_name = "VK_EXT_extension_618";
// Extension: VK_EXT_extension_618
// Number: 618
// Type: invalid
// Author: EXT
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_618_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_618_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_618&quot;
pub const VK_EXT_fragment_density_map_offset_name = "VK_EXT_fragment_density_map_offset";
// Extension: VK_EXT_fragment_density_map_offset
// Number: 620
// Type: device
// Author: EXT
// Depends: (VK_KHR_get_physical_device_properties2,VK_VERSION_1_1)+VK_EXT_fragment_density_map+(VK_KHR_create_renderpass2,VK_VERSION_1_2)+(VK_VERSION_1_3,VK_KHR_dynamic_rendering)
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_FRAGMENT_DENSITY_MAP_OFFSET_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_FRAGMENT_DENSITY_MAP_OFFSET_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_fragment_density_map_offset&quot;
//         Type:
//             Name: VkRenderingEndInfoEXT
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Extnumber: 426
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Extnumber: 426
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Extnumber: 426
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_RENDERING_END_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Alias: VK_STRUCTURE_TYPE_RENDERING_END_INFO_KHR
//         Enum:
//             Name: VK_IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_EXT
//             Negative: false
//             Bitpos: 15
//             Extends: VkImageCreateFlagBits
//         Type:
//             Name: VkPhysicalDeviceFragmentDensityMapOffsetFeaturesEXT
//         Type:
//             Name: VkPhysicalDeviceFragmentDensityMapOffsetPropertiesEXT
//         Type:
//             Name: VkRenderPassFragmentDensityMapOffsetEndInfoEXT
//         Command:
//             Name: vkCmdEndRendering2EXT
//         Feature:
//             Name: fragmentDensityMapOffset
//             Struct: VkPhysicalDeviceFragmentDensityMapOffsetFeaturesEXT
pub const VK_EXT_zero_initialize_device_memory_name = "VK_EXT_zero_initialize_device_memory";
// Extension: VK_EXT_zero_initialize_device_memory
// Number: 621
// Type: device
// Author: EXT
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_ZERO_INITIALIZE_DEVICE_MEMORY_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_ZERO_INITIALIZE_DEVICE_MEMORY_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_zero_initialize_device_memory&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_DEVICE_MEMORY_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_MEMORY_ALLOCATE_ZERO_INITIALIZE_BIT_EXT
//             Negative: false
//             Bitpos: 3
//             Extends: VkMemoryAllocateFlagBits
//         Enum:
//             Name: VK_IMAGE_LAYOUT_ZERO_INITIALIZED_EXT
//             Negative: false
//             Extends: VkImageLayout
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT
//         Feature:
//             Name: zeroInitializeDeviceMemory
//             Struct: VkPhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT
pub const VK_KHR_present_mode_fifo_latest_ready_name = "VK_KHR_present_mode_fifo_latest_ready";
// Extension: VK_KHR_present_mode_fifo_latest_ready
// Number: 622
// Type: device
// Author: KHR
// Depends: VK_KHR_swapchain
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_PRESENT_MODE_FIFO_LATEST_READY_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_PRESENT_MODE_FIFO_LATEST_READY_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_present_mode_fifo_latest_ready&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_MODE_FIFO_LATEST_READY_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Extnumber: 362
//             Offset: 0
//         Enum:
//             Name: VK_PRESENT_MODE_FIFO_LATEST_READY_KHR
//             Negative: false
//             Extends: VkPresentModeKHR
//             Extnumber: 362
//             Offset: 0
//         Type:
//             Name: VkPhysicalDevicePresentModeFifoLatestReadyFeaturesKHR
//         Feature:
//             Name: presentModeFifoLatestReady
//             Struct: VkPhysicalDevicePresentModeFifoLatestReadyFeaturesKHR
pub const VK_EXT_extension_623_name = "VK_EXT_extension_623";
// Extension: VK_EXT_extension_623
// Number: 623
// Type: invalid
// Author: EXT
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_623_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_623_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_623&quot;
pub const VK_KHR_extension_624_name = "VK_KHR_extension_624";
// Extension: VK_KHR_extension_624
// Number: 624
// Type: invalid
// Author: KHR
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_KHR_EXTENSION_624_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_KHR_EXTENSION_624_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_extension_624&quot;
//         Enum:
//             Name: VK_BUILD_ACCELERATION_STRUCTURE_RESERVED_10_BIT_KHR
//             Negative: false
//             Bitpos: 10
//             Extends: VkBuildAccelerationStructureFlagBitsKHR
//     Depends: VK_KHR_maintenance5,VK_VERSION_1_4
//         Enum:
//             Name: VK_PIPELINE_CREATE_2_RESERVED_41_BIT_KHR
//             Negative: false
//             Bitpos: 41
//             Extends: VkPipelineCreateFlagBits2
//     Depends: VK_EXT_shader_object
//         Enum:
//             Name: VK_SHADER_CREATE_RESERVED_12_BIT_EXT
//             Negative: false
//             Bitpos: 12
//             Extends: VkShaderCreateFlagBitsEXT
pub const VK_KHR_extension_625_name = "VK_KHR_extension_625";
// Extension: VK_KHR_extension_625
// Number: 625
// Type: invalid
// Author: KHR
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_KHR_EXTENSION_625_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_KHR_EXTENSION_625_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_extension_625&quot;
pub const VK_EXT_extension_626_name = "VK_EXT_extension_626";
// Extension: VK_EXT_extension_626
// Number: 626
// Type: invalid
// Author: EXT
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_626_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_626_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_626&quot;
pub const VK_NV_extension_627_name = "VK_NV_extension_627";
// Extension: VK_NV_extension_627
// Number: 627
// Type: invalid
// Author: NV
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_NV_EXTENSION_627_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_NV_EXTENSION_627_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_extension_627&quot;
pub const VK_EXT_shader_64bit_indexing_name = "VK_EXT_shader_64bit_indexing";
// Extension: VK_EXT_shader_64bit_indexing
// Number: 628
// Type: device
// Author: EXT
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_SHADER_64BIT_INDEXING_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_SHADER_64BIT_INDEXING_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_shader_64bit_indexing&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_64_BIT_INDEXING_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceShader64BitIndexingFeaturesEXT
//         Enum:
//             Name: VK_PIPELINE_CREATE_2_64_BIT_INDEXING_BIT_EXT
//             Negative: false
//             Bitpos: 43
//             Extends: VkPipelineCreateFlagBits2
//         Enum:
//             Name: VK_SHADER_CREATE_64_BIT_INDEXING_BIT_EXT
//             Negative: false
//             Bitpos: 15
//             Extends: VkShaderCreateFlagBitsEXT
//         Feature:
//             Name: shader64BitIndexing
//             Struct: VkPhysicalDeviceShader64BitIndexingFeaturesEXT
pub const VK_EXT_custom_resolve_name = "VK_EXT_custom_resolve";
// Extension: VK_EXT_custom_resolve
// Number: 629
// Type: device
// Author: EXT
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_CUSTOM_RESOLVE_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_CUSTOM_RESOLVE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_custom_resolve&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_RESOLVE_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_SUBPASS_DESCRIPTION_FRAGMENT_REGION_BIT_EXT
//             Negative: false
//             Bitpos: 2
//             Extends: VkSubpassDescriptionFlagBits
//         Enum:
//             Name: VK_SUBPASS_DESCRIPTION_CUSTOM_RESOLVE_BIT_EXT
//             Negative: false
//             Bitpos: 3
//             Extends: VkSubpassDescriptionFlagBits
//         Type:
//             Name: VkPhysicalDeviceCustomResolveFeaturesEXT
//         Feature:
//             Name: customResolve
//             Struct: VkPhysicalDeviceCustomResolveFeaturesEXT
//     Depends: VK_KHR_dynamic_rendering,VK_VERSION_1_3
//         Enum:
//             Name: VK_RENDERING_FRAGMENT_REGION_BIT_EXT
//             Negative: false
//             Bitpos: 6
//             Extends: VkRenderingFlagBits
//         Enum:
//             Name: VK_RENDERING_CUSTOM_RESOLVE_BIT_EXT
//             Negative: false
//             Bitpos: 7
//             Extends: VkRenderingFlagBits
//         Enum:
//             Name: VK_RESOLVE_MODE_CUSTOM_BIT_EXT
//             Negative: false
//             Bitpos: 5
//             Extends: VkResolveModeFlagBits
//         Enum:
//             Name: VK_STRUCTURE_TYPE_BEGIN_CUSTOM_RESOLVE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_CUSTOM_RESOLVE_CREATE_INFO_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Type:
//             Name: VkBeginCustomResolveInfoEXT
//         Type:
//             Name: VkCustomResolveCreateInfoEXT
//         Command:
//             Name: vkCmdBeginCustomResolveEXT
pub const VK_QCOM_data_graph_model_name = "VK_QCOM_data_graph_model";
// Extension: VK_QCOM_data_graph_model
// Number: 630
// Type: device
// Author: QCOM
// Depends: VK_ARM_data_graph
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_QCOM_DATA_GRAPH_MODEL_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_QCOM_DATA_GRAPH_MODEL_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_QCOM_data_graph_model&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DATA_GRAPH_MODEL_FEATURES_QCOM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_BUILTIN_MODEL_CREATE_INFO_QCOM
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_PHYSICAL_DEVICE_DATA_GRAPH_PROCESSING_ENGINE_TYPE_NEURAL_QCOM
//             Negative: false
//             Extends: VkPhysicalDeviceDataGraphProcessingEngineTypeARM
//             Offset: 0
//         Enum:
//             Name: VK_PHYSICAL_DEVICE_DATA_GRAPH_PROCESSING_ENGINE_TYPE_COMPUTE_QCOM
//             Negative: false
//             Extends: VkPhysicalDeviceDataGraphProcessingEngineTypeARM
//             Offset: 1
//         Enum:
//             Name: VK_PHYSICAL_DEVICE_DATA_GRAPH_OPERATION_TYPE_NEURAL_MODEL_QCOM
//             Negative: false
//             Extends: VkPhysicalDeviceDataGraphOperationTypeARM
//             Offset: 0
//         Enum:
//             Name: VK_PHYSICAL_DEVICE_DATA_GRAPH_OPERATION_TYPE_BUILTIN_MODEL_QCOM
//             Negative: false
//             Extends: VkPhysicalDeviceDataGraphOperationTypeARM
//             Offset: 1
//         Enum:
//             Name: VK_PIPELINE_CACHE_HEADER_VERSION_DATA_GRAPH_QCOM
//             Negative: false
//             Extends: VkPipelineCacheHeaderVersion
//             Offset: 0
//         Enum:
//             Name: VK_DATA_GRAPH_MODEL_TOOLCHAIN_VERSION_LENGTH_QCOM
//             Negative: false
//         Type:
//             Name: VkDataGraphModelCacheTypeQCOM
//         Type:
//             Name: VkPipelineCacheHeaderVersionDataGraphQCOM
//         Type:
//             Name: VkDataGraphPipelineBuiltinModelCreateInfoQCOM
//         Type:
//             Name: VkPhysicalDeviceDataGraphModelFeaturesQCOM
//         Feature:
//             Name: dataGraphModel
//             Struct: VkPhysicalDeviceDataGraphModelFeaturesQCOM
pub const VK_KHR_maintenance10_name = "VK_KHR_maintenance10";
// Extension: VK_KHR_maintenance10
// Number: 631
// Type: device
// Author: KHR
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_KHR_MAINTENANCE_10_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_KHR_MAINTENANCE_10_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_maintenance10&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_10_FEATURES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_10_PROPERTIES_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Enum:
//             Name: VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_FLAGS_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 2
//         Enum:
//             Name: VK_STRUCTURE_TYPE_RENDERING_END_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Extnumber: 620
//             Offset: 3
//         Enum:
//             Name: VK_STRUCTURE_TYPE_RESOLVE_IMAGE_MODE_INFO_KHR
//             Negative: false
//             Extends: VkStructureType
//             Offset: 4
//         Type:
//             Name: VkPhysicalDeviceMaintenance10FeaturesKHR
//         Type:
//             Name: VkPhysicalDeviceMaintenance10PropertiesKHR
//         Type:
//             Name: VkRenderingEndInfoKHR
//         Command:
//             Name: vkCmdEndRendering2KHR
//         Type:
//             Name: VkRenderingAttachmentFlagsInfoKHR
//         Type:
//             Name: VkRenderingAttachmentFlagsKHR
//         Type:
//             Name: VkRenderingAttachmentFlagBitsKHR
//         Type:
//             Name: VkResolveImageModeInfoKHR
//         Type:
//             Name: VkResolveImageFlagsKHR
//         Type:
//             Name: VkResolveImageFlagBitsKHR
//         Feature:
//             Name: maintenance10
//             Struct: VkPhysicalDeviceMaintenance10FeaturesKHR
//         Enum:
//             Name: VK_ATTACHMENT_DESCRIPTION_RESOLVE_SKIP_TRANSFER_FUNCTION_BIT_KHR
//             Negative: false
//             Bitpos: 1
//             Extends: VkAttachmentDescriptionFlagBits
//         Enum:
//             Name: VK_ATTACHMENT_DESCRIPTION_RESOLVE_ENABLE_TRANSFER_FUNCTION_BIT_KHR
//             Negative: false
//             Bitpos: 2
//             Extends: VkAttachmentDescriptionFlagBits
//     Depends: (VK_VERSION_1_4,VK_KHR_dynamic_rendering_local_read)+(VK_VERSION_1_3,VK_KHR_dynamic_rendering)
//         Enum:
//             Name: VK_RENDERING_LOCAL_READ_CONCURRENT_ACCESS_CONTROL_BIT_KHR
//             Negative: false
//             Bitpos: 8
//             Extends: VkRenderingFlagBits
//         Enum:
//             Name: VK_RENDERING_ATTACHMENT_INPUT_ATTACHMENT_FEEDBACK_BIT_KHR
//             Negative: false
//             Bitpos: 0
//             Extends: VkRenderingAttachmentFlagBitsKHR
//     Depends: VK_KHR_format_feature_flags2,VK_VERSION_1_3
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_DEPTH_COPY_ON_COMPUTE_QUEUE_BIT_KHR
//             Negative: false
//             Bitpos: 52
//             Extends: VkFormatFeatureFlagBits2
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_DEPTH_COPY_ON_TRANSFER_QUEUE_BIT_KHR
//             Negative: false
//             Bitpos: 53
//             Extends: VkFormatFeatureFlagBits2
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_STENCIL_COPY_ON_COMPUTE_QUEUE_BIT_KHR
//             Negative: false
//             Bitpos: 54
//             Extends: VkFormatFeatureFlagBits2
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_STENCIL_COPY_ON_TRANSFER_QUEUE_BIT_KHR
//             Negative: false
//             Bitpos: 55
//             Extends: VkFormatFeatureFlagBits2
//     Depends: VK_VERSION_1_3,VK_KHR_dynamic_rendering
//         Enum:
//             Name: VK_RENDERING_ATTACHMENT_RESOLVE_SKIP_TRANSFER_FUNCTION_BIT_KHR
//             Negative: false
//             Bitpos: 1
//             Extends: VkRenderingAttachmentFlagBitsKHR
//         Enum:
//             Name: VK_RENDERING_ATTACHMENT_RESOLVE_ENABLE_TRANSFER_FUNCTION_BIT_KHR
//             Negative: false
//             Bitpos: 2
//             Extends: VkRenderingAttachmentFlagBitsKHR
//     Depends: VK_VERSION_1_3,VK_KHR_copy_commands2
//         Enum:
//             Name: VK_RESOLVE_IMAGE_SKIP_TRANSFER_FUNCTION_BIT_KHR
//             Negative: false
//             Bitpos: 0
//             Extends: VkResolveImageFlagBitsKHR
//         Enum:
//             Name: VK_RESOLVE_IMAGE_ENABLE_TRANSFER_FUNCTION_BIT_KHR
//             Negative: false
//             Bitpos: 1
//             Extends: VkResolveImageFlagBitsKHR
pub const VK_ARM_extension_632_name = "VK_ARM_extension_632";
// Extension: VK_ARM_extension_632
// Number: 632
// Type: invalid
// Author: ARM
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_ARM_EXTENSION_632_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_ARM_EXTENSION_632_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_ARM_extension_632&quot;
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_RESERVED_56_BIT_ARM
//             Negative: false
//             Bitpos: 56
//             Extends: VkFormatFeatureFlagBits2
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_RESERVED_57_BIT_ARM
//             Negative: false
//             Bitpos: 57
//             Extends: VkFormatFeatureFlagBits2
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_RESERVED_58_BIT_ARM
//             Negative: false
//             Bitpos: 58
//             Extends: VkFormatFeatureFlagBits2
pub const VK_MTK_extension_633_name = "VK_MTK_extension_633";
// Extension: VK_MTK_extension_633
// Number: 633
// Type: invalid
// Author: MTK
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_MTK_EXTENSION_633_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_MTK_EXTENSION_633_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_MTK_extension_633&quot;
pub const VK_NV_extension_634_name = "VK_NV_extension_634";
// Extension: VK_NV_extension_634
// Number: 634
// Type: invalid
// Author: NV
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_NV_EXTENSION_634_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_NV_EXTENSION_634_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_extension_634&quot;
pub const VK_MTK_extension_635_name = "VK_MTK_extension_635";
// Extension: VK_MTK_extension_635
// Number: 635
// Type: invalid
// Author: MTK
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_MTK_EXTENSION_635_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_MTK_EXTENSION_635_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_MTK_extension_635&quot;
pub const VK_EXT_extension_636_name = "VK_EXT_extension_636";
// Extension: VK_EXT_extension_636
// Number: 636
// Type: invalid
// Author: EXT
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_636_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_636_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_636&quot;
pub const VK_EXT_extension_637_name = "VK_EXT_extension_637";
// Extension: VK_EXT_extension_637
// Number: 637
// Type: invalid
// Author: EXT
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_637_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_637_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_637&quot;
pub const VK_SEC_pipeline_cache_incremental_mode_name = "VK_SEC_pipeline_cache_incremental_mode";
// Extension: VK_SEC_pipeline_cache_incremental_mode
// Number: 638
// Type: device
// Author: SEC
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_SEC_PIPELINE_CACHE_INCREMENTAL_MODE_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_SEC_PIPELINE_CACHE_INCREMENTAL_MODE_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_SEC_pipeline_cache_incremental_mode&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CACHE_INCREMENTAL_MODE_FEATURES_SEC
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDevicePipelineCacheIncrementalModeFeaturesSEC
//         Feature:
//             Name: pipelineCacheIncrementalMode
//             Struct: VkPhysicalDevicePipelineCacheIncrementalModeFeaturesSEC
pub const VK_EXT_extension_639_name = "VK_EXT_extension_639";
// Extension: VK_EXT_extension_639
// Number: 639
// Type: invalid
// Author: EXT
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_639_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_639_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_639&quot;
pub const VK_NV_extension_640_name = "VK_NV_extension_640";
// Extension: VK_NV_extension_640
// Number: 640
// Type: invalid
// Author: NV
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_NV_EXTENSION_640_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_NV_EXTENSION_640_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_extension_640&quot;
pub const VK_EXT_extension_641_name = "VK_EXT_extension_641";
// Extension: VK_EXT_extension_641
// Number: 641
// Type: invalid
// Author: EXT
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_641_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_641_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_641&quot;
//         Enum:
//             Name: VK_PIPELINE_CREATE_2_RESERVED_45_BIT_EXT
//             Negative: false
//             Bitpos: 45
//             Extends: VkPipelineCreateFlagBits2
pub const VK_EXT_extension_642_name = "VK_EXT_extension_642";
// Extension: VK_EXT_extension_642
// Number: 642
// Type: invalid
// Author: EXT
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_642_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_642_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_642&quot;
pub const VK_EXT_shader_uniform_buffer_unsized_array_name = "VK_EXT_shader_uniform_buffer_unsized_array";
// Extension: VK_EXT_shader_uniform_buffer_unsized_array
// Number: 643
// Type: device
// Author: EXT
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_EXT_SHADER_UNIFORM_BUFFER_UNSIZED_ARRAY_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_EXT_SHADER_UNIFORM_BUFFER_UNSIZED_ARRAY_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_shader_uniform_buffer_unsized_array&quot;
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_UNIFORM_BUFFER_UNSIZED_ARRAY_FEATURES_EXT
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Type:
//             Name: VkPhysicalDeviceShaderUniformBufferUnsizedArrayFeaturesEXT
//         Feature:
//             Name: shaderUniformBufferUnsizedArray
//             Struct: VkPhysicalDeviceShaderUniformBufferUnsizedArrayFeaturesEXT
pub const VK_EXT_extension_644_name = "VK_EXT_extension_644";
// Extension: VK_EXT_extension_644
// Number: 644
// Type: invalid
// Author: EXT
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_644_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_644_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_644&quot;
pub const VK_EXT_extension_645_name = "VK_EXT_extension_645";
// Extension: VK_EXT_extension_645
// Number: 645
// Type: invalid
// Author: EXT
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_645_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_645_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_645&quot;
pub const VK_NV_compute_occupancy_priority_name = "VK_NV_compute_occupancy_priority";
// Extension: VK_NV_compute_occupancy_priority
// Number: 646
// Type: device
// Author: NV
// Depends: VK_KHR_get_physical_device_properties2,VK_VERSION_1_1
// Supported: supported
// Unlocks:
//         Enum:
//             Name: VK_NV_COMPUTE_OCCUPANCY_PRIORITY_SPEC_VERSION
//             Negative: false
//             Value: 1
//         Enum:
//             Name: VK_NV_COMPUTE_OCCUPANCY_PRIORITY_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_compute_occupancy_priority&quot;
//         Enum:
//             Name: VK_COMPUTE_OCCUPANCY_PRIORITY_LOW_NV
//             Negative: false
//         Enum:
//             Name: VK_COMPUTE_OCCUPANCY_PRIORITY_NORMAL_NV
//             Negative: false
//         Enum:
//             Name: VK_COMPUTE_OCCUPANCY_PRIORITY_HIGH_NV
//             Negative: false
//         Enum:
//             Name: VK_STRUCTURE_TYPE_COMPUTE_OCCUPANCY_PRIORITY_PARAMETERS_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 0
//         Enum:
//             Name: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_OCCUPANCY_PRIORITY_FEATURES_NV
//             Negative: false
//             Extends: VkStructureType
//             Offset: 1
//         Type:
//             Name: VkComputeOccupancyPriorityParametersNV
//         Type:
//             Name: VkPhysicalDeviceComputeOccupancyPriorityFeaturesNV
//         Feature:
//             Name: computeOccupancyPriority
//             Struct: VkPhysicalDeviceComputeOccupancyPriorityFeaturesNV
//         Command:
//             Name: vkCmdSetComputeOccupancyPriorityNV
pub const VK_KHR_extension_647_name = "VK_KHR_extension_647";
// Extension: VK_KHR_extension_647
// Number: 647
// Type: device
// Author: KHR
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_KHR_EXTENSION_647_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_KHR_EXTENSION_647_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_extension_647&quot;
//         Enum:
//             Name: VK_QUEUE_RESERVED_13_BIT_EXT
//             Negative: false
//             Bitpos: 13
//             Extends: VkQueueFlagBits
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_RESERVED_47_BIT_KHR
//             Negative: false
//             Bitpos: 47
//             Extends: VkPipelineStageFlagBits2
//         Enum:
//             Name: VK_ACCESS_2_RESERVED_60_BIT_KHR
//             Negative: false
//             Bitpos: 60
//             Extends: VkAccessFlagBits2
//         Enum:
//             Name: VK_ACCESS_2_RESERVED_61_BIT_KHR
//             Negative: false
//             Bitpos: 61
//             Extends: VkAccessFlagBits2
//         Enum:
//             Name: VK_BUFFER_USAGE_2_RESERVED_35_BIT_KHR
//             Negative: false
//             Bitpos: 35
//             Extends: VkBufferUsageFlagBits2
//         Enum:
//             Name: VK_BUFFER_USAGE_2_RESERVED_36_BIT_KHR
//             Negative: false
//             Bitpos: 36
//             Extends: VkBufferUsageFlagBits2
//         Enum:
//             Name: VK_IMAGE_USAGE_RESERVED_29_BIT_KHR
//             Negative: false
//             Bitpos: 29
//             Extends: VkImageUsageFlagBits
//         Enum:
//             Name: VK_IMAGE_USAGE_RESERVED_30_BIT_KHR
//             Negative: false
//             Bitpos: 30
//             Extends: VkImageUsageFlagBits
pub const VK_KHR_extension_648_name = "VK_KHR_extension_648";
// Extension: VK_KHR_extension_648
// Number: 648
// Type: device
// Author: KHR
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_KHR_EXTENSION_648_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_KHR_EXTENSION_648_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_extension_648&quot;
pub const VK_AMD_extension_649_name = "VK_AMD_extension_649";
// Extension: VK_AMD_extension_649
// Number: 649
// Type: device
// Author: AMD
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_AMD_EXTENSION_649_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_AMD_EXTENSION_649_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_extension_649&quot;
//         Enum:
//             Name: VK_PIPELINE_CREATE_2_RESERVED_47_BIT_AMD
//             Negative: false
//             Bitpos: 47
//             Extends: VkPipelineCreateFlagBits2
pub const VK_AMD_extension_650_name = "VK_AMD_extension_650";
// Extension: VK_AMD_extension_650
// Number: 650
// Type: device
// Author: AMD
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_AMD_EXTENSION_650_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_AMD_EXTENSION_650_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_extension_650&quot;
pub const VK_AMD_extension_651_name = "VK_AMD_extension_651";
// Extension: VK_AMD_extension_651
// Number: 651
// Type: device
// Author: AMD
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_AMD_EXTENSION_651_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_AMD_EXTENSION_651_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_extension_651&quot;
pub const VK_AMD_extension_652_name = "VK_AMD_extension_652";
// Extension: VK_AMD_extension_652
// Number: 652
// Type: device
// Author: AMD
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_AMD_EXTENSION_652_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_AMD_EXTENSION_652_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_extension_652&quot;
pub const VK_AMD_extension_653_name = "VK_AMD_extension_653";
// Extension: VK_AMD_extension_653
// Number: 653
// Type: device
// Author: AMD
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_AMD_EXTENSION_653_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_AMD_EXTENSION_653_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_AMD_extension_653&quot;
pub const VK_VALVE_extension_654_name = "VK_VALVE_extension_654";
// Extension: VK_VALVE_extension_654
// Number: 654
// Type: device
// Author: VALVE
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_VALVE_EXTENSION_654_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_VALVE_EXTENSION_654_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_VALVE_extension_654&quot;
pub const VK_ARM_extension_655_name = "VK_ARM_extension_655";
// Extension: VK_ARM_extension_655
// Number: 655
// Type: device
// Author: Arm
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_ARM_EXTENSION_655_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_ARM_EXTENSION_655_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_ARM_extension_655&quot;
pub const VK_ARM_extension_656_name = "VK_ARM_extension_656";
// Extension: VK_ARM_extension_656
// Number: 656
// Type: device
// Author: Arm
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_ARM_EXTENSION_656_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_ARM_EXTENSION_656_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_ARM_extension_656&quot;
pub const VK_ARM_extension_657_name = "VK_ARM_extension_657";
// Extension: VK_ARM_extension_657
// Number: 657
// Type: device
// Author: Arm
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_ARM_EXTENSION_657_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_ARM_EXTENSION_657_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_ARM_extension_657&quot;
pub const VK_KHR_extension_658_name = "VK_KHR_extension_658";
// Extension: VK_KHR_extension_658
// Number: 658
// Type: device
// Author: KHR
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_KHR_EXTENSION_658_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_KHR_EXTENSION_658_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_extension_658&quot;
//         Enum:
//             Name: VK_IMAGE_CREATE_RESERVED_22_BIT_KHR
//             Negative: false
//             Bitpos: 22
//             Extends: VkImageCreateFlagBits
//     Depends: VK_EXT_shader_object
//         Enum:
//             Name: VK_SHADER_CREATE_RESERVED_18_BIT_KHR
//             Negative: false
//             Bitpos: 18
//             Extends: VkShaderCreateFlagBitsEXT
pub const VK_ARM_extension_659_name = "VK_ARM_extension_659";
// Extension: VK_ARM_extension_659
// Number: 659
// Type: invalid
// Author: Arm
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_ARM_EXTENSION_659_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_ARM_EXTENSION_659_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_ARM_extension_659&quot;
//         Enum:
//             Name: VK_QUEUE_RESERVED_11_BIT_ARM
//             Negative: false
//             Bitpos: 11
//             Extends: VkQueueFlagBits
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_RESERVED_43_BIT_ARM
//             Negative: false
//             Bitpos: 43
//             Extends: VkPipelineStageFlagBits2
//         Enum:
//             Name: VK_ACCESS_2_RESERVED_49_BIT_ARM
//             Negative: false
//             Bitpos: 49
//             Extends: VkAccessFlagBits2
//         Enum:
//             Name: VK_ACCESS_2_RESERVED_50_BIT_ARM
//             Negative: false
//             Bitpos: 50
//             Extends: VkAccessFlagBits2
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_RESERVED_47_BIT_ARM
//             Negative: false
//             Bitpos: 47
//             Extends: VkFormatFeatureFlagBits2
pub const VK_EXT_extension_660_name = "VK_EXT_extension_660";
// Extension: VK_EXT_extension_660
// Number: 660
// Type: invalid
// Author: EXT
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_660_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_660_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_660&quot;
pub const VK_KHR_extension_661_name = "VK_KHR_extension_661";
// Extension: VK_KHR_extension_661
// Number: 661
// Type: device
// Author: KHR
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_KHR_EXTENSION_661_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_KHR_EXTENSION_661_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_KHR_extension_661&quot;
pub const VK_VALVE_extension_662_name = "VK_VALVE_extension_662";
// Extension: VK_VALVE_extension_662
// Number: 662
// Type: device
// Author: VALVE
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_VALVE_EXTENSION_662_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_VALVE_EXTENSION_662_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_VALVE_extension_662&quot;
pub const VK_EXT_extension_663_name = "VK_EXT_extension_663";
// Extension: VK_EXT_extension_663
// Number: 663
// Type: invalid
// Author: EXT
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_663_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_663_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_663&quot;
pub const VK_EXT_extension_664_name = "VK_EXT_extension_664";
// Extension: VK_EXT_extension_664
// Number: 664
// Type: invalid
// Author: HUAWEI
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_EXT_EXTENSION_664_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_EXT_EXTENSION_664_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_EXT_extension_664&quot;
//         Enum:
//             Name: VK_COMMAND_BUFFER_USAGE_RESERVED_3_BIT_HUAWEI
//             Negative: false
//             Bitpos: 3
//             Extends: VkCommandBufferUsageFlagBits
//         Enum:
//             Name: VK_SHADER_STAGE_RESERVED_16_BIT_HUAWEI
//             Negative: false
//             Bitpos: 16
//             Extends: VkShaderStageFlagBits
//         Enum:
//             Name: VK_IMAGE_USAGE_RESERVED_16_BIT_HUAWEI
//             Negative: false
//             Bitpos: 16
//             Extends: VkImageUsageFlagBits
//         Enum:
//             Name: VK_IMAGE_USAGE_RESERVED_27_BIT_HUAWEI
//             Negative: false
//             Bitpos: 17
//             Extends: VkImageUsageFlagBits
//         Enum:
//             Name: VK_PIPELINE_CREATE_2_RESERVED_48_BIT_HUAWEI
//             Negative: false
//             Bitpos: 48
//             Extends: VkPipelineCreateFlagBits2
//         Enum:
//             Name: VK_BUFFER_USAGE_2_RESERVED_37_BIT_HUAWEI
//             Negative: false
//             Bitpos: 37
//             Extends: VkBufferUsageFlagBits2
//         Enum:
//             Name: VK_PIPELINE_STAGE_2_RESERVED_48_BIT_HUAWEI
//             Negative: false
//             Bitpos: 48
//             Extends: VkPipelineStageFlagBits2
//         Enum:
//             Name: VK_IMAGE_ASPECT_RESERVED_11_BIT_HUAWEI
//             Negative: false
//             Bitpos: 11
//             Extends: VkImageAspectFlagBits
//         Enum:
//             Name: VK_FORMAT_FEATURE_2_RESERVED_61_BIT_HUAWEI
//             Negative: false
//             Bitpos: 61
//             Extends: VkFormatFeatureFlagBits2
pub const VK_SEC_extension_665_name = "VK_SEC_extension_665";
// Extension: VK_SEC_extension_665
// Number: 665
// Type: invalid
// Author: SEC
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_SEC_EXTENSION_665_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_SEC_EXTENSION_665_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_SEC_extension_665&quot;
pub const VK_GOOGLE_extension_666_name = "VK_GOOGLE_extension_666";
// Extension: VK_GOOGLE_extension_666
// Number: 666
// Type: invalid
// Author: GOOGLE
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_GOOGLE_EXTENSION_666_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_GOOGLE_EXTENSION_666_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_GOOGLE_extension_666&quot;
pub const VK_HUAWEI_extension_667_name = "VK_HUAWEI_extension_667";
// Extension: VK_HUAWEI_extension_667
// Number: 667
// Type: invalid
// Author: HUAWEI
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_HUAWEI_EXTENSION_667_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_HUAWEI_EXTENSION_667_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_HUAWEI_extension_667&quot;
//         Enum:
//             Name: VK_COMMAND_BUFFER_USAGE_RESERVED_4_BIT_HUAWEI
//             Negative: false
//             Bitpos: 4
//             Extends: VkCommandBufferUsageFlagBits
pub const VK_NV_extension_668_name = "VK_NV_extension_668";
// Extension: VK_NV_extension_668
// Number: 668
// Type: invalid
// Author: NV
// Supported: disabled
// Unlocks:
//         Enum:
//             Name: VK_NV_EXTENSION_668_SPEC_VERSION
//             Negative: false
//             Value: 0
//         Enum:
//             Name: VK_NV_EXTENSION_668_EXTENSION_NAME
//             Negative: false
//             Value: &quot;VK_NV_extension_668&quot;
