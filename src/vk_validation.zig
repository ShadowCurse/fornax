// This file is auto generated by gen/gen_vk_validation.zig

const std = @import("std");
const vk = @import("vk.zig");
const log = @import("log.zig");
const Allocator = std.mem.Allocator;

pub const Extensions = struct {
    instance: packed struct(u43) {
        VK_KHR_surface: bool = false,
        VK_KHR_display: bool = false,
        VK_KHR_xlib_surface: bool = false,
        VK_KHR_xcb_surface: bool = false,
        VK_KHR_wayland_surface: bool = false,
        VK_KHR_android_surface: bool = false,
        VK_KHR_win32_surface: bool = false,
        VK_EXT_debug_report: bool = false,
        VK_GGP_stream_descriptor_surface: bool = false,
        VK_NV_external_memory_capabilities: bool = false,
        VK_KHR_get_physical_device_properties2: bool = false,
        VK_EXT_validation_flags: bool = false,
        VK_NN_vi_surface: bool = false,
        VK_KHR_device_group_creation: bool = false,
        VK_KHR_external_memory_capabilities: bool = false,
        VK_KHR_external_semaphore_capabilities: bool = false,
        VK_EXT_direct_mode_display: bool = false,
        VK_EXT_acquire_xlib_display: bool = false,
        VK_EXT_display_surface_counter: bool = false,
        VK_EXT_swapchain_colorspace: bool = false,
        VK_KHR_external_fence_capabilities: bool = false,
        VK_KHR_get_surface_capabilities2: bool = false,
        VK_KHR_get_display_properties2: bool = false,
        VK_MVK_ios_surface: bool = false,
        VK_MVK_macos_surface: bool = false,
        VK_EXT_debug_utils: bool = false,
        VK_FUCHSIA_imagepipe_surface: bool = false,
        VK_EXT_metal_surface: bool = false,
        VK_KHR_surface_protected_capabilities: bool = false,
        VK_EXT_validation_features: bool = false,
        VK_EXT_headless_surface: bool = false,
        VK_EXT_surface_maintenance1: bool = false,
        VK_EXT_acquire_drm_display: bool = false,
        VK_EXT_directfb_surface: bool = false,
        VK_QNX_screen_surface: bool = false,
        VK_KHR_portability_enumeration: bool = false,
        VK_GOOGLE_surfaceless_query: bool = false,
        VK_EXT_application_parameters: bool = false,
        VK_LUNARG_direct_driver_loading: bool = false,
        VK_KHR_surface_maintenance1: bool = false,
        VK_EXT_layer_settings: bool = false,
        VK_NV_display_stereo: bool = false,
        VK_OHOS_surface: bool = false,
    } = .{},
    device: packed struct(u401) {
        VK_KHR_swapchain: bool = false,
        VK_KHR_display_swapchain: bool = false,
        VK_NV_glsl_shader: bool = false,
        VK_EXT_depth_range_unrestricted: bool = false,
        VK_KHR_sampler_mirror_clamp_to_edge: bool = false,
        VK_IMG_filter_cubic: bool = false,
        VK_AMD_rasterization_order: bool = false,
        VK_AMD_shader_trinary_minmax: bool = false,
        VK_AMD_shader_explicit_vertex_parameter: bool = false,
        VK_EXT_debug_marker: bool = false,
        VK_KHR_video_queue: bool = false,
        VK_KHR_video_decode_queue: bool = false,
        VK_AMD_gcn_shader: bool = false,
        VK_NV_dedicated_allocation: bool = false,
        VK_EXT_transform_feedback: bool = false,
        VK_NVX_binary_import: bool = false,
        VK_NVX_image_view_handle: bool = false,
        VK_AMD_draw_indirect_count: bool = false,
        VK_AMD_negative_viewport_height: bool = false,
        VK_AMD_gpu_shader_half_float: bool = false,
        VK_AMD_shader_ballot: bool = false,
        VK_KHR_video_encode_h264: bool = false,
        VK_KHR_video_encode_h265: bool = false,
        VK_KHR_video_decode_h264: bool = false,
        VK_AMD_texture_gather_bias_lod: bool = false,
        VK_AMD_shader_info: bool = false,
        VK_KHR_dynamic_rendering: bool = false,
        VK_AMD_shader_image_load_store_lod: bool = false,
        VK_NV_corner_sampled_image: bool = false,
        VK_NV_private_vendor_info: bool = false,
        VK_KHR_multiview: bool = false,
        VK_IMG_format_pvrtc: bool = false,
        VK_NV_external_memory: bool = false,
        VK_NV_external_memory_win32: bool = false,
        VK_NV_win32_keyed_mutex: bool = false,
        VK_KHR_device_group: bool = false,
        VK_KHR_shader_draw_parameters: bool = false,
        VK_EXT_shader_subgroup_ballot: bool = false,
        VK_EXT_shader_subgroup_vote: bool = false,
        VK_EXT_texture_compression_astc_hdr: bool = false,
        VK_EXT_astc_decode_mode: bool = false,
        VK_EXT_pipeline_robustness: bool = false,
        VK_KHR_maintenance1: bool = false,
        VK_KHR_external_memory: bool = false,
        VK_KHR_external_memory_win32: bool = false,
        VK_KHR_external_memory_fd: bool = false,
        VK_KHR_win32_keyed_mutex: bool = false,
        VK_KHR_external_semaphore: bool = false,
        VK_KHR_external_semaphore_win32: bool = false,
        VK_KHR_external_semaphore_fd: bool = false,
        VK_KHR_push_descriptor: bool = false,
        VK_EXT_conditional_rendering: bool = false,
        VK_KHR_shader_float16_int8: bool = false,
        VK_KHR_16bit_storage: bool = false,
        VK_KHR_incremental_present: bool = false,
        VK_KHR_descriptor_update_template: bool = false,
        VK_NV_clip_space_w_scaling: bool = false,
        VK_EXT_display_control: bool = false,
        VK_GOOGLE_display_timing: bool = false,
        VK_NV_sample_mask_override_coverage: bool = false,
        VK_NV_geometry_shader_passthrough: bool = false,
        VK_NV_viewport_array2: bool = false,
        VK_NVX_multiview_per_view_attributes: bool = false,
        VK_NV_viewport_swizzle: bool = false,
        VK_EXT_discard_rectangles: bool = false,
        VK_EXT_conservative_rasterization: bool = false,
        VK_EXT_depth_clip_enable: bool = false,
        VK_EXT_hdr_metadata: bool = false,
        VK_KHR_imageless_framebuffer: bool = false,
        VK_KHR_create_renderpass2: bool = false,
        VK_IMG_relaxed_line_rasterization: bool = false,
        VK_KHR_shared_presentable_image: bool = false,
        VK_KHR_external_fence: bool = false,
        VK_KHR_external_fence_win32: bool = false,
        VK_KHR_external_fence_fd: bool = false,
        VK_KHR_performance_query: bool = false,
        VK_KHR_maintenance2: bool = false,
        VK_KHR_variable_pointers: bool = false,
        VK_EXT_external_memory_dma_buf: bool = false,
        VK_EXT_queue_family_foreign: bool = false,
        VK_KHR_dedicated_allocation: bool = false,
        VK_ANDROID_external_memory_android_hardware_buffer: bool = false,
        VK_EXT_sampler_filter_minmax: bool = false,
        VK_KHR_storage_buffer_storage_class: bool = false,
        VK_AMD_gpu_shader_int16: bool = false,
        VK_AMDX_shader_enqueue: bool = false,
        VK_AMD_mixed_attachment_samples: bool = false,
        VK_AMD_shader_fragment_mask: bool = false,
        VK_EXT_inline_uniform_block: bool = false,
        VK_EXT_shader_stencil_export: bool = false,
        VK_KHR_shader_bfloat16: bool = false,
        VK_EXT_sample_locations: bool = false,
        VK_KHR_relaxed_block_layout: bool = false,
        VK_KHR_get_memory_requirements2: bool = false,
        VK_KHR_image_format_list: bool = false,
        VK_EXT_blend_operation_advanced: bool = false,
        VK_NV_fragment_coverage_to_color: bool = false,
        VK_KHR_acceleration_structure: bool = false,
        VK_KHR_ray_tracing_pipeline: bool = false,
        VK_KHR_ray_query: bool = false,
        VK_NV_framebuffer_mixed_samples: bool = false,
        VK_NV_fill_rectangle: bool = false,
        VK_NV_shader_sm_builtins: bool = false,
        VK_EXT_post_depth_coverage: bool = false,
        VK_KHR_sampler_ycbcr_conversion: bool = false,
        VK_KHR_bind_memory2: bool = false,
        VK_EXT_image_drm_format_modifier: bool = false,
        VK_EXT_validation_cache: bool = false,
        VK_EXT_descriptor_indexing: bool = false,
        VK_EXT_shader_viewport_index_layer: bool = false,
        VK_KHR_portability_subset: bool = false,
        VK_NV_shading_rate_image: bool = false,
        VK_NV_ray_tracing: bool = false,
        VK_NV_representative_fragment_test: bool = false,
        VK_KHR_maintenance3: bool = false,
        VK_KHR_draw_indirect_count: bool = false,
        VK_EXT_filter_cubic: bool = false,
        VK_QCOM_render_pass_shader_resolve: bool = false,
        VK_EXT_global_priority: bool = false,
        VK_KHR_shader_subgroup_extended_types: bool = false,
        VK_KHR_8bit_storage: bool = false,
        VK_EXT_external_memory_host: bool = false,
        VK_AMD_buffer_marker: bool = false,
        VK_KHR_shader_atomic_int64: bool = false,
        VK_KHR_shader_clock: bool = false,
        VK_AMD_pipeline_compiler_control: bool = false,
        VK_EXT_calibrated_timestamps: bool = false,
        VK_AMD_shader_core_properties: bool = false,
        VK_KHR_video_decode_h265: bool = false,
        VK_KHR_global_priority: bool = false,
        VK_AMD_memory_overallocation_behavior: bool = false,
        VK_EXT_vertex_attribute_divisor: bool = false,
        VK_GGP_frame_token: bool = false,
        VK_EXT_pipeline_creation_feedback: bool = false,
        VK_KHR_driver_properties: bool = false,
        VK_KHR_shader_float_controls: bool = false,
        VK_NV_shader_subgroup_partitioned: bool = false,
        VK_KHR_depth_stencil_resolve: bool = false,
        VK_KHR_swapchain_mutable_format: bool = false,
        VK_NV_compute_shader_derivatives: bool = false,
        VK_NV_mesh_shader: bool = false,
        VK_NV_fragment_shader_barycentric: bool = false,
        VK_NV_shader_image_footprint: bool = false,
        VK_NV_scissor_exclusive: bool = false,
        VK_NV_device_diagnostic_checkpoints: bool = false,
        VK_KHR_timeline_semaphore: bool = false,
        VK_EXT_present_timing: bool = false,
        VK_INTEL_shader_integer_functions2: bool = false,
        VK_INTEL_performance_query: bool = false,
        VK_KHR_vulkan_memory_model: bool = false,
        VK_EXT_pci_bus_info: bool = false,
        VK_AMD_display_native_hdr: bool = false,
        VK_KHR_shader_terminate_invocation: bool = false,
        VK_EXT_fragment_density_map: bool = false,
        VK_EXT_scalar_block_layout: bool = false,
        VK_GOOGLE_hlsl_functionality1: bool = false,
        VK_GOOGLE_decorate_string: bool = false,
        VK_EXT_subgroup_size_control: bool = false,
        VK_KHR_fragment_shading_rate: bool = false,
        VK_AMD_shader_core_properties2: bool = false,
        VK_AMD_device_coherent_memory: bool = false,
        VK_KHR_dynamic_rendering_local_read: bool = false,
        VK_EXT_shader_image_atomic_int64: bool = false,
        VK_KHR_shader_quad_control: bool = false,
        VK_KHR_spirv_1_4: bool = false,
        VK_EXT_memory_budget: bool = false,
        VK_EXT_memory_priority: bool = false,
        VK_NV_dedicated_allocation_image_aliasing: bool = false,
        VK_KHR_separate_depth_stencil_layouts: bool = false,
        VK_EXT_buffer_device_address: bool = false,
        VK_EXT_tooling_info: bool = false,
        VK_EXT_separate_stencil_usage: bool = false,
        VK_KHR_present_wait: bool = false,
        VK_NV_cooperative_matrix: bool = false,
        VK_NV_coverage_reduction_mode: bool = false,
        VK_EXT_fragment_shader_interlock: bool = false,
        VK_EXT_ycbcr_image_arrays: bool = false,
        VK_KHR_uniform_buffer_standard_layout: bool = false,
        VK_EXT_provoking_vertex: bool = false,
        VK_EXT_full_screen_exclusive: bool = false,
        VK_KHR_buffer_device_address: bool = false,
        VK_EXT_line_rasterization: bool = false,
        VK_EXT_shader_atomic_float: bool = false,
        VK_EXT_host_query_reset: bool = false,
        VK_EXT_index_type_uint8: bool = false,
        VK_EXT_extended_dynamic_state: bool = false,
        VK_KHR_deferred_host_operations: bool = false,
        VK_KHR_pipeline_executable_properties: bool = false,
        VK_EXT_host_image_copy: bool = false,
        VK_KHR_map_memory2: bool = false,
        VK_EXT_map_memory_placed: bool = false,
        VK_EXT_shader_atomic_float2: bool = false,
        VK_EXT_swapchain_maintenance1: bool = false,
        VK_EXT_shader_demote_to_helper_invocation: bool = false,
        VK_NV_device_generated_commands: bool = false,
        VK_NV_inherited_viewport_scissor: bool = false,
        VK_KHR_shader_integer_dot_product: bool = false,
        VK_EXT_texel_buffer_alignment: bool = false,
        VK_QCOM_render_pass_transform: bool = false,
        VK_EXT_depth_bias_control: bool = false,
        VK_EXT_device_memory_report: bool = false,
        VK_EXT_robustness2: bool = false,
        VK_EXT_custom_border_color: bool = false,
        VK_GOOGLE_user_type: bool = false,
        VK_KHR_pipeline_library: bool = false,
        VK_NV_present_barrier: bool = false,
        VK_KHR_shader_non_semantic_info: bool = false,
        VK_KHR_present_id: bool = false,
        VK_EXT_private_data: bool = false,
        VK_EXT_pipeline_creation_cache_control: bool = false,
        VK_KHR_video_encode_queue: bool = false,
        VK_NV_device_diagnostics_config: bool = false,
        VK_QCOM_render_pass_store_ops: bool = false,
        VK_NV_cuda_kernel_launch: bool = false,
        VK_KHR_object_refresh: bool = false,
        VK_QCOM_tile_shading: bool = false,
        VK_NV_low_latency: bool = false,
        VK_EXT_metal_objects: bool = false,
        VK_KHR_synchronization2: bool = false,
        VK_EXT_descriptor_buffer: bool = false,
        VK_EXT_graphics_pipeline_library: bool = false,
        VK_AMD_shader_early_and_late_fragment_tests: bool = false,
        VK_KHR_fragment_shader_barycentric: bool = false,
        VK_KHR_shader_subgroup_uniform_control_flow: bool = false,
        VK_KHR_zero_initialize_workgroup_memory: bool = false,
        VK_NV_fragment_shading_rate_enums: bool = false,
        VK_NV_ray_tracing_motion_blur: bool = false,
        VK_EXT_mesh_shader: bool = false,
        VK_EXT_ycbcr_2plane_444_formats: bool = false,
        VK_EXT_fragment_density_map2: bool = false,
        VK_QCOM_rotated_copy_commands: bool = false,
        VK_EXT_image_robustness: bool = false,
        VK_KHR_workgroup_memory_explicit_layout: bool = false,
        VK_KHR_copy_commands2: bool = false,
        VK_EXT_image_compression_control: bool = false,
        VK_EXT_attachment_feedback_loop_layout: bool = false,
        VK_EXT_4444_formats: bool = false,
        VK_EXT_device_fault: bool = false,
        VK_ARM_rasterization_order_attachment_access: bool = false,
        VK_EXT_rgba10x6_formats: bool = false,
        VK_NV_acquire_winrt_display: bool = false,
        VK_VALVE_mutable_descriptor_type: bool = false,
        VK_EXT_vertex_input_dynamic_state: bool = false,
        VK_EXT_physical_device_drm: bool = false,
        VK_EXT_device_address_binding_report: bool = false,
        VK_EXT_depth_clip_control: bool = false,
        VK_EXT_primitive_topology_list_restart: bool = false,
        VK_KHR_format_feature_flags2: bool = false,
        VK_EXT_present_mode_fifo_latest_ready: bool = false,
        VK_FUCHSIA_external_memory: bool = false,
        VK_FUCHSIA_external_semaphore: bool = false,
        VK_FUCHSIA_buffer_collection: bool = false,
        VK_HUAWEI_subpass_shading: bool = false,
        VK_HUAWEI_invocation_mask: bool = false,
        VK_NV_external_memory_rdma: bool = false,
        VK_EXT_pipeline_properties: bool = false,
        VK_NV_external_sci_sync: bool = false,
        VK_NV_external_memory_sci_buf: bool = false,
        VK_EXT_frame_boundary: bool = false,
        VK_EXT_multisampled_render_to_single_sampled: bool = false,
        VK_EXT_extended_dynamic_state2: bool = false,
        VK_EXT_color_write_enable: bool = false,
        VK_EXT_primitives_generated_query: bool = false,
        VK_KHR_ray_tracing_maintenance1: bool = false,
        VK_KHR_shader_untyped_pointers: bool = false,
        VK_EXT_global_priority_query: bool = false,
        VK_VALVE_video_encode_rgb_conversion: bool = false,
        VK_EXT_image_view_min_lod: bool = false,
        VK_EXT_multi_draw: bool = false,
        VK_EXT_image_2d_view_of_3d: bool = false,
        VK_EXT_shader_tile_image: bool = false,
        VK_EXT_opacity_micromap: bool = false,
        VK_NV_displacement_micromap: bool = false,
        VK_EXT_load_store_op_none: bool = false,
        VK_HUAWEI_cluster_culling_shader: bool = false,
        VK_EXT_border_color_swizzle: bool = false,
        VK_EXT_pageable_device_local_memory: bool = false,
        VK_KHR_maintenance4: bool = false,
        VK_ARM_shader_core_properties: bool = false,
        VK_KHR_shader_subgroup_rotate: bool = false,
        VK_ARM_scheduling_controls: bool = false,
        VK_EXT_image_sliced_view_of_3d: bool = false,
        VK_VALVE_descriptor_set_host_mapping: bool = false,
        VK_EXT_depth_clamp_zero_one: bool = false,
        VK_EXT_non_seamless_cube_map: bool = false,
        VK_ARM_render_pass_striped: bool = false,
        VK_QCOM_fragment_density_map_offset: bool = false,
        VK_NV_copy_memory_indirect: bool = false,
        VK_NV_memory_decompression: bool = false,
        VK_NV_device_generated_commands_compute: bool = false,
        VK_NV_ray_tracing_linear_swept_spheres: bool = false,
        VK_NV_linear_color_attachment: bool = false,
        VK_KHR_shader_maximal_reconvergence: bool = false,
        VK_EXT_image_compression_control_swapchain: bool = false,
        VK_QCOM_image_processing: bool = false,
        VK_EXT_nested_command_buffer: bool = false,
        VK_OHOS_external_memory: bool = false,
        VK_EXT_external_memory_acquire_unmodified: bool = false,
        VK_EXT_extended_dynamic_state3: bool = false,
        VK_EXT_subpass_merge_feedback: bool = false,
        VK_ARM_tensors: bool = false,
        VK_EXT_shader_module_identifier: bool = false,
        VK_EXT_rasterization_order_attachment_access: bool = false,
        VK_NV_optical_flow: bool = false,
        VK_EXT_legacy_dithering: bool = false,
        VK_EXT_pipeline_protected_access: bool = false,
        VK_ANDROID_external_format_resolve: bool = false,
        VK_KHR_maintenance5: bool = false,
        VK_AMD_anti_lag: bool = false,
        VK_AMDX_dense_geometry_format: bool = false,
        VK_KHR_present_id2: bool = false,
        VK_KHR_present_wait2: bool = false,
        VK_KHR_ray_tracing_position_fetch: bool = false,
        VK_EXT_shader_object: bool = false,
        VK_KHR_pipeline_binary: bool = false,
        VK_QCOM_tile_properties: bool = false,
        VK_SEC_amigo_profiling: bool = false,
        VK_KHR_swapchain_maintenance1: bool = false,
        VK_QCOM_multiview_per_view_viewports: bool = false,
        VK_NV_external_sci_sync2: bool = false,
        VK_NV_ray_tracing_invocation_reorder: bool = false,
        VK_NV_cooperative_vector: bool = false,
        VK_NV_extended_sparse_address_space: bool = false,
        VK_EXT_mutable_descriptor_type: bool = false,
        VK_EXT_legacy_vertex_attributes: bool = false,
        VK_ARM_shader_core_builtins: bool = false,
        VK_EXT_pipeline_library_group_handles: bool = false,
        VK_EXT_dynamic_rendering_unused_attachments: bool = false,
        VK_NV_low_latency2: bool = false,
        VK_KHR_cooperative_matrix: bool = false,
        VK_ARM_data_graph: bool = false,
        VK_QCOM_multiview_per_view_render_areas: bool = false,
        VK_KHR_compute_shader_derivatives: bool = false,
        VK_KHR_video_decode_av1: bool = false,
        VK_KHR_video_encode_av1: bool = false,
        VK_KHR_video_decode_vp9: bool = false,
        VK_KHR_video_maintenance1: bool = false,
        VK_NV_per_stage_descriptor_set: bool = false,
        VK_QCOM_image_processing2: bool = false,
        VK_QCOM_filter_cubic_weights: bool = false,
        VK_QCOM_ycbcr_degamma: bool = false,
        VK_QCOM_filter_cubic_clamp: bool = false,
        VK_EXT_attachment_feedback_loop_dynamic_state: bool = false,
        VK_KHR_vertex_attribute_divisor: bool = false,
        VK_KHR_load_store_op_none: bool = false,
        VK_KHR_unified_image_layouts: bool = false,
        VK_KHR_shader_float_controls2: bool = false,
        VK_QNX_external_memory_screen_buffer: bool = false,
        VK_MSFT_layered_driver: bool = false,
        VK_KHR_index_type_uint8: bool = false,
        VK_KHR_line_rasterization: bool = false,
        VK_KHR_calibrated_timestamps: bool = false,
        VK_KHR_shader_expect_assume: bool = false,
        VK_KHR_maintenance6: bool = false,
        VK_NV_descriptor_pool_overallocation: bool = false,
        VK_QCOM_tile_memory_heap: bool = false,
        VK_KHR_copy_memory_indirect: bool = false,
        VK_EXT_memory_decompression: bool = false,
        VK_KHR_video_encode_intra_refresh: bool = false,
        VK_KHR_video_encode_quantization_map: bool = false,
        VK_NV_raw_access_chains: bool = false,
        VK_NV_external_compute_queue: bool = false,
        VK_KHR_shader_relaxed_extended_instruction: bool = false,
        VK_NV_command_buffer_inheritance: bool = false,
        VK_KHR_maintenance7: bool = false,
        VK_NV_shader_atomic_float16_vector: bool = false,
        VK_EXT_shader_replicated_composites: bool = false,
        VK_EXT_shader_float8: bool = false,
        VK_NV_ray_tracing_validation: bool = false,
        VK_NV_cluster_acceleration_structure: bool = false,
        VK_NV_partitioned_acceleration_structure: bool = false,
        VK_EXT_device_generated_commands: bool = false,
        VK_KHR_maintenance8: bool = false,
        VK_MESA_image_alignment_control: bool = false,
        VK_KHR_shader_fma: bool = false,
        VK_EXT_ray_tracing_invocation_reorder: bool = false,
        VK_EXT_depth_clamp_control: bool = false,
        VK_KHR_maintenance9: bool = false,
        VK_KHR_video_maintenance2: bool = false,
        VK_OHOS_native_buffer: bool = false,
        VK_HUAWEI_hdr_vivid: bool = false,
        VK_NV_cooperative_matrix2: bool = false,
        VK_ARM_pipeline_opacity_micromap: bool = false,
        VK_EXT_external_memory_metal: bool = false,
        VK_KHR_depth_clamp_zero_one: bool = false,
        VK_ARM_performance_counters_by_region: bool = false,
        VK_EXT_vertex_attribute_robustness: bool = false,
        VK_ARM_format_pack: bool = false,
        VK_VALVE_fragment_density_map_layered: bool = false,
        VK_KHR_robustness2: bool = false,
        VK_NV_present_metering: bool = false,
        VK_EXT_fragment_density_map_offset: bool = false,
        VK_EXT_zero_initialize_device_memory: bool = false,
        VK_KHR_present_mode_fifo_latest_ready: bool = false,
        VK_EXT_shader_64bit_indexing: bool = false,
        VK_EXT_custom_resolve: bool = false,
        VK_QCOM_data_graph_model: bool = false,
        VK_KHR_maintenance10: bool = false,
        VK_SEC_pipeline_cache_incremental_mode: bool = false,
        VK_EXT_shader_uniform_buffer_unsized_array: bool = false,
        VK_NV_compute_occupancy_priority: bool = false,
    } = .{},

    const Self = @This();

    pub fn init(
        tmp_alloc: Allocator,
        api_version: vk.ApiVersion,
        instance_extensions: []const [*c]const u8,
        device_extensions: []const [*c]const u8,
    ) !Self {
        const ie = try tmp_alloc.alloc([]const u8, instance_extensions.len);
        for (instance_extensions, ie) |a, *b| b.* = std.mem.span(a);
        const de = try tmp_alloc.alloc([]const u8, device_extensions.len);
        for (device_extensions, de) |a, *b| b.* = std.mem.span(a);
        var self: Self = .{};
        if (!api_version.less(vk.VK_API_VERSION_1_1)) {
            self.instance.VK_KHR_get_physical_device_properties2 = true;
            self.instance.VK_KHR_device_group_creation = true;
            self.instance.VK_KHR_external_memory_capabilities = true;
            self.instance.VK_KHR_external_semaphore_capabilities = true;
            self.instance.VK_KHR_external_fence_capabilities = true;
            self.device.VK_KHR_multiview = true;
            self.device.VK_KHR_device_group = true;
            self.device.VK_KHR_shader_draw_parameters = true;
            self.device.VK_KHR_maintenance1 = true;
            self.device.VK_KHR_external_memory = true;
            self.device.VK_KHR_external_semaphore = true;
            self.device.VK_KHR_16bit_storage = true;
            self.device.VK_KHR_descriptor_update_template = true;
            self.device.VK_KHR_external_fence = true;
            self.device.VK_KHR_maintenance2 = true;
            self.device.VK_KHR_variable_pointers = true;
            self.device.VK_KHR_dedicated_allocation = true;
            self.device.VK_KHR_storage_buffer_storage_class = true;
            self.device.VK_KHR_relaxed_block_layout = true;
            self.device.VK_KHR_get_memory_requirements2 = true;
            self.device.VK_KHR_sampler_ycbcr_conversion = true;
            self.device.VK_KHR_bind_memory2 = true;
            self.device.VK_KHR_maintenance3 = true;
        }
        if (!api_version.less(vk.VK_API_VERSION_1_2)) {
            self.device.VK_KHR_sampler_mirror_clamp_to_edge = true;
            self.device.VK_KHR_shader_float16_int8 = true;
            self.device.VK_KHR_imageless_framebuffer = true;
            self.device.VK_KHR_create_renderpass2 = true;
            self.device.VK_EXT_sampler_filter_minmax = true;
            self.device.VK_KHR_image_format_list = true;
            self.device.VK_EXT_descriptor_indexing = true;
            self.device.VK_EXT_shader_viewport_index_layer = true;
            self.device.VK_KHR_draw_indirect_count = true;
            self.device.VK_KHR_shader_subgroup_extended_types = true;
            self.device.VK_KHR_8bit_storage = true;
            self.device.VK_KHR_shader_atomic_int64 = true;
            self.device.VK_KHR_driver_properties = true;
            self.device.VK_KHR_shader_float_controls = true;
            self.device.VK_KHR_depth_stencil_resolve = true;
            self.device.VK_KHR_timeline_semaphore = true;
            self.device.VK_KHR_vulkan_memory_model = true;
            self.device.VK_EXT_scalar_block_layout = true;
            self.device.VK_KHR_spirv_1_4 = true;
            self.device.VK_KHR_separate_depth_stencil_layouts = true;
            self.device.VK_EXT_separate_stencil_usage = true;
            self.device.VK_KHR_uniform_buffer_standard_layout = true;
            self.device.VK_KHR_buffer_device_address = true;
            self.device.VK_EXT_host_query_reset = true;
        }
        if (!api_version.less(vk.VK_API_VERSION_1_3)) {
            self.device.VK_KHR_dynamic_rendering = true;
            self.device.VK_EXT_texture_compression_astc_hdr = true;
            self.device.VK_EXT_inline_uniform_block = true;
            self.device.VK_EXT_pipeline_creation_feedback = true;
            self.device.VK_KHR_shader_terminate_invocation = true;
            self.device.VK_EXT_subgroup_size_control = true;
            self.device.VK_EXT_tooling_info = true;
            self.device.VK_EXT_extended_dynamic_state = true;
            self.device.VK_EXT_shader_demote_to_helper_invocation = true;
            self.device.VK_KHR_shader_integer_dot_product = true;
            self.device.VK_EXT_texel_buffer_alignment = true;
            self.device.VK_KHR_shader_non_semantic_info = true;
            self.device.VK_EXT_private_data = true;
            self.device.VK_EXT_pipeline_creation_cache_control = true;
            self.device.VK_KHR_synchronization2 = true;
            self.device.VK_KHR_zero_initialize_workgroup_memory = true;
            self.device.VK_EXT_ycbcr_2plane_444_formats = true;
            self.device.VK_EXT_image_robustness = true;
            self.device.VK_KHR_copy_commands2 = true;
            self.device.VK_EXT_4444_formats = true;
            self.device.VK_KHR_format_feature_flags2 = true;
            self.device.VK_EXT_extended_dynamic_state2 = true;
            self.device.VK_KHR_maintenance4 = true;
        }
        if (!api_version.less(vk.VK_API_VERSION_1_4)) {
            self.device.VK_EXT_pipeline_robustness = true;
            self.device.VK_KHR_push_descriptor = true;
            self.device.VK_KHR_global_priority = true;
            self.device.VK_KHR_dynamic_rendering_local_read = true;
            self.device.VK_EXT_host_image_copy = true;
            self.device.VK_KHR_map_memory2 = true;
            self.device.VK_KHR_shader_subgroup_rotate = true;
            self.device.VK_EXT_pipeline_protected_access = true;
            self.device.VK_KHR_maintenance5 = true;
            self.device.VK_KHR_vertex_attribute_divisor = true;
            self.device.VK_KHR_load_store_op_none = true;
            self.device.VK_KHR_shader_float_controls2 = true;
            self.device.VK_KHR_index_type_uint8 = true;
            self.device.VK_KHR_line_rasterization = true;
            self.device.VK_KHR_shader_expect_assume = true;
            self.device.VK_KHR_maintenance6 = true;
        }
        // Instance extensions
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_surface")) {
                self.instance.VK_KHR_surface = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_display") and (self.instance.VK_KHR_surface)) {
                self.instance.VK_KHR_display = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_xlib_surface") and (self.instance.VK_KHR_surface)) {
                self.instance.VK_KHR_xlib_surface = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_xcb_surface") and (self.instance.VK_KHR_surface)) {
                self.instance.VK_KHR_xcb_surface = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_wayland_surface") and (self.instance.VK_KHR_surface)) {
                self.instance.VK_KHR_wayland_surface = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_android_surface") and (self.instance.VK_KHR_surface)) {
                self.instance.VK_KHR_android_surface = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_win32_surface") and (self.instance.VK_KHR_surface)) {
                self.instance.VK_KHR_win32_surface = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_debug_report")) {
                self.instance.VK_EXT_debug_report = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_GGP_stream_descriptor_surface") and (self.instance.VK_KHR_surface)) {
                self.instance.VK_GGP_stream_descriptor_surface = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_NV_external_memory_capabilities")) {
                self.instance.VK_NV_external_memory_capabilities = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_get_physical_device_properties2")) {
                self.instance.VK_KHR_get_physical_device_properties2 = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_validation_flags")) {
                self.instance.VK_EXT_validation_flags = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_NN_vi_surface") and (self.instance.VK_KHR_surface)) {
                self.instance.VK_NN_vi_surface = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_device_group_creation")) {
                self.instance.VK_KHR_device_group_creation = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_external_memory_capabilities") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.instance.VK_KHR_external_memory_capabilities = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_external_semaphore_capabilities") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.instance.VK_KHR_external_semaphore_capabilities = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_direct_mode_display") and (self.instance.VK_KHR_display)) {
                self.instance.VK_EXT_direct_mode_display = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_acquire_xlib_display") and (self.instance.VK_EXT_direct_mode_display)) {
                self.instance.VK_EXT_acquire_xlib_display = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_display_surface_counter") and (self.instance.VK_KHR_display)) {
                self.instance.VK_EXT_display_surface_counter = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_swapchain_colorspace") and (self.instance.VK_KHR_surface)) {
                self.instance.VK_EXT_swapchain_colorspace = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_external_fence_capabilities") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.instance.VK_KHR_external_fence_capabilities = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_get_surface_capabilities2") and (self.instance.VK_KHR_surface)) {
                self.instance.VK_KHR_get_surface_capabilities2 = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_get_display_properties2") and (self.instance.VK_KHR_display)) {
                self.instance.VK_KHR_get_display_properties2 = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_MVK_ios_surface") and (self.instance.VK_KHR_surface)) {
                self.instance.VK_MVK_ios_surface = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_MVK_macos_surface") and (self.instance.VK_KHR_surface)) {
                self.instance.VK_MVK_macos_surface = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_debug_utils")) {
                self.instance.VK_EXT_debug_utils = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_FUCHSIA_imagepipe_surface") and (self.instance.VK_KHR_surface)) {
                self.instance.VK_FUCHSIA_imagepipe_surface = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_metal_surface") and (self.instance.VK_KHR_surface)) {
                self.instance.VK_EXT_metal_surface = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_surface_protected_capabilities") and (!api_version.less(vk.VK_API_VERSION_1_1) and self.instance.VK_KHR_get_surface_capabilities2)) {
                self.instance.VK_KHR_surface_protected_capabilities = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_validation_features")) {
                self.instance.VK_EXT_validation_features = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_headless_surface") and (self.instance.VK_KHR_surface)) {
                self.instance.VK_EXT_headless_surface = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_surface_maintenance1") and (self.instance.VK_KHR_surface and self.instance.VK_KHR_get_surface_capabilities2)) {
                self.instance.VK_EXT_surface_maintenance1 = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_acquire_drm_display") and (self.instance.VK_EXT_direct_mode_display)) {
                self.instance.VK_EXT_acquire_drm_display = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_directfb_surface") and (self.instance.VK_KHR_surface)) {
                self.instance.VK_EXT_directfb_surface = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_QNX_screen_surface") and (self.instance.VK_KHR_surface)) {
                self.instance.VK_QNX_screen_surface = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_portability_enumeration")) {
                self.instance.VK_KHR_portability_enumeration = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_GOOGLE_surfaceless_query") and (self.instance.VK_KHR_surface)) {
                self.instance.VK_GOOGLE_surfaceless_query = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_application_parameters")) {
                self.instance.VK_EXT_application_parameters = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_LUNARG_direct_driver_loading")) {
                self.instance.VK_LUNARG_direct_driver_loading = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_surface_maintenance1") and (self.instance.VK_KHR_surface or self.instance.VK_KHR_get_surface_capabilities2)) {
                self.instance.VK_KHR_surface_maintenance1 = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_layer_settings")) {
                self.instance.VK_EXT_layer_settings = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_NV_display_stereo") and (self.instance.VK_KHR_display and self.instance.VK_KHR_get_display_properties2)) {
                self.instance.VK_NV_display_stereo = true;
                break;
            }
        }
        for (ie) |ext| {
            if (std.mem.eql(u8, ext, "VK_OHOS_surface") and (self.instance.VK_KHR_surface)) {
                self.instance.VK_OHOS_surface = true;
                break;
            }
        }
        // Device extensions
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_swapchain") and (self.instance.VK_KHR_surface)) {
                self.device.VK_KHR_swapchain = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_display_swapchain") and (self.device.VK_KHR_swapchain and self.instance.VK_KHR_display)) {
                self.device.VK_KHR_display_swapchain = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_NV_glsl_shader")) {
                self.device.VK_NV_glsl_shader = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_depth_range_unrestricted")) {
                self.device.VK_EXT_depth_range_unrestricted = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_sampler_mirror_clamp_to_edge")) {
                self.device.VK_KHR_sampler_mirror_clamp_to_edge = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_IMG_filter_cubic")) {
                self.device.VK_IMG_filter_cubic = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_AMD_rasterization_order")) {
                self.device.VK_AMD_rasterization_order = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_AMD_shader_trinary_minmax")) {
                self.device.VK_AMD_shader_trinary_minmax = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_AMD_shader_explicit_vertex_parameter")) {
                self.device.VK_AMD_shader_explicit_vertex_parameter = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_debug_marker") and (self.instance.VK_EXT_debug_report)) {
                self.device.VK_EXT_debug_marker = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_video_queue") and ((!api_version.less(vk.VK_API_VERSION_1_1) and self.device.VK_KHR_synchronization2) or !api_version.less(vk.VK_API_VERSION_1_3))) {
                self.device.VK_KHR_video_queue = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_video_decode_queue") and (self.device.VK_KHR_video_queue and (self.device.VK_KHR_synchronization2 or !api_version.less(vk.VK_API_VERSION_1_3)))) {
                self.device.VK_KHR_video_decode_queue = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_AMD_gcn_shader")) {
                self.device.VK_AMD_gcn_shader = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_NV_dedicated_allocation")) {
                self.device.VK_NV_dedicated_allocation = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_transform_feedback") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_EXT_transform_feedback = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_NVX_binary_import")) {
                self.device.VK_NVX_binary_import = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_NVX_image_view_handle")) {
                self.device.VK_NVX_image_view_handle = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_AMD_draw_indirect_count")) {
                self.device.VK_AMD_draw_indirect_count = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_AMD_negative_viewport_height")) {
                self.device.VK_AMD_negative_viewport_height = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_AMD_gpu_shader_half_float")) {
                self.device.VK_AMD_gpu_shader_half_float = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_AMD_shader_ballot")) {
                self.device.VK_AMD_shader_ballot = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_video_encode_h264") and (self.device.VK_KHR_video_encode_queue)) {
                self.device.VK_KHR_video_encode_h264 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_video_encode_h265") and (self.device.VK_KHR_video_encode_queue)) {
                self.device.VK_KHR_video_encode_h265 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_video_decode_h264") and (self.device.VK_KHR_video_decode_queue)) {
                self.device.VK_KHR_video_decode_h264 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_AMD_texture_gather_bias_lod") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_AMD_texture_gather_bias_lod = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_AMD_shader_info")) {
                self.device.VK_AMD_shader_info = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_dynamic_rendering") and (((self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1)) and self.device.VK_KHR_depth_stencil_resolve) or !api_version.less(vk.VK_API_VERSION_1_2))) {
                self.device.VK_KHR_dynamic_rendering = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_AMD_shader_image_load_store_lod")) {
                self.device.VK_AMD_shader_image_load_store_lod = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_NV_corner_sampled_image") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_NV_corner_sampled_image = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_NV_private_vendor_info")) {
                self.device.VK_NV_private_vendor_info = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_multiview") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_KHR_multiview = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_IMG_format_pvrtc")) {
                self.device.VK_IMG_format_pvrtc = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_NV_external_memory") and (self.instance.VK_NV_external_memory_capabilities)) {
                self.device.VK_NV_external_memory = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_NV_external_memory_win32") and (self.device.VK_NV_external_memory)) {
                self.device.VK_NV_external_memory_win32 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_NV_win32_keyed_mutex") and (self.device.VK_NV_external_memory_win32)) {
                self.device.VK_NV_win32_keyed_mutex = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_device_group") and (self.instance.VK_KHR_device_group_creation)) {
                self.device.VK_KHR_device_group = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_shader_draw_parameters")) {
                self.device.VK_KHR_shader_draw_parameters = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_shader_subgroup_ballot")) {
                self.device.VK_EXT_shader_subgroup_ballot = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_shader_subgroup_vote")) {
                self.device.VK_EXT_shader_subgroup_vote = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_texture_compression_astc_hdr") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_EXT_texture_compression_astc_hdr = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_astc_decode_mode") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_EXT_astc_decode_mode = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_pipeline_robustness") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_EXT_pipeline_robustness = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_maintenance1")) {
                self.device.VK_KHR_maintenance1 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_external_memory") and (self.instance.VK_KHR_external_memory_capabilities or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_KHR_external_memory = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_external_memory_win32") and (self.device.VK_KHR_external_memory or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_KHR_external_memory_win32 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_external_memory_fd") and (self.device.VK_KHR_external_memory or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_KHR_external_memory_fd = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_win32_keyed_mutex") and (self.device.VK_KHR_external_memory_win32)) {
                self.device.VK_KHR_win32_keyed_mutex = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_external_semaphore") and (self.instance.VK_KHR_external_semaphore_capabilities)) {
                self.device.VK_KHR_external_semaphore = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_external_semaphore_win32") and (self.device.VK_KHR_external_semaphore)) {
                self.device.VK_KHR_external_semaphore_win32 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_external_semaphore_fd") and (self.device.VK_KHR_external_semaphore or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_KHR_external_semaphore_fd = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_push_descriptor") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_KHR_push_descriptor = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_conditional_rendering") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_EXT_conditional_rendering = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_shader_float16_int8") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_KHR_shader_float16_int8 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_16bit_storage") and ((self.instance.VK_KHR_get_physical_device_properties2 and self.device.VK_KHR_storage_buffer_storage_class) or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_KHR_16bit_storage = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_incremental_present") and (self.device.VK_KHR_swapchain)) {
                self.device.VK_KHR_incremental_present = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_descriptor_update_template")) {
                self.device.VK_KHR_descriptor_update_template = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_NV_clip_space_w_scaling")) {
                self.device.VK_NV_clip_space_w_scaling = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_display_control") and (self.instance.VK_EXT_display_surface_counter and self.device.VK_KHR_swapchain)) {
                self.device.VK_EXT_display_control = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_GOOGLE_display_timing") and (self.device.VK_KHR_swapchain)) {
                self.device.VK_GOOGLE_display_timing = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_NV_sample_mask_override_coverage")) {
                self.device.VK_NV_sample_mask_override_coverage = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_NV_geometry_shader_passthrough")) {
                self.device.VK_NV_geometry_shader_passthrough = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_NV_viewport_array2")) {
                self.device.VK_NV_viewport_array2 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_NVX_multiview_per_view_attributes") and (self.device.VK_KHR_multiview or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_NVX_multiview_per_view_attributes = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_NV_viewport_swizzle")) {
                self.device.VK_NV_viewport_swizzle = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_discard_rectangles") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_EXT_discard_rectangles = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_conservative_rasterization") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_EXT_conservative_rasterization = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_depth_clip_enable") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_EXT_depth_clip_enable = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_hdr_metadata") and (self.device.VK_KHR_swapchain)) {
                self.device.VK_EXT_hdr_metadata = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_imageless_framebuffer") and ((((self.instance.VK_KHR_get_physical_device_properties2 and self.device.VK_KHR_maintenance2) or !api_version.less(vk.VK_API_VERSION_1_1)) and self.device.VK_KHR_image_format_list) or !api_version.less(vk.VK_API_VERSION_1_2))) {
                self.device.VK_KHR_imageless_framebuffer = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_create_renderpass2") and ((self.device.VK_KHR_multiview and self.device.VK_KHR_maintenance2) or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_KHR_create_renderpass2 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_IMG_relaxed_line_rasterization") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_IMG_relaxed_line_rasterization = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_shared_presentable_image") and (self.device.VK_KHR_swapchain and self.instance.VK_KHR_get_surface_capabilities2 and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1)))) {
                self.device.VK_KHR_shared_presentable_image = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_external_fence") and (self.instance.VK_KHR_external_fence_capabilities)) {
                self.device.VK_KHR_external_fence = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_external_fence_win32") and (self.device.VK_KHR_external_fence)) {
                self.device.VK_KHR_external_fence_win32 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_external_fence_fd") and (self.device.VK_KHR_external_fence or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_KHR_external_fence_fd = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_performance_query") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_KHR_performance_query = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_maintenance2")) {
                self.device.VK_KHR_maintenance2 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_variable_pointers") and ((self.instance.VK_KHR_get_physical_device_properties2 and self.device.VK_KHR_storage_buffer_storage_class) or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_KHR_variable_pointers = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_external_memory_dma_buf") and (self.device.VK_KHR_external_memory_fd)) {
                self.device.VK_EXT_external_memory_dma_buf = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_queue_family_foreign") and (self.device.VK_KHR_external_memory or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_EXT_queue_family_foreign = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_dedicated_allocation") and (self.device.VK_KHR_get_memory_requirements2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_KHR_dedicated_allocation = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_ANDROID_external_memory_android_hardware_buffer") and (((self.device.VK_KHR_sampler_ycbcr_conversion and self.device.VK_KHR_external_memory and self.device.VK_KHR_dedicated_allocation) or !api_version.less(vk.VK_API_VERSION_1_1)) and self.device.VK_EXT_queue_family_foreign)) {
                self.device.VK_ANDROID_external_memory_android_hardware_buffer = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_sampler_filter_minmax") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_EXT_sampler_filter_minmax = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_storage_buffer_storage_class")) {
                self.device.VK_KHR_storage_buffer_storage_class = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_AMD_gpu_shader_int16")) {
                self.device.VK_AMD_gpu_shader_int16 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_AMDX_shader_enqueue") and (((self.device.VK_KHR_synchronization2 and self.device.VK_KHR_spirv_1_4 and self.device.VK_EXT_extended_dynamic_state) or !api_version.less(vk.VK_API_VERSION_1_3)) and self.device.VK_KHR_maintenance5 and self.device.VK_KHR_pipeline_library)) {
                self.device.VK_AMDX_shader_enqueue = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_AMD_mixed_attachment_samples")) {
                self.device.VK_AMD_mixed_attachment_samples = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_AMD_shader_fragment_mask")) {
                self.device.VK_AMD_shader_fragment_mask = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_inline_uniform_block") and ((self.instance.VK_KHR_get_physical_device_properties2 and self.device.VK_KHR_maintenance1) or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_EXT_inline_uniform_block = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_shader_stencil_export")) {
                self.device.VK_EXT_shader_stencil_export = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_shader_bfloat16") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_KHR_shader_bfloat16 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_sample_locations") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_EXT_sample_locations = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_relaxed_block_layout")) {
                self.device.VK_KHR_relaxed_block_layout = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_get_memory_requirements2")) {
                self.device.VK_KHR_get_memory_requirements2 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_image_format_list")) {
                self.device.VK_KHR_image_format_list = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_blend_operation_advanced") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_EXT_blend_operation_advanced = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_NV_fragment_coverage_to_color")) {
                self.device.VK_NV_fragment_coverage_to_color = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_acceleration_structure") and (((!api_version.less(vk.VK_API_VERSION_1_1) and self.device.VK_EXT_descriptor_indexing and self.device.VK_KHR_buffer_device_address) or !api_version.less(vk.VK_API_VERSION_1_2)) and self.device.VK_KHR_deferred_host_operations)) {
                self.device.VK_KHR_acceleration_structure = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_ray_tracing_pipeline") and ((self.device.VK_KHR_spirv_1_4 or !api_version.less(vk.VK_API_VERSION_1_2)) and self.device.VK_KHR_acceleration_structure)) {
                self.device.VK_KHR_ray_tracing_pipeline = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_ray_query") and ((self.device.VK_KHR_spirv_1_4 or !api_version.less(vk.VK_API_VERSION_1_2)) and self.device.VK_KHR_acceleration_structure)) {
                self.device.VK_KHR_ray_query = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_NV_framebuffer_mixed_samples")) {
                self.device.VK_NV_framebuffer_mixed_samples = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_NV_fill_rectangle")) {
                self.device.VK_NV_fill_rectangle = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_NV_shader_sm_builtins") and (!api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_NV_shader_sm_builtins = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_post_depth_coverage")) {
                self.device.VK_EXT_post_depth_coverage = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_sampler_ycbcr_conversion") and ((self.device.VK_KHR_maintenance1 and self.device.VK_KHR_bind_memory2 and self.device.VK_KHR_get_memory_requirements2 and self.instance.VK_KHR_get_physical_device_properties2) or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_KHR_sampler_ycbcr_conversion = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_bind_memory2")) {
                self.device.VK_KHR_bind_memory2 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_image_drm_format_modifier") and ((((self.device.VK_KHR_bind_memory2 and self.instance.VK_KHR_get_physical_device_properties2 and self.device.VK_KHR_sampler_ycbcr_conversion) or !api_version.less(vk.VK_API_VERSION_1_1)) and self.device.VK_KHR_image_format_list) or !api_version.less(vk.VK_API_VERSION_1_2))) {
                self.device.VK_EXT_image_drm_format_modifier = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_validation_cache")) {
                self.device.VK_EXT_validation_cache = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_descriptor_indexing") and ((self.instance.VK_KHR_get_physical_device_properties2 and self.device.VK_KHR_maintenance3) or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_EXT_descriptor_indexing = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_shader_viewport_index_layer")) {
                self.device.VK_EXT_shader_viewport_index_layer = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_portability_subset") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_KHR_portability_subset = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_NV_shading_rate_image") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_NV_shading_rate_image = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_NV_ray_tracing") and ((self.instance.VK_KHR_get_physical_device_properties2 and self.device.VK_KHR_get_memory_requirements2) or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_NV_ray_tracing = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_NV_representative_fragment_test") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_NV_representative_fragment_test = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_maintenance3") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_KHR_maintenance3 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_draw_indirect_count")) {
                self.device.VK_KHR_draw_indirect_count = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_filter_cubic")) {
                self.device.VK_EXT_filter_cubic = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_QCOM_render_pass_shader_resolve")) {
                self.device.VK_QCOM_render_pass_shader_resolve = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_global_priority")) {
                self.device.VK_EXT_global_priority = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_shader_subgroup_extended_types") and (!api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_KHR_shader_subgroup_extended_types = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_8bit_storage") and ((self.instance.VK_KHR_get_physical_device_properties2 and self.device.VK_KHR_storage_buffer_storage_class) or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_KHR_8bit_storage = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_external_memory_host") and (self.device.VK_KHR_external_memory or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_EXT_external_memory_host = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_AMD_buffer_marker")) {
                self.device.VK_AMD_buffer_marker = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_shader_atomic_int64") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_KHR_shader_atomic_int64 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_shader_clock") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_KHR_shader_clock = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_AMD_pipeline_compiler_control")) {
                self.device.VK_AMD_pipeline_compiler_control = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_calibrated_timestamps") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_EXT_calibrated_timestamps = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_AMD_shader_core_properties") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_AMD_shader_core_properties = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_video_decode_h265") and (self.device.VK_KHR_video_decode_queue)) {
                self.device.VK_KHR_video_decode_h265 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_global_priority") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_KHR_global_priority = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_AMD_memory_overallocation_behavior")) {
                self.device.VK_AMD_memory_overallocation_behavior = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_vertex_attribute_divisor") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_EXT_vertex_attribute_divisor = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_GGP_frame_token") and (self.device.VK_KHR_swapchain and self.instance.VK_GGP_stream_descriptor_surface)) {
                self.device.VK_GGP_frame_token = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_pipeline_creation_feedback")) {
                self.device.VK_EXT_pipeline_creation_feedback = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_driver_properties") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_KHR_driver_properties = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_shader_float_controls") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_KHR_shader_float_controls = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_NV_shader_subgroup_partitioned") and (!api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_NV_shader_subgroup_partitioned = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_depth_stencil_resolve") and (self.device.VK_KHR_create_renderpass2 or !api_version.less(vk.VK_API_VERSION_1_2))) {
                self.device.VK_KHR_depth_stencil_resolve = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_swapchain_mutable_format") and (self.device.VK_KHR_swapchain and (self.device.VK_KHR_maintenance2 or !api_version.less(vk.VK_API_VERSION_1_1)) and (self.device.VK_KHR_image_format_list or !api_version.less(vk.VK_API_VERSION_1_2)))) {
                self.device.VK_KHR_swapchain_mutable_format = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_NV_compute_shader_derivatives") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_NV_compute_shader_derivatives = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_NV_mesh_shader") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_NV_mesh_shader = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_NV_fragment_shader_barycentric") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_NV_fragment_shader_barycentric = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_NV_shader_image_footprint") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_NV_shader_image_footprint = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_NV_scissor_exclusive") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_NV_scissor_exclusive = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_NV_device_diagnostic_checkpoints") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_NV_device_diagnostic_checkpoints = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_timeline_semaphore") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_KHR_timeline_semaphore = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_present_timing") and (self.device.VK_KHR_swapchain and self.device.VK_KHR_present_id2 and self.instance.VK_KHR_get_surface_capabilities2 and self.device.VK_KHR_calibrated_timestamps)) {
                self.device.VK_EXT_present_timing = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_INTEL_shader_integer_functions2") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_INTEL_shader_integer_functions2 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_INTEL_performance_query")) {
                self.device.VK_INTEL_performance_query = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_vulkan_memory_model") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_KHR_vulkan_memory_model = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_pci_bus_info") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_EXT_pci_bus_info = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_AMD_display_native_hdr") and ((self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1)) and self.instance.VK_KHR_get_surface_capabilities2 and self.device.VK_KHR_swapchain)) {
                self.device.VK_AMD_display_native_hdr = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_shader_terminate_invocation") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_KHR_shader_terminate_invocation = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_fragment_density_map") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_EXT_fragment_density_map = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_scalar_block_layout") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_EXT_scalar_block_layout = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_GOOGLE_hlsl_functionality1")) {
                self.device.VK_GOOGLE_hlsl_functionality1 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_GOOGLE_decorate_string")) {
                self.device.VK_GOOGLE_decorate_string = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_subgroup_size_control") and (!api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_EXT_subgroup_size_control = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_fragment_shading_rate") and (((self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1)) and self.device.VK_KHR_create_renderpass2) or !api_version.less(vk.VK_API_VERSION_1_2))) {
                self.device.VK_KHR_fragment_shading_rate = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_AMD_shader_core_properties2") and (self.device.VK_AMD_shader_core_properties)) {
                self.device.VK_AMD_shader_core_properties2 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_AMD_device_coherent_memory") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_AMD_device_coherent_memory = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_dynamic_rendering_local_read") and (self.device.VK_KHR_dynamic_rendering or !api_version.less(vk.VK_API_VERSION_1_3))) {
                self.device.VK_KHR_dynamic_rendering_local_read = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_shader_image_atomic_int64") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_EXT_shader_image_atomic_int64 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_shader_quad_control") and (((!api_version.less(vk.VK_API_VERSION_1_1) and self.device.VK_KHR_vulkan_memory_model) or !api_version.less(vk.VK_API_VERSION_1_2)) and self.device.VK_KHR_shader_maximal_reconvergence)) {
                self.device.VK_KHR_shader_quad_control = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_spirv_1_4") and (!api_version.less(vk.VK_API_VERSION_1_1) and self.device.VK_KHR_shader_float_controls)) {
                self.device.VK_KHR_spirv_1_4 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_memory_budget") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_EXT_memory_budget = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_memory_priority") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_EXT_memory_priority = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_NV_dedicated_allocation_image_aliasing") and ((self.device.VK_KHR_dedicated_allocation and self.instance.VK_KHR_get_physical_device_properties2) or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_NV_dedicated_allocation_image_aliasing = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_separate_depth_stencil_layouts") and (((self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1)) and self.device.VK_KHR_create_renderpass2) or !api_version.less(vk.VK_API_VERSION_1_2))) {
                self.device.VK_KHR_separate_depth_stencil_layouts = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_buffer_device_address") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_EXT_buffer_device_address = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_tooling_info")) {
                self.device.VK_EXT_tooling_info = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_separate_stencil_usage")) {
                self.device.VK_EXT_separate_stencil_usage = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_present_wait") and (self.device.VK_KHR_swapchain and self.device.VK_KHR_present_id)) {
                self.device.VK_KHR_present_wait = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_NV_cooperative_matrix") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_NV_cooperative_matrix = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_NV_coverage_reduction_mode") and (self.device.VK_NV_framebuffer_mixed_samples and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1)))) {
                self.device.VK_NV_coverage_reduction_mode = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_fragment_shader_interlock") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_EXT_fragment_shader_interlock = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_ycbcr_image_arrays") and (self.device.VK_KHR_sampler_ycbcr_conversion or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_EXT_ycbcr_image_arrays = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_uniform_buffer_standard_layout") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_KHR_uniform_buffer_standard_layout = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_provoking_vertex") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_EXT_provoking_vertex = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_full_screen_exclusive") and ((self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1)) and self.instance.VK_KHR_surface and self.instance.VK_KHR_get_surface_capabilities2 and self.device.VK_KHR_swapchain)) {
                self.device.VK_EXT_full_screen_exclusive = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_buffer_device_address") and ((self.instance.VK_KHR_get_physical_device_properties2 and self.device.VK_KHR_device_group) or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_KHR_buffer_device_address = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_line_rasterization") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_EXT_line_rasterization = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_shader_atomic_float") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_EXT_shader_atomic_float = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_host_query_reset") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_EXT_host_query_reset = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_index_type_uint8") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_EXT_index_type_uint8 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_extended_dynamic_state") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_EXT_extended_dynamic_state = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_deferred_host_operations")) {
                self.device.VK_KHR_deferred_host_operations = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_pipeline_executable_properties") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_KHR_pipeline_executable_properties = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_host_image_copy") and (((self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1)) and self.device.VK_KHR_copy_commands2 and self.device.VK_KHR_format_feature_flags2) or !api_version.less(vk.VK_API_VERSION_1_3))) {
                self.device.VK_EXT_host_image_copy = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_map_memory2")) {
                self.device.VK_KHR_map_memory2 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_map_memory_placed") and (self.device.VK_KHR_map_memory2 or !api_version.less(vk.VK_API_VERSION_1_4))) {
                self.device.VK_EXT_map_memory_placed = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_shader_atomic_float2") and (self.device.VK_EXT_shader_atomic_float)) {
                self.device.VK_EXT_shader_atomic_float2 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_swapchain_maintenance1") and (self.device.VK_KHR_swapchain and self.instance.VK_EXT_surface_maintenance1 and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1)))) {
                self.device.VK_EXT_swapchain_maintenance1 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_shader_demote_to_helper_invocation") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_EXT_shader_demote_to_helper_invocation = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_NV_device_generated_commands") and ((!api_version.less(vk.VK_API_VERSION_1_1) and self.device.VK_KHR_buffer_device_address) or !api_version.less(vk.VK_API_VERSION_1_2))) {
                self.device.VK_NV_device_generated_commands = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_NV_inherited_viewport_scissor") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_NV_inherited_viewport_scissor = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_shader_integer_dot_product") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_KHR_shader_integer_dot_product = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_texel_buffer_alignment") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_EXT_texel_buffer_alignment = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_QCOM_render_pass_transform")) {
                self.device.VK_QCOM_render_pass_transform = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_depth_bias_control") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_EXT_depth_bias_control = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_device_memory_report") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_EXT_device_memory_report = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_robustness2") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_EXT_robustness2 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_custom_border_color") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_EXT_custom_border_color = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_GOOGLE_user_type")) {
                self.device.VK_GOOGLE_user_type = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_pipeline_library")) {
                self.device.VK_KHR_pipeline_library = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_NV_present_barrier") and ((self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1)) and self.instance.VK_KHR_surface and self.instance.VK_KHR_get_surface_capabilities2 and self.device.VK_KHR_swapchain)) {
                self.device.VK_NV_present_barrier = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_shader_non_semantic_info")) {
                self.device.VK_KHR_shader_non_semantic_info = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_present_id") and (self.device.VK_KHR_swapchain and self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_KHR_present_id = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_private_data") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_EXT_private_data = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_pipeline_creation_cache_control") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_EXT_pipeline_creation_cache_control = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_video_encode_queue") and (self.device.VK_KHR_video_queue and (self.device.VK_KHR_synchronization2 or !api_version.less(vk.VK_API_VERSION_1_3)))) {
                self.device.VK_KHR_video_encode_queue = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_NV_device_diagnostics_config") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_NV_device_diagnostics_config = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_QCOM_render_pass_store_ops")) {
                self.device.VK_QCOM_render_pass_store_ops = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_NV_cuda_kernel_launch") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_NV_cuda_kernel_launch = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_object_refresh")) {
                self.device.VK_KHR_object_refresh = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_QCOM_tile_shading") and (self.device.VK_QCOM_tile_properties or self.instance.VK_KHR_get_physical_device_properties2)) {
                self.device.VK_QCOM_tile_shading = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_NV_low_latency")) {
                self.device.VK_NV_low_latency = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_metal_objects")) {
                self.device.VK_EXT_metal_objects = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_synchronization2") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_KHR_synchronization2 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_descriptor_buffer") and (((((self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1)) and self.device.VK_KHR_buffer_device_address and self.device.VK_EXT_descriptor_indexing) or !api_version.less(vk.VK_API_VERSION_1_2)) and self.device.VK_KHR_synchronization2) or !api_version.less(vk.VK_API_VERSION_1_3))) {
                self.device.VK_EXT_descriptor_buffer = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_graphics_pipeline_library") and ((self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1)) and self.device.VK_KHR_pipeline_library)) {
                self.device.VK_EXT_graphics_pipeline_library = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_AMD_shader_early_and_late_fragment_tests") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_AMD_shader_early_and_late_fragment_tests = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_fragment_shader_barycentric") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_KHR_fragment_shader_barycentric = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_shader_subgroup_uniform_control_flow") and (!api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_KHR_shader_subgroup_uniform_control_flow = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_zero_initialize_workgroup_memory") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_KHR_zero_initialize_workgroup_memory = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_NV_fragment_shading_rate_enums") and (self.device.VK_KHR_fragment_shading_rate)) {
                self.device.VK_NV_fragment_shading_rate_enums = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_NV_ray_tracing_motion_blur") and (self.device.VK_KHR_ray_tracing_pipeline)) {
                self.device.VK_NV_ray_tracing_motion_blur = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_mesh_shader") and (self.device.VK_KHR_spirv_1_4 or !api_version.less(vk.VK_API_VERSION_1_2))) {
                self.device.VK_EXT_mesh_shader = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_ycbcr_2plane_444_formats") and (self.device.VK_KHR_sampler_ycbcr_conversion or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_EXT_ycbcr_2plane_444_formats = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_fragment_density_map2") and (self.device.VK_EXT_fragment_density_map)) {
                self.device.VK_EXT_fragment_density_map2 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_QCOM_rotated_copy_commands") and (self.device.VK_KHR_copy_commands2 or !api_version.less(vk.VK_API_VERSION_1_3))) {
                self.device.VK_QCOM_rotated_copy_commands = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_image_robustness") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_EXT_image_robustness = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_workgroup_memory_explicit_layout") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_KHR_workgroup_memory_explicit_layout = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_copy_commands2") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_KHR_copy_commands2 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_image_compression_control") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_EXT_image_compression_control = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_attachment_feedback_loop_layout") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_EXT_attachment_feedback_loop_layout = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_4444_formats") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_EXT_4444_formats = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_device_fault") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_EXT_device_fault = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_ARM_rasterization_order_attachment_access") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_ARM_rasterization_order_attachment_access = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_rgba10x6_formats") and (self.device.VK_KHR_sampler_ycbcr_conversion or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_EXT_rgba10x6_formats = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_NV_acquire_winrt_display") and (self.instance.VK_EXT_direct_mode_display)) {
                self.device.VK_NV_acquire_winrt_display = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_VALVE_mutable_descriptor_type") and (self.device.VK_KHR_maintenance3)) {
                self.device.VK_VALVE_mutable_descriptor_type = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_vertex_input_dynamic_state") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_EXT_vertex_input_dynamic_state = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_physical_device_drm") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_EXT_physical_device_drm = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_device_address_binding_report") and ((self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1)) and self.instance.VK_EXT_debug_utils)) {
                self.device.VK_EXT_device_address_binding_report = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_depth_clip_control") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_EXT_depth_clip_control = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_primitive_topology_list_restart") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_EXT_primitive_topology_list_restart = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_format_feature_flags2") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_KHR_format_feature_flags2 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_present_mode_fifo_latest_ready") and (self.device.VK_KHR_swapchain)) {
                self.device.VK_EXT_present_mode_fifo_latest_ready = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_FUCHSIA_external_memory") and ((self.instance.VK_KHR_external_memory_capabilities and self.device.VK_KHR_external_memory) or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_FUCHSIA_external_memory = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_FUCHSIA_external_semaphore") and (self.instance.VK_KHR_external_semaphore_capabilities and self.device.VK_KHR_external_semaphore)) {
                self.device.VK_FUCHSIA_external_semaphore = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_FUCHSIA_buffer_collection") and (self.device.VK_FUCHSIA_external_memory and (self.device.VK_KHR_sampler_ycbcr_conversion or !api_version.less(vk.VK_API_VERSION_1_1)))) {
                self.device.VK_FUCHSIA_buffer_collection = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_HUAWEI_subpass_shading") and (((self.device.VK_KHR_create_renderpass2 or !api_version.less(vk.VK_API_VERSION_1_2)) and self.device.VK_KHR_synchronization2) or !api_version.less(vk.VK_API_VERSION_1_3))) {
                self.device.VK_HUAWEI_subpass_shading = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_HUAWEI_invocation_mask") and (self.device.VK_KHR_ray_tracing_pipeline and (self.device.VK_KHR_synchronization2 or !api_version.less(vk.VK_API_VERSION_1_3)))) {
                self.device.VK_HUAWEI_invocation_mask = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_NV_external_memory_rdma") and (self.device.VK_KHR_external_memory or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_NV_external_memory_rdma = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_pipeline_properties") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_EXT_pipeline_properties = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_NV_external_sci_sync") and (!api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_NV_external_sci_sync = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_NV_external_memory_sci_buf") and (!api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_NV_external_memory_sci_buf = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_frame_boundary") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_EXT_frame_boundary = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_multisampled_render_to_single_sampled") and ((self.device.VK_KHR_create_renderpass2 and self.device.VK_KHR_depth_stencil_resolve) or !api_version.less(vk.VK_API_VERSION_1_2))) {
                self.device.VK_EXT_multisampled_render_to_single_sampled = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_extended_dynamic_state2") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_EXT_extended_dynamic_state2 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_color_write_enable") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_EXT_color_write_enable = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_primitives_generated_query") and (self.device.VK_EXT_transform_feedback)) {
                self.device.VK_EXT_primitives_generated_query = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_ray_tracing_maintenance1") and (self.device.VK_KHR_acceleration_structure)) {
                self.device.VK_KHR_ray_tracing_maintenance1 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_shader_untyped_pointers") and (self.instance.VK_KHR_get_physical_device_properties2)) {
                self.device.VK_KHR_shader_untyped_pointers = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_global_priority_query") and (self.device.VK_EXT_global_priority and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1)))) {
                self.device.VK_EXT_global_priority_query = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_VALVE_video_encode_rgb_conversion") and (self.device.VK_KHR_video_encode_queue and (self.device.VK_KHR_sampler_ycbcr_conversion or !api_version.less(vk.VK_API_VERSION_1_1)))) {
                self.device.VK_VALVE_video_encode_rgb_conversion = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_image_view_min_lod") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_EXT_image_view_min_lod = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_multi_draw") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_EXT_multi_draw = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_image_2d_view_of_3d") and ((self.device.VK_KHR_maintenance1 and self.instance.VK_KHR_get_physical_device_properties2) or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_EXT_image_2d_view_of_3d = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_shader_tile_image") and (!api_version.less(vk.VK_API_VERSION_1_3))) {
                self.device.VK_EXT_shader_tile_image = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_opacity_micromap") and (self.device.VK_KHR_acceleration_structure and (self.device.VK_KHR_synchronization2 or !api_version.less(vk.VK_API_VERSION_1_3)))) {
                self.device.VK_EXT_opacity_micromap = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_NV_displacement_micromap") and (self.device.VK_EXT_opacity_micromap)) {
                self.device.VK_NV_displacement_micromap = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_load_store_op_none")) {
                self.device.VK_EXT_load_store_op_none = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_HUAWEI_cluster_culling_shader") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_HUAWEI_cluster_culling_shader = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_border_color_swizzle") and (self.device.VK_EXT_custom_border_color)) {
                self.device.VK_EXT_border_color_swizzle = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_pageable_device_local_memory") and (self.device.VK_EXT_memory_priority)) {
                self.device.VK_EXT_pageable_device_local_memory = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_maintenance4") and (!api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_KHR_maintenance4 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_ARM_shader_core_properties") and (!api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_ARM_shader_core_properties = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_shader_subgroup_rotate") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_KHR_shader_subgroup_rotate = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_ARM_scheduling_controls") and (self.device.VK_ARM_shader_core_builtins)) {
                self.device.VK_ARM_scheduling_controls = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_image_sliced_view_of_3d") and ((self.device.VK_KHR_maintenance1 and self.instance.VK_KHR_get_physical_device_properties2) or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_EXT_image_sliced_view_of_3d = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_VALVE_descriptor_set_host_mapping") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_VALVE_descriptor_set_host_mapping = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_depth_clamp_zero_one") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_EXT_depth_clamp_zero_one = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_non_seamless_cube_map") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_EXT_non_seamless_cube_map = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_ARM_render_pass_striped") and (((self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1)) and self.device.VK_KHR_synchronization2) or !api_version.less(vk.VK_API_VERSION_1_3))) {
                self.device.VK_ARM_render_pass_striped = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_QCOM_fragment_density_map_offset") and ((self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1)) and self.device.VK_EXT_fragment_density_map)) {
                self.device.VK_QCOM_fragment_density_map_offset = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_NV_copy_memory_indirect") and (((self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1)) and self.device.VK_KHR_buffer_device_address) or !api_version.less(vk.VK_API_VERSION_1_2))) {
                self.device.VK_NV_copy_memory_indirect = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_NV_memory_decompression") and (((self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1)) and self.device.VK_KHR_buffer_device_address) or !api_version.less(vk.VK_API_VERSION_1_2))) {
                self.device.VK_NV_memory_decompression = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_NV_device_generated_commands_compute") and (self.device.VK_NV_device_generated_commands)) {
                self.device.VK_NV_device_generated_commands_compute = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_NV_ray_tracing_linear_swept_spheres") and (self.device.VK_KHR_ray_tracing_pipeline)) {
                self.device.VK_NV_ray_tracing_linear_swept_spheres = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_NV_linear_color_attachment") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_NV_linear_color_attachment = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_shader_maximal_reconvergence") and (!api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_KHR_shader_maximal_reconvergence = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_image_compression_control_swapchain") and (self.device.VK_EXT_image_compression_control)) {
                self.device.VK_EXT_image_compression_control_swapchain = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_QCOM_image_processing") and (self.device.VK_KHR_format_feature_flags2 or !api_version.less(vk.VK_API_VERSION_1_3))) {
                self.device.VK_QCOM_image_processing = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_nested_command_buffer") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_EXT_nested_command_buffer = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_OHOS_external_memory") and (((self.device.VK_KHR_sampler_ycbcr_conversion and self.device.VK_KHR_external_memory and self.device.VK_KHR_dedicated_allocation) or !api_version.less(vk.VK_API_VERSION_1_1)) and self.device.VK_EXT_queue_family_foreign)) {
                self.device.VK_OHOS_external_memory = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_external_memory_acquire_unmodified") and (self.device.VK_KHR_external_memory or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_EXT_external_memory_acquire_unmodified = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_extended_dynamic_state3") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_EXT_extended_dynamic_state3 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_subpass_merge_feedback") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_EXT_subpass_merge_feedback = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_ARM_tensors") and (!api_version.less(vk.VK_API_VERSION_1_3))) {
                self.device.VK_ARM_tensors = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_shader_module_identifier") and (((self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1)) and self.device.VK_EXT_pipeline_creation_cache_control) or !api_version.less(vk.VK_API_VERSION_1_3))) {
                self.device.VK_EXT_shader_module_identifier = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_rasterization_order_attachment_access") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_EXT_rasterization_order_attachment_access = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_NV_optical_flow") and (((self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1)) and self.device.VK_KHR_format_feature_flags2 and self.device.VK_KHR_synchronization2) or !api_version.less(vk.VK_API_VERSION_1_3))) {
                self.device.VK_NV_optical_flow = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_legacy_dithering") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_EXT_legacy_dithering = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_pipeline_protected_access") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_EXT_pipeline_protected_access = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_ANDROID_external_format_resolve") and (self.device.VK_ANDROID_external_memory_android_hardware_buffer)) {
                self.device.VK_ANDROID_external_format_resolve = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_maintenance5") and ((!api_version.less(vk.VK_API_VERSION_1_1) and self.device.VK_KHR_dynamic_rendering) or !api_version.less(vk.VK_API_VERSION_1_3))) {
                self.device.VK_KHR_maintenance5 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_AMD_anti_lag") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_AMD_anti_lag = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_AMDX_dense_geometry_format") and (self.device.VK_KHR_acceleration_structure and (self.device.VK_KHR_maintenance5 or !api_version.less(vk.VK_API_VERSION_1_4)))) {
                self.device.VK_AMDX_dense_geometry_format = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_present_id2") and (self.instance.VK_KHR_get_surface_capabilities2 and self.instance.VK_KHR_surface and self.device.VK_KHR_swapchain)) {
                self.device.VK_KHR_present_id2 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_present_wait2") and (self.instance.VK_KHR_get_surface_capabilities2 and self.instance.VK_KHR_surface and self.device.VK_KHR_swapchain and self.device.VK_KHR_present_id2)) {
                self.device.VK_KHR_present_wait2 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_ray_tracing_position_fetch") and (self.device.VK_KHR_acceleration_structure)) {
                self.device.VK_KHR_ray_tracing_position_fetch = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_shader_object") and (((self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1)) and self.device.VK_KHR_dynamic_rendering) or !api_version.less(vk.VK_API_VERSION_1_3))) {
                self.device.VK_EXT_shader_object = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_pipeline_binary") and (self.device.VK_KHR_maintenance5 or !api_version.less(vk.VK_API_VERSION_1_4))) {
                self.device.VK_KHR_pipeline_binary = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_QCOM_tile_properties") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_QCOM_tile_properties = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_SEC_amigo_profiling") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_SEC_amigo_profiling = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_swapchain_maintenance1") and (self.device.VK_KHR_swapchain or self.instance.VK_KHR_surface_maintenance1 or self.instance.VK_KHR_get_physical_device_properties2)) {
                self.device.VK_KHR_swapchain_maintenance1 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_QCOM_multiview_per_view_viewports") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_QCOM_multiview_per_view_viewports = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_NV_external_sci_sync2") and (!api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_NV_external_sci_sync2 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_NV_ray_tracing_invocation_reorder") and (self.device.VK_KHR_ray_tracing_pipeline)) {
                self.device.VK_NV_ray_tracing_invocation_reorder = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_NV_cooperative_vector") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_NV_cooperative_vector = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_NV_extended_sparse_address_space") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_NV_extended_sparse_address_space = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_mutable_descriptor_type") and (self.device.VK_KHR_maintenance3 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_EXT_mutable_descriptor_type = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_legacy_vertex_attributes") and (self.device.VK_EXT_vertex_input_dynamic_state)) {
                self.device.VK_EXT_legacy_vertex_attributes = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_ARM_shader_core_builtins") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_ARM_shader_core_builtins = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_pipeline_library_group_handles") and (self.device.VK_KHR_ray_tracing_pipeline and self.device.VK_KHR_pipeline_library)) {
                self.device.VK_EXT_pipeline_library_group_handles = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_dynamic_rendering_unused_attachments") and (((self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1)) and self.device.VK_KHR_dynamic_rendering) or !api_version.less(vk.VK_API_VERSION_1_3))) {
                self.device.VK_EXT_dynamic_rendering_unused_attachments = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_NV_low_latency2") and ((!api_version.less(vk.VK_API_VERSION_1_2) or self.device.VK_KHR_timeline_semaphore) and (self.device.VK_KHR_present_id or self.device.VK_KHR_present_id2))) {
                self.device.VK_NV_low_latency2 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_cooperative_matrix") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_KHR_cooperative_matrix = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_ARM_data_graph") and (!api_version.less(vk.VK_API_VERSION_1_3) and self.device.VK_KHR_maintenance5 and self.device.VK_KHR_deferred_host_operations)) {
                self.device.VK_ARM_data_graph = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_QCOM_multiview_per_view_render_areas") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_QCOM_multiview_per_view_render_areas = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_compute_shader_derivatives") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_KHR_compute_shader_derivatives = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_video_decode_av1") and (self.device.VK_KHR_video_decode_queue)) {
                self.device.VK_KHR_video_decode_av1 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_video_encode_av1") and (self.device.VK_KHR_video_encode_queue)) {
                self.device.VK_KHR_video_encode_av1 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_video_decode_vp9") and (self.device.VK_KHR_video_decode_queue)) {
                self.device.VK_KHR_video_decode_vp9 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_video_maintenance1") and (self.device.VK_KHR_video_queue)) {
                self.device.VK_KHR_video_maintenance1 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_NV_per_stage_descriptor_set") and (self.device.VK_KHR_maintenance6 or !api_version.less(vk.VK_API_VERSION_1_4))) {
                self.device.VK_NV_per_stage_descriptor_set = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_QCOM_image_processing2") and (self.device.VK_QCOM_image_processing)) {
                self.device.VK_QCOM_image_processing2 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_QCOM_filter_cubic_weights") and (self.device.VK_EXT_filter_cubic)) {
                self.device.VK_QCOM_filter_cubic_weights = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_QCOM_ycbcr_degamma") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_QCOM_ycbcr_degamma = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_QCOM_filter_cubic_clamp") and ((self.device.VK_EXT_filter_cubic) and (!api_version.less(vk.VK_API_VERSION_1_2) or self.device.VK_EXT_sampler_filter_minmax))) {
                self.device.VK_QCOM_filter_cubic_clamp = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_attachment_feedback_loop_dynamic_state") and ((self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1)) and self.device.VK_EXT_attachment_feedback_loop_layout)) {
                self.device.VK_EXT_attachment_feedback_loop_dynamic_state = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_vertex_attribute_divisor") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_KHR_vertex_attribute_divisor = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_load_store_op_none")) {
                self.device.VK_KHR_load_store_op_none = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_unified_image_layouts") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_KHR_unified_image_layouts = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_shader_float_controls2") and (!api_version.less(vk.VK_API_VERSION_1_1) and self.device.VK_KHR_shader_float_controls)) {
                self.device.VK_KHR_shader_float_controls2 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_QNX_external_memory_screen_buffer") and (((self.device.VK_KHR_sampler_ycbcr_conversion and self.device.VK_KHR_external_memory and self.device.VK_KHR_dedicated_allocation) or !api_version.less(vk.VK_API_VERSION_1_1)) and self.device.VK_EXT_queue_family_foreign)) {
                self.device.VK_QNX_external_memory_screen_buffer = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_MSFT_layered_driver") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_MSFT_layered_driver = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_index_type_uint8") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_KHR_index_type_uint8 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_line_rasterization") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_KHR_line_rasterization = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_calibrated_timestamps") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_KHR_calibrated_timestamps = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_shader_expect_assume") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_KHR_shader_expect_assume = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_maintenance6") and (!api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_KHR_maintenance6 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_NV_descriptor_pool_overallocation") and (!api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_NV_descriptor_pool_overallocation = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_QCOM_tile_memory_heap") and ((self.device.VK_KHR_get_memory_requirements2 and self.instance.VK_KHR_get_physical_device_properties2) or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_QCOM_tile_memory_heap = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_copy_memory_indirect") and ((self.instance.VK_KHR_get_physical_device_properties2 and self.device.VK_KHR_buffer_device_address) or !api_version.less(vk.VK_API_VERSION_1_2))) {
                self.device.VK_KHR_copy_memory_indirect = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_memory_decompression") and (self.instance.VK_KHR_get_physical_device_properties2 and self.device.VK_KHR_buffer_device_address)) {
                self.device.VK_EXT_memory_decompression = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_video_encode_intra_refresh") and (self.device.VK_KHR_video_encode_queue)) {
                self.device.VK_KHR_video_encode_intra_refresh = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_video_encode_quantization_map") and (self.device.VK_KHR_video_encode_queue and (self.device.VK_KHR_format_feature_flags2 or !api_version.less(vk.VK_API_VERSION_1_3)))) {
                self.device.VK_KHR_video_encode_quantization_map = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_NV_raw_access_chains") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_NV_raw_access_chains = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_NV_external_compute_queue")) {
                self.device.VK_NV_external_compute_queue = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_shader_relaxed_extended_instruction") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_KHR_shader_relaxed_extended_instruction = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_NV_command_buffer_inheritance") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_NV_command_buffer_inheritance = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_maintenance7") and (!api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_KHR_maintenance7 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_NV_shader_atomic_float16_vector") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_NV_shader_atomic_float16_vector = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_shader_replicated_composites") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_EXT_shader_replicated_composites = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_shader_float8") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_EXT_shader_float8 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_NV_ray_tracing_validation") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_NV_ray_tracing_validation = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_NV_cluster_acceleration_structure") and (self.device.VK_KHR_acceleration_structure)) {
                self.device.VK_NV_cluster_acceleration_structure = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_NV_partitioned_acceleration_structure") and (self.device.VK_KHR_acceleration_structure)) {
                self.device.VK_NV_partitioned_acceleration_structure = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_device_generated_commands") and (((self.device.VK_KHR_buffer_device_address or !api_version.less(vk.VK_API_VERSION_1_2)) and self.device.VK_KHR_maintenance5) or !api_version.less(vk.VK_API_VERSION_1_3))) {
                self.device.VK_EXT_device_generated_commands = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_maintenance8") and (!api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_KHR_maintenance8 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_MESA_image_alignment_control") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_MESA_image_alignment_control = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_shader_fma") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_KHR_shader_fma = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_ray_tracing_invocation_reorder") and (self.device.VK_KHR_ray_tracing_pipeline)) {
                self.device.VK_EXT_ray_tracing_invocation_reorder = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_depth_clamp_control") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_EXT_depth_clamp_control = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_maintenance9") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_KHR_maintenance9 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_video_maintenance2") and (self.device.VK_KHR_video_queue)) {
                self.device.VK_KHR_video_maintenance2 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_OHOS_native_buffer")) {
                self.device.VK_OHOS_native_buffer = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_HUAWEI_hdr_vivid") and ((self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1)) and self.device.VK_KHR_swapchain and self.device.VK_EXT_hdr_metadata)) {
                self.device.VK_HUAWEI_hdr_vivid = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_NV_cooperative_matrix2") and (self.device.VK_KHR_cooperative_matrix)) {
                self.device.VK_NV_cooperative_matrix2 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_ARM_pipeline_opacity_micromap") and (self.device.VK_EXT_opacity_micromap)) {
                self.device.VK_ARM_pipeline_opacity_micromap = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_external_memory_metal") and (self.device.VK_KHR_external_memory or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_EXT_external_memory_metal = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_depth_clamp_zero_one") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_KHR_depth_clamp_zero_one = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_ARM_performance_counters_by_region") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_ARM_performance_counters_by_region = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_vertex_attribute_robustness") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_EXT_vertex_attribute_robustness = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_ARM_format_pack") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_ARM_format_pack = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_VALVE_fragment_density_map_layered") and ((self.device.VK_KHR_maintenance5 or !api_version.less(vk.VK_API_VERSION_1_4)) and self.device.VK_EXT_fragment_density_map)) {
                self.device.VK_VALVE_fragment_density_map_layered = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_robustness2") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_KHR_robustness2 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_NV_present_metering") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_NV_present_metering = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_fragment_density_map_offset") and ((self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1)) and self.device.VK_EXT_fragment_density_map and (self.device.VK_KHR_create_renderpass2 or !api_version.less(vk.VK_API_VERSION_1_2)) and (!api_version.less(vk.VK_API_VERSION_1_3) or self.device.VK_KHR_dynamic_rendering))) {
                self.device.VK_EXT_fragment_density_map_offset = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_zero_initialize_device_memory") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_EXT_zero_initialize_device_memory = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_present_mode_fifo_latest_ready") and (self.device.VK_KHR_swapchain)) {
                self.device.VK_KHR_present_mode_fifo_latest_ready = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_shader_64bit_indexing") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_EXT_shader_64bit_indexing = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_custom_resolve") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_EXT_custom_resolve = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_QCOM_data_graph_model") and (self.device.VK_ARM_data_graph)) {
                self.device.VK_QCOM_data_graph_model = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_KHR_maintenance10") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_KHR_maintenance10 = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_SEC_pipeline_cache_incremental_mode") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_SEC_pipeline_cache_incremental_mode = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_EXT_shader_uniform_buffer_unsized_array") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_EXT_shader_uniform_buffer_unsized_array = true;
                break;
            }
        }
        for (de) |ext| {
            if (std.mem.eql(u8, ext, "VK_NV_compute_occupancy_priority") and (self.instance.VK_KHR_get_physical_device_properties2 or !api_version.less(vk.VK_API_VERSION_1_1))) {
                self.device.VK_NV_compute_occupancy_priority = true;
                break;
            }
        }
        return self;
    }
};

pub fn validate_VkBaseOutStructure(extensions: *const Extensions, item: *const vk.VkBaseOutStructure, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkBaseOutStructure: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkBaseInStructure(extensions: *const Extensions, item: *const vk.VkBaseInStructure, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkBaseInStructure: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkOffset2D(extensions: *const Extensions, item: *const vk.VkOffset2D, validate_pnext: bool) bool {
    _ = item;
    _ = extensions;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkOffset3D(extensions: *const Extensions, item: *const vk.VkOffset3D, validate_pnext: bool) bool {
    _ = item;
    _ = extensions;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkExtent2D(extensions: *const Extensions, item: *const vk.VkExtent2D, validate_pnext: bool) bool {
    _ = item;
    _ = extensions;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkExtent3D(extensions: *const Extensions, item: *const vk.VkExtent3D, validate_pnext: bool) bool {
    _ = item;
    _ = extensions;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkViewport(extensions: *const Extensions, item: *const vk.VkViewport, validate_pnext: bool) bool {
    _ = item;
    _ = extensions;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkRect2D(extensions: *const Extensions, item: *const vk.VkRect2D, validate_pnext: bool) bool {
    if (!validate_VkOffset2D(extensions, &item.offset, false))
        return false;
    if (!validate_VkExtent2D(extensions, &item.extent, false))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkClearRect(extensions: *const Extensions, item: *const vk.VkClearRect, validate_pnext: bool) bool {
    if (!validate_VkRect2D(extensions, &item.rect, false))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkComponentMapping(extensions: *const Extensions, item: *const vk.VkComponentMapping, validate_pnext: bool) bool {
    if (!validate_VkComponentSwizzle(extensions, &item.r))
        return false;
    if (!validate_VkComponentSwizzle(extensions, &item.g))
        return false;
    if (!validate_VkComponentSwizzle(extensions, &item.b))
        return false;
    if (!validate_VkComponentSwizzle(extensions, &item.a))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDeviceProperties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceProperties, validate_pnext: bool) bool {
    if (!validate_VkPhysicalDeviceType(extensions, &item.deviceType))
        return false;
    if (!validate_VkPhysicalDeviceLimits(extensions, &item.limits, false))
        return false;
    if (!validate_VkPhysicalDeviceSparseProperties(extensions, &item.sparseProperties, false))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkExtensionProperties(extensions: *const Extensions, item: *const vk.VkExtensionProperties, validate_pnext: bool) bool {
    _ = item;
    _ = extensions;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkLayerProperties(extensions: *const Extensions, item: *const vk.VkLayerProperties, validate_pnext: bool) bool {
    _ = item;
    _ = extensions;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkApplicationInfo(extensions: *const Extensions, item: *const vk.VkApplicationInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkApplicationInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkAllocationCallbacks(extensions: *const Extensions, item: *const vk.VkAllocationCallbacks, validate_pnext: bool) bool {
    _ = item;
    _ = extensions;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkDeviceQueueCreateInfo(extensions: *const Extensions, item: *const vk.VkDeviceQueueCreateInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkDeviceQueueCreateFlags(extensions, &item.flags))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDeviceQueueCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDeviceCreateInfo(extensions: *const Extensions, item: *const vk.VkDeviceCreateInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkDeviceCreateFlags(extensions, &item.flags))
        return false;
    if (item.pQueueCreateInfos) |v| {
        for (v[0..item.queueCreateInfoCount]) |*vv| {
            if (!validate_VkDeviceQueueCreateInfo(extensions, vv, false))
                return false;
        }
    }
    if (item.pEnabledFeatures) |v| {
        if (!validate_VkPhysicalDeviceFeatures(extensions, v, false))
            return false;
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDeviceCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkInstanceCreateInfo(extensions: *const Extensions, item: *const vk.VkInstanceCreateInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkInstanceCreateFlags(extensions, &item.flags))
        return false;
    if (item.pApplicationInfo) |v| {
        if (!validate_VkApplicationInfo(extensions, v, false))
            return false;
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkInstanceCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkQueueFamilyProperties(extensions: *const Extensions, item: *const vk.VkQueueFamilyProperties, validate_pnext: bool) bool {
    if (!validate_VkQueueFlags(extensions, &item.queueFlags))
        return false;
    if (!validate_VkExtent3D(extensions, &item.minImageTransferGranularity, false))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDeviceMemoryProperties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMemoryProperties, validate_pnext: bool) bool {
        for (item.memoryTypes) |v| {
            if (!validate_VkMemoryType(extensions, v))
                return false;
        }
        for (item.memoryHeaps) |v| {
            if (!validate_VkMemoryHeap(extensions, v))
                return false;
        }
    _ = validate_pnext;
    return true;
}

pub fn validate_VkMemoryAllocateInfo(extensions: *const Extensions, item: *const vk.VkMemoryAllocateInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMemoryAllocateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkMemoryRequirements(extensions: *const Extensions, item: *const vk.VkMemoryRequirements, validate_pnext: bool) bool {
    _ = item;
    _ = extensions;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkSparseImageFormatProperties(extensions: *const Extensions, item: *const vk.VkSparseImageFormatProperties, validate_pnext: bool) bool {
    if (!validate_VkImageAspectFlags(extensions, &item.aspectMask))
        return false;
    if (!validate_VkExtent3D(extensions, &item.imageGranularity, false))
        return false;
    if (!validate_VkSparseImageFormatFlags(extensions, &item.flags))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkSparseImageMemoryRequirements(extensions: *const Extensions, item: *const vk.VkSparseImageMemoryRequirements, validate_pnext: bool) bool {
    if (!validate_VkSparseImageFormatProperties(extensions, &item.formatProperties, false))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkMemoryType(extensions: *const Extensions, item: *const vk.VkMemoryType, validate_pnext: bool) bool {
    if (!validate_VkMemoryPropertyFlags(extensions, &item.propertyFlags))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkMemoryHeap(extensions: *const Extensions, item: *const vk.VkMemoryHeap, validate_pnext: bool) bool {
    if (!validate_VkMemoryHeapFlags(extensions, &item.flags))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkMappedMemoryRange(extensions: *const Extensions, item: *const vk.VkMappedMemoryRange, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMappedMemoryRange: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkFormatProperties(extensions: *const Extensions, item: *const vk.VkFormatProperties, validate_pnext: bool) bool {
    if (!validate_VkFormatFeatureFlags(extensions, &item.linearTilingFeatures))
        return false;
    if (!validate_VkFormatFeatureFlags(extensions, &item.optimalTilingFeatures))
        return false;
    if (!validate_VkFormatFeatureFlags(extensions, &item.bufferFeatures))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkImageFormatProperties(extensions: *const Extensions, item: *const vk.VkImageFormatProperties, validate_pnext: bool) bool {
    if (!validate_VkExtent3D(extensions, &item.maxExtent, false))
        return false;
    if (!validate_VkSampleCountFlags(extensions, &item.sampleCounts))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkDescriptorBufferInfo(extensions: *const Extensions, item: *const vk.VkDescriptorBufferInfo, validate_pnext: bool) bool {
    _ = item;
    _ = extensions;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkDescriptorImageInfo(extensions: *const Extensions, item: *const vk.VkDescriptorImageInfo, validate_pnext: bool) bool {
    if (!validate_VkImageLayout(extensions, &item.imageLayout))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkWriteDescriptorSet(extensions: *const Extensions, item: *const vk.VkWriteDescriptorSet, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkDescriptorType(extensions, &item.descriptorType))
        return false;
    if (item.pImageInfo) |v| {
        for (v[0..item.descriptorCount]) |*vv| {
            if (!validate_VkDescriptorImageInfo(extensions, vv, false))
                return false;
        }
    }
    if (item.pBufferInfo) |v| {
        for (v[0..item.descriptorCount]) |*vv| {
            if (!validate_VkDescriptorBufferInfo(extensions, vv, false))
                return false;
        }
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkWriteDescriptorSet: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkCopyDescriptorSet(extensions: *const Extensions, item: *const vk.VkCopyDescriptorSet, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkCopyDescriptorSet: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkBufferUsageFlags2CreateInfo(extensions: *const Extensions, item: *const vk.VkBufferUsageFlags2CreateInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkBufferUsageFlags2(extensions, &item.usage))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO,
            => if (!validate_VkBufferViewCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO,
            => if (!validate_VkBufferCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO,
            => if (!validate_VkPhysicalDeviceExternalBufferInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_INFO_EXT,
            => if (!validate_VkDescriptorBufferBindingInfoEXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkBufferUsageFlags2CreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkBufferCreateInfo(extensions: *const Extensions, item: *const vk.VkBufferCreateInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkBufferCreateFlags(extensions, &item.flags))
        return false;
    if (!validate_VkBufferUsageFlags(extensions, &item.usage))
        return false;
    if (!validate_VkSharingMode(extensions, &item.sharingMode))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkBufferCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkBufferViewCreateInfo(extensions: *const Extensions, item: *const vk.VkBufferViewCreateInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkBufferViewCreateFlags(extensions, &item.flags))
        return false;
    if (!validate_VkFormat(extensions, &item.format))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkBufferViewCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImageSubresource(extensions: *const Extensions, item: *const vk.VkImageSubresource, validate_pnext: bool) bool {
    if (!validate_VkImageAspectFlags(extensions, &item.aspectMask))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkImageSubresourceLayers(extensions: *const Extensions, item: *const vk.VkImageSubresourceLayers, validate_pnext: bool) bool {
    if (!validate_VkImageAspectFlags(extensions, &item.aspectMask))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkImageSubresourceRange(extensions: *const Extensions, item: *const vk.VkImageSubresourceRange, validate_pnext: bool) bool {
    if (!validate_VkImageAspectFlags(extensions, &item.aspectMask))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkMemoryBarrier(extensions: *const Extensions, item: *const vk.VkMemoryBarrier, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkAccessFlags(extensions, &item.srcAccessMask))
        return false;
    if (!validate_VkAccessFlags(extensions, &item.dstAccessMask))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMemoryBarrier: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkBufferMemoryBarrier(extensions: *const Extensions, item: *const vk.VkBufferMemoryBarrier, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkAccessFlags(extensions, &item.srcAccessMask))
        return false;
    if (!validate_VkAccessFlags(extensions, &item.dstAccessMask))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkBufferMemoryBarrier: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImageMemoryBarrier(extensions: *const Extensions, item: *const vk.VkImageMemoryBarrier, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkAccessFlags(extensions, &item.srcAccessMask))
        return false;
    if (!validate_VkAccessFlags(extensions, &item.dstAccessMask))
        return false;
    if (!validate_VkImageLayout(extensions, &item.oldLayout))
        return false;
    if (!validate_VkImageLayout(extensions, &item.newLayout))
        return false;
    if (!validate_VkImageSubresourceRange(extensions, &item.subresourceRange, false))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImageMemoryBarrier: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImageCreateInfo(extensions: *const Extensions, item: *const vk.VkImageCreateInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkImageCreateFlags(extensions, &item.flags))
        return false;
    if (!validate_VkImageType(extensions, &item.imageType))
        return false;
    if (!validate_VkFormat(extensions, &item.format))
        return false;
    if (!validate_VkExtent3D(extensions, &item.extent, false))
        return false;
    if (!validate_VkSampleCountFlags(extensions, &item.samples))
        return false;
    if (!validate_VkImageTiling(extensions, &item.tiling))
        return false;
    if (!validate_VkImageUsageFlags(extensions, &item.usage))
        return false;
    if (!validate_VkSharingMode(extensions, &item.sharingMode))
        return false;
    if (!validate_VkImageLayout(extensions, &item.initialLayout))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImageCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSubresourceLayout(extensions: *const Extensions, item: *const vk.VkSubresourceLayout, validate_pnext: bool) bool {
    _ = item;
    _ = extensions;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkImageViewCreateInfo(extensions: *const Extensions, item: *const vk.VkImageViewCreateInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkImageViewCreateFlags(extensions, &item.flags))
        return false;
    if (!validate_VkImageViewType(extensions, &item.viewType))
        return false;
    if (!validate_VkFormat(extensions, &item.format))
        return false;
    if (!validate_VkComponentMapping(extensions, &item.components, false))
        return false;
    if (!validate_VkImageSubresourceRange(extensions, &item.subresourceRange, false))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImageViewCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkBufferCopy(extensions: *const Extensions, item: *const vk.VkBufferCopy, validate_pnext: bool) bool {
    _ = item;
    _ = extensions;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkSparseMemoryBind(extensions: *const Extensions, item: *const vk.VkSparseMemoryBind, validate_pnext: bool) bool {
    if (!validate_VkSparseMemoryBindFlags(extensions, &item.flags))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkSparseImageMemoryBind(extensions: *const Extensions, item: *const vk.VkSparseImageMemoryBind, validate_pnext: bool) bool {
    if (!validate_VkImageSubresource(extensions, &item.subresource, false))
        return false;
    if (!validate_VkOffset3D(extensions, &item.offset, false))
        return false;
    if (!validate_VkExtent3D(extensions, &item.extent, false))
        return false;
    if (!validate_VkSparseMemoryBindFlags(extensions, &item.flags))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkSparseBufferMemoryBindInfo(extensions: *const Extensions, item: *const vk.VkSparseBufferMemoryBindInfo, validate_pnext: bool) bool {
    if (item.pBinds) |v| {
        for (v[0..item.bindCount]) |*vv| {
            if (!validate_VkSparseMemoryBind(extensions, vv, false))
                return false;
        }
    }
    _ = validate_pnext;
    return true;
}

pub fn validate_VkSparseImageOpaqueMemoryBindInfo(extensions: *const Extensions, item: *const vk.VkSparseImageOpaqueMemoryBindInfo, validate_pnext: bool) bool {
    if (item.pBinds) |v| {
        for (v[0..item.bindCount]) |*vv| {
            if (!validate_VkSparseMemoryBind(extensions, vv, false))
                return false;
        }
    }
    _ = validate_pnext;
    return true;
}

pub fn validate_VkSparseImageMemoryBindInfo(extensions: *const Extensions, item: *const vk.VkSparseImageMemoryBindInfo, validate_pnext: bool) bool {
    if (item.pBinds) |v| {
        for (v[0..item.bindCount]) |*vv| {
            if (!validate_VkSparseImageMemoryBind(extensions, vv, false))
                return false;
        }
    }
    _ = validate_pnext;
    return true;
}

pub fn validate_VkBindSparseInfo(extensions: *const Extensions, item: *const vk.VkBindSparseInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (item.pBufferBinds) |v| {
        for (v[0..item.bufferBindCount]) |*vv| {
            if (!validate_VkSparseBufferMemoryBindInfo(extensions, vv, false))
                return false;
        }
    }
    if (item.pImageOpaqueBinds) |v| {
        for (v[0..item.imageOpaqueBindCount]) |*vv| {
            if (!validate_VkSparseImageOpaqueMemoryBindInfo(extensions, vv, false))
                return false;
        }
    }
    if (item.pImageBinds) |v| {
        for (v[0..item.imageBindCount]) |*vv| {
            if (!validate_VkSparseImageMemoryBindInfo(extensions, vv, false))
                return false;
        }
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkBindSparseInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImageCopy(extensions: *const Extensions, item: *const vk.VkImageCopy, validate_pnext: bool) bool {
    if (!validate_VkImageSubresourceLayers(extensions, &item.srcSubresource, false))
        return false;
    if (!validate_VkOffset3D(extensions, &item.srcOffset, false))
        return false;
    if (!validate_VkImageSubresourceLayers(extensions, &item.dstSubresource, false))
        return false;
    if (!validate_VkOffset3D(extensions, &item.dstOffset, false))
        return false;
    if (!validate_VkExtent3D(extensions, &item.extent, false))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkImageBlit(extensions: *const Extensions, item: *const vk.VkImageBlit, validate_pnext: bool) bool {
    if (!validate_VkImageSubresourceLayers(extensions, &item.srcSubresource, false))
        return false;
        for (item.srcOffsets) |v| {
            if (!validate_VkOffset3D(extensions, v))
                return false;
        }
    if (!validate_VkImageSubresourceLayers(extensions, &item.dstSubresource, false))
        return false;
        for (item.dstOffsets) |v| {
            if (!validate_VkOffset3D(extensions, v))
                return false;
        }
    _ = validate_pnext;
    return true;
}

pub fn validate_VkBufferImageCopy(extensions: *const Extensions, item: *const vk.VkBufferImageCopy, validate_pnext: bool) bool {
    if (!validate_VkImageSubresourceLayers(extensions, &item.imageSubresource, false))
        return false;
    if (!validate_VkOffset3D(extensions, &item.imageOffset, false))
        return false;
    if (!validate_VkExtent3D(extensions, &item.imageExtent, false))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkStridedDeviceAddressRangeKHR(extensions: *const Extensions, item: *const vk.VkStridedDeviceAddressRangeKHR, validate_pnext: bool) bool {
    _ = item;
    _ = extensions;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkCopyMemoryIndirectCommandKHR(extensions: *const Extensions, item: *const vk.VkCopyMemoryIndirectCommandKHR, validate_pnext: bool) bool {
    _ = item;
    _ = extensions;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkCopyMemoryIndirectInfoKHR(extensions: *const Extensions, item: *const vk.VkCopyMemoryIndirectInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkAddressCopyFlagsKHR(extensions, &item.srcCopyFlags))
        return false;
    if (!validate_VkAddressCopyFlagsKHR(extensions, &item.dstCopyFlags))
        return false;
    if (!validate_VkStridedDeviceAddressRangeKHR(extensions, &item.copyAddressRange, false))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkCopyMemoryIndirectInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkCopyMemoryToImageIndirectCommandKHR(extensions: *const Extensions, item: *const vk.VkCopyMemoryToImageIndirectCommandKHR, validate_pnext: bool) bool {
    if (!validate_VkImageSubresourceLayers(extensions, &item.imageSubresource, false))
        return false;
    if (!validate_VkOffset3D(extensions, &item.imageOffset, false))
        return false;
    if (!validate_VkExtent3D(extensions, &item.imageExtent, false))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkCopyMemoryToImageIndirectInfoKHR(extensions: *const Extensions, item: *const vk.VkCopyMemoryToImageIndirectInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkAddressCopyFlagsKHR(extensions, &item.srcCopyFlags))
        return false;
    if (!validate_VkStridedDeviceAddressRangeKHR(extensions, &item.copyAddressRange, false))
        return false;
    if (!validate_VkImageLayout(extensions, &item.dstImageLayout))
        return false;
    if (item.pImageSubresources) |v| {
        for (v[0..item.copyCount]) |*vv| {
            if (!validate_VkImageSubresourceLayers(extensions, vv, false))
                return false;
        }
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkCopyMemoryToImageIndirectInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImageResolve(extensions: *const Extensions, item: *const vk.VkImageResolve, validate_pnext: bool) bool {
    if (!validate_VkImageSubresourceLayers(extensions, &item.srcSubresource, false))
        return false;
    if (!validate_VkOffset3D(extensions, &item.srcOffset, false))
        return false;
    if (!validate_VkImageSubresourceLayers(extensions, &item.dstSubresource, false))
        return false;
    if (!validate_VkOffset3D(extensions, &item.dstOffset, false))
        return false;
    if (!validate_VkExtent3D(extensions, &item.extent, false))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkShaderModuleCreateInfo(extensions: *const Extensions, item: *const vk.VkShaderModuleCreateInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkShaderModuleCreateFlags(extensions, &item.flags))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO,
            => if (!validate_VkPipelineShaderStageCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_CREATE_INFO_ARM,
            => if (!validate_VkDataGraphPipelineCreateInfoARM(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkShaderModuleCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDescriptorSetLayoutBinding(extensions: *const Extensions, item: *const vk.VkDescriptorSetLayoutBinding, validate_pnext: bool) bool {
    if (!validate_VkDescriptorType(extensions, &item.descriptorType))
        return false;
    if (!validate_VkShaderStageFlags(extensions, &item.stageFlags))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkDescriptorSetLayoutCreateInfo(extensions: *const Extensions, item: *const vk.VkDescriptorSetLayoutCreateInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkDescriptorSetLayoutCreateFlags(extensions, &item.flags))
        return false;
    if (item.pBindings) |v| {
        for (v[0..item.bindingCount]) |*vv| {
            if (!validate_VkDescriptorSetLayoutBinding(extensions, vv, false))
                return false;
        }
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDescriptorSetLayoutCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDescriptorPoolSize(extensions: *const Extensions, item: *const vk.VkDescriptorPoolSize, validate_pnext: bool) bool {
    if (!validate_VkDescriptorType(extensions, &item.type))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkDescriptorPoolCreateInfo(extensions: *const Extensions, item: *const vk.VkDescriptorPoolCreateInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkDescriptorPoolCreateFlags(extensions, &item.flags))
        return false;
    if (item.pPoolSizes) |v| {
        for (v[0..item.poolSizeCount]) |*vv| {
            if (!validate_VkDescriptorPoolSize(extensions, vv, false))
                return false;
        }
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDescriptorPoolCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDescriptorSetAllocateInfo(extensions: *const Extensions, item: *const vk.VkDescriptorSetAllocateInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDescriptorSetAllocateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSpecializationMapEntry(extensions: *const Extensions, item: *const vk.VkSpecializationMapEntry, validate_pnext: bool) bool {
    _ = item;
    _ = extensions;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkSpecializationInfo(extensions: *const Extensions, item: *const vk.VkSpecializationInfo, validate_pnext: bool) bool {
    if (item.pMapEntries) |v| {
        for (v[0..item.mapEntryCount]) |*vv| {
            if (!validate_VkSpecializationMapEntry(extensions, vv, false))
                return false;
        }
    }
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPipelineShaderStageCreateInfo(extensions: *const Extensions, item: *const vk.VkPipelineShaderStageCreateInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkPipelineShaderStageCreateFlags(extensions, &item.flags))
        return false;
    if (!validate_VkShaderStageFlags(extensions, &item.stage))
        return false;
    if (item.pSpecializationInfo) |v| {
        if (!validate_VkSpecializationInfo(extensions, v, false))
            return false;
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineShaderStageCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkComputePipelineCreateInfo(extensions: *const Extensions, item: *const vk.VkComputePipelineCreateInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkPipelineCreateFlags(extensions, &item.flags))
        return false;
    if (!validate_VkPipelineShaderStageCreateInfo(extensions, &item.stage, false))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkComputePipelineCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkComputePipelineIndirectBufferInfoNV(extensions: *const Extensions, item: *const vk.VkComputePipelineIndirectBufferInfoNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO,
            => if (!validate_VkComputePipelineCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkComputePipelineIndirectBufferInfoNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPipelineCreateFlags2CreateInfo(extensions: *const Extensions, item: *const vk.VkPipelineCreateFlags2CreateInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkPipelineCreateFlags2(extensions, &item.flags))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO,
            => if (!validate_VkComputePipelineCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO,
            => if (!validate_VkGraphicsPipelineCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV,
            => if (!validate_VkRayTracingPipelineCreateInfoNV(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_KHR,
            => if (!validate_VkRayTracingPipelineCreateInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineCreateFlags2CreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVertexInputBindingDescription(extensions: *const Extensions, item: *const vk.VkVertexInputBindingDescription, validate_pnext: bool) bool {
    if (!validate_VkVertexInputRate(extensions, &item.inputRate))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkVertexInputAttributeDescription(extensions: *const Extensions, item: *const vk.VkVertexInputAttributeDescription, validate_pnext: bool) bool {
    if (!validate_VkFormat(extensions, &item.format))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPipelineVertexInputStateCreateInfo(extensions: *const Extensions, item: *const vk.VkPipelineVertexInputStateCreateInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkPipelineVertexInputStateCreateFlags(extensions, &item.flags))
        return false;
    if (item.pVertexBindingDescriptions) |v| {
        for (v[0..item.vertexBindingDescriptionCount]) |*vv| {
            if (!validate_VkVertexInputBindingDescription(extensions, vv, false))
                return false;
        }
    }
    if (item.pVertexAttributeDescriptions) |v| {
        for (v[0..item.vertexAttributeDescriptionCount]) |*vv| {
            if (!validate_VkVertexInputAttributeDescription(extensions, vv, false))
                return false;
        }
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineVertexInputStateCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPipelineInputAssemblyStateCreateInfo(extensions: *const Extensions, item: *const vk.VkPipelineInputAssemblyStateCreateInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkPipelineInputAssemblyStateCreateFlags(extensions, &item.flags))
        return false;
    if (!validate_VkPrimitiveTopology(extensions, &item.topology))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineInputAssemblyStateCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPipelineTessellationStateCreateInfo(extensions: *const Extensions, item: *const vk.VkPipelineTessellationStateCreateInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkPipelineTessellationStateCreateFlags(extensions, &item.flags))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineTessellationStateCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPipelineViewportStateCreateInfo(extensions: *const Extensions, item: *const vk.VkPipelineViewportStateCreateInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkPipelineViewportStateCreateFlags(extensions, &item.flags))
        return false;
    if (item.pViewports) |v| {
        for (v[0..item.viewportCount]) |*vv| {
            if (!validate_VkViewport(extensions, vv, false))
                return false;
        }
    }
    if (item.pScissors) |v| {
        for (v[0..item.scissorCount]) |*vv| {
            if (!validate_VkRect2D(extensions, vv, false))
                return false;
        }
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineViewportStateCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPipelineRasterizationStateCreateInfo(extensions: *const Extensions, item: *const vk.VkPipelineRasterizationStateCreateInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkPipelineRasterizationStateCreateFlags(extensions, &item.flags))
        return false;
    if (!validate_VkPolygonMode(extensions, &item.polygonMode))
        return false;
    if (!validate_VkCullModeFlags(extensions, &item.cullMode))
        return false;
    if (!validate_VkFrontFace(extensions, &item.frontFace))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineRasterizationStateCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPipelineMultisampleStateCreateInfo(extensions: *const Extensions, item: *const vk.VkPipelineMultisampleStateCreateInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkPipelineMultisampleStateCreateFlags(extensions, &item.flags))
        return false;
    if (!validate_VkSampleCountFlags(extensions, &item.rasterizationSamples))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineMultisampleStateCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPipelineColorBlendAttachmentState(extensions: *const Extensions, item: *const vk.VkPipelineColorBlendAttachmentState, validate_pnext: bool) bool {
    if (!validate_VkBlendFactor(extensions, &item.srcColorBlendFactor))
        return false;
    if (!validate_VkBlendFactor(extensions, &item.dstColorBlendFactor))
        return false;
    if (!validate_VkBlendOp(extensions, &item.colorBlendOp))
        return false;
    if (!validate_VkBlendFactor(extensions, &item.srcAlphaBlendFactor))
        return false;
    if (!validate_VkBlendFactor(extensions, &item.dstAlphaBlendFactor))
        return false;
    if (!validate_VkBlendOp(extensions, &item.alphaBlendOp))
        return false;
    if (!validate_VkColorComponentFlags(extensions, &item.colorWriteMask))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPipelineColorBlendStateCreateInfo(extensions: *const Extensions, item: *const vk.VkPipelineColorBlendStateCreateInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkPipelineColorBlendStateCreateFlags(extensions, &item.flags))
        return false;
    if (!validate_VkLogicOp(extensions, &item.logicOp))
        return false;
    if (item.pAttachments) |v| {
        for (v[0..item.attachmentCount]) |*vv| {
            if (!validate_VkPipelineColorBlendAttachmentState(extensions, vv, false))
                return false;
        }
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineColorBlendStateCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPipelineDynamicStateCreateInfo(extensions: *const Extensions, item: *const vk.VkPipelineDynamicStateCreateInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkPipelineDynamicStateCreateFlags(extensions, &item.flags))
        return false;
    if (item.pDynamicStates) |v| {
        for (v[0..item.dynamicStateCount]) |*vv| {
            if (!validate_VkDynamicState(extensions, vv))
                return false;
        }
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineDynamicStateCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkStencilOpState(extensions: *const Extensions, item: *const vk.VkStencilOpState, validate_pnext: bool) bool {
    if (!validate_VkStencilOp(extensions, &item.failOp))
        return false;
    if (!validate_VkStencilOp(extensions, &item.passOp))
        return false;
    if (!validate_VkStencilOp(extensions, &item.depthFailOp))
        return false;
    if (!validate_VkCompareOp(extensions, &item.compareOp))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPipelineDepthStencilStateCreateInfo(extensions: *const Extensions, item: *const vk.VkPipelineDepthStencilStateCreateInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkPipelineDepthStencilStateCreateFlags(extensions, &item.flags))
        return false;
    if (!validate_VkCompareOp(extensions, &item.depthCompareOp))
        return false;
    if (!validate_VkStencilOpState(extensions, &item.front, false))
        return false;
    if (!validate_VkStencilOpState(extensions, &item.back, false))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineDepthStencilStateCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkGraphicsPipelineCreateInfo(extensions: *const Extensions, item: *const vk.VkGraphicsPipelineCreateInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkPipelineCreateFlags(extensions, &item.flags))
        return false;
    if (item.pStages) |v| {
        for (v[0..item.stageCount]) |*vv| {
            if (!validate_VkPipelineShaderStageCreateInfo(extensions, vv, false))
                return false;
        }
    }
    if (item.pVertexInputState) |v| {
        if (!validate_VkPipelineVertexInputStateCreateInfo(extensions, v, false))
            return false;
    }
    if (item.pInputAssemblyState) |v| {
        if (!validate_VkPipelineInputAssemblyStateCreateInfo(extensions, v, false))
            return false;
    }
    if (item.pTessellationState) |v| {
        if (!validate_VkPipelineTessellationStateCreateInfo(extensions, v, false))
            return false;
    }
    if (item.pViewportState) |v| {
        if (!validate_VkPipelineViewportStateCreateInfo(extensions, v, false))
            return false;
    }
    if (item.pRasterizationState) |v| {
        if (!validate_VkPipelineRasterizationStateCreateInfo(extensions, v, false))
            return false;
    }
    if (item.pMultisampleState) |v| {
        if (!validate_VkPipelineMultisampleStateCreateInfo(extensions, v, false))
            return false;
    }
    if (item.pDepthStencilState) |v| {
        if (!validate_VkPipelineDepthStencilStateCreateInfo(extensions, v, false))
            return false;
    }
    if (item.pColorBlendState) |v| {
        if (!validate_VkPipelineColorBlendStateCreateInfo(extensions, v, false))
            return false;
    }
    if (item.pDynamicState) |v| {
        if (!validate_VkPipelineDynamicStateCreateInfo(extensions, v, false))
            return false;
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkGraphicsPipelineCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPipelineCacheCreateInfo(extensions: *const Extensions, item: *const vk.VkPipelineCacheCreateInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkPipelineCacheCreateFlags(extensions, &item.flags))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineCacheCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPipelineCacheHeaderVersionOne(extensions: *const Extensions, item: *const vk.VkPipelineCacheHeaderVersionOne, validate_pnext: bool) bool {
    if (!validate_VkPipelineCacheHeaderVersion(extensions, &item.headerVersion))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPipelineCacheStageValidationIndexEntry(extensions: *const Extensions, item: *const vk.VkPipelineCacheStageValidationIndexEntry, validate_pnext: bool) bool {
    _ = item;
    _ = extensions;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPipelineCacheSafetyCriticalIndexEntry(extensions: *const Extensions, item: *const vk.VkPipelineCacheSafetyCriticalIndexEntry, validate_pnext: bool) bool {
    _ = item;
    _ = extensions;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPipelineCacheHeaderVersionSafetyCriticalOne(extensions: *const Extensions, item: *const vk.VkPipelineCacheHeaderVersionSafetyCriticalOne, validate_pnext: bool) bool {
    if (!validate_VkPipelineCacheHeaderVersionOne(extensions, &item.headerVersionOne, false))
        return false;
    if (!validate_VkPipelineCacheValidationVersion(extensions, &item.validationVersion))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPipelineCacheHeaderVersionDataGraphQCOM(extensions: *const Extensions, item: *const vk.VkPipelineCacheHeaderVersionDataGraphQCOM, validate_pnext: bool) bool {
    if (!validate_VkPipelineCacheHeaderVersion(extensions, &item.headerVersion))
        return false;
    if (!validate_VkDataGraphModelCacheTypeQCOM(extensions, &item.cacheType))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPushConstantRange(extensions: *const Extensions, item: *const vk.VkPushConstantRange, validate_pnext: bool) bool {
    if (!validate_VkShaderStageFlags(extensions, &item.stageFlags))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPipelineBinaryCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkPipelineBinaryCreateInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (item.pKeysAndDataInfo) |v| {
        if (!validate_VkPipelineBinaryKeysAndDataKHR(extensions, v, false))
            return false;
    }
    if (item.pPipelineCreateInfo) |v| {
        if (!validate_VkPipelineCreateInfoKHR(extensions, v, false))
            return false;
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineBinaryCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPipelineBinaryHandlesInfoKHR(extensions: *const Extensions, item: *const vk.VkPipelineBinaryHandlesInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineBinaryHandlesInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPipelineBinaryDataKHR(extensions: *const Extensions, item: *const vk.VkPipelineBinaryDataKHR, validate_pnext: bool) bool {
    _ = item;
    _ = extensions;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPipelineBinaryKeysAndDataKHR(extensions: *const Extensions, item: *const vk.VkPipelineBinaryKeysAndDataKHR, validate_pnext: bool) bool {
    if (item.pPipelineBinaryKeys) |v| {
        for (v[0..item.binaryCount]) |*vv| {
            if (!validate_VkPipelineBinaryKeyKHR(extensions, vv, false))
                return false;
        }
    }
    if (item.pPipelineBinaryData) |v| {
        for (v[0..item.binaryCount]) |*vv| {
            if (!validate_VkPipelineBinaryDataKHR(extensions, vv, false))
                return false;
        }
    }
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPipelineBinaryKeyKHR(extensions: *const Extensions, item: *const vk.VkPipelineBinaryKeyKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineBinaryKeyKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPipelineBinaryInfoKHR(extensions: *const Extensions, item: *const vk.VkPipelineBinaryInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO,
            => if (!validate_VkGraphicsPipelineCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO,
            => if (!validate_VkComputePipelineCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_KHR,
            => if (!validate_VkRayTracingPipelineCreateInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineBinaryInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkReleaseCapturedPipelineDataInfoKHR(extensions: *const Extensions, item: *const vk.VkReleaseCapturedPipelineDataInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkReleaseCapturedPipelineDataInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPipelineBinaryDataInfoKHR(extensions: *const Extensions, item: *const vk.VkPipelineBinaryDataInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineBinaryDataInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPipelineCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkPipelineCreateInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPipelineLayoutCreateInfo(extensions: *const Extensions, item: *const vk.VkPipelineLayoutCreateInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkPipelineLayoutCreateFlags(extensions, &item.flags))
        return false;
    if (item.pPushConstantRanges) |v| {
        for (v[0..item.pushConstantRangeCount]) |*vv| {
            if (!validate_VkPushConstantRange(extensions, vv, false))
                return false;
        }
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_SETS_INFO,
            => if (!validate_VkBindDescriptorSetsInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_PUSH_CONSTANTS_INFO,
            => if (!validate_VkPushConstantsInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_INFO,
            => if (!validate_VkPushDescriptorSetInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_WITH_TEMPLATE_INFO,
            => if (!validate_VkPushDescriptorSetWithTemplateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_SET_DESCRIPTOR_BUFFER_OFFSETS_INFO_EXT,
            => if (!validate_VkSetDescriptorBufferOffsetsInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_BUFFER_EMBEDDED_SAMPLERS_INFO_EXT,
            => if (!validate_VkBindDescriptorBufferEmbeddedSamplersInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_EXT,
            => if (!validate_VkIndirectCommandsLayoutCreateInfoEXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineLayoutCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSamplerCreateInfo(extensions: *const Extensions, item: *const vk.VkSamplerCreateInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkSamplerCreateFlags(extensions, &item.flags))
        return false;
    if (!validate_VkFilter(extensions, &item.magFilter))
        return false;
    if (!validate_VkFilter(extensions, &item.minFilter))
        return false;
    if (!validate_VkSamplerMipmapMode(extensions, &item.mipmapMode))
        return false;
    if (!validate_VkSamplerAddressMode(extensions, &item.addressModeU))
        return false;
    if (!validate_VkSamplerAddressMode(extensions, &item.addressModeV))
        return false;
    if (!validate_VkSamplerAddressMode(extensions, &item.addressModeW))
        return false;
    if (!validate_VkCompareOp(extensions, &item.compareOp))
        return false;
    if (!validate_VkBorderColor(extensions, &item.borderColor))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSamplerCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkCommandPoolCreateInfo(extensions: *const Extensions, item: *const vk.VkCommandPoolCreateInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkCommandPoolCreateFlags(extensions, &item.flags))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkCommandPoolCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkCommandBufferAllocateInfo(extensions: *const Extensions, item: *const vk.VkCommandBufferAllocateInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkCommandBufferLevel(extensions, &item.level))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkCommandBufferAllocateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkCommandBufferInheritanceInfo(extensions: *const Extensions, item: *const vk.VkCommandBufferInheritanceInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkQueryControlFlags(extensions, &item.queryFlags))
        return false;
    if (!validate_VkQueryPipelineStatisticFlags(extensions, &item.pipelineStatistics))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkCommandBufferInheritanceInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkCommandBufferBeginInfo(extensions: *const Extensions, item: *const vk.VkCommandBufferBeginInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkCommandBufferUsageFlags(extensions, &item.flags))
        return false;
    if (item.pInheritanceInfo) |v| {
        if (!validate_VkCommandBufferInheritanceInfo(extensions, v, false))
            return false;
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkCommandBufferBeginInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkRenderPassBeginInfo(extensions: *const Extensions, item: *const vk.VkRenderPassBeginInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkRect2D(extensions, &item.renderArea, false))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkRenderPassBeginInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkClearDepthStencilValue(extensions: *const Extensions, item: *const vk.VkClearDepthStencilValue, validate_pnext: bool) bool {
    _ = item;
    _ = extensions;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkClearAttachment(extensions: *const Extensions, item: *const vk.VkClearAttachment, validate_pnext: bool) bool {
    if (!validate_VkImageAspectFlags(extensions, &item.aspectMask))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkAttachmentDescription(extensions: *const Extensions, item: *const vk.VkAttachmentDescription, validate_pnext: bool) bool {
    if (!validate_VkAttachmentDescriptionFlags(extensions, &item.flags))
        return false;
    if (!validate_VkFormat(extensions, &item.format))
        return false;
    if (!validate_VkSampleCountFlags(extensions, &item.samples))
        return false;
    if (!validate_VkAttachmentLoadOp(extensions, &item.loadOp))
        return false;
    if (!validate_VkAttachmentStoreOp(extensions, &item.storeOp))
        return false;
    if (!validate_VkAttachmentLoadOp(extensions, &item.stencilLoadOp))
        return false;
    if (!validate_VkAttachmentStoreOp(extensions, &item.stencilStoreOp))
        return false;
    if (!validate_VkImageLayout(extensions, &item.initialLayout))
        return false;
    if (!validate_VkImageLayout(extensions, &item.finalLayout))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkAttachmentReference(extensions: *const Extensions, item: *const vk.VkAttachmentReference, validate_pnext: bool) bool {
    if (!validate_VkImageLayout(extensions, &item.layout))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkSubpassDescription(extensions: *const Extensions, item: *const vk.VkSubpassDescription, validate_pnext: bool) bool {
    if (!validate_VkSubpassDescriptionFlags(extensions, &item.flags))
        return false;
    if (!validate_VkPipelineBindPoint(extensions, &item.pipelineBindPoint))
        return false;
    if (item.pInputAttachments) |v| {
        for (v[0..item.inputAttachmentCount]) |*vv| {
            if (!validate_VkAttachmentReference(extensions, vv, false))
                return false;
        }
    }
    if (item.pColorAttachments) |v| {
        for (v[0..item.colorAttachmentCount]) |*vv| {
            if (!validate_VkAttachmentReference(extensions, vv, false))
                return false;
        }
    }
    if (item.pResolveAttachments) |v| {
        for (v[0..item.colorAttachmentCount]) |*vv| {
            if (!validate_VkAttachmentReference(extensions, vv, false))
                return false;
        }
    }
    if (item.pDepthStencilAttachment) |v| {
        if (!validate_VkAttachmentReference(extensions, v, false))
            return false;
    }
    _ = validate_pnext;
    return true;
}

pub fn validate_VkSubpassDependency(extensions: *const Extensions, item: *const vk.VkSubpassDependency, validate_pnext: bool) bool {
    if (!validate_VkPipelineStageFlags(extensions, &item.srcStageMask))
        return false;
    if (!validate_VkPipelineStageFlags(extensions, &item.dstStageMask))
        return false;
    if (!validate_VkAccessFlags(extensions, &item.srcAccessMask))
        return false;
    if (!validate_VkAccessFlags(extensions, &item.dstAccessMask))
        return false;
    if (!validate_VkDependencyFlags(extensions, &item.dependencyFlags))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkRenderPassCreateInfo(extensions: *const Extensions, item: *const vk.VkRenderPassCreateInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkRenderPassCreateFlags(extensions, &item.flags))
        return false;
    if (item.pAttachments) |v| {
        for (v[0..item.attachmentCount]) |*vv| {
            if (!validate_VkAttachmentDescription(extensions, vv, false))
                return false;
        }
    }
    if (item.pSubpasses) |v| {
        for (v[0..item.subpassCount]) |*vv| {
            if (!validate_VkSubpassDescription(extensions, vv, false))
                return false;
        }
    }
    if (item.pDependencies) |v| {
        for (v[0..item.dependencyCount]) |*vv| {
            if (!validate_VkSubpassDependency(extensions, vv, false))
                return false;
        }
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkRenderPassCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkEventCreateInfo(extensions: *const Extensions, item: *const vk.VkEventCreateInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkEventCreateFlags(extensions, &item.flags))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkEventCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkFenceCreateInfo(extensions: *const Extensions, item: *const vk.VkFenceCreateInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkFenceCreateFlags(extensions, &item.flags))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkFenceCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceFeatures, validate_pnext: bool) bool {
    _ = item;
    _ = extensions;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDeviceSparseProperties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceSparseProperties, validate_pnext: bool) bool {
    _ = item;
    _ = extensions;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDeviceLimits(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceLimits, validate_pnext: bool) bool {
    if (!validate_VkSampleCountFlags(extensions, &item.framebufferColorSampleCounts))
        return false;
    if (!validate_VkSampleCountFlags(extensions, &item.framebufferDepthSampleCounts))
        return false;
    if (!validate_VkSampleCountFlags(extensions, &item.framebufferStencilSampleCounts))
        return false;
    if (!validate_VkSampleCountFlags(extensions, &item.framebufferNoAttachmentsSampleCounts))
        return false;
    if (!validate_VkSampleCountFlags(extensions, &item.sampledImageColorSampleCounts))
        return false;
    if (!validate_VkSampleCountFlags(extensions, &item.sampledImageIntegerSampleCounts))
        return false;
    if (!validate_VkSampleCountFlags(extensions, &item.sampledImageDepthSampleCounts))
        return false;
    if (!validate_VkSampleCountFlags(extensions, &item.sampledImageStencilSampleCounts))
        return false;
    if (!validate_VkSampleCountFlags(extensions, &item.storageImageSampleCounts))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkSemaphoreCreateInfo(extensions: *const Extensions, item: *const vk.VkSemaphoreCreateInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkSemaphoreCreateFlags(extensions, &item.flags))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSemaphoreCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkQueryPoolCreateInfo(extensions: *const Extensions, item: *const vk.VkQueryPoolCreateInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkQueryPoolCreateFlags(extensions, &item.flags))
        return false;
    if (!validate_VkQueryType(extensions, &item.queryType))
        return false;
    if (!validate_VkQueryPipelineStatisticFlags(extensions, &item.pipelineStatistics))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkQueryPoolCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkFramebufferCreateInfo(extensions: *const Extensions, item: *const vk.VkFramebufferCreateInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkFramebufferCreateFlags(extensions, &item.flags))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkFramebufferCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDrawIndirectCommand(extensions: *const Extensions, item: *const vk.VkDrawIndirectCommand, validate_pnext: bool) bool {
    _ = item;
    _ = extensions;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkDrawIndexedIndirectCommand(extensions: *const Extensions, item: *const vk.VkDrawIndexedIndirectCommand, validate_pnext: bool) bool {
    _ = item;
    _ = extensions;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkDispatchIndirectCommand(extensions: *const Extensions, item: *const vk.VkDispatchIndirectCommand, validate_pnext: bool) bool {
    _ = item;
    _ = extensions;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkMultiDrawInfoEXT(extensions: *const Extensions, item: *const vk.VkMultiDrawInfoEXT, validate_pnext: bool) bool {
    _ = item;
    _ = extensions;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkMultiDrawIndexedInfoEXT(extensions: *const Extensions, item: *const vk.VkMultiDrawIndexedInfoEXT, validate_pnext: bool) bool {
    _ = item;
    _ = extensions;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkSubmitInfo(extensions: *const Extensions, item: *const vk.VkSubmitInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (item.pWaitDstStageMask) |v| {
        for (v[0..item.waitSemaphoreCount]) |*vv| {
            if (!validate_VkPipelineStageFlags(extensions, vv))
                return false;
        }
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSubmitInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDisplayPropertiesKHR(extensions: *const Extensions, item: *const vk.VkDisplayPropertiesKHR, validate_pnext: bool) bool {
    if (!validate_VkExtent2D(extensions, &item.physicalDimensions, false))
        return false;
    if (!validate_VkExtent2D(extensions, &item.physicalResolution, false))
        return false;
    if (!validate_VkSurfaceTransformFlagsKHR(extensions, &item.supportedTransforms))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkDisplayPlanePropertiesKHR(extensions: *const Extensions, item: *const vk.VkDisplayPlanePropertiesKHR, validate_pnext: bool) bool {
    _ = item;
    _ = extensions;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkDisplayModeParametersKHR(extensions: *const Extensions, item: *const vk.VkDisplayModeParametersKHR, validate_pnext: bool) bool {
    if (!validate_VkExtent2D(extensions, &item.visibleRegion, false))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkDisplayModePropertiesKHR(extensions: *const Extensions, item: *const vk.VkDisplayModePropertiesKHR, validate_pnext: bool) bool {
    if (!validate_VkDisplayModeParametersKHR(extensions, &item.parameters, false))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkDisplayModeCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkDisplayModeCreateInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkDisplayModeCreateFlagsKHR(extensions, &item.flags))
        return false;
    if (!validate_VkDisplayModeParametersKHR(extensions, &item.parameters, false))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDisplayModeCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDisplayPlaneCapabilitiesKHR(extensions: *const Extensions, item: *const vk.VkDisplayPlaneCapabilitiesKHR, validate_pnext: bool) bool {
    if (!validate_VkDisplayPlaneAlphaFlagsKHR(extensions, &item.supportedAlpha))
        return false;
    if (!validate_VkOffset2D(extensions, &item.minSrcPosition, false))
        return false;
    if (!validate_VkOffset2D(extensions, &item.maxSrcPosition, false))
        return false;
    if (!validate_VkExtent2D(extensions, &item.minSrcExtent, false))
        return false;
    if (!validate_VkExtent2D(extensions, &item.maxSrcExtent, false))
        return false;
    if (!validate_VkOffset2D(extensions, &item.minDstPosition, false))
        return false;
    if (!validate_VkOffset2D(extensions, &item.maxDstPosition, false))
        return false;
    if (!validate_VkExtent2D(extensions, &item.minDstExtent, false))
        return false;
    if (!validate_VkExtent2D(extensions, &item.maxDstExtent, false))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkDisplaySurfaceCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkDisplaySurfaceCreateInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkDisplaySurfaceCreateFlagsKHR(extensions, &item.flags))
        return false;
    if (!validate_VkSurfaceTransformFlagsKHR(extensions, &item.transform))
        return false;
    if (!validate_VkDisplayPlaneAlphaFlagsKHR(extensions, &item.alphaMode))
        return false;
    if (!validate_VkExtent2D(extensions, &item.imageExtent, false))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDisplaySurfaceCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDisplaySurfaceStereoCreateInfoNV(extensions: *const Extensions, item: *const vk.VkDisplaySurfaceStereoCreateInfoNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkDisplaySurfaceStereoTypeNV(extensions, &item.stereoType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR,
            => if (!validate_VkDisplaySurfaceCreateInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDisplaySurfaceStereoCreateInfoNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDisplayPresentInfoKHR(extensions: *const Extensions, item: *const vk.VkDisplayPresentInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkRect2D(extensions, &item.srcRect, false))
        return false;
    if (!validate_VkRect2D(extensions, &item.dstRect, false))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PRESENT_INFO_KHR,
            => if (!validate_VkPresentInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDisplayPresentInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSurfaceCapabilitiesKHR(extensions: *const Extensions, item: *const vk.VkSurfaceCapabilitiesKHR, validate_pnext: bool) bool {
    if (!validate_VkExtent2D(extensions, &item.currentExtent, false))
        return false;
    if (!validate_VkExtent2D(extensions, &item.minImageExtent, false))
        return false;
    if (!validate_VkExtent2D(extensions, &item.maxImageExtent, false))
        return false;
    if (!validate_VkSurfaceTransformFlagsKHR(extensions, &item.supportedTransforms))
        return false;
    if (!validate_VkSurfaceTransformFlagsKHR(extensions, &item.currentTransform))
        return false;
    if (!validate_VkCompositeAlphaFlagsKHR(extensions, &item.supportedCompositeAlpha))
        return false;
    if (!validate_VkImageUsageFlags(extensions, &item.supportedUsageFlags))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkAndroidSurfaceCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkAndroidSurfaceCreateInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkAndroidSurfaceCreateFlagsKHR(extensions, &item.flags))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkAndroidSurfaceCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkViSurfaceCreateInfoNN(extensions: *const Extensions, item: *const vk.VkViSurfaceCreateInfoNN, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkViSurfaceCreateFlagsNN(extensions, &item.flags))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkViSurfaceCreateInfoNN: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkWaylandSurfaceCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkWaylandSurfaceCreateInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkWaylandSurfaceCreateFlagsKHR(extensions, &item.flags))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkWaylandSurfaceCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkWin32SurfaceCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkWin32SurfaceCreateInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkWin32SurfaceCreateFlagsKHR(extensions, &item.flags))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkWin32SurfaceCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkXlibSurfaceCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkXlibSurfaceCreateInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkXlibSurfaceCreateFlagsKHR(extensions, &item.flags))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkXlibSurfaceCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkXcbSurfaceCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkXcbSurfaceCreateInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkXcbSurfaceCreateFlagsKHR(extensions, &item.flags))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkXcbSurfaceCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDirectFBSurfaceCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkDirectFBSurfaceCreateInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkDirectFBSurfaceCreateFlagsEXT(extensions, &item.flags))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDirectFBSurfaceCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImagePipeSurfaceCreateInfoFUCHSIA(extensions: *const Extensions, item: *const vk.VkImagePipeSurfaceCreateInfoFUCHSIA, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkImagePipeSurfaceCreateFlagsFUCHSIA(extensions, &item.flags))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImagePipeSurfaceCreateInfoFUCHSIA: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkStreamDescriptorSurfaceCreateInfoGGP(extensions: *const Extensions, item: *const vk.VkStreamDescriptorSurfaceCreateInfoGGP, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkStreamDescriptorSurfaceCreateFlagsGGP(extensions, &item.flags))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkStreamDescriptorSurfaceCreateInfoGGP: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkScreenSurfaceCreateInfoQNX(extensions: *const Extensions, item: *const vk.VkScreenSurfaceCreateInfoQNX, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkScreenSurfaceCreateFlagsQNX(extensions, &item.flags))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkScreenSurfaceCreateInfoQNX: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSurfaceFormatKHR(extensions: *const Extensions, item: *const vk.VkSurfaceFormatKHR, validate_pnext: bool) bool {
    if (!validate_VkFormat(extensions, &item.format))
        return false;
    if (!validate_VkColorSpaceKHR(extensions, &item.colorSpace))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkSwapchainCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkSwapchainCreateInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkSwapchainCreateFlagsKHR(extensions, &item.flags))
        return false;
    if (!validate_VkFormat(extensions, &item.imageFormat))
        return false;
    if (!validate_VkColorSpaceKHR(extensions, &item.imageColorSpace))
        return false;
    if (!validate_VkExtent2D(extensions, &item.imageExtent, false))
        return false;
    if (!validate_VkImageUsageFlags(extensions, &item.imageUsage))
        return false;
    if (!validate_VkSharingMode(extensions, &item.imageSharingMode))
        return false;
    if (!validate_VkSurfaceTransformFlagsKHR(extensions, &item.preTransform))
        return false;
    if (!validate_VkCompositeAlphaFlagsKHR(extensions, &item.compositeAlpha))
        return false;
    if (!validate_VkPresentModeKHR(extensions, &item.presentMode))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSwapchainCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPresentInfoKHR(extensions: *const Extensions, item: *const vk.VkPresentInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (item.pResults) |v| {
        for (v[0..item.swapchainCount]) |*vv| {
            if (!validate_VkResult(extensions, vv))
                return false;
        }
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPresentInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDebugReportCallbackCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkDebugReportCallbackCreateInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkDebugReportFlagsEXT(extensions, &item.flags))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO,
            => if (!validate_VkInstanceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDebugReportCallbackCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkValidationFlagsEXT(extensions: *const Extensions, item: *const vk.VkValidationFlagsEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (item.pDisabledValidationChecks) |v| {
        for (v[0..item.disabledValidationCheckCount]) |*vv| {
            if (!validate_VkValidationCheckEXT(extensions, vv))
                return false;
        }
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO,
            => if (!validate_VkInstanceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkValidationFlagsEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkValidationFeaturesEXT(extensions: *const Extensions, item: *const vk.VkValidationFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (item.pEnabledValidationFeatures) |v| {
        for (v[0..item.enabledValidationFeatureCount]) |*vv| {
            if (!validate_VkValidationFeatureEnableEXT(extensions, vv))
                return false;
        }
    }
    if (item.pDisabledValidationFeatures) |v| {
        for (v[0..item.disabledValidationFeatureCount]) |*vv| {
            if (!validate_VkValidationFeatureDisableEXT(extensions, vv))
                return false;
        }
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO,
            => if (!validate_VkInstanceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO,
            => if (!validate_VkShaderModuleCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_SHADER_CREATE_INFO_EXT,
            => if (!validate_VkShaderCreateInfoEXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkValidationFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkLayerSettingsCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkLayerSettingsCreateInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (item.pSettings) |v| {
        for (v[0..item.settingCount]) |*vv| {
            if (!validate_VkLayerSettingEXT(extensions, vv, false))
                return false;
        }
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO,
            => if (!validate_VkInstanceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkLayerSettingsCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkLayerSettingEXT(extensions: *const Extensions, item: *const vk.VkLayerSettingEXT, validate_pnext: bool) bool {
    if (!validate_VkLayerSettingTypeEXT(extensions, &item.type))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkApplicationParametersEXT(extensions: *const Extensions, item: *const vk.VkApplicationParametersEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_APPLICATION_INFO,
            => if (!validate_VkApplicationInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkApplicationParametersEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPipelineRasterizationStateRasterizationOrderAMD(extensions: *const Extensions, item: *const vk.VkPipelineRasterizationStateRasterizationOrderAMD, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkRasterizationOrderAMD(extensions, &item.rasterizationOrder))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO,
            => if (!validate_VkPipelineRasterizationStateCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineRasterizationStateRasterizationOrderAMD: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDebugMarkerObjectNameInfoEXT(extensions: *const Extensions, item: *const vk.VkDebugMarkerObjectNameInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkDebugReportObjectTypeEXT(extensions, &item.objectType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDebugMarkerObjectNameInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDebugMarkerObjectTagInfoEXT(extensions: *const Extensions, item: *const vk.VkDebugMarkerObjectTagInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkDebugReportObjectTypeEXT(extensions, &item.objectType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDebugMarkerObjectTagInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDebugMarkerMarkerInfoEXT(extensions: *const Extensions, item: *const vk.VkDebugMarkerMarkerInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDebugMarkerMarkerInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDedicatedAllocationImageCreateInfoNV(extensions: *const Extensions, item: *const vk.VkDedicatedAllocationImageCreateInfoNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO,
            => if (!validate_VkImageCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDedicatedAllocationImageCreateInfoNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDedicatedAllocationBufferCreateInfoNV(extensions: *const Extensions, item: *const vk.VkDedicatedAllocationBufferCreateInfoNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO,
            => if (!validate_VkBufferCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDedicatedAllocationBufferCreateInfoNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDedicatedAllocationMemoryAllocateInfoNV(extensions: *const Extensions, item: *const vk.VkDedicatedAllocationMemoryAllocateInfoNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO,
            => if (!validate_VkMemoryAllocateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDedicatedAllocationMemoryAllocateInfoNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkExternalImageFormatPropertiesNV(extensions: *const Extensions, item: *const vk.VkExternalImageFormatPropertiesNV, validate_pnext: bool) bool {
    if (!validate_VkImageFormatProperties(extensions, &item.imageFormatProperties, false))
        return false;
    if (!validate_VkExternalMemoryFeatureFlagsNV(extensions, &item.externalMemoryFeatures))
        return false;
    if (!validate_VkExternalMemoryHandleTypeFlagsNV(extensions, &item.exportFromImportedHandleTypes))
        return false;
    if (!validate_VkExternalMemoryHandleTypeFlagsNV(extensions, &item.compatibleHandleTypes))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkExternalMemoryImageCreateInfoNV(extensions: *const Extensions, item: *const vk.VkExternalMemoryImageCreateInfoNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkExternalMemoryHandleTypeFlagsNV(extensions, &item.handleTypes))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO,
            => if (!validate_VkImageCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkExternalMemoryImageCreateInfoNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkExportMemoryAllocateInfoNV(extensions: *const Extensions, item: *const vk.VkExportMemoryAllocateInfoNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkExternalMemoryHandleTypeFlagsNV(extensions, &item.handleTypes))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO,
            => if (!validate_VkMemoryAllocateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkExportMemoryAllocateInfoNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImportMemoryWin32HandleInfoNV(extensions: *const Extensions, item: *const vk.VkImportMemoryWin32HandleInfoNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkExternalMemoryHandleTypeFlagsNV(extensions, &item.handleType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO,
            => if (!validate_VkMemoryAllocateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImportMemoryWin32HandleInfoNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkExportMemoryWin32HandleInfoNV(extensions: *const Extensions, item: *const vk.VkExportMemoryWin32HandleInfoNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO,
            => if (!validate_VkMemoryAllocateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkExportMemoryWin32HandleInfoNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkExportMemorySciBufInfoNV(extensions: *const Extensions, item: *const vk.VkExportMemorySciBufInfoNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO,
            => if (!validate_VkMemoryAllocateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkExportMemorySciBufInfoNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImportMemorySciBufInfoNV(extensions: *const Extensions, item: *const vk.VkImportMemorySciBufInfoNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkExternalMemoryHandleTypeFlags(extensions, &item.handleType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO,
            => if (!validate_VkMemoryAllocateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImportMemorySciBufInfoNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkMemoryGetSciBufInfoNV(extensions: *const Extensions, item: *const vk.VkMemoryGetSciBufInfoNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkExternalMemoryHandleTypeFlags(extensions, &item.handleType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMemoryGetSciBufInfoNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkMemorySciBufPropertiesNV(extensions: *const Extensions, item: *const vk.VkMemorySciBufPropertiesNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMemorySciBufPropertiesNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceExternalMemorySciBufFeaturesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceExternalMemorySciBufFeaturesNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceExternalMemorySciBufFeaturesNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkWin32KeyedMutexAcquireReleaseInfoNV(extensions: *const Extensions, item: *const vk.VkWin32KeyedMutexAcquireReleaseInfoNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_SUBMIT_INFO,
            => if (!validate_VkSubmitInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_SUBMIT_INFO_2,
            => if (!validate_VkSubmitInfo2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkWin32KeyedMutexAcquireReleaseInfoNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDevicePrivateDataCreateInfo(extensions: *const Extensions, item: *const vk.VkDevicePrivateDataCreateInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDevicePrivateDataCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPrivateDataSlotCreateInfo(extensions: *const Extensions, item: *const vk.VkPrivateDataSlotCreateInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkPrivateDataSlotCreateFlags(extensions, &item.flags))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPrivateDataSlotCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDevicePrivateDataFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePrivateDataFeatures, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDevicePrivateDataFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceClusterAccelerationStructureFeaturesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceClusterAccelerationStructureFeaturesNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceClusterAccelerationStructureFeaturesNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceClusterAccelerationStructurePropertiesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceClusterAccelerationStructurePropertiesNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceClusterAccelerationStructurePropertiesNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkStridedDeviceAddressNV(extensions: *const Extensions, item: *const vk.VkStridedDeviceAddressNV, validate_pnext: bool) bool {
    _ = item;
    _ = extensions;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkRayTracingPipelineClusterAccelerationStructureCreateInfoNV(extensions: *const Extensions, item: *const vk.VkRayTracingPipelineClusterAccelerationStructureCreateInfoNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_KHR,
            => if (!validate_VkRayTracingPipelineCreateInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkRayTracingPipelineClusterAccelerationStructureCreateInfoNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV(extensions: *const Extensions, item: *const vk.VkClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV, validate_pnext: bool) bool {
    _ = item;
    _ = extensions;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkClusterAccelerationStructureMoveObjectsInfoNV(extensions: *const Extensions, item: *const vk.VkClusterAccelerationStructureMoveObjectsInfoNV, validate_pnext: bool) bool {
    _ = item;
    _ = extensions;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkClusterAccelerationStructureBuildClustersBottomLevelInfoNV(extensions: *const Extensions, item: *const vk.VkClusterAccelerationStructureBuildClustersBottomLevelInfoNV, validate_pnext: bool) bool {
    _ = item;
    _ = extensions;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkClusterAccelerationStructureGetTemplateIndicesInfoNV(extensions: *const Extensions, item: *const vk.VkClusterAccelerationStructureGetTemplateIndicesInfoNV, validate_pnext: bool) bool {
    _ = item;
    _ = extensions;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkClusterAccelerationStructureBuildTriangleClusterInfoNV(extensions: *const Extensions, item: *const vk.VkClusterAccelerationStructureBuildTriangleClusterInfoNV, validate_pnext: bool) bool {
    if (!validate_VkClusterAccelerationStructureClusterFlagsNV(extensions, &item.clusterFlags))
        return false;
    if (!validate_VkClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV(extensions, &item.baseGeometryIndexAndGeometryFlags, false))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkClusterAccelerationStructureBuildTriangleClusterTemplateInfoNV(extensions: *const Extensions, item: *const vk.VkClusterAccelerationStructureBuildTriangleClusterTemplateInfoNV, validate_pnext: bool) bool {
    if (!validate_VkClusterAccelerationStructureClusterFlagsNV(extensions, &item.clusterFlags))
        return false;
    if (!validate_VkClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV(extensions, &item.baseGeometryIndexAndGeometryFlags, false))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkClusterAccelerationStructureInstantiateClusterInfoNV(extensions: *const Extensions, item: *const vk.VkClusterAccelerationStructureInstantiateClusterInfoNV, validate_pnext: bool) bool {
    if (!validate_VkStridedDeviceAddressNV(extensions, &item.vertexBuffer, false))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkClusterAccelerationStructureClustersBottomLevelInputNV(extensions: *const Extensions, item: *const vk.VkClusterAccelerationStructureClustersBottomLevelInputNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkClusterAccelerationStructureClustersBottomLevelInputNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkClusterAccelerationStructureTriangleClusterInputNV(extensions: *const Extensions, item: *const vk.VkClusterAccelerationStructureTriangleClusterInputNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkFormat(extensions, &item.vertexFormat))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkClusterAccelerationStructureTriangleClusterInputNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkClusterAccelerationStructureMoveObjectsInputNV(extensions: *const Extensions, item: *const vk.VkClusterAccelerationStructureMoveObjectsInputNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkClusterAccelerationStructureTypeNV(extensions, &item.type))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkClusterAccelerationStructureMoveObjectsInputNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkClusterAccelerationStructureInputInfoNV(extensions: *const Extensions, item: *const vk.VkClusterAccelerationStructureInputInfoNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkBuildAccelerationStructureFlagsKHR(extensions, &item.flags))
        return false;
    if (!validate_VkClusterAccelerationStructureOpTypeNV(extensions, &item.opType))
        return false;
    if (!validate_VkClusterAccelerationStructureOpModeNV(extensions, &item.opMode))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkClusterAccelerationStructureInputInfoNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkClusterAccelerationStructureCommandsInfoNV(extensions: *const Extensions, item: *const vk.VkClusterAccelerationStructureCommandsInfoNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkClusterAccelerationStructureInputInfoNV(extensions, &item.input, false))
        return false;
    if (!validate_VkStridedDeviceAddressRegionKHR(extensions, &item.dstAddressesArray, false))
        return false;
    if (!validate_VkStridedDeviceAddressRegionKHR(extensions, &item.dstSizesArray, false))
        return false;
    if (!validate_VkStridedDeviceAddressRegionKHR(extensions, &item.srcInfosArray, false))
        return false;
    if (!validate_VkClusterAccelerationStructureAddressResolutionFlagsNV(extensions, &item.addressResolutionFlags))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkClusterAccelerationStructureCommandsInfoNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceMultiDrawPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMultiDrawPropertiesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceMultiDrawPropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkGraphicsShaderGroupCreateInfoNV(extensions: *const Extensions, item: *const vk.VkGraphicsShaderGroupCreateInfoNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (item.pStages) |v| {
        for (v[0..item.stageCount]) |*vv| {
            if (!validate_VkPipelineShaderStageCreateInfo(extensions, vv, false))
                return false;
        }
    }
    if (item.pVertexInputState) |v| {
        if (!validate_VkPipelineVertexInputStateCreateInfo(extensions, v, false))
            return false;
    }
    if (item.pTessellationState) |v| {
        if (!validate_VkPipelineTessellationStateCreateInfo(extensions, v, false))
            return false;
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkGraphicsShaderGroupCreateInfoNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkGraphicsPipelineShaderGroupsCreateInfoNV(extensions: *const Extensions, item: *const vk.VkGraphicsPipelineShaderGroupsCreateInfoNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (item.pGroups) |v| {
        for (v[0..item.groupCount]) |*vv| {
            if (!validate_VkGraphicsShaderGroupCreateInfoNV(extensions, vv, false))
                return false;
        }
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO,
            => if (!validate_VkGraphicsPipelineCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkGraphicsPipelineShaderGroupsCreateInfoNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkBindShaderGroupIndirectCommandNV(extensions: *const Extensions, item: *const vk.VkBindShaderGroupIndirectCommandNV, validate_pnext: bool) bool {
    _ = item;
    _ = extensions;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkBindIndexBufferIndirectCommandNV(extensions: *const Extensions, item: *const vk.VkBindIndexBufferIndirectCommandNV, validate_pnext: bool) bool {
    if (!validate_VkIndexType(extensions, &item.indexType))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkBindVertexBufferIndirectCommandNV(extensions: *const Extensions, item: *const vk.VkBindVertexBufferIndirectCommandNV, validate_pnext: bool) bool {
    _ = item;
    _ = extensions;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkSetStateFlagsIndirectCommandNV(extensions: *const Extensions, item: *const vk.VkSetStateFlagsIndirectCommandNV, validate_pnext: bool) bool {
    _ = item;
    _ = extensions;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkIndirectCommandsStreamNV(extensions: *const Extensions, item: *const vk.VkIndirectCommandsStreamNV, validate_pnext: bool) bool {
    _ = item;
    _ = extensions;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkIndirectCommandsLayoutTokenNV(extensions: *const Extensions, item: *const vk.VkIndirectCommandsLayoutTokenNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkIndirectCommandsTokenTypeNV(extensions, &item.tokenType))
        return false;
    if (!validate_VkShaderStageFlags(extensions, &item.pushconstantShaderStageFlags))
        return false;
    if (!validate_VkIndirectStateFlagsNV(extensions, &item.indirectStateFlags))
        return false;
    if (item.pIndexTypes) |v| {
        for (v[0..item.indexTypeCount]) |*vv| {
            if (!validate_VkIndexType(extensions, vv))
                return false;
        }
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkIndirectCommandsLayoutTokenNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkIndirectCommandsLayoutCreateInfoNV(extensions: *const Extensions, item: *const vk.VkIndirectCommandsLayoutCreateInfoNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkIndirectCommandsLayoutUsageFlagsNV(extensions, &item.flags))
        return false;
    if (!validate_VkPipelineBindPoint(extensions, &item.pipelineBindPoint))
        return false;
    if (item.pTokens) |v| {
        for (v[0..item.tokenCount]) |*vv| {
            if (!validate_VkIndirectCommandsLayoutTokenNV(extensions, vv, false))
                return false;
        }
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkIndirectCommandsLayoutCreateInfoNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkGeneratedCommandsInfoNV(extensions: *const Extensions, item: *const vk.VkGeneratedCommandsInfoNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkPipelineBindPoint(extensions, &item.pipelineBindPoint))
        return false;
    if (item.pStreams) |v| {
        for (v[0..item.streamCount]) |*vv| {
            if (!validate_VkIndirectCommandsStreamNV(extensions, vv, false))
                return false;
        }
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkGeneratedCommandsInfoNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkGeneratedCommandsMemoryRequirementsInfoNV(extensions: *const Extensions, item: *const vk.VkGeneratedCommandsMemoryRequirementsInfoNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkPipelineBindPoint(extensions, &item.pipelineBindPoint))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkGeneratedCommandsMemoryRequirementsInfoNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPipelineIndirectDeviceAddressInfoNV(extensions: *const Extensions, item: *const vk.VkPipelineIndirectDeviceAddressInfoNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkPipelineBindPoint(extensions, &item.pipelineBindPoint))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineIndirectDeviceAddressInfoNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkBindPipelineIndirectCommandNV(extensions: *const Extensions, item: *const vk.VkBindPipelineIndirectCommandNV, validate_pnext: bool) bool {
    _ = item;
    _ = extensions;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDeviceFeatures2(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceFeatures2, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkPhysicalDeviceFeatures(extensions, &item.features, false))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceFeatures2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceProperties2(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceProperties2, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkPhysicalDeviceProperties(extensions, &item.properties, false))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceProperties2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkFormatProperties2(extensions: *const Extensions, item: *const vk.VkFormatProperties2, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkFormatProperties(extensions, &item.formatProperties, false))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkFormatProperties2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImageFormatProperties2(extensions: *const Extensions, item: *const vk.VkImageFormatProperties2, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkImageFormatProperties(extensions, &item.imageFormatProperties, false))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImageFormatProperties2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceImageFormatInfo2(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceImageFormatInfo2, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkFormat(extensions, &item.format))
        return false;
    if (!validate_VkImageType(extensions, &item.type))
        return false;
    if (!validate_VkImageTiling(extensions, &item.tiling))
        return false;
    if (!validate_VkImageUsageFlags(extensions, &item.usage))
        return false;
    if (!validate_VkImageCreateFlags(extensions, &item.flags))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceImageFormatInfo2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkQueueFamilyProperties2(extensions: *const Extensions, item: *const vk.VkQueueFamilyProperties2, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkQueueFamilyProperties(extensions, &item.queueFamilyProperties, false))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkQueueFamilyProperties2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceMemoryProperties2(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMemoryProperties2, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkPhysicalDeviceMemoryProperties(extensions, &item.memoryProperties, false))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceMemoryProperties2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSparseImageFormatProperties2(extensions: *const Extensions, item: *const vk.VkSparseImageFormatProperties2, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkSparseImageFormatProperties(extensions, &item.properties, false))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSparseImageFormatProperties2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceSparseImageFormatInfo2(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceSparseImageFormatInfo2, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkFormat(extensions, &item.format))
        return false;
    if (!validate_VkImageType(extensions, &item.type))
        return false;
    if (!validate_VkSampleCountFlags(extensions, &item.samples))
        return false;
    if (!validate_VkImageUsageFlags(extensions, &item.usage))
        return false;
    if (!validate_VkImageTiling(extensions, &item.tiling))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceSparseImageFormatInfo2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDevicePushDescriptorProperties(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePushDescriptorProperties, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDevicePushDescriptorProperties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkConformanceVersion(extensions: *const Extensions, item: *const vk.VkConformanceVersion, validate_pnext: bool) bool {
    _ = item;
    _ = extensions;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDeviceDriverProperties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDriverProperties, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkDriverId(extensions, &item.driverID))
        return false;
    if (!validate_VkConformanceVersion(extensions, &item.conformanceVersion, false))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceDriverProperties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPresentRegionsKHR(extensions: *const Extensions, item: *const vk.VkPresentRegionsKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (item.pRegions) |v| {
        for (v[0..item.swapchainCount]) |*vv| {
            if (!validate_VkPresentRegionKHR(extensions, vv, false))
                return false;
        }
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PRESENT_INFO_KHR,
            => if (!validate_VkPresentInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPresentRegionsKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPresentRegionKHR(extensions: *const Extensions, item: *const vk.VkPresentRegionKHR, validate_pnext: bool) bool {
    if (item.pRectangles) |v| {
        for (v[0..item.rectangleCount]) |*vv| {
            if (!validate_VkRectLayerKHR(extensions, vv, false))
                return false;
        }
    }
    _ = validate_pnext;
    return true;
}

pub fn validate_VkRectLayerKHR(extensions: *const Extensions, item: *const vk.VkRectLayerKHR, validate_pnext: bool) bool {
    if (!validate_VkOffset2D(extensions, &item.offset, false))
        return false;
    if (!validate_VkExtent2D(extensions, &item.extent, false))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDeviceVariablePointersFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVariablePointersFeatures, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceVariablePointersFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkExternalMemoryProperties(extensions: *const Extensions, item: *const vk.VkExternalMemoryProperties, validate_pnext: bool) bool {
    if (!validate_VkExternalMemoryFeatureFlags(extensions, &item.externalMemoryFeatures))
        return false;
    if (!validate_VkExternalMemoryHandleTypeFlags(extensions, &item.exportFromImportedHandleTypes))
        return false;
    if (!validate_VkExternalMemoryHandleTypeFlags(extensions, &item.compatibleHandleTypes))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDeviceExternalImageFormatInfo(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceExternalImageFormatInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkExternalMemoryHandleTypeFlags(extensions, &item.handleType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2,
            => if (!validate_VkPhysicalDeviceImageFormatInfo2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceExternalImageFormatInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkExternalImageFormatProperties(extensions: *const Extensions, item: *const vk.VkExternalImageFormatProperties, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkExternalMemoryProperties(extensions, &item.externalMemoryProperties, false))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2,
            => if (!validate_VkImageFormatProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkExternalImageFormatProperties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceExternalBufferInfo(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceExternalBufferInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkBufferCreateFlags(extensions, &item.flags))
        return false;
    if (!validate_VkBufferUsageFlags(extensions, &item.usage))
        return false;
    if (!validate_VkExternalMemoryHandleTypeFlags(extensions, &item.handleType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceExternalBufferInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkExternalBufferProperties(extensions: *const Extensions, item: *const vk.VkExternalBufferProperties, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkExternalMemoryProperties(extensions, &item.externalMemoryProperties, false))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkExternalBufferProperties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceIDProperties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceIDProperties, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceIDProperties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkExternalMemoryImageCreateInfo(extensions: *const Extensions, item: *const vk.VkExternalMemoryImageCreateInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkExternalMemoryHandleTypeFlags(extensions, &item.handleTypes))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO,
            => if (!validate_VkImageCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkExternalMemoryImageCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkExternalMemoryBufferCreateInfo(extensions: *const Extensions, item: *const vk.VkExternalMemoryBufferCreateInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkExternalMemoryHandleTypeFlags(extensions, &item.handleTypes))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO,
            => if (!validate_VkBufferCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkExternalMemoryBufferCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkExportMemoryAllocateInfo(extensions: *const Extensions, item: *const vk.VkExportMemoryAllocateInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkExternalMemoryHandleTypeFlags(extensions, &item.handleTypes))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO,
            => if (!validate_VkMemoryAllocateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkExportMemoryAllocateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImportMemoryWin32HandleInfoKHR(extensions: *const Extensions, item: *const vk.VkImportMemoryWin32HandleInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkExternalMemoryHandleTypeFlags(extensions, &item.handleType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO,
            => if (!validate_VkMemoryAllocateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImportMemoryWin32HandleInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkExportMemoryWin32HandleInfoKHR(extensions: *const Extensions, item: *const vk.VkExportMemoryWin32HandleInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO,
            => if (!validate_VkMemoryAllocateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkExportMemoryWin32HandleInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImportMemoryZirconHandleInfoFUCHSIA(extensions: *const Extensions, item: *const vk.VkImportMemoryZirconHandleInfoFUCHSIA, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkExternalMemoryHandleTypeFlags(extensions, &item.handleType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO,
            => if (!validate_VkMemoryAllocateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImportMemoryZirconHandleInfoFUCHSIA: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkMemoryZirconHandlePropertiesFUCHSIA(extensions: *const Extensions, item: *const vk.VkMemoryZirconHandlePropertiesFUCHSIA, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMemoryZirconHandlePropertiesFUCHSIA: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkMemoryGetZirconHandleInfoFUCHSIA(extensions: *const Extensions, item: *const vk.VkMemoryGetZirconHandleInfoFUCHSIA, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkExternalMemoryHandleTypeFlags(extensions, &item.handleType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMemoryGetZirconHandleInfoFUCHSIA: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkMemoryWin32HandlePropertiesKHR(extensions: *const Extensions, item: *const vk.VkMemoryWin32HandlePropertiesKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMemoryWin32HandlePropertiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkMemoryGetWin32HandleInfoKHR(extensions: *const Extensions, item: *const vk.VkMemoryGetWin32HandleInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkExternalMemoryHandleTypeFlags(extensions, &item.handleType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMemoryGetWin32HandleInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImportMemoryFdInfoKHR(extensions: *const Extensions, item: *const vk.VkImportMemoryFdInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkExternalMemoryHandleTypeFlags(extensions, &item.handleType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO,
            => if (!validate_VkMemoryAllocateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImportMemoryFdInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkMemoryFdPropertiesKHR(extensions: *const Extensions, item: *const vk.VkMemoryFdPropertiesKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMemoryFdPropertiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkMemoryGetFdInfoKHR(extensions: *const Extensions, item: *const vk.VkMemoryGetFdInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkExternalMemoryHandleTypeFlags(extensions, &item.handleType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMemoryGetFdInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkWin32KeyedMutexAcquireReleaseInfoKHR(extensions: *const Extensions, item: *const vk.VkWin32KeyedMutexAcquireReleaseInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_SUBMIT_INFO,
            => if (!validate_VkSubmitInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_SUBMIT_INFO_2,
            => if (!validate_VkSubmitInfo2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkWin32KeyedMutexAcquireReleaseInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImportMemoryMetalHandleInfoEXT(extensions: *const Extensions, item: *const vk.VkImportMemoryMetalHandleInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkExternalMemoryHandleTypeFlags(extensions, &item.handleType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO,
            => if (!validate_VkMemoryAllocateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImportMemoryMetalHandleInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkMemoryMetalHandlePropertiesEXT(extensions: *const Extensions, item: *const vk.VkMemoryMetalHandlePropertiesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMemoryMetalHandlePropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkMemoryGetMetalHandleInfoEXT(extensions: *const Extensions, item: *const vk.VkMemoryGetMetalHandleInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkExternalMemoryHandleTypeFlags(extensions, &item.handleType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMemoryGetMetalHandleInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceExternalSemaphoreInfo(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceExternalSemaphoreInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkExternalSemaphoreHandleTypeFlags(extensions, &item.handleType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceExternalSemaphoreInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkExternalSemaphoreProperties(extensions: *const Extensions, item: *const vk.VkExternalSemaphoreProperties, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkExternalSemaphoreHandleTypeFlags(extensions, &item.exportFromImportedHandleTypes))
        return false;
    if (!validate_VkExternalSemaphoreHandleTypeFlags(extensions, &item.compatibleHandleTypes))
        return false;
    if (!validate_VkExternalSemaphoreFeatureFlags(extensions, &item.externalSemaphoreFeatures))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkExternalSemaphoreProperties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkExportSemaphoreCreateInfo(extensions: *const Extensions, item: *const vk.VkExportSemaphoreCreateInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkExternalSemaphoreHandleTypeFlags(extensions, &item.handleTypes))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO,
            => if (!validate_VkSemaphoreCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkExportSemaphoreCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImportSemaphoreWin32HandleInfoKHR(extensions: *const Extensions, item: *const vk.VkImportSemaphoreWin32HandleInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkSemaphoreImportFlags(extensions, &item.flags))
        return false;
    if (!validate_VkExternalSemaphoreHandleTypeFlags(extensions, &item.handleType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImportSemaphoreWin32HandleInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkExportSemaphoreWin32HandleInfoKHR(extensions: *const Extensions, item: *const vk.VkExportSemaphoreWin32HandleInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO,
            => if (!validate_VkSemaphoreCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkExportSemaphoreWin32HandleInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkD3D12FenceSubmitInfoKHR(extensions: *const Extensions, item: *const vk.VkD3D12FenceSubmitInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_SUBMIT_INFO,
            => if (!validate_VkSubmitInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkD3D12FenceSubmitInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSemaphoreGetWin32HandleInfoKHR(extensions: *const Extensions, item: *const vk.VkSemaphoreGetWin32HandleInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkExternalSemaphoreHandleTypeFlags(extensions, &item.handleType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSemaphoreGetWin32HandleInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImportSemaphoreFdInfoKHR(extensions: *const Extensions, item: *const vk.VkImportSemaphoreFdInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkSemaphoreImportFlags(extensions, &item.flags))
        return false;
    if (!validate_VkExternalSemaphoreHandleTypeFlags(extensions, &item.handleType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImportSemaphoreFdInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSemaphoreGetFdInfoKHR(extensions: *const Extensions, item: *const vk.VkSemaphoreGetFdInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkExternalSemaphoreHandleTypeFlags(extensions, &item.handleType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSemaphoreGetFdInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImportSemaphoreZirconHandleInfoFUCHSIA(extensions: *const Extensions, item: *const vk.VkImportSemaphoreZirconHandleInfoFUCHSIA, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkSemaphoreImportFlags(extensions, &item.flags))
        return false;
    if (!validate_VkExternalSemaphoreHandleTypeFlags(extensions, &item.handleType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImportSemaphoreZirconHandleInfoFUCHSIA: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSemaphoreGetZirconHandleInfoFUCHSIA(extensions: *const Extensions, item: *const vk.VkSemaphoreGetZirconHandleInfoFUCHSIA, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkExternalSemaphoreHandleTypeFlags(extensions, &item.handleType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSemaphoreGetZirconHandleInfoFUCHSIA: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceExternalFenceInfo(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceExternalFenceInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkExternalFenceHandleTypeFlags(extensions, &item.handleType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceExternalFenceInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkExternalFenceProperties(extensions: *const Extensions, item: *const vk.VkExternalFenceProperties, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkExternalFenceHandleTypeFlags(extensions, &item.exportFromImportedHandleTypes))
        return false;
    if (!validate_VkExternalFenceHandleTypeFlags(extensions, &item.compatibleHandleTypes))
        return false;
    if (!validate_VkExternalFenceFeatureFlags(extensions, &item.externalFenceFeatures))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkExternalFenceProperties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkExportFenceCreateInfo(extensions: *const Extensions, item: *const vk.VkExportFenceCreateInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkExternalFenceHandleTypeFlags(extensions, &item.handleTypes))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_FENCE_CREATE_INFO,
            => if (!validate_VkFenceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkExportFenceCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImportFenceWin32HandleInfoKHR(extensions: *const Extensions, item: *const vk.VkImportFenceWin32HandleInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkFenceImportFlags(extensions, &item.flags))
        return false;
    if (!validate_VkExternalFenceHandleTypeFlags(extensions, &item.handleType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImportFenceWin32HandleInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkExportFenceWin32HandleInfoKHR(extensions: *const Extensions, item: *const vk.VkExportFenceWin32HandleInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_FENCE_CREATE_INFO,
            => if (!validate_VkFenceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkExportFenceWin32HandleInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkFenceGetWin32HandleInfoKHR(extensions: *const Extensions, item: *const vk.VkFenceGetWin32HandleInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkExternalFenceHandleTypeFlags(extensions, &item.handleType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkFenceGetWin32HandleInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImportFenceFdInfoKHR(extensions: *const Extensions, item: *const vk.VkImportFenceFdInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkFenceImportFlags(extensions, &item.flags))
        return false;
    if (!validate_VkExternalFenceHandleTypeFlags(extensions, &item.handleType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImportFenceFdInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkFenceGetFdInfoKHR(extensions: *const Extensions, item: *const vk.VkFenceGetFdInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkExternalFenceHandleTypeFlags(extensions, &item.handleType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkFenceGetFdInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkExportFenceSciSyncInfoNV(extensions: *const Extensions, item: *const vk.VkExportFenceSciSyncInfoNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_FENCE_CREATE_INFO,
            => if (!validate_VkFenceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkExportFenceSciSyncInfoNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImportFenceSciSyncInfoNV(extensions: *const Extensions, item: *const vk.VkImportFenceSciSyncInfoNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkExternalFenceHandleTypeFlags(extensions, &item.handleType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImportFenceSciSyncInfoNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkFenceGetSciSyncInfoNV(extensions: *const Extensions, item: *const vk.VkFenceGetSciSyncInfoNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkExternalFenceHandleTypeFlags(extensions, &item.handleType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkFenceGetSciSyncInfoNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkExportSemaphoreSciSyncInfoNV(extensions: *const Extensions, item: *const vk.VkExportSemaphoreSciSyncInfoNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO,
            => if (!validate_VkSemaphoreCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkExportSemaphoreSciSyncInfoNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImportSemaphoreSciSyncInfoNV(extensions: *const Extensions, item: *const vk.VkImportSemaphoreSciSyncInfoNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkExternalSemaphoreHandleTypeFlags(extensions, &item.handleType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImportSemaphoreSciSyncInfoNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSemaphoreGetSciSyncInfoNV(extensions: *const Extensions, item: *const vk.VkSemaphoreGetSciSyncInfoNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkExternalSemaphoreHandleTypeFlags(extensions, &item.handleType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSemaphoreGetSciSyncInfoNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSciSyncAttributesInfoNV(extensions: *const Extensions, item: *const vk.VkSciSyncAttributesInfoNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkSciSyncClientTypeNV(extensions, &item.clientType))
        return false;
    if (!validate_VkSciSyncPrimitiveTypeNV(extensions, &item.primitiveType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSciSyncAttributesInfoNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceExternalSciSyncFeaturesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceExternalSciSyncFeaturesNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceExternalSciSyncFeaturesNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceExternalSciSync2FeaturesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceExternalSciSync2FeaturesNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceExternalSciSync2FeaturesNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSemaphoreSciSyncPoolCreateInfoNV(extensions: *const Extensions, item: *const vk.VkSemaphoreSciSyncPoolCreateInfoNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSemaphoreSciSyncPoolCreateInfoNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSemaphoreSciSyncCreateInfoNV(extensions: *const Extensions, item: *const vk.VkSemaphoreSciSyncCreateInfoNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO,
            => if (!validate_VkSemaphoreCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSemaphoreSciSyncCreateInfoNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDeviceSemaphoreSciSyncPoolReservationCreateInfoNV(extensions: *const Extensions, item: *const vk.VkDeviceSemaphoreSciSyncPoolReservationCreateInfoNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDeviceSemaphoreSciSyncPoolReservationCreateInfoNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceMultiviewFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMultiviewFeatures, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceMultiviewFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceMultiviewProperties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMultiviewProperties, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceMultiviewProperties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkRenderPassMultiviewCreateInfo(extensions: *const Extensions, item: *const vk.VkRenderPassMultiviewCreateInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO,
            => if (!validate_VkRenderPassCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkRenderPassMultiviewCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSurfaceCapabilities2EXT(extensions: *const Extensions, item: *const vk.VkSurfaceCapabilities2EXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkExtent2D(extensions, &item.currentExtent, false))
        return false;
    if (!validate_VkExtent2D(extensions, &item.minImageExtent, false))
        return false;
    if (!validate_VkExtent2D(extensions, &item.maxImageExtent, false))
        return false;
    if (!validate_VkSurfaceTransformFlagsKHR(extensions, &item.supportedTransforms))
        return false;
    if (!validate_VkSurfaceTransformFlagsKHR(extensions, &item.currentTransform))
        return false;
    if (!validate_VkCompositeAlphaFlagsKHR(extensions, &item.supportedCompositeAlpha))
        return false;
    if (!validate_VkImageUsageFlags(extensions, &item.supportedUsageFlags))
        return false;
    if (!validate_VkSurfaceCounterFlagsEXT(extensions, &item.supportedSurfaceCounters))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSurfaceCapabilities2EXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDisplayPowerInfoEXT(extensions: *const Extensions, item: *const vk.VkDisplayPowerInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkDisplayPowerStateEXT(extensions, &item.powerState))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDisplayPowerInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDeviceEventInfoEXT(extensions: *const Extensions, item: *const vk.VkDeviceEventInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkDeviceEventTypeEXT(extensions, &item.deviceEvent))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDeviceEventInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDisplayEventInfoEXT(extensions: *const Extensions, item: *const vk.VkDisplayEventInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkDisplayEventTypeEXT(extensions, &item.displayEvent))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDisplayEventInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSwapchainCounterCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkSwapchainCounterCreateInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkSurfaceCounterFlagsEXT(extensions, &item.surfaceCounters))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR,
            => if (!validate_VkSwapchainCreateInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSwapchainCounterCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceGroupProperties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceGroupProperties, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceGroupProperties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkMemoryAllocateFlagsInfo(extensions: *const Extensions, item: *const vk.VkMemoryAllocateFlagsInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkMemoryAllocateFlags(extensions, &item.flags))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO,
            => if (!validate_VkMemoryAllocateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMemoryAllocateFlagsInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkBindBufferMemoryInfo(extensions: *const Extensions, item: *const vk.VkBindBufferMemoryInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkBindBufferMemoryInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkBindBufferMemoryDeviceGroupInfo(extensions: *const Extensions, item: *const vk.VkBindBufferMemoryDeviceGroupInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO,
            => if (!validate_VkBindBufferMemoryInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkBindBufferMemoryDeviceGroupInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkBindImageMemoryInfo(extensions: *const Extensions, item: *const vk.VkBindImageMemoryInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkBindImageMemoryInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkBindImageMemoryDeviceGroupInfo(extensions: *const Extensions, item: *const vk.VkBindImageMemoryDeviceGroupInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (item.pSplitInstanceBindRegions) |v| {
        for (v[0..item.splitInstanceBindRegionCount]) |*vv| {
            if (!validate_VkRect2D(extensions, vv, false))
                return false;
        }
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO,
            => if (!validate_VkBindImageMemoryInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkBindImageMemoryDeviceGroupInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDeviceGroupRenderPassBeginInfo(extensions: *const Extensions, item: *const vk.VkDeviceGroupRenderPassBeginInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (item.pDeviceRenderAreas) |v| {
        for (v[0..item.deviceRenderAreaCount]) |*vv| {
            if (!validate_VkRect2D(extensions, vv, false))
                return false;
        }
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO,
            => if (!validate_VkRenderPassBeginInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_RENDERING_INFO,
            => if (!validate_VkRenderingInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDeviceGroupRenderPassBeginInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDeviceGroupCommandBufferBeginInfo(extensions: *const Extensions, item: *const vk.VkDeviceGroupCommandBufferBeginInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO,
            => if (!validate_VkCommandBufferBeginInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDeviceGroupCommandBufferBeginInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDeviceGroupSubmitInfo(extensions: *const Extensions, item: *const vk.VkDeviceGroupSubmitInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_SUBMIT_INFO,
            => if (!validate_VkSubmitInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDeviceGroupSubmitInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDeviceGroupBindSparseInfo(extensions: *const Extensions, item: *const vk.VkDeviceGroupBindSparseInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_BIND_SPARSE_INFO,
            => if (!validate_VkBindSparseInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDeviceGroupBindSparseInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDeviceGroupPresentCapabilitiesKHR(extensions: *const Extensions, item: *const vk.VkDeviceGroupPresentCapabilitiesKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkDeviceGroupPresentModeFlagsKHR(extensions, &item.modes))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDeviceGroupPresentCapabilitiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImageSwapchainCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkImageSwapchainCreateInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO,
            => if (!validate_VkImageCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImageSwapchainCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkBindImageMemorySwapchainInfoKHR(extensions: *const Extensions, item: *const vk.VkBindImageMemorySwapchainInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO,
            => if (!validate_VkBindImageMemoryInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkBindImageMemorySwapchainInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkAcquireNextImageInfoKHR(extensions: *const Extensions, item: *const vk.VkAcquireNextImageInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkAcquireNextImageInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDeviceGroupPresentInfoKHR(extensions: *const Extensions, item: *const vk.VkDeviceGroupPresentInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkDeviceGroupPresentModeFlagsKHR(extensions, &item.mode))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PRESENT_INFO_KHR,
            => if (!validate_VkPresentInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDeviceGroupPresentInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDeviceGroupDeviceCreateInfo(extensions: *const Extensions, item: *const vk.VkDeviceGroupDeviceCreateInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDeviceGroupDeviceCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDeviceGroupSwapchainCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkDeviceGroupSwapchainCreateInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkDeviceGroupPresentModeFlagsKHR(extensions, &item.modes))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR,
            => if (!validate_VkSwapchainCreateInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDeviceGroupSwapchainCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDescriptorUpdateTemplateEntry(extensions: *const Extensions, item: *const vk.VkDescriptorUpdateTemplateEntry, validate_pnext: bool) bool {
    if (!validate_VkDescriptorType(extensions, &item.descriptorType))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkDescriptorUpdateTemplateCreateInfo(extensions: *const Extensions, item: *const vk.VkDescriptorUpdateTemplateCreateInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkDescriptorUpdateTemplateCreateFlags(extensions, &item.flags))
        return false;
    if (item.pDescriptorUpdateEntries) |v| {
        for (v[0..item.descriptorUpdateEntryCount]) |*vv| {
            if (!validate_VkDescriptorUpdateTemplateEntry(extensions, vv, false))
                return false;
        }
    }
    if (!validate_VkDescriptorUpdateTemplateType(extensions, &item.templateType))
        return false;
    if (!validate_VkPipelineBindPoint(extensions, &item.pipelineBindPoint))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDescriptorUpdateTemplateCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkXYColorEXT(extensions: *const Extensions, item: *const vk.VkXYColorEXT, validate_pnext: bool) bool {
    _ = item;
    _ = extensions;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDevicePresentIdFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePresentIdFeaturesKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDevicePresentIdFeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPresentIdKHR(extensions: *const Extensions, item: *const vk.VkPresentIdKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PRESENT_INFO_KHR,
            => if (!validate_VkPresentInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPresentIdKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDevicePresentId2FeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePresentId2FeaturesKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDevicePresentId2FeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPresentId2KHR(extensions: *const Extensions, item: *const vk.VkPresentId2KHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PRESENT_INFO_KHR,
            => if (!validate_VkPresentInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPresentId2KHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPresentWait2InfoKHR(extensions: *const Extensions, item: *const vk.VkPresentWait2InfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPresentWait2InfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDevicePresentWaitFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePresentWaitFeaturesKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDevicePresentWaitFeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDevicePresentWait2FeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePresentWait2FeaturesKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDevicePresentWait2FeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDevicePresentTimingFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePresentTimingFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDevicePresentTimingFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPresentTimingSurfaceCapabilitiesEXT(extensions: *const Extensions, item: *const vk.VkPresentTimingSurfaceCapabilitiesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkPresentStageFlagsEXT(extensions, &item.presentStageQueries))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR,
            => if (!validate_VkSurfaceCapabilities2KHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPresentTimingSurfaceCapabilitiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSwapchainTimingPropertiesEXT(extensions: *const Extensions, item: *const vk.VkSwapchainTimingPropertiesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSwapchainTimingPropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSwapchainTimeDomainPropertiesEXT(extensions: *const Extensions, item: *const vk.VkSwapchainTimeDomainPropertiesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (item.pTimeDomains) |v| {
        for (v[0..item.timeDomainCount]) |*vv| {
            if (!validate_VkTimeDomainKHR(extensions, vv))
                return false;
        }
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSwapchainTimeDomainPropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPresentStageTimeEXT(extensions: *const Extensions, item: *const vk.VkPresentStageTimeEXT, validate_pnext: bool) bool {
    if (!validate_VkPresentStageFlagsEXT(extensions, &item.stage))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPastPresentationTimingInfoEXT(extensions: *const Extensions, item: *const vk.VkPastPresentationTimingInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkPastPresentationTimingFlagsEXT(extensions, &item.flags))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPastPresentationTimingInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPastPresentationTimingPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPastPresentationTimingPropertiesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (item.pPresentationTimings) |v| {
        for (v[0..item.presentationTimingCount]) |*vv| {
            if (!validate_VkPastPresentationTimingEXT(extensions, vv, false))
                return false;
        }
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPastPresentationTimingPropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPastPresentationTimingEXT(extensions: *const Extensions, item: *const vk.VkPastPresentationTimingEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (item.pPresentStages) |v| {
        for (v[0..item.presentStageCount]) |*vv| {
            if (!validate_VkPresentStageTimeEXT(extensions, vv, false))
                return false;
        }
    }
    if (!validate_VkTimeDomainKHR(extensions, &item.timeDomain))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPastPresentationTimingEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPresentTimingsInfoEXT(extensions: *const Extensions, item: *const vk.VkPresentTimingsInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (item.pTimingInfos) |v| {
        for (v[0..item.swapchainCount]) |*vv| {
            if (!validate_VkPresentTimingInfoEXT(extensions, vv, false))
                return false;
        }
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PRESENT_INFO_KHR,
            => if (!validate_VkPresentInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPresentTimingsInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPresentTimingInfoEXT(extensions: *const Extensions, item: *const vk.VkPresentTimingInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkPresentTimingInfoFlagsEXT(extensions, &item.flags))
        return false;
    if (!validate_VkPresentStageFlagsEXT(extensions, &item.presentStageQueries))
        return false;
    if (!validate_VkPresentStageFlagsEXT(extensions, &item.targetTimeDomainPresentStage))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPresentTimingInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSwapchainCalibratedTimestampInfoEXT(extensions: *const Extensions, item: *const vk.VkSwapchainCalibratedTimestampInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkPresentStageFlagsEXT(extensions, &item.presentStage))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_KHR,
            => if (!validate_VkCalibratedTimestampInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSwapchainCalibratedTimestampInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkHdrMetadataEXT(extensions: *const Extensions, item: *const vk.VkHdrMetadataEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkXYColorEXT(extensions, &item.displayPrimaryRed, false))
        return false;
    if (!validate_VkXYColorEXT(extensions, &item.displayPrimaryGreen, false))
        return false;
    if (!validate_VkXYColorEXT(extensions, &item.displayPrimaryBlue, false))
        return false;
    if (!validate_VkXYColorEXT(extensions, &item.whitePoint, false))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkHdrMetadataEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkHdrVividDynamicMetadataHUAWEI(extensions: *const Extensions, item: *const vk.VkHdrVividDynamicMetadataHUAWEI, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_HDR_METADATA_EXT,
            => if (!validate_VkHdrMetadataEXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkHdrVividDynamicMetadataHUAWEI: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDisplayNativeHdrSurfaceCapabilitiesAMD(extensions: *const Extensions, item: *const vk.VkDisplayNativeHdrSurfaceCapabilitiesAMD, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR,
            => if (!validate_VkSurfaceCapabilities2KHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDisplayNativeHdrSurfaceCapabilitiesAMD: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSwapchainDisplayNativeHdrCreateInfoAMD(extensions: *const Extensions, item: *const vk.VkSwapchainDisplayNativeHdrCreateInfoAMD, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR,
            => if (!validate_VkSwapchainCreateInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSwapchainDisplayNativeHdrCreateInfoAMD: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkRefreshCycleDurationGOOGLE(extensions: *const Extensions, item: *const vk.VkRefreshCycleDurationGOOGLE, validate_pnext: bool) bool {
    _ = item;
    _ = extensions;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPastPresentationTimingGOOGLE(extensions: *const Extensions, item: *const vk.VkPastPresentationTimingGOOGLE, validate_pnext: bool) bool {
    _ = item;
    _ = extensions;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPresentTimesInfoGOOGLE(extensions: *const Extensions, item: *const vk.VkPresentTimesInfoGOOGLE, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (item.pTimes) |v| {
        for (v[0..item.swapchainCount]) |*vv| {
            if (!validate_VkPresentTimeGOOGLE(extensions, vv, false))
                return false;
        }
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PRESENT_INFO_KHR,
            => if (!validate_VkPresentInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPresentTimesInfoGOOGLE: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPresentTimeGOOGLE(extensions: *const Extensions, item: *const vk.VkPresentTimeGOOGLE, validate_pnext: bool) bool {
    _ = item;
    _ = extensions;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkIOSSurfaceCreateInfoMVK(extensions: *const Extensions, item: *const vk.VkIOSSurfaceCreateInfoMVK, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkIOSSurfaceCreateFlagsMVK(extensions, &item.flags))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkIOSSurfaceCreateInfoMVK: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkMacOSSurfaceCreateInfoMVK(extensions: *const Extensions, item: *const vk.VkMacOSSurfaceCreateInfoMVK, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkMacOSSurfaceCreateFlagsMVK(extensions, &item.flags))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMacOSSurfaceCreateInfoMVK: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkMetalSurfaceCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkMetalSurfaceCreateInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkMetalSurfaceCreateFlagsEXT(extensions, &item.flags))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMetalSurfaceCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkViewportWScalingNV(extensions: *const Extensions, item: *const vk.VkViewportWScalingNV, validate_pnext: bool) bool {
    _ = item;
    _ = extensions;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPipelineViewportWScalingStateCreateInfoNV(extensions: *const Extensions, item: *const vk.VkPipelineViewportWScalingStateCreateInfoNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (item.pViewportWScalings) |v| {
        for (v[0..item.viewportCount]) |*vv| {
            if (!validate_VkViewportWScalingNV(extensions, vv, false))
                return false;
        }
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO,
            => if (!validate_VkPipelineViewportStateCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineViewportWScalingStateCreateInfoNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkViewportSwizzleNV(extensions: *const Extensions, item: *const vk.VkViewportSwizzleNV, validate_pnext: bool) bool {
    if (!validate_VkViewportCoordinateSwizzleNV(extensions, &item.x))
        return false;
    if (!validate_VkViewportCoordinateSwizzleNV(extensions, &item.y))
        return false;
    if (!validate_VkViewportCoordinateSwizzleNV(extensions, &item.z))
        return false;
    if (!validate_VkViewportCoordinateSwizzleNV(extensions, &item.w))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPipelineViewportSwizzleStateCreateInfoNV(extensions: *const Extensions, item: *const vk.VkPipelineViewportSwizzleStateCreateInfoNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkPipelineViewportSwizzleStateCreateFlagsNV(extensions, &item.flags))
        return false;
    if (item.pViewportSwizzles) |v| {
        for (v[0..item.viewportCount]) |*vv| {
            if (!validate_VkViewportSwizzleNV(extensions, vv, false))
                return false;
        }
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO,
            => if (!validate_VkPipelineViewportStateCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineViewportSwizzleStateCreateInfoNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceDiscardRectanglePropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDiscardRectanglePropertiesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceDiscardRectanglePropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPipelineDiscardRectangleStateCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkPipelineDiscardRectangleStateCreateInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkPipelineDiscardRectangleStateCreateFlagsEXT(extensions, &item.flags))
        return false;
    if (!validate_VkDiscardRectangleModeEXT(extensions, &item.discardRectangleMode))
        return false;
    if (item.pDiscardRectangles) |v| {
        for (v[0..item.discardRectangleCount]) |*vv| {
            if (!validate_VkRect2D(extensions, vv, false))
                return false;
        }
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO,
            => if (!validate_VkGraphicsPipelineCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineDiscardRectangleStateCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkInputAttachmentAspectReference(extensions: *const Extensions, item: *const vk.VkInputAttachmentAspectReference, validate_pnext: bool) bool {
    if (!validate_VkImageAspectFlags(extensions, &item.aspectMask))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkRenderPassInputAttachmentAspectCreateInfo(extensions: *const Extensions, item: *const vk.VkRenderPassInputAttachmentAspectCreateInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (item.pAspectReferences) |v| {
        for (v[0..item.aspectReferenceCount]) |*vv| {
            if (!validate_VkInputAttachmentAspectReference(extensions, vv, false))
                return false;
        }
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO,
            => if (!validate_VkRenderPassCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkRenderPassInputAttachmentAspectCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceSurfaceInfo2KHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceSurfaceInfo2KHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceSurfaceInfo2KHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSurfaceCapabilities2KHR(extensions: *const Extensions, item: *const vk.VkSurfaceCapabilities2KHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkSurfaceCapabilitiesKHR(extensions, &item.surfaceCapabilities, false))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSurfaceCapabilities2KHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSurfaceFormat2KHR(extensions: *const Extensions, item: *const vk.VkSurfaceFormat2KHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkSurfaceFormatKHR(extensions, &item.surfaceFormat, false))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSurfaceFormat2KHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDisplayProperties2KHR(extensions: *const Extensions, item: *const vk.VkDisplayProperties2KHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkDisplayPropertiesKHR(extensions, &item.displayProperties, false))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDisplayProperties2KHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDisplayPlaneProperties2KHR(extensions: *const Extensions, item: *const vk.VkDisplayPlaneProperties2KHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkDisplayPlanePropertiesKHR(extensions, &item.displayPlaneProperties, false))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDisplayPlaneProperties2KHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDisplayModeProperties2KHR(extensions: *const Extensions, item: *const vk.VkDisplayModeProperties2KHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkDisplayModePropertiesKHR(extensions, &item.displayModeProperties, false))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDisplayModeProperties2KHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDisplayModeStereoPropertiesNV(extensions: *const Extensions, item: *const vk.VkDisplayModeStereoPropertiesNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR,
            => if (!validate_VkDisplayModeProperties2KHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDisplayModeStereoPropertiesNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDisplayPlaneInfo2KHR(extensions: *const Extensions, item: *const vk.VkDisplayPlaneInfo2KHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDisplayPlaneInfo2KHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDisplayPlaneCapabilities2KHR(extensions: *const Extensions, item: *const vk.VkDisplayPlaneCapabilities2KHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkDisplayPlaneCapabilitiesKHR(extensions, &item.capabilities, false))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDisplayPlaneCapabilities2KHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSharedPresentSurfaceCapabilitiesKHR(extensions: *const Extensions, item: *const vk.VkSharedPresentSurfaceCapabilitiesKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkImageUsageFlags(extensions, &item.sharedPresentSupportedUsageFlags))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR,
            => if (!validate_VkSurfaceCapabilities2KHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSharedPresentSurfaceCapabilitiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDevice16BitStorageFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDevice16BitStorageFeatures, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDevice16BitStorageFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceSubgroupProperties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceSubgroupProperties, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkShaderStageFlags(extensions, &item.supportedStages))
        return false;
    if (!validate_VkSubgroupFeatureFlags(extensions, &item.supportedOperations))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceSubgroupProperties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkBufferMemoryRequirementsInfo2(extensions: *const Extensions, item: *const vk.VkBufferMemoryRequirementsInfo2, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkBufferMemoryRequirementsInfo2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDeviceBufferMemoryRequirements(extensions: *const Extensions, item: *const vk.VkDeviceBufferMemoryRequirements, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (item.pCreateInfo) |v| {
        if (!validate_VkBufferCreateInfo(extensions, v, false))
            return false;
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDeviceBufferMemoryRequirements: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImageMemoryRequirementsInfo2(extensions: *const Extensions, item: *const vk.VkImageMemoryRequirementsInfo2, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImageMemoryRequirementsInfo2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImageSparseMemoryRequirementsInfo2(extensions: *const Extensions, item: *const vk.VkImageSparseMemoryRequirementsInfo2, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImageSparseMemoryRequirementsInfo2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDeviceImageMemoryRequirements(extensions: *const Extensions, item: *const vk.VkDeviceImageMemoryRequirements, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (item.pCreateInfo) |v| {
        if (!validate_VkImageCreateInfo(extensions, v, false))
            return false;
    }
    if (!validate_VkImageAspectFlags(extensions, &item.planeAspect))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDeviceImageMemoryRequirements: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkMemoryRequirements2(extensions: *const Extensions, item: *const vk.VkMemoryRequirements2, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkMemoryRequirements(extensions, &item.memoryRequirements, false))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMemoryRequirements2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSparseImageMemoryRequirements2(extensions: *const Extensions, item: *const vk.VkSparseImageMemoryRequirements2, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkSparseImageMemoryRequirements(extensions, &item.memoryRequirements, false))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSparseImageMemoryRequirements2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDevicePointClippingProperties(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePointClippingProperties, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkPointClippingBehavior(extensions, &item.pointClippingBehavior))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDevicePointClippingProperties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkMemoryDedicatedRequirements(extensions: *const Extensions, item: *const vk.VkMemoryDedicatedRequirements, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2,
            => if (!validate_VkMemoryRequirements2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMemoryDedicatedRequirements: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkMemoryDedicatedAllocateInfo(extensions: *const Extensions, item: *const vk.VkMemoryDedicatedAllocateInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO,
            => if (!validate_VkMemoryAllocateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMemoryDedicatedAllocateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImageViewUsageCreateInfo(extensions: *const Extensions, item: *const vk.VkImageViewUsageCreateInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkImageUsageFlags(extensions, &item.usage))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO,
            => if (!validate_VkImageViewCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImageViewUsageCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImageViewSlicedCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkImageViewSlicedCreateInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO,
            => if (!validate_VkImageViewCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImageViewSlicedCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPipelineTessellationDomainOriginStateCreateInfo(extensions: *const Extensions, item: *const vk.VkPipelineTessellationDomainOriginStateCreateInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkTessellationDomainOrigin(extensions, &item.domainOrigin))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO,
            => if (!validate_VkPipelineTessellationStateCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineTessellationDomainOriginStateCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSamplerYcbcrConversionInfo(extensions: *const Extensions, item: *const vk.VkSamplerYcbcrConversionInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO,
            => if (!validate_VkSamplerCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO,
            => if (!validate_VkImageViewCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSamplerYcbcrConversionInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSamplerYcbcrConversionCreateInfo(extensions: *const Extensions, item: *const vk.VkSamplerYcbcrConversionCreateInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkFormat(extensions, &item.format))
        return false;
    if (!validate_VkSamplerYcbcrModelConversion(extensions, &item.ycbcrModel))
        return false;
    if (!validate_VkSamplerYcbcrRange(extensions, &item.ycbcrRange))
        return false;
    if (!validate_VkComponentMapping(extensions, &item.components, false))
        return false;
    if (!validate_VkChromaLocation(extensions, &item.xChromaOffset))
        return false;
    if (!validate_VkChromaLocation(extensions, &item.yChromaOffset))
        return false;
    if (!validate_VkFilter(extensions, &item.chromaFilter))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSamplerYcbcrConversionCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkBindImagePlaneMemoryInfo(extensions: *const Extensions, item: *const vk.VkBindImagePlaneMemoryInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkImageAspectFlags(extensions, &item.planeAspect))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO,
            => if (!validate_VkBindImageMemoryInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkBindImagePlaneMemoryInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImagePlaneMemoryRequirementsInfo(extensions: *const Extensions, item: *const vk.VkImagePlaneMemoryRequirementsInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkImageAspectFlags(extensions, &item.planeAspect))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2,
            => if (!validate_VkImageMemoryRequirementsInfo2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImagePlaneMemoryRequirementsInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceSamplerYcbcrConversionFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceSamplerYcbcrConversionFeatures, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceSamplerYcbcrConversionFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSamplerYcbcrConversionImageFormatProperties(extensions: *const Extensions, item: *const vk.VkSamplerYcbcrConversionImageFormatProperties, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2,
            => if (!validate_VkImageFormatProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSamplerYcbcrConversionImageFormatProperties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkTextureLODGatherFormatPropertiesAMD(extensions: *const Extensions, item: *const vk.VkTextureLODGatherFormatPropertiesAMD, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2,
            => if (!validate_VkImageFormatProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkTextureLODGatherFormatPropertiesAMD: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkConditionalRenderingBeginInfoEXT(extensions: *const Extensions, item: *const vk.VkConditionalRenderingBeginInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkConditionalRenderingFlagsEXT(extensions, &item.flags))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkConditionalRenderingBeginInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkProtectedSubmitInfo(extensions: *const Extensions, item: *const vk.VkProtectedSubmitInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_SUBMIT_INFO,
            => if (!validate_VkSubmitInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkProtectedSubmitInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceProtectedMemoryFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceProtectedMemoryFeatures, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceProtectedMemoryFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceProtectedMemoryProperties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceProtectedMemoryProperties, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceProtectedMemoryProperties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDeviceQueueInfo2(extensions: *const Extensions, item: *const vk.VkDeviceQueueInfo2, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkDeviceQueueCreateFlags(extensions, &item.flags))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDeviceQueueInfo2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPipelineCoverageToColorStateCreateInfoNV(extensions: *const Extensions, item: *const vk.VkPipelineCoverageToColorStateCreateInfoNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkPipelineCoverageToColorStateCreateFlagsNV(extensions, &item.flags))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO,
            => if (!validate_VkPipelineMultisampleStateCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineCoverageToColorStateCreateInfoNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceSamplerFilterMinmaxProperties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceSamplerFilterMinmaxProperties, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceSamplerFilterMinmaxProperties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSampleLocationEXT(extensions: *const Extensions, item: *const vk.VkSampleLocationEXT, validate_pnext: bool) bool {
    _ = item;
    _ = extensions;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkSampleLocationsInfoEXT(extensions: *const Extensions, item: *const vk.VkSampleLocationsInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkSampleCountFlags(extensions, &item.sampleLocationsPerPixel))
        return false;
    if (!validate_VkExtent2D(extensions, &item.sampleLocationGridSize, false))
        return false;
    if (item.pSampleLocations) |v| {
        for (v[0..item.sampleLocationsCount]) |*vv| {
            if (!validate_VkSampleLocationEXT(extensions, vv, false))
                return false;
        }
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER,
            => if (!validate_VkImageMemoryBarrier(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2,
            => if (!validate_VkImageMemoryBarrier2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSampleLocationsInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkAttachmentSampleLocationsEXT(extensions: *const Extensions, item: *const vk.VkAttachmentSampleLocationsEXT, validate_pnext: bool) bool {
    if (!validate_VkSampleLocationsInfoEXT(extensions, &item.sampleLocationsInfo, false))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkSubpassSampleLocationsEXT(extensions: *const Extensions, item: *const vk.VkSubpassSampleLocationsEXT, validate_pnext: bool) bool {
    if (!validate_VkSampleLocationsInfoEXT(extensions, &item.sampleLocationsInfo, false))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkRenderPassSampleLocationsBeginInfoEXT(extensions: *const Extensions, item: *const vk.VkRenderPassSampleLocationsBeginInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (item.pAttachmentInitialSampleLocations) |v| {
        for (v[0..item.attachmentInitialSampleLocationsCount]) |*vv| {
            if (!validate_VkAttachmentSampleLocationsEXT(extensions, vv, false))
                return false;
        }
    }
    if (item.pPostSubpassSampleLocations) |v| {
        for (v[0..item.postSubpassSampleLocationsCount]) |*vv| {
            if (!validate_VkSubpassSampleLocationsEXT(extensions, vv, false))
                return false;
        }
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO,
            => if (!validate_VkRenderPassBeginInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkRenderPassSampleLocationsBeginInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPipelineSampleLocationsStateCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkPipelineSampleLocationsStateCreateInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkSampleLocationsInfoEXT(extensions, &item.sampleLocationsInfo, false))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO,
            => if (!validate_VkPipelineMultisampleStateCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineSampleLocationsStateCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceSampleLocationsPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceSampleLocationsPropertiesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkSampleCountFlags(extensions, &item.sampleLocationSampleCounts))
        return false;
    if (!validate_VkExtent2D(extensions, &item.maxSampleLocationGridSize, false))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceSampleLocationsPropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkMultisamplePropertiesEXT(extensions: *const Extensions, item: *const vk.VkMultisamplePropertiesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkExtent2D(extensions, &item.maxSampleLocationGridSize, false))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMultisamplePropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSamplerReductionModeCreateInfo(extensions: *const Extensions, item: *const vk.VkSamplerReductionModeCreateInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkSamplerReductionMode(extensions, &item.reductionMode))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO,
            => if (!validate_VkSamplerCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSamplerReductionModeCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceMultiDrawFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMultiDrawFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceMultiDrawFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPipelineColorBlendAdvancedStateCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkPipelineColorBlendAdvancedStateCreateInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkBlendOverlapEXT(extensions, &item.blendOverlap))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO,
            => if (!validate_VkPipelineColorBlendStateCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineColorBlendAdvancedStateCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceInlineUniformBlockFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceInlineUniformBlockFeatures, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceInlineUniformBlockFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceInlineUniformBlockProperties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceInlineUniformBlockProperties, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceInlineUniformBlockProperties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkWriteDescriptorSetInlineUniformBlock(extensions: *const Extensions, item: *const vk.VkWriteDescriptorSetInlineUniformBlock, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET,
            => if (!validate_VkWriteDescriptorSet(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkWriteDescriptorSetInlineUniformBlock: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDescriptorPoolInlineUniformBlockCreateInfo(extensions: *const Extensions, item: *const vk.VkDescriptorPoolInlineUniformBlockCreateInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO,
            => if (!validate_VkDescriptorPoolCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDescriptorPoolInlineUniformBlockCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPipelineCoverageModulationStateCreateInfoNV(extensions: *const Extensions, item: *const vk.VkPipelineCoverageModulationStateCreateInfoNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkPipelineCoverageModulationStateCreateFlagsNV(extensions, &item.flags))
        return false;
    if (!validate_VkCoverageModulationModeNV(extensions, &item.coverageModulationMode))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO,
            => if (!validate_VkPipelineMultisampleStateCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineCoverageModulationStateCreateInfoNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImageFormatListCreateInfo(extensions: *const Extensions, item: *const vk.VkImageFormatListCreateInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (item.pViewFormats) |v| {
        for (v[0..item.viewFormatCount]) |*vv| {
            if (!validate_VkFormat(extensions, vv))
                return false;
        }
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO,
            => if (!validate_VkImageCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR,
            => if (!validate_VkSwapchainCreateInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2,
            => if (!validate_VkPhysicalDeviceImageFormatInfo2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImageFormatListCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkValidationCacheCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkValidationCacheCreateInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkValidationCacheCreateFlagsEXT(extensions, &item.flags))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkValidationCacheCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkShaderModuleValidationCacheCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkShaderModuleValidationCacheCreateInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO,
            => if (!validate_VkShaderModuleCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO,
            => if (!validate_VkPipelineShaderStageCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkShaderModuleValidationCacheCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceMaintenance3Properties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMaintenance3Properties, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceMaintenance3Properties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceMaintenance4Features(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMaintenance4Features, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceMaintenance4Features: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceMaintenance4Properties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMaintenance4Properties, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceMaintenance4Properties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceMaintenance5Features(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMaintenance5Features, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceMaintenance5Features: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceMaintenance5Properties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMaintenance5Properties, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceMaintenance5Properties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceMaintenance6Features(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMaintenance6Features, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceMaintenance6Features: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceMaintenance6Properties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMaintenance6Properties, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceMaintenance6Properties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceMaintenance7FeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMaintenance7FeaturesKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceMaintenance7FeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceMaintenance7PropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMaintenance7PropertiesKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceMaintenance7PropertiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceLayeredApiPropertiesListKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceLayeredApiPropertiesListKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (item.pLayeredApis) |v| {
        for (v[0..item.layeredApiCount]) |*vv| {
            if (!validate_VkPhysicalDeviceLayeredApiPropertiesKHR(extensions, vv, false))
                return false;
        }
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceLayeredApiPropertiesListKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceLayeredApiPropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceLayeredApiPropertiesKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkPhysicalDeviceLayeredApiKHR(extensions, &item.layeredAPI))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceLayeredApiPropertiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceLayeredApiVulkanPropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceLayeredApiVulkanPropertiesKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkPhysicalDeviceProperties2(extensions, &item.properties, false))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_PROPERTIES_KHR,
            => if (!validate_VkPhysicalDeviceLayeredApiPropertiesKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceLayeredApiVulkanPropertiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceMaintenance8FeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMaintenance8FeaturesKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceMaintenance8FeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceMaintenance9FeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMaintenance9FeaturesKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceMaintenance9FeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceMaintenance9PropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMaintenance9PropertiesKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkDefaultVertexAttributeValueKHR(extensions, &item.defaultVertexAttributeValue))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceMaintenance9PropertiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceMaintenance10PropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMaintenance10PropertiesKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceMaintenance10PropertiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceMaintenance10FeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMaintenance10FeaturesKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceMaintenance10FeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkQueueFamilyOwnershipTransferPropertiesKHR(extensions: *const Extensions, item: *const vk.VkQueueFamilyOwnershipTransferPropertiesKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2,
            => if (!validate_VkQueueFamilyProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkQueueFamilyOwnershipTransferPropertiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkRenderingAreaInfo(extensions: *const Extensions, item: *const vk.VkRenderingAreaInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (item.pColorAttachmentFormats) |v| {
        for (v[0..item.colorAttachmentCount]) |*vv| {
            if (!validate_VkFormat(extensions, vv))
                return false;
        }
    }
    if (!validate_VkFormat(extensions, &item.depthAttachmentFormat))
        return false;
    if (!validate_VkFormat(extensions, &item.stencilAttachmentFormat))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkRenderingAreaInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDescriptorSetLayoutSupport(extensions: *const Extensions, item: *const vk.VkDescriptorSetLayoutSupport, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDescriptorSetLayoutSupport: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceShaderDrawParametersFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderDrawParametersFeatures, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShaderDrawParametersFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceShaderFloat16Int8Features(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderFloat16Int8Features, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShaderFloat16Int8Features: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceFloatControlsProperties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceFloatControlsProperties, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkShaderFloatControlsIndependence(extensions, &item.denormBehaviorIndependence))
        return false;
    if (!validate_VkShaderFloatControlsIndependence(extensions, &item.roundingModeIndependence))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceFloatControlsProperties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceHostQueryResetFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceHostQueryResetFeatures, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceHostQueryResetFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkShaderResourceUsageAMD(extensions: *const Extensions, item: *const vk.VkShaderResourceUsageAMD, validate_pnext: bool) bool {
    _ = item;
    _ = extensions;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkShaderStatisticsInfoAMD(extensions: *const Extensions, item: *const vk.VkShaderStatisticsInfoAMD, validate_pnext: bool) bool {
    if (!validate_VkShaderStageFlags(extensions, &item.shaderStageMask))
        return false;
    if (!validate_VkShaderResourceUsageAMD(extensions, &item.resourceUsage, false))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkDeviceQueueGlobalPriorityCreateInfo(extensions: *const Extensions, item: *const vk.VkDeviceQueueGlobalPriorityCreateInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkQueueGlobalPriority(extensions, &item.globalPriority))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO,
            => if (!validate_VkDeviceQueueCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDeviceQueueGlobalPriorityCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceGlobalPriorityQueryFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceGlobalPriorityQueryFeatures, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceGlobalPriorityQueryFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkQueueFamilyGlobalPriorityProperties(extensions: *const Extensions, item: *const vk.VkQueueFamilyGlobalPriorityProperties, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
        for (item.priorities) |v| {
            if (!validate_VkQueueGlobalPriority(extensions, v))
                return false;
        }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2,
            => if (!validate_VkQueueFamilyProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkQueueFamilyGlobalPriorityProperties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDebugUtilsObjectNameInfoEXT(extensions: *const Extensions, item: *const vk.VkDebugUtilsObjectNameInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkObjectType(extensions, &item.objectType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO,
            => if (!validate_VkPipelineShaderStageCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDebugUtilsObjectNameInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDebugUtilsObjectTagInfoEXT(extensions: *const Extensions, item: *const vk.VkDebugUtilsObjectTagInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkObjectType(extensions, &item.objectType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDebugUtilsObjectTagInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDebugUtilsLabelEXT(extensions: *const Extensions, item: *const vk.VkDebugUtilsLabelEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDebugUtilsLabelEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDebugUtilsMessengerCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkDebugUtilsMessengerCreateInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkDebugUtilsMessengerCreateFlagsEXT(extensions, &item.flags))
        return false;
    if (!validate_VkDebugUtilsMessageSeverityFlagsEXT(extensions, &item.messageSeverity))
        return false;
    if (!validate_VkDebugUtilsMessageTypeFlagsEXT(extensions, &item.messageType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO,
            => if (!validate_VkInstanceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDebugUtilsMessengerCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDebugUtilsMessengerCallbackDataEXT(extensions: *const Extensions, item: *const vk.VkDebugUtilsMessengerCallbackDataEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkDebugUtilsMessengerCallbackDataFlagsEXT(extensions, &item.flags))
        return false;
    if (item.pQueueLabels) |v| {
        for (v[0..item.queueLabelCount]) |*vv| {
            if (!validate_VkDebugUtilsLabelEXT(extensions, vv, false))
                return false;
        }
    }
    if (item.pCmdBufLabels) |v| {
        for (v[0..item.cmdBufLabelCount]) |*vv| {
            if (!validate_VkDebugUtilsLabelEXT(extensions, vv, false))
                return false;
        }
    }
    if (item.pObjects) |v| {
        for (v[0..item.objectCount]) |*vv| {
            if (!validate_VkDebugUtilsObjectNameInfoEXT(extensions, vv, false))
                return false;
        }
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDebugUtilsMessengerCallbackDataEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceDeviceMemoryReportFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDeviceMemoryReportFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceDeviceMemoryReportFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDeviceDeviceMemoryReportCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkDeviceDeviceMemoryReportCreateInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkDeviceMemoryReportFlagsEXT(extensions, &item.flags))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDeviceDeviceMemoryReportCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDeviceMemoryReportCallbackDataEXT(extensions: *const Extensions, item: *const vk.VkDeviceMemoryReportCallbackDataEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkDeviceMemoryReportFlagsEXT(extensions, &item.flags))
        return false;
    if (!validate_VkDeviceMemoryReportEventTypeEXT(extensions, &item.type))
        return false;
    if (!validate_VkObjectType(extensions, &item.objectType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDeviceMemoryReportCallbackDataEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImportMemoryHostPointerInfoEXT(extensions: *const Extensions, item: *const vk.VkImportMemoryHostPointerInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkExternalMemoryHandleTypeFlags(extensions, &item.handleType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO,
            => if (!validate_VkMemoryAllocateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImportMemoryHostPointerInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkMemoryHostPointerPropertiesEXT(extensions: *const Extensions, item: *const vk.VkMemoryHostPointerPropertiesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMemoryHostPointerPropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceExternalMemoryHostPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceExternalMemoryHostPropertiesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceExternalMemoryHostPropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceConservativeRasterizationPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceConservativeRasterizationPropertiesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceConservativeRasterizationPropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkCalibratedTimestampInfoKHR(extensions: *const Extensions, item: *const vk.VkCalibratedTimestampInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkTimeDomainKHR(extensions, &item.timeDomain))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkCalibratedTimestampInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceShaderCorePropertiesAMD(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderCorePropertiesAMD, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShaderCorePropertiesAMD: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceShaderCoreProperties2AMD(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderCoreProperties2AMD, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkShaderCorePropertiesFlagsAMD(extensions, &item.shaderCoreFeatures))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShaderCoreProperties2AMD: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPipelineRasterizationConservativeStateCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkPipelineRasterizationConservativeStateCreateInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkPipelineRasterizationConservativeStateCreateFlagsEXT(extensions, &item.flags))
        return false;
    if (!validate_VkConservativeRasterizationModeEXT(extensions, &item.conservativeRasterizationMode))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO,
            => if (!validate_VkPipelineRasterizationStateCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineRasterizationConservativeStateCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceDescriptorIndexingFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDescriptorIndexingFeatures, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceDescriptorIndexingFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceDescriptorIndexingProperties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDescriptorIndexingProperties, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceDescriptorIndexingProperties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDescriptorSetLayoutBindingFlagsCreateInfo(extensions: *const Extensions, item: *const vk.VkDescriptorSetLayoutBindingFlagsCreateInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (item.pBindingFlags) |v| {
        for (v[0..item.bindingCount]) |*vv| {
            if (!validate_VkDescriptorBindingFlags(extensions, vv))
                return false;
        }
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO,
            => if (!validate_VkDescriptorSetLayoutCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDescriptorSetLayoutBindingFlagsCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDescriptorSetVariableDescriptorCountAllocateInfo(extensions: *const Extensions, item: *const vk.VkDescriptorSetVariableDescriptorCountAllocateInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO,
            => if (!validate_VkDescriptorSetAllocateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDescriptorSetVariableDescriptorCountAllocateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDescriptorSetVariableDescriptorCountLayoutSupport(extensions: *const Extensions, item: *const vk.VkDescriptorSetVariableDescriptorCountLayoutSupport, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT,
            => if (!validate_VkDescriptorSetLayoutSupport(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDescriptorSetVariableDescriptorCountLayoutSupport: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkAttachmentDescription2(extensions: *const Extensions, item: *const vk.VkAttachmentDescription2, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkAttachmentDescriptionFlags(extensions, &item.flags))
        return false;
    if (!validate_VkFormat(extensions, &item.format))
        return false;
    if (!validate_VkSampleCountFlags(extensions, &item.samples))
        return false;
    if (!validate_VkAttachmentLoadOp(extensions, &item.loadOp))
        return false;
    if (!validate_VkAttachmentStoreOp(extensions, &item.storeOp))
        return false;
    if (!validate_VkAttachmentLoadOp(extensions, &item.stencilLoadOp))
        return false;
    if (!validate_VkAttachmentStoreOp(extensions, &item.stencilStoreOp))
        return false;
    if (!validate_VkImageLayout(extensions, &item.initialLayout))
        return false;
    if (!validate_VkImageLayout(extensions, &item.finalLayout))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkAttachmentDescription2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkAttachmentReference2(extensions: *const Extensions, item: *const vk.VkAttachmentReference2, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkImageLayout(extensions, &item.layout))
        return false;
    if (!validate_VkImageAspectFlags(extensions, &item.aspectMask))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkAttachmentReference2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSubpassDescription2(extensions: *const Extensions, item: *const vk.VkSubpassDescription2, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkSubpassDescriptionFlags(extensions, &item.flags))
        return false;
    if (!validate_VkPipelineBindPoint(extensions, &item.pipelineBindPoint))
        return false;
    if (item.pInputAttachments) |v| {
        for (v[0..item.inputAttachmentCount]) |*vv| {
            if (!validate_VkAttachmentReference2(extensions, vv, false))
                return false;
        }
    }
    if (item.pColorAttachments) |v| {
        for (v[0..item.colorAttachmentCount]) |*vv| {
            if (!validate_VkAttachmentReference2(extensions, vv, false))
                return false;
        }
    }
    if (item.pResolveAttachments) |v| {
        for (v[0..item.colorAttachmentCount]) |*vv| {
            if (!validate_VkAttachmentReference2(extensions, vv, false))
                return false;
        }
    }
    if (item.pDepthStencilAttachment) |v| {
        if (!validate_VkAttachmentReference2(extensions, v, false))
            return false;
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSubpassDescription2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSubpassDependency2(extensions: *const Extensions, item: *const vk.VkSubpassDependency2, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkPipelineStageFlags(extensions, &item.srcStageMask))
        return false;
    if (!validate_VkPipelineStageFlags(extensions, &item.dstStageMask))
        return false;
    if (!validate_VkAccessFlags(extensions, &item.srcAccessMask))
        return false;
    if (!validate_VkAccessFlags(extensions, &item.dstAccessMask))
        return false;
    if (!validate_VkDependencyFlags(extensions, &item.dependencyFlags))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSubpassDependency2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkRenderPassCreateInfo2(extensions: *const Extensions, item: *const vk.VkRenderPassCreateInfo2, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkRenderPassCreateFlags(extensions, &item.flags))
        return false;
    if (item.pAttachments) |v| {
        for (v[0..item.attachmentCount]) |*vv| {
            if (!validate_VkAttachmentDescription2(extensions, vv, false))
                return false;
        }
    }
    if (item.pSubpasses) |v| {
        for (v[0..item.subpassCount]) |*vv| {
            if (!validate_VkSubpassDescription2(extensions, vv, false))
                return false;
        }
    }
    if (item.pDependencies) |v| {
        for (v[0..item.dependencyCount]) |*vv| {
            if (!validate_VkSubpassDependency2(extensions, vv, false))
                return false;
        }
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkRenderPassCreateInfo2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSubpassBeginInfo(extensions: *const Extensions, item: *const vk.VkSubpassBeginInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkSubpassContents(extensions, &item.contents))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSubpassBeginInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSubpassEndInfo(extensions: *const Extensions, item: *const vk.VkSubpassEndInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSubpassEndInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceTimelineSemaphoreFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceTimelineSemaphoreFeatures, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceTimelineSemaphoreFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceTimelineSemaphoreProperties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceTimelineSemaphoreProperties, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceTimelineSemaphoreProperties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSemaphoreTypeCreateInfo(extensions: *const Extensions, item: *const vk.VkSemaphoreTypeCreateInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkSemaphoreType(extensions, &item.semaphoreType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO,
            => if (!validate_VkSemaphoreCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO,
            => if (!validate_VkPhysicalDeviceExternalSemaphoreInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSemaphoreTypeCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkTimelineSemaphoreSubmitInfo(extensions: *const Extensions, item: *const vk.VkTimelineSemaphoreSubmitInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_SUBMIT_INFO,
            => if (!validate_VkSubmitInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_BIND_SPARSE_INFO,
            => if (!validate_VkBindSparseInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkTimelineSemaphoreSubmitInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSemaphoreWaitInfo(extensions: *const Extensions, item: *const vk.VkSemaphoreWaitInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkSemaphoreWaitFlags(extensions, &item.flags))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSemaphoreWaitInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSemaphoreSignalInfo(extensions: *const Extensions, item: *const vk.VkSemaphoreSignalInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSemaphoreSignalInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVertexInputBindingDivisorDescription(extensions: *const Extensions, item: *const vk.VkVertexInputBindingDivisorDescription, validate_pnext: bool) bool {
    _ = item;
    _ = extensions;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPipelineVertexInputDivisorStateCreateInfo(extensions: *const Extensions, item: *const vk.VkPipelineVertexInputDivisorStateCreateInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (item.pVertexBindingDivisors) |v| {
        for (v[0..item.vertexBindingDivisorCount]) |*vv| {
            if (!validate_VkVertexInputBindingDivisorDescription(extensions, vv, false))
                return false;
        }
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO,
            => if (!validate_VkPipelineVertexInputStateCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineVertexInputDivisorStateCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceVertexAttributeDivisorProperties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVertexAttributeDivisorProperties, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceVertexAttributeDivisorProperties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDevicePCIBusInfoPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePCIBusInfoPropertiesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDevicePCIBusInfoPropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImportAndroidHardwareBufferInfoANDROID(extensions: *const Extensions, item: *const vk.VkImportAndroidHardwareBufferInfoANDROID, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO,
            => if (!validate_VkMemoryAllocateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImportAndroidHardwareBufferInfoANDROID: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkAndroidHardwareBufferUsageANDROID(extensions: *const Extensions, item: *const vk.VkAndroidHardwareBufferUsageANDROID, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2,
            => if (!validate_VkImageFormatProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkAndroidHardwareBufferUsageANDROID: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkAndroidHardwareBufferPropertiesANDROID(extensions: *const Extensions, item: *const vk.VkAndroidHardwareBufferPropertiesANDROID, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkAndroidHardwareBufferPropertiesANDROID: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkMemoryGetAndroidHardwareBufferInfoANDROID(extensions: *const Extensions, item: *const vk.VkMemoryGetAndroidHardwareBufferInfoANDROID, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMemoryGetAndroidHardwareBufferInfoANDROID: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkAndroidHardwareBufferFormatPropertiesANDROID(extensions: *const Extensions, item: *const vk.VkAndroidHardwareBufferFormatPropertiesANDROID, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkFormat(extensions, &item.format))
        return false;
    if (!validate_VkFormatFeatureFlags(extensions, &item.formatFeatures))
        return false;
    if (!validate_VkComponentMapping(extensions, &item.samplerYcbcrConversionComponents, false))
        return false;
    if (!validate_VkSamplerYcbcrModelConversion(extensions, &item.suggestedYcbcrModel))
        return false;
    if (!validate_VkSamplerYcbcrRange(extensions, &item.suggestedYcbcrRange))
        return false;
    if (!validate_VkChromaLocation(extensions, &item.suggestedXChromaOffset))
        return false;
    if (!validate_VkChromaLocation(extensions, &item.suggestedYChromaOffset))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID,
            => if (!validate_VkAndroidHardwareBufferPropertiesANDROID(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkAndroidHardwareBufferFormatPropertiesANDROID: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkCommandBufferInheritanceConditionalRenderingInfoEXT(extensions: *const Extensions, item: *const vk.VkCommandBufferInheritanceConditionalRenderingInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO,
            => if (!validate_VkCommandBufferInheritanceInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkCommandBufferInheritanceConditionalRenderingInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkExternalFormatANDROID(extensions: *const Extensions, item: *const vk.VkExternalFormatANDROID, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO,
            => if (!validate_VkImageCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO,
            => if (!validate_VkSamplerYcbcrConversionCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2,
            => if (!validate_VkAttachmentDescription2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO,
            => if (!validate_VkGraphicsPipelineCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO,
            => if (!validate_VkCommandBufferInheritanceInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkExternalFormatANDROID: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDevice8BitStorageFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDevice8BitStorageFeatures, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDevice8BitStorageFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceConditionalRenderingFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceConditionalRenderingFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceConditionalRenderingFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceVulkanMemoryModelFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVulkanMemoryModelFeatures, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceVulkanMemoryModelFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceShaderAtomicInt64Features(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderAtomicInt64Features, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShaderAtomicInt64Features: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceShaderAtomicFloatFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderAtomicFloatFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShaderAtomicFloatFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceVertexAttributeDivisorFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVertexAttributeDivisorFeatures, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceVertexAttributeDivisorFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkQueueFamilyCheckpointPropertiesNV(extensions: *const Extensions, item: *const vk.VkQueueFamilyCheckpointPropertiesNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkPipelineStageFlags(extensions, &item.checkpointExecutionStageMask))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2,
            => if (!validate_VkQueueFamilyProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkQueueFamilyCheckpointPropertiesNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkCheckpointDataNV(extensions: *const Extensions, item: *const vk.VkCheckpointDataNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkPipelineStageFlags(extensions, &item.stage))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkCheckpointDataNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceDepthStencilResolveProperties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDepthStencilResolveProperties, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkResolveModeFlags(extensions, &item.supportedDepthResolveModes))
        return false;
    if (!validate_VkResolveModeFlags(extensions, &item.supportedStencilResolveModes))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceDepthStencilResolveProperties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSubpassDescriptionDepthStencilResolve(extensions: *const Extensions, item: *const vk.VkSubpassDescriptionDepthStencilResolve, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkResolveModeFlags(extensions, &item.depthResolveMode))
        return false;
    if (!validate_VkResolveModeFlags(extensions, &item.stencilResolveMode))
        return false;
    if (item.pDepthStencilResolveAttachment) |v| {
        if (!validate_VkAttachmentReference2(extensions, v, false))
            return false;
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2,
            => if (!validate_VkSubpassDescription2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSubpassDescriptionDepthStencilResolve: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImageViewASTCDecodeModeEXT(extensions: *const Extensions, item: *const vk.VkImageViewASTCDecodeModeEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkFormat(extensions, &item.decodeMode))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO,
            => if (!validate_VkImageViewCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImageViewASTCDecodeModeEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceASTCDecodeFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceASTCDecodeFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceASTCDecodeFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceTransformFeedbackFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceTransformFeedbackFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceTransformFeedbackFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceTransformFeedbackPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceTransformFeedbackPropertiesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceTransformFeedbackPropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPipelineRasterizationStateStreamCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkPipelineRasterizationStateStreamCreateInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkPipelineRasterizationStateStreamCreateFlagsEXT(extensions, &item.flags))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO,
            => if (!validate_VkPipelineRasterizationStateCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineRasterizationStateStreamCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPipelineRepresentativeFragmentTestStateCreateInfoNV(extensions: *const Extensions, item: *const vk.VkPipelineRepresentativeFragmentTestStateCreateInfoNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO,
            => if (!validate_VkGraphicsPipelineCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineRepresentativeFragmentTestStateCreateInfoNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceExclusiveScissorFeaturesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceExclusiveScissorFeaturesNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceExclusiveScissorFeaturesNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPipelineViewportExclusiveScissorStateCreateInfoNV(extensions: *const Extensions, item: *const vk.VkPipelineViewportExclusiveScissorStateCreateInfoNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (item.pExclusiveScissors) |v| {
        for (v[0..item.exclusiveScissorCount]) |*vv| {
            if (!validate_VkRect2D(extensions, vv, false))
                return false;
        }
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO,
            => if (!validate_VkPipelineViewportStateCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineViewportExclusiveScissorStateCreateInfoNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceCornerSampledImageFeaturesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceCornerSampledImageFeaturesNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceCornerSampledImageFeaturesNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceComputeShaderDerivativesPropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceComputeShaderDerivativesPropertiesKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceComputeShaderDerivativesPropertiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceShaderImageFootprintFeaturesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderImageFootprintFeaturesNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShaderImageFootprintFeaturesNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceCopyMemoryIndirectFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceCopyMemoryIndirectFeaturesKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceCopyMemoryIndirectFeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceCopyMemoryIndirectFeaturesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceCopyMemoryIndirectFeaturesNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceCopyMemoryIndirectFeaturesNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceCopyMemoryIndirectPropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceCopyMemoryIndirectPropertiesKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkQueueFlags(extensions, &item.supportedQueues))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceCopyMemoryIndirectPropertiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceMemoryDecompressionFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMemoryDecompressionFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceMemoryDecompressionFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceMemoryDecompressionPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMemoryDecompressionPropertiesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkMemoryDecompressionMethodFlagsEXT(extensions, &item.decompressionMethods))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceMemoryDecompressionPropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkShadingRatePaletteNV(extensions: *const Extensions, item: *const vk.VkShadingRatePaletteNV, validate_pnext: bool) bool {
    if (item.pShadingRatePaletteEntries) |v| {
        for (v[0..item.shadingRatePaletteEntryCount]) |*vv| {
            if (!validate_VkShadingRatePaletteEntryNV(extensions, vv))
                return false;
        }
    }
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPipelineViewportShadingRateImageStateCreateInfoNV(extensions: *const Extensions, item: *const vk.VkPipelineViewportShadingRateImageStateCreateInfoNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (item.pShadingRatePalettes) |v| {
        for (v[0..item.viewportCount]) |*vv| {
            if (!validate_VkShadingRatePaletteNV(extensions, vv, false))
                return false;
        }
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO,
            => if (!validate_VkPipelineViewportStateCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineViewportShadingRateImageStateCreateInfoNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceShadingRateImageFeaturesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShadingRateImageFeaturesNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShadingRateImageFeaturesNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceShadingRateImagePropertiesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShadingRateImagePropertiesNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkExtent2D(extensions, &item.shadingRateTexelSize, false))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShadingRateImagePropertiesNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceInvocationMaskFeaturesHUAWEI(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceInvocationMaskFeaturesHUAWEI, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceInvocationMaskFeaturesHUAWEI: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkCoarseSampleLocationNV(extensions: *const Extensions, item: *const vk.VkCoarseSampleLocationNV, validate_pnext: bool) bool {
    _ = item;
    _ = extensions;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkCoarseSampleOrderCustomNV(extensions: *const Extensions, item: *const vk.VkCoarseSampleOrderCustomNV, validate_pnext: bool) bool {
    if (!validate_VkShadingRatePaletteEntryNV(extensions, &item.shadingRate))
        return false;
    if (item.pSampleLocations) |v| {
        for (v[0..item.sampleLocationCount]) |*vv| {
            if (!validate_VkCoarseSampleLocationNV(extensions, vv, false))
                return false;
        }
    }
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPipelineViewportCoarseSampleOrderStateCreateInfoNV(extensions: *const Extensions, item: *const vk.VkPipelineViewportCoarseSampleOrderStateCreateInfoNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkCoarseSampleOrderTypeNV(extensions, &item.sampleOrderType))
        return false;
    if (item.pCustomSampleOrders) |v| {
        for (v[0..item.customSampleOrderCount]) |*vv| {
            if (!validate_VkCoarseSampleOrderCustomNV(extensions, vv, false))
                return false;
        }
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO,
            => if (!validate_VkPipelineViewportStateCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineViewportCoarseSampleOrderStateCreateInfoNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceMeshShaderFeaturesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMeshShaderFeaturesNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceMeshShaderFeaturesNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceMeshShaderPropertiesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMeshShaderPropertiesNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceMeshShaderPropertiesNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDrawMeshTasksIndirectCommandNV(extensions: *const Extensions, item: *const vk.VkDrawMeshTasksIndirectCommandNV, validate_pnext: bool) bool {
    _ = item;
    _ = extensions;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDeviceMeshShaderFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMeshShaderFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceMeshShaderFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceMeshShaderPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMeshShaderPropertiesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceMeshShaderPropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDrawMeshTasksIndirectCommandEXT(extensions: *const Extensions, item: *const vk.VkDrawMeshTasksIndirectCommandEXT, validate_pnext: bool) bool {
    _ = item;
    _ = extensions;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkRayTracingShaderGroupCreateInfoNV(extensions: *const Extensions, item: *const vk.VkRayTracingShaderGroupCreateInfoNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkRayTracingShaderGroupTypeKHR(extensions, &item.type))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkRayTracingShaderGroupCreateInfoNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkRayTracingShaderGroupCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkRayTracingShaderGroupCreateInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkRayTracingShaderGroupTypeKHR(extensions, &item.type))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkRayTracingShaderGroupCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkRayTracingPipelineCreateInfoNV(extensions: *const Extensions, item: *const vk.VkRayTracingPipelineCreateInfoNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkPipelineCreateFlags(extensions, &item.flags))
        return false;
    if (item.pStages) |v| {
        for (v[0..item.stageCount]) |*vv| {
            if (!validate_VkPipelineShaderStageCreateInfo(extensions, vv, false))
                return false;
        }
    }
    if (item.pGroups) |v| {
        for (v[0..item.groupCount]) |*vv| {
            if (!validate_VkRayTracingShaderGroupCreateInfoNV(extensions, vv, false))
                return false;
        }
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkRayTracingPipelineCreateInfoNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkRayTracingPipelineCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkRayTracingPipelineCreateInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkPipelineCreateFlags(extensions, &item.flags))
        return false;
    if (item.pStages) |v| {
        for (v[0..item.stageCount]) |*vv| {
            if (!validate_VkPipelineShaderStageCreateInfo(extensions, vv, false))
                return false;
        }
    }
    if (item.pGroups) |v| {
        for (v[0..item.groupCount]) |*vv| {
            if (!validate_VkRayTracingShaderGroupCreateInfoKHR(extensions, vv, false))
                return false;
        }
    }
    if (item.pLibraryInfo) |v| {
        if (!validate_VkPipelineLibraryCreateInfoKHR(extensions, v, false))
            return false;
    }
    if (item.pLibraryInterface) |v| {
        if (!validate_VkRayTracingPipelineInterfaceCreateInfoKHR(extensions, v, false))
            return false;
    }
    if (item.pDynamicState) |v| {
        if (!validate_VkPipelineDynamicStateCreateInfo(extensions, v, false))
            return false;
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkRayTracingPipelineCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkGeometryTrianglesNV(extensions: *const Extensions, item: *const vk.VkGeometryTrianglesNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkFormat(extensions, &item.vertexFormat))
        return false;
    if (!validate_VkIndexType(extensions, &item.indexType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkGeometryTrianglesNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkGeometryAABBNV(extensions: *const Extensions, item: *const vk.VkGeometryAABBNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkGeometryAABBNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkGeometryDataNV(extensions: *const Extensions, item: *const vk.VkGeometryDataNV, validate_pnext: bool) bool {
    if (!validate_VkGeometryTrianglesNV(extensions, &item.triangles, false))
        return false;
    if (!validate_VkGeometryAABBNV(extensions, &item.aabbs, false))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkGeometryNV(extensions: *const Extensions, item: *const vk.VkGeometryNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkGeometryTypeKHR(extensions, &item.geometryType))
        return false;
    if (!validate_VkGeometryDataNV(extensions, &item.geometry, false))
        return false;
    if (!validate_VkGeometryFlagsKHR(extensions, &item.flags))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkGeometryNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkAccelerationStructureInfoNV(extensions: *const Extensions, item: *const vk.VkAccelerationStructureInfoNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkAccelerationStructureTypeKHR(extensions, &item.type))
        return false;
    if (item.pGeometries) |v| {
        for (v[0..item.geometryCount]) |*vv| {
            if (!validate_VkGeometryNV(extensions, vv, false))
                return false;
        }
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkAccelerationStructureInfoNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkAccelerationStructureCreateInfoNV(extensions: *const Extensions, item: *const vk.VkAccelerationStructureCreateInfoNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkAccelerationStructureInfoNV(extensions, &item.info, false))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkAccelerationStructureCreateInfoNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkBindAccelerationStructureMemoryInfoNV(extensions: *const Extensions, item: *const vk.VkBindAccelerationStructureMemoryInfoNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkBindAccelerationStructureMemoryInfoNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkWriteDescriptorSetAccelerationStructureKHR(extensions: *const Extensions, item: *const vk.VkWriteDescriptorSetAccelerationStructureKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET,
            => if (!validate_VkWriteDescriptorSet(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkWriteDescriptorSetAccelerationStructureKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkWriteDescriptorSetAccelerationStructureNV(extensions: *const Extensions, item: *const vk.VkWriteDescriptorSetAccelerationStructureNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET,
            => if (!validate_VkWriteDescriptorSet(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkWriteDescriptorSetAccelerationStructureNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkAccelerationStructureMemoryRequirementsInfoNV(extensions: *const Extensions, item: *const vk.VkAccelerationStructureMemoryRequirementsInfoNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkAccelerationStructureMemoryRequirementsTypeNV(extensions, &item.type))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkAccelerationStructureMemoryRequirementsInfoNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceAccelerationStructureFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceAccelerationStructureFeaturesKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceAccelerationStructureFeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceRayTracingPipelineFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceRayTracingPipelineFeaturesKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceRayTracingPipelineFeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceRayQueryFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceRayQueryFeaturesKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceRayQueryFeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceAccelerationStructurePropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceAccelerationStructurePropertiesKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceAccelerationStructurePropertiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceRayTracingPipelinePropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceRayTracingPipelinePropertiesKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceRayTracingPipelinePropertiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceRayTracingPropertiesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceRayTracingPropertiesNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceRayTracingPropertiesNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkStridedDeviceAddressRegionKHR(extensions: *const Extensions, item: *const vk.VkStridedDeviceAddressRegionKHR, validate_pnext: bool) bool {
    _ = item;
    _ = extensions;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkTraceRaysIndirectCommandKHR(extensions: *const Extensions, item: *const vk.VkTraceRaysIndirectCommandKHR, validate_pnext: bool) bool {
    _ = item;
    _ = extensions;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkTraceRaysIndirectCommand2KHR(extensions: *const Extensions, item: *const vk.VkTraceRaysIndirectCommand2KHR, validate_pnext: bool) bool {
    _ = item;
    _ = extensions;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDrmFormatModifierPropertiesListEXT(extensions: *const Extensions, item: *const vk.VkDrmFormatModifierPropertiesListEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (item.pDrmFormatModifierProperties) |v| {
        for (v[0..item.drmFormatModifierCount]) |*vv| {
            if (!validate_VkDrmFormatModifierPropertiesEXT(extensions, vv, false))
                return false;
        }
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2,
            => if (!validate_VkFormatProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDrmFormatModifierPropertiesListEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDrmFormatModifierPropertiesEXT(extensions: *const Extensions, item: *const vk.VkDrmFormatModifierPropertiesEXT, validate_pnext: bool) bool {
    if (!validate_VkFormatFeatureFlags(extensions, &item.drmFormatModifierTilingFeatures))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDeviceImageDrmFormatModifierInfoEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceImageDrmFormatModifierInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkSharingMode(extensions, &item.sharingMode))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2,
            => if (!validate_VkPhysicalDeviceImageFormatInfo2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceImageDrmFormatModifierInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImageDrmFormatModifierListCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkImageDrmFormatModifierListCreateInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO,
            => if (!validate_VkImageCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImageDrmFormatModifierListCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImageDrmFormatModifierExplicitCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkImageDrmFormatModifierExplicitCreateInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (item.pPlaneLayouts) |v| {
        for (v[0..item.drmFormatModifierPlaneCount]) |*vv| {
            if (!validate_VkSubresourceLayout(extensions, vv, false))
                return false;
        }
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO,
            => if (!validate_VkImageCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImageDrmFormatModifierExplicitCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImageDrmFormatModifierPropertiesEXT(extensions: *const Extensions, item: *const vk.VkImageDrmFormatModifierPropertiesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImageDrmFormatModifierPropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImageStencilUsageCreateInfo(extensions: *const Extensions, item: *const vk.VkImageStencilUsageCreateInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkImageUsageFlags(extensions, &item.stencilUsage))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO,
            => if (!validate_VkImageCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2,
            => if (!validate_VkPhysicalDeviceImageFormatInfo2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImageStencilUsageCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDeviceMemoryOverallocationCreateInfoAMD(extensions: *const Extensions, item: *const vk.VkDeviceMemoryOverallocationCreateInfoAMD, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkMemoryOverallocationBehaviorAMD(extensions, &item.overallocationBehavior))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDeviceMemoryOverallocationCreateInfoAMD: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceFragmentDensityMapFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceFragmentDensityMapFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceFragmentDensityMapFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceFragmentDensityMap2FeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceFragmentDensityMap2FeaturesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceFragmentDensityMap2FeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceFragmentDensityMapOffsetFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceFragmentDensityMapOffsetFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceFragmentDensityMapOffsetFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceFragmentDensityMapPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceFragmentDensityMapPropertiesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkExtent2D(extensions, &item.minFragmentDensityTexelSize, false))
        return false;
    if (!validate_VkExtent2D(extensions, &item.maxFragmentDensityTexelSize, false))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceFragmentDensityMapPropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceFragmentDensityMap2PropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceFragmentDensityMap2PropertiesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceFragmentDensityMap2PropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceFragmentDensityMapOffsetPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceFragmentDensityMapOffsetPropertiesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkExtent2D(extensions, &item.fragmentDensityOffsetGranularity, false))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceFragmentDensityMapOffsetPropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkRenderPassFragmentDensityMapCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkRenderPassFragmentDensityMapCreateInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkAttachmentReference(extensions, &item.fragmentDensityMapAttachment, false))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO,
            => if (!validate_VkRenderPassCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2,
            => if (!validate_VkRenderPassCreateInfo2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkRenderPassFragmentDensityMapCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkRenderPassFragmentDensityMapOffsetEndInfoEXT(extensions: *const Extensions, item: *const vk.VkRenderPassFragmentDensityMapOffsetEndInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (item.pFragmentDensityOffsets) |v| {
        for (v[0..item.fragmentDensityOffsetCount]) |*vv| {
            if (!validate_VkOffset2D(extensions, vv, false))
                return false;
        }
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_SUBPASS_END_INFO,
            => if (!validate_VkSubpassEndInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_RENDERING_END_INFO_KHR,
            => if (!validate_VkRenderingEndInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkRenderPassFragmentDensityMapOffsetEndInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceScalarBlockLayoutFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceScalarBlockLayoutFeatures, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceScalarBlockLayoutFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSurfaceProtectedCapabilitiesKHR(extensions: *const Extensions, item: *const vk.VkSurfaceProtectedCapabilitiesKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR,
            => if (!validate_VkSurfaceCapabilities2KHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSurfaceProtectedCapabilitiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceUniformBufferStandardLayoutFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceUniformBufferStandardLayoutFeatures, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceUniformBufferStandardLayoutFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceDepthClipEnableFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDepthClipEnableFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceDepthClipEnableFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPipelineRasterizationDepthClipStateCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkPipelineRasterizationDepthClipStateCreateInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkPipelineRasterizationDepthClipStateCreateFlagsEXT(extensions, &item.flags))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO,
            => if (!validate_VkPipelineRasterizationStateCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineRasterizationDepthClipStateCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceMemoryBudgetPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMemoryBudgetPropertiesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceMemoryProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceMemoryBudgetPropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceMemoryPriorityFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMemoryPriorityFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceMemoryPriorityFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkMemoryPriorityAllocateInfoEXT(extensions: *const Extensions, item: *const vk.VkMemoryPriorityAllocateInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO,
            => if (!validate_VkMemoryAllocateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMemoryPriorityAllocateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceBufferDeviceAddressFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceBufferDeviceAddressFeatures, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceBufferDeviceAddressFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceBufferDeviceAddressFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceBufferDeviceAddressFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceBufferDeviceAddressFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkBufferDeviceAddressInfo(extensions: *const Extensions, item: *const vk.VkBufferDeviceAddressInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkBufferDeviceAddressInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkBufferOpaqueCaptureAddressCreateInfo(extensions: *const Extensions, item: *const vk.VkBufferOpaqueCaptureAddressCreateInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO,
            => if (!validate_VkBufferCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkBufferOpaqueCaptureAddressCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkBufferDeviceAddressCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkBufferDeviceAddressCreateInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO,
            => if (!validate_VkBufferCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkBufferDeviceAddressCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceImageViewImageFormatInfoEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceImageViewImageFormatInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkImageViewType(extensions, &item.imageViewType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2,
            => if (!validate_VkPhysicalDeviceImageFormatInfo2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceImageViewImageFormatInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkFilterCubicImageViewImageFormatPropertiesEXT(extensions: *const Extensions, item: *const vk.VkFilterCubicImageViewImageFormatPropertiesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2,
            => if (!validate_VkImageFormatProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkFilterCubicImageViewImageFormatPropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceImagelessFramebufferFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceImagelessFramebufferFeatures, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceImagelessFramebufferFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkFramebufferAttachmentsCreateInfo(extensions: *const Extensions, item: *const vk.VkFramebufferAttachmentsCreateInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (item.pAttachmentImageInfos) |v| {
        for (v[0..item.attachmentImageInfoCount]) |*vv| {
            if (!validate_VkFramebufferAttachmentImageInfo(extensions, vv, false))
                return false;
        }
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO,
            => if (!validate_VkFramebufferCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkFramebufferAttachmentsCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkFramebufferAttachmentImageInfo(extensions: *const Extensions, item: *const vk.VkFramebufferAttachmentImageInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkImageCreateFlags(extensions, &item.flags))
        return false;
    if (!validate_VkImageUsageFlags(extensions, &item.usage))
        return false;
    if (item.pViewFormats) |v| {
        for (v[0..item.viewFormatCount]) |*vv| {
            if (!validate_VkFormat(extensions, vv))
                return false;
        }
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkFramebufferAttachmentImageInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkRenderPassAttachmentBeginInfo(extensions: *const Extensions, item: *const vk.VkRenderPassAttachmentBeginInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO,
            => if (!validate_VkRenderPassBeginInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkRenderPassAttachmentBeginInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceTextureCompressionASTCHDRFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceTextureCompressionASTCHDRFeatures, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceTextureCompressionASTCHDRFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceCooperativeMatrixFeaturesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceCooperativeMatrixFeaturesNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceCooperativeMatrixFeaturesNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceCooperativeMatrixPropertiesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceCooperativeMatrixPropertiesNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkShaderStageFlags(extensions, &item.cooperativeMatrixSupportedStages))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceCooperativeMatrixPropertiesNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkCooperativeMatrixPropertiesNV(extensions: *const Extensions, item: *const vk.VkCooperativeMatrixPropertiesNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkComponentTypeKHR(extensions, &item.AType))
        return false;
    if (!validate_VkComponentTypeKHR(extensions, &item.BType))
        return false;
    if (!validate_VkComponentTypeKHR(extensions, &item.CType))
        return false;
    if (!validate_VkComponentTypeKHR(extensions, &item.DType))
        return false;
    if (!validate_VkScopeKHR(extensions, &item.scope))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkCooperativeMatrixPropertiesNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceYcbcrImageArraysFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceYcbcrImageArraysFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceYcbcrImageArraysFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImageViewHandleInfoNVX(extensions: *const Extensions, item: *const vk.VkImageViewHandleInfoNVX, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkDescriptorType(extensions, &item.descriptorType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImageViewHandleInfoNVX: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImageViewAddressPropertiesNVX(extensions: *const Extensions, item: *const vk.VkImageViewAddressPropertiesNVX, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImageViewAddressPropertiesNVX: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPresentFrameTokenGGP(extensions: *const Extensions, item: *const vk.VkPresentFrameTokenGGP, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PRESENT_INFO_KHR,
            => if (!validate_VkPresentInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPresentFrameTokenGGP: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPipelineCreationFeedback(extensions: *const Extensions, item: *const vk.VkPipelineCreationFeedback, validate_pnext: bool) bool {
    if (!validate_VkPipelineCreationFeedbackFlags(extensions, &item.flags))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPipelineCreationFeedbackCreateInfo(extensions: *const Extensions, item: *const vk.VkPipelineCreationFeedbackCreateInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (item.pPipelineCreationFeedback) |v| {
        if (!validate_VkPipelineCreationFeedback(extensions, v, false))
            return false;
    }
    if (item.pPipelineStageCreationFeedbacks) |v| {
        for (v[0..item.pipelineStageCreationFeedbackCount]) |*vv| {
            if (!validate_VkPipelineCreationFeedback(extensions, vv, false))
                return false;
        }
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO,
            => if (!validate_VkGraphicsPipelineCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO,
            => if (!validate_VkComputePipelineCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV,
            => if (!validate_VkRayTracingPipelineCreateInfoNV(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_KHR,
            => if (!validate_VkRayTracingPipelineCreateInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_EXECUTION_GRAPH_PIPELINE_CREATE_INFO_AMDX,
            => if (!validate_VkExecutionGraphPipelineCreateInfoAMDX(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_CREATE_INFO_ARM,
            => if (!validate_VkDataGraphPipelineCreateInfoARM(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineCreationFeedbackCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSurfaceFullScreenExclusiveInfoEXT(extensions: *const Extensions, item: *const vk.VkSurfaceFullScreenExclusiveInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkFullScreenExclusiveEXT(extensions, &item.fullScreenExclusive))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR,
            => if (!validate_VkPhysicalDeviceSurfaceInfo2KHR(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR,
            => if (!validate_VkSwapchainCreateInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSurfaceFullScreenExclusiveInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSurfaceFullScreenExclusiveWin32InfoEXT(extensions: *const Extensions, item: *const vk.VkSurfaceFullScreenExclusiveWin32InfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR,
            => if (!validate_VkPhysicalDeviceSurfaceInfo2KHR(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR,
            => if (!validate_VkSwapchainCreateInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSurfaceFullScreenExclusiveWin32InfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSurfaceCapabilitiesFullScreenExclusiveEXT(extensions: *const Extensions, item: *const vk.VkSurfaceCapabilitiesFullScreenExclusiveEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR,
            => if (!validate_VkSurfaceCapabilities2KHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSurfaceCapabilitiesFullScreenExclusiveEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDevicePresentBarrierFeaturesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePresentBarrierFeaturesNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDevicePresentBarrierFeaturesNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSurfaceCapabilitiesPresentBarrierNV(extensions: *const Extensions, item: *const vk.VkSurfaceCapabilitiesPresentBarrierNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR,
            => if (!validate_VkSurfaceCapabilities2KHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSurfaceCapabilitiesPresentBarrierNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSwapchainPresentBarrierCreateInfoNV(extensions: *const Extensions, item: *const vk.VkSwapchainPresentBarrierCreateInfoNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR,
            => if (!validate_VkSwapchainCreateInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSwapchainPresentBarrierCreateInfoNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDevicePerformanceQueryFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePerformanceQueryFeaturesKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDevicePerformanceQueryFeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDevicePerformanceQueryPropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePerformanceQueryPropertiesKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDevicePerformanceQueryPropertiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPerformanceCounterKHR(extensions: *const Extensions, item: *const vk.VkPerformanceCounterKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkPerformanceCounterUnitKHR(extensions, &item.unit))
        return false;
    if (!validate_VkPerformanceCounterScopeKHR(extensions, &item.scope))
        return false;
    if (!validate_VkPerformanceCounterStorageKHR(extensions, &item.storage))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPerformanceCounterKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPerformanceCounterDescriptionKHR(extensions: *const Extensions, item: *const vk.VkPerformanceCounterDescriptionKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkPerformanceCounterDescriptionFlagsKHR(extensions, &item.flags))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPerformanceCounterDescriptionKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkQueryPoolPerformanceCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkQueryPoolPerformanceCreateInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO,
            => if (!validate_VkQueryPoolCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkQueryPoolPerformanceCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkAcquireProfilingLockInfoKHR(extensions: *const Extensions, item: *const vk.VkAcquireProfilingLockInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkAcquireProfilingLockFlagsKHR(extensions, &item.flags))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkAcquireProfilingLockInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPerformanceQuerySubmitInfoKHR(extensions: *const Extensions, item: *const vk.VkPerformanceQuerySubmitInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_SUBMIT_INFO,
            => if (!validate_VkSubmitInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_SUBMIT_INFO_2,
            => if (!validate_VkSubmitInfo2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPerformanceQuerySubmitInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPerformanceQueryReservationInfoKHR(extensions: *const Extensions, item: *const vk.VkPerformanceQueryReservationInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPerformanceQueryReservationInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkHeadlessSurfaceCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkHeadlessSurfaceCreateInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkHeadlessSurfaceCreateFlagsEXT(extensions, &item.flags))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkHeadlessSurfaceCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceCoverageReductionModeFeaturesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceCoverageReductionModeFeaturesNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceCoverageReductionModeFeaturesNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPipelineCoverageReductionStateCreateInfoNV(extensions: *const Extensions, item: *const vk.VkPipelineCoverageReductionStateCreateInfoNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkPipelineCoverageReductionStateCreateFlagsNV(extensions, &item.flags))
        return false;
    if (!validate_VkCoverageReductionModeNV(extensions, &item.coverageReductionMode))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO,
            => if (!validate_VkPipelineMultisampleStateCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineCoverageReductionStateCreateInfoNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkFramebufferMixedSamplesCombinationNV(extensions: *const Extensions, item: *const vk.VkFramebufferMixedSamplesCombinationNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkCoverageReductionModeNV(extensions, &item.coverageReductionMode))
        return false;
    if (!validate_VkSampleCountFlags(extensions, &item.rasterizationSamples))
        return false;
    if (!validate_VkSampleCountFlags(extensions, &item.depthStencilSamples))
        return false;
    if (!validate_VkSampleCountFlags(extensions, &item.colorSamples))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkFramebufferMixedSamplesCombinationNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPerformanceValueINTEL(extensions: *const Extensions, item: *const vk.VkPerformanceValueINTEL, validate_pnext: bool) bool {
    if (!validate_VkPerformanceValueTypeINTEL(extensions, &item.type))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkInitializePerformanceApiInfoINTEL(extensions: *const Extensions, item: *const vk.VkInitializePerformanceApiInfoINTEL, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkInitializePerformanceApiInfoINTEL: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkQueryPoolPerformanceQueryCreateInfoINTEL(extensions: *const Extensions, item: *const vk.VkQueryPoolPerformanceQueryCreateInfoINTEL, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkQueryPoolSamplingModeINTEL(extensions, &item.performanceCountersSampling))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO,
            => if (!validate_VkQueryPoolCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkQueryPoolPerformanceQueryCreateInfoINTEL: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPerformanceMarkerInfoINTEL(extensions: *const Extensions, item: *const vk.VkPerformanceMarkerInfoINTEL, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPerformanceMarkerInfoINTEL: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPerformanceStreamMarkerInfoINTEL(extensions: *const Extensions, item: *const vk.VkPerformanceStreamMarkerInfoINTEL, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPerformanceStreamMarkerInfoINTEL: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPerformanceOverrideInfoINTEL(extensions: *const Extensions, item: *const vk.VkPerformanceOverrideInfoINTEL, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkPerformanceOverrideTypeINTEL(extensions, &item.type))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPerformanceOverrideInfoINTEL: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPerformanceConfigurationAcquireInfoINTEL(extensions: *const Extensions, item: *const vk.VkPerformanceConfigurationAcquireInfoINTEL, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkPerformanceConfigurationTypeINTEL(extensions, &item.type))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPerformanceConfigurationAcquireInfoINTEL: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceShaderClockFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderClockFeaturesKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShaderClockFeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceIndexTypeUint8Features(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceIndexTypeUint8Features, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceIndexTypeUint8Features: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceShaderSMBuiltinsPropertiesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderSMBuiltinsPropertiesNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShaderSMBuiltinsPropertiesNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceShaderSMBuiltinsFeaturesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderSMBuiltinsFeaturesNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShaderSMBuiltinsFeaturesNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkAttachmentReferenceStencilLayout(extensions: *const Extensions, item: *const vk.VkAttachmentReferenceStencilLayout, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkImageLayout(extensions, &item.stencilLayout))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2,
            => if (!validate_VkAttachmentReference2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkAttachmentReferenceStencilLayout: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkAttachmentDescriptionStencilLayout(extensions: *const Extensions, item: *const vk.VkAttachmentDescriptionStencilLayout, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkImageLayout(extensions, &item.stencilInitialLayout))
        return false;
    if (!validate_VkImageLayout(extensions, &item.stencilFinalLayout))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2,
            => if (!validate_VkAttachmentDescription2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkAttachmentDescriptionStencilLayout: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPipelineInfoKHR(extensions: *const Extensions, item: *const vk.VkPipelineInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPipelineExecutablePropertiesKHR(extensions: *const Extensions, item: *const vk.VkPipelineExecutablePropertiesKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkShaderStageFlags(extensions, &item.stages))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineExecutablePropertiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPipelineExecutableInfoKHR(extensions: *const Extensions, item: *const vk.VkPipelineExecutableInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineExecutableInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPipelineExecutableStatisticKHR(extensions: *const Extensions, item: *const vk.VkPipelineExecutableStatisticKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkPipelineExecutableStatisticFormatKHR(extensions, &item.format))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineExecutableStatisticKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPipelineExecutableInternalRepresentationKHR(extensions: *const Extensions, item: *const vk.VkPipelineExecutableInternalRepresentationKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineExecutableInternalRepresentationKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceTexelBufferAlignmentProperties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceTexelBufferAlignmentProperties, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceTexelBufferAlignmentProperties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceSubgroupSizeControlFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceSubgroupSizeControlFeatures, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceSubgroupSizeControlFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceSubgroupSizeControlProperties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceSubgroupSizeControlProperties, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkShaderStageFlags(extensions, &item.requiredSubgroupSizeStages))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceSubgroupSizeControlProperties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPipelineShaderStageRequiredSubgroupSizeCreateInfo(extensions: *const Extensions, item: *const vk.VkPipelineShaderStageRequiredSubgroupSizeCreateInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO,
            => if (!validate_VkPipelineShaderStageCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_SHADER_CREATE_INFO_EXT,
            => if (!validate_VkShaderCreateInfoEXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineShaderStageRequiredSubgroupSizeCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSubpassShadingPipelineCreateInfoHUAWEI(extensions: *const Extensions, item: *const vk.VkSubpassShadingPipelineCreateInfoHUAWEI, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO,
            => if (!validate_VkComputePipelineCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSubpassShadingPipelineCreateInfoHUAWEI: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceSubpassShadingPropertiesHUAWEI(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceSubpassShadingPropertiesHUAWEI, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceSubpassShadingPropertiesHUAWEI: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkMemoryOpaqueCaptureAddressAllocateInfo(extensions: *const Extensions, item: *const vk.VkMemoryOpaqueCaptureAddressAllocateInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO,
            => if (!validate_VkMemoryAllocateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMemoryOpaqueCaptureAddressAllocateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDeviceMemoryOpaqueCaptureAddressInfo(extensions: *const Extensions, item: *const vk.VkDeviceMemoryOpaqueCaptureAddressInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDeviceMemoryOpaqueCaptureAddressInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceLineRasterizationFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceLineRasterizationFeatures, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceLineRasterizationFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceLineRasterizationProperties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceLineRasterizationProperties, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceLineRasterizationProperties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPipelineRasterizationLineStateCreateInfo(extensions: *const Extensions, item: *const vk.VkPipelineRasterizationLineStateCreateInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkLineRasterizationMode(extensions, &item.lineRasterizationMode))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO,
            => if (!validate_VkPipelineRasterizationStateCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineRasterizationLineStateCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDevicePipelineCreationCacheControlFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePipelineCreationCacheControlFeatures, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDevicePipelineCreationCacheControlFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceVulkan11Features(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVulkan11Features, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceVulkan11Features: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceVulkan11Properties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVulkan11Properties, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkShaderStageFlags(extensions, &item.subgroupSupportedStages))
        return false;
    if (!validate_VkSubgroupFeatureFlags(extensions, &item.subgroupSupportedOperations))
        return false;
    if (!validate_VkPointClippingBehavior(extensions, &item.pointClippingBehavior))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceVulkan11Properties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceVulkan12Features(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVulkan12Features, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceVulkan12Features: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceVulkan12Properties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVulkan12Properties, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkDriverId(extensions, &item.driverID))
        return false;
    if (!validate_VkConformanceVersion(extensions, &item.conformanceVersion, false))
        return false;
    if (!validate_VkShaderFloatControlsIndependence(extensions, &item.denormBehaviorIndependence))
        return false;
    if (!validate_VkShaderFloatControlsIndependence(extensions, &item.roundingModeIndependence))
        return false;
    if (!validate_VkResolveModeFlags(extensions, &item.supportedDepthResolveModes))
        return false;
    if (!validate_VkResolveModeFlags(extensions, &item.supportedStencilResolveModes))
        return false;
    if (!validate_VkSampleCountFlags(extensions, &item.framebufferIntegerColorSampleCounts))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceVulkan12Properties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceVulkan13Features(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVulkan13Features, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceVulkan13Features: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceVulkan13Properties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVulkan13Properties, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkShaderStageFlags(extensions, &item.requiredSubgroupSizeStages))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceVulkan13Properties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceVulkan14Features(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVulkan14Features, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceVulkan14Features: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceVulkan14Properties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVulkan14Properties, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkPipelineRobustnessBufferBehavior(extensions, &item.defaultRobustnessStorageBuffers))
        return false;
    if (!validate_VkPipelineRobustnessBufferBehavior(extensions, &item.defaultRobustnessUniformBuffers))
        return false;
    if (!validate_VkPipelineRobustnessBufferBehavior(extensions, &item.defaultRobustnessVertexInputs))
        return false;
    if (!validate_VkPipelineRobustnessImageBehavior(extensions, &item.defaultRobustnessImages))
        return false;
    if (item.pCopySrcLayouts) |v| {
        for (v[0..item.copySrcLayoutCount]) |*vv| {
            if (!validate_VkImageLayout(extensions, vv))
                return false;
        }
    }
    if (item.pCopyDstLayouts) |v| {
        for (v[0..item.copyDstLayoutCount]) |*vv| {
            if (!validate_VkImageLayout(extensions, vv))
                return false;
        }
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceVulkan14Properties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPipelineCompilerControlCreateInfoAMD(extensions: *const Extensions, item: *const vk.VkPipelineCompilerControlCreateInfoAMD, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkPipelineCompilerControlFlagsAMD(extensions, &item.compilerControlFlags))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO,
            => if (!validate_VkGraphicsPipelineCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO,
            => if (!validate_VkComputePipelineCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_EXECUTION_GRAPH_PIPELINE_CREATE_INFO_AMDX,
            => if (!validate_VkExecutionGraphPipelineCreateInfoAMDX(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineCompilerControlCreateInfoAMD: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceCoherentMemoryFeaturesAMD(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceCoherentMemoryFeaturesAMD, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceCoherentMemoryFeaturesAMD: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkFaultData(extensions: *const Extensions, item: *const vk.VkFaultData, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkFaultLevel(extensions, &item.faultLevel))
        return false;
    if (!validate_VkFaultType(extensions, &item.faultType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkFaultData: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkFaultCallbackInfo(extensions: *const Extensions, item: *const vk.VkFaultCallbackInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (item.pFaults) |v| {
        for (v[0..item.faultCount]) |*vv| {
            if (!validate_VkFaultData(extensions, vv, false))
                return false;
        }
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkFaultCallbackInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceToolProperties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceToolProperties, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkToolPurposeFlags(extensions, &item.purposes))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceToolProperties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSamplerCustomBorderColorCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkSamplerCustomBorderColorCreateInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkFormat(extensions, &item.format))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO,
            => if (!validate_VkSamplerCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSamplerCustomBorderColorCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceCustomBorderColorPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceCustomBorderColorPropertiesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceCustomBorderColorPropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceCustomBorderColorFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceCustomBorderColorFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceCustomBorderColorFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSamplerBorderColorComponentMappingCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkSamplerBorderColorComponentMappingCreateInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkComponentMapping(extensions, &item.components, false))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO,
            => if (!validate_VkSamplerCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSamplerBorderColorComponentMappingCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceBorderColorSwizzleFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceBorderColorSwizzleFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceBorderColorSwizzleFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkAccelerationStructureGeometryTrianglesDataKHR(extensions: *const Extensions, item: *const vk.VkAccelerationStructureGeometryTrianglesDataKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkFormat(extensions, &item.vertexFormat))
        return false;
    if (!validate_VkIndexType(extensions, &item.indexType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkAccelerationStructureGeometryTrianglesDataKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkAccelerationStructureGeometryAabbsDataKHR(extensions: *const Extensions, item: *const vk.VkAccelerationStructureGeometryAabbsDataKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkAccelerationStructureGeometryAabbsDataKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkAccelerationStructureGeometryInstancesDataKHR(extensions: *const Extensions, item: *const vk.VkAccelerationStructureGeometryInstancesDataKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkAccelerationStructureGeometryInstancesDataKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkAccelerationStructureGeometryLinearSweptSpheresDataNV(extensions: *const Extensions, item: *const vk.VkAccelerationStructureGeometryLinearSweptSpheresDataNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkFormat(extensions, &item.vertexFormat))
        return false;
    if (!validate_VkFormat(extensions, &item.radiusFormat))
        return false;
    if (!validate_VkIndexType(extensions, &item.indexType))
        return false;
    if (!validate_VkRayTracingLssIndexingModeNV(extensions, &item.indexingMode))
        return false;
    if (!validate_VkRayTracingLssPrimitiveEndCapsModeNV(extensions, &item.endCapsMode))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR,
            => if (!validate_VkAccelerationStructureGeometryKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkAccelerationStructureGeometryLinearSweptSpheresDataNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkAccelerationStructureGeometrySpheresDataNV(extensions: *const Extensions, item: *const vk.VkAccelerationStructureGeometrySpheresDataNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkFormat(extensions, &item.vertexFormat))
        return false;
    if (!validate_VkFormat(extensions, &item.radiusFormat))
        return false;
    if (!validate_VkIndexType(extensions, &item.indexType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR,
            => if (!validate_VkAccelerationStructureGeometryKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkAccelerationStructureGeometrySpheresDataNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkAccelerationStructureGeometryKHR(extensions: *const Extensions, item: *const vk.VkAccelerationStructureGeometryKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkGeometryTypeKHR(extensions, &item.geometryType))
        return false;
    if (!validate_VkGeometryFlagsKHR(extensions, &item.flags))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkAccelerationStructureGeometryKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkAccelerationStructureBuildGeometryInfoKHR(extensions: *const Extensions, item: *const vk.VkAccelerationStructureBuildGeometryInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkAccelerationStructureTypeKHR(extensions, &item.type))
        return false;
    if (!validate_VkBuildAccelerationStructureFlagsKHR(extensions, &item.flags))
        return false;
    if (!validate_VkBuildAccelerationStructureModeKHR(extensions, &item.mode))
        return false;
    if (item.pGeometries) |v| {
        for (v[0..item.geometryCount]) |*vv| {
            if (!validate_VkAccelerationStructureGeometryKHR(extensions, vv, false))
                return false;
        }
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkAccelerationStructureBuildGeometryInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkAccelerationStructureBuildRangeInfoKHR(extensions: *const Extensions, item: *const vk.VkAccelerationStructureBuildRangeInfoKHR, validate_pnext: bool) bool {
    _ = item;
    _ = extensions;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkAccelerationStructureCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkAccelerationStructureCreateInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkAccelerationStructureCreateFlagsKHR(extensions, &item.createFlags))
        return false;
    if (!validate_VkAccelerationStructureTypeKHR(extensions, &item.type))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkAccelerationStructureCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkAabbPositionsKHR(extensions: *const Extensions, item: *const vk.VkAabbPositionsKHR, validate_pnext: bool) bool {
    _ = item;
    _ = extensions;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkTransformMatrixKHR(extensions: *const Extensions, item: *const vk.VkTransformMatrixKHR, validate_pnext: bool) bool {
    _ = item;
    _ = extensions;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkAccelerationStructureInstanceKHR(extensions: *const Extensions, item: *const vk.VkAccelerationStructureInstanceKHR, validate_pnext: bool) bool {
    if (!validate_VkTransformMatrixKHR(extensions, &item.transform, false))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkAccelerationStructureDeviceAddressInfoKHR(extensions: *const Extensions, item: *const vk.VkAccelerationStructureDeviceAddressInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkAccelerationStructureDeviceAddressInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkAccelerationStructureVersionInfoKHR(extensions: *const Extensions, item: *const vk.VkAccelerationStructureVersionInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkAccelerationStructureVersionInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkCopyAccelerationStructureInfoKHR(extensions: *const Extensions, item: *const vk.VkCopyAccelerationStructureInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkCopyAccelerationStructureModeKHR(extensions, &item.mode))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkCopyAccelerationStructureInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkCopyAccelerationStructureToMemoryInfoKHR(extensions: *const Extensions, item: *const vk.VkCopyAccelerationStructureToMemoryInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkCopyAccelerationStructureModeKHR(extensions, &item.mode))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkCopyAccelerationStructureToMemoryInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkCopyMemoryToAccelerationStructureInfoKHR(extensions: *const Extensions, item: *const vk.VkCopyMemoryToAccelerationStructureInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkCopyAccelerationStructureModeKHR(extensions, &item.mode))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkCopyMemoryToAccelerationStructureInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkRayTracingPipelineInterfaceCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkRayTracingPipelineInterfaceCreateInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkRayTracingPipelineInterfaceCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPipelineLibraryCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkPipelineLibraryCreateInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO,
            => if (!validate_VkGraphicsPipelineCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineLibraryCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkRefreshObjectKHR(extensions: *const Extensions, item: *const vk.VkRefreshObjectKHR, validate_pnext: bool) bool {
    if (!validate_VkObjectType(extensions, &item.objectType))
        return false;
    if (!validate_VkRefreshObjectFlagsKHR(extensions, &item.flags))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkRefreshObjectListKHR(extensions: *const Extensions, item: *const vk.VkRefreshObjectListKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (item.pObjects) |v| {
        for (v[0..item.objectCount]) |*vv| {
            if (!validate_VkRefreshObjectKHR(extensions, vv, false))
                return false;
        }
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkRefreshObjectListKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceExtendedDynamicStateFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceExtendedDynamicStateFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceExtendedDynamicStateFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceExtendedDynamicState2FeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceExtendedDynamicState2FeaturesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceExtendedDynamicState2FeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceExtendedDynamicState3FeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceExtendedDynamicState3FeaturesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceExtendedDynamicState3FeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceExtendedDynamicState3PropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceExtendedDynamicState3PropertiesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceExtendedDynamicState3PropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkColorBlendEquationEXT(extensions: *const Extensions, item: *const vk.VkColorBlendEquationEXT, validate_pnext: bool) bool {
    if (!validate_VkBlendFactor(extensions, &item.srcColorBlendFactor))
        return false;
    if (!validate_VkBlendFactor(extensions, &item.dstColorBlendFactor))
        return false;
    if (!validate_VkBlendOp(extensions, &item.colorBlendOp))
        return false;
    if (!validate_VkBlendFactor(extensions, &item.srcAlphaBlendFactor))
        return false;
    if (!validate_VkBlendFactor(extensions, &item.dstAlphaBlendFactor))
        return false;
    if (!validate_VkBlendOp(extensions, &item.alphaBlendOp))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkColorBlendAdvancedEXT(extensions: *const Extensions, item: *const vk.VkColorBlendAdvancedEXT, validate_pnext: bool) bool {
    if (!validate_VkBlendOp(extensions, &item.advancedBlendOp))
        return false;
    if (!validate_VkBlendOverlapEXT(extensions, &item.blendOverlap))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkRenderPassTransformBeginInfoQCOM(extensions: *const Extensions, item: *const vk.VkRenderPassTransformBeginInfoQCOM, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkSurfaceTransformFlagsKHR(extensions, &item.transform))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO,
            => if (!validate_VkRenderPassBeginInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkRenderPassTransformBeginInfoQCOM: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkCopyCommandTransformInfoQCOM(extensions: *const Extensions, item: *const vk.VkCopyCommandTransformInfoQCOM, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkSurfaceTransformFlagsKHR(extensions, &item.transform))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2,
            => if (!validate_VkBufferImageCopy2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_IMAGE_BLIT_2,
            => if (!validate_VkImageBlit2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkCopyCommandTransformInfoQCOM: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkCommandBufferInheritanceRenderPassTransformInfoQCOM(extensions: *const Extensions, item: *const vk.VkCommandBufferInheritanceRenderPassTransformInfoQCOM, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkSurfaceTransformFlagsKHR(extensions, &item.transform))
        return false;
    if (!validate_VkRect2D(extensions, &item.renderArea, false))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO,
            => if (!validate_VkCommandBufferInheritanceInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkCommandBufferInheritanceRenderPassTransformInfoQCOM: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDevicePartitionedAccelerationStructureFeaturesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePartitionedAccelerationStructureFeaturesNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDevicePartitionedAccelerationStructureFeaturesNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDevicePartitionedAccelerationStructurePropertiesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePartitionedAccelerationStructurePropertiesNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDevicePartitionedAccelerationStructurePropertiesNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkBuildPartitionedAccelerationStructureIndirectCommandNV(extensions: *const Extensions, item: *const vk.VkBuildPartitionedAccelerationStructureIndirectCommandNV, validate_pnext: bool) bool {
    if (!validate_VkPartitionedAccelerationStructureOpTypeNV(extensions, &item.opType))
        return false;
    if (!validate_VkStridedDeviceAddressNV(extensions, &item.argData, false))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPartitionedAccelerationStructureFlagsNV(extensions: *const Extensions, item: *const vk.VkPartitionedAccelerationStructureFlagsNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCES_INPUT_NV,
            => if (!validate_VkPartitionedAccelerationStructureInstancesInputNV(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPartitionedAccelerationStructureFlagsNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPartitionedAccelerationStructureWriteInstanceDataNV(extensions: *const Extensions, item: *const vk.VkPartitionedAccelerationStructureWriteInstanceDataNV, validate_pnext: bool) bool {
    if (!validate_VkTransformMatrixKHR(extensions, &item.transform, false))
        return false;
    if (!validate_VkPartitionedAccelerationStructureInstanceFlagsNV(extensions, &item.instanceFlags))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPartitionedAccelerationStructureUpdateInstanceDataNV(extensions: *const Extensions, item: *const vk.VkPartitionedAccelerationStructureUpdateInstanceDataNV, validate_pnext: bool) bool {
    _ = item;
    _ = extensions;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPartitionedAccelerationStructureWritePartitionTranslationDataNV(extensions: *const Extensions, item: *const vk.VkPartitionedAccelerationStructureWritePartitionTranslationDataNV, validate_pnext: bool) bool {
    _ = item;
    _ = extensions;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkWriteDescriptorSetPartitionedAccelerationStructureNV(extensions: *const Extensions, item: *const vk.VkWriteDescriptorSetPartitionedAccelerationStructureNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET,
            => if (!validate_VkWriteDescriptorSet(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkWriteDescriptorSetPartitionedAccelerationStructureNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPartitionedAccelerationStructureInstancesInputNV(extensions: *const Extensions, item: *const vk.VkPartitionedAccelerationStructureInstancesInputNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkBuildAccelerationStructureFlagsKHR(extensions, &item.flags))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPartitionedAccelerationStructureInstancesInputNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkBuildPartitionedAccelerationStructureInfoNV(extensions: *const Extensions, item: *const vk.VkBuildPartitionedAccelerationStructureInfoNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkPartitionedAccelerationStructureInstancesInputNV(extensions, &item.input, false))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkBuildPartitionedAccelerationStructureInfoNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceDiagnosticsConfigFeaturesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDiagnosticsConfigFeaturesNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceDiagnosticsConfigFeaturesNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDeviceDiagnosticsConfigCreateInfoNV(extensions: *const Extensions, item: *const vk.VkDeviceDiagnosticsConfigCreateInfoNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkDeviceDiagnosticsConfigFlagsNV(extensions, &item.flags))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDeviceDiagnosticsConfigCreateInfoNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPipelineOfflineCreateInfo(extensions: *const Extensions, item: *const vk.VkPipelineOfflineCreateInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkPipelineMatchControl(extensions, &item.matchControl))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO,
            => if (!validate_VkGraphicsPipelineCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO,
            => if (!validate_VkComputePipelineCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_KHR,
            => if (!validate_VkRayTracingPipelineCreateInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV,
            => if (!validate_VkRayTracingPipelineCreateInfoNV(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineOfflineCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceRobustness2FeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceRobustness2FeaturesKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceRobustness2FeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceRobustness2PropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceRobustness2PropertiesKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceRobustness2PropertiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceImageRobustnessFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceImageRobustnessFeatures, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceImageRobustnessFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDevicePortabilitySubsetFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePortabilitySubsetFeaturesKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDevicePortabilitySubsetFeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDevicePortabilitySubsetPropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePortabilitySubsetPropertiesKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDevicePortabilitySubsetPropertiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDevice4444FormatsFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDevice4444FormatsFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDevice4444FormatsFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceSubpassShadingFeaturesHUAWEI(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceSubpassShadingFeaturesHUAWEI, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceSubpassShadingFeaturesHUAWEI: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_FEATURES_HUAWEI,
            => if (!validate_VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkBufferCopy2(extensions: *const Extensions, item: *const vk.VkBufferCopy2, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkBufferCopy2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImageCopy2(extensions: *const Extensions, item: *const vk.VkImageCopy2, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkImageSubresourceLayers(extensions, &item.srcSubresource, false))
        return false;
    if (!validate_VkOffset3D(extensions, &item.srcOffset, false))
        return false;
    if (!validate_VkImageSubresourceLayers(extensions, &item.dstSubresource, false))
        return false;
    if (!validate_VkOffset3D(extensions, &item.dstOffset, false))
        return false;
    if (!validate_VkExtent3D(extensions, &item.extent, false))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImageCopy2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImageBlit2(extensions: *const Extensions, item: *const vk.VkImageBlit2, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkImageSubresourceLayers(extensions, &item.srcSubresource, false))
        return false;
        for (item.srcOffsets) |v| {
            if (!validate_VkOffset3D(extensions, v))
                return false;
        }
    if (!validate_VkImageSubresourceLayers(extensions, &item.dstSubresource, false))
        return false;
        for (item.dstOffsets) |v| {
            if (!validate_VkOffset3D(extensions, v))
                return false;
        }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImageBlit2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkBufferImageCopy2(extensions: *const Extensions, item: *const vk.VkBufferImageCopy2, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkImageSubresourceLayers(extensions, &item.imageSubresource, false))
        return false;
    if (!validate_VkOffset3D(extensions, &item.imageOffset, false))
        return false;
    if (!validate_VkExtent3D(extensions, &item.imageExtent, false))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkBufferImageCopy2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImageResolve2(extensions: *const Extensions, item: *const vk.VkImageResolve2, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkImageSubresourceLayers(extensions, &item.srcSubresource, false))
        return false;
    if (!validate_VkOffset3D(extensions, &item.srcOffset, false))
        return false;
    if (!validate_VkImageSubresourceLayers(extensions, &item.dstSubresource, false))
        return false;
    if (!validate_VkOffset3D(extensions, &item.dstOffset, false))
        return false;
    if (!validate_VkExtent3D(extensions, &item.extent, false))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImageResolve2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkCopyBufferInfo2(extensions: *const Extensions, item: *const vk.VkCopyBufferInfo2, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (item.pRegions) |v| {
        for (v[0..item.regionCount]) |*vv| {
            if (!validate_VkBufferCopy2(extensions, vv, false))
                return false;
        }
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkCopyBufferInfo2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkCopyImageInfo2(extensions: *const Extensions, item: *const vk.VkCopyImageInfo2, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkImageLayout(extensions, &item.srcImageLayout))
        return false;
    if (!validate_VkImageLayout(extensions, &item.dstImageLayout))
        return false;
    if (item.pRegions) |v| {
        for (v[0..item.regionCount]) |*vv| {
            if (!validate_VkImageCopy2(extensions, vv, false))
                return false;
        }
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkCopyImageInfo2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkBlitImageInfo2(extensions: *const Extensions, item: *const vk.VkBlitImageInfo2, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkImageLayout(extensions, &item.srcImageLayout))
        return false;
    if (!validate_VkImageLayout(extensions, &item.dstImageLayout))
        return false;
    if (item.pRegions) |v| {
        for (v[0..item.regionCount]) |*vv| {
            if (!validate_VkImageBlit2(extensions, vv, false))
                return false;
        }
    }
    if (!validate_VkFilter(extensions, &item.filter))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkBlitImageInfo2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkCopyBufferToImageInfo2(extensions: *const Extensions, item: *const vk.VkCopyBufferToImageInfo2, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkImageLayout(extensions, &item.dstImageLayout))
        return false;
    if (item.pRegions) |v| {
        for (v[0..item.regionCount]) |*vv| {
            if (!validate_VkBufferImageCopy2(extensions, vv, false))
                return false;
        }
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkCopyBufferToImageInfo2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkCopyImageToBufferInfo2(extensions: *const Extensions, item: *const vk.VkCopyImageToBufferInfo2, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkImageLayout(extensions, &item.srcImageLayout))
        return false;
    if (item.pRegions) |v| {
        for (v[0..item.regionCount]) |*vv| {
            if (!validate_VkBufferImageCopy2(extensions, vv, false))
                return false;
        }
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkCopyImageToBufferInfo2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkResolveImageInfo2(extensions: *const Extensions, item: *const vk.VkResolveImageInfo2, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkImageLayout(extensions, &item.srcImageLayout))
        return false;
    if (!validate_VkImageLayout(extensions, &item.dstImageLayout))
        return false;
    if (item.pRegions) |v| {
        for (v[0..item.regionCount]) |*vv| {
            if (!validate_VkImageResolve2(extensions, vv, false))
                return false;
        }
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkResolveImageInfo2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkFragmentShadingRateAttachmentInfoKHR(extensions: *const Extensions, item: *const vk.VkFragmentShadingRateAttachmentInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (item.pFragmentShadingRateAttachment) |v| {
        if (!validate_VkAttachmentReference2(extensions, v, false))
            return false;
    }
    if (!validate_VkExtent2D(extensions, &item.shadingRateAttachmentTexelSize, false))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2,
            => if (!validate_VkSubpassDescription2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkFragmentShadingRateAttachmentInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPipelineFragmentShadingRateStateCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkPipelineFragmentShadingRateStateCreateInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkExtent2D(extensions, &item.fragmentSize, false))
        return false;
        for (item.combinerOps) |v| {
            if (!validate_VkFragmentShadingRateCombinerOpKHR(extensions, v))
                return false;
        }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO,
            => if (!validate_VkGraphicsPipelineCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineFragmentShadingRateStateCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceFragmentShadingRateFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceFragmentShadingRateFeaturesKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceFragmentShadingRateFeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceFragmentShadingRatePropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceFragmentShadingRatePropertiesKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkExtent2D(extensions, &item.minFragmentShadingRateAttachmentTexelSize, false))
        return false;
    if (!validate_VkExtent2D(extensions, &item.maxFragmentShadingRateAttachmentTexelSize, false))
        return false;
    if (!validate_VkExtent2D(extensions, &item.maxFragmentSize, false))
        return false;
    if (!validate_VkSampleCountFlags(extensions, &item.maxFragmentShadingRateRasterizationSamples))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceFragmentShadingRatePropertiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceFragmentShadingRateKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceFragmentShadingRateKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkSampleCountFlags(extensions, &item.sampleCounts))
        return false;
    if (!validate_VkExtent2D(extensions, &item.fragmentSize, false))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceFragmentShadingRateKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceShaderTerminateInvocationFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderTerminateInvocationFeatures, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShaderTerminateInvocationFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkSampleCountFlags(extensions, &item.maxFragmentShadingRateInvocationCount))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPipelineFragmentShadingRateEnumStateCreateInfoNV(extensions: *const Extensions, item: *const vk.VkPipelineFragmentShadingRateEnumStateCreateInfoNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkFragmentShadingRateTypeNV(extensions, &item.shadingRateType))
        return false;
    if (!validate_VkFragmentShadingRateNV(extensions, &item.shadingRate))
        return false;
        for (item.combinerOps) |v| {
            if (!validate_VkFragmentShadingRateCombinerOpKHR(extensions, v))
                return false;
        }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO,
            => if (!validate_VkGraphicsPipelineCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineFragmentShadingRateEnumStateCreateInfoNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkAccelerationStructureBuildSizesInfoKHR(extensions: *const Extensions, item: *const vk.VkAccelerationStructureBuildSizesInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkAccelerationStructureBuildSizesInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceImage2DViewOf3DFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceImage2DViewOf3DFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceImage2DViewOf3DFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkMutableDescriptorTypeListEXT(extensions: *const Extensions, item: *const vk.VkMutableDescriptorTypeListEXT, validate_pnext: bool) bool {
    if (item.pDescriptorTypes) |v| {
        for (v[0..item.descriptorTypeCount]) |*vv| {
            if (!validate_VkDescriptorType(extensions, vv))
                return false;
        }
    }
    _ = validate_pnext;
    return true;
}

pub fn validate_VkMutableDescriptorTypeCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkMutableDescriptorTypeCreateInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (item.pMutableDescriptorTypeLists) |v| {
        for (v[0..item.mutableDescriptorTypeListCount]) |*vv| {
            if (!validate_VkMutableDescriptorTypeListEXT(extensions, vv, false))
                return false;
        }
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO,
            => if (!validate_VkDescriptorSetLayoutCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO,
            => if (!validate_VkDescriptorPoolCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMutableDescriptorTypeCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceDepthClipControlFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDepthClipControlFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceDepthClipControlFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkBeginCustomResolveInfoEXT(extensions: *const Extensions, item: *const vk.VkBeginCustomResolveInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkBeginCustomResolveInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceCustomResolveFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceCustomResolveFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceCustomResolveFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkCustomResolveCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkCustomResolveCreateInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (item.pColorAttachmentFormats) |v| {
        for (v[0..item.colorAttachmentCount]) |*vv| {
            if (!validate_VkFormat(extensions, vv))
                return false;
        }
    }
    if (!validate_VkFormat(extensions, &item.depthAttachmentFormat))
        return false;
    if (!validate_VkFormat(extensions, &item.stencilAttachmentFormat))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO,
            => if (!validate_VkGraphicsPipelineCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO,
            => if (!validate_VkCommandBufferInheritanceInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_SHADER_CREATE_INFO_EXT,
            => if (!validate_VkShaderCreateInfoEXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkCustomResolveCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkIndirectCommandsInputModeFlagsEXT(extensions, &item.supportedIndirectCommandsInputModes))
        return false;
    if (!validate_VkShaderStageFlags(extensions, &item.supportedIndirectCommandsShaderStages))
        return false;
    if (!validate_VkShaderStageFlags(extensions, &item.supportedIndirectCommandsShaderStagesPipelineBinding))
        return false;
    if (!validate_VkShaderStageFlags(extensions, &item.supportedIndirectCommandsShaderStagesShaderBinding))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkGeneratedCommandsPipelineInfoEXT(extensions: *const Extensions, item: *const vk.VkGeneratedCommandsPipelineInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_EXT,
            => if (!validate_VkGeneratedCommandsInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_EXT,
            => if (!validate_VkGeneratedCommandsMemoryRequirementsInfoEXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkGeneratedCommandsPipelineInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkGeneratedCommandsShaderInfoEXT(extensions: *const Extensions, item: *const vk.VkGeneratedCommandsShaderInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_EXT,
            => if (!validate_VkGeneratedCommandsInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_EXT,
            => if (!validate_VkGeneratedCommandsMemoryRequirementsInfoEXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkGeneratedCommandsShaderInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkGeneratedCommandsMemoryRequirementsInfoEXT(extensions: *const Extensions, item: *const vk.VkGeneratedCommandsMemoryRequirementsInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkGeneratedCommandsMemoryRequirementsInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkIndirectExecutionSetPipelineInfoEXT(extensions: *const Extensions, item: *const vk.VkIndirectExecutionSetPipelineInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkIndirectExecutionSetPipelineInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkIndirectExecutionSetShaderLayoutInfoEXT(extensions: *const Extensions, item: *const vk.VkIndirectExecutionSetShaderLayoutInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkIndirectExecutionSetShaderLayoutInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkIndirectExecutionSetShaderInfoEXT(extensions: *const Extensions, item: *const vk.VkIndirectExecutionSetShaderInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (item.pSetLayoutInfos) |v| {
        for (v[0..item.shaderCount]) |*vv| {
            if (!validate_VkIndirectExecutionSetShaderLayoutInfoEXT(extensions, vv, false))
                return false;
        }
    }
    if (item.pPushConstantRanges) |v| {
        for (v[0..item.pushConstantRangeCount]) |*vv| {
            if (!validate_VkPushConstantRange(extensions, vv, false))
                return false;
        }
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkIndirectExecutionSetShaderInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkIndirectExecutionSetCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkIndirectExecutionSetCreateInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkIndirectExecutionSetInfoTypeEXT(extensions, &item.type))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkIndirectExecutionSetCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkGeneratedCommandsInfoEXT(extensions: *const Extensions, item: *const vk.VkGeneratedCommandsInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkShaderStageFlags(extensions, &item.shaderStages))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkGeneratedCommandsInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkWriteIndirectExecutionSetPipelineEXT(extensions: *const Extensions, item: *const vk.VkWriteIndirectExecutionSetPipelineEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkWriteIndirectExecutionSetPipelineEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkWriteIndirectExecutionSetShaderEXT(extensions: *const Extensions, item: *const vk.VkWriteIndirectExecutionSetShaderEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkWriteIndirectExecutionSetShaderEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkIndirectCommandsLayoutCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkIndirectCommandsLayoutCreateInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkIndirectCommandsLayoutUsageFlagsEXT(extensions, &item.flags))
        return false;
    if (!validate_VkShaderStageFlags(extensions, &item.shaderStages))
        return false;
    if (item.pTokens) |v| {
        for (v[0..item.tokenCount]) |*vv| {
            if (!validate_VkIndirectCommandsLayoutTokenEXT(extensions, vv, false))
                return false;
        }
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkIndirectCommandsLayoutCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkIndirectCommandsLayoutTokenEXT(extensions: *const Extensions, item: *const vk.VkIndirectCommandsLayoutTokenEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkIndirectCommandsTokenTypeEXT(extensions, &item.type))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkIndirectCommandsLayoutTokenEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDrawIndirectCountIndirectCommandEXT(extensions: *const Extensions, item: *const vk.VkDrawIndirectCountIndirectCommandEXT, validate_pnext: bool) bool {
    _ = item;
    _ = extensions;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkIndirectCommandsVertexBufferTokenEXT(extensions: *const Extensions, item: *const vk.VkIndirectCommandsVertexBufferTokenEXT, validate_pnext: bool) bool {
    _ = item;
    _ = extensions;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkBindVertexBufferIndirectCommandEXT(extensions: *const Extensions, item: *const vk.VkBindVertexBufferIndirectCommandEXT, validate_pnext: bool) bool {
    _ = item;
    _ = extensions;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkIndirectCommandsIndexBufferTokenEXT(extensions: *const Extensions, item: *const vk.VkIndirectCommandsIndexBufferTokenEXT, validate_pnext: bool) bool {
    if (!validate_VkIndirectCommandsInputModeFlagsEXT(extensions, &item.mode))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkBindIndexBufferIndirectCommandEXT(extensions: *const Extensions, item: *const vk.VkBindIndexBufferIndirectCommandEXT, validate_pnext: bool) bool {
    if (!validate_VkIndexType(extensions, &item.indexType))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkIndirectCommandsPushConstantTokenEXT(extensions: *const Extensions, item: *const vk.VkIndirectCommandsPushConstantTokenEXT, validate_pnext: bool) bool {
    if (!validate_VkPushConstantRange(extensions, &item.updateRange, false))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkIndirectCommandsExecutionSetTokenEXT(extensions: *const Extensions, item: *const vk.VkIndirectCommandsExecutionSetTokenEXT, validate_pnext: bool) bool {
    if (!validate_VkIndirectExecutionSetInfoTypeEXT(extensions, &item.type))
        return false;
    if (!validate_VkShaderStageFlags(extensions, &item.shaderStages))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPipelineViewportDepthClipControlCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkPipelineViewportDepthClipControlCreateInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO,
            => if (!validate_VkPipelineViewportStateCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineViewportDepthClipControlCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceDepthClampControlFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDepthClampControlFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceDepthClampControlFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPipelineViewportDepthClampControlCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkPipelineViewportDepthClampControlCreateInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkDepthClampModeEXT(extensions, &item.depthClampMode))
        return false;
    if (item.pDepthClampRange) |v| {
        if (!validate_VkDepthClampRangeEXT(extensions, v, false))
            return false;
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO,
            => if (!validate_VkPipelineViewportStateCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineViewportDepthClampControlCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceExternalMemoryRDMAFeaturesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceExternalMemoryRDMAFeaturesNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceExternalMemoryRDMAFeaturesNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVertexInputBindingDescription2EXT(extensions: *const Extensions, item: *const vk.VkVertexInputBindingDescription2EXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkVertexInputRate(extensions, &item.inputRate))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVertexInputBindingDescription2EXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVertexInputAttributeDescription2EXT(extensions: *const Extensions, item: *const vk.VkVertexInputAttributeDescription2EXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkFormat(extensions, &item.format))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVertexInputAttributeDescription2EXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceColorWriteEnableFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceColorWriteEnableFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceColorWriteEnableFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPipelineColorWriteCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkPipelineColorWriteCreateInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO,
            => if (!validate_VkPipelineColorBlendStateCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineColorWriteCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkMemoryBarrier2(extensions: *const Extensions, item: *const vk.VkMemoryBarrier2, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkPipelineStageFlags2(extensions, &item.srcStageMask))
        return false;
    if (!validate_VkAccessFlags2(extensions, &item.srcAccessMask))
        return false;
    if (!validate_VkPipelineStageFlags2(extensions, &item.dstStageMask))
        return false;
    if (!validate_VkAccessFlags2(extensions, &item.dstAccessMask))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2,
            => if (!validate_VkSubpassDependency2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMemoryBarrier2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImageMemoryBarrier2(extensions: *const Extensions, item: *const vk.VkImageMemoryBarrier2, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkPipelineStageFlags2(extensions, &item.srcStageMask))
        return false;
    if (!validate_VkAccessFlags2(extensions, &item.srcAccessMask))
        return false;
    if (!validate_VkPipelineStageFlags2(extensions, &item.dstStageMask))
        return false;
    if (!validate_VkAccessFlags2(extensions, &item.dstAccessMask))
        return false;
    if (!validate_VkImageLayout(extensions, &item.oldLayout))
        return false;
    if (!validate_VkImageLayout(extensions, &item.newLayout))
        return false;
    if (!validate_VkImageSubresourceRange(extensions, &item.subresourceRange, false))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImageMemoryBarrier2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkBufferMemoryBarrier2(extensions: *const Extensions, item: *const vk.VkBufferMemoryBarrier2, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkPipelineStageFlags2(extensions, &item.srcStageMask))
        return false;
    if (!validate_VkAccessFlags2(extensions, &item.srcAccessMask))
        return false;
    if (!validate_VkPipelineStageFlags2(extensions, &item.dstStageMask))
        return false;
    if (!validate_VkAccessFlags2(extensions, &item.dstAccessMask))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkBufferMemoryBarrier2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkMemoryBarrierAccessFlags3KHR(extensions: *const Extensions, item: *const vk.VkMemoryBarrierAccessFlags3KHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkAccessFlags3KHR(extensions, &item.srcAccessMask3))
        return false;
    if (!validate_VkAccessFlags3KHR(extensions, &item.dstAccessMask3))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2,
            => if (!validate_VkSubpassDependency2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2,
            => if (!validate_VkBufferMemoryBarrier2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2,
            => if (!validate_VkImageMemoryBarrier2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMemoryBarrierAccessFlags3KHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDependencyInfo(extensions: *const Extensions, item: *const vk.VkDependencyInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkDependencyFlags(extensions, &item.dependencyFlags))
        return false;
    if (item.pMemoryBarriers) |v| {
        for (v[0..item.memoryBarrierCount]) |*vv| {
            if (!validate_VkMemoryBarrier2(extensions, vv, false))
                return false;
        }
    }
    if (item.pBufferMemoryBarriers) |v| {
        for (v[0..item.bufferMemoryBarrierCount]) |*vv| {
            if (!validate_VkBufferMemoryBarrier2(extensions, vv, false))
                return false;
        }
    }
    if (item.pImageMemoryBarriers) |v| {
        for (v[0..item.imageMemoryBarrierCount]) |*vv| {
            if (!validate_VkImageMemoryBarrier2(extensions, vv, false))
                return false;
        }
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDependencyInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSemaphoreSubmitInfo(extensions: *const Extensions, item: *const vk.VkSemaphoreSubmitInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkPipelineStageFlags2(extensions, &item.stageMask))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSemaphoreSubmitInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkCommandBufferSubmitInfo(extensions: *const Extensions, item: *const vk.VkCommandBufferSubmitInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkCommandBufferSubmitInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSubmitInfo2(extensions: *const Extensions, item: *const vk.VkSubmitInfo2, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkSubmitFlags(extensions, &item.flags))
        return false;
    if (item.pWaitSemaphoreInfos) |v| {
        for (v[0..item.waitSemaphoreInfoCount]) |*vv| {
            if (!validate_VkSemaphoreSubmitInfo(extensions, vv, false))
                return false;
        }
    }
    if (item.pCommandBufferInfos) |v| {
        for (v[0..item.commandBufferInfoCount]) |*vv| {
            if (!validate_VkCommandBufferSubmitInfo(extensions, vv, false))
                return false;
        }
    }
    if (item.pSignalSemaphoreInfos) |v| {
        for (v[0..item.signalSemaphoreInfoCount]) |*vv| {
            if (!validate_VkSemaphoreSubmitInfo(extensions, vv, false))
                return false;
        }
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSubmitInfo2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkQueueFamilyCheckpointProperties2NV(extensions: *const Extensions, item: *const vk.VkQueueFamilyCheckpointProperties2NV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkPipelineStageFlags2(extensions, &item.checkpointExecutionStageMask))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2,
            => if (!validate_VkQueueFamilyProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkQueueFamilyCheckpointProperties2NV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkCheckpointData2NV(extensions: *const Extensions, item: *const vk.VkCheckpointData2NV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkPipelineStageFlags2(extensions, &item.stage))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkCheckpointData2NV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceSynchronization2Features(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceSynchronization2Features, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceSynchronization2Features: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceUnifiedImageLayoutsFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceUnifiedImageLayoutsFeaturesKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceUnifiedImageLayoutsFeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceHostImageCopyFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceHostImageCopyFeatures, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceHostImageCopyFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceHostImageCopyProperties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceHostImageCopyProperties, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (item.pCopySrcLayouts) |v| {
        for (v[0..item.copySrcLayoutCount]) |*vv| {
            if (!validate_VkImageLayout(extensions, vv))
                return false;
        }
    }
    if (item.pCopyDstLayouts) |v| {
        for (v[0..item.copyDstLayoutCount]) |*vv| {
            if (!validate_VkImageLayout(extensions, vv))
                return false;
        }
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceHostImageCopyProperties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkMemoryToImageCopy(extensions: *const Extensions, item: *const vk.VkMemoryToImageCopy, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkImageSubresourceLayers(extensions, &item.imageSubresource, false))
        return false;
    if (!validate_VkOffset3D(extensions, &item.imageOffset, false))
        return false;
    if (!validate_VkExtent3D(extensions, &item.imageExtent, false))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMemoryToImageCopy: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImageToMemoryCopy(extensions: *const Extensions, item: *const vk.VkImageToMemoryCopy, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkImageSubresourceLayers(extensions, &item.imageSubresource, false))
        return false;
    if (!validate_VkOffset3D(extensions, &item.imageOffset, false))
        return false;
    if (!validate_VkExtent3D(extensions, &item.imageExtent, false))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImageToMemoryCopy: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkCopyMemoryToImageInfo(extensions: *const Extensions, item: *const vk.VkCopyMemoryToImageInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkHostImageCopyFlags(extensions, &item.flags))
        return false;
    if (!validate_VkImageLayout(extensions, &item.dstImageLayout))
        return false;
    if (item.pRegions) |v| {
        for (v[0..item.regionCount]) |*vv| {
            if (!validate_VkMemoryToImageCopy(extensions, vv, false))
                return false;
        }
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkCopyMemoryToImageInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkCopyImageToMemoryInfo(extensions: *const Extensions, item: *const vk.VkCopyImageToMemoryInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkHostImageCopyFlags(extensions, &item.flags))
        return false;
    if (!validate_VkImageLayout(extensions, &item.srcImageLayout))
        return false;
    if (item.pRegions) |v| {
        for (v[0..item.regionCount]) |*vv| {
            if (!validate_VkImageToMemoryCopy(extensions, vv, false))
                return false;
        }
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkCopyImageToMemoryInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkCopyImageToImageInfo(extensions: *const Extensions, item: *const vk.VkCopyImageToImageInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkHostImageCopyFlags(extensions, &item.flags))
        return false;
    if (!validate_VkImageLayout(extensions, &item.srcImageLayout))
        return false;
    if (!validate_VkImageLayout(extensions, &item.dstImageLayout))
        return false;
    if (item.pRegions) |v| {
        for (v[0..item.regionCount]) |*vv| {
            if (!validate_VkImageCopy2(extensions, vv, false))
                return false;
        }
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkCopyImageToImageInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkHostImageLayoutTransitionInfo(extensions: *const Extensions, item: *const vk.VkHostImageLayoutTransitionInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkImageLayout(extensions, &item.oldLayout))
        return false;
    if (!validate_VkImageLayout(extensions, &item.newLayout))
        return false;
    if (!validate_VkImageSubresourceRange(extensions, &item.subresourceRange, false))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkHostImageLayoutTransitionInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSubresourceHostMemcpySize(extensions: *const Extensions, item: *const vk.VkSubresourceHostMemcpySize, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2,
            => if (!validate_VkSubresourceLayout2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSubresourceHostMemcpySize: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkHostImageCopyDevicePerformanceQuery(extensions: *const Extensions, item: *const vk.VkHostImageCopyDevicePerformanceQuery, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2,
            => if (!validate_VkImageFormatProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkHostImageCopyDevicePerformanceQuery: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceVulkanSC10Properties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVulkanSC10Properties, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceVulkanSC10Properties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPipelinePoolSize(extensions: *const Extensions, item: *const vk.VkPipelinePoolSize, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelinePoolSize: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDeviceObjectReservationCreateInfo(extensions: *const Extensions, item: *const vk.VkDeviceObjectReservationCreateInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (item.pPipelineCacheCreateInfos) |v| {
        for (v[0..item.pipelineCacheCreateInfoCount]) |*vv| {
            if (!validate_VkPipelineCacheCreateInfo(extensions, vv, false))
                return false;
        }
    }
    if (item.pPipelinePoolSizes) |v| {
        for (v[0..item.pipelinePoolSizeCount]) |*vv| {
            if (!validate_VkPipelinePoolSize(extensions, vv, false))
                return false;
        }
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDeviceObjectReservationCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkCommandPoolMemoryReservationCreateInfo(extensions: *const Extensions, item: *const vk.VkCommandPoolMemoryReservationCreateInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO,
            => if (!validate_VkCommandPoolCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkCommandPoolMemoryReservationCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkCommandPoolMemoryConsumption(extensions: *const Extensions, item: *const vk.VkCommandPoolMemoryConsumption, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkCommandPoolMemoryConsumption: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceVulkanSC10Features(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVulkanSC10Features, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceVulkanSC10Features: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceLegacyDitheringFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceLegacyDitheringFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceLegacyDitheringFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSurfaceCapabilitiesPresentId2KHR(extensions: *const Extensions, item: *const vk.VkSurfaceCapabilitiesPresentId2KHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR,
            => if (!validate_VkSurfaceCapabilities2KHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSurfaceCapabilitiesPresentId2KHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSurfaceCapabilitiesPresentWait2KHR(extensions: *const Extensions, item: *const vk.VkSurfaceCapabilitiesPresentWait2KHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR,
            => if (!validate_VkSurfaceCapabilities2KHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSurfaceCapabilitiesPresentWait2KHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSubpassResolvePerformanceQueryEXT(extensions: *const Extensions, item: *const vk.VkSubpassResolvePerformanceQueryEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2,
            => if (!validate_VkFormatProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSubpassResolvePerformanceQueryEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkMultisampledRenderToSingleSampledInfoEXT(extensions: *const Extensions, item: *const vk.VkMultisampledRenderToSingleSampledInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkSampleCountFlags(extensions, &item.rasterizationSamples))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2,
            => if (!validate_VkSubpassDescription2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_RENDERING_INFO,
            => if (!validate_VkRenderingInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMultisampledRenderToSingleSampledInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDevicePipelineProtectedAccessFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePipelineProtectedAccessFeatures, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDevicePipelineProtectedAccessFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkQueueFamilyVideoPropertiesKHR(extensions: *const Extensions, item: *const vk.VkQueueFamilyVideoPropertiesKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkVideoCodecOperationFlagsKHR(extensions, &item.videoCodecOperations))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2,
            => if (!validate_VkQueueFamilyProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkQueueFamilyVideoPropertiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkQueueFamilyQueryResultStatusPropertiesKHR(extensions: *const Extensions, item: *const vk.VkQueueFamilyQueryResultStatusPropertiesKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2,
            => if (!validate_VkQueueFamilyProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkQueueFamilyQueryResultStatusPropertiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoProfileListInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoProfileListInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (item.pProfiles) |v| {
        for (v[0..item.profileCount]) |*vv| {
            if (!validate_VkVideoProfileInfoKHR(extensions, vv, false))
                return false;
        }
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2,
            => if (!validate_VkPhysicalDeviceImageFormatInfo2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_FORMAT_INFO_KHR,
            => if (!validate_VkPhysicalDeviceVideoFormatInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO,
            => if (!validate_VkImageCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO,
            => if (!validate_VkBufferCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoProfileListInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceVideoFormatInfoKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVideoFormatInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkImageUsageFlags(extensions, &item.imageUsage))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceVideoFormatInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoFormatPropertiesKHR(extensions: *const Extensions, item: *const vk.VkVideoFormatPropertiesKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkFormat(extensions, &item.format))
        return false;
    if (!validate_VkComponentMapping(extensions, &item.componentMapping, false))
        return false;
    if (!validate_VkImageCreateFlags(extensions, &item.imageCreateFlags))
        return false;
    if (!validate_VkImageType(extensions, &item.imageType))
        return false;
    if (!validate_VkImageTiling(extensions, &item.imageTiling))
        return false;
    if (!validate_VkImageUsageFlags(extensions, &item.imageUsageFlags))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoFormatPropertiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeQuantizationMapCapabilitiesKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeQuantizationMapCapabilitiesKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkExtent2D(extensions, &item.maxQuantizationMapExtent, false))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_VIDEO_CAPABILITIES_KHR,
            => if (!validate_VkVideoCapabilitiesKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeQuantizationMapCapabilitiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeH264QuantizationMapCapabilitiesKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH264QuantizationMapCapabilitiesKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_VIDEO_CAPABILITIES_KHR,
            => if (!validate_VkVideoCapabilitiesKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeH264QuantizationMapCapabilitiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeH265QuantizationMapCapabilitiesKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH265QuantizationMapCapabilitiesKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_VIDEO_CAPABILITIES_KHR,
            => if (!validate_VkVideoCapabilitiesKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeH265QuantizationMapCapabilitiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeAV1QuantizationMapCapabilitiesKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeAV1QuantizationMapCapabilitiesKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_VIDEO_CAPABILITIES_KHR,
            => if (!validate_VkVideoCapabilitiesKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeAV1QuantizationMapCapabilitiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoFormatQuantizationMapPropertiesKHR(extensions: *const Extensions, item: *const vk.VkVideoFormatQuantizationMapPropertiesKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkExtent2D(extensions, &item.quantizationMapTexelSize, false))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_VIDEO_FORMAT_PROPERTIES_KHR,
            => if (!validate_VkVideoFormatPropertiesKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoFormatQuantizationMapPropertiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoFormatH265QuantizationMapPropertiesKHR(extensions: *const Extensions, item: *const vk.VkVideoFormatH265QuantizationMapPropertiesKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkVideoEncodeH265CtbSizeFlagsKHR(extensions, &item.compatibleCtbSizes))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_VIDEO_FORMAT_PROPERTIES_KHR,
            => if (!validate_VkVideoFormatPropertiesKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoFormatH265QuantizationMapPropertiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoFormatAV1QuantizationMapPropertiesKHR(extensions: *const Extensions, item: *const vk.VkVideoFormatAV1QuantizationMapPropertiesKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkVideoEncodeAV1SuperblockSizeFlagsKHR(extensions, &item.compatibleSuperblockSizes))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_VIDEO_FORMAT_PROPERTIES_KHR,
            => if (!validate_VkVideoFormatPropertiesKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoFormatAV1QuantizationMapPropertiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoProfileInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoProfileInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkVideoCodecOperationFlagsKHR(extensions, &item.videoCodecOperation))
        return false;
    if (!validate_VkVideoChromaSubsamplingFlagsKHR(extensions, &item.chromaSubsampling))
        return false;
    if (!validate_VkVideoComponentBitDepthFlagsKHR(extensions, &item.lumaBitDepth))
        return false;
    if (!validate_VkVideoComponentBitDepthFlagsKHR(extensions, &item.chromaBitDepth))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO,
            => if (!validate_VkQueryPoolCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoProfileInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoCapabilitiesKHR(extensions: *const Extensions, item: *const vk.VkVideoCapabilitiesKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkVideoCapabilityFlagsKHR(extensions, &item.flags))
        return false;
    if (!validate_VkExtent2D(extensions, &item.pictureAccessGranularity, false))
        return false;
    if (!validate_VkExtent2D(extensions, &item.minCodedExtent, false))
        return false;
    if (!validate_VkExtent2D(extensions, &item.maxCodedExtent, false))
        return false;
    if (!validate_VkExtensionProperties(extensions, &item.stdHeaderVersion, false))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoCapabilitiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoSessionMemoryRequirementsKHR(extensions: *const Extensions, item: *const vk.VkVideoSessionMemoryRequirementsKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkMemoryRequirements(extensions, &item.memoryRequirements, false))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoSessionMemoryRequirementsKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkBindVideoSessionMemoryInfoKHR(extensions: *const Extensions, item: *const vk.VkBindVideoSessionMemoryInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkBindVideoSessionMemoryInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoPictureResourceInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoPictureResourceInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkOffset2D(extensions, &item.codedOffset, false))
        return false;
    if (!validate_VkExtent2D(extensions, &item.codedExtent, false))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoPictureResourceInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoReferenceSlotInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoReferenceSlotInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (item.pPictureResource) |v| {
        if (!validate_VkVideoPictureResourceInfoKHR(extensions, v, false))
            return false;
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoReferenceSlotInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoDecodeCapabilitiesKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeCapabilitiesKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkVideoDecodeCapabilityFlagsKHR(extensions, &item.flags))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_VIDEO_CAPABILITIES_KHR,
            => if (!validate_VkVideoCapabilitiesKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoDecodeCapabilitiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoDecodeUsageInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeUsageInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkVideoDecodeUsageFlagsKHR(extensions, &item.videoUsageHints))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_VIDEO_PROFILE_INFO_KHR,
            => if (!validate_VkVideoProfileInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO,
            => if (!validate_VkQueryPoolCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoDecodeUsageInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoDecodeInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkVideoDecodeFlagsKHR(extensions, &item.flags))
        return false;
    if (!validate_VkVideoPictureResourceInfoKHR(extensions, &item.dstPictureResource, false))
        return false;
    if (item.pSetupReferenceSlot) |v| {
        if (!validate_VkVideoReferenceSlotInfoKHR(extensions, v, false))
            return false;
    }
    if (item.pReferenceSlots) |v| {
        for (v[0..item.referenceSlotCount]) |*vv| {
            if (!validate_VkVideoReferenceSlotInfoKHR(extensions, vv, false))
                return false;
        }
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoDecodeInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceVideoMaintenance1FeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVideoMaintenance1FeaturesKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceVideoMaintenance1FeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceVideoMaintenance2FeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVideoMaintenance2FeaturesKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceVideoMaintenance2FeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoInlineQueryInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoInlineQueryInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_VIDEO_DECODE_INFO_KHR,
            => if (!validate_VkVideoDecodeInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_INFO_KHR,
            => if (!validate_VkVideoEncodeInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoInlineQueryInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoDecodeH264ProfileInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeH264ProfileInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkVideoDecodeH264PictureLayoutFlagsKHR(extensions, &item.pictureLayout))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_VIDEO_PROFILE_INFO_KHR,
            => if (!validate_VkVideoProfileInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO,
            => if (!validate_VkQueryPoolCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoDecodeH264ProfileInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoDecodeH264CapabilitiesKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeH264CapabilitiesKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkOffset2D(extensions, &item.fieldOffsetGranularity, false))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_VIDEO_CAPABILITIES_KHR,
            => if (!validate_VkVideoCapabilitiesKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoDecodeH264CapabilitiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoDecodeH264SessionParametersAddInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeH264SessionParametersAddInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_UPDATE_INFO_KHR,
            => if (!validate_VkVideoSessionParametersUpdateInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoDecodeH264SessionParametersAddInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoDecodeH264SessionParametersCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeH264SessionParametersCreateInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (item.pParametersAddInfo) |v| {
        if (!validate_VkVideoDecodeH264SessionParametersAddInfoKHR(extensions, v, false))
            return false;
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_CREATE_INFO_KHR,
            => if (!validate_VkVideoSessionParametersCreateInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoDecodeH264SessionParametersCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoDecodeH264InlineSessionParametersInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeH264InlineSessionParametersInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_VIDEO_DECODE_INFO_KHR,
            => if (!validate_VkVideoDecodeInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoDecodeH264InlineSessionParametersInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoDecodeH264PictureInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeH264PictureInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_VIDEO_DECODE_INFO_KHR,
            => if (!validate_VkVideoDecodeInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoDecodeH264PictureInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoDecodeH264DpbSlotInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeH264DpbSlotInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_VIDEO_REFERENCE_SLOT_INFO_KHR,
            => if (!validate_VkVideoReferenceSlotInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoDecodeH264DpbSlotInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoDecodeH265ProfileInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeH265ProfileInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_VIDEO_PROFILE_INFO_KHR,
            => if (!validate_VkVideoProfileInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO,
            => if (!validate_VkQueryPoolCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoDecodeH265ProfileInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoDecodeH265CapabilitiesKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeH265CapabilitiesKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_VIDEO_CAPABILITIES_KHR,
            => if (!validate_VkVideoCapabilitiesKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoDecodeH265CapabilitiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoDecodeH265SessionParametersAddInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeH265SessionParametersAddInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_UPDATE_INFO_KHR,
            => if (!validate_VkVideoSessionParametersUpdateInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoDecodeH265SessionParametersAddInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoDecodeH265SessionParametersCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeH265SessionParametersCreateInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (item.pParametersAddInfo) |v| {
        if (!validate_VkVideoDecodeH265SessionParametersAddInfoKHR(extensions, v, false))
            return false;
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_CREATE_INFO_KHR,
            => if (!validate_VkVideoSessionParametersCreateInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoDecodeH265SessionParametersCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoDecodeH265InlineSessionParametersInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeH265InlineSessionParametersInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_VIDEO_DECODE_INFO_KHR,
            => if (!validate_VkVideoDecodeInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoDecodeH265InlineSessionParametersInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoDecodeH265PictureInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeH265PictureInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_VIDEO_DECODE_INFO_KHR,
            => if (!validate_VkVideoDecodeInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoDecodeH265PictureInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoDecodeH265DpbSlotInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeH265DpbSlotInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_VIDEO_REFERENCE_SLOT_INFO_KHR,
            => if (!validate_VkVideoReferenceSlotInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoDecodeH265DpbSlotInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceVideoDecodeVP9FeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVideoDecodeVP9FeaturesKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceVideoDecodeVP9FeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoDecodeVP9ProfileInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeVP9ProfileInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_VIDEO_PROFILE_INFO_KHR,
            => if (!validate_VkVideoProfileInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO,
            => if (!validate_VkQueryPoolCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoDecodeVP9ProfileInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoDecodeVP9CapabilitiesKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeVP9CapabilitiesKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_VIDEO_CAPABILITIES_KHR,
            => if (!validate_VkVideoCapabilitiesKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoDecodeVP9CapabilitiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoDecodeVP9PictureInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeVP9PictureInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_VIDEO_DECODE_INFO_KHR,
            => if (!validate_VkVideoDecodeInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoDecodeVP9PictureInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoDecodeAV1ProfileInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeAV1ProfileInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_VIDEO_PROFILE_INFO_KHR,
            => if (!validate_VkVideoProfileInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO,
            => if (!validate_VkQueryPoolCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoDecodeAV1ProfileInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoDecodeAV1CapabilitiesKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeAV1CapabilitiesKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_VIDEO_CAPABILITIES_KHR,
            => if (!validate_VkVideoCapabilitiesKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoDecodeAV1CapabilitiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoDecodeAV1SessionParametersCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeAV1SessionParametersCreateInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_CREATE_INFO_KHR,
            => if (!validate_VkVideoSessionParametersCreateInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoDecodeAV1SessionParametersCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoDecodeAV1InlineSessionParametersInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeAV1InlineSessionParametersInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_VIDEO_DECODE_INFO_KHR,
            => if (!validate_VkVideoDecodeInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoDecodeAV1InlineSessionParametersInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoDecodeAV1PictureInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeAV1PictureInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_VIDEO_DECODE_INFO_KHR,
            => if (!validate_VkVideoDecodeInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoDecodeAV1PictureInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoDecodeAV1DpbSlotInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeAV1DpbSlotInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_VIDEO_REFERENCE_SLOT_INFO_KHR,
            => if (!validate_VkVideoReferenceSlotInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoDecodeAV1DpbSlotInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoSessionCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoSessionCreateInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkVideoSessionCreateFlagsKHR(extensions, &item.flags))
        return false;
    if (item.pVideoProfile) |v| {
        if (!validate_VkVideoProfileInfoKHR(extensions, v, false))
            return false;
    }
    if (!validate_VkFormat(extensions, &item.pictureFormat))
        return false;
    if (!validate_VkExtent2D(extensions, &item.maxCodedExtent, false))
        return false;
    if (!validate_VkFormat(extensions, &item.referencePictureFormat))
        return false;
    if (item.pStdHeaderVersion) |v| {
        if (!validate_VkExtensionProperties(extensions, v, false))
            return false;
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoSessionCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoSessionParametersCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoSessionParametersCreateInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkVideoSessionParametersCreateFlagsKHR(extensions, &item.flags))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoSessionParametersCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoSessionParametersUpdateInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoSessionParametersUpdateInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoSessionParametersUpdateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeSessionParametersGetInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeSessionParametersGetInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeSessionParametersGetInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeSessionParametersFeedbackInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeSessionParametersFeedbackInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeSessionParametersFeedbackInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoBeginCodingInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoBeginCodingInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkVideoBeginCodingFlagsKHR(extensions, &item.flags))
        return false;
    if (item.pReferenceSlots) |v| {
        for (v[0..item.referenceSlotCount]) |*vv| {
            if (!validate_VkVideoReferenceSlotInfoKHR(extensions, vv, false))
                return false;
        }
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoBeginCodingInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEndCodingInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEndCodingInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkVideoEndCodingFlagsKHR(extensions, &item.flags))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEndCodingInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoCodingControlInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoCodingControlInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkVideoCodingControlFlagsKHR(extensions, &item.flags))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoCodingControlInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeUsageInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeUsageInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkVideoEncodeUsageFlagsKHR(extensions, &item.videoUsageHints))
        return false;
    if (!validate_VkVideoEncodeContentFlagsKHR(extensions, &item.videoContentHints))
        return false;
    if (!validate_VkVideoEncodeTuningModeKHR(extensions, &item.tuningMode))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_VIDEO_PROFILE_INFO_KHR,
            => if (!validate_VkVideoProfileInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO,
            => if (!validate_VkQueryPoolCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeUsageInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkVideoEncodeFlagsKHR(extensions, &item.flags))
        return false;
    if (!validate_VkVideoPictureResourceInfoKHR(extensions, &item.srcPictureResource, false))
        return false;
    if (item.pSetupReferenceSlot) |v| {
        if (!validate_VkVideoReferenceSlotInfoKHR(extensions, v, false))
            return false;
    }
    if (item.pReferenceSlots) |v| {
        for (v[0..item.referenceSlotCount]) |*vv| {
            if (!validate_VkVideoReferenceSlotInfoKHR(extensions, vv, false))
                return false;
        }
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeQuantizationMapInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeQuantizationMapInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkExtent2D(extensions, &item.quantizationMapExtent, false))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_INFO_KHR,
            => if (!validate_VkVideoEncodeInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeQuantizationMapInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkExtent2D(extensions, &item.quantizationMapTexelSize, false))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_CREATE_INFO_KHR,
            => if (!validate_VkVideoSessionParametersCreateInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkQueryPoolVideoEncodeFeedbackCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkQueryPoolVideoEncodeFeedbackCreateInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkVideoEncodeFeedbackFlagsKHR(extensions, &item.encodeFeedbackFlags))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO,
            => if (!validate_VkQueryPoolCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkQueryPoolVideoEncodeFeedbackCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeQualityLevelInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeQualityLevelInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_VIDEO_CODING_CONTROL_INFO_KHR,
            => if (!validate_VkVideoCodingControlInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_CREATE_INFO_KHR,
            => if (!validate_VkVideoSessionParametersCreateInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeQualityLevelInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (item.pVideoProfile) |v| {
        if (!validate_VkVideoProfileInfoKHR(extensions, v, false))
            return false;
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeQualityLevelPropertiesKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeQualityLevelPropertiesKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkVideoEncodeRateControlModeFlagsKHR(extensions, &item.preferredRateControlMode))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeQualityLevelPropertiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeRateControlInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeRateControlInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkVideoEncodeRateControlFlagsKHR(extensions, &item.flags))
        return false;
    if (!validate_VkVideoEncodeRateControlModeFlagsKHR(extensions, &item.rateControlMode))
        return false;
    if (item.pLayers) |v| {
        for (v[0..item.layerCount]) |*vv| {
            if (!validate_VkVideoEncodeRateControlLayerInfoKHR(extensions, vv, false))
                return false;
        }
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_VIDEO_CODING_CONTROL_INFO_KHR,
            => if (!validate_VkVideoCodingControlInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_VIDEO_BEGIN_CODING_INFO_KHR,
            => if (!validate_VkVideoBeginCodingInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeRateControlInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeRateControlLayerInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeRateControlLayerInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeRateControlLayerInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeCapabilitiesKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeCapabilitiesKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkVideoEncodeCapabilityFlagsKHR(extensions, &item.flags))
        return false;
    if (!validate_VkVideoEncodeRateControlModeFlagsKHR(extensions, &item.rateControlModes))
        return false;
    if (!validate_VkExtent2D(extensions, &item.encodeInputPictureGranularity, false))
        return false;
    if (!validate_VkVideoEncodeFeedbackFlagsKHR(extensions, &item.supportedEncodeFeedbackFlags))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_VIDEO_CAPABILITIES_KHR,
            => if (!validate_VkVideoCapabilitiesKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeCapabilitiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeH264CapabilitiesKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH264CapabilitiesKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkVideoEncodeH264CapabilityFlagsKHR(extensions, &item.flags))
        return false;
    if (!validate_VkVideoEncodeH264StdFlagsKHR(extensions, &item.stdSyntaxFlags))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_VIDEO_CAPABILITIES_KHR,
            => if (!validate_VkVideoCapabilitiesKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeH264CapabilitiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeH264QualityLevelPropertiesKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH264QualityLevelPropertiesKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkVideoEncodeH264RateControlFlagsKHR(extensions, &item.preferredRateControlFlags))
        return false;
    if (!validate_VkVideoEncodeH264QpKHR(extensions, &item.preferredConstantQp, false))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_PROPERTIES_KHR,
            => if (!validate_VkVideoEncodeQualityLevelPropertiesKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeH264QualityLevelPropertiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeH264SessionCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH264SessionCreateInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_VIDEO_SESSION_CREATE_INFO_KHR,
            => if (!validate_VkVideoSessionCreateInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeH264SessionCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeH264SessionParametersAddInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH264SessionParametersAddInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_UPDATE_INFO_KHR,
            => if (!validate_VkVideoSessionParametersUpdateInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeH264SessionParametersAddInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeH264SessionParametersCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH264SessionParametersCreateInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (item.pParametersAddInfo) |v| {
        if (!validate_VkVideoEncodeH264SessionParametersAddInfoKHR(extensions, v, false))
            return false;
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_CREATE_INFO_KHR,
            => if (!validate_VkVideoSessionParametersCreateInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeH264SessionParametersCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeH264SessionParametersGetInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH264SessionParametersGetInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_GET_INFO_KHR,
            => if (!validate_VkVideoEncodeSessionParametersGetInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeH264SessionParametersGetInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeH264SessionParametersFeedbackInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH264SessionParametersFeedbackInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_FEEDBACK_INFO_KHR,
            => if (!validate_VkVideoEncodeSessionParametersFeedbackInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeH264SessionParametersFeedbackInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeH264DpbSlotInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH264DpbSlotInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_VIDEO_REFERENCE_SLOT_INFO_KHR,
            => if (!validate_VkVideoReferenceSlotInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeH264DpbSlotInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeH264PictureInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH264PictureInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (item.pNaluSliceEntries) |v| {
        for (v[0..item.naluSliceEntryCount]) |*vv| {
            if (!validate_VkVideoEncodeH264NaluSliceInfoKHR(extensions, vv, false))
                return false;
        }
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_INFO_KHR,
            => if (!validate_VkVideoEncodeInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeH264PictureInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeH264ProfileInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH264ProfileInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_VIDEO_PROFILE_INFO_KHR,
            => if (!validate_VkVideoProfileInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO,
            => if (!validate_VkQueryPoolCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeH264ProfileInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeH264NaluSliceInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH264NaluSliceInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeH264NaluSliceInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeH264RateControlInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH264RateControlInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkVideoEncodeH264RateControlFlagsKHR(extensions, &item.flags))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_VIDEO_CODING_CONTROL_INFO_KHR,
            => if (!validate_VkVideoCodingControlInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_VIDEO_BEGIN_CODING_INFO_KHR,
            => if (!validate_VkVideoBeginCodingInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeH264RateControlInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeH264QpKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH264QpKHR, validate_pnext: bool) bool {
    _ = item;
    _ = extensions;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkVideoEncodeH264FrameSizeKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH264FrameSizeKHR, validate_pnext: bool) bool {
    _ = item;
    _ = extensions;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkVideoEncodeH264GopRemainingFrameInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH264GopRemainingFrameInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_VIDEO_BEGIN_CODING_INFO_KHR,
            => if (!validate_VkVideoBeginCodingInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeH264GopRemainingFrameInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeH264RateControlLayerInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH264RateControlLayerInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkVideoEncodeH264QpKHR(extensions, &item.minQp, false))
        return false;
    if (!validate_VkVideoEncodeH264QpKHR(extensions, &item.maxQp, false))
        return false;
    if (!validate_VkVideoEncodeH264FrameSizeKHR(extensions, &item.maxFrameSize, false))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_LAYER_INFO_KHR,
            => if (!validate_VkVideoEncodeRateControlLayerInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeH264RateControlLayerInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeH265CapabilitiesKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH265CapabilitiesKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkVideoEncodeH265CapabilityFlagsKHR(extensions, &item.flags))
        return false;
    if (!validate_VkExtent2D(extensions, &item.maxTiles, false))
        return false;
    if (!validate_VkVideoEncodeH265CtbSizeFlagsKHR(extensions, &item.ctbSizes))
        return false;
    if (!validate_VkVideoEncodeH265TransformBlockSizeFlagsKHR(extensions, &item.transformBlockSizes))
        return false;
    if (!validate_VkVideoEncodeH265StdFlagsKHR(extensions, &item.stdSyntaxFlags))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_VIDEO_CAPABILITIES_KHR,
            => if (!validate_VkVideoCapabilitiesKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeH265CapabilitiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeH265QualityLevelPropertiesKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH265QualityLevelPropertiesKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkVideoEncodeH265RateControlFlagsKHR(extensions, &item.preferredRateControlFlags))
        return false;
    if (!validate_VkVideoEncodeH265QpKHR(extensions, &item.preferredConstantQp, false))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_PROPERTIES_KHR,
            => if (!validate_VkVideoEncodeQualityLevelPropertiesKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeH265QualityLevelPropertiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeH265SessionCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH265SessionCreateInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_VIDEO_SESSION_CREATE_INFO_KHR,
            => if (!validate_VkVideoSessionCreateInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeH265SessionCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeH265SessionParametersAddInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH265SessionParametersAddInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_UPDATE_INFO_KHR,
            => if (!validate_VkVideoSessionParametersUpdateInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeH265SessionParametersAddInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeH265SessionParametersCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH265SessionParametersCreateInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (item.pParametersAddInfo) |v| {
        if (!validate_VkVideoEncodeH265SessionParametersAddInfoKHR(extensions, v, false))
            return false;
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_CREATE_INFO_KHR,
            => if (!validate_VkVideoSessionParametersCreateInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeH265SessionParametersCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeH265SessionParametersGetInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH265SessionParametersGetInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_GET_INFO_KHR,
            => if (!validate_VkVideoEncodeSessionParametersGetInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeH265SessionParametersGetInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeH265SessionParametersFeedbackInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH265SessionParametersFeedbackInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_FEEDBACK_INFO_KHR,
            => if (!validate_VkVideoEncodeSessionParametersFeedbackInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeH265SessionParametersFeedbackInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeH265PictureInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH265PictureInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (item.pNaluSliceSegmentEntries) |v| {
        for (v[0..item.naluSliceSegmentEntryCount]) |*vv| {
            if (!validate_VkVideoEncodeH265NaluSliceSegmentInfoKHR(extensions, vv, false))
                return false;
        }
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_INFO_KHR,
            => if (!validate_VkVideoEncodeInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeH265PictureInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeH265NaluSliceSegmentInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH265NaluSliceSegmentInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeH265NaluSliceSegmentInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeH265RateControlInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH265RateControlInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkVideoEncodeH265RateControlFlagsKHR(extensions, &item.flags))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_VIDEO_CODING_CONTROL_INFO_KHR,
            => if (!validate_VkVideoCodingControlInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_VIDEO_BEGIN_CODING_INFO_KHR,
            => if (!validate_VkVideoBeginCodingInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeH265RateControlInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeH265QpKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH265QpKHR, validate_pnext: bool) bool {
    _ = item;
    _ = extensions;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkVideoEncodeH265FrameSizeKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH265FrameSizeKHR, validate_pnext: bool) bool {
    _ = item;
    _ = extensions;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkVideoEncodeH265GopRemainingFrameInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH265GopRemainingFrameInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_VIDEO_BEGIN_CODING_INFO_KHR,
            => if (!validate_VkVideoBeginCodingInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeH265GopRemainingFrameInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeH265RateControlLayerInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH265RateControlLayerInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkVideoEncodeH265QpKHR(extensions, &item.minQp, false))
        return false;
    if (!validate_VkVideoEncodeH265QpKHR(extensions, &item.maxQp, false))
        return false;
    if (!validate_VkVideoEncodeH265FrameSizeKHR(extensions, &item.maxFrameSize, false))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_LAYER_INFO_KHR,
            => if (!validate_VkVideoEncodeRateControlLayerInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeH265RateControlLayerInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeH265ProfileInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH265ProfileInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_VIDEO_PROFILE_INFO_KHR,
            => if (!validate_VkVideoProfileInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO,
            => if (!validate_VkQueryPoolCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeH265ProfileInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeH265DpbSlotInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH265DpbSlotInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_VIDEO_REFERENCE_SLOT_INFO_KHR,
            => if (!validate_VkVideoReferenceSlotInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeH265DpbSlotInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeAV1CapabilitiesKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeAV1CapabilitiesKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkVideoEncodeAV1CapabilityFlagsKHR(extensions, &item.flags))
        return false;
    if (!validate_VkExtent2D(extensions, &item.codedPictureAlignment, false))
        return false;
    if (!validate_VkExtent2D(extensions, &item.maxTiles, false))
        return false;
    if (!validate_VkExtent2D(extensions, &item.minTileSize, false))
        return false;
    if (!validate_VkExtent2D(extensions, &item.maxTileSize, false))
        return false;
    if (!validate_VkVideoEncodeAV1SuperblockSizeFlagsKHR(extensions, &item.superblockSizes))
        return false;
    if (!validate_VkVideoEncodeAV1StdFlagsKHR(extensions, &item.stdSyntaxFlags))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_VIDEO_CAPABILITIES_KHR,
            => if (!validate_VkVideoCapabilitiesKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeAV1CapabilitiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeAV1QualityLevelPropertiesKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeAV1QualityLevelPropertiesKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkVideoEncodeAV1RateControlFlagsKHR(extensions, &item.preferredRateControlFlags))
        return false;
    if (!validate_VkVideoEncodeAV1QIndexKHR(extensions, &item.preferredConstantQIndex, false))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_PROPERTIES_KHR,
            => if (!validate_VkVideoEncodeQualityLevelPropertiesKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeAV1QualityLevelPropertiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceVideoEncodeAV1FeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVideoEncodeAV1FeaturesKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceVideoEncodeAV1FeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeAV1SessionCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeAV1SessionCreateInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_VIDEO_SESSION_CREATE_INFO_KHR,
            => if (!validate_VkVideoSessionCreateInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeAV1SessionCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeAV1SessionParametersCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeAV1SessionParametersCreateInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_CREATE_INFO_KHR,
            => if (!validate_VkVideoSessionParametersCreateInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeAV1SessionParametersCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeAV1DpbSlotInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeAV1DpbSlotInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_VIDEO_REFERENCE_SLOT_INFO_KHR,
            => if (!validate_VkVideoReferenceSlotInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeAV1DpbSlotInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeAV1PictureInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeAV1PictureInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkVideoEncodeAV1PredictionModeKHR(extensions, &item.predictionMode))
        return false;
    if (!validate_VkVideoEncodeAV1RateControlGroupKHR(extensions, &item.rateControlGroup))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_INFO_KHR,
            => if (!validate_VkVideoEncodeInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeAV1PictureInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeAV1ProfileInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeAV1ProfileInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_VIDEO_PROFILE_INFO_KHR,
            => if (!validate_VkVideoProfileInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO,
            => if (!validate_VkQueryPoolCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeAV1ProfileInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeAV1RateControlInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeAV1RateControlInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkVideoEncodeAV1RateControlFlagsKHR(extensions, &item.flags))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_VIDEO_CODING_CONTROL_INFO_KHR,
            => if (!validate_VkVideoCodingControlInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_VIDEO_BEGIN_CODING_INFO_KHR,
            => if (!validate_VkVideoBeginCodingInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeAV1RateControlInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeAV1QIndexKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeAV1QIndexKHR, validate_pnext: bool) bool {
    _ = item;
    _ = extensions;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkVideoEncodeAV1FrameSizeKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeAV1FrameSizeKHR, validate_pnext: bool) bool {
    _ = item;
    _ = extensions;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkVideoEncodeAV1GopRemainingFrameInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeAV1GopRemainingFrameInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_VIDEO_BEGIN_CODING_INFO_KHR,
            => if (!validate_VkVideoBeginCodingInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeAV1GopRemainingFrameInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeAV1RateControlLayerInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeAV1RateControlLayerInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkVideoEncodeAV1QIndexKHR(extensions, &item.minQIndex, false))
        return false;
    if (!validate_VkVideoEncodeAV1QIndexKHR(extensions, &item.maxQIndex, false))
        return false;
    if (!validate_VkVideoEncodeAV1FrameSizeKHR(extensions, &item.maxFrameSize, false))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_LAYER_INFO_KHR,
            => if (!validate_VkVideoEncodeRateControlLayerInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeAV1RateControlLayerInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceInheritedViewportScissorFeaturesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceInheritedViewportScissorFeaturesNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceInheritedViewportScissorFeaturesNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkCommandBufferInheritanceViewportScissorInfoNV(extensions: *const Extensions, item: *const vk.VkCommandBufferInheritanceViewportScissorInfoNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (item.pViewportDepths) |v| {
        if (!validate_VkViewport(extensions, v, false))
            return false;
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO,
            => if (!validate_VkCommandBufferInheritanceInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkCommandBufferInheritanceViewportScissorInfoNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceProvokingVertexFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceProvokingVertexFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceProvokingVertexFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceProvokingVertexPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceProvokingVertexPropertiesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceProvokingVertexPropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPipelineRasterizationProvokingVertexStateCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkPipelineRasterizationProvokingVertexStateCreateInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkProvokingVertexModeEXT(extensions, &item.provokingVertexMode))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO,
            => if (!validate_VkPipelineRasterizationStateCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineRasterizationProvokingVertexStateCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeIntraRefreshCapabilitiesKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeIntraRefreshCapabilitiesKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkVideoEncodeIntraRefreshModeFlagsKHR(extensions, &item.intraRefreshModes))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_VIDEO_CAPABILITIES_KHR,
            => if (!validate_VkVideoCapabilitiesKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeIntraRefreshCapabilitiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeSessionIntraRefreshCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeSessionIntraRefreshCreateInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkVideoEncodeIntraRefreshModeFlagsKHR(extensions, &item.intraRefreshMode))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_VIDEO_SESSION_CREATE_INFO_KHR,
            => if (!validate_VkVideoSessionCreateInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeSessionIntraRefreshCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeIntraRefreshInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeIntraRefreshInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_VIDEO_ENCODE_INFO_KHR,
            => if (!validate_VkVideoEncodeInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeIntraRefreshInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoReferenceIntraRefreshInfoKHR(extensions: *const Extensions, item: *const vk.VkVideoReferenceIntraRefreshInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_VIDEO_REFERENCE_SLOT_INFO_KHR,
            => if (!validate_VkVideoReferenceSlotInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoReferenceIntraRefreshInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkCuModuleCreateInfoNVX(extensions: *const Extensions, item: *const vk.VkCuModuleCreateInfoNVX, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkCuModuleCreateInfoNVX: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkCuModuleTexturingModeCreateInfoNVX(extensions: *const Extensions, item: *const vk.VkCuModuleTexturingModeCreateInfoNVX, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_CU_MODULE_CREATE_INFO_NVX,
            => if (!validate_VkCuModuleCreateInfoNVX(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkCuModuleTexturingModeCreateInfoNVX: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkCuFunctionCreateInfoNVX(extensions: *const Extensions, item: *const vk.VkCuFunctionCreateInfoNVX, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkCuFunctionCreateInfoNVX: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkCuLaunchInfoNVX(extensions: *const Extensions, item: *const vk.VkCuLaunchInfoNVX, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkCuLaunchInfoNVX: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceDescriptorBufferFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDescriptorBufferFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceDescriptorBufferFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceDescriptorBufferPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDescriptorBufferPropertiesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceDescriptorBufferPropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDescriptorAddressInfoEXT(extensions: *const Extensions, item: *const vk.VkDescriptorAddressInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkFormat(extensions, &item.format))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDescriptorAddressInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDescriptorBufferBindingInfoEXT(extensions: *const Extensions, item: *const vk.VkDescriptorBufferBindingInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkBufferUsageFlags(extensions, &item.usage))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDescriptorBufferBindingInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDescriptorBufferBindingPushDescriptorBufferHandleEXT(extensions: *const Extensions, item: *const vk.VkDescriptorBufferBindingPushDescriptorBufferHandleEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_INFO_EXT,
            => if (!validate_VkDescriptorBufferBindingInfoEXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDescriptorBufferBindingPushDescriptorBufferHandleEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDescriptorGetInfoEXT(extensions: *const Extensions, item: *const vk.VkDescriptorGetInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkDescriptorType(extensions, &item.type))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDescriptorGetInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkBufferCaptureDescriptorDataInfoEXT(extensions: *const Extensions, item: *const vk.VkBufferCaptureDescriptorDataInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkBufferCaptureDescriptorDataInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImageCaptureDescriptorDataInfoEXT(extensions: *const Extensions, item: *const vk.VkImageCaptureDescriptorDataInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImageCaptureDescriptorDataInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImageViewCaptureDescriptorDataInfoEXT(extensions: *const Extensions, item: *const vk.VkImageViewCaptureDescriptorDataInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImageViewCaptureDescriptorDataInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSamplerCaptureDescriptorDataInfoEXT(extensions: *const Extensions, item: *const vk.VkSamplerCaptureDescriptorDataInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSamplerCaptureDescriptorDataInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkAccelerationStructureCaptureDescriptorDataInfoEXT(extensions: *const Extensions, item: *const vk.VkAccelerationStructureCaptureDescriptorDataInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkAccelerationStructureCaptureDescriptorDataInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkOpaqueCaptureDescriptorDataCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkOpaqueCaptureDescriptorDataCreateInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO,
            => if (!validate_VkBufferCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO,
            => if (!validate_VkImageCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO,
            => if (!validate_VkImageViewCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO,
            => if (!validate_VkSamplerCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR,
            => if (!validate_VkAccelerationStructureCreateInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV,
            => if (!validate_VkAccelerationStructureCreateInfoNV(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_TENSOR_CREATE_INFO_ARM,
            => if (!validate_VkTensorCreateInfoARM(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_TENSOR_VIEW_CREATE_INFO_ARM,
            => if (!validate_VkTensorViewCreateInfoARM(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkOpaqueCaptureDescriptorDataCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceShaderIntegerDotProductFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderIntegerDotProductFeatures, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShaderIntegerDotProductFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceShaderIntegerDotProductProperties(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderIntegerDotProductProperties, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShaderIntegerDotProductProperties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceDrmPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDrmPropertiesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceDrmPropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceShaderFmaFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderFmaFeaturesKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShaderFmaFeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceRayTracingMotionBlurFeaturesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceRayTracingMotionBlurFeaturesNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceRayTracingMotionBlurFeaturesNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceRayTracingValidationFeaturesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceRayTracingValidationFeaturesNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceRayTracingValidationFeaturesNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkAccelerationStructureGeometryMotionTrianglesDataNV(extensions: *const Extensions, item: *const vk.VkAccelerationStructureGeometryMotionTrianglesDataNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR,
            => if (!validate_VkAccelerationStructureGeometryTrianglesDataKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkAccelerationStructureGeometryMotionTrianglesDataNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkAccelerationStructureMotionInfoNV(extensions: *const Extensions, item: *const vk.VkAccelerationStructureMotionInfoNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkAccelerationStructureMotionInfoFlagsNV(extensions, &item.flags))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR,
            => if (!validate_VkAccelerationStructureCreateInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkAccelerationStructureMotionInfoNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSRTDataNV(extensions: *const Extensions, item: *const vk.VkSRTDataNV, validate_pnext: bool) bool {
    _ = item;
    _ = extensions;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkAccelerationStructureSRTMotionInstanceNV(extensions: *const Extensions, item: *const vk.VkAccelerationStructureSRTMotionInstanceNV, validate_pnext: bool) bool {
    if (!validate_VkSRTDataNV(extensions, &item.transformT0, false))
        return false;
    if (!validate_VkSRTDataNV(extensions, &item.transformT1, false))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkAccelerationStructureMatrixMotionInstanceNV(extensions: *const Extensions, item: *const vk.VkAccelerationStructureMatrixMotionInstanceNV, validate_pnext: bool) bool {
    if (!validate_VkTransformMatrixKHR(extensions, &item.transformT0, false))
        return false;
    if (!validate_VkTransformMatrixKHR(extensions, &item.transformT1, false))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkAccelerationStructureMotionInstanceNV(extensions: *const Extensions, item: *const vk.VkAccelerationStructureMotionInstanceNV, validate_pnext: bool) bool {
    if (!validate_VkAccelerationStructureMotionInstanceTypeNV(extensions, &item.type))
        return false;
    if (!validate_VkAccelerationStructureMotionInstanceFlagsNV(extensions, &item.flags))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkMemoryGetRemoteAddressInfoNV(extensions: *const Extensions, item: *const vk.VkMemoryGetRemoteAddressInfoNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkExternalMemoryHandleTypeFlags(extensions, &item.handleType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMemoryGetRemoteAddressInfoNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImportMemoryBufferCollectionFUCHSIA(extensions: *const Extensions, item: *const vk.VkImportMemoryBufferCollectionFUCHSIA, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO,
            => if (!validate_VkMemoryAllocateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImportMemoryBufferCollectionFUCHSIA: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkBufferCollectionImageCreateInfoFUCHSIA(extensions: *const Extensions, item: *const vk.VkBufferCollectionImageCreateInfoFUCHSIA, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO,
            => if (!validate_VkImageCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkBufferCollectionImageCreateInfoFUCHSIA: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkBufferCollectionBufferCreateInfoFUCHSIA(extensions: *const Extensions, item: *const vk.VkBufferCollectionBufferCreateInfoFUCHSIA, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO,
            => if (!validate_VkBufferCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkBufferCollectionBufferCreateInfoFUCHSIA: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkBufferCollectionCreateInfoFUCHSIA(extensions: *const Extensions, item: *const vk.VkBufferCollectionCreateInfoFUCHSIA, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkBufferCollectionCreateInfoFUCHSIA: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkBufferCollectionPropertiesFUCHSIA(extensions: *const Extensions, item: *const vk.VkBufferCollectionPropertiesFUCHSIA, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkFormatFeatureFlags(extensions, &item.formatFeatures))
        return false;
    if (!validate_VkSysmemColorSpaceFUCHSIA(extensions, &item.sysmemColorSpaceIndex, false))
        return false;
    if (!validate_VkComponentMapping(extensions, &item.samplerYcbcrConversionComponents, false))
        return false;
    if (!validate_VkSamplerYcbcrModelConversion(extensions, &item.suggestedYcbcrModel))
        return false;
    if (!validate_VkSamplerYcbcrRange(extensions, &item.suggestedYcbcrRange))
        return false;
    if (!validate_VkChromaLocation(extensions, &item.suggestedXChromaOffset))
        return false;
    if (!validate_VkChromaLocation(extensions, &item.suggestedYChromaOffset))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkBufferCollectionPropertiesFUCHSIA: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkBufferConstraintsInfoFUCHSIA(extensions: *const Extensions, item: *const vk.VkBufferConstraintsInfoFUCHSIA, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkBufferCreateInfo(extensions, &item.createInfo, false))
        return false;
    if (!validate_VkFormatFeatureFlags(extensions, &item.requiredFormatFeatures))
        return false;
    if (!validate_VkBufferCollectionConstraintsInfoFUCHSIA(extensions, &item.bufferCollectionConstraints, false))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkBufferConstraintsInfoFUCHSIA: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSysmemColorSpaceFUCHSIA(extensions: *const Extensions, item: *const vk.VkSysmemColorSpaceFUCHSIA, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSysmemColorSpaceFUCHSIA: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImageFormatConstraintsInfoFUCHSIA(extensions: *const Extensions, item: *const vk.VkImageFormatConstraintsInfoFUCHSIA, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkImageCreateInfo(extensions, &item.imageCreateInfo, false))
        return false;
    if (!validate_VkFormatFeatureFlags(extensions, &item.requiredFormatFeatures))
        return false;
    if (!validate_VkImageFormatConstraintsFlagsFUCHSIA(extensions, &item.flags))
        return false;
    if (item.pColorSpaces) |v| {
        for (v[0..item.colorSpaceCount]) |*vv| {
            if (!validate_VkSysmemColorSpaceFUCHSIA(extensions, vv, false))
                return false;
        }
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImageFormatConstraintsInfoFUCHSIA: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImageConstraintsInfoFUCHSIA(extensions: *const Extensions, item: *const vk.VkImageConstraintsInfoFUCHSIA, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (item.pFormatConstraints) |v| {
        for (v[0..item.formatConstraintsCount]) |*vv| {
            if (!validate_VkImageFormatConstraintsInfoFUCHSIA(extensions, vv, false))
                return false;
        }
    }
    if (!validate_VkBufferCollectionConstraintsInfoFUCHSIA(extensions, &item.bufferCollectionConstraints, false))
        return false;
    if (!validate_VkImageConstraintsInfoFlagsFUCHSIA(extensions, &item.flags))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImageConstraintsInfoFUCHSIA: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkBufferCollectionConstraintsInfoFUCHSIA(extensions: *const Extensions, item: *const vk.VkBufferCollectionConstraintsInfoFUCHSIA, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkBufferCollectionConstraintsInfoFUCHSIA: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkCudaModuleCreateInfoNV(extensions: *const Extensions, item: *const vk.VkCudaModuleCreateInfoNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkCudaModuleCreateInfoNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkCudaFunctionCreateInfoNV(extensions: *const Extensions, item: *const vk.VkCudaFunctionCreateInfoNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkCudaFunctionCreateInfoNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkCudaLaunchInfoNV(extensions: *const Extensions, item: *const vk.VkCudaLaunchInfoNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkCudaLaunchInfoNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkFormatProperties3(extensions: *const Extensions, item: *const vk.VkFormatProperties3, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkFormatFeatureFlags2(extensions, &item.linearTilingFeatures))
        return false;
    if (!validate_VkFormatFeatureFlags2(extensions, &item.optimalTilingFeatures))
        return false;
    if (!validate_VkFormatFeatureFlags2(extensions, &item.bufferFeatures))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2,
            => if (!validate_VkFormatProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkFormatProperties3: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDrmFormatModifierPropertiesList2EXT(extensions: *const Extensions, item: *const vk.VkDrmFormatModifierPropertiesList2EXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (item.pDrmFormatModifierProperties) |v| {
        for (v[0..item.drmFormatModifierCount]) |*vv| {
            if (!validate_VkDrmFormatModifierProperties2EXT(extensions, vv, false))
                return false;
        }
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2,
            => if (!validate_VkFormatProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDrmFormatModifierPropertiesList2EXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDrmFormatModifierProperties2EXT(extensions: *const Extensions, item: *const vk.VkDrmFormatModifierProperties2EXT, validate_pnext: bool) bool {
    if (!validate_VkFormatFeatureFlags2(extensions, &item.drmFormatModifierTilingFeatures))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkAndroidHardwareBufferFormatProperties2ANDROID(extensions: *const Extensions, item: *const vk.VkAndroidHardwareBufferFormatProperties2ANDROID, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkFormat(extensions, &item.format))
        return false;
    if (!validate_VkFormatFeatureFlags2(extensions, &item.formatFeatures))
        return false;
    if (!validate_VkComponentMapping(extensions, &item.samplerYcbcrConversionComponents, false))
        return false;
    if (!validate_VkSamplerYcbcrModelConversion(extensions, &item.suggestedYcbcrModel))
        return false;
    if (!validate_VkSamplerYcbcrRange(extensions, &item.suggestedYcbcrRange))
        return false;
    if (!validate_VkChromaLocation(extensions, &item.suggestedXChromaOffset))
        return false;
    if (!validate_VkChromaLocation(extensions, &item.suggestedYChromaOffset))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID,
            => if (!validate_VkAndroidHardwareBufferPropertiesANDROID(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkAndroidHardwareBufferFormatProperties2ANDROID: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPipelineRenderingCreateInfo(extensions: *const Extensions, item: *const vk.VkPipelineRenderingCreateInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (item.pColorAttachmentFormats) |v| {
        for (v[0..item.colorAttachmentCount]) |*vv| {
            if (!validate_VkFormat(extensions, vv))
                return false;
        }
    }
    if (!validate_VkFormat(extensions, &item.depthAttachmentFormat))
        return false;
    if (!validate_VkFormat(extensions, &item.stencilAttachmentFormat))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO,
            => if (!validate_VkGraphicsPipelineCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineRenderingCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkRenderingInfo(extensions: *const Extensions, item: *const vk.VkRenderingInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkRenderingFlags(extensions, &item.flags))
        return false;
    if (!validate_VkRect2D(extensions, &item.renderArea, false))
        return false;
    if (item.pColorAttachments) |v| {
        for (v[0..item.colorAttachmentCount]) |*vv| {
            if (!validate_VkRenderingAttachmentInfo(extensions, vv, false))
                return false;
        }
    }
    if (item.pDepthAttachment) |v| {
        if (!validate_VkRenderingAttachmentInfo(extensions, v, false))
            return false;
    }
    if (item.pStencilAttachment) |v| {
        if (!validate_VkRenderingAttachmentInfo(extensions, v, false))
            return false;
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkRenderingInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkRenderingEndInfoKHR(extensions: *const Extensions, item: *const vk.VkRenderingEndInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkRenderingEndInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkRenderingAttachmentInfo(extensions: *const Extensions, item: *const vk.VkRenderingAttachmentInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkImageLayout(extensions, &item.imageLayout))
        return false;
    if (!validate_VkResolveModeFlags(extensions, &item.resolveMode))
        return false;
    if (!validate_VkImageLayout(extensions, &item.resolveImageLayout))
        return false;
    if (!validate_VkAttachmentLoadOp(extensions, &item.loadOp))
        return false;
    if (!validate_VkAttachmentStoreOp(extensions, &item.storeOp))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkRenderingAttachmentInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkRenderingFragmentShadingRateAttachmentInfoKHR(extensions: *const Extensions, item: *const vk.VkRenderingFragmentShadingRateAttachmentInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkImageLayout(extensions, &item.imageLayout))
        return false;
    if (!validate_VkExtent2D(extensions, &item.shadingRateAttachmentTexelSize, false))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_RENDERING_INFO,
            => if (!validate_VkRenderingInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkRenderingFragmentShadingRateAttachmentInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkRenderingFragmentDensityMapAttachmentInfoEXT(extensions: *const Extensions, item: *const vk.VkRenderingFragmentDensityMapAttachmentInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkImageLayout(extensions, &item.imageLayout))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_RENDERING_INFO,
            => if (!validate_VkRenderingInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkRenderingFragmentDensityMapAttachmentInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceDynamicRenderingFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDynamicRenderingFeatures, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceDynamicRenderingFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkCommandBufferInheritanceRenderingInfo(extensions: *const Extensions, item: *const vk.VkCommandBufferInheritanceRenderingInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkRenderingFlags(extensions, &item.flags))
        return false;
    if (item.pColorAttachmentFormats) |v| {
        for (v[0..item.colorAttachmentCount]) |*vv| {
            if (!validate_VkFormat(extensions, vv))
                return false;
        }
    }
    if (!validate_VkFormat(extensions, &item.depthAttachmentFormat))
        return false;
    if (!validate_VkFormat(extensions, &item.stencilAttachmentFormat))
        return false;
    if (!validate_VkSampleCountFlags(extensions, &item.rasterizationSamples))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO,
            => if (!validate_VkCommandBufferInheritanceInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkCommandBufferInheritanceRenderingInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkAttachmentSampleCountInfoAMD(extensions: *const Extensions, item: *const vk.VkAttachmentSampleCountInfoAMD, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (item.pColorAttachmentSamples) |v| {
        for (v[0..item.colorAttachmentCount]) |*vv| {
            if (!validate_VkSampleCountFlags(extensions, vv))
                return false;
        }
    }
    if (!validate_VkSampleCountFlags(extensions, &item.depthStencilAttachmentSamples))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO,
            => if (!validate_VkCommandBufferInheritanceInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO,
            => if (!validate_VkGraphicsPipelineCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkAttachmentSampleCountInfoAMD: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkMultiviewPerViewAttributesInfoNVX(extensions: *const Extensions, item: *const vk.VkMultiviewPerViewAttributesInfoNVX, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO,
            => if (!validate_VkCommandBufferInheritanceInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO,
            => if (!validate_VkGraphicsPipelineCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_RENDERING_INFO,
            => if (!validate_VkRenderingInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMultiviewPerViewAttributesInfoNVX: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceImageViewMinLodFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceImageViewMinLodFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceImageViewMinLodFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImageViewMinLodCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkImageViewMinLodCreateInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO,
            => if (!validate_VkImageViewCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImageViewMinLodCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceLinearColorAttachmentFeaturesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceLinearColorAttachmentFeaturesNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceLinearColorAttachmentFeaturesNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDevicePipelineBinaryFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePipelineBinaryFeaturesKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDevicePipelineBinaryFeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDevicePipelineBinaryInternalCacheControlKHR(extensions: *const Extensions, item: *const vk.VkDevicePipelineBinaryInternalCacheControlKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDevicePipelineBinaryInternalCacheControlKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDevicePipelineBinaryPropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePipelineBinaryPropertiesKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDevicePipelineBinaryPropertiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkGraphicsPipelineLibraryCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkGraphicsPipelineLibraryCreateInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkGraphicsPipelineLibraryFlagsEXT(extensions, &item.flags))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO,
            => if (!validate_VkGraphicsPipelineCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkGraphicsPipelineLibraryCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDescriptorSetBindingReferenceVALVE(extensions: *const Extensions, item: *const vk.VkDescriptorSetBindingReferenceVALVE, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDescriptorSetBindingReferenceVALVE: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDescriptorSetLayoutHostMappingInfoVALVE(extensions: *const Extensions, item: *const vk.VkDescriptorSetLayoutHostMappingInfoVALVE, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDescriptorSetLayoutHostMappingInfoVALVE: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceNestedCommandBufferFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceNestedCommandBufferFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceNestedCommandBufferFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceNestedCommandBufferPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceNestedCommandBufferPropertiesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceNestedCommandBufferPropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPipelineShaderStageModuleIdentifierCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkPipelineShaderStageModuleIdentifierCreateInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO,
            => if (!validate_VkPipelineShaderStageCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineShaderStageModuleIdentifierCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkShaderModuleIdentifierEXT(extensions: *const Extensions, item: *const vk.VkShaderModuleIdentifierEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkShaderModuleIdentifierEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImageCompressionControlEXT(extensions: *const Extensions, item: *const vk.VkImageCompressionControlEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkImageCompressionFlagsEXT(extensions, &item.flags))
        return false;
    if (item.pFixedRateFlags) |v| {
        for (v[0..item.compressionControlPlaneCount]) |*vv| {
            if (!validate_VkImageCompressionFixedRateFlagsEXT(extensions, vv))
                return false;
        }
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO,
            => if (!validate_VkImageCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR,
            => if (!validate_VkSwapchainCreateInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2,
            => if (!validate_VkPhysicalDeviceImageFormatInfo2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImageCompressionControlEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceImageCompressionControlFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceImageCompressionControlFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceImageCompressionControlFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImageCompressionPropertiesEXT(extensions: *const Extensions, item: *const vk.VkImageCompressionPropertiesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkImageCompressionFlagsEXT(extensions, &item.imageCompressionFlags))
        return false;
    if (!validate_VkImageCompressionFixedRateFlagsEXT(extensions, &item.imageCompressionFixedRateFlags))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2,
            => if (!validate_VkImageFormatProperties2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR,
            => if (!validate_VkSurfaceFormat2KHR(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2,
            => if (!validate_VkSubresourceLayout2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImageCompressionPropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImageSubresource2(extensions: *const Extensions, item: *const vk.VkImageSubresource2, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkImageSubresource(extensions, &item.imageSubresource, false))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImageSubresource2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSubresourceLayout2(extensions: *const Extensions, item: *const vk.VkSubresourceLayout2, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkSubresourceLayout(extensions, &item.subresourceLayout, false))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSubresourceLayout2: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkRenderPassCreationControlEXT(extensions: *const Extensions, item: *const vk.VkRenderPassCreationControlEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2,
            => if (!validate_VkRenderPassCreateInfo2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2,
            => if (!validate_VkSubpassDescription2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkRenderPassCreationControlEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkRenderPassCreationFeedbackInfoEXT(extensions: *const Extensions, item: *const vk.VkRenderPassCreationFeedbackInfoEXT, validate_pnext: bool) bool {
    _ = item;
    _ = extensions;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkRenderPassCreationFeedbackCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkRenderPassCreationFeedbackCreateInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (item.pRenderPassFeedback) |v| {
        if (!validate_VkRenderPassCreationFeedbackInfoEXT(extensions, v, false))
            return false;
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2,
            => if (!validate_VkRenderPassCreateInfo2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkRenderPassCreationFeedbackCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkRenderPassSubpassFeedbackInfoEXT(extensions: *const Extensions, item: *const vk.VkRenderPassSubpassFeedbackInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkSubpassMergeStatusEXT(extensions, &item.subpassMergeStatus))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkRenderPassSubpassFeedbackCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkRenderPassSubpassFeedbackCreateInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (item.pSubpassFeedback) |v| {
        if (!validate_VkRenderPassSubpassFeedbackInfoEXT(extensions, v, false))
            return false;
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2,
            => if (!validate_VkSubpassDescription2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkRenderPassSubpassFeedbackCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkMicromapBuildInfoEXT(extensions: *const Extensions, item: *const vk.VkMicromapBuildInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkMicromapTypeEXT(extensions, &item.type))
        return false;
    if (!validate_VkBuildMicromapFlagsEXT(extensions, &item.flags))
        return false;
    if (!validate_VkBuildMicromapModeEXT(extensions, &item.mode))
        return false;
    if (item.pUsageCounts) |v| {
        for (v[0..item.usageCountsCount]) |*vv| {
            if (!validate_VkMicromapUsageEXT(extensions, vv, false))
                return false;
        }
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMicromapBuildInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkMicromapCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkMicromapCreateInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkMicromapCreateFlagsEXT(extensions, &item.createFlags))
        return false;
    if (!validate_VkMicromapTypeEXT(extensions, &item.type))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMicromapCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkMicromapVersionInfoEXT(extensions: *const Extensions, item: *const vk.VkMicromapVersionInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMicromapVersionInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkCopyMicromapInfoEXT(extensions: *const Extensions, item: *const vk.VkCopyMicromapInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkCopyMicromapModeEXT(extensions, &item.mode))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkCopyMicromapInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkCopyMicromapToMemoryInfoEXT(extensions: *const Extensions, item: *const vk.VkCopyMicromapToMemoryInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkCopyMicromapModeEXT(extensions, &item.mode))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkCopyMicromapToMemoryInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkCopyMemoryToMicromapInfoEXT(extensions: *const Extensions, item: *const vk.VkCopyMemoryToMicromapInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkCopyMicromapModeEXT(extensions, &item.mode))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkCopyMemoryToMicromapInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkMicromapBuildSizesInfoEXT(extensions: *const Extensions, item: *const vk.VkMicromapBuildSizesInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMicromapBuildSizesInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkMicromapUsageEXT(extensions: *const Extensions, item: *const vk.VkMicromapUsageEXT, validate_pnext: bool) bool {
    _ = item;
    _ = extensions;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkMicromapTriangleEXT(extensions: *const Extensions, item: *const vk.VkMicromapTriangleEXT, validate_pnext: bool) bool {
    _ = item;
    _ = extensions;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDeviceOpacityMicromapFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceOpacityMicromapFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceOpacityMicromapFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceOpacityMicromapPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceOpacityMicromapPropertiesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceOpacityMicromapPropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkAccelerationStructureTrianglesOpacityMicromapEXT(extensions: *const Extensions, item: *const vk.VkAccelerationStructureTrianglesOpacityMicromapEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkIndexType(extensions, &item.indexType))
        return false;
    if (item.pUsageCounts) |v| {
        for (v[0..item.usageCountsCount]) |*vv| {
            if (!validate_VkMicromapUsageEXT(extensions, vv, false))
                return false;
        }
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR,
            => if (!validate_VkAccelerationStructureGeometryTrianglesDataKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DENSE_GEOMETRY_FORMAT_TRIANGLES_DATA_AMDX,
            => if (!validate_VkAccelerationStructureDenseGeometryFormatTrianglesDataAMDX(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkAccelerationStructureTrianglesOpacityMicromapEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceDisplacementMicromapFeaturesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDisplacementMicromapFeaturesNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceDisplacementMicromapFeaturesNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceDisplacementMicromapPropertiesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDisplacementMicromapPropertiesNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceDisplacementMicromapPropertiesNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkAccelerationStructureTrianglesDisplacementMicromapNV(extensions: *const Extensions, item: *const vk.VkAccelerationStructureTrianglesDisplacementMicromapNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkFormat(extensions, &item.displacementBiasAndScaleFormat))
        return false;
    if (!validate_VkFormat(extensions, &item.displacementVectorFormat))
        return false;
    if (!validate_VkIndexType(extensions, &item.indexType))
        return false;
    if (item.pUsageCounts) |v| {
        for (v[0..item.usageCountsCount]) |*vv| {
            if (!validate_VkMicromapUsageEXT(extensions, vv, false))
                return false;
        }
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR,
            => if (!validate_VkAccelerationStructureGeometryTrianglesDataKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkAccelerationStructureTrianglesDisplacementMicromapNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPipelinePropertiesIdentifierEXT(extensions: *const Extensions, item: *const vk.VkPipelinePropertiesIdentifierEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelinePropertiesIdentifierEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDevicePipelinePropertiesFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePipelinePropertiesFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDevicePipelinePropertiesFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkExternalMemoryAcquireUnmodifiedEXT(extensions: *const Extensions, item: *const vk.VkExternalMemoryAcquireUnmodifiedEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER,
            => if (!validate_VkBufferMemoryBarrier(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2,
            => if (!validate_VkBufferMemoryBarrier2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER,
            => if (!validate_VkImageMemoryBarrier(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2,
            => if (!validate_VkImageMemoryBarrier2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkExternalMemoryAcquireUnmodifiedEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkExportMetalObjectCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkExportMetalObjectCreateInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkExportMetalObjectTypeFlagsEXT(extensions, &item.exportObjectType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO,
            => if (!validate_VkInstanceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO,
            => if (!validate_VkMemoryAllocateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO,
            => if (!validate_VkImageCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO,
            => if (!validate_VkImageViewCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO,
            => if (!validate_VkBufferViewCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO,
            => if (!validate_VkSemaphoreCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_EVENT_CREATE_INFO,
            => if (!validate_VkEventCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkExportMetalObjectCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkExportMetalObjectsInfoEXT(extensions: *const Extensions, item: *const vk.VkExportMetalObjectsInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkExportMetalObjectsInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkExportMetalDeviceInfoEXT(extensions: *const Extensions, item: *const vk.VkExportMetalDeviceInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECTS_INFO_EXT,
            => if (!validate_VkExportMetalObjectsInfoEXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkExportMetalDeviceInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkExportMetalCommandQueueInfoEXT(extensions: *const Extensions, item: *const vk.VkExportMetalCommandQueueInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECTS_INFO_EXT,
            => if (!validate_VkExportMetalObjectsInfoEXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkExportMetalCommandQueueInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkExportMetalBufferInfoEXT(extensions: *const Extensions, item: *const vk.VkExportMetalBufferInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECTS_INFO_EXT,
            => if (!validate_VkExportMetalObjectsInfoEXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkExportMetalBufferInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImportMetalBufferInfoEXT(extensions: *const Extensions, item: *const vk.VkImportMetalBufferInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO,
            => if (!validate_VkMemoryAllocateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImportMetalBufferInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkExportMetalTextureInfoEXT(extensions: *const Extensions, item: *const vk.VkExportMetalTextureInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkImageAspectFlags(extensions, &item.plane))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECTS_INFO_EXT,
            => if (!validate_VkExportMetalObjectsInfoEXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkExportMetalTextureInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImportMetalTextureInfoEXT(extensions: *const Extensions, item: *const vk.VkImportMetalTextureInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkImageAspectFlags(extensions, &item.plane))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO,
            => if (!validate_VkImageCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImportMetalTextureInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkExportMetalIOSurfaceInfoEXT(extensions: *const Extensions, item: *const vk.VkExportMetalIOSurfaceInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECTS_INFO_EXT,
            => if (!validate_VkExportMetalObjectsInfoEXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkExportMetalIOSurfaceInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImportMetalIOSurfaceInfoEXT(extensions: *const Extensions, item: *const vk.VkImportMetalIOSurfaceInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO,
            => if (!validate_VkImageCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImportMetalIOSurfaceInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkExportMetalSharedEventInfoEXT(extensions: *const Extensions, item: *const vk.VkExportMetalSharedEventInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECTS_INFO_EXT,
            => if (!validate_VkExportMetalObjectsInfoEXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkExportMetalSharedEventInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImportMetalSharedEventInfoEXT(extensions: *const Extensions, item: *const vk.VkImportMetalSharedEventInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO,
            => if (!validate_VkSemaphoreCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_EVENT_CREATE_INFO,
            => if (!validate_VkEventCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImportMetalSharedEventInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDevicePipelineRobustnessFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePipelineRobustnessFeatures, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDevicePipelineRobustnessFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPipelineRobustnessCreateInfo(extensions: *const Extensions, item: *const vk.VkPipelineRobustnessCreateInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkPipelineRobustnessBufferBehavior(extensions, &item.storageBuffers))
        return false;
    if (!validate_VkPipelineRobustnessBufferBehavior(extensions, &item.uniformBuffers))
        return false;
    if (!validate_VkPipelineRobustnessBufferBehavior(extensions, &item.vertexInputs))
        return false;
    if (!validate_VkPipelineRobustnessImageBehavior(extensions, &item.images))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO,
            => if (!validate_VkGraphicsPipelineCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO,
            => if (!validate_VkComputePipelineCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO,
            => if (!validate_VkPipelineShaderStageCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_KHR,
            => if (!validate_VkRayTracingPipelineCreateInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineRobustnessCreateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDevicePipelineRobustnessProperties(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePipelineRobustnessProperties, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkPipelineRobustnessBufferBehavior(extensions, &item.defaultRobustnessStorageBuffers))
        return false;
    if (!validate_VkPipelineRobustnessBufferBehavior(extensions, &item.defaultRobustnessUniformBuffers))
        return false;
    if (!validate_VkPipelineRobustnessBufferBehavior(extensions, &item.defaultRobustnessVertexInputs))
        return false;
    if (!validate_VkPipelineRobustnessImageBehavior(extensions, &item.defaultRobustnessImages))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDevicePipelineRobustnessProperties: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImageViewSampleWeightCreateInfoQCOM(extensions: *const Extensions, item: *const vk.VkImageViewSampleWeightCreateInfoQCOM, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkOffset2D(extensions, &item.filterCenter, false))
        return false;
    if (!validate_VkExtent2D(extensions, &item.filterSize, false))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO,
            => if (!validate_VkImageViewCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImageViewSampleWeightCreateInfoQCOM: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceImageProcessingFeaturesQCOM(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceImageProcessingFeaturesQCOM, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceImageProcessingFeaturesQCOM: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceImageProcessingPropertiesQCOM(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceImageProcessingPropertiesQCOM, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkExtent2D(extensions, &item.maxWeightFilterDimension, false))
        return false;
    if (!validate_VkExtent2D(extensions, &item.maxBlockMatchRegion, false))
        return false;
    if (!validate_VkExtent2D(extensions, &item.maxBoxFilterBlockSize, false))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceImageProcessingPropertiesQCOM: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceTilePropertiesFeaturesQCOM(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceTilePropertiesFeaturesQCOM, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceTilePropertiesFeaturesQCOM: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkTilePropertiesQCOM(extensions: *const Extensions, item: *const vk.VkTilePropertiesQCOM, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkExtent3D(extensions, &item.tileSize, false))
        return false;
    if (!validate_VkExtent2D(extensions, &item.apronSize, false))
        return false;
    if (!validate_VkOffset2D(extensions, &item.origin, false))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkTilePropertiesQCOM: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkTileMemoryBindInfoQCOM(extensions: *const Extensions, item: *const vk.VkTileMemoryBindInfoQCOM, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO,
            => if (!validate_VkCommandBufferInheritanceInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkTileMemoryBindInfoQCOM: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceAmigoProfilingFeaturesSEC(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceAmigoProfilingFeaturesSEC, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceAmigoProfilingFeaturesSEC: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkAmigoProfilingSubmitInfoSEC(extensions: *const Extensions, item: *const vk.VkAmigoProfilingSubmitInfoSEC, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_SUBMIT_INFO,
            => if (!validate_VkSubmitInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkAmigoProfilingSubmitInfoSEC: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkAttachmentFeedbackLoopInfoEXT(extensions: *const Extensions, item: *const vk.VkAttachmentFeedbackLoopInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO,
            => if (!validate_VkRenderingAttachmentInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkAttachmentFeedbackLoopInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceAddressBindingReportFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceAddressBindingReportFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceAddressBindingReportFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkRenderingAttachmentFlagsInfoKHR(extensions: *const Extensions, item: *const vk.VkRenderingAttachmentFlagsInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkRenderingAttachmentFlagsKHR(extensions, &item.flags))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO,
            => if (!validate_VkRenderingAttachmentInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkRenderingAttachmentFlagsInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkResolveImageModeInfoKHR(extensions: *const Extensions, item: *const vk.VkResolveImageModeInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkResolveImageFlagsKHR(extensions, &item.flags))
        return false;
    if (!validate_VkResolveModeFlags(extensions, &item.resolveMode))
        return false;
    if (!validate_VkResolveModeFlags(extensions, &item.stencilResolveMode))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2,
            => if (!validate_VkResolveImageInfo2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkResolveImageModeInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDeviceAddressBindingCallbackDataEXT(extensions: *const Extensions, item: *const vk.VkDeviceAddressBindingCallbackDataEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkDeviceAddressBindingFlagsEXT(extensions, &item.flags))
        return false;
    if (!validate_VkDeviceAddressBindingTypeEXT(extensions, &item.bindingType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT,
            => if (!validate_VkDebugUtilsMessengerCallbackDataEXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDeviceAddressBindingCallbackDataEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceOpticalFlowFeaturesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceOpticalFlowFeaturesNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceOpticalFlowFeaturesNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceOpticalFlowPropertiesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceOpticalFlowPropertiesNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkOpticalFlowGridSizeFlagsNV(extensions, &item.supportedOutputGridSizes))
        return false;
    if (!validate_VkOpticalFlowGridSizeFlagsNV(extensions, &item.supportedHintGridSizes))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceOpticalFlowPropertiesNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkOpticalFlowImageFormatInfoNV(extensions: *const Extensions, item: *const vk.VkOpticalFlowImageFormatInfoNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkOpticalFlowUsageFlagsNV(extensions, &item.usage))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2,
            => if (!validate_VkPhysicalDeviceImageFormatInfo2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO,
            => if (!validate_VkImageCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkOpticalFlowImageFormatInfoNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkOpticalFlowImageFormatPropertiesNV(extensions: *const Extensions, item: *const vk.VkOpticalFlowImageFormatPropertiesNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkFormat(extensions, &item.format))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkOpticalFlowImageFormatPropertiesNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkOpticalFlowSessionCreateInfoNV(extensions: *const Extensions, item: *const vk.VkOpticalFlowSessionCreateInfoNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkFormat(extensions, &item.imageFormat))
        return false;
    if (!validate_VkFormat(extensions, &item.flowVectorFormat))
        return false;
    if (!validate_VkFormat(extensions, &item.costFormat))
        return false;
    if (!validate_VkOpticalFlowGridSizeFlagsNV(extensions, &item.outputGridSize))
        return false;
    if (!validate_VkOpticalFlowGridSizeFlagsNV(extensions, &item.hintGridSize))
        return false;
    if (!validate_VkOpticalFlowPerformanceLevelNV(extensions, &item.performanceLevel))
        return false;
    if (!validate_VkOpticalFlowSessionCreateFlagsNV(extensions, &item.flags))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkOpticalFlowSessionCreateInfoNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkOpticalFlowSessionCreatePrivateDataInfoNV(extensions: *const Extensions, item: *const vk.VkOpticalFlowSessionCreatePrivateDataInfoNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_INFO_NV,
            => if (!validate_VkOpticalFlowSessionCreateInfoNV(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkOpticalFlowSessionCreatePrivateDataInfoNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkOpticalFlowExecuteInfoNV(extensions: *const Extensions, item: *const vk.VkOpticalFlowExecuteInfoNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkOpticalFlowExecuteFlagsNV(extensions, &item.flags))
        return false;
    if (item.pRegions) |v| {
        for (v[0..item.regionCount]) |*vv| {
            if (!validate_VkRect2D(extensions, vv, false))
                return false;
        }
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkOpticalFlowExecuteInfoNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceFaultFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceFaultFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceFaultFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDeviceFaultAddressInfoEXT(extensions: *const Extensions, item: *const vk.VkDeviceFaultAddressInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkDeviceFaultAddressTypeEXT(extensions, &item.addressType))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkDeviceFaultVendorInfoEXT(extensions: *const Extensions, item: *const vk.VkDeviceFaultVendorInfoEXT, validate_pnext: bool) bool {
    _ = item;
    _ = extensions;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkDeviceFaultCountsEXT(extensions: *const Extensions, item: *const vk.VkDeviceFaultCountsEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDeviceFaultCountsEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDeviceFaultInfoEXT(extensions: *const Extensions, item: *const vk.VkDeviceFaultInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (item.pAddressInfos) |v| {
        if (!validate_VkDeviceFaultAddressInfoEXT(extensions, v, false))
            return false;
    }
    if (item.pVendorInfos) |v| {
        if (!validate_VkDeviceFaultVendorInfoEXT(extensions, v, false))
            return false;
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDeviceFaultInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDeviceFaultVendorBinaryHeaderVersionOneEXT(extensions: *const Extensions, item: *const vk.VkDeviceFaultVendorBinaryHeaderVersionOneEXT, validate_pnext: bool) bool {
    if (!validate_VkDeviceFaultVendorBinaryHeaderVersionEXT(extensions, &item.headerVersion))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDepthBiasInfoEXT(extensions: *const Extensions, item: *const vk.VkDepthBiasInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDepthBiasInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDepthBiasRepresentationInfoEXT(extensions: *const Extensions, item: *const vk.VkDepthBiasRepresentationInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkDepthBiasRepresentationEXT(extensions, &item.depthBiasRepresentation))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEPTH_BIAS_INFO_EXT,
            => if (!validate_VkDepthBiasInfoEXT(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO,
            => if (!validate_VkPipelineRasterizationStateCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDepthBiasRepresentationInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDecompressMemoryRegionNV(extensions: *const Extensions, item: *const vk.VkDecompressMemoryRegionNV, validate_pnext: bool) bool {
    _ = item;
    _ = extensions;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkDecompressMemoryRegionEXT(extensions: *const Extensions, item: *const vk.VkDecompressMemoryRegionEXT, validate_pnext: bool) bool {
    _ = item;
    _ = extensions;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkDecompressMemoryInfoEXT(extensions: *const Extensions, item: *const vk.VkDecompressMemoryInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkMemoryDecompressionMethodFlagsEXT(extensions, &item.decompressionMethod))
        return false;
    if (item.pRegions) |v| {
        for (v[0..item.regionCount]) |*vv| {
            if (!validate_VkDecompressMemoryRegionEXT(extensions, vv, false))
                return false;
        }
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDecompressMemoryInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkFrameBoundaryEXT(extensions: *const Extensions, item: *const vk.VkFrameBoundaryEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkFrameBoundaryFlagsEXT(extensions, &item.flags))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_SUBMIT_INFO,
            => if (!validate_VkSubmitInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_SUBMIT_INFO_2,
            => if (!validate_VkSubmitInfo2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_PRESENT_INFO_KHR,
            => if (!validate_VkPresentInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_BIND_SPARSE_INFO,
            => if (!validate_VkBindSparseInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkFrameBoundaryEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceFrameBoundaryFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceFrameBoundaryFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceFrameBoundaryFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSurfacePresentModeKHR(extensions: *const Extensions, item: *const vk.VkSurfacePresentModeKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkPresentModeKHR(extensions, &item.presentMode))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR,
            => if (!validate_VkPhysicalDeviceSurfaceInfo2KHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSurfacePresentModeKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSurfacePresentScalingCapabilitiesKHR(extensions: *const Extensions, item: *const vk.VkSurfacePresentScalingCapabilitiesKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkPresentScalingFlagsKHR(extensions, &item.supportedPresentScaling))
        return false;
    if (!validate_VkPresentGravityFlagsKHR(extensions, &item.supportedPresentGravityX))
        return false;
    if (!validate_VkPresentGravityFlagsKHR(extensions, &item.supportedPresentGravityY))
        return false;
    if (!validate_VkExtent2D(extensions, &item.minScaledImageExtent, false))
        return false;
    if (!validate_VkExtent2D(extensions, &item.maxScaledImageExtent, false))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR,
            => if (!validate_VkSurfaceCapabilities2KHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSurfacePresentScalingCapabilitiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSurfacePresentModeCompatibilityKHR(extensions: *const Extensions, item: *const vk.VkSurfacePresentModeCompatibilityKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (item.pPresentModes) |v| {
        for (v[0..item.presentModeCount]) |*vv| {
            if (!validate_VkPresentModeKHR(extensions, vv))
                return false;
        }
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR,
            => if (!validate_VkSurfaceCapabilities2KHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSurfacePresentModeCompatibilityKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceSwapchainMaintenance1FeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceSwapchainMaintenance1FeaturesKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceSwapchainMaintenance1FeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSwapchainPresentFenceInfoKHR(extensions: *const Extensions, item: *const vk.VkSwapchainPresentFenceInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PRESENT_INFO_KHR,
            => if (!validate_VkPresentInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSwapchainPresentFenceInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSwapchainPresentModesCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkSwapchainPresentModesCreateInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (item.pPresentModes) |v| {
        for (v[0..item.presentModeCount]) |*vv| {
            if (!validate_VkPresentModeKHR(extensions, vv))
                return false;
        }
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR,
            => if (!validate_VkSwapchainCreateInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSwapchainPresentModesCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSwapchainPresentModeInfoKHR(extensions: *const Extensions, item: *const vk.VkSwapchainPresentModeInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (item.pPresentModes) |v| {
        for (v[0..item.swapchainCount]) |*vv| {
            if (!validate_VkPresentModeKHR(extensions, vv))
                return false;
        }
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PRESENT_INFO_KHR,
            => if (!validate_VkPresentInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSwapchainPresentModeInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSwapchainPresentScalingCreateInfoKHR(extensions: *const Extensions, item: *const vk.VkSwapchainPresentScalingCreateInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkPresentScalingFlagsKHR(extensions, &item.scalingBehavior))
        return false;
    if (!validate_VkPresentGravityFlagsKHR(extensions, &item.presentGravityX))
        return false;
    if (!validate_VkPresentGravityFlagsKHR(extensions, &item.presentGravityY))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR,
            => if (!validate_VkSwapchainCreateInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSwapchainPresentScalingCreateInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkReleaseSwapchainImagesInfoKHR(extensions: *const Extensions, item: *const vk.VkReleaseSwapchainImagesInfoKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkReleaseSwapchainImagesInfoKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceDepthBiasControlFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDepthBiasControlFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceDepthBiasControlFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceRayTracingInvocationReorderFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceRayTracingInvocationReorderFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceRayTracingInvocationReorderFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceRayTracingInvocationReorderPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceRayTracingInvocationReorderPropertiesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkRayTracingInvocationReorderModeEXT(extensions, &item.rayTracingInvocationReorderReorderingHint))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceRayTracingInvocationReorderPropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkRayTracingInvocationReorderModeEXT(extensions, &item.rayTracingInvocationReorderReorderingHint))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkImageUsageFlags(extensions, &item.extendedSparseImageUsageFlags))
        return false;
    if (!validate_VkBufferUsageFlags(extensions, &item.extendedSparseBufferUsageFlags))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDirectDriverLoadingInfoLUNARG(extensions: *const Extensions, item: *const vk.VkDirectDriverLoadingInfoLUNARG, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkDirectDriverLoadingFlagsLUNARG(extensions, &item.flags))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDirectDriverLoadingInfoLUNARG: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDirectDriverLoadingListLUNARG(extensions: *const Extensions, item: *const vk.VkDirectDriverLoadingListLUNARG, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkDirectDriverLoadingModeLUNARG(extensions, &item.mode))
        return false;
    if (item.pDrivers) |v| {
        for (v[0..item.driverCount]) |*vv| {
            if (!validate_VkDirectDriverLoadingInfoLUNARG(extensions, vv, false))
                return false;
        }
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO,
            => if (!validate_VkInstanceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDirectDriverLoadingListLUNARG: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDeviceImageSubresourceInfo(extensions: *const Extensions, item: *const vk.VkDeviceImageSubresourceInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (item.pCreateInfo) |v| {
        if (!validate_VkImageCreateInfo(extensions, v, false))
            return false;
    }
    if (item.pSubresource) |v| {
        if (!validate_VkImageSubresource2(extensions, v, false))
            return false;
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDeviceImageSubresourceInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceShaderCorePropertiesARM(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderCorePropertiesARM, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShaderCorePropertiesARM: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM(extensions: *const Extensions, item: *const vk.VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (item.pPerViewRenderAreas) |v| {
        for (v[0..item.perViewRenderAreaCount]) |*vv| {
            if (!validate_VkRect2D(extensions, vv, false))
                return false;
        }
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO,
            => if (!validate_VkRenderPassBeginInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_RENDERING_INFO,
            => if (!validate_VkRenderingInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkQueryLowLatencySupportNV(extensions: *const Extensions, item: *const vk.VkQueryLowLatencySupportNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO,
            => if (!validate_VkSemaphoreCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkQueryLowLatencySupportNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkMemoryMapInfo(extensions: *const Extensions, item: *const vk.VkMemoryMapInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkMemoryMapFlags(extensions, &item.flags))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMemoryMapInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkMemoryUnmapInfo(extensions: *const Extensions, item: *const vk.VkMemoryUnmapInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkMemoryUnmapFlags(extensions, &item.flags))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMemoryUnmapInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceShaderObjectFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderObjectFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShaderObjectFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceShaderObjectPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderObjectPropertiesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShaderObjectPropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkShaderCreateInfoEXT(extensions: *const Extensions, item: *const vk.VkShaderCreateInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkShaderCreateFlagsEXT(extensions, &item.flags))
        return false;
    if (!validate_VkShaderStageFlags(extensions, &item.stage))
        return false;
    if (!validate_VkShaderStageFlags(extensions, &item.nextStage))
        return false;
    if (!validate_VkShaderCodeTypeEXT(extensions, &item.codeType))
        return false;
    if (item.pPushConstantRanges) |v| {
        for (v[0..item.pushConstantRangeCount]) |*vv| {
            if (!validate_VkPushConstantRange(extensions, vv, false))
                return false;
        }
    }
    if (item.pSpecializationInfo) |v| {
        if (!validate_VkSpecializationInfo(extensions, v, false))
            return false;
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkShaderCreateInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceShaderTileImageFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderTileImageFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShaderTileImageFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceShaderTileImagePropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderTileImagePropertiesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShaderTileImagePropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImportScreenBufferInfoQNX(extensions: *const Extensions, item: *const vk.VkImportScreenBufferInfoQNX, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO,
            => if (!validate_VkMemoryAllocateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImportScreenBufferInfoQNX: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkScreenBufferPropertiesQNX(extensions: *const Extensions, item: *const vk.VkScreenBufferPropertiesQNX, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkScreenBufferPropertiesQNX: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkScreenBufferFormatPropertiesQNX(extensions: *const Extensions, item: *const vk.VkScreenBufferFormatPropertiesQNX, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkFormat(extensions, &item.format))
        return false;
    if (!validate_VkFormatFeatureFlags(extensions, &item.formatFeatures))
        return false;
    if (!validate_VkComponentMapping(extensions, &item.samplerYcbcrConversionComponents, false))
        return false;
    if (!validate_VkSamplerYcbcrModelConversion(extensions, &item.suggestedYcbcrModel))
        return false;
    if (!validate_VkSamplerYcbcrRange(extensions, &item.suggestedYcbcrRange))
        return false;
    if (!validate_VkChromaLocation(extensions, &item.suggestedXChromaOffset))
        return false;
    if (!validate_VkChromaLocation(extensions, &item.suggestedYChromaOffset))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_SCREEN_BUFFER_PROPERTIES_QNX,
            => if (!validate_VkScreenBufferPropertiesQNX(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkScreenBufferFormatPropertiesQNX: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkExternalFormatQNX(extensions: *const Extensions, item: *const vk.VkExternalFormatQNX, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO,
            => if (!validate_VkImageCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO,
            => if (!validate_VkSamplerYcbcrConversionCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkExternalFormatQNX: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceCooperativeMatrixFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceCooperativeMatrixFeaturesKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceCooperativeMatrixFeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkCooperativeMatrixPropertiesKHR(extensions: *const Extensions, item: *const vk.VkCooperativeMatrixPropertiesKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkComponentTypeKHR(extensions, &item.AType))
        return false;
    if (!validate_VkComponentTypeKHR(extensions, &item.BType))
        return false;
    if (!validate_VkComponentTypeKHR(extensions, &item.CType))
        return false;
    if (!validate_VkComponentTypeKHR(extensions, &item.ResultType))
        return false;
    if (!validate_VkScopeKHR(extensions, &item.scope))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkCooperativeMatrixPropertiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceCooperativeMatrixPropertiesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceCooperativeMatrixPropertiesKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkShaderStageFlags(extensions, &item.cooperativeMatrixSupportedStages))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceCooperativeMatrixPropertiesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceShaderEnqueuePropertiesAMDX(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderEnqueuePropertiesAMDX, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShaderEnqueuePropertiesAMDX: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceShaderEnqueueFeaturesAMDX(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderEnqueueFeaturesAMDX, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShaderEnqueueFeaturesAMDX: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkExecutionGraphPipelineCreateInfoAMDX(extensions: *const Extensions, item: *const vk.VkExecutionGraphPipelineCreateInfoAMDX, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkPipelineCreateFlags(extensions, &item.flags))
        return false;
    if (item.pStages) |v| {
        for (v[0..item.stageCount]) |*vv| {
            if (!validate_VkPipelineShaderStageCreateInfo(extensions, vv, false))
                return false;
        }
    }
    if (item.pLibraryInfo) |v| {
        if (!validate_VkPipelineLibraryCreateInfoKHR(extensions, v, false))
            return false;
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkExecutionGraphPipelineCreateInfoAMDX: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPipelineShaderStageNodeCreateInfoAMDX(extensions: *const Extensions, item: *const vk.VkPipelineShaderStageNodeCreateInfoAMDX, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO,
            => if (!validate_VkPipelineShaderStageCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineShaderStageNodeCreateInfoAMDX: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkExecutionGraphPipelineScratchSizeAMDX(extensions: *const Extensions, item: *const vk.VkExecutionGraphPipelineScratchSizeAMDX, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkExecutionGraphPipelineScratchSizeAMDX: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDispatchGraphInfoAMDX(extensions: *const Extensions, item: *const vk.VkDispatchGraphInfoAMDX, validate_pnext: bool) bool {
    _ = item;
    _ = extensions;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkDispatchGraphCountInfoAMDX(extensions: *const Extensions, item: *const vk.VkDispatchGraphCountInfoAMDX, validate_pnext: bool) bool {
    _ = item;
    _ = extensions;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDeviceAntiLagFeaturesAMD(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceAntiLagFeaturesAMD, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceAntiLagFeaturesAMD: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkAntiLagDataAMD(extensions: *const Extensions, item: *const vk.VkAntiLagDataAMD, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkAntiLagModeAMD(extensions, &item.mode))
        return false;
    if (item.pPresentationInfo) |v| {
        if (!validate_VkAntiLagPresentationInfoAMD(extensions, v, false))
            return false;
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkAntiLagDataAMD: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkAntiLagPresentationInfoAMD(extensions: *const Extensions, item: *const vk.VkAntiLagPresentationInfoAMD, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkAntiLagStageAMD(extensions, &item.stage))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkAntiLagPresentationInfoAMD: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkBindMemoryStatus(extensions: *const Extensions, item: *const vk.VkBindMemoryStatus, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (item.pResult) |v| {
        if (!validate_VkResult(extensions, v))
            return false;
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO,
            => if (!validate_VkBindBufferMemoryInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO,
            => if (!validate_VkBindImageMemoryInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkBindMemoryStatus: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceTileMemoryHeapFeaturesQCOM(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceTileMemoryHeapFeaturesQCOM, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceTileMemoryHeapFeaturesQCOM: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceTileMemoryHeapPropertiesQCOM(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceTileMemoryHeapPropertiesQCOM, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceTileMemoryHeapPropertiesQCOM: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkTileMemorySizeInfoQCOM(extensions: *const Extensions, item: *const vk.VkTileMemorySizeInfoQCOM, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO,
            => if (!validate_VkRenderPassCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2,
            => if (!validate_VkRenderPassCreateInfo2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_RENDERING_INFO,
            => if (!validate_VkRenderingInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkTileMemorySizeInfoQCOM: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkTileMemoryRequirementsQCOM(extensions: *const Extensions, item: *const vk.VkTileMemoryRequirementsQCOM, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2,
            => if (!validate_VkMemoryRequirements2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkTileMemoryRequirementsQCOM: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkBindDescriptorSetsInfo(extensions: *const Extensions, item: *const vk.VkBindDescriptorSetsInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkShaderStageFlags(extensions, &item.stageFlags))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkBindDescriptorSetsInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPushConstantsInfo(extensions: *const Extensions, item: *const vk.VkPushConstantsInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkShaderStageFlags(extensions, &item.stageFlags))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPushConstantsInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPushDescriptorSetInfo(extensions: *const Extensions, item: *const vk.VkPushDescriptorSetInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkShaderStageFlags(extensions, &item.stageFlags))
        return false;
    if (item.pDescriptorWrites) |v| {
        for (v[0..item.descriptorWriteCount]) |*vv| {
            if (!validate_VkWriteDescriptorSet(extensions, vv, false))
                return false;
        }
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPushDescriptorSetInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPushDescriptorSetWithTemplateInfo(extensions: *const Extensions, item: *const vk.VkPushDescriptorSetWithTemplateInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPushDescriptorSetWithTemplateInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSetDescriptorBufferOffsetsInfoEXT(extensions: *const Extensions, item: *const vk.VkSetDescriptorBufferOffsetsInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkShaderStageFlags(extensions, &item.stageFlags))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSetDescriptorBufferOffsetsInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkBindDescriptorBufferEmbeddedSamplersInfoEXT(extensions: *const Extensions, item: *const vk.VkBindDescriptorBufferEmbeddedSamplersInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkShaderStageFlags(extensions, &item.stageFlags))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkBindDescriptorBufferEmbeddedSamplersInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceCubicClampFeaturesQCOM(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceCubicClampFeaturesQCOM, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceCubicClampFeaturesQCOM: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceYcbcrDegammaFeaturesQCOM(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceYcbcrDegammaFeaturesQCOM, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceYcbcrDegammaFeaturesQCOM: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM(extensions: *const Extensions, item: *const vk.VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO,
            => if (!validate_VkSamplerYcbcrConversionCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceCubicWeightsFeaturesQCOM(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceCubicWeightsFeaturesQCOM, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceCubicWeightsFeaturesQCOM: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSamplerCubicWeightsCreateInfoQCOM(extensions: *const Extensions, item: *const vk.VkSamplerCubicWeightsCreateInfoQCOM, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkCubicFilterWeightsQCOM(extensions, &item.cubicWeights))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO,
            => if (!validate_VkSamplerCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSamplerCubicWeightsCreateInfoQCOM: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkBlitImageCubicWeightsInfoQCOM(extensions: *const Extensions, item: *const vk.VkBlitImageCubicWeightsInfoQCOM, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkCubicFilterWeightsQCOM(extensions, &item.cubicWeights))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2,
            => if (!validate_VkBlitImageInfo2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkBlitImageCubicWeightsInfoQCOM: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceImageProcessing2FeaturesQCOM(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceImageProcessing2FeaturesQCOM, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceImageProcessing2FeaturesQCOM: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceImageProcessing2PropertiesQCOM(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceImageProcessing2PropertiesQCOM, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkExtent2D(extensions, &item.maxBlockMatchWindow, false))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceImageProcessing2PropertiesQCOM: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSamplerBlockMatchWindowCreateInfoQCOM(extensions: *const Extensions, item: *const vk.VkSamplerBlockMatchWindowCreateInfoQCOM, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkExtent2D(extensions, &item.windowExtent, false))
        return false;
    if (!validate_VkBlockMatchWindowCompareModeQCOM(extensions, &item.windowCompareMode))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO,
            => if (!validate_VkSamplerCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSamplerBlockMatchWindowCreateInfoQCOM: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceLayeredDriverPropertiesMSFT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceLayeredDriverPropertiesMSFT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkLayeredDriverUnderlyingApiMSFT(extensions, &item.underlyingAPI))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceLayeredDriverPropertiesMSFT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDevicePerStageDescriptorSetFeaturesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePerStageDescriptorSetFeaturesNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDevicePerStageDescriptorSetFeaturesNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceExternalFormatResolveFeaturesANDROID(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceExternalFormatResolveFeaturesANDROID, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceExternalFormatResolveFeaturesANDROID: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceExternalFormatResolvePropertiesANDROID(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceExternalFormatResolvePropertiesANDROID, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkChromaLocation(extensions, &item.externalFormatResolveChromaOffsetX))
        return false;
    if (!validate_VkChromaLocation(extensions, &item.externalFormatResolveChromaOffsetY))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceExternalFormatResolvePropertiesANDROID: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkAndroidHardwareBufferFormatResolvePropertiesANDROID(extensions: *const Extensions, item: *const vk.VkAndroidHardwareBufferFormatResolvePropertiesANDROID, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkFormat(extensions, &item.colorAttachmentFormat))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID,
            => if (!validate_VkAndroidHardwareBufferPropertiesANDROID(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkAndroidHardwareBufferFormatResolvePropertiesANDROID: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkLatencySleepModeInfoNV(extensions: *const Extensions, item: *const vk.VkLatencySleepModeInfoNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkLatencySleepModeInfoNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkLatencySleepInfoNV(extensions: *const Extensions, item: *const vk.VkLatencySleepInfoNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkLatencySleepInfoNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSetLatencyMarkerInfoNV(extensions: *const Extensions, item: *const vk.VkSetLatencyMarkerInfoNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkLatencyMarkerNV(extensions, &item.marker))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSetLatencyMarkerInfoNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkGetLatencyMarkerInfoNV(extensions: *const Extensions, item: *const vk.VkGetLatencyMarkerInfoNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (item.pTimings) |v| {
        for (v[0..item.timingCount]) |*vv| {
            if (!validate_VkLatencyTimingsFrameReportNV(extensions, vv, false))
                return false;
        }
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkGetLatencyMarkerInfoNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkLatencyTimingsFrameReportNV(extensions: *const Extensions, item: *const vk.VkLatencyTimingsFrameReportNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkLatencyTimingsFrameReportNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkOutOfBandQueueTypeInfoNV(extensions: *const Extensions, item: *const vk.VkOutOfBandQueueTypeInfoNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkOutOfBandQueueTypeNV(extensions, &item.queueType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkOutOfBandQueueTypeInfoNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkLatencySubmissionPresentIdNV(extensions: *const Extensions, item: *const vk.VkLatencySubmissionPresentIdNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_SUBMIT_INFO,
            => if (!validate_VkSubmitInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_SUBMIT_INFO_2,
            => if (!validate_VkSubmitInfo2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkLatencySubmissionPresentIdNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSwapchainLatencyCreateInfoNV(extensions: *const Extensions, item: *const vk.VkSwapchainLatencyCreateInfoNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR,
            => if (!validate_VkSwapchainCreateInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSwapchainLatencyCreateInfoNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkLatencySurfaceCapabilitiesNV(extensions: *const Extensions, item: *const vk.VkLatencySurfaceCapabilitiesNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (item.pPresentModes) |v| {
        for (v[0..item.presentModeCount]) |*vv| {
            if (!validate_VkPresentModeKHR(extensions, vv))
                return false;
        }
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR,
            => if (!validate_VkSurfaceCapabilities2KHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkLatencySurfaceCapabilitiesNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceCudaKernelLaunchFeaturesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceCudaKernelLaunchFeaturesNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceCudaKernelLaunchFeaturesNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceCudaKernelLaunchPropertiesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceCudaKernelLaunchPropertiesNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceCudaKernelLaunchPropertiesNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDeviceQueueShaderCoreControlCreateInfoARM(extensions: *const Extensions, item: *const vk.VkDeviceQueueShaderCoreControlCreateInfoARM, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO,
            => if (!validate_VkDeviceQueueCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDeviceQueueShaderCoreControlCreateInfoARM: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceSchedulingControlsFeaturesARM(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceSchedulingControlsFeaturesARM, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceSchedulingControlsFeaturesARM: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceSchedulingControlsPropertiesARM(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceSchedulingControlsPropertiesARM, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkPhysicalDeviceSchedulingControlsFlagsARM(extensions, &item.schedulingControlsFlags))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceSchedulingControlsPropertiesARM: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceRenderPassStripedFeaturesARM(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceRenderPassStripedFeaturesARM, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceRenderPassStripedFeaturesARM: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceRenderPassStripedPropertiesARM(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceRenderPassStripedPropertiesARM, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkExtent2D(extensions, &item.renderPassStripeGranularity, false))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceRenderPassStripedPropertiesARM: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkRenderPassStripeInfoARM(extensions: *const Extensions, item: *const vk.VkRenderPassStripeInfoARM, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkRect2D(extensions, &item.stripeArea, false))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkRenderPassStripeInfoARM: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkRenderPassStripeBeginInfoARM(extensions: *const Extensions, item: *const vk.VkRenderPassStripeBeginInfoARM, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (item.pStripeInfos) |v| {
        for (v[0..item.stripeInfoCount]) |*vv| {
            if (!validate_VkRenderPassStripeInfoARM(extensions, vv, false))
                return false;
        }
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_RENDERING_INFO,
            => if (!validate_VkRenderingInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO,
            => if (!validate_VkRenderPassBeginInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkRenderPassStripeBeginInfoARM: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkRenderPassStripeSubmitInfoARM(extensions: *const Extensions, item: *const vk.VkRenderPassStripeSubmitInfoARM, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (item.pStripeSemaphoreInfos) |v| {
        for (v[0..item.stripeSemaphoreInfoCount]) |*vv| {
            if (!validate_VkSemaphoreSubmitInfo(extensions, vv, false))
                return false;
        }
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO,
            => if (!validate_VkCommandBufferSubmitInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkRenderPassStripeSubmitInfoARM: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDevicePipelineOpacityMicromapFeaturesARM(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePipelineOpacityMicromapFeaturesARM, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDevicePipelineOpacityMicromapFeaturesARM: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceShaderSubgroupRotateFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderSubgroupRotateFeatures, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShaderSubgroupRotateFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceShaderExpectAssumeFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderExpectAssumeFeatures, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShaderExpectAssumeFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceShaderFloatControls2Features(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderFloatControls2Features, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShaderFloatControls2Features: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceDynamicRenderingLocalReadFeatures(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDynamicRenderingLocalReadFeatures, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceDynamicRenderingLocalReadFeatures: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkRenderingAttachmentLocationInfo(extensions: *const Extensions, item: *const vk.VkRenderingAttachmentLocationInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO,
            => if (!validate_VkGraphicsPipelineCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO,
            => if (!validate_VkCommandBufferInheritanceInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkRenderingAttachmentLocationInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkRenderingInputAttachmentIndexInfo(extensions: *const Extensions, item: *const vk.VkRenderingInputAttachmentIndexInfo, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO,
            => if (!validate_VkGraphicsPipelineCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO,
            => if (!validate_VkCommandBufferInheritanceInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkRenderingInputAttachmentIndexInfo: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceShaderQuadControlFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderQuadControlFeaturesKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShaderQuadControlFeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceMapMemoryPlacedFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMapMemoryPlacedFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceMapMemoryPlacedFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceMapMemoryPlacedPropertiesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceMapMemoryPlacedPropertiesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceMapMemoryPlacedPropertiesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkMemoryMapPlacedInfoEXT(extensions: *const Extensions, item: *const vk.VkMemoryMapPlacedInfoEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_MEMORY_MAP_INFO,
            => if (!validate_VkMemoryMapInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMemoryMapPlacedInfoEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceShaderBfloat16FeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderBfloat16FeaturesKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShaderBfloat16FeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceRawAccessChainsFeaturesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceRawAccessChainsFeaturesNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceRawAccessChainsFeaturesNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceCommandBufferInheritanceFeaturesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceCommandBufferInheritanceFeaturesNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceCommandBufferInheritanceFeaturesNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceImageAlignmentControlFeaturesMESA(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceImageAlignmentControlFeaturesMESA, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceImageAlignmentControlFeaturesMESA: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceImageAlignmentControlPropertiesMESA(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceImageAlignmentControlPropertiesMESA, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceImageAlignmentControlPropertiesMESA: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImageAlignmentControlCreateInfoMESA(extensions: *const Extensions, item: *const vk.VkImageAlignmentControlCreateInfoMESA, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO,
            => if (!validate_VkImageCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImageAlignmentControlCreateInfoMESA: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDevicePresentModeFifoLatestReadyFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePresentModeFifoLatestReadyFeaturesKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDevicePresentModeFifoLatestReadyFeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDepthClampRangeEXT(extensions: *const Extensions, item: *const vk.VkDepthClampRangeEXT, validate_pnext: bool) bool {
    _ = item;
    _ = extensions;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDeviceCooperativeMatrix2FeaturesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceCooperativeMatrix2FeaturesNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceCooperativeMatrix2FeaturesNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceCooperativeMatrix2PropertiesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceCooperativeMatrix2PropertiesNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceCooperativeMatrix2PropertiesNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkCooperativeMatrixFlexibleDimensionsPropertiesNV(extensions: *const Extensions, item: *const vk.VkCooperativeMatrixFlexibleDimensionsPropertiesNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkComponentTypeKHR(extensions, &item.AType))
        return false;
    if (!validate_VkComponentTypeKHR(extensions, &item.BType))
        return false;
    if (!validate_VkComponentTypeKHR(extensions, &item.CType))
        return false;
    if (!validate_VkComponentTypeKHR(extensions, &item.ResultType))
        return false;
    if (!validate_VkScopeKHR(extensions, &item.scope))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkCooperativeMatrixFlexibleDimensionsPropertiesNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceHdrVividFeaturesHUAWEI(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceHdrVividFeaturesHUAWEI, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceHdrVividFeaturesHUAWEI: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceDenseGeometryFormatFeaturesAMDX(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDenseGeometryFormatFeaturesAMDX, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceDenseGeometryFormatFeaturesAMDX: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkAccelerationStructureDenseGeometryFormatTrianglesDataAMDX(extensions: *const Extensions, item: *const vk.VkAccelerationStructureDenseGeometryFormatTrianglesDataAMDX, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkCompressedTriangleFormatAMDX(extensions, &item.format))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR,
            => if (!validate_VkAccelerationStructureGeometryKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkAccelerationStructureDenseGeometryFormatTrianglesDataAMDX: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceDepthClampZeroOneFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDepthClampZeroOneFeaturesKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceDepthClampZeroOneFeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceCooperativeVectorFeaturesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceCooperativeVectorFeaturesNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceCooperativeVectorFeaturesNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkCooperativeVectorPropertiesNV(extensions: *const Extensions, item: *const vk.VkCooperativeVectorPropertiesNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkComponentTypeKHR(extensions, &item.inputType))
        return false;
    if (!validate_VkComponentTypeKHR(extensions, &item.inputInterpretation))
        return false;
    if (!validate_VkComponentTypeKHR(extensions, &item.matrixInterpretation))
        return false;
    if (!validate_VkComponentTypeKHR(extensions, &item.biasInterpretation))
        return false;
    if (!validate_VkComponentTypeKHR(extensions, &item.resultType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkCooperativeVectorPropertiesNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceCooperativeVectorPropertiesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceCooperativeVectorPropertiesNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkShaderStageFlags(extensions, &item.cooperativeVectorSupportedStages))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceCooperativeVectorPropertiesNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkConvertCooperativeVectorMatrixInfoNV(extensions: *const Extensions, item: *const vk.VkConvertCooperativeVectorMatrixInfoNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkComponentTypeKHR(extensions, &item.srcComponentType))
        return false;
    if (!validate_VkComponentTypeKHR(extensions, &item.dstComponentType))
        return false;
    if (!validate_VkCooperativeVectorMatrixLayoutNV(extensions, &item.srcLayout))
        return false;
    if (!validate_VkCooperativeVectorMatrixLayoutNV(extensions, &item.dstLayout))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkConvertCooperativeVectorMatrixInfoNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceTileShadingFeaturesQCOM(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceTileShadingFeaturesQCOM, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceTileShadingFeaturesQCOM: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceTileShadingPropertiesQCOM(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceTileShadingPropertiesQCOM, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkExtent2D(extensions, &item.tileGranularity, false))
        return false;
    if (!validate_VkExtent2D(extensions, &item.maxTileShadingRate, false))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceTileShadingPropertiesQCOM: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkRenderPassTileShadingCreateInfoQCOM(extensions: *const Extensions, item: *const vk.VkRenderPassTileShadingCreateInfoQCOM, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkTileShadingRenderPassFlagsQCOM(extensions, &item.flags))
        return false;
    if (!validate_VkExtent2D(extensions, &item.tileApronSize, false))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO,
            => if (!validate_VkRenderPassCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2,
            => if (!validate_VkRenderPassCreateInfo2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_RENDERING_INFO,
            => if (!validate_VkRenderingInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO,
            => if (!validate_VkCommandBufferInheritanceInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkRenderPassTileShadingCreateInfoQCOM: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPerTileBeginInfoQCOM(extensions: *const Extensions, item: *const vk.VkPerTileBeginInfoQCOM, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPerTileBeginInfoQCOM: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPerTileEndInfoQCOM(extensions: *const Extensions, item: *const vk.VkPerTileEndInfoQCOM, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPerTileEndInfoQCOM: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDispatchTileInfoQCOM(extensions: *const Extensions, item: *const vk.VkDispatchTileInfoQCOM, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDispatchTileInfoQCOM: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceFragmentDensityMapLayeredPropertiesVALVE(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceFragmentDensityMapLayeredPropertiesVALVE, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceFragmentDensityMapLayeredPropertiesVALVE: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPipelineFragmentDensityMapLayeredCreateInfoVALVE(extensions: *const Extensions, item: *const vk.VkPipelineFragmentDensityMapLayeredCreateInfoVALVE, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO,
            => if (!validate_VkGraphicsPipelineCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPipelineFragmentDensityMapLayeredCreateInfoVALVE: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSetPresentConfigNV(extensions: *const Extensions, item: *const vk.VkSetPresentConfigNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PRESENT_INFO_KHR,
            => if (!validate_VkPresentInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSetPresentConfigNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDevicePresentMeteringFeaturesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePresentMeteringFeaturesNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDevicePresentMeteringFeaturesNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkExternalComputeQueueDeviceCreateInfoNV(extensions: *const Extensions, item: *const vk.VkExternalComputeQueueDeviceCreateInfoNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkExternalComputeQueueDeviceCreateInfoNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkExternalComputeQueueCreateInfoNV(extensions: *const Extensions, item: *const vk.VkExternalComputeQueueCreateInfoNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkExternalComputeQueueCreateInfoNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkExternalComputeQueueDataParamsNV(extensions: *const Extensions, item: *const vk.VkExternalComputeQueueDataParamsNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkExternalComputeQueueDataParamsNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceExternalComputeQueuePropertiesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceExternalComputeQueuePropertiesNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceExternalComputeQueuePropertiesNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceShaderUniformBufferUnsizedArrayFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderUniformBufferUnsizedArrayFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShaderUniformBufferUnsizedArrayFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceFormatPackFeaturesARM(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceFormatPackFeaturesARM, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceFormatPackFeaturesARM: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkTensorDescriptionARM(extensions: *const Extensions, item: *const vk.VkTensorDescriptionARM, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkTensorTilingARM(extensions, &item.tiling))
        return false;
    if (!validate_VkFormat(extensions, &item.format))
        return false;
    if (!validate_VkTensorUsageFlagsARM(extensions, &item.usage))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_RESOURCE_INFO_ARM,
            => if (!validate_VkDataGraphPipelineResourceInfoARM(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_CONSTANT_ARM,
            => if (!validate_VkDataGraphPipelineConstantARM(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkTensorDescriptionARM: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkTensorCreateInfoARM(extensions: *const Extensions, item: *const vk.VkTensorCreateInfoARM, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkTensorCreateFlagsARM(extensions, &item.flags))
        return false;
    if (item.pDescription) |v| {
        if (!validate_VkTensorDescriptionARM(extensions, v, false))
            return false;
    }
    if (!validate_VkSharingMode(extensions, &item.sharingMode))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkTensorCreateInfoARM: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkTensorViewCreateInfoARM(extensions: *const Extensions, item: *const vk.VkTensorViewCreateInfoARM, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkTensorViewCreateFlagsARM(extensions, &item.flags))
        return false;
    if (!validate_VkFormat(extensions, &item.format))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkTensorViewCreateInfoARM: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkTensorMemoryRequirementsInfoARM(extensions: *const Extensions, item: *const vk.VkTensorMemoryRequirementsInfoARM, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkTensorMemoryRequirementsInfoARM: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkBindTensorMemoryInfoARM(extensions: *const Extensions, item: *const vk.VkBindTensorMemoryInfoARM, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkBindTensorMemoryInfoARM: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkWriteDescriptorSetTensorARM(extensions: *const Extensions, item: *const vk.VkWriteDescriptorSetTensorARM, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET,
            => if (!validate_VkWriteDescriptorSet(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkWriteDescriptorSetTensorARM: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkTensorFormatPropertiesARM(extensions: *const Extensions, item: *const vk.VkTensorFormatPropertiesARM, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkFormatFeatureFlags2(extensions, &item.optimalTilingTensorFeatures))
        return false;
    if (!validate_VkFormatFeatureFlags2(extensions, &item.linearTilingTensorFeatures))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2,
            => if (!validate_VkFormatProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkTensorFormatPropertiesARM: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceTensorPropertiesARM(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceTensorPropertiesARM, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkShaderStageFlags(extensions, &item.shaderTensorSupportedStages))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceTensorPropertiesARM: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkTensorMemoryBarrierARM(extensions: *const Extensions, item: *const vk.VkTensorMemoryBarrierARM, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkPipelineStageFlags2(extensions, &item.srcStageMask))
        return false;
    if (!validate_VkAccessFlags2(extensions, &item.srcAccessMask))
        return false;
    if (!validate_VkPipelineStageFlags2(extensions, &item.dstStageMask))
        return false;
    if (!validate_VkAccessFlags2(extensions, &item.dstAccessMask))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEPENDENCY_INFO,
            => if (!validate_VkDependencyInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkTensorMemoryBarrierARM: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkTensorDependencyInfoARM(extensions: *const Extensions, item: *const vk.VkTensorDependencyInfoARM, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (item.pTensorMemoryBarriers) |v| {
        if (!validate_VkTensorMemoryBarrierARM(extensions, v, false))
            return false;
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEPENDENCY_INFO,
            => if (!validate_VkDependencyInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkTensorDependencyInfoARM: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceTensorFeaturesARM(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceTensorFeaturesARM, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceTensorFeaturesARM: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDeviceTensorMemoryRequirementsARM(extensions: *const Extensions, item: *const vk.VkDeviceTensorMemoryRequirementsARM, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (item.pCreateInfo) |v| {
        if (!validate_VkTensorCreateInfoARM(extensions, v, false))
            return false;
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDeviceTensorMemoryRequirementsARM: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkCopyTensorInfoARM(extensions: *const Extensions, item: *const vk.VkCopyTensorInfoARM, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (item.pRegions) |v| {
        for (v[0..item.regionCount]) |*vv| {
            if (!validate_VkTensorCopyARM(extensions, vv, false))
                return false;
        }
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkCopyTensorInfoARM: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkTensorCopyARM(extensions: *const Extensions, item: *const vk.VkTensorCopyARM, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkTensorCopyARM: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkMemoryDedicatedAllocateInfoTensorARM(extensions: *const Extensions, item: *const vk.VkMemoryDedicatedAllocateInfoTensorARM, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO,
            => if (!validate_VkMemoryAllocateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMemoryDedicatedAllocateInfoTensorARM: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceDescriptorBufferTensorPropertiesARM(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDescriptorBufferTensorPropertiesARM, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceDescriptorBufferTensorPropertiesARM: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceDescriptorBufferTensorFeaturesARM(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDescriptorBufferTensorFeaturesARM, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceDescriptorBufferTensorFeaturesARM: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkTensorCaptureDescriptorDataInfoARM(extensions: *const Extensions, item: *const vk.VkTensorCaptureDescriptorDataInfoARM, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkTensorCaptureDescriptorDataInfoARM: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkTensorViewCaptureDescriptorDataInfoARM(extensions: *const Extensions, item: *const vk.VkTensorViewCaptureDescriptorDataInfoARM, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkTensorViewCaptureDescriptorDataInfoARM: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDescriptorGetTensorInfoARM(extensions: *const Extensions, item: *const vk.VkDescriptorGetTensorInfoARM, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_DESCRIPTOR_GET_INFO_EXT,
            => if (!validate_VkDescriptorGetInfoEXT(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDescriptorGetTensorInfoARM: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkFrameBoundaryTensorsARM(extensions: *const Extensions, item: *const vk.VkFrameBoundaryTensorsARM, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_SUBMIT_INFO,
            => if (!validate_VkSubmitInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_SUBMIT_INFO_2,
            => if (!validate_VkSubmitInfo2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_PRESENT_INFO_KHR,
            => if (!validate_VkPresentInfoKHR(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_BIND_SPARSE_INFO,
            => if (!validate_VkBindSparseInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkFrameBoundaryTensorsARM: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceExternalTensorInfoARM(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceExternalTensorInfoARM, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkTensorCreateFlagsARM(extensions, &item.flags))
        return false;
    if (item.pDescription) |v| {
        if (!validate_VkTensorDescriptionARM(extensions, v, false))
            return false;
    }
    if (!validate_VkExternalMemoryHandleTypeFlags(extensions, &item.handleType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceExternalTensorInfoARM: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkExternalTensorPropertiesARM(extensions: *const Extensions, item: *const vk.VkExternalTensorPropertiesARM, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkExternalMemoryProperties(extensions, &item.externalMemoryProperties, false))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkExternalTensorPropertiesARM: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkExternalMemoryTensorCreateInfoARM(extensions: *const Extensions, item: *const vk.VkExternalMemoryTensorCreateInfoARM, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkExternalMemoryHandleTypeFlags(extensions, &item.handleTypes))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_TENSOR_CREATE_INFO_ARM,
            => if (!validate_VkTensorCreateInfoARM(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkExternalMemoryTensorCreateInfoARM: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceShaderFloat8FeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderFloat8FeaturesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShaderFloat8FeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSurfaceCreateInfoOHOS(extensions: *const Extensions, item: *const vk.VkSurfaceCreateInfoOHOS, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkSurfaceCreateFlagsOHOS(extensions, &item.flags))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSurfaceCreateInfoOHOS: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceDataGraphFeaturesARM(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDataGraphFeaturesARM, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceDataGraphFeaturesARM: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDataGraphPipelineConstantTensorSemiStructuredSparsityInfoARM(extensions: *const Extensions, item: *const vk.VkDataGraphPipelineConstantTensorSemiStructuredSparsityInfoARM, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_CONSTANT_ARM,
            => if (!validate_VkDataGraphPipelineConstantARM(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDataGraphPipelineConstantTensorSemiStructuredSparsityInfoARM: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDataGraphPipelineConstantARM(extensions: *const Extensions, item: *const vk.VkDataGraphPipelineConstantARM, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDataGraphPipelineConstantARM: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDataGraphPipelineResourceInfoARM(extensions: *const Extensions, item: *const vk.VkDataGraphPipelineResourceInfoARM, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDataGraphPipelineResourceInfoARM: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDataGraphPipelineCompilerControlCreateInfoARM(extensions: *const Extensions, item: *const vk.VkDataGraphPipelineCompilerControlCreateInfoARM, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_CREATE_INFO_ARM,
            => if (!validate_VkDataGraphPipelineCreateInfoARM(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDataGraphPipelineCompilerControlCreateInfoARM: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDataGraphPipelineCreateInfoARM(extensions: *const Extensions, item: *const vk.VkDataGraphPipelineCreateInfoARM, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (item.pResourceInfos) |v| {
        for (v[0..item.resourceInfoCount]) |*vv| {
            if (!validate_VkDataGraphPipelineResourceInfoARM(extensions, vv, false))
                return false;
        }
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDataGraphPipelineCreateInfoARM: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDataGraphPipelineShaderModuleCreateInfoARM(extensions: *const Extensions, item: *const vk.VkDataGraphPipelineShaderModuleCreateInfoARM, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (item.pSpecializationInfo) |v| {
        if (!validate_VkSpecializationInfo(extensions, v, false))
            return false;
    }
    if (item.pConstants) |v| {
        for (v[0..item.constantCount]) |*vv| {
            if (!validate_VkDataGraphPipelineConstantARM(extensions, vv, false))
                return false;
        }
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_CREATE_INFO_ARM,
            => if (!validate_VkDataGraphPipelineCreateInfoARM(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDataGraphPipelineShaderModuleCreateInfoARM: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDataGraphPipelineSessionCreateInfoARM(extensions: *const Extensions, item: *const vk.VkDataGraphPipelineSessionCreateInfoARM, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkDataGraphPipelineSessionCreateFlagsARM(extensions, &item.flags))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDataGraphPipelineSessionCreateInfoARM: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDataGraphPipelineSessionBindPointRequirementsInfoARM(extensions: *const Extensions, item: *const vk.VkDataGraphPipelineSessionBindPointRequirementsInfoARM, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDataGraphPipelineSessionBindPointRequirementsInfoARM: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDataGraphPipelineSessionBindPointRequirementARM(extensions: *const Extensions, item: *const vk.VkDataGraphPipelineSessionBindPointRequirementARM, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkDataGraphPipelineSessionBindPointARM(extensions, &item.bindPoint))
        return false;
    if (!validate_VkDataGraphPipelineSessionBindPointTypeARM(extensions, &item.bindPointType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDataGraphPipelineSessionBindPointRequirementARM: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDataGraphPipelineSessionMemoryRequirementsInfoARM(extensions: *const Extensions, item: *const vk.VkDataGraphPipelineSessionMemoryRequirementsInfoARM, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkDataGraphPipelineSessionBindPointARM(extensions, &item.bindPoint))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDataGraphPipelineSessionMemoryRequirementsInfoARM: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkBindDataGraphPipelineSessionMemoryInfoARM(extensions: *const Extensions, item: *const vk.VkBindDataGraphPipelineSessionMemoryInfoARM, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkDataGraphPipelineSessionBindPointARM(extensions, &item.bindPoint))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkBindDataGraphPipelineSessionMemoryInfoARM: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDataGraphPipelineInfoARM(extensions: *const Extensions, item: *const vk.VkDataGraphPipelineInfoARM, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDataGraphPipelineInfoARM: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDataGraphPipelinePropertyQueryResultARM(extensions: *const Extensions, item: *const vk.VkDataGraphPipelinePropertyQueryResultARM, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkDataGraphPipelinePropertyARM(extensions, &item.property))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDataGraphPipelinePropertyQueryResultARM: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDataGraphPipelineIdentifierCreateInfoARM(extensions: *const Extensions, item: *const vk.VkDataGraphPipelineIdentifierCreateInfoARM, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_CREATE_INFO_ARM,
            => if (!validate_VkDataGraphPipelineCreateInfoARM(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDataGraphPipelineIdentifierCreateInfoARM: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDataGraphPipelineDispatchInfoARM(extensions: *const Extensions, item: *const vk.VkDataGraphPipelineDispatchInfoARM, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkDataGraphPipelineDispatchFlagsARM(extensions, &item.flags))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDataGraphPipelineDispatchInfoARM: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceDataGraphProcessingEngineARM(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDataGraphProcessingEngineARM, validate_pnext: bool) bool {
    if (!validate_VkPhysicalDeviceDataGraphProcessingEngineTypeARM(extensions, &item.type))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkPhysicalDeviceDataGraphOperationSupportARM(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDataGraphOperationSupportARM, validate_pnext: bool) bool {
    if (!validate_VkPhysicalDeviceDataGraphOperationTypeARM(extensions, &item.operationType))
        return false;
    _ = validate_pnext;
    return true;
}

pub fn validate_VkQueueFamilyDataGraphPropertiesARM(extensions: *const Extensions, item: *const vk.VkQueueFamilyDataGraphPropertiesARM, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkPhysicalDeviceDataGraphProcessingEngineARM(extensions, &item.engine, false))
        return false;
    if (!validate_VkPhysicalDeviceDataGraphOperationSupportARM(extensions, &item.operation, false))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkQueueFamilyDataGraphPropertiesARM: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARM(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARM, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkPhysicalDeviceDataGraphProcessingEngineTypeARM(extensions, &item.engineType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARM: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkQueueFamilyDataGraphProcessingEnginePropertiesARM(extensions: *const Extensions, item: *const vk.VkQueueFamilyDataGraphProcessingEnginePropertiesARM, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkExternalSemaphoreHandleTypeFlags(extensions, &item.foreignSemaphoreHandleTypes))
        return false;
    if (!validate_VkExternalMemoryHandleTypeFlags(extensions, &item.foreignMemoryHandleTypes))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkQueueFamilyDataGraphProcessingEnginePropertiesARM: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDataGraphProcessingEngineCreateInfoARM(extensions: *const Extensions, item: *const vk.VkDataGraphProcessingEngineCreateInfoARM, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (item.pProcessingEngines) |v| {
        for (v[0..item.processingEngineCount]) |*vv| {
            if (!validate_VkPhysicalDeviceDataGraphProcessingEngineARM(extensions, vv, false))
                return false;
        }
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_CREATE_INFO_ARM,
            => if (!validate_VkDataGraphPipelineCreateInfoARM(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO,
            => if (!validate_VkDescriptorPoolCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO,
            => if (!validate_VkCommandPoolCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDataGraphProcessingEngineCreateInfoARM: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDevicePipelineCacheIncrementalModeFeaturesSEC(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePipelineCacheIncrementalModeFeaturesSEC, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDevicePipelineCacheIncrementalModeFeaturesSEC: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkDataGraphPipelineBuiltinModelCreateInfoQCOM(extensions: *const Extensions, item: *const vk.VkDataGraphPipelineBuiltinModelCreateInfoQCOM, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (item.pOperation) |v| {
        if (!validate_VkPhysicalDeviceDataGraphOperationSupportARM(extensions, v, false))
            return false;
    }
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_CREATE_INFO_ARM,
            => if (!validate_VkDataGraphPipelineCreateInfoARM(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkDataGraphPipelineBuiltinModelCreateInfoQCOM: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceDataGraphModelFeaturesQCOM(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDataGraphModelFeaturesQCOM, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceDataGraphModelFeaturesQCOM: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceShaderUntypedPointersFeaturesKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShaderUntypedPointersFeaturesKHR, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShaderUntypedPointersFeaturesKHR: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkNativeBufferOHOS(extensions: *const Extensions, item: *const vk.VkNativeBufferOHOS, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO,
            => if (!validate_VkImageCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO,
            => if (!validate_VkBindImageMemoryInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkNativeBufferOHOS: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkSwapchainImageCreateInfoOHOS(extensions: *const Extensions, item: *const vk.VkSwapchainImageCreateInfoOHOS, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkSwapchainImageUsageFlagsOHOS(extensions, &item.usage))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO,
            => if (!validate_VkImageCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkSwapchainImageCreateInfoOHOS: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDevicePresentationPropertiesOHOS(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePresentationPropertiesOHOS, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDevicePresentationPropertiesOHOS: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceVideoEncodeRgbConversionFeaturesVALVE(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceVideoEncodeRgbConversionFeaturesVALVE, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceVideoEncodeRgbConversionFeaturesVALVE: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeRgbConversionCapabilitiesVALVE(extensions: *const Extensions, item: *const vk.VkVideoEncodeRgbConversionCapabilitiesVALVE, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkVideoEncodeRgbModelConversionFlagsVALVE(extensions, &item.rgbModels))
        return false;
    if (!validate_VkVideoEncodeRgbRangeCompressionFlagsVALVE(extensions, &item.rgbRanges))
        return false;
    if (!validate_VkVideoEncodeRgbChromaOffsetFlagsVALVE(extensions, &item.xChromaOffsets))
        return false;
    if (!validate_VkVideoEncodeRgbChromaOffsetFlagsVALVE(extensions, &item.yChromaOffsets))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_VIDEO_CAPABILITIES_KHR,
            => if (!validate_VkVideoCapabilitiesKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeRgbConversionCapabilitiesVALVE: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeProfileRgbConversionInfoVALVE(extensions: *const Extensions, item: *const vk.VkVideoEncodeProfileRgbConversionInfoVALVE, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_VIDEO_PROFILE_INFO_KHR,
            => if (!validate_VkVideoProfileInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeProfileRgbConversionInfoVALVE: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkVideoEncodeSessionRgbConversionCreateInfoVALVE(extensions: *const Extensions, item: *const vk.VkVideoEncodeSessionRgbConversionCreateInfoVALVE, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkVideoEncodeRgbModelConversionFlagsVALVE(extensions, &item.rgbModel))
        return false;
    if (!validate_VkVideoEncodeRgbRangeCompressionFlagsVALVE(extensions, &item.rgbRange))
        return false;
    if (!validate_VkVideoEncodeRgbChromaOffsetFlagsVALVE(extensions, &item.xChromaOffset))
        return false;
    if (!validate_VkVideoEncodeRgbChromaOffsetFlagsVALVE(extensions, &item.yChromaOffset))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_VIDEO_SESSION_CREATE_INFO_KHR,
            => if (!validate_VkVideoSessionCreateInfoKHR(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkVideoEncodeSessionRgbConversionCreateInfoVALVE: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceShader64BitIndexingFeaturesEXT(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceShader64BitIndexingFeaturesEXT, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceShader64BitIndexingFeaturesEXT: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkNativeBufferUsageOHOS(extensions: *const Extensions, item: *const vk.VkNativeBufferUsageOHOS, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2,
            => if (!validate_VkImageFormatProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkNativeBufferUsageOHOS: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkNativeBufferPropertiesOHOS(extensions: *const Extensions, item: *const vk.VkNativeBufferPropertiesOHOS, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkNativeBufferPropertiesOHOS: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkNativeBufferFormatPropertiesOHOS(extensions: *const Extensions, item: *const vk.VkNativeBufferFormatPropertiesOHOS, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkFormat(extensions, &item.format))
        return false;
    if (!validate_VkFormatFeatureFlags(extensions, &item.formatFeatures))
        return false;
    if (!validate_VkComponentMapping(extensions, &item.samplerYcbcrConversionComponents, false))
        return false;
    if (!validate_VkSamplerYcbcrModelConversion(extensions, &item.suggestedYcbcrModel))
        return false;
    if (!validate_VkSamplerYcbcrRange(extensions, &item.suggestedYcbcrRange))
        return false;
    if (!validate_VkChromaLocation(extensions, &item.suggestedXChromaOffset))
        return false;
    if (!validate_VkChromaLocation(extensions, &item.suggestedYChromaOffset))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_NATIVE_BUFFER_PROPERTIES_OHOS,
            => if (!validate_VkNativeBufferPropertiesOHOS(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkNativeBufferFormatPropertiesOHOS: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImportNativeBufferInfoOHOS(extensions: *const Extensions, item: *const vk.VkImportNativeBufferInfoOHOS, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO,
            => if (!validate_VkMemoryAllocateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkImportNativeBufferInfoOHOS: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkMemoryGetNativeBufferInfoOHOS(extensions: *const Extensions, item: *const vk.VkMemoryGetNativeBufferInfoOHOS, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkMemoryGetNativeBufferInfoOHOS: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkExternalFormatOHOS(extensions: *const Extensions, item: *const vk.VkExternalFormatOHOS, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO,
            => if (!validate_VkImageCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO,
            => if (!validate_VkSamplerYcbcrConversionCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2,
            => if (!validate_VkAttachmentDescription2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO,
            => if (!validate_VkGraphicsPipelineCreateInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO,
            => if (!validate_VkCommandBufferInheritanceInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkExternalFormatOHOS: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDevicePerformanceCountersByRegionFeaturesARM(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePerformanceCountersByRegionFeaturesARM, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDevicePerformanceCountersByRegionFeaturesARM: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDevicePerformanceCountersByRegionPropertiesARM(extensions: *const Extensions, item: *const vk.VkPhysicalDevicePerformanceCountersByRegionPropertiesARM, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkExtent2D(extensions, &item.performanceCounterRegionSize, false))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
            => if (!validate_VkPhysicalDeviceProperties2(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDevicePerformanceCountersByRegionPropertiesARM: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPerformanceCounterARM(extensions: *const Extensions, item: *const vk.VkPerformanceCounterARM, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPerformanceCounterARM: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPerformanceCounterDescriptionARM(extensions: *const Extensions, item: *const vk.VkPerformanceCounterDescriptionARM, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_VkPerformanceCounterDescriptionFlagsARM(extensions, &item.flags))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPerformanceCounterDescriptionARM: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkRenderPassPerformanceCountersByRegionBeginInfoARM(extensions: *const Extensions, item: *const vk.VkRenderPassPerformanceCountersByRegionBeginInfoARM, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO,
            => if (!validate_VkRenderPassBeginInfo(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_RENDERING_INFO,
            => if (!validate_VkRenderingInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkRenderPassPerformanceCountersByRegionBeginInfoARM: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkComputeOccupancyPriorityParametersNV(extensions: *const Extensions, item: *const vk.VkComputeOccupancyPriorityParametersNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkComputeOccupancyPriorityParametersNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkPhysicalDeviceComputeOccupancyPriorityFeaturesNV(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceComputeOccupancyPriorityFeaturesNV, validate_pnext: bool) bool {
    if (!validate_VkStructureType(extensions, &item.sType))
        return false;
    if (!validate_pnext) return true;

    var pnext: ?*const vk.VkBaseInStructure = @ptrCast(@alignCast(item.pNext));
    while (pnext) |next| {
        pnext = next.pNext;
        switch (next.sType) {
            vk.VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            => if (!validate_VkPhysicalDeviceFeatures2(extensions, @ptrCast(next), false))
                return false,
            vk.VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
            => if (!validate_VkDeviceCreateInfo(extensions, @ptrCast(next), false))
                return false,
            else => |v| {
                log.debug(@src(), "Invalid pNext chain item for VkPhysicalDeviceComputeOccupancyPriorityFeaturesNV: {d}", .{v});
                return false;
            },
        }
    }
    return true;
}

pub fn validate_VkImageLayout(extensions: *const Extensions, item: *const vk.VkImageLayout) bool {
    const min = 0;
    const max = 1000620000;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    if (extensions.device.VK_KHR_swapchain and item.* == .VK_IMAGE_LAYOUT_PRESENT_SRC_KHR)
        return true;
    if (extensions.device.VK_KHR_video_decode_queue and item.* == .VK_IMAGE_LAYOUT_VIDEO_DECODE_DST_KHR)
        return true;
    if (extensions.device.VK_KHR_video_decode_queue and item.* == .VK_IMAGE_LAYOUT_VIDEO_DECODE_SRC_KHR)
        return true;
    if (extensions.device.VK_KHR_video_decode_queue and item.* == .VK_IMAGE_LAYOUT_VIDEO_DECODE_DPB_KHR)
        return true;
    if (extensions.device.VK_KHR_shared_presentable_image and item.* == .VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR)
        return true;
    if (extensions.device.VK_KHR_fragment_shading_rate and item.* == .VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR)
        return true;
    if (extensions.device.VK_EXT_fragment_density_map and item.* == .VK_IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT)
        return true;
    if (extensions.device.VK_KHR_video_encode_queue and item.* == .VK_IMAGE_LAYOUT_VIDEO_ENCODE_DST_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_queue and item.* == .VK_IMAGE_LAYOUT_VIDEO_ENCODE_SRC_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_queue and item.* == .VK_IMAGE_LAYOUT_VIDEO_ENCODE_DPB_KHR)
        return true;
    if (extensions.device.VK_EXT_attachment_feedback_loop_layout and item.* == .VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT)
        return true;
    if (extensions.device.VK_ARM_tensors and item.* == .VK_IMAGE_LAYOUT_TENSOR_ALIASING_ARM)
        return true;
    if (extensions.device.VK_KHR_video_encode_quantization_map and item.* == .VK_IMAGE_LAYOUT_VIDEO_ENCODE_QUANTIZATION_MAP_KHR)
        return true;
    if (extensions.device.VK_EXT_zero_initialize_device_memory and item.* == .VK_IMAGE_LAYOUT_ZERO_INITIALIZED_EXT)
        return true;
    return true;
}

pub fn validate_VkAttachmentLoadOp(extensions: *const Extensions, item: *const vk.VkAttachmentLoadOp) bool {
    const min = 0;
    const max = 1000400000;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkAttachmentStoreOp(extensions: *const Extensions, item: *const vk.VkAttachmentStoreOp) bool {
    const min = 0;
    const max = 1000301000;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkImageType(extensions: *const Extensions, item: *const vk.VkImageType) bool {
    const min = 0;
    const max = 2;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkImageTiling(extensions: *const Extensions, item: *const vk.VkImageTiling) bool {
    const min = 0;
    const max = 1000158000;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    if (extensions.device.VK_EXT_image_drm_format_modifier and item.* == .VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT)
        return true;
    return true;
}

pub fn validate_VkImageViewType(extensions: *const Extensions, item: *const vk.VkImageViewType) bool {
    const min = 0;
    const max = 6;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkCommandBufferLevel(extensions: *const Extensions, item: *const vk.VkCommandBufferLevel) bool {
    const min = 0;
    const max = 1;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkComponentSwizzle(extensions: *const Extensions, item: *const vk.VkComponentSwizzle) bool {
    const min = 0;
    const max = 6;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkDescriptorType(extensions: *const Extensions, item: *const vk.VkDescriptorType) bool {
    const min = 0;
    const max = 1000570000;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    if (extensions.device.VK_KHR_acceleration_structure and item.* == .VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR)
        return true;
    if (extensions.device.VK_NV_ray_tracing and item.* == .VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV)
        return true;
    if (extensions.device.VK_EXT_mutable_descriptor_type and item.* == .VK_DESCRIPTOR_TYPE_MUTABLE_EXT)
        return true;
    if (extensions.device.VK_QCOM_image_processing and item.* == .VK_DESCRIPTOR_TYPE_SAMPLE_WEIGHT_IMAGE_QCOM)
        return true;
    if (extensions.device.VK_QCOM_image_processing and item.* == .VK_DESCRIPTOR_TYPE_BLOCK_MATCH_IMAGE_QCOM)
        return true;
    if (extensions.device.VK_ARM_tensors and item.* == .VK_DESCRIPTOR_TYPE_TENSOR_ARM)
        return true;
    if (extensions.device.VK_NV_partitioned_acceleration_structure and item.* == .VK_DESCRIPTOR_TYPE_PARTITIONED_ACCELERATION_STRUCTURE_NV)
        return true;
    return true;
}

pub fn validate_VkQueryType(extensions: *const Extensions, item: *const vk.VkQueryType) bool {
    const min = 0;
    const max = 1000396001;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    if (extensions.device.VK_KHR_video_queue and item.* == .VK_QUERY_TYPE_RESULT_STATUS_ONLY_KHR)
        return true;
    if (extensions.device.VK_EXT_transform_feedback and item.* == .VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT)
        return true;
    if (extensions.device.VK_KHR_performance_query and item.* == .VK_QUERY_TYPE_PERFORMANCE_QUERY_KHR)
        return true;
    if (extensions.device.VK_KHR_acceleration_structure and item.* == .VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_KHR)
        return true;
    if (extensions.device.VK_KHR_acceleration_structure and item.* == .VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_SIZE_KHR)
        return true;
    if (extensions.device.VK_NV_ray_tracing and item.* == .VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_NV)
        return true;
    if (extensions.device.VK_INTEL_performance_query and item.* == .VK_QUERY_TYPE_PERFORMANCE_QUERY_INTEL)
        return true;
    if (extensions.device.VK_KHR_video_encode_queue and item.* == .VK_QUERY_TYPE_VIDEO_ENCODE_FEEDBACK_KHR)
        return true;
    if (extensions.device.VK_EXT_mesh_shader and item.* == .VK_QUERY_TYPE_MESH_PRIMITIVES_GENERATED_EXT)
        return true;
    if (extensions.device.VK_EXT_primitives_generated_query and item.* == .VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT)
        return true;
    if (extensions.device.VK_KHR_ray_tracing_maintenance1 and item.* == .VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_BOTTOM_LEVEL_POINTERS_KHR)
        return true;
    if (extensions.device.VK_KHR_ray_tracing_maintenance1 and item.* == .VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SIZE_KHR)
        return true;
    if (extensions.device.VK_EXT_opacity_micromap and item.* == .VK_QUERY_TYPE_MICROMAP_SERIALIZATION_SIZE_EXT)
        return true;
    if (extensions.device.VK_EXT_opacity_micromap and item.* == .VK_QUERY_TYPE_MICROMAP_COMPACTED_SIZE_EXT)
        return true;
    return true;
}

pub fn validate_VkBorderColor(extensions: *const Extensions, item: *const vk.VkBorderColor) bool {
    const min = 0;
    const max = 1000287004;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    if (extensions.device.VK_EXT_custom_border_color and item.* == .VK_BORDER_COLOR_FLOAT_CUSTOM_EXT)
        return true;
    if (extensions.device.VK_EXT_custom_border_color and item.* == .VK_BORDER_COLOR_INT_CUSTOM_EXT)
        return true;
    return true;
}

pub fn validate_VkPipelineBindPoint(extensions: *const Extensions, item: *const vk.VkPipelineBindPoint) bool {
    const min = 0;
    const max = 1000507000;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    if (extensions.device.VK_AMDX_shader_enqueue and item.* == .VK_PIPELINE_BIND_POINT_EXECUTION_GRAPH_AMDX)
        return true;
    if (extensions.device.VK_KHR_ray_tracing_pipeline and item.* == .VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR)
        return true;
    if (extensions.device.VK_HUAWEI_subpass_shading and item.* == .VK_PIPELINE_BIND_POINT_SUBPASS_SHADING_HUAWEI)
        return true;
    if (extensions.device.VK_ARM_data_graph and item.* == .VK_PIPELINE_BIND_POINT_DATA_GRAPH_ARM)
        return true;
    return true;
}

pub fn validate_VkPipelineCacheHeaderVersion(extensions: *const Extensions, item: *const vk.VkPipelineCacheHeaderVersion) bool {
    const min = 1;
    const max = 1000629000;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    if (extensions.device.VK_QCOM_data_graph_model and item.* == .VK_PIPELINE_CACHE_HEADER_VERSION_DATA_GRAPH_QCOM)
        return true;
    return true;
}

pub fn validate_VkPrimitiveTopology(extensions: *const Extensions, item: *const vk.VkPrimitiveTopology) bool {
    const min = 0;
    const max = 10;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkSharingMode(extensions: *const Extensions, item: *const vk.VkSharingMode) bool {
    const min = 0;
    const max = 1;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkIndexType(extensions: *const Extensions, item: *const vk.VkIndexType) bool {
    const min = 0;
    const max = 1000265000;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    if (extensions.device.VK_KHR_acceleration_structure and item.* == .VK_INDEX_TYPE_NONE_KHR)
        return true;
    return true;
}

pub fn validate_VkFilter(extensions: *const Extensions, item: *const vk.VkFilter) bool {
    const min = 0;
    const max = 1000015000;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    if (extensions.device.VK_EXT_filter_cubic and item.* == .VK_FILTER_CUBIC_EXT)
        return true;
    return true;
}

pub fn validate_VkSamplerMipmapMode(extensions: *const Extensions, item: *const vk.VkSamplerMipmapMode) bool {
    const min = 0;
    const max = 1;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkSamplerAddressMode(extensions: *const Extensions, item: *const vk.VkSamplerAddressMode) bool {
    const min = 0;
    const max = 4;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    if (extensions.device.VK_KHR_sampler_mirror_clamp_to_edge and item.* == .VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE)
        return true;
    return true;
}

pub fn validate_VkCompareOp(extensions: *const Extensions, item: *const vk.VkCompareOp) bool {
    const min = 0;
    const max = 7;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkPolygonMode(extensions: *const Extensions, item: *const vk.VkPolygonMode) bool {
    const min = 0;
    const max = 1000153000;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    if (extensions.device.VK_NV_fill_rectangle and item.* == .VK_POLYGON_MODE_FILL_RECTANGLE_NV)
        return true;
    return true;
}

pub fn validate_VkFrontFace(extensions: *const Extensions, item: *const vk.VkFrontFace) bool {
    const min = 0;
    const max = 1;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkBlendFactor(extensions: *const Extensions, item: *const vk.VkBlendFactor) bool {
    const min = 0;
    const max = 18;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkBlendOp(extensions: *const Extensions, item: *const vk.VkBlendOp) bool {
    const min = 0;
    const max = 1000148045;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == .VK_BLEND_OP_ZERO_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == .VK_BLEND_OP_SRC_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == .VK_BLEND_OP_DST_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == .VK_BLEND_OP_SRC_OVER_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == .VK_BLEND_OP_DST_OVER_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == .VK_BLEND_OP_SRC_IN_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == .VK_BLEND_OP_DST_IN_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == .VK_BLEND_OP_SRC_OUT_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == .VK_BLEND_OP_DST_OUT_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == .VK_BLEND_OP_SRC_ATOP_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == .VK_BLEND_OP_DST_ATOP_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == .VK_BLEND_OP_XOR_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == .VK_BLEND_OP_MULTIPLY_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == .VK_BLEND_OP_SCREEN_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == .VK_BLEND_OP_OVERLAY_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == .VK_BLEND_OP_DARKEN_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == .VK_BLEND_OP_LIGHTEN_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == .VK_BLEND_OP_COLORDODGE_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == .VK_BLEND_OP_COLORBURN_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == .VK_BLEND_OP_HARDLIGHT_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == .VK_BLEND_OP_SOFTLIGHT_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == .VK_BLEND_OP_DIFFERENCE_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == .VK_BLEND_OP_EXCLUSION_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == .VK_BLEND_OP_INVERT_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == .VK_BLEND_OP_INVERT_RGB_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == .VK_BLEND_OP_LINEARDODGE_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == .VK_BLEND_OP_LINEARBURN_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == .VK_BLEND_OP_VIVIDLIGHT_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == .VK_BLEND_OP_LINEARLIGHT_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == .VK_BLEND_OP_PINLIGHT_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == .VK_BLEND_OP_HARDMIX_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == .VK_BLEND_OP_HSL_HUE_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == .VK_BLEND_OP_HSL_SATURATION_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == .VK_BLEND_OP_HSL_COLOR_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == .VK_BLEND_OP_HSL_LUMINOSITY_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == .VK_BLEND_OP_PLUS_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == .VK_BLEND_OP_PLUS_CLAMPED_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == .VK_BLEND_OP_PLUS_CLAMPED_ALPHA_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == .VK_BLEND_OP_PLUS_DARKER_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == .VK_BLEND_OP_MINUS_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == .VK_BLEND_OP_MINUS_CLAMPED_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == .VK_BLEND_OP_CONTRAST_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == .VK_BLEND_OP_INVERT_OVG_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == .VK_BLEND_OP_RED_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == .VK_BLEND_OP_GREEN_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == .VK_BLEND_OP_BLUE_EXT)
        return true;
    return true;
}

pub fn validate_VkStencilOp(extensions: *const Extensions, item: *const vk.VkStencilOp) bool {
    const min = 0;
    const max = 7;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkLogicOp(extensions: *const Extensions, item: *const vk.VkLogicOp) bool {
    const min = 0;
    const max = 15;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkInternalAllocationType(extensions: *const Extensions, item: *const vk.VkInternalAllocationType) bool {
    const min = 0;
    const max = 0;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkSystemAllocationScope(extensions: *const Extensions, item: *const vk.VkSystemAllocationScope) bool {
    const min = 0;
    const max = 4;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkPhysicalDeviceType(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceType) bool {
    const min = 0;
    const max = 4;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkVertexInputRate(extensions: *const Extensions, item: *const vk.VkVertexInputRate) bool {
    const min = 0;
    const max = 1;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkFormat(extensions: *const Extensions, item: *const vk.VkFormat) bool {
    const min = 0;
    const max = 1000609013;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    if (extensions.device.VK_IMG_format_pvrtc and item.* == .VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG)
        return true;
    if (extensions.device.VK_IMG_format_pvrtc and item.* == .VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG)
        return true;
    if (extensions.device.VK_IMG_format_pvrtc and item.* == .VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG)
        return true;
    if (extensions.device.VK_IMG_format_pvrtc and item.* == .VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG)
        return true;
    if (extensions.device.VK_IMG_format_pvrtc and item.* == .VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG)
        return true;
    if (extensions.device.VK_IMG_format_pvrtc and item.* == .VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG)
        return true;
    if (extensions.device.VK_IMG_format_pvrtc and item.* == .VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG)
        return true;
    if (extensions.device.VK_IMG_format_pvrtc and item.* == .VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG)
        return true;
    if (extensions.device.VK_ARM_tensors and item.* == .VK_FORMAT_R8_BOOL_ARM)
        return true;
    if (extensions.device.VK_NV_optical_flow and item.* == .VK_FORMAT_R16G16_SFIXED5_NV)
        return true;
    if (extensions.device.VK_ARM_format_pack and item.* == .VK_FORMAT_R10X6_UINT_PACK16_ARM)
        return true;
    if (extensions.device.VK_ARM_format_pack and item.* == .VK_FORMAT_R10X6G10X6_UINT_2PACK16_ARM)
        return true;
    if (extensions.device.VK_ARM_format_pack and item.* == .VK_FORMAT_R10X6G10X6B10X6A10X6_UINT_4PACK16_ARM)
        return true;
    if (extensions.device.VK_ARM_format_pack and item.* == .VK_FORMAT_R12X4_UINT_PACK16_ARM)
        return true;
    if (extensions.device.VK_ARM_format_pack and item.* == .VK_FORMAT_R12X4G12X4_UINT_2PACK16_ARM)
        return true;
    if (extensions.device.VK_ARM_format_pack and item.* == .VK_FORMAT_R12X4G12X4B12X4A12X4_UINT_4PACK16_ARM)
        return true;
    if (extensions.device.VK_ARM_format_pack and item.* == .VK_FORMAT_R14X2_UINT_PACK16_ARM)
        return true;
    if (extensions.device.VK_ARM_format_pack and item.* == .VK_FORMAT_R14X2G14X2_UINT_2PACK16_ARM)
        return true;
    if (extensions.device.VK_ARM_format_pack and item.* == .VK_FORMAT_R14X2G14X2B14X2A14X2_UINT_4PACK16_ARM)
        return true;
    if (extensions.device.VK_ARM_format_pack and item.* == .VK_FORMAT_R14X2_UNORM_PACK16_ARM)
        return true;
    if (extensions.device.VK_ARM_format_pack and item.* == .VK_FORMAT_R14X2G14X2_UNORM_2PACK16_ARM)
        return true;
    if (extensions.device.VK_ARM_format_pack and item.* == .VK_FORMAT_R14X2G14X2B14X2A14X2_UNORM_4PACK16_ARM)
        return true;
    if (extensions.device.VK_ARM_format_pack and item.* == .VK_FORMAT_G14X2_B14X2R14X2_2PLANE_420_UNORM_3PACK16_ARM)
        return true;
    if (extensions.device.VK_ARM_format_pack and item.* == .VK_FORMAT_G14X2_B14X2R14X2_2PLANE_422_UNORM_3PACK16_ARM)
        return true;
    return true;
}

pub fn validate_VkStructureType(extensions: *const Extensions, item: *const vk.VkStructureType) bool {
    const min = 0;
    const max = 1000685000;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    if (extensions.device.VK_KHR_swapchain and item.* == .VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_swapchain and item.* == .VK_STRUCTURE_TYPE_PRESENT_INFO_KHR)
        return true;
    if (extensions.instance.VK_KHR_display and item.* == .VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR)
        return true;
    if (extensions.instance.VK_KHR_display and item.* == .VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_display_swapchain and item.* == .VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR)
        return true;
    if (extensions.instance.VK_KHR_xlib_surface and item.* == .VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR)
        return true;
    if (extensions.instance.VK_KHR_xcb_surface and item.* == .VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR)
        return true;
    if (extensions.instance.VK_KHR_wayland_surface and item.* == .VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR)
        return true;
    if (extensions.instance.VK_KHR_android_surface and item.* == .VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR)
        return true;
    if (extensions.instance.VK_KHR_win32_surface and item.* == .VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR)
        return true;
    if (extensions.instance.VK_EXT_debug_report and item.* == .VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_AMD_rasterization_order and item.* == .VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD)
        return true;
    if (extensions.device.VK_EXT_debug_marker and item.* == .VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_debug_marker and item.* == .VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_debug_marker and item.* == .VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT)
        return true;
    if (extensions.device.VK_KHR_video_queue and item.* == .VK_STRUCTURE_TYPE_VIDEO_PROFILE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_queue and item.* == .VK_STRUCTURE_TYPE_VIDEO_CAPABILITIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_queue and item.* == .VK_STRUCTURE_TYPE_VIDEO_PICTURE_RESOURCE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_queue and item.* == .VK_STRUCTURE_TYPE_VIDEO_SESSION_MEMORY_REQUIREMENTS_KHR)
        return true;
    if (extensions.device.VK_KHR_video_queue and item.* == .VK_STRUCTURE_TYPE_BIND_VIDEO_SESSION_MEMORY_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_queue and item.* == .VK_STRUCTURE_TYPE_VIDEO_SESSION_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_queue and item.* == .VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_queue and item.* == .VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_UPDATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_queue and item.* == .VK_STRUCTURE_TYPE_VIDEO_BEGIN_CODING_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_queue and item.* == .VK_STRUCTURE_TYPE_VIDEO_END_CODING_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_queue and item.* == .VK_STRUCTURE_TYPE_VIDEO_CODING_CONTROL_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_queue and item.* == .VK_STRUCTURE_TYPE_VIDEO_REFERENCE_SLOT_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_queue and item.* == .VK_STRUCTURE_TYPE_QUEUE_FAMILY_VIDEO_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_queue and item.* == .VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_queue and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_FORMAT_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_queue and item.* == .VK_STRUCTURE_TYPE_VIDEO_FORMAT_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_queue and item.* == .VK_STRUCTURE_TYPE_QUEUE_FAMILY_QUERY_RESULT_STATUS_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_decode_queue and item.* == .VK_STRUCTURE_TYPE_VIDEO_DECODE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_decode_queue and item.* == .VK_STRUCTURE_TYPE_VIDEO_DECODE_CAPABILITIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_decode_queue and item.* == .VK_STRUCTURE_TYPE_VIDEO_DECODE_USAGE_INFO_KHR)
        return true;
    if (extensions.device.VK_NV_dedicated_allocation and item.* == .VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV)
        return true;
    if (extensions.device.VK_NV_dedicated_allocation and item.* == .VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV)
        return true;
    if (extensions.device.VK_NV_dedicated_allocation and item.* == .VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV)
        return true;
    if (extensions.device.VK_EXT_transform_feedback and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_transform_feedback and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_transform_feedback and item.* == .VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_NVX_binary_import and item.* == .VK_STRUCTURE_TYPE_CU_MODULE_CREATE_INFO_NVX)
        return true;
    if (extensions.device.VK_NVX_binary_import and item.* == .VK_STRUCTURE_TYPE_CU_FUNCTION_CREATE_INFO_NVX)
        return true;
    if (extensions.device.VK_NVX_binary_import and item.* == .VK_STRUCTURE_TYPE_CU_LAUNCH_INFO_NVX)
        return true;
    if (extensions.device.VK_NVX_binary_import and item.* == .VK_STRUCTURE_TYPE_CU_MODULE_TEXTURING_MODE_CREATE_INFO_NVX)
        return true;
    if (extensions.device.VK_NVX_image_view_handle and item.* == .VK_STRUCTURE_TYPE_IMAGE_VIEW_HANDLE_INFO_NVX)
        return true;
    if (extensions.device.VK_NVX_image_view_handle and item.* == .VK_STRUCTURE_TYPE_IMAGE_VIEW_ADDRESS_PROPERTIES_NVX)
        return true;
    if (extensions.device.VK_KHR_video_encode_h264 and item.* == .VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_CAPABILITIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h264 and item.* == .VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h264 and item.* == .VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h264 and item.* == .VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PICTURE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h264 and item.* == .VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_DPB_SLOT_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h264 and item.* == .VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_NALU_SLICE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h264 and item.* == .VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_GOP_REMAINING_FRAME_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h264 and item.* == .VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PROFILE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h264 and item.* == .VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h264 and item.* == .VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_LAYER_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h264 and item.* == .VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h264 and item.* == .VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_QUALITY_LEVEL_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h264 and item.* == .VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_GET_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h264 and item.* == .VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_FEEDBACK_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h265 and item.* == .VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_CAPABILITIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h265 and item.* == .VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h265 and item.* == .VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h265 and item.* == .VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PICTURE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h265 and item.* == .VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_DPB_SLOT_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h265 and item.* == .VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_NALU_SLICE_SEGMENT_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h265 and item.* == .VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_GOP_REMAINING_FRAME_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h265 and item.* == .VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PROFILE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h265 and item.* == .VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h265 and item.* == .VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_LAYER_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h265 and item.* == .VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h265 and item.* == .VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_QUALITY_LEVEL_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h265 and item.* == .VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_GET_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_h265 and item.* == .VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_FEEDBACK_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_decode_h264 and item.* == .VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_CAPABILITIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_decode_h264 and item.* == .VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PICTURE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_decode_h264 and item.* == .VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PROFILE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_decode_h264 and item.* == .VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_decode_h264 and item.* == .VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_decode_h264 and item.* == .VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_DPB_SLOT_INFO_KHR)
        return true;
    if (extensions.device.VK_AMD_texture_gather_bias_lod and item.* == .VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD)
        return true;
    if (extensions.device.VK_KHR_fragment_shading_rate and item.* == .VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR)
        return true;
    if (extensions.device.VK_EXT_fragment_density_map and item.* == .VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT)
        return true;
    if (extensions.device.VK_AMD_mixed_attachment_samples and item.* == .VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD)
        return true;
    if (extensions.device.VK_NVX_multiview_per_view_attributes and item.* == .VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_NVX)
        return true;
    if (extensions.instance.VK_GGP_stream_descriptor_surface and item.* == .VK_STRUCTURE_TYPE_STREAM_DESCRIPTOR_SURFACE_CREATE_INFO_GGP)
        return true;
    if (extensions.device.VK_NV_corner_sampled_image and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV)
        return true;
    if (extensions.device.VK_NV_private_vendor_info and item.* == .VK_STRUCTURE_TYPE_PRIVATE_VENDOR_INFO_PLACEHOLDER_OFFSET_0_NV)
        return true;
    if (extensions.device.VK_NV_external_memory and item.* == .VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV)
        return true;
    if (extensions.device.VK_NV_external_memory and item.* == .VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV)
        return true;
    if (extensions.device.VK_NV_external_memory_win32 and item.* == .VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV)
        return true;
    if (extensions.device.VK_NV_external_memory_win32 and item.* == .VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV)
        return true;
    if (extensions.device.VK_NV_win32_keyed_mutex and item.* == .VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV)
        return true;
    if (extensions.device.VK_KHR_swapchain and item.* == .VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR)
        return true;
    if (extensions.device.VK_KHR_swapchain and item.* == .VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_device_group and item.* == .VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_swapchain and item.* == .VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_swapchain and item.* == .VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_device_group and item.* == .VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR)
        return true;
    if (extensions.instance.VK_EXT_validation_flags and item.* == .VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT)
        return true;
    if (extensions.instance.VK_NN_vi_surface and item.* == .VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN)
        return true;
    if (extensions.device.VK_EXT_astc_decode_mode and item.* == .VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT)
        return true;
    if (extensions.device.VK_EXT_astc_decode_mode and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT)
        return true;
    if (extensions.device.VK_KHR_external_memory_win32 and item.* == .VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_external_memory_win32 and item.* == .VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_external_memory_win32 and item.* == .VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_external_memory_win32 and item.* == .VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_external_memory_fd and item.* == .VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_external_memory_fd and item.* == .VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_external_memory_fd and item.* == .VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_win32_keyed_mutex and item.* == .VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_external_semaphore_win32 and item.* == .VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_external_semaphore_win32 and item.* == .VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_external_semaphore_win32 and item.* == .VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_external_semaphore_win32 and item.* == .VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_external_semaphore_fd and item.* == .VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_external_semaphore_fd and item.* == .VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR)
        return true;
    if (extensions.device.VK_EXT_conditional_rendering and item.* == .VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_conditional_rendering and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_conditional_rendering and item.* == .VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT)
        return true;
    if (extensions.device.VK_KHR_incremental_present and item.* == .VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR)
        return true;
    if (extensions.device.VK_NV_clip_space_w_scaling and item.* == .VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV)
        return true;
    if (extensions.instance.VK_EXT_display_surface_counter and item.* == .VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT)
        return true;
    if (extensions.device.VK_EXT_display_control and item.* == .VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_display_control and item.* == .VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_display_control and item.* == .VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_display_control and item.* == .VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_GOOGLE_display_timing and item.* == .VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE)
        return true;
    if (extensions.device.VK_NVX_multiview_per_view_attributes and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX)
        return true;
    if (extensions.device.VK_NV_viewport_swizzle and item.* == .VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV)
        return true;
    if (extensions.device.VK_EXT_discard_rectangles and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_discard_rectangles and item.* == .VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_conservative_rasterization and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_conservative_rasterization and item.* == .VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_depth_clip_enable and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_depth_clip_enable and item.* == .VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_hdr_metadata and item.* == .VK_STRUCTURE_TYPE_HDR_METADATA_EXT)
        return true;
    if (extensions.device.VK_IMG_relaxed_line_rasterization and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RELAXED_LINE_RASTERIZATION_FEATURES_IMG)
        return true;
    if (extensions.device.VK_KHR_shared_presentable_image and item.* == .VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR)
        return true;
    if (extensions.device.VK_KHR_external_fence_win32 and item.* == .VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_external_fence_win32 and item.* == .VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_external_fence_win32 and item.* == .VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_external_fence_fd and item.* == .VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_external_fence_fd and item.* == .VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_performance_query and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_performance_query and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_performance_query and item.* == .VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_performance_query and item.* == .VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_performance_query and item.* == .VK_STRUCTURE_TYPE_ACQUIRE_PROFILING_LOCK_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_performance_query and item.* == .VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_KHR)
        return true;
    if (extensions.device.VK_KHR_performance_query and item.* == .VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_DESCRIPTION_KHR)
        return true;
    if (extensions.device.VK_KHR_performance_query and item.* == .VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_RESERVATION_INFO_KHR)
        return true;
    if (extensions.instance.VK_KHR_get_surface_capabilities2 and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR)
        return true;
    if (extensions.instance.VK_KHR_get_surface_capabilities2 and item.* == .VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR)
        return true;
    if (extensions.instance.VK_KHR_get_surface_capabilities2 and item.* == .VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR)
        return true;
    if (extensions.instance.VK_KHR_get_display_properties2 and item.* == .VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR)
        return true;
    if (extensions.instance.VK_KHR_get_display_properties2 and item.* == .VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR)
        return true;
    if (extensions.instance.VK_KHR_get_display_properties2 and item.* == .VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR)
        return true;
    if (extensions.instance.VK_KHR_get_display_properties2 and item.* == .VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR)
        return true;
    if (extensions.instance.VK_KHR_get_display_properties2 and item.* == .VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR)
        return true;
    if (extensions.instance.VK_MVK_ios_surface and item.* == .VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK)
        return true;
    if (extensions.instance.VK_MVK_macos_surface and item.* == .VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK)
        return true;
    if (extensions.instance.VK_EXT_debug_utils and item.* == .VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT)
        return true;
    if (extensions.instance.VK_EXT_debug_utils and item.* == .VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT)
        return true;
    if (extensions.instance.VK_EXT_debug_utils and item.* == .VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT)
        return true;
    if (extensions.instance.VK_EXT_debug_utils and item.* == .VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT)
        return true;
    if (extensions.instance.VK_EXT_debug_utils and item.* == .VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_ANDROID_external_memory_android_hardware_buffer and item.* == .VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID)
        return true;
    if (extensions.device.VK_ANDROID_external_memory_android_hardware_buffer and item.* == .VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID)
        return true;
    if (extensions.device.VK_ANDROID_external_memory_android_hardware_buffer and item.* == .VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID)
        return true;
    if (extensions.device.VK_ANDROID_external_memory_android_hardware_buffer and item.* == .VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID)
        return true;
    if (extensions.device.VK_ANDROID_external_memory_android_hardware_buffer and item.* == .VK_STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID)
        return true;
    if (extensions.device.VK_ANDROID_external_memory_android_hardware_buffer and item.* == .VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID)
        return true;
    if (extensions.device.VK_ANDROID_external_memory_android_hardware_buffer and item.* == .VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_2_ANDROID)
        return true;
    if (extensions.device.VK_AMDX_shader_enqueue and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ENQUEUE_FEATURES_AMDX)
        return true;
    if (extensions.device.VK_AMDX_shader_enqueue and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ENQUEUE_PROPERTIES_AMDX)
        return true;
    if (extensions.device.VK_AMDX_shader_enqueue and item.* == .VK_STRUCTURE_TYPE_EXECUTION_GRAPH_PIPELINE_SCRATCH_SIZE_AMDX)
        return true;
    if (extensions.device.VK_AMDX_shader_enqueue and item.* == .VK_STRUCTURE_TYPE_EXECUTION_GRAPH_PIPELINE_CREATE_INFO_AMDX)
        return true;
    if (extensions.device.VK_AMDX_shader_enqueue and item.* == .VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_NODE_CREATE_INFO_AMDX)
        return true;
    if (extensions.device.VK_KHR_shader_bfloat16 and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_BFLOAT16_FEATURES_KHR)
        return true;
    if (extensions.device.VK_EXT_sample_locations and item.* == .VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_sample_locations and item.* == .VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_sample_locations and item.* == .VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_sample_locations and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_sample_locations and item.* == .VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_blend_operation_advanced and item.* == .VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_NV_fragment_coverage_to_color and item.* == .VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV)
        return true;
    if (extensions.device.VK_KHR_acceleration_structure and item.* == .VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_acceleration_structure and item.* == .VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_acceleration_structure and item.* == .VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_AABBS_DATA_KHR)
        return true;
    if (extensions.device.VK_KHR_acceleration_structure and item.* == .VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR)
        return true;
    if (extensions.device.VK_KHR_acceleration_structure and item.* == .VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR)
        return true;
    if (extensions.device.VK_KHR_acceleration_structure and item.* == .VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR)
        return true;
    if (extensions.device.VK_KHR_acceleration_structure and item.* == .VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR)
        return true;
    if (extensions.device.VK_KHR_acceleration_structure and item.* == .VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_VERSION_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_acceleration_structure and item.* == .VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_acceleration_structure and item.* == .VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_acceleration_structure and item.* == .VK_STRUCTURE_TYPE_COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_acceleration_structure and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_acceleration_structure and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_ray_tracing_pipeline and item.* == .VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_ray_tracing_pipeline and item.* == .VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_acceleration_structure and item.* == .VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_ray_tracing_pipeline and item.* == .VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_INTERFACE_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_acceleration_structure and item.* == .VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR)
        return true;
    if (extensions.device.VK_NV_framebuffer_mixed_samples and item.* == .VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV)
        return true;
    if (extensions.device.VK_NV_shader_sm_builtins and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV)
        return true;
    if (extensions.device.VK_NV_shader_sm_builtins and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV)
        return true;
    if (extensions.device.VK_EXT_image_drm_format_modifier and item.* == .VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT)
        return true;
    if (extensions.device.VK_EXT_image_drm_format_modifier and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_image_drm_format_modifier and item.* == .VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_image_drm_format_modifier and item.* == .VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_image_drm_format_modifier and item.* == .VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_image_drm_format_modifier and item.* == .VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT)
        return true;
    if (extensions.device.VK_EXT_validation_cache and item.* == .VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_validation_cache and item.* == .VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_KHR_portability_subset and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_portability_subset and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_NV_shading_rate_image and item.* == .VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV)
        return true;
    if (extensions.device.VK_NV_shading_rate_image and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV)
        return true;
    if (extensions.device.VK_NV_shading_rate_image and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV)
        return true;
    if (extensions.device.VK_NV_shading_rate_image and item.* == .VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV)
        return true;
    if (extensions.device.VK_NV_ray_tracing and item.* == .VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV)
        return true;
    if (extensions.device.VK_NV_ray_tracing and item.* == .VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV)
        return true;
    if (extensions.device.VK_NV_ray_tracing and item.* == .VK_STRUCTURE_TYPE_GEOMETRY_NV)
        return true;
    if (extensions.device.VK_NV_ray_tracing and item.* == .VK_STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV)
        return true;
    if (extensions.device.VK_NV_ray_tracing and item.* == .VK_STRUCTURE_TYPE_GEOMETRY_AABB_NV)
        return true;
    if (extensions.device.VK_NV_ray_tracing and item.* == .VK_STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV)
        return true;
    if (extensions.device.VK_NV_ray_tracing and item.* == .VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV)
        return true;
    if (extensions.device.VK_NV_ray_tracing and item.* == .VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV)
        return true;
    if (extensions.device.VK_NV_ray_tracing and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV)
        return true;
    if (extensions.device.VK_NV_ray_tracing and item.* == .VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV)
        return true;
    if (extensions.device.VK_NV_ray_tracing and item.* == .VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV)
        return true;
    if (extensions.device.VK_NV_representative_fragment_test and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV)
        return true;
    if (extensions.device.VK_NV_representative_fragment_test and item.* == .VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV)
        return true;
    if (extensions.device.VK_EXT_filter_cubic and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_filter_cubic and item.* == .VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_external_memory_host and item.* == .VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_external_memory_host and item.* == .VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_external_memory_host and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_KHR_shader_clock and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR)
        return true;
    if (extensions.device.VK_AMD_pipeline_compiler_control and item.* == .VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD)
        return true;
    if (extensions.device.VK_KHR_calibrated_timestamps and item.* == .VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_KHR)
        return true;
    if (extensions.device.VK_AMD_shader_core_properties and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD)
        return true;
    if (extensions.device.VK_KHR_video_decode_h265 and item.* == .VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_CAPABILITIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_decode_h265 and item.* == .VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_decode_h265 and item.* == .VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_decode_h265 and item.* == .VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PROFILE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_decode_h265 and item.* == .VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PICTURE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_decode_h265 and item.* == .VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_DPB_SLOT_INFO_KHR)
        return true;
    if (extensions.device.VK_AMD_memory_overallocation_behavior and item.* == .VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD)
        return true;
    if (extensions.device.VK_EXT_vertex_attribute_divisor and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_GGP_frame_token and item.* == .VK_STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP)
        return true;
    if (extensions.device.VK_KHR_compute_shader_derivatives and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_KHR)
        return true;
    if (extensions.device.VK_NV_mesh_shader and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV)
        return true;
    if (extensions.device.VK_NV_mesh_shader and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV)
        return true;
    if (extensions.device.VK_KHR_fragment_shader_barycentric and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR)
        return true;
    if (extensions.device.VK_NV_shader_image_footprint and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV)
        return true;
    if (extensions.device.VK_NV_scissor_exclusive and item.* == .VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV)
        return true;
    if (extensions.device.VK_NV_scissor_exclusive and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV)
        return true;
    if (extensions.device.VK_NV_device_diagnostic_checkpoints and item.* == .VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV)
        return true;
    if (extensions.device.VK_NV_device_diagnostic_checkpoints and item.* == .VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV)
        return true;
    if (extensions.device.VK_EXT_present_timing and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_TIMING_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_present_timing and item.* == .VK_STRUCTURE_TYPE_SWAPCHAIN_TIMING_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_present_timing and item.* == .VK_STRUCTURE_TYPE_SWAPCHAIN_TIME_DOMAIN_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_present_timing and item.* == .VK_STRUCTURE_TYPE_PRESENT_TIMINGS_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_present_timing and item.* == .VK_STRUCTURE_TYPE_PRESENT_TIMING_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_present_timing and item.* == .VK_STRUCTURE_TYPE_PAST_PRESENTATION_TIMING_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_present_timing and item.* == .VK_STRUCTURE_TYPE_PAST_PRESENTATION_TIMING_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_present_timing and item.* == .VK_STRUCTURE_TYPE_PAST_PRESENTATION_TIMING_EXT)
        return true;
    if (extensions.device.VK_EXT_present_timing and item.* == .VK_STRUCTURE_TYPE_PRESENT_TIMING_SURFACE_CAPABILITIES_EXT)
        return true;
    if (extensions.device.VK_EXT_present_timing and item.* == .VK_STRUCTURE_TYPE_SWAPCHAIN_CALIBRATED_TIMESTAMP_INFO_EXT)
        return true;
    if (extensions.device.VK_INTEL_shader_integer_functions2 and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL)
        return true;
    if (extensions.device.VK_INTEL_performance_query and item.* == .VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL)
        return true;
    if (extensions.device.VK_INTEL_performance_query and item.* == .VK_STRUCTURE_TYPE_INITIALIZE_PERFORMANCE_API_INFO_INTEL)
        return true;
    if (extensions.device.VK_INTEL_performance_query and item.* == .VK_STRUCTURE_TYPE_PERFORMANCE_MARKER_INFO_INTEL)
        return true;
    if (extensions.device.VK_INTEL_performance_query and item.* == .VK_STRUCTURE_TYPE_PERFORMANCE_STREAM_MARKER_INFO_INTEL)
        return true;
    if (extensions.device.VK_INTEL_performance_query and item.* == .VK_STRUCTURE_TYPE_PERFORMANCE_OVERRIDE_INFO_INTEL)
        return true;
    if (extensions.device.VK_INTEL_performance_query and item.* == .VK_STRUCTURE_TYPE_PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL)
        return true;
    if (extensions.device.VK_EXT_pci_bus_info and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_AMD_display_native_hdr and item.* == .VK_STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD)
        return true;
    if (extensions.device.VK_AMD_display_native_hdr and item.* == .VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD)
        return true;
    if (extensions.instance.VK_FUCHSIA_imagepipe_surface and item.* == .VK_STRUCTURE_TYPE_IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA)
        return true;
    if (extensions.instance.VK_EXT_metal_surface and item.* == .VK_STRUCTURE_TYPE_METAL_SURFACE_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_fragment_density_map and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_fragment_density_map and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_fragment_density_map and item.* == .VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_KHR_fragment_shading_rate and item.* == .VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_fragment_shading_rate and item.* == .VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_fragment_shading_rate and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_fragment_shading_rate and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_fragment_shading_rate and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR)
        return true;
    if (extensions.device.VK_AMD_shader_core_properties2 and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD)
        return true;
    if (extensions.device.VK_AMD_device_coherent_memory and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD)
        return true;
    if (extensions.device.VK_EXT_shader_image_atomic_int64 and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT)
        return true;
    if (extensions.device.VK_KHR_shader_quad_control and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_QUAD_CONTROL_FEATURES_KHR)
        return true;
    if (extensions.device.VK_EXT_memory_budget and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_memory_priority and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_memory_priority and item.* == .VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT)
        return true;
    if (extensions.instance.VK_KHR_surface_protected_capabilities and item.* == .VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR)
        return true;
    if (extensions.device.VK_NV_dedicated_allocation_image_aliasing and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV)
        return true;
    if (extensions.device.VK_EXT_buffer_device_address and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_buffer_device_address and item.* == .VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT)
        return true;
    if (extensions.instance.VK_EXT_validation_features and item.* == .VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT)
        return true;
    if (extensions.device.VK_KHR_present_wait and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR)
        return true;
    if (extensions.device.VK_NV_cooperative_matrix and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV)
        return true;
    if (extensions.device.VK_NV_cooperative_matrix and item.* == .VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_NV)
        return true;
    if (extensions.device.VK_NV_cooperative_matrix and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV)
        return true;
    if (extensions.device.VK_NV_coverage_reduction_mode and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV)
        return true;
    if (extensions.device.VK_NV_coverage_reduction_mode and item.* == .VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV)
        return true;
    if (extensions.device.VK_NV_coverage_reduction_mode and item.* == .VK_STRUCTURE_TYPE_FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV)
        return true;
    if (extensions.device.VK_EXT_fragment_shader_interlock and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_ycbcr_image_arrays and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_provoking_vertex and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_provoking_vertex and item.* == .VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_provoking_vertex and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_full_screen_exclusive and item.* == .VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_full_screen_exclusive and item.* == .VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_full_screen_exclusive and item.* == .VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT)
        return true;
    if (extensions.instance.VK_EXT_headless_surface and item.* == .VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_shader_atomic_float and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT)
        return true;
    if (extensions.device.VK_KHR_pipeline_executable_properties and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_pipeline_executable_properties and item.* == .VK_STRUCTURE_TYPE_PIPELINE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_pipeline_executable_properties and item.* == .VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_pipeline_executable_properties and item.* == .VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_pipeline_executable_properties and item.* == .VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_STATISTIC_KHR)
        return true;
    if (extensions.device.VK_KHR_pipeline_executable_properties and item.* == .VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR)
        return true;
    if (extensions.device.VK_EXT_map_memory_placed and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_map_memory_placed and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_map_memory_placed and item.* == .VK_STRUCTURE_TYPE_MEMORY_MAP_PLACED_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_shader_atomic_float2 and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT)
        return true;
    if (extensions.instance.VK_KHR_surface_maintenance1 and item.* == .VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_KHR)
        return true;
    if (extensions.instance.VK_KHR_surface_maintenance1 and item.* == .VK_STRUCTURE_TYPE_SURFACE_PRESENT_SCALING_CAPABILITIES_KHR)
        return true;
    if (extensions.instance.VK_KHR_surface_maintenance1 and item.* == .VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_COMPATIBILITY_KHR)
        return true;
    if (extensions.device.VK_KHR_swapchain_maintenance1 and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_swapchain_maintenance1 and item.* == .VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_swapchain_maintenance1 and item.* == .VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODES_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_swapchain_maintenance1 and item.* == .VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_swapchain_maintenance1 and item.* == .VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_SCALING_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_swapchain_maintenance1 and item.* == .VK_STRUCTURE_TYPE_RELEASE_SWAPCHAIN_IMAGES_INFO_KHR)
        return true;
    if (extensions.device.VK_NV_device_generated_commands and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV)
        return true;
    if (extensions.device.VK_NV_device_generated_commands and item.* == .VK_STRUCTURE_TYPE_GRAPHICS_SHADER_GROUP_CREATE_INFO_NV)
        return true;
    if (extensions.device.VK_NV_device_generated_commands and item.* == .VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV)
        return true;
    if (extensions.device.VK_NV_device_generated_commands and item.* == .VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_NV)
        return true;
    if (extensions.device.VK_NV_device_generated_commands and item.* == .VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NV)
        return true;
    if (extensions.device.VK_NV_device_generated_commands and item.* == .VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_NV)
        return true;
    if (extensions.device.VK_NV_device_generated_commands and item.* == .VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_NV)
        return true;
    if (extensions.device.VK_NV_device_generated_commands and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV)
        return true;
    if (extensions.device.VK_NV_inherited_viewport_scissor and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV)
        return true;
    if (extensions.device.VK_NV_inherited_viewport_scissor and item.* == .VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_VIEWPORT_SCISSOR_INFO_NV)
        return true;
    if (extensions.device.VK_EXT_texel_buffer_alignment and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT)
        return true;
    if (extensions.device.VK_QCOM_render_pass_transform and item.* == .VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM)
        return true;
    if (extensions.device.VK_QCOM_render_pass_transform and item.* == .VK_STRUCTURE_TYPE_RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM)
        return true;
    if (extensions.device.VK_EXT_depth_bias_control and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_BIAS_CONTROL_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_depth_bias_control and item.* == .VK_STRUCTURE_TYPE_DEPTH_BIAS_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_depth_bias_control and item.* == .VK_STRUCTURE_TYPE_DEPTH_BIAS_REPRESENTATION_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_device_memory_report and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_device_memory_report and item.* == .VK_STRUCTURE_TYPE_DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_device_memory_report and item.* == .VK_STRUCTURE_TYPE_DEVICE_MEMORY_REPORT_CALLBACK_DATA_EXT)
        return true;
    if (extensions.device.VK_KHR_robustness2 and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_robustness2 and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_EXT_custom_border_color and item.* == .VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_custom_border_color and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_custom_border_color and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT)
        return true;
    if (extensions.device.VK_KHR_pipeline_library and item.* == .VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_NV_present_barrier and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_BARRIER_FEATURES_NV)
        return true;
    if (extensions.device.VK_NV_present_barrier and item.* == .VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_BARRIER_NV)
        return true;
    if (extensions.device.VK_NV_present_barrier and item.* == .VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_BARRIER_CREATE_INFO_NV)
        return true;
    if (extensions.device.VK_KHR_present_id and item.* == .VK_STRUCTURE_TYPE_PRESENT_ID_KHR)
        return true;
    if (extensions.device.VK_KHR_present_id and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_queue and item.* == .VK_STRUCTURE_TYPE_VIDEO_ENCODE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_queue and item.* == .VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_queue and item.* == .VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_LAYER_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_queue and item.* == .VK_STRUCTURE_TYPE_VIDEO_ENCODE_CAPABILITIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_queue and item.* == .VK_STRUCTURE_TYPE_VIDEO_ENCODE_USAGE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_queue and item.* == .VK_STRUCTURE_TYPE_QUERY_POOL_VIDEO_ENCODE_FEEDBACK_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_queue and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_queue and item.* == .VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_queue and item.* == .VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_queue and item.* == .VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_GET_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_queue and item.* == .VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_FEEDBACK_INFO_KHR)
        return true;
    if (extensions.device.VK_NV_device_diagnostics_config and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV)
        return true;
    if (extensions.device.VK_NV_device_diagnostics_config and item.* == .VK_STRUCTURE_TYPE_DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV)
        return true;
    if (extensions.device.VK_NV_cuda_kernel_launch and item.* == .VK_STRUCTURE_TYPE_CUDA_MODULE_CREATE_INFO_NV)
        return true;
    if (extensions.device.VK_NV_cuda_kernel_launch and item.* == .VK_STRUCTURE_TYPE_CUDA_FUNCTION_CREATE_INFO_NV)
        return true;
    if (extensions.device.VK_NV_cuda_kernel_launch and item.* == .VK_STRUCTURE_TYPE_CUDA_LAUNCH_INFO_NV)
        return true;
    if (extensions.device.VK_NV_cuda_kernel_launch and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUDA_KERNEL_LAUNCH_FEATURES_NV)
        return true;
    if (extensions.device.VK_NV_cuda_kernel_launch and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUDA_KERNEL_LAUNCH_PROPERTIES_NV)
        return true;
    if (extensions.device.VK_KHR_object_refresh and item.* == .VK_STRUCTURE_TYPE_REFRESH_OBJECT_LIST_KHR)
        return true;
    if (extensions.device.VK_QCOM_tile_shading and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_SHADING_FEATURES_QCOM)
        return true;
    if (extensions.device.VK_QCOM_tile_shading and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_SHADING_PROPERTIES_QCOM)
        return true;
    if (extensions.device.VK_QCOM_tile_shading and item.* == .VK_STRUCTURE_TYPE_RENDER_PASS_TILE_SHADING_CREATE_INFO_QCOM)
        return true;
    if (extensions.device.VK_QCOM_tile_shading and item.* == .VK_STRUCTURE_TYPE_PER_TILE_BEGIN_INFO_QCOM)
        return true;
    if (extensions.device.VK_QCOM_tile_shading and item.* == .VK_STRUCTURE_TYPE_PER_TILE_END_INFO_QCOM)
        return true;
    if (extensions.device.VK_QCOM_tile_shading and item.* == .VK_STRUCTURE_TYPE_DISPATCH_TILE_INFO_QCOM)
        return true;
    if (extensions.device.VK_NV_low_latency and item.* == .VK_STRUCTURE_TYPE_QUERY_LOW_LATENCY_SUPPORT_NV)
        return true;
    if (extensions.device.VK_EXT_metal_objects and item.* == .VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_metal_objects and item.* == .VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECTS_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_metal_objects and item.* == .VK_STRUCTURE_TYPE_EXPORT_METAL_DEVICE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_metal_objects and item.* == .VK_STRUCTURE_TYPE_EXPORT_METAL_COMMAND_QUEUE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_metal_objects and item.* == .VK_STRUCTURE_TYPE_EXPORT_METAL_BUFFER_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_metal_objects and item.* == .VK_STRUCTURE_TYPE_IMPORT_METAL_BUFFER_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_metal_objects and item.* == .VK_STRUCTURE_TYPE_EXPORT_METAL_TEXTURE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_metal_objects and item.* == .VK_STRUCTURE_TYPE_IMPORT_METAL_TEXTURE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_metal_objects and item.* == .VK_STRUCTURE_TYPE_EXPORT_METAL_IO_SURFACE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_metal_objects and item.* == .VK_STRUCTURE_TYPE_IMPORT_METAL_IO_SURFACE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_metal_objects and item.* == .VK_STRUCTURE_TYPE_EXPORT_METAL_SHARED_EVENT_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_metal_objects and item.* == .VK_STRUCTURE_TYPE_IMPORT_METAL_SHARED_EVENT_INFO_EXT)
        return true;
    if (extensions.device.VK_NV_device_diagnostic_checkpoints and item.* == .VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV)
        return true;
    if (extensions.device.VK_NV_device_diagnostic_checkpoints and item.* == .VK_STRUCTURE_TYPE_CHECKPOINT_DATA_2_NV)
        return true;
    if (extensions.device.VK_EXT_descriptor_buffer and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_descriptor_buffer and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_DENSITY_MAP_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_descriptor_buffer and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_descriptor_buffer and item.* == .VK_STRUCTURE_TYPE_DESCRIPTOR_ADDRESS_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_descriptor_buffer and item.* == .VK_STRUCTURE_TYPE_DESCRIPTOR_GET_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_descriptor_buffer and item.* == .VK_STRUCTURE_TYPE_BUFFER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_descriptor_buffer and item.* == .VK_STRUCTURE_TYPE_IMAGE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_descriptor_buffer and item.* == .VK_STRUCTURE_TYPE_IMAGE_VIEW_CAPTURE_DESCRIPTOR_DATA_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_descriptor_buffer and item.* == .VK_STRUCTURE_TYPE_SAMPLER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_descriptor_buffer and item.* == .VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_descriptor_buffer and item.* == .VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_descriptor_buffer and item.* == .VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_descriptor_buffer and item.* == .VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_PUSH_DESCRIPTOR_BUFFER_HANDLE_EXT)
        return true;
    if (extensions.device.VK_EXT_graphics_pipeline_library and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_graphics_pipeline_library and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_graphics_pipeline_library and item.* == .VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_LIBRARY_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_AMD_shader_early_and_late_fragment_tests and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_FEATURES_AMD)
        return true;
    if (extensions.device.VK_KHR_fragment_shader_barycentric and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_shader_subgroup_uniform_control_flow and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR)
        return true;
    if (extensions.device.VK_NV_fragment_shading_rate_enums and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV)
        return true;
    if (extensions.device.VK_NV_fragment_shading_rate_enums and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV)
        return true;
    if (extensions.device.VK_NV_fragment_shading_rate_enums and item.* == .VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV)
        return true;
    if (extensions.device.VK_NV_ray_tracing_motion_blur and item.* == .VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_MOTION_TRIANGLES_DATA_NV)
        return true;
    if (extensions.device.VK_NV_ray_tracing_motion_blur and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV)
        return true;
    if (extensions.device.VK_NV_ray_tracing_motion_blur and item.* == .VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MOTION_INFO_NV)
        return true;
    if (extensions.device.VK_EXT_mesh_shader and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_mesh_shader and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_ycbcr_2plane_444_formats and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_fragment_density_map2 and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_fragment_density_map2 and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_QCOM_rotated_copy_commands and item.* == .VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM)
        return true;
    if (extensions.device.VK_KHR_workgroup_memory_explicit_layout and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR)
        return true;
    if (extensions.device.VK_EXT_image_compression_control and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_image_compression_control and item.* == .VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT)
        return true;
    if (extensions.device.VK_EXT_image_compression_control and item.* == .VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_attachment_feedback_loop_layout and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_4444_formats and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_device_fault and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FAULT_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_device_fault and item.* == .VK_STRUCTURE_TYPE_DEVICE_FAULT_COUNTS_EXT)
        return true;
    if (extensions.device.VK_EXT_device_fault and item.* == .VK_STRUCTURE_TYPE_DEVICE_FAULT_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_rasterization_order_attachment_access and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_rgba10x6_formats and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT)
        return true;
    if (extensions.instance.VK_EXT_directfb_surface and item.* == .VK_STRUCTURE_TYPE_DIRECTFB_SURFACE_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_KHR_ray_tracing_pipeline and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_ray_tracing_pipeline and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_ray_query and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR)
        return true;
    if (extensions.device.VK_EXT_mutable_descriptor_type and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_mutable_descriptor_type and item.* == .VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_vertex_input_dynamic_state and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_vertex_input_dynamic_state and item.* == .VK_STRUCTURE_TYPE_VERTEX_INPUT_BINDING_DESCRIPTION_2_EXT)
        return true;
    if (extensions.device.VK_EXT_vertex_input_dynamic_state and item.* == .VK_STRUCTURE_TYPE_VERTEX_INPUT_ATTRIBUTE_DESCRIPTION_2_EXT)
        return true;
    if (extensions.device.VK_EXT_physical_device_drm and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRM_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_device_address_binding_report and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ADDRESS_BINDING_REPORT_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_device_address_binding_report and item.* == .VK_STRUCTURE_TYPE_DEVICE_ADDRESS_BINDING_CALLBACK_DATA_EXT)
        return true;
    if (extensions.device.VK_EXT_depth_clip_control and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_depth_clip_control and item.* == .VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLIP_CONTROL_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_primitive_topology_list_restart and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT)
        return true;
    if (extensions.device.VK_KHR_present_mode_fifo_latest_ready and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_MODE_FIFO_LATEST_READY_FEATURES_KHR)
        return true;
    if (extensions.device.VK_FUCHSIA_external_memory and item.* == .VK_STRUCTURE_TYPE_IMPORT_MEMORY_ZIRCON_HANDLE_INFO_FUCHSIA)
        return true;
    if (extensions.device.VK_FUCHSIA_external_memory and item.* == .VK_STRUCTURE_TYPE_MEMORY_ZIRCON_HANDLE_PROPERTIES_FUCHSIA)
        return true;
    if (extensions.device.VK_FUCHSIA_external_memory and item.* == .VK_STRUCTURE_TYPE_MEMORY_GET_ZIRCON_HANDLE_INFO_FUCHSIA)
        return true;
    if (extensions.device.VK_FUCHSIA_external_semaphore and item.* == .VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_ZIRCON_HANDLE_INFO_FUCHSIA)
        return true;
    if (extensions.device.VK_FUCHSIA_external_semaphore and item.* == .VK_STRUCTURE_TYPE_SEMAPHORE_GET_ZIRCON_HANDLE_INFO_FUCHSIA)
        return true;
    if (extensions.device.VK_FUCHSIA_buffer_collection and item.* == .VK_STRUCTURE_TYPE_BUFFER_COLLECTION_CREATE_INFO_FUCHSIA)
        return true;
    if (extensions.device.VK_FUCHSIA_buffer_collection and item.* == .VK_STRUCTURE_TYPE_IMPORT_MEMORY_BUFFER_COLLECTION_FUCHSIA)
        return true;
    if (extensions.device.VK_FUCHSIA_buffer_collection and item.* == .VK_STRUCTURE_TYPE_BUFFER_COLLECTION_IMAGE_CREATE_INFO_FUCHSIA)
        return true;
    if (extensions.device.VK_FUCHSIA_buffer_collection and item.* == .VK_STRUCTURE_TYPE_BUFFER_COLLECTION_PROPERTIES_FUCHSIA)
        return true;
    if (extensions.device.VK_FUCHSIA_buffer_collection and item.* == .VK_STRUCTURE_TYPE_BUFFER_CONSTRAINTS_INFO_FUCHSIA)
        return true;
    if (extensions.device.VK_FUCHSIA_buffer_collection and item.* == .VK_STRUCTURE_TYPE_BUFFER_COLLECTION_BUFFER_CREATE_INFO_FUCHSIA)
        return true;
    if (extensions.device.VK_FUCHSIA_buffer_collection and item.* == .VK_STRUCTURE_TYPE_IMAGE_CONSTRAINTS_INFO_FUCHSIA)
        return true;
    if (extensions.device.VK_FUCHSIA_buffer_collection and item.* == .VK_STRUCTURE_TYPE_IMAGE_FORMAT_CONSTRAINTS_INFO_FUCHSIA)
        return true;
    if (extensions.device.VK_FUCHSIA_buffer_collection and item.* == .VK_STRUCTURE_TYPE_SYSMEM_COLOR_SPACE_FUCHSIA)
        return true;
    if (extensions.device.VK_FUCHSIA_buffer_collection and item.* == .VK_STRUCTURE_TYPE_BUFFER_COLLECTION_CONSTRAINTS_INFO_FUCHSIA)
        return true;
    if (extensions.device.VK_HUAWEI_subpass_shading and item.* == .VK_STRUCTURE_TYPE_SUBPASS_SHADING_PIPELINE_CREATE_INFO_HUAWEI)
        return true;
    if (extensions.device.VK_HUAWEI_subpass_shading and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI)
        return true;
    if (extensions.device.VK_HUAWEI_subpass_shading and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_PROPERTIES_HUAWEI)
        return true;
    if (extensions.device.VK_HUAWEI_invocation_mask and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI)
        return true;
    if (extensions.device.VK_NV_external_memory_rdma and item.* == .VK_STRUCTURE_TYPE_MEMORY_GET_REMOTE_ADDRESS_INFO_NV)
        return true;
    if (extensions.device.VK_NV_external_memory_rdma and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_RDMA_FEATURES_NV)
        return true;
    if (extensions.device.VK_EXT_pipeline_properties and item.* == .VK_STRUCTURE_TYPE_PIPELINE_PROPERTIES_IDENTIFIER_EXT)
        return true;
    if (extensions.device.VK_EXT_pipeline_properties and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROPERTIES_FEATURES_EXT)
        return true;
    if (extensions.device.VK_NV_external_sci_sync and item.* == .VK_STRUCTURE_TYPE_IMPORT_FENCE_SCI_SYNC_INFO_NV)
        return true;
    if (extensions.device.VK_NV_external_sci_sync and item.* == .VK_STRUCTURE_TYPE_EXPORT_FENCE_SCI_SYNC_INFO_NV)
        return true;
    if (extensions.device.VK_NV_external_sci_sync and item.* == .VK_STRUCTURE_TYPE_FENCE_GET_SCI_SYNC_INFO_NV)
        return true;
    if (extensions.device.VK_NV_external_sci_sync and item.* == .VK_STRUCTURE_TYPE_SCI_SYNC_ATTRIBUTES_INFO_NV)
        return true;
    if (extensions.device.VK_NV_external_sci_sync and item.* == .VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_SCI_SYNC_INFO_NV)
        return true;
    if (extensions.device.VK_NV_external_sci_sync and item.* == .VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_SCI_SYNC_INFO_NV)
        return true;
    if (extensions.device.VK_NV_external_sci_sync and item.* == .VK_STRUCTURE_TYPE_SEMAPHORE_GET_SCI_SYNC_INFO_NV)
        return true;
    if (extensions.device.VK_NV_external_sci_sync and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SCI_SYNC_FEATURES_NV)
        return true;
    if (extensions.device.VK_NV_external_memory_sci_buf and item.* == .VK_STRUCTURE_TYPE_IMPORT_MEMORY_SCI_BUF_INFO_NV)
        return true;
    if (extensions.device.VK_NV_external_memory_sci_buf and item.* == .VK_STRUCTURE_TYPE_EXPORT_MEMORY_SCI_BUF_INFO_NV)
        return true;
    if (extensions.device.VK_NV_external_memory_sci_buf and item.* == .VK_STRUCTURE_TYPE_MEMORY_GET_SCI_BUF_INFO_NV)
        return true;
    if (extensions.device.VK_NV_external_memory_sci_buf and item.* == .VK_STRUCTURE_TYPE_MEMORY_SCI_BUF_PROPERTIES_NV)
        return true;
    if (extensions.device.VK_NV_external_memory_sci_buf and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_SCI_BUF_FEATURES_NV)
        return true;
    if (extensions.device.VK_EXT_frame_boundary and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAME_BOUNDARY_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_frame_boundary and item.* == .VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT)
        return true;
    if (extensions.device.VK_EXT_multisampled_render_to_single_sampled and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_multisampled_render_to_single_sampled and item.* == .VK_STRUCTURE_TYPE_SUBPASS_RESOLVE_PERFORMANCE_QUERY_EXT)
        return true;
    if (extensions.device.VK_EXT_multisampled_render_to_single_sampled and item.* == .VK_STRUCTURE_TYPE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state2 and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT)
        return true;
    if (extensions.instance.VK_QNX_screen_surface and item.* == .VK_STRUCTURE_TYPE_SCREEN_SURFACE_CREATE_INFO_QNX)
        return true;
    if (extensions.device.VK_EXT_color_write_enable and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_color_write_enable and item.* == .VK_STRUCTURE_TYPE_PIPELINE_COLOR_WRITE_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_primitives_generated_query and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT)
        return true;
    if (extensions.device.VK_KHR_ray_tracing_maintenance1 and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_shader_untyped_pointers and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_UNTYPED_POINTERS_FEATURES_KHR)
        return true;
    if (extensions.device.VK_VALVE_video_encode_rgb_conversion and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_RGB_CONVERSION_FEATURES_VALVE)
        return true;
    if (extensions.device.VK_VALVE_video_encode_rgb_conversion and item.* == .VK_STRUCTURE_TYPE_VIDEO_ENCODE_RGB_CONVERSION_CAPABILITIES_VALVE)
        return true;
    if (extensions.device.VK_VALVE_video_encode_rgb_conversion and item.* == .VK_STRUCTURE_TYPE_VIDEO_ENCODE_PROFILE_RGB_CONVERSION_INFO_VALVE)
        return true;
    if (extensions.device.VK_VALVE_video_encode_rgb_conversion and item.* == .VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_RGB_CONVERSION_CREATE_INFO_VALVE)
        return true;
    if (extensions.device.VK_EXT_image_view_min_lod and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_image_view_min_lod and item.* == .VK_STRUCTURE_TYPE_IMAGE_VIEW_MIN_LOD_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_multi_draw and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_multi_draw and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_image_2d_view_of_3d and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_shader_tile_image and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_shader_tile_image and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_opacity_micromap and item.* == .VK_STRUCTURE_TYPE_MICROMAP_BUILD_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_opacity_micromap and item.* == .VK_STRUCTURE_TYPE_MICROMAP_VERSION_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_opacity_micromap and item.* == .VK_STRUCTURE_TYPE_COPY_MICROMAP_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_opacity_micromap and item.* == .VK_STRUCTURE_TYPE_COPY_MICROMAP_TO_MEMORY_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_opacity_micromap and item.* == .VK_STRUCTURE_TYPE_COPY_MEMORY_TO_MICROMAP_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_opacity_micromap and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_opacity_micromap and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_opacity_micromap and item.* == .VK_STRUCTURE_TYPE_MICROMAP_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_opacity_micromap and item.* == .VK_STRUCTURE_TYPE_MICROMAP_BUILD_SIZES_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_opacity_micromap and item.* == .VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_OPACITY_MICROMAP_EXT)
        return true;
    if (extensions.device.VK_NV_displacement_micromap and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISPLACEMENT_MICROMAP_FEATURES_NV)
        return true;
    if (extensions.device.VK_NV_displacement_micromap and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISPLACEMENT_MICROMAP_PROPERTIES_NV)
        return true;
    if (extensions.device.VK_NV_displacement_micromap and item.* == .VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_DISPLACEMENT_MICROMAP_NV)
        return true;
    if (extensions.device.VK_HUAWEI_cluster_culling_shader and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_FEATURES_HUAWEI)
        return true;
    if (extensions.device.VK_HUAWEI_cluster_culling_shader and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_PROPERTIES_HUAWEI)
        return true;
    if (extensions.device.VK_HUAWEI_cluster_culling_shader and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_VRS_FEATURES_HUAWEI)
        return true;
    if (extensions.device.VK_EXT_border_color_swizzle and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_border_color_swizzle and item.* == .VK_STRUCTURE_TYPE_SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_pageable_device_local_memory and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT)
        return true;
    if (extensions.device.VK_ARM_shader_core_properties and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_ARM)
        return true;
    if (extensions.device.VK_ARM_scheduling_controls and item.* == .VK_STRUCTURE_TYPE_DEVICE_QUEUE_SHADER_CORE_CONTROL_CREATE_INFO_ARM)
        return true;
    if (extensions.device.VK_ARM_scheduling_controls and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_FEATURES_ARM)
        return true;
    if (extensions.device.VK_ARM_scheduling_controls and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_PROPERTIES_ARM)
        return true;
    if (extensions.device.VK_EXT_image_sliced_view_of_3d and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_SLICED_VIEW_OF_3D_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_image_sliced_view_of_3d and item.* == .VK_STRUCTURE_TYPE_IMAGE_VIEW_SLICED_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_VALVE_descriptor_set_host_mapping and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE)
        return true;
    if (extensions.device.VK_VALVE_descriptor_set_host_mapping and item.* == .VK_STRUCTURE_TYPE_DESCRIPTOR_SET_BINDING_REFERENCE_VALVE)
        return true;
    if (extensions.device.VK_VALVE_descriptor_set_host_mapping and item.* == .VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_HOST_MAPPING_INFO_VALVE)
        return true;
    if (extensions.device.VK_KHR_depth_clamp_zero_one and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_KHR)
        return true;
    if (extensions.device.VK_EXT_non_seamless_cube_map and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT)
        return true;
    if (extensions.device.VK_ARM_render_pass_striped and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_FEATURES_ARM)
        return true;
    if (extensions.device.VK_ARM_render_pass_striped and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_PROPERTIES_ARM)
        return true;
    if (extensions.device.VK_ARM_render_pass_striped and item.* == .VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_BEGIN_INFO_ARM)
        return true;
    if (extensions.device.VK_ARM_render_pass_striped and item.* == .VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_INFO_ARM)
        return true;
    if (extensions.device.VK_ARM_render_pass_striped and item.* == .VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_SUBMIT_INFO_ARM)
        return true;
    if (extensions.device.VK_EXT_fragment_density_map_offset and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_fragment_density_map_offset and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_fragment_density_map_offset and item.* == .VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_EXT)
        return true;
    if (extensions.device.VK_NV_copy_memory_indirect and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_FEATURES_NV)
        return true;
    if (extensions.device.VK_KHR_copy_memory_indirect and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_EXT_memory_decompression and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_memory_decompression and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_NV_device_generated_commands_compute and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_COMPUTE_FEATURES_NV)
        return true;
    if (extensions.device.VK_NV_device_generated_commands_compute and item.* == .VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_INDIRECT_BUFFER_INFO_NV)
        return true;
    if (extensions.device.VK_NV_device_generated_commands_compute and item.* == .VK_STRUCTURE_TYPE_PIPELINE_INDIRECT_DEVICE_ADDRESS_INFO_NV)
        return true;
    if (extensions.device.VK_NV_ray_tracing_linear_swept_spheres and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_LINEAR_SWEPT_SPHERES_FEATURES_NV)
        return true;
    if (extensions.device.VK_NV_ray_tracing_linear_swept_spheres and item.* == .VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_LINEAR_SWEPT_SPHERES_DATA_NV)
        return true;
    if (extensions.device.VK_NV_ray_tracing_linear_swept_spheres and item.* == .VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_SPHERES_DATA_NV)
        return true;
    if (extensions.device.VK_NV_linear_color_attachment and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINEAR_COLOR_ATTACHMENT_FEATURES_NV)
        return true;
    if (extensions.device.VK_KHR_shader_maximal_reconvergence and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MAXIMAL_RECONVERGENCE_FEATURES_KHR)
        return true;
    if (extensions.instance.VK_EXT_application_parameters and item.* == .VK_STRUCTURE_TYPE_APPLICATION_PARAMETERS_EXT)
        return true;
    if (extensions.device.VK_EXT_image_compression_control_swapchain and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT)
        return true;
    if (extensions.device.VK_QCOM_image_processing and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_FEATURES_QCOM)
        return true;
    if (extensions.device.VK_QCOM_image_processing and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_PROPERTIES_QCOM)
        return true;
    if (extensions.device.VK_QCOM_image_processing and item.* == .VK_STRUCTURE_TYPE_IMAGE_VIEW_SAMPLE_WEIGHT_CREATE_INFO_QCOM)
        return true;
    if (extensions.device.VK_EXT_nested_command_buffer and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_nested_command_buffer and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_OHOS_external_memory and item.* == .VK_STRUCTURE_TYPE_NATIVE_BUFFER_USAGE_OHOS)
        return true;
    if (extensions.device.VK_OHOS_external_memory and item.* == .VK_STRUCTURE_TYPE_NATIVE_BUFFER_PROPERTIES_OHOS)
        return true;
    if (extensions.device.VK_OHOS_external_memory and item.* == .VK_STRUCTURE_TYPE_NATIVE_BUFFER_FORMAT_PROPERTIES_OHOS)
        return true;
    if (extensions.device.VK_OHOS_external_memory and item.* == .VK_STRUCTURE_TYPE_IMPORT_NATIVE_BUFFER_INFO_OHOS)
        return true;
    if (extensions.device.VK_OHOS_external_memory and item.* == .VK_STRUCTURE_TYPE_MEMORY_GET_NATIVE_BUFFER_INFO_OHOS)
        return true;
    if (extensions.device.VK_OHOS_external_memory and item.* == .VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_OHOS)
        return true;
    if (extensions.device.VK_EXT_external_memory_acquire_unmodified and item.* == .VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT)
        return true;
    if (extensions.device.VK_OHOS_native_buffer and item.* == .VK_STRUCTURE_TYPE_NATIVE_BUFFER_OHOS)
        return true;
    if (extensions.device.VK_OHOS_native_buffer and item.* == .VK_STRUCTURE_TYPE_SWAPCHAIN_IMAGE_CREATE_INFO_OHOS)
        return true;
    if (extensions.device.VK_OHOS_native_buffer and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENTATION_PROPERTIES_OHOS)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_subpass_merge_feedback and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_subpass_merge_feedback and item.* == .VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_CONTROL_EXT)
        return true;
    if (extensions.device.VK_EXT_subpass_merge_feedback and item.* == .VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_FEEDBACK_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_subpass_merge_feedback and item.* == .VK_STRUCTURE_TYPE_RENDER_PASS_SUBPASS_FEEDBACK_CREATE_INFO_EXT)
        return true;
    if (extensions.instance.VK_LUNARG_direct_driver_loading and item.* == .VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_INFO_LUNARG)
        return true;
    if (extensions.instance.VK_LUNARG_direct_driver_loading and item.* == .VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_LIST_LUNARG)
        return true;
    if (extensions.device.VK_ARM_tensors and item.* == .VK_STRUCTURE_TYPE_TENSOR_CREATE_INFO_ARM)
        return true;
    if (extensions.device.VK_ARM_tensors and item.* == .VK_STRUCTURE_TYPE_TENSOR_VIEW_CREATE_INFO_ARM)
        return true;
    if (extensions.device.VK_ARM_tensors and item.* == .VK_STRUCTURE_TYPE_BIND_TENSOR_MEMORY_INFO_ARM)
        return true;
    if (extensions.device.VK_ARM_tensors and item.* == .VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_TENSOR_ARM)
        return true;
    if (extensions.device.VK_ARM_tensors and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TENSOR_PROPERTIES_ARM)
        return true;
    if (extensions.device.VK_ARM_tensors and item.* == .VK_STRUCTURE_TYPE_TENSOR_FORMAT_PROPERTIES_ARM)
        return true;
    if (extensions.device.VK_ARM_tensors and item.* == .VK_STRUCTURE_TYPE_TENSOR_DESCRIPTION_ARM)
        return true;
    if (extensions.device.VK_ARM_tensors and item.* == .VK_STRUCTURE_TYPE_TENSOR_MEMORY_REQUIREMENTS_INFO_ARM)
        return true;
    if (extensions.device.VK_ARM_tensors and item.* == .VK_STRUCTURE_TYPE_TENSOR_MEMORY_BARRIER_ARM)
        return true;
    if (extensions.device.VK_ARM_tensors and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TENSOR_FEATURES_ARM)
        return true;
    if (extensions.device.VK_ARM_tensors and item.* == .VK_STRUCTURE_TYPE_DEVICE_TENSOR_MEMORY_REQUIREMENTS_ARM)
        return true;
    if (extensions.device.VK_ARM_tensors and item.* == .VK_STRUCTURE_TYPE_COPY_TENSOR_INFO_ARM)
        return true;
    if (extensions.device.VK_ARM_tensors and item.* == .VK_STRUCTURE_TYPE_TENSOR_COPY_ARM)
        return true;
    if (extensions.device.VK_ARM_tensors and item.* == .VK_STRUCTURE_TYPE_TENSOR_DEPENDENCY_INFO_ARM)
        return true;
    if (extensions.device.VK_ARM_tensors and item.* == .VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_TENSOR_ARM)
        return true;
    if (extensions.device.VK_ARM_tensors and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_TENSOR_INFO_ARM)
        return true;
    if (extensions.device.VK_ARM_tensors and item.* == .VK_STRUCTURE_TYPE_EXTERNAL_TENSOR_PROPERTIES_ARM)
        return true;
    if (extensions.device.VK_ARM_tensors and item.* == .VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_TENSOR_CREATE_INFO_ARM)
        return true;
    if (extensions.device.VK_ARM_tensors and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_TENSOR_FEATURES_ARM)
        return true;
    if (extensions.device.VK_ARM_tensors and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_TENSOR_PROPERTIES_ARM)
        return true;
    if (extensions.device.VK_ARM_tensors and item.* == .VK_STRUCTURE_TYPE_DESCRIPTOR_GET_TENSOR_INFO_ARM)
        return true;
    if (extensions.device.VK_ARM_tensors and item.* == .VK_STRUCTURE_TYPE_TENSOR_CAPTURE_DESCRIPTOR_DATA_INFO_ARM)
        return true;
    if (extensions.device.VK_ARM_tensors and item.* == .VK_STRUCTURE_TYPE_TENSOR_VIEW_CAPTURE_DESCRIPTOR_DATA_INFO_ARM)
        return true;
    if (extensions.device.VK_ARM_tensors and item.* == .VK_STRUCTURE_TYPE_FRAME_BOUNDARY_TENSORS_ARM)
        return true;
    if (extensions.device.VK_EXT_shader_module_identifier and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_shader_module_identifier and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_shader_module_identifier and item.* == .VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_MODULE_IDENTIFIER_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_shader_module_identifier and item.* == .VK_STRUCTURE_TYPE_SHADER_MODULE_IDENTIFIER_EXT)
        return true;
    if (extensions.device.VK_NV_optical_flow and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_FEATURES_NV)
        return true;
    if (extensions.device.VK_NV_optical_flow and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_PROPERTIES_NV)
        return true;
    if (extensions.device.VK_NV_optical_flow and item.* == .VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV)
        return true;
    if (extensions.device.VK_NV_optical_flow and item.* == .VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_PROPERTIES_NV)
        return true;
    if (extensions.device.VK_NV_optical_flow and item.* == .VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_INFO_NV)
        return true;
    if (extensions.device.VK_NV_optical_flow and item.* == .VK_STRUCTURE_TYPE_OPTICAL_FLOW_EXECUTE_INFO_NV)
        return true;
    if (extensions.device.VK_NV_optical_flow and item.* == .VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_PRIVATE_DATA_INFO_NV)
        return true;
    if (extensions.device.VK_EXT_legacy_dithering and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT)
        return true;
    if (extensions.device.VK_ANDROID_external_format_resolve and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FORMAT_RESOLVE_FEATURES_ANDROID)
        return true;
    if (extensions.device.VK_ANDROID_external_format_resolve and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FORMAT_RESOLVE_PROPERTIES_ANDROID)
        return true;
    if (extensions.device.VK_ANDROID_external_format_resolve and item.* == .VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_RESOLVE_PROPERTIES_ANDROID)
        return true;
    if (extensions.device.VK_AMD_anti_lag and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ANTI_LAG_FEATURES_AMD)
        return true;
    if (extensions.device.VK_AMD_anti_lag and item.* == .VK_STRUCTURE_TYPE_ANTI_LAG_DATA_AMD)
        return true;
    if (extensions.device.VK_AMD_anti_lag and item.* == .VK_STRUCTURE_TYPE_ANTI_LAG_PRESENTATION_INFO_AMD)
        return true;
    if (extensions.device.VK_AMDX_dense_geometry_format and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DENSE_GEOMETRY_FORMAT_FEATURES_AMDX)
        return true;
    if (extensions.device.VK_AMDX_dense_geometry_format and item.* == .VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DENSE_GEOMETRY_FORMAT_TRIANGLES_DATA_AMDX)
        return true;
    if (extensions.device.VK_KHR_present_id2 and item.* == .VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_ID_2_KHR)
        return true;
    if (extensions.device.VK_KHR_present_id2 and item.* == .VK_STRUCTURE_TYPE_PRESENT_ID_2_KHR)
        return true;
    if (extensions.device.VK_KHR_present_id2 and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_2_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_present_wait2 and item.* == .VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_WAIT_2_KHR)
        return true;
    if (extensions.device.VK_KHR_present_wait2 and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_2_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_present_wait2 and item.* == .VK_STRUCTURE_TYPE_PRESENT_WAIT_2_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_ray_tracing_position_fetch and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_POSITION_FETCH_FEATURES_KHR)
        return true;
    if (extensions.device.VK_EXT_shader_object and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_shader_object and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_shader_object and item.* == .VK_STRUCTURE_TYPE_SHADER_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_KHR_pipeline_binary and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_pipeline_binary and item.* == .VK_STRUCTURE_TYPE_PIPELINE_BINARY_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_pipeline_binary and item.* == .VK_STRUCTURE_TYPE_PIPELINE_BINARY_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_pipeline_binary and item.* == .VK_STRUCTURE_TYPE_PIPELINE_BINARY_KEY_KHR)
        return true;
    if (extensions.device.VK_KHR_pipeline_binary and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_pipeline_binary and item.* == .VK_STRUCTURE_TYPE_RELEASE_CAPTURED_PIPELINE_DATA_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_pipeline_binary and item.* == .VK_STRUCTURE_TYPE_PIPELINE_BINARY_DATA_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_pipeline_binary and item.* == .VK_STRUCTURE_TYPE_PIPELINE_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_pipeline_binary and item.* == .VK_STRUCTURE_TYPE_DEVICE_PIPELINE_BINARY_INTERNAL_CACHE_CONTROL_KHR)
        return true;
    if (extensions.device.VK_KHR_pipeline_binary and item.* == .VK_STRUCTURE_TYPE_PIPELINE_BINARY_HANDLES_INFO_KHR)
        return true;
    if (extensions.device.VK_QCOM_tile_properties and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_PROPERTIES_FEATURES_QCOM)
        return true;
    if (extensions.device.VK_QCOM_tile_properties and item.* == .VK_STRUCTURE_TYPE_TILE_PROPERTIES_QCOM)
        return true;
    if (extensions.device.VK_SEC_amigo_profiling and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_AMIGO_PROFILING_FEATURES_SEC)
        return true;
    if (extensions.device.VK_SEC_amigo_profiling and item.* == .VK_STRUCTURE_TYPE_AMIGO_PROFILING_SUBMIT_INFO_SEC)
        return true;
    if (extensions.device.VK_QCOM_multiview_per_view_viewports and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_VIEWPORTS_FEATURES_QCOM)
        return true;
    if (extensions.device.VK_NV_external_sci_sync2 and item.* == .VK_STRUCTURE_TYPE_SEMAPHORE_SCI_SYNC_POOL_CREATE_INFO_NV)
        return true;
    if (extensions.device.VK_NV_external_sci_sync2 and item.* == .VK_STRUCTURE_TYPE_SEMAPHORE_SCI_SYNC_CREATE_INFO_NV)
        return true;
    if (extensions.device.VK_NV_external_sci_sync2 and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SCI_SYNC_2_FEATURES_NV)
        return true;
    if (extensions.device.VK_NV_external_sci_sync2 and item.* == .VK_STRUCTURE_TYPE_DEVICE_SEMAPHORE_SCI_SYNC_POOL_RESERVATION_CREATE_INFO_NV)
        return true;
    if (extensions.device.VK_NV_ray_tracing_invocation_reorder and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_FEATURES_NV)
        return true;
    if (extensions.device.VK_NV_ray_tracing_invocation_reorder and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_PROPERTIES_NV)
        return true;
    if (extensions.device.VK_NV_cooperative_vector and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_VECTOR_FEATURES_NV)
        return true;
    if (extensions.device.VK_NV_cooperative_vector and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_VECTOR_PROPERTIES_NV)
        return true;
    if (extensions.device.VK_NV_cooperative_vector and item.* == .VK_STRUCTURE_TYPE_COOPERATIVE_VECTOR_PROPERTIES_NV)
        return true;
    if (extensions.device.VK_NV_cooperative_vector and item.* == .VK_STRUCTURE_TYPE_CONVERT_COOPERATIVE_VECTOR_MATRIX_INFO_NV)
        return true;
    if (extensions.device.VK_NV_extended_sparse_address_space and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_FEATURES_NV)
        return true;
    if (extensions.device.VK_NV_extended_sparse_address_space and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_PROPERTIES_NV)
        return true;
    if (extensions.device.VK_EXT_legacy_vertex_attributes and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_legacy_vertex_attributes and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_PROPERTIES_EXT)
        return true;
    if (extensions.instance.VK_EXT_layer_settings and item.* == .VK_STRUCTURE_TYPE_LAYER_SETTINGS_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_ARM_shader_core_builtins and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_FEATURES_ARM)
        return true;
    if (extensions.device.VK_ARM_shader_core_builtins and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_PROPERTIES_ARM)
        return true;
    if (extensions.device.VK_EXT_pipeline_library_group_handles and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_LIBRARY_GROUP_HANDLES_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_dynamic_rendering_unused_attachments and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_FEATURES_EXT)
        return true;
    if (extensions.device.VK_NV_low_latency2 and item.* == .VK_STRUCTURE_TYPE_LATENCY_SLEEP_MODE_INFO_NV)
        return true;
    if (extensions.device.VK_NV_low_latency2 and item.* == .VK_STRUCTURE_TYPE_LATENCY_SLEEP_INFO_NV)
        return true;
    if (extensions.device.VK_NV_low_latency2 and item.* == .VK_STRUCTURE_TYPE_SET_LATENCY_MARKER_INFO_NV)
        return true;
    if (extensions.device.VK_NV_low_latency2 and item.* == .VK_STRUCTURE_TYPE_GET_LATENCY_MARKER_INFO_NV)
        return true;
    if (extensions.device.VK_NV_low_latency2 and item.* == .VK_STRUCTURE_TYPE_LATENCY_TIMINGS_FRAME_REPORT_NV)
        return true;
    if (extensions.device.VK_NV_low_latency2 and item.* == .VK_STRUCTURE_TYPE_LATENCY_SUBMISSION_PRESENT_ID_NV)
        return true;
    if (extensions.device.VK_NV_low_latency2 and item.* == .VK_STRUCTURE_TYPE_OUT_OF_BAND_QUEUE_TYPE_INFO_NV)
        return true;
    if (extensions.device.VK_NV_low_latency2 and item.* == .VK_STRUCTURE_TYPE_SWAPCHAIN_LATENCY_CREATE_INFO_NV)
        return true;
    if (extensions.device.VK_NV_low_latency2 and item.* == .VK_STRUCTURE_TYPE_LATENCY_SURFACE_CAPABILITIES_NV)
        return true;
    if (extensions.device.VK_KHR_cooperative_matrix and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_cooperative_matrix and item.* == .VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_cooperative_matrix and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_ARM_data_graph and item.* == .VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_CREATE_INFO_ARM)
        return true;
    if (extensions.device.VK_ARM_data_graph and item.* == .VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_CREATE_INFO_ARM)
        return true;
    if (extensions.device.VK_ARM_data_graph and item.* == .VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_RESOURCE_INFO_ARM)
        return true;
    if (extensions.device.VK_ARM_data_graph and item.* == .VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_CONSTANT_ARM)
        return true;
    if (extensions.device.VK_ARM_data_graph and item.* == .VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_MEMORY_REQUIREMENTS_INFO_ARM)
        return true;
    if (extensions.device.VK_ARM_data_graph and item.* == .VK_STRUCTURE_TYPE_BIND_DATA_GRAPH_PIPELINE_SESSION_MEMORY_INFO_ARM)
        return true;
    if (extensions.device.VK_ARM_data_graph and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DATA_GRAPH_FEATURES_ARM)
        return true;
    if (extensions.device.VK_ARM_data_graph and item.* == .VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SHADER_MODULE_CREATE_INFO_ARM)
        return true;
    if (extensions.device.VK_ARM_data_graph and item.* == .VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_PROPERTY_QUERY_RESULT_ARM)
        return true;
    if (extensions.device.VK_ARM_data_graph and item.* == .VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_INFO_ARM)
        return true;
    if (extensions.device.VK_ARM_data_graph and item.* == .VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_COMPILER_CONTROL_CREATE_INFO_ARM)
        return true;
    if (extensions.device.VK_ARM_data_graph and item.* == .VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_REQUIREMENTS_INFO_ARM)
        return true;
    if (extensions.device.VK_ARM_data_graph and item.* == .VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_REQUIREMENT_ARM)
        return true;
    if (extensions.device.VK_ARM_data_graph and item.* == .VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_IDENTIFIER_CREATE_INFO_ARM)
        return true;
    if (extensions.device.VK_ARM_data_graph and item.* == .VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_DISPATCH_INFO_ARM)
        return true;
    if (extensions.device.VK_ARM_data_graph and item.* == .VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_CONSTANT_TENSOR_SEMI_STRUCTURED_SPARSITY_INFO_ARM)
        return true;
    if (extensions.device.VK_ARM_data_graph and item.* == .VK_STRUCTURE_TYPE_DATA_GRAPH_PROCESSING_ENGINE_CREATE_INFO_ARM)
        return true;
    if (extensions.device.VK_ARM_data_graph and item.* == .VK_STRUCTURE_TYPE_QUEUE_FAMILY_DATA_GRAPH_PROCESSING_ENGINE_PROPERTIES_ARM)
        return true;
    if (extensions.device.VK_ARM_data_graph and item.* == .VK_STRUCTURE_TYPE_QUEUE_FAMILY_DATA_GRAPH_PROPERTIES_ARM)
        return true;
    if (extensions.device.VK_ARM_data_graph and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_QUEUE_FAMILY_DATA_GRAPH_PROCESSING_ENGINE_INFO_ARM)
        return true;
    if (extensions.device.VK_QCOM_multiview_per_view_render_areas and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_RENDER_AREAS_FEATURES_QCOM)
        return true;
    if (extensions.device.VK_QCOM_multiview_per_view_render_areas and item.* == .VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_RENDER_AREAS_RENDER_PASS_BEGIN_INFO_QCOM)
        return true;
    if (extensions.device.VK_KHR_compute_shader_derivatives and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_decode_av1 and item.* == .VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_CAPABILITIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_decode_av1 and item.* == .VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_PICTURE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_decode_av1 and item.* == .VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_PROFILE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_decode_av1 and item.* == .VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_SESSION_PARAMETERS_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_decode_av1 and item.* == .VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_DPB_SLOT_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_av1 and item.* == .VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_CAPABILITIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_av1 and item.* == .VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_SESSION_PARAMETERS_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_av1 and item.* == .VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_PICTURE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_av1 and item.* == .VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_DPB_SLOT_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_av1 and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_AV1_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_av1 and item.* == .VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_PROFILE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_av1 and item.* == .VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_RATE_CONTROL_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_av1 and item.* == .VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_RATE_CONTROL_LAYER_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_av1 and item.* == .VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_QUALITY_LEVEL_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_av1 and item.* == .VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_SESSION_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_av1 and item.* == .VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_GOP_REMAINING_FRAME_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_decode_vp9 and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_DECODE_VP9_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_decode_vp9 and item.* == .VK_STRUCTURE_TYPE_VIDEO_DECODE_VP9_CAPABILITIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_decode_vp9 and item.* == .VK_STRUCTURE_TYPE_VIDEO_DECODE_VP9_PICTURE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_decode_vp9 and item.* == .VK_STRUCTURE_TYPE_VIDEO_DECODE_VP9_PROFILE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_maintenance1 and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_1_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_maintenance1 and item.* == .VK_STRUCTURE_TYPE_VIDEO_INLINE_QUERY_INFO_KHR)
        return true;
    if (extensions.device.VK_NV_per_stage_descriptor_set and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PER_STAGE_DESCRIPTOR_SET_FEATURES_NV)
        return true;
    if (extensions.device.VK_QCOM_image_processing2 and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_FEATURES_QCOM)
        return true;
    if (extensions.device.VK_QCOM_image_processing2 and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_PROPERTIES_QCOM)
        return true;
    if (extensions.device.VK_QCOM_image_processing2 and item.* == .VK_STRUCTURE_TYPE_SAMPLER_BLOCK_MATCH_WINDOW_CREATE_INFO_QCOM)
        return true;
    if (extensions.device.VK_QCOM_filter_cubic_weights and item.* == .VK_STRUCTURE_TYPE_SAMPLER_CUBIC_WEIGHTS_CREATE_INFO_QCOM)
        return true;
    if (extensions.device.VK_QCOM_filter_cubic_weights and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_WEIGHTS_FEATURES_QCOM)
        return true;
    if (extensions.device.VK_QCOM_filter_cubic_weights and item.* == .VK_STRUCTURE_TYPE_BLIT_IMAGE_CUBIC_WEIGHTS_INFO_QCOM)
        return true;
    if (extensions.device.VK_QCOM_ycbcr_degamma and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_DEGAMMA_FEATURES_QCOM)
        return true;
    if (extensions.device.VK_QCOM_ycbcr_degamma and item.* == .VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_YCBCR_DEGAMMA_CREATE_INFO_QCOM)
        return true;
    if (extensions.device.VK_QCOM_filter_cubic_clamp and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_CLAMP_FEATURES_QCOM)
        return true;
    if (extensions.device.VK_EXT_attachment_feedback_loop_dynamic_state and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_FEATURES_EXT)
        return true;
    if (extensions.device.VK_KHR_unified_image_layouts and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFIED_IMAGE_LAYOUTS_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_unified_image_layouts and item.* == .VK_STRUCTURE_TYPE_ATTACHMENT_FEEDBACK_LOOP_INFO_EXT)
        return true;
    if (extensions.device.VK_QNX_external_memory_screen_buffer and item.* == .VK_STRUCTURE_TYPE_SCREEN_BUFFER_PROPERTIES_QNX)
        return true;
    if (extensions.device.VK_QNX_external_memory_screen_buffer and item.* == .VK_STRUCTURE_TYPE_SCREEN_BUFFER_FORMAT_PROPERTIES_QNX)
        return true;
    if (extensions.device.VK_QNX_external_memory_screen_buffer and item.* == .VK_STRUCTURE_TYPE_IMPORT_SCREEN_BUFFER_INFO_QNX)
        return true;
    if (extensions.device.VK_QNX_external_memory_screen_buffer and item.* == .VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_QNX)
        return true;
    if (extensions.device.VK_QNX_external_memory_screen_buffer and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_SCREEN_BUFFER_FEATURES_QNX)
        return true;
    if (extensions.device.VK_MSFT_layered_driver and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_DRIVER_PROPERTIES_MSFT)
        return true;
    if (extensions.device.VK_KHR_maintenance6 and item.* == .VK_STRUCTURE_TYPE_SET_DESCRIPTOR_BUFFER_OFFSETS_INFO_EXT)
        return true;
    if (extensions.device.VK_KHR_maintenance6 and item.* == .VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_BUFFER_EMBEDDED_SAMPLERS_INFO_EXT)
        return true;
    if (extensions.device.VK_NV_descriptor_pool_overallocation and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_POOL_OVERALLOCATION_FEATURES_NV)
        return true;
    if (extensions.device.VK_QCOM_tile_memory_heap and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_MEMORY_HEAP_FEATURES_QCOM)
        return true;
    if (extensions.device.VK_QCOM_tile_memory_heap and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_MEMORY_HEAP_PROPERTIES_QCOM)
        return true;
    if (extensions.device.VK_QCOM_tile_memory_heap and item.* == .VK_STRUCTURE_TYPE_TILE_MEMORY_REQUIREMENTS_QCOM)
        return true;
    if (extensions.device.VK_QCOM_tile_memory_heap and item.* == .VK_STRUCTURE_TYPE_TILE_MEMORY_BIND_INFO_QCOM)
        return true;
    if (extensions.device.VK_QCOM_tile_memory_heap and item.* == .VK_STRUCTURE_TYPE_TILE_MEMORY_SIZE_INFO_QCOM)
        return true;
    if (extensions.device.VK_KHR_copy_memory_indirect and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_copy_memory_indirect and item.* == .VK_STRUCTURE_TYPE_COPY_MEMORY_INDIRECT_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_copy_memory_indirect and item.* == .VK_STRUCTURE_TYPE_COPY_MEMORY_TO_IMAGE_INDIRECT_INFO_KHR)
        return true;
    if (extensions.device.VK_EXT_memory_decompression and item.* == .VK_STRUCTURE_TYPE_DECOMPRESS_MEMORY_INFO_EXT)
        return true;
    if (extensions.instance.VK_NV_display_stereo and item.* == .VK_STRUCTURE_TYPE_DISPLAY_SURFACE_STEREO_CREATE_INFO_NV)
        return true;
    if (extensions.instance.VK_NV_display_stereo and item.* == .VK_STRUCTURE_TYPE_DISPLAY_MODE_STEREO_PROPERTIES_NV)
        return true;
    if (extensions.device.VK_KHR_video_encode_intra_refresh and item.* == .VK_STRUCTURE_TYPE_VIDEO_ENCODE_INTRA_REFRESH_CAPABILITIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_intra_refresh and item.* == .VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_INTRA_REFRESH_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_intra_refresh and item.* == .VK_STRUCTURE_TYPE_VIDEO_ENCODE_INTRA_REFRESH_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_intra_refresh and item.* == .VK_STRUCTURE_TYPE_VIDEO_REFERENCE_INTRA_REFRESH_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_intra_refresh and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_INTRA_REFRESH_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_quantization_map and item.* == .VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_CAPABILITIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_quantization_map and item.* == .VK_STRUCTURE_TYPE_VIDEO_FORMAT_QUANTIZATION_MAP_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_quantization_map and item.* == .VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_quantization_map and item.* == .VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_QUANTIZATION_MAP_CAPABILITIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_quantization_map and item.* == .VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_QUANTIZATION_MAP_CAPABILITIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_quantization_map and item.* == .VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_SESSION_PARAMETERS_CREATE_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_quantization_map and item.* == .VK_STRUCTURE_TYPE_VIDEO_FORMAT_H265_QUANTIZATION_MAP_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_quantization_map and item.* == .VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_QUANTIZATION_MAP_CAPABILITIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_quantization_map and item.* == .VK_STRUCTURE_TYPE_VIDEO_FORMAT_AV1_QUANTIZATION_MAP_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_encode_quantization_map and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUANTIZATION_MAP_FEATURES_KHR)
        return true;
    if (extensions.device.VK_NV_raw_access_chains and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAW_ACCESS_CHAINS_FEATURES_NV)
        return true;
    if (extensions.device.VK_NV_external_compute_queue and item.* == .VK_STRUCTURE_TYPE_EXTERNAL_COMPUTE_QUEUE_DEVICE_CREATE_INFO_NV)
        return true;
    if (extensions.device.VK_NV_external_compute_queue and item.* == .VK_STRUCTURE_TYPE_EXTERNAL_COMPUTE_QUEUE_CREATE_INFO_NV)
        return true;
    if (extensions.device.VK_NV_external_compute_queue and item.* == .VK_STRUCTURE_TYPE_EXTERNAL_COMPUTE_QUEUE_DATA_PARAMS_NV)
        return true;
    if (extensions.device.VK_NV_external_compute_queue and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_COMPUTE_QUEUE_PROPERTIES_NV)
        return true;
    if (extensions.device.VK_KHR_shader_relaxed_extended_instruction and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_RELAXED_EXTENDED_INSTRUCTION_FEATURES_KHR)
        return true;
    if (extensions.device.VK_NV_command_buffer_inheritance and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMMAND_BUFFER_INHERITANCE_FEATURES_NV)
        return true;
    if (extensions.device.VK_KHR_maintenance7 and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_7_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance7 and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_7_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance7 and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_PROPERTIES_LIST_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance7 and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance7 and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_VULKAN_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_NV_shader_atomic_float16_vector and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT16_VECTOR_FEATURES_NV)
        return true;
    if (extensions.device.VK_EXT_shader_replicated_composites and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_REPLICATED_COMPOSITES_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_shader_float8 and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT8_FEATURES_EXT)
        return true;
    if (extensions.device.VK_NV_ray_tracing_validation and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_VALIDATION_FEATURES_NV)
        return true;
    if (extensions.device.VK_NV_cluster_acceleration_structure and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_ACCELERATION_STRUCTURE_FEATURES_NV)
        return true;
    if (extensions.device.VK_NV_cluster_acceleration_structure and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_ACCELERATION_STRUCTURE_PROPERTIES_NV)
        return true;
    if (extensions.device.VK_NV_cluster_acceleration_structure and item.* == .VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_CLUSTERS_BOTTOM_LEVEL_INPUT_NV)
        return true;
    if (extensions.device.VK_NV_cluster_acceleration_structure and item.* == .VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_TRIANGLE_CLUSTER_INPUT_NV)
        return true;
    if (extensions.device.VK_NV_cluster_acceleration_structure and item.* == .VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_MOVE_OBJECTS_INPUT_NV)
        return true;
    if (extensions.device.VK_NV_cluster_acceleration_structure and item.* == .VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_INPUT_INFO_NV)
        return true;
    if (extensions.device.VK_NV_cluster_acceleration_structure and item.* == .VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_COMMANDS_INFO_NV)
        return true;
    if (extensions.device.VK_NV_cluster_acceleration_structure and item.* == .VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CLUSTER_ACCELERATION_STRUCTURE_CREATE_INFO_NV)
        return true;
    if (extensions.device.VK_NV_partitioned_acceleration_structure and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PARTITIONED_ACCELERATION_STRUCTURE_FEATURES_NV)
        return true;
    if (extensions.device.VK_NV_partitioned_acceleration_structure and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PARTITIONED_ACCELERATION_STRUCTURE_PROPERTIES_NV)
        return true;
    if (extensions.device.VK_NV_partitioned_acceleration_structure and item.* == .VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_PARTITIONED_ACCELERATION_STRUCTURE_NV)
        return true;
    if (extensions.device.VK_NV_partitioned_acceleration_structure and item.* == .VK_STRUCTURE_TYPE_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCES_INPUT_NV)
        return true;
    if (extensions.device.VK_NV_partitioned_acceleration_structure and item.* == .VK_STRUCTURE_TYPE_BUILD_PARTITIONED_ACCELERATION_STRUCTURE_INFO_NV)
        return true;
    if (extensions.device.VK_NV_partitioned_acceleration_structure and item.* == .VK_STRUCTURE_TYPE_PARTITIONED_ACCELERATION_STRUCTURE_FLAGS_NV)
        return true;
    if (extensions.device.VK_EXT_device_generated_commands and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_device_generated_commands and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_device_generated_commands and item.* == .VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_device_generated_commands and item.* == .VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_device_generated_commands and item.* == .VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_device_generated_commands and item.* == .VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_device_generated_commands and item.* == .VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_EXT)
        return true;
    if (extensions.device.VK_EXT_device_generated_commands and item.* == .VK_STRUCTURE_TYPE_WRITE_INDIRECT_EXECUTION_SET_PIPELINE_EXT)
        return true;
    if (extensions.device.VK_EXT_device_generated_commands and item.* == .VK_STRUCTURE_TYPE_WRITE_INDIRECT_EXECUTION_SET_SHADER_EXT)
        return true;
    if (extensions.device.VK_EXT_device_generated_commands and item.* == .VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_PIPELINE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_device_generated_commands and item.* == .VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_SHADER_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_device_generated_commands and item.* == .VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_SHADER_LAYOUT_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_device_generated_commands and item.* == .VK_STRUCTURE_TYPE_GENERATED_COMMANDS_PIPELINE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_device_generated_commands and item.* == .VK_STRUCTURE_TYPE_GENERATED_COMMANDS_SHADER_INFO_EXT)
        return true;
    if (extensions.device.VK_KHR_maintenance8 and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_8_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance8 and item.* == .VK_STRUCTURE_TYPE_MEMORY_BARRIER_ACCESS_FLAGS_3_KHR)
        return true;
    if (extensions.device.VK_MESA_image_alignment_control and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_FEATURES_MESA)
        return true;
    if (extensions.device.VK_MESA_image_alignment_control and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_PROPERTIES_MESA)
        return true;
    if (extensions.device.VK_MESA_image_alignment_control and item.* == .VK_STRUCTURE_TYPE_IMAGE_ALIGNMENT_CONTROL_CREATE_INFO_MESA)
        return true;
    if (extensions.device.VK_KHR_shader_fma and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FMA_FEATURES_KHR)
        return true;
    if (extensions.device.VK_EXT_ray_tracing_invocation_reorder and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_ray_tracing_invocation_reorder and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_depth_clamp_control and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_CONTROL_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_depth_clamp_control and item.* == .VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLAMP_CONTROL_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_KHR_maintenance9 and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_9_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance9 and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_9_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance9 and item.* == .VK_STRUCTURE_TYPE_QUEUE_FAMILY_OWNERSHIP_TRANSFER_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_maintenance2 and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_2_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_video_maintenance2 and item.* == .VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_INLINE_SESSION_PARAMETERS_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_maintenance2 and item.* == .VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_INLINE_SESSION_PARAMETERS_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_video_maintenance2 and item.* == .VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_INLINE_SESSION_PARAMETERS_INFO_KHR)
        return true;
    if (extensions.device.VK_HUAWEI_hdr_vivid and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HDR_VIVID_FEATURES_HUAWEI)
        return true;
    if (extensions.device.VK_HUAWEI_hdr_vivid and item.* == .VK_STRUCTURE_TYPE_HDR_VIVID_DYNAMIC_METADATA_HUAWEI)
        return true;
    if (extensions.device.VK_NV_cooperative_matrix2 and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_2_FEATURES_NV)
        return true;
    if (extensions.device.VK_NV_cooperative_matrix2 and item.* == .VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_FLEXIBLE_DIMENSIONS_PROPERTIES_NV)
        return true;
    if (extensions.device.VK_NV_cooperative_matrix2 and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_2_PROPERTIES_NV)
        return true;
    if (extensions.device.VK_ARM_pipeline_opacity_micromap and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_OPACITY_MICROMAP_FEATURES_ARM)
        return true;
    if (extensions.device.VK_EXT_external_memory_metal and item.* == .VK_STRUCTURE_TYPE_IMPORT_MEMORY_METAL_HANDLE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_external_memory_metal and item.* == .VK_STRUCTURE_TYPE_MEMORY_METAL_HANDLE_PROPERTIES_EXT)
        return true;
    if (extensions.device.VK_EXT_external_memory_metal and item.* == .VK_STRUCTURE_TYPE_MEMORY_GET_METAL_HANDLE_INFO_EXT)
        return true;
    if (extensions.device.VK_ARM_performance_counters_by_region and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_COUNTERS_BY_REGION_FEATURES_ARM)
        return true;
    if (extensions.device.VK_ARM_performance_counters_by_region and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_COUNTERS_BY_REGION_PROPERTIES_ARM)
        return true;
    if (extensions.device.VK_ARM_performance_counters_by_region and item.* == .VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_ARM)
        return true;
    if (extensions.device.VK_ARM_performance_counters_by_region and item.* == .VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_DESCRIPTION_ARM)
        return true;
    if (extensions.device.VK_ARM_performance_counters_by_region and item.* == .VK_STRUCTURE_TYPE_RENDER_PASS_PERFORMANCE_COUNTERS_BY_REGION_BEGIN_INFO_ARM)
        return true;
    if (extensions.device.VK_EXT_vertex_attribute_robustness and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_ROBUSTNESS_FEATURES_EXT)
        return true;
    if (extensions.device.VK_ARM_format_pack and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FORMAT_PACK_FEATURES_ARM)
        return true;
    if (extensions.device.VK_VALVE_fragment_density_map_layered and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_LAYERED_FEATURES_VALVE)
        return true;
    if (extensions.device.VK_VALVE_fragment_density_map_layered and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_LAYERED_PROPERTIES_VALVE)
        return true;
    if (extensions.device.VK_VALVE_fragment_density_map_layered and item.* == .VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_DENSITY_MAP_LAYERED_CREATE_INFO_VALVE)
        return true;
    if (extensions.device.VK_NV_present_metering and item.* == .VK_STRUCTURE_TYPE_SET_PRESENT_CONFIG_NV)
        return true;
    if (extensions.device.VK_NV_present_metering and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_METERING_FEATURES_NV)
        return true;
    if (extensions.device.VK_KHR_maintenance10 and item.* == .VK_STRUCTURE_TYPE_RENDERING_END_INFO_KHR)
        return true;
    if (extensions.device.VK_EXT_zero_initialize_device_memory and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_DEVICE_MEMORY_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_shader_64bit_indexing and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_64_BIT_INDEXING_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_custom_resolve and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_RESOLVE_FEATURES_EXT)
        return true;
    if (extensions.device.VK_EXT_custom_resolve and item.* == .VK_STRUCTURE_TYPE_BEGIN_CUSTOM_RESOLVE_INFO_EXT)
        return true;
    if (extensions.device.VK_EXT_custom_resolve and item.* == .VK_STRUCTURE_TYPE_CUSTOM_RESOLVE_CREATE_INFO_EXT)
        return true;
    if (extensions.device.VK_QCOM_data_graph_model and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DATA_GRAPH_MODEL_FEATURES_QCOM)
        return true;
    if (extensions.device.VK_QCOM_data_graph_model and item.* == .VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_BUILTIN_MODEL_CREATE_INFO_QCOM)
        return true;
    if (extensions.device.VK_KHR_maintenance10 and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_10_FEATURES_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance10 and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_10_PROPERTIES_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance10 and item.* == .VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_FLAGS_INFO_KHR)
        return true;
    if (extensions.device.VK_KHR_maintenance10 and item.* == .VK_STRUCTURE_TYPE_RESOLVE_IMAGE_MODE_INFO_KHR)
        return true;
    if (extensions.device.VK_SEC_pipeline_cache_incremental_mode and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CACHE_INCREMENTAL_MODE_FEATURES_SEC)
        return true;
    if (extensions.device.VK_EXT_shader_uniform_buffer_unsized_array and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_UNIFORM_BUFFER_UNSIZED_ARRAY_FEATURES_EXT)
        return true;
    if (extensions.device.VK_NV_compute_occupancy_priority and item.* == .VK_STRUCTURE_TYPE_COMPUTE_OCCUPANCY_PRIORITY_PARAMETERS_NV)
        return true;
    if (extensions.device.VK_NV_compute_occupancy_priority and item.* == .VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_OCCUPANCY_PRIORITY_FEATURES_NV)
        return true;
    if (extensions.instance.VK_OHOS_surface and item.* == .VK_STRUCTURE_TYPE_SURFACE_CREATE_INFO_OHOS)
        return true;
    return true;
}

pub fn validate_VkSubpassContents(extensions: *const Extensions, item: *const vk.VkSubpassContents) bool {
    const min = 0;
    const max = 1000451000;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    if (extensions.device.VK_KHR_maintenance7 and item.* == .VK_SUBPASS_CONTENTS_INLINE_AND_SECONDARY_COMMAND_BUFFERS_KHR)
        return true;
    return true;
}

pub fn validate_VkResult(extensions: *const Extensions, item: *const vk.VkResult) bool {
    const min = -1000483000;
    const max = 1000483000;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    if (extensions.device.VK_KHR_pipeline_binary and item.* == .VK_ERROR_NOT_ENOUGH_SPACE_KHR)
        return true;
    if (extensions.device.VK_EXT_image_compression_control and item.* == .VK_ERROR_COMPRESSION_EXHAUSTED_EXT)
        return true;
    if (extensions.device.VK_KHR_video_encode_queue and item.* == .VK_ERROR_INVALID_VIDEO_STD_PARAMETERS_KHR)
        return true;
    if (extensions.device.VK_EXT_full_screen_exclusive and item.* == .VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT)
        return true;
    if (extensions.device.VK_EXT_present_timing and item.* == .VK_ERROR_PRESENT_TIMING_QUEUE_FULL_EXT)
        return true;
    if (extensions.device.VK_EXT_image_drm_format_modifier and item.* == .VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT)
        return true;
    if (extensions.device.VK_KHR_video_queue and item.* == .VK_ERROR_VIDEO_STD_VERSION_NOT_SUPPORTED_KHR)
        return true;
    if (extensions.device.VK_KHR_video_queue and item.* == .VK_ERROR_VIDEO_PROFILE_CODEC_NOT_SUPPORTED_KHR)
        return true;
    if (extensions.device.VK_KHR_video_queue and item.* == .VK_ERROR_VIDEO_PROFILE_FORMAT_NOT_SUPPORTED_KHR)
        return true;
    if (extensions.device.VK_KHR_video_queue and item.* == .VK_ERROR_VIDEO_PROFILE_OPERATION_NOT_SUPPORTED_KHR)
        return true;
    if (extensions.device.VK_KHR_video_queue and item.* == .VK_ERROR_VIDEO_PICTURE_LAYOUT_NOT_SUPPORTED_KHR)
        return true;
    if (extensions.device.VK_KHR_video_queue and item.* == .VK_ERROR_IMAGE_USAGE_NOT_SUPPORTED_KHR)
        return true;
    if (extensions.device.VK_NV_glsl_shader and item.* == .VK_ERROR_INVALID_SHADER_NV)
        return true;
    if (extensions.device.VK_KHR_display_swapchain and item.* == .VK_ERROR_INCOMPATIBLE_DISPLAY_KHR)
        return true;
    if (extensions.device.VK_KHR_swapchain and item.* == .VK_ERROR_OUT_OF_DATE_KHR)
        return true;
    if (extensions.instance.VK_KHR_surface and item.* == .VK_ERROR_NATIVE_WINDOW_IN_USE_KHR)
        return true;
    if (extensions.instance.VK_KHR_surface and item.* == .VK_ERROR_SURFACE_LOST_KHR)
        return true;
    if (extensions.device.VK_KHR_swapchain and item.* == .VK_SUBOPTIMAL_KHR)
        return true;
    if (extensions.device.VK_KHR_deferred_host_operations and item.* == .VK_THREAD_IDLE_KHR)
        return true;
    if (extensions.device.VK_KHR_deferred_host_operations and item.* == .VK_THREAD_DONE_KHR)
        return true;
    if (extensions.device.VK_KHR_deferred_host_operations and item.* == .VK_OPERATION_DEFERRED_KHR)
        return true;
    if (extensions.device.VK_KHR_deferred_host_operations and item.* == .VK_OPERATION_NOT_DEFERRED_KHR)
        return true;
    if (extensions.device.VK_EXT_shader_object and item.* == .VK_INCOMPATIBLE_SHADER_BINARY_EXT)
        return true;
    if (extensions.device.VK_KHR_pipeline_binary and item.* == .VK_PIPELINE_BINARY_MISSING_KHR)
        return true;
    return true;
}

pub fn validate_VkDynamicState(extensions: *const Extensions, item: *const vk.VkDynamicState) bool {
    const min = 0;
    const max = 1000582000;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    if (extensions.device.VK_NV_clip_space_w_scaling and item.* == .VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV)
        return true;
    if (extensions.device.VK_EXT_discard_rectangles and item.* == .VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT)
        return true;
    if (extensions.device.VK_EXT_discard_rectangles and item.* == .VK_DYNAMIC_STATE_DISCARD_RECTANGLE_ENABLE_EXT)
        return true;
    if (extensions.device.VK_EXT_discard_rectangles and item.* == .VK_DYNAMIC_STATE_DISCARD_RECTANGLE_MODE_EXT)
        return true;
    if (extensions.device.VK_EXT_sample_locations and item.* == .VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT)
        return true;
    if (extensions.device.VK_NV_shading_rate_image and item.* == .VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV)
        return true;
    if (extensions.device.VK_NV_shading_rate_image and item.* == .VK_DYNAMIC_STATE_VIEWPORT_COARSE_SAMPLE_ORDER_NV)
        return true;
    if (extensions.device.VK_NV_scissor_exclusive and item.* == .VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_ENABLE_NV)
        return true;
    if (extensions.device.VK_NV_scissor_exclusive and item.* == .VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_NV)
        return true;
    if (extensions.device.VK_KHR_fragment_shading_rate and item.* == .VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR)
        return true;
    if (extensions.device.VK_KHR_ray_tracing_pipeline and item.* == .VK_DYNAMIC_STATE_RAY_TRACING_PIPELINE_STACK_SIZE_KHR)
        return true;
    if (extensions.device.VK_EXT_vertex_input_dynamic_state and item.* == .VK_DYNAMIC_STATE_VERTEX_INPUT_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state2 and item.* == .VK_DYNAMIC_STATE_PATCH_CONTROL_POINTS_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state2 and item.* == .VK_DYNAMIC_STATE_LOGIC_OP_EXT)
        return true;
    if (extensions.device.VK_EXT_color_write_enable and item.* == .VK_DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == .VK_DYNAMIC_STATE_TESSELLATION_DOMAIN_ORIGIN_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == .VK_DYNAMIC_STATE_DEPTH_CLAMP_ENABLE_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == .VK_DYNAMIC_STATE_POLYGON_MODE_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == .VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == .VK_DYNAMIC_STATE_SAMPLE_MASK_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == .VK_DYNAMIC_STATE_ALPHA_TO_COVERAGE_ENABLE_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == .VK_DYNAMIC_STATE_ALPHA_TO_ONE_ENABLE_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == .VK_DYNAMIC_STATE_LOGIC_OP_ENABLE_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == .VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == .VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == .VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == .VK_DYNAMIC_STATE_RASTERIZATION_STREAM_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == .VK_DYNAMIC_STATE_CONSERVATIVE_RASTERIZATION_MODE_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == .VK_DYNAMIC_STATE_EXTRA_PRIMITIVE_OVERESTIMATION_SIZE_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == .VK_DYNAMIC_STATE_DEPTH_CLIP_ENABLE_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == .VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == .VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == .VK_DYNAMIC_STATE_PROVOKING_VERTEX_MODE_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == .VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == .VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == .VK_DYNAMIC_STATE_DEPTH_CLIP_NEGATIVE_ONE_TO_ONE_EXT)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == .VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_ENABLE_NV)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == .VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == .VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == .VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_LOCATION_NV)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == .VK_DYNAMIC_STATE_COVERAGE_MODULATION_MODE_NV)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == .VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_ENABLE_NV)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == .VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_NV)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == .VK_DYNAMIC_STATE_SHADING_RATE_IMAGE_ENABLE_NV)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == .VK_DYNAMIC_STATE_REPRESENTATIVE_FRAGMENT_TEST_ENABLE_NV)
        return true;
    if (extensions.device.VK_EXT_extended_dynamic_state3 and item.* == .VK_DYNAMIC_STATE_COVERAGE_REDUCTION_MODE_NV)
        return true;
    if (extensions.device.VK_EXT_attachment_feedback_loop_dynamic_state and item.* == .VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT)
        return true;
    if (extensions.device.VK_EXT_depth_clamp_control and item.* == .VK_DYNAMIC_STATE_DEPTH_CLAMP_RANGE_EXT)
        return true;
    return true;
}

pub fn validate_VkDescriptorUpdateTemplateType(extensions: *const Extensions, item: *const vk.VkDescriptorUpdateTemplateType) bool {
    const min = 0;
    const max = 1;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkObjectType(extensions: *const Extensions, item: *const vk.VkObjectType) bool {
    const min = 0;
    const max = 1000572001;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    if (extensions.instance.VK_KHR_surface and item.* == .VK_OBJECT_TYPE_SURFACE_KHR)
        return true;
    if (extensions.device.VK_KHR_swapchain and item.* == .VK_OBJECT_TYPE_SWAPCHAIN_KHR)
        return true;
    if (extensions.instance.VK_KHR_display and item.* == .VK_OBJECT_TYPE_DISPLAY_KHR)
        return true;
    if (extensions.instance.VK_KHR_display and item.* == .VK_OBJECT_TYPE_DISPLAY_MODE_KHR)
        return true;
    if (extensions.instance.VK_EXT_debug_report and item.* == .VK_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT)
        return true;
    if (extensions.device.VK_KHR_video_queue and item.* == .VK_OBJECT_TYPE_VIDEO_SESSION_KHR)
        return true;
    if (extensions.device.VK_KHR_video_queue and item.* == .VK_OBJECT_TYPE_VIDEO_SESSION_PARAMETERS_KHR)
        return true;
    if (extensions.device.VK_NVX_binary_import and item.* == .VK_OBJECT_TYPE_CU_MODULE_NVX)
        return true;
    if (extensions.device.VK_NVX_binary_import and item.* == .VK_OBJECT_TYPE_CU_FUNCTION_NVX)
        return true;
    if (extensions.instance.VK_EXT_debug_utils and item.* == .VK_OBJECT_TYPE_DEBUG_UTILS_MESSENGER_EXT)
        return true;
    if (extensions.device.VK_KHR_acceleration_structure and item.* == .VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_KHR)
        return true;
    if (extensions.device.VK_EXT_validation_cache and item.* == .VK_OBJECT_TYPE_VALIDATION_CACHE_EXT)
        return true;
    if (extensions.device.VK_NV_ray_tracing and item.* == .VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV)
        return true;
    if (extensions.device.VK_INTEL_performance_query and item.* == .VK_OBJECT_TYPE_PERFORMANCE_CONFIGURATION_INTEL)
        return true;
    if (extensions.device.VK_KHR_deferred_host_operations and item.* == .VK_OBJECT_TYPE_DEFERRED_OPERATION_KHR)
        return true;
    if (extensions.device.VK_NV_device_generated_commands and item.* == .VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NV)
        return true;
    if (extensions.device.VK_NV_cuda_kernel_launch and item.* == .VK_OBJECT_TYPE_CUDA_MODULE_NV)
        return true;
    if (extensions.device.VK_NV_cuda_kernel_launch and item.* == .VK_OBJECT_TYPE_CUDA_FUNCTION_NV)
        return true;
    if (extensions.device.VK_FUCHSIA_buffer_collection and item.* == .VK_OBJECT_TYPE_BUFFER_COLLECTION_FUCHSIA)
        return true;
    if (extensions.device.VK_EXT_opacity_micromap and item.* == .VK_OBJECT_TYPE_MICROMAP_EXT)
        return true;
    if (extensions.device.VK_ARM_tensors and item.* == .VK_OBJECT_TYPE_TENSOR_ARM)
        return true;
    if (extensions.device.VK_ARM_tensors and item.* == .VK_OBJECT_TYPE_TENSOR_VIEW_ARM)
        return true;
    if (extensions.device.VK_NV_optical_flow and item.* == .VK_OBJECT_TYPE_OPTICAL_FLOW_SESSION_NV)
        return true;
    if (extensions.device.VK_EXT_shader_object and item.* == .VK_OBJECT_TYPE_SHADER_EXT)
        return true;
    if (extensions.device.VK_KHR_pipeline_binary and item.* == .VK_OBJECT_TYPE_PIPELINE_BINARY_KHR)
        return true;
    if (extensions.device.VK_NV_external_sci_sync2 and item.* == .VK_OBJECT_TYPE_SEMAPHORE_SCI_SYNC_POOL_NV)
        return true;
    if (extensions.device.VK_ARM_data_graph and item.* == .VK_OBJECT_TYPE_DATA_GRAPH_PIPELINE_SESSION_ARM)
        return true;
    if (extensions.device.VK_NV_external_compute_queue and item.* == .VK_OBJECT_TYPE_EXTERNAL_COMPUTE_QUEUE_NV)
        return true;
    if (extensions.device.VK_EXT_device_generated_commands and item.* == .VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_EXT)
        return true;
    if (extensions.device.VK_EXT_device_generated_commands and item.* == .VK_OBJECT_TYPE_INDIRECT_EXECUTION_SET_EXT)
        return true;
    return true;
}

pub fn validate_VkRayTracingInvocationReorderModeEXT(extensions: *const Extensions, item: *const vk.VkRayTracingInvocationReorderModeEXT) bool {
    const min = 0;
    const max = 1;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkRayTracingLssIndexingModeNV(extensions: *const Extensions, item: *const vk.VkRayTracingLssIndexingModeNV) bool {
    const min = 0;
    const max = 1;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkRayTracingLssPrimitiveEndCapsModeNV(extensions: *const Extensions, item: *const vk.VkRayTracingLssPrimitiveEndCapsModeNV) bool {
    const min = 0;
    const max = 1;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkDirectDriverLoadingModeLUNARG(extensions: *const Extensions, item: *const vk.VkDirectDriverLoadingModeLUNARG) bool {
    const min = 0;
    const max = 1;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkAntiLagModeAMD(extensions: *const Extensions, item: *const vk.VkAntiLagModeAMD) bool {
    const min = 0;
    const max = 2;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkAntiLagStageAMD(extensions: *const Extensions, item: *const vk.VkAntiLagStageAMD) bool {
    const min = 0;
    const max = 1;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkSemaphoreType(extensions: *const Extensions, item: *const vk.VkSemaphoreType) bool {
    const min = 0;
    const max = 1;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkPresentModeKHR(extensions: *const Extensions, item: *const vk.VkPresentModeKHR) bool {
    const min = 0;
    const max = 1000361000;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    if (extensions.device.VK_KHR_shared_presentable_image and item.* == .VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR)
        return true;
    if (extensions.device.VK_KHR_shared_presentable_image and item.* == .VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR)
        return true;
    if (extensions.device.VK_KHR_present_mode_fifo_latest_ready and item.* == .VK_PRESENT_MODE_FIFO_LATEST_READY_KHR)
        return true;
    return true;
}

pub fn validate_VkColorSpaceKHR(extensions: *const Extensions, item: *const vk.VkColorSpaceKHR) bool {
    const min = 0;
    const max = 1000213000;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    if (extensions.instance.VK_EXT_swapchain_colorspace and item.* == .VK_COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT)
        return true;
    if (extensions.instance.VK_EXT_swapchain_colorspace and item.* == .VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT)
        return true;
    if (extensions.instance.VK_EXT_swapchain_colorspace and item.* == .VK_COLOR_SPACE_DISPLAY_P3_LINEAR_EXT)
        return true;
    if (extensions.instance.VK_EXT_swapchain_colorspace and item.* == .VK_COLOR_SPACE_DCI_P3_NONLINEAR_EXT)
        return true;
    if (extensions.instance.VK_EXT_swapchain_colorspace and item.* == .VK_COLOR_SPACE_BT709_LINEAR_EXT)
        return true;
    if (extensions.instance.VK_EXT_swapchain_colorspace and item.* == .VK_COLOR_SPACE_BT709_NONLINEAR_EXT)
        return true;
    if (extensions.instance.VK_EXT_swapchain_colorspace and item.* == .VK_COLOR_SPACE_BT2020_LINEAR_EXT)
        return true;
    if (extensions.instance.VK_EXT_swapchain_colorspace and item.* == .VK_COLOR_SPACE_HDR10_ST2084_EXT)
        return true;
    if (extensions.instance.VK_EXT_swapchain_colorspace and item.* == .VK_COLOR_SPACE_DOLBYVISION_EXT)
        return true;
    if (extensions.instance.VK_EXT_swapchain_colorspace and item.* == .VK_COLOR_SPACE_HDR10_HLG_EXT)
        return true;
    if (extensions.instance.VK_EXT_swapchain_colorspace and item.* == .VK_COLOR_SPACE_ADOBERGB_LINEAR_EXT)
        return true;
    if (extensions.instance.VK_EXT_swapchain_colorspace and item.* == .VK_COLOR_SPACE_ADOBERGB_NONLINEAR_EXT)
        return true;
    if (extensions.instance.VK_EXT_swapchain_colorspace and item.* == .VK_COLOR_SPACE_PASS_THROUGH_EXT)
        return true;
    if (extensions.instance.VK_EXT_swapchain_colorspace and item.* == .VK_COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT)
        return true;
    if (extensions.device.VK_AMD_display_native_hdr and item.* == .VK_COLOR_SPACE_DISPLAY_NATIVE_AMD)
        return true;
    return true;
}

pub fn validate_VkDisplaySurfaceStereoTypeNV(extensions: *const Extensions, item: *const vk.VkDisplaySurfaceStereoTypeNV) bool {
    const min = 0;
    const max = 3;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkTimeDomainKHR(extensions: *const Extensions, item: *const vk.VkTimeDomainKHR) bool {
    const min = 0;
    const max = 1000208001;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    if (extensions.device.VK_EXT_present_timing and item.* == .VK_TIME_DOMAIN_PRESENT_STAGE_LOCAL_EXT)
        return true;
    if (extensions.device.VK_EXT_present_timing and item.* == .VK_TIME_DOMAIN_SWAPCHAIN_LOCAL_EXT)
        return true;
    return true;
}

pub fn validate_VkDebugReportObjectTypeEXT(extensions: *const Extensions, item: *const vk.VkDebugReportObjectTypeEXT) bool {
    const min = 0;
    const max = 1000366000;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    if (extensions.device.VK_NVX_binary_import and item.* == .VK_DEBUG_REPORT_OBJECT_TYPE_CU_MODULE_NVX_EXT)
        return true;
    if (extensions.device.VK_NVX_binary_import and item.* == .VK_DEBUG_REPORT_OBJECT_TYPE_CU_FUNCTION_NVX_EXT)
        return true;
    if (extensions.instance.VK_EXT_debug_report and item.* == .VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_EXT)
        return true;
    if (extensions.device.VK_KHR_acceleration_structure and item.* == .VK_DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_KHR_EXT)
        return true;
    if (extensions.device.VK_KHR_sampler_ycbcr_conversion and item.* == .VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT)
        return true;
    if (extensions.device.VK_NV_ray_tracing and item.* == .VK_DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV_EXT)
        return true;
    if (extensions.device.VK_NV_cuda_kernel_launch and item.* == .VK_DEBUG_REPORT_OBJECT_TYPE_CUDA_MODULE_NV_EXT)
        return true;
    if (extensions.device.VK_NV_cuda_kernel_launch and item.* == .VK_DEBUG_REPORT_OBJECT_TYPE_CUDA_FUNCTION_NV_EXT)
        return true;
    if (extensions.device.VK_FUCHSIA_buffer_collection and item.* == .VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_COLLECTION_FUCHSIA_EXT)
        return true;
    return true;
}

pub fn validate_VkDeviceMemoryReportEventTypeEXT(extensions: *const Extensions, item: *const vk.VkDeviceMemoryReportEventTypeEXT) bool {
    const min = 0;
    const max = 4;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkRasterizationOrderAMD(extensions: *const Extensions, item: *const vk.VkRasterizationOrderAMD) bool {
    const min = 0;
    const max = 1;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkClusterAccelerationStructureTypeNV(extensions: *const Extensions, item: *const vk.VkClusterAccelerationStructureTypeNV) bool {
    const min = 0;
    const max = 2;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkClusterAccelerationStructureOpTypeNV(extensions: *const Extensions, item: *const vk.VkClusterAccelerationStructureOpTypeNV) bool {
    const min = 0;
    const max = 5;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkClusterAccelerationStructureOpModeNV(extensions: *const Extensions, item: *const vk.VkClusterAccelerationStructureOpModeNV) bool {
    const min = 0;
    const max = 2;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkValidationCheckEXT(extensions: *const Extensions, item: *const vk.VkValidationCheckEXT) bool {
    const min = 0;
    const max = 1;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkValidationFeatureEnableEXT(extensions: *const Extensions, item: *const vk.VkValidationFeatureEnableEXT) bool {
    const min = 0;
    const max = 4;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkValidationFeatureDisableEXT(extensions: *const Extensions, item: *const vk.VkValidationFeatureDisableEXT) bool {
    const min = 0;
    const max = 7;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkLayerSettingTypeEXT(extensions: *const Extensions, item: *const vk.VkLayerSettingTypeEXT) bool {
    const min = 0;
    const max = 7;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkIndirectCommandsTokenTypeNV(extensions: *const Extensions, item: *const vk.VkIndirectCommandsTokenTypeNV) bool {
    const min = 0;
    const max = 1000428004;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    if (extensions.device.VK_EXT_mesh_shader and item.* == .VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_NV)
        return true;
    if (extensions.device.VK_NV_device_generated_commands_compute and item.* == .VK_INDIRECT_COMMANDS_TOKEN_TYPE_PIPELINE_NV)
        return true;
    if (extensions.device.VK_NV_device_generated_commands_compute and item.* == .VK_INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_NV)
        return true;
    return true;
}

pub fn validate_VkDisplayPowerStateEXT(extensions: *const Extensions, item: *const vk.VkDisplayPowerStateEXT) bool {
    const min = 0;
    const max = 2;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkDeviceEventTypeEXT(extensions: *const Extensions, item: *const vk.VkDeviceEventTypeEXT) bool {
    const min = 0;
    const max = 0;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkDisplayEventTypeEXT(extensions: *const Extensions, item: *const vk.VkDisplayEventTypeEXT) bool {
    const min = 0;
    const max = 0;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkViewportCoordinateSwizzleNV(extensions: *const Extensions, item: *const vk.VkViewportCoordinateSwizzleNV) bool {
    const min = 0;
    const max = 7;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkDiscardRectangleModeEXT(extensions: *const Extensions, item: *const vk.VkDiscardRectangleModeEXT) bool {
    const min = 0;
    const max = 1;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkPointClippingBehavior(extensions: *const Extensions, item: *const vk.VkPointClippingBehavior) bool {
    const min = 0;
    const max = 1;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkSamplerReductionMode(extensions: *const Extensions, item: *const vk.VkSamplerReductionMode) bool {
    const min = 0;
    const max = 1000521000;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    if (extensions.device.VK_QCOM_filter_cubic_clamp and item.* == .VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_RANGECLAMP_QCOM)
        return true;
    return true;
}

pub fn validate_VkTessellationDomainOrigin(extensions: *const Extensions, item: *const vk.VkTessellationDomainOrigin) bool {
    const min = 0;
    const max = 1;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkSamplerYcbcrModelConversion(extensions: *const Extensions, item: *const vk.VkSamplerYcbcrModelConversion) bool {
    const min = 0;
    const max = 4;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkSamplerYcbcrRange(extensions: *const Extensions, item: *const vk.VkSamplerYcbcrRange) bool {
    const min = 0;
    const max = 1;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkChromaLocation(extensions: *const Extensions, item: *const vk.VkChromaLocation) bool {
    const min = 0;
    const max = 1;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkBlendOverlapEXT(extensions: *const Extensions, item: *const vk.VkBlendOverlapEXT) bool {
    const min = 0;
    const max = 2;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkCoverageModulationModeNV(extensions: *const Extensions, item: *const vk.VkCoverageModulationModeNV) bool {
    const min = 0;
    const max = 3;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkCoverageReductionModeNV(extensions: *const Extensions, item: *const vk.VkCoverageReductionModeNV) bool {
    const min = 0;
    const max = 1;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkValidationCacheHeaderVersionEXT(extensions: *const Extensions, item: *const vk.VkValidationCacheHeaderVersionEXT) bool {
    const min = 1;
    const max = 1;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkShaderInfoTypeAMD(extensions: *const Extensions, item: *const vk.VkShaderInfoTypeAMD) bool {
    const min = 0;
    const max = 2;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkQueueGlobalPriority(extensions: *const Extensions, item: *const vk.VkQueueGlobalPriority) bool {
    const min = 128;
    const max = 1024;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkConservativeRasterizationModeEXT(extensions: *const Extensions, item: *const vk.VkConservativeRasterizationModeEXT) bool {
    const min = 0;
    const max = 2;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkVendorId(extensions: *const Extensions, item: *const vk.VkVendorId) bool {
    const min = 65536;
    const max = 65543;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkDriverId(extensions: *const Extensions, item: *const vk.VkDriverId) bool {
    const min = 1;
    const max = 28;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkShadingRatePaletteEntryNV(extensions: *const Extensions, item: *const vk.VkShadingRatePaletteEntryNV) bool {
    const min = 0;
    const max = 11;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkCoarseSampleOrderTypeNV(extensions: *const Extensions, item: *const vk.VkCoarseSampleOrderTypeNV) bool {
    const min = 0;
    const max = 3;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkCopyAccelerationStructureModeKHR(extensions: *const Extensions, item: *const vk.VkCopyAccelerationStructureModeKHR) bool {
    const min = 0;
    const max = 3;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    if (extensions.device.VK_KHR_acceleration_structure and item.* == .VK_COPY_ACCELERATION_STRUCTURE_MODE_SERIALIZE_KHR)
        return true;
    if (extensions.device.VK_KHR_acceleration_structure and item.* == .VK_COPY_ACCELERATION_STRUCTURE_MODE_DESERIALIZE_KHR)
        return true;
    return true;
}

pub fn validate_VkBuildAccelerationStructureModeKHR(extensions: *const Extensions, item: *const vk.VkBuildAccelerationStructureModeKHR) bool {
    const min = 0;
    const max = 1;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkAccelerationStructureTypeKHR(extensions: *const Extensions, item: *const vk.VkAccelerationStructureTypeKHR) bool {
    const min = 0;
    const max = 2;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkGeometryTypeKHR(extensions: *const Extensions, item: *const vk.VkGeometryTypeKHR) bool {
    const min = 0;
    const max = 1000478000;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    if (extensions.device.VK_NV_ray_tracing_linear_swept_spheres and item.* == .VK_GEOMETRY_TYPE_SPHERES_NV)
        return true;
    if (extensions.device.VK_NV_ray_tracing_linear_swept_spheres and item.* == .VK_GEOMETRY_TYPE_LINEAR_SWEPT_SPHERES_NV)
        return true;
    if (extensions.device.VK_AMDX_dense_geometry_format and item.* == .VK_GEOMETRY_TYPE_DENSE_GEOMETRY_FORMAT_TRIANGLES_AMDX)
        return true;
    return true;
}

pub fn validate_VkAccelerationStructureMemoryRequirementsTypeNV(extensions: *const Extensions, item: *const vk.VkAccelerationStructureMemoryRequirementsTypeNV) bool {
    const min = 0;
    const max = 2;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkAccelerationStructureBuildTypeKHR(extensions: *const Extensions, item: *const vk.VkAccelerationStructureBuildTypeKHR) bool {
    const min = 0;
    const max = 2;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkRayTracingShaderGroupTypeKHR(extensions: *const Extensions, item: *const vk.VkRayTracingShaderGroupTypeKHR) bool {
    const min = 0;
    const max = 2;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkAccelerationStructureCompatibilityKHR(extensions: *const Extensions, item: *const vk.VkAccelerationStructureCompatibilityKHR) bool {
    const min = 0;
    const max = 1;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkShaderGroupShaderKHR(extensions: *const Extensions, item: *const vk.VkShaderGroupShaderKHR) bool {
    const min = 0;
    const max = 3;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkMemoryOverallocationBehaviorAMD(extensions: *const Extensions, item: *const vk.VkMemoryOverallocationBehaviorAMD) bool {
    const min = 0;
    const max = 2;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkFullScreenExclusiveEXT(extensions: *const Extensions, item: *const vk.VkFullScreenExclusiveEXT) bool {
    const min = 0;
    const max = 3;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkPerformanceCounterScopeKHR(extensions: *const Extensions, item: *const vk.VkPerformanceCounterScopeKHR) bool {
    const min = 0;
    const max = 2;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkPerformanceCounterUnitKHR(extensions: *const Extensions, item: *const vk.VkPerformanceCounterUnitKHR) bool {
    const min = 0;
    const max = 10;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkPerformanceCounterStorageKHR(extensions: *const Extensions, item: *const vk.VkPerformanceCounterStorageKHR) bool {
    const min = 0;
    const max = 5;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkPerformanceConfigurationTypeINTEL(extensions: *const Extensions, item: *const vk.VkPerformanceConfigurationTypeINTEL) bool {
    const min = 0;
    const max = 0;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkQueryPoolSamplingModeINTEL(extensions: *const Extensions, item: *const vk.VkQueryPoolSamplingModeINTEL) bool {
    const min = 0;
    const max = 0;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkPerformanceOverrideTypeINTEL(extensions: *const Extensions, item: *const vk.VkPerformanceOverrideTypeINTEL) bool {
    const min = 0;
    const max = 1;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkPerformanceParameterTypeINTEL(extensions: *const Extensions, item: *const vk.VkPerformanceParameterTypeINTEL) bool {
    const min = 0;
    const max = 1;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkPerformanceValueTypeINTEL(extensions: *const Extensions, item: *const vk.VkPerformanceValueTypeINTEL) bool {
    const min = 0;
    const max = 4;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkShaderFloatControlsIndependence(extensions: *const Extensions, item: *const vk.VkShaderFloatControlsIndependence) bool {
    const min = 0;
    const max = 2;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkPipelineExecutableStatisticFormatKHR(extensions: *const Extensions, item: *const vk.VkPipelineExecutableStatisticFormatKHR) bool {
    const min = 0;
    const max = 3;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkLineRasterizationMode(extensions: *const Extensions, item: *const vk.VkLineRasterizationMode) bool {
    const min = 0;
    const max = 3;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkFaultLevel(extensions: *const Extensions, item: *const vk.VkFaultLevel) bool {
    const min = 0;
    const max = 3;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkFaultType(extensions: *const Extensions, item: *const vk.VkFaultType) bool {
    const min = 0;
    const max = 6;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkFaultQueryBehavior(extensions: *const Extensions, item: *const vk.VkFaultQueryBehavior) bool {
    const min = 0;
    const max = 0;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkPipelineMatchControl(extensions: *const Extensions, item: *const vk.VkPipelineMatchControl) bool {
    const min = 0;
    const max = 0;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkFragmentShadingRateCombinerOpKHR(extensions: *const Extensions, item: *const vk.VkFragmentShadingRateCombinerOpKHR) bool {
    const min = 0;
    const max = 4;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkFragmentShadingRateNV(extensions: *const Extensions, item: *const vk.VkFragmentShadingRateNV) bool {
    const min = 0;
    const max = 15;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkFragmentShadingRateTypeNV(extensions: *const Extensions, item: *const vk.VkFragmentShadingRateTypeNV) bool {
    const min = 0;
    const max = 1;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkSubpassMergeStatusEXT(extensions: *const Extensions, item: *const vk.VkSubpassMergeStatusEXT) bool {
    const min = 0;
    const max = 13;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkSciSyncClientTypeNV(extensions: *const Extensions, item: *const vk.VkSciSyncClientTypeNV) bool {
    const min = 0;
    const max = 2;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkSciSyncPrimitiveTypeNV(extensions: *const Extensions, item: *const vk.VkSciSyncPrimitiveTypeNV) bool {
    const min = 0;
    const max = 1;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkProvokingVertexModeEXT(extensions: *const Extensions, item: *const vk.VkProvokingVertexModeEXT) bool {
    const min = 0;
    const max = 1;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkPipelineCacheValidationVersion(extensions: *const Extensions, item: *const vk.VkPipelineCacheValidationVersion) bool {
    const min = 1;
    const max = 1;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkAccelerationStructureMotionInstanceTypeNV(extensions: *const Extensions, item: *const vk.VkAccelerationStructureMotionInstanceTypeNV) bool {
    const min = 0;
    const max = 2;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkDeviceAddressBindingTypeEXT(extensions: *const Extensions, item: *const vk.VkDeviceAddressBindingTypeEXT) bool {
    const min = 0;
    const max = 1;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkQueryResultStatusKHR(extensions: *const Extensions, item: *const vk.VkQueryResultStatusKHR) bool {
    const min = -1000299000;
    const max = 1;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    if (extensions.device.VK_KHR_video_encode_queue and item.* == .VK_QUERY_RESULT_STATUS_INSUFFICIENT_BITSTREAM_BUFFER_RANGE_KHR)
        return true;
    return true;
}

pub fn validate_VkVideoEncodeTuningModeKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeTuningModeKHR) bool {
    const min = 0;
    const max = 4;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkPartitionedAccelerationStructureOpTypeNV(extensions: *const Extensions, item: *const vk.VkPartitionedAccelerationStructureOpTypeNV) bool {
    const min = 0;
    const max = 2;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkVideoEncodeAV1PredictionModeKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeAV1PredictionModeKHR) bool {
    const min = 0;
    const max = 3;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkVideoEncodeAV1RateControlGroupKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeAV1RateControlGroupKHR) bool {
    const min = 0;
    const max = 2;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkPipelineRobustnessBufferBehavior(extensions: *const Extensions, item: *const vk.VkPipelineRobustnessBufferBehavior) bool {
    const min = 0;
    const max = 3;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkPipelineRobustnessImageBehavior(extensions: *const Extensions, item: *const vk.VkPipelineRobustnessImageBehavior) bool {
    const min = 0;
    const max = 3;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkOpticalFlowPerformanceLevelNV(extensions: *const Extensions, item: *const vk.VkOpticalFlowPerformanceLevelNV) bool {
    const min = 0;
    const max = 3;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkOpticalFlowSessionBindingPointNV(extensions: *const Extensions, item: *const vk.VkOpticalFlowSessionBindingPointNV) bool {
    const min = 0;
    const max = 8;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkMicromapTypeEXT(extensions: *const Extensions, item: *const vk.VkMicromapTypeEXT) bool {
    const min = 0;
    const max = 1000397000;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    if (extensions.device.VK_NV_displacement_micromap and item.* == .VK_MICROMAP_TYPE_DISPLACEMENT_MICROMAP_NV)
        return true;
    return true;
}

pub fn validate_VkCopyMicromapModeEXT(extensions: *const Extensions, item: *const vk.VkCopyMicromapModeEXT) bool {
    const min = 0;
    const max = 3;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkBuildMicromapModeEXT(extensions: *const Extensions, item: *const vk.VkBuildMicromapModeEXT) bool {
    const min = 0;
    const max = 0;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkOpacityMicromapFormatEXT(extensions: *const Extensions, item: *const vk.VkOpacityMicromapFormatEXT) bool {
    const min = 1;
    const max = 2;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkOpacityMicromapSpecialIndexEXT(extensions: *const Extensions, item: *const vk.VkOpacityMicromapSpecialIndexEXT) bool {
    const min = -5;
    const max = -1;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    if (extensions.device.VK_NV_cluster_acceleration_structure and item.* == .VK_OPACITY_MICROMAP_SPECIAL_INDEX_CLUSTER_GEOMETRY_DISABLE_OPACITY_MICROMAP_NV)
        return true;
    return true;
}

pub fn validate_VkDepthBiasRepresentationEXT(extensions: *const Extensions, item: *const vk.VkDepthBiasRepresentationEXT) bool {
    const min = 0;
    const max = 2;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkDeviceFaultAddressTypeEXT(extensions: *const Extensions, item: *const vk.VkDeviceFaultAddressTypeEXT) bool {
    const min = 0;
    const max = 6;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkDeviceFaultVendorBinaryHeaderVersionEXT(extensions: *const Extensions, item: *const vk.VkDeviceFaultVendorBinaryHeaderVersionEXT) bool {
    const min = 1;
    const max = 1;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkIndirectExecutionSetInfoTypeEXT(extensions: *const Extensions, item: *const vk.VkIndirectExecutionSetInfoTypeEXT) bool {
    const min = 0;
    const max = 1;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkIndirectCommandsTokenTypeEXT(extensions: *const Extensions, item: *const vk.VkIndirectCommandsTokenTypeEXT) bool {
    const min = 0;
    const max = 1000386004;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    if (extensions.device.VK_NV_mesh_shader and item.* == .VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_NV_EXT)
        return true;
    if (extensions.device.VK_NV_mesh_shader and item.* == .VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_COUNT_NV_EXT)
        return true;
    if (extensions.device.VK_EXT_mesh_shader and item.* == .VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_EXT)
        return true;
    if (extensions.device.VK_EXT_mesh_shader and item.* == .VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_COUNT_EXT)
        return true;
    if (extensions.device.VK_KHR_ray_tracing_maintenance1 and item.* == .VK_INDIRECT_COMMANDS_TOKEN_TYPE_TRACE_RAYS2_EXT)
        return true;
    return true;
}

pub fn validate_VkDisplacementMicromapFormatNV(extensions: *const Extensions, item: *const vk.VkDisplacementMicromapFormatNV) bool {
    const min = 1;
    const max = 3;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkShaderCodeTypeEXT(extensions: *const Extensions, item: *const vk.VkShaderCodeTypeEXT) bool {
    const min = 0;
    const max = 1;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkScopeKHR(extensions: *const Extensions, item: *const vk.VkScopeKHR) bool {
    const min = 1;
    const max = 5;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkComponentTypeKHR(extensions: *const Extensions, item: *const vk.VkComponentTypeKHR) bool {
    const min = 0;
    const max = 1000491003;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    if (extensions.device.VK_KHR_shader_bfloat16 and item.* == .VK_COMPONENT_TYPE_BFLOAT16_KHR)
        return true;
    if (extensions.device.VK_NV_cooperative_vector and item.* == .VK_COMPONENT_TYPE_SINT8_PACKED_NV)
        return true;
    if (extensions.device.VK_NV_cooperative_vector and item.* == .VK_COMPONENT_TYPE_UINT8_PACKED_NV)
        return true;
    if (extensions.device.VK_EXT_shader_float8 and item.* == .VK_COMPONENT_TYPE_FLOAT8_E4M3_EXT)
        return true;
    if (extensions.device.VK_EXT_shader_float8 and item.* == .VK_COMPONENT_TYPE_FLOAT8_E5M2_EXT)
        return true;
    return true;
}

pub fn validate_VkCubicFilterWeightsQCOM(extensions: *const Extensions, item: *const vk.VkCubicFilterWeightsQCOM) bool {
    const min = 0;
    const max = 3;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkBlockMatchWindowCompareModeQCOM(extensions: *const Extensions, item: *const vk.VkBlockMatchWindowCompareModeQCOM) bool {
    const min = 0;
    const max = 1;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkPhysicalDeviceLayeredApiKHR(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceLayeredApiKHR) bool {
    const min = 0;
    const max = 4;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkLayeredDriverUnderlyingApiMSFT(extensions: *const Extensions, item: *const vk.VkLayeredDriverUnderlyingApiMSFT) bool {
    const min = 0;
    const max = 1;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkLatencyMarkerNV(extensions: *const Extensions, item: *const vk.VkLatencyMarkerNV) bool {
    const min = 0;
    const max = 11;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkOutOfBandQueueTypeNV(extensions: *const Extensions, item: *const vk.VkOutOfBandQueueTypeNV) bool {
    const min = 0;
    const max = 1;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkCompressedTriangleFormatAMDX(extensions: *const Extensions, item: *const vk.VkCompressedTriangleFormatAMDX) bool {
    const min = 0;
    const max = 0;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkDepthClampModeEXT(extensions: *const Extensions, item: *const vk.VkDepthClampModeEXT) bool {
    const min = 0;
    const max = 1;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkCooperativeVectorMatrixLayoutNV(extensions: *const Extensions, item: *const vk.VkCooperativeVectorMatrixLayoutNV) bool {
    const min = 0;
    const max = 3;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkTensorTilingARM(extensions: *const Extensions, item: *const vk.VkTensorTilingARM) bool {
    const min = 0;
    const max = 1;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkDefaultVertexAttributeValueKHR(extensions: *const Extensions, item: *const vk.VkDefaultVertexAttributeValueKHR) bool {
    const min = 0;
    const max = 1;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkDataGraphPipelineSessionBindPointARM(extensions: *const Extensions, item: *const vk.VkDataGraphPipelineSessionBindPointARM) bool {
    const min = 0;
    const max = 0;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkDataGraphPipelineSessionBindPointTypeARM(extensions: *const Extensions, item: *const vk.VkDataGraphPipelineSessionBindPointTypeARM) bool {
    const min = 0;
    const max = 0;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkDataGraphPipelinePropertyARM(extensions: *const Extensions, item: *const vk.VkDataGraphPipelinePropertyARM) bool {
    const min = 0;
    const max = 1;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkPhysicalDeviceDataGraphProcessingEngineTypeARM(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDataGraphProcessingEngineTypeARM) bool {
    const min = 0;
    const max = 1000629001;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    if (extensions.device.VK_QCOM_data_graph_model and item.* == .VK_PHYSICAL_DEVICE_DATA_GRAPH_PROCESSING_ENGINE_TYPE_NEURAL_QCOM)
        return true;
    if (extensions.device.VK_QCOM_data_graph_model and item.* == .VK_PHYSICAL_DEVICE_DATA_GRAPH_PROCESSING_ENGINE_TYPE_COMPUTE_QCOM)
        return true;
    return true;
}

pub fn validate_VkPhysicalDeviceDataGraphOperationTypeARM(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceDataGraphOperationTypeARM) bool {
    const min = 0;
    const max = 1000629001;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    if (extensions.device.VK_QCOM_data_graph_model and item.* == .VK_PHYSICAL_DEVICE_DATA_GRAPH_OPERATION_TYPE_NEURAL_MODEL_QCOM)
        return true;
    if (extensions.device.VK_QCOM_data_graph_model and item.* == .VK_PHYSICAL_DEVICE_DATA_GRAPH_OPERATION_TYPE_BUILTIN_MODEL_QCOM)
        return true;
    return true;
}

pub fn validate_VkDataGraphModelCacheTypeQCOM(extensions: *const Extensions, item: *const vk.VkDataGraphModelCacheTypeQCOM) bool {
    const min = 0;
    const max = 0;
    const v: i32 = @intFromEnum(item.*);
    if (v < min or max < v)
        return false;
    _ = extensions;
    return true;
}

pub fn validate_VkFramebufferCreateFlags(extensions: *const Extensions, item: *const vk.VkFramebufferCreateFlags) bool {
    const valid_value: vk.VkFramebufferCreateFlags = .{
        .VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT = true,
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkQueryPoolCreateFlags(extensions: *const Extensions, item: *const vk.VkQueryPoolCreateFlags) bool {
    const valid_value: vk.VkQueryPoolCreateFlags = .{
        .VK_QUERY_POOL_CREATE_RESET_BIT_KHR = extensions.device.VK_KHR_maintenance9,
    };
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkRenderPassCreateFlags(extensions: *const Extensions, item: *const vk.VkRenderPassCreateFlags) bool {
    const valid_value: vk.VkRenderPassCreateFlags = .{
        .VK_RENDER_PASS_CREATE_TRANSFORM_BIT_QCOM = extensions.device.VK_QCOM_render_pass_transform,
        .VK_RENDER_PASS_CREATE_PER_LAYER_FRAGMENT_DENSITY_BIT_VALVE = extensions.device.VK_VALVE_fragment_density_map_layered,
    };
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkSamplerCreateFlags(extensions: *const Extensions, item: *const vk.VkSamplerCreateFlags) bool {
    const valid_value: vk.VkSamplerCreateFlags = .{
        .VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT = extensions.device.VK_EXT_fragment_density_map,
        .VK_SAMPLER_CREATE_SUBSAMPLED_COARSE_RECONSTRUCTION_BIT_EXT = extensions.device.VK_EXT_fragment_density_map,
        .VK_SAMPLER_CREATE_NON_SEAMLESS_CUBE_MAP_BIT_EXT = extensions.device.VK_EXT_non_seamless_cube_map,
        .VK_SAMPLER_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT = extensions.device.VK_EXT_descriptor_buffer,
        .VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM = extensions.device.VK_QCOM_image_processing,
    };
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkPipelineLayoutCreateFlags(extensions: *const Extensions, item: *const vk.VkPipelineLayoutCreateFlags) bool {
    const valid_value: vk.VkPipelineLayoutCreateFlags = .{
        .VK_PIPELINE_LAYOUT_CREATE_INDEPENDENT_SETS_BIT_EXT = extensions.device.VK_EXT_graphics_pipeline_library,
    };
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkPipelineCacheCreateFlags(extensions: *const Extensions, item: *const vk.VkPipelineCacheCreateFlags) bool {
    const valid_value: vk.VkPipelineCacheCreateFlags = .{
        .VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT = true,
        .VK_PIPELINE_CACHE_CREATE_READ_ONLY_BIT = true,
        .VK_PIPELINE_CACHE_CREATE_USE_APPLICATION_STORAGE_BIT = true,
        .VK_PIPELINE_CACHE_CREATE_INTERNALLY_SYNCHRONIZED_MERGE_BIT_KHR = extensions.device.VK_KHR_maintenance8,
    };
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkPipelineDepthStencilStateCreateFlags(extensions: *const Extensions, item: *const vk.VkPipelineDepthStencilStateCreateFlags) bool {
    const valid_value: vk.VkPipelineDepthStencilStateCreateFlags = .{
        .VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_EXT = extensions.device.VK_EXT_rasterization_order_attachment_access,
        .VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_EXT = extensions.device.VK_EXT_rasterization_order_attachment_access,
    };
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkPipelineDynamicStateCreateFlags(extensions: *const Extensions, item: *const vk.VkPipelineDynamicStateCreateFlags) bool {
    const valid_value: vk.VkPipelineDynamicStateCreateFlags = .{
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkPipelineColorBlendStateCreateFlags(extensions: *const Extensions, item: *const vk.VkPipelineColorBlendStateCreateFlags) bool {
    const valid_value: vk.VkPipelineColorBlendStateCreateFlags = .{
        .VK_PIPELINE_COLOR_BLEND_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_BIT_EXT = extensions.device.VK_EXT_rasterization_order_attachment_access,
    };
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkPipelineMultisampleStateCreateFlags(extensions: *const Extensions, item: *const vk.VkPipelineMultisampleStateCreateFlags) bool {
    const valid_value: vk.VkPipelineMultisampleStateCreateFlags = .{
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkPipelineRasterizationStateCreateFlags(extensions: *const Extensions, item: *const vk.VkPipelineRasterizationStateCreateFlags) bool {
    const valid_value: vk.VkPipelineRasterizationStateCreateFlags = .{
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkPipelineViewportStateCreateFlags(extensions: *const Extensions, item: *const vk.VkPipelineViewportStateCreateFlags) bool {
    const valid_value: vk.VkPipelineViewportStateCreateFlags = .{
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkPipelineTessellationStateCreateFlags(extensions: *const Extensions, item: *const vk.VkPipelineTessellationStateCreateFlags) bool {
    const valid_value: vk.VkPipelineTessellationStateCreateFlags = .{
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkPipelineInputAssemblyStateCreateFlags(extensions: *const Extensions, item: *const vk.VkPipelineInputAssemblyStateCreateFlags) bool {
    const valid_value: vk.VkPipelineInputAssemblyStateCreateFlags = .{
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkPipelineVertexInputStateCreateFlags(extensions: *const Extensions, item: *const vk.VkPipelineVertexInputStateCreateFlags) bool {
    const valid_value: vk.VkPipelineVertexInputStateCreateFlags = .{
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkPipelineShaderStageCreateFlags(extensions: *const Extensions, item: *const vk.VkPipelineShaderStageCreateFlags) bool {
    const valid_value: vk.VkPipelineShaderStageCreateFlags = .{
        .VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT = true,
        .VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT = true,
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkDescriptorSetLayoutCreateFlags(extensions: *const Extensions, item: *const vk.VkDescriptorSetLayoutCreateFlags) bool {
    const valid_value: vk.VkDescriptorSetLayoutCreateFlags = .{
        .VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT = true,
        .VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT = true,
        .VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_EXT = extensions.device.VK_EXT_mutable_descriptor_type,
        .VK_DESCRIPTOR_SET_LAYOUT_CREATE_DESCRIPTOR_BUFFER_BIT_EXT = extensions.device.VK_EXT_descriptor_buffer,
        .VK_DESCRIPTOR_SET_LAYOUT_CREATE_EMBEDDED_IMMUTABLE_SAMPLERS_BIT_EXT = extensions.device.VK_EXT_descriptor_buffer,
        .VK_DESCRIPTOR_SET_LAYOUT_CREATE_PER_STAGE_BIT_NV = extensions.device.VK_NV_per_stage_descriptor_set,
        .VK_DESCRIPTOR_SET_LAYOUT_CREATE_INDIRECT_BINDABLE_BIT_NV = extensions.device.VK_NV_device_generated_commands_compute,
    };
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkBufferViewCreateFlags(extensions: *const Extensions, item: *const vk.VkBufferViewCreateFlags) bool {
    const valid_value: vk.VkBufferViewCreateFlags = .{
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkInstanceCreateFlags(extensions: *const Extensions, item: *const vk.VkInstanceCreateFlags) bool {
    const valid_value: vk.VkInstanceCreateFlags = .{
        .VK_INSTANCE_CREATE_ENUMERATE_PORTABILITY_BIT_KHR = extensions.instance.VK_KHR_portability_enumeration,
    };
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkDeviceCreateFlags(extensions: *const Extensions, item: *const vk.VkDeviceCreateFlags) bool {
    const valid_value: vk.VkDeviceCreateFlags = .{
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkDeviceQueueCreateFlags(extensions: *const Extensions, item: *const vk.VkDeviceQueueCreateFlags) bool {
    const valid_value: vk.VkDeviceQueueCreateFlags = .{
        .VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT = true,
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkQueueFlags(extensions: *const Extensions, item: *const vk.VkQueueFlags) bool {
    const valid_value: vk.VkQueueFlags = .{
        .VK_QUEUE_GRAPHICS_BIT = true,
        .VK_QUEUE_COMPUTE_BIT = true,
        .VK_QUEUE_TRANSFER_BIT = true,
        .VK_QUEUE_SPARSE_BINDING_BIT = true,
        .VK_QUEUE_PROTECTED_BIT = true,
        .VK_QUEUE_VIDEO_DECODE_BIT_KHR = extensions.device.VK_KHR_video_decode_queue,
        .VK_QUEUE_VIDEO_ENCODE_BIT_KHR = extensions.device.VK_KHR_video_encode_queue,
        .VK_QUEUE_OPTICAL_FLOW_BIT_NV = extensions.device.VK_NV_optical_flow,
        .VK_QUEUE_DATA_GRAPH_BIT_ARM = extensions.device.VK_ARM_data_graph,
    };
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkMemoryPropertyFlags(extensions: *const Extensions, item: *const vk.VkMemoryPropertyFlags) bool {
    const valid_value: vk.VkMemoryPropertyFlags = .{
        .VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT = true,
        .VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT = true,
        .VK_MEMORY_PROPERTY_HOST_COHERENT_BIT = true,
        .VK_MEMORY_PROPERTY_HOST_CACHED_BIT = true,
        .VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT = true,
        .VK_MEMORY_PROPERTY_PROTECTED_BIT = true,
        .VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD = extensions.device.VK_AMD_device_coherent_memory,
        .VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD = extensions.device.VK_AMD_device_coherent_memory,
        .VK_MEMORY_PROPERTY_RDMA_CAPABLE_BIT_NV = extensions.device.VK_NV_external_memory_rdma,
    };
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkMemoryHeapFlags(extensions: *const Extensions, item: *const vk.VkMemoryHeapFlags) bool {
    const valid_value: vk.VkMemoryHeapFlags = .{
        .VK_MEMORY_HEAP_DEVICE_LOCAL_BIT = true,
        .VK_MEMORY_HEAP_MULTI_INSTANCE_BIT = true,
        .VK_MEMORY_HEAP_SEU_SAFE_BIT = true,
        .VK_MEMORY_HEAP_TILE_MEMORY_BIT_QCOM = extensions.device.VK_QCOM_tile_memory_heap,
    };
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkAccessFlags(extensions: *const Extensions, item: *const vk.VkAccessFlags) bool {
    const valid_value: vk.VkAccessFlags = .{
        .VK_ACCESS_INDIRECT_COMMAND_READ_BIT = true,
        .VK_ACCESS_INDEX_READ_BIT = true,
        .VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT = true,
        .VK_ACCESS_UNIFORM_READ_BIT = true,
        .VK_ACCESS_INPUT_ATTACHMENT_READ_BIT = true,
        .VK_ACCESS_SHADER_READ_BIT = true,
        .VK_ACCESS_SHADER_WRITE_BIT = true,
        .VK_ACCESS_COLOR_ATTACHMENT_READ_BIT = true,
        .VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT = true,
        .VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT = true,
        .VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT = true,
        .VK_ACCESS_TRANSFER_READ_BIT = true,
        .VK_ACCESS_TRANSFER_WRITE_BIT = true,
        .VK_ACCESS_HOST_READ_BIT = true,
        .VK_ACCESS_HOST_WRITE_BIT = true,
        .VK_ACCESS_MEMORY_READ_BIT = true,
        .VK_ACCESS_MEMORY_WRITE_BIT = true,
        .VK_ACCESS_COMMAND_PREPROCESS_READ_BIT_EXT = extensions.device.VK_EXT_device_generated_commands,
        .VK_ACCESS_COMMAND_PREPROCESS_WRITE_BIT_EXT = extensions.device.VK_EXT_device_generated_commands,
        .VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT = extensions.device.VK_EXT_blend_operation_advanced,
        .VK_ACCESS_CONDITIONAL_RENDERING_READ_BIT_EXT = extensions.device.VK_EXT_conditional_rendering,
        .VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR = extensions.device.VK_KHR_acceleration_structure,
        .VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_KHR = extensions.device.VK_KHR_acceleration_structure,
        .VK_ACCESS_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR = extensions.device.VK_KHR_fragment_shading_rate,
        .VK_ACCESS_FRAGMENT_DENSITY_MAP_READ_BIT_EXT = extensions.device.VK_EXT_fragment_density_map,
        .VK_ACCESS_TRANSFORM_FEEDBACK_WRITE_BIT_EXT = extensions.device.VK_EXT_transform_feedback,
        .VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT = extensions.device.VK_EXT_transform_feedback,
        .VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT = extensions.device.VK_EXT_transform_feedback,
    };
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkBufferUsageFlags(extensions: *const Extensions, item: *const vk.VkBufferUsageFlags) bool {
    const valid_value: vk.VkBufferUsageFlags = .{
        .VK_BUFFER_USAGE_TRANSFER_SRC_BIT = true,
        .VK_BUFFER_USAGE_TRANSFER_DST_BIT = true,
        .VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT = true,
        .VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT = true,
        .VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT = true,
        .VK_BUFFER_USAGE_STORAGE_BUFFER_BIT = true,
        .VK_BUFFER_USAGE_INDEX_BUFFER_BIT = true,
        .VK_BUFFER_USAGE_VERTEX_BUFFER_BIT = true,
        .VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT = true,
        .VK_BUFFER_USAGE_CONDITIONAL_RENDERING_BIT_EXT = extensions.device.VK_EXT_conditional_rendering,
        .VK_BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR = extensions.device.VK_KHR_ray_tracing_pipeline,
        .VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT = extensions.device.VK_EXT_transform_feedback,
        .VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT = extensions.device.VK_EXT_transform_feedback,
        .VK_BUFFER_USAGE_VIDEO_DECODE_SRC_BIT_KHR = extensions.device.VK_KHR_video_decode_queue,
        .VK_BUFFER_USAGE_VIDEO_DECODE_DST_BIT_KHR = extensions.device.VK_KHR_video_decode_queue,
        .VK_BUFFER_USAGE_VIDEO_ENCODE_DST_BIT_KHR = extensions.device.VK_KHR_video_encode_queue,
        .VK_BUFFER_USAGE_VIDEO_ENCODE_SRC_BIT_KHR = extensions.device.VK_KHR_video_encode_queue,
        .VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT = true,
        .VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR = extensions.device.VK_KHR_acceleration_structure,
        .VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR = extensions.device.VK_KHR_acceleration_structure,
        .VK_BUFFER_USAGE_SAMPLER_DESCRIPTOR_BUFFER_BIT_EXT = extensions.device.VK_EXT_descriptor_buffer,
        .VK_BUFFER_USAGE_RESOURCE_DESCRIPTOR_BUFFER_BIT_EXT = extensions.device.VK_EXT_descriptor_buffer,
        .VK_BUFFER_USAGE_MICROMAP_BUILD_INPUT_READ_ONLY_BIT_EXT = extensions.device.VK_EXT_opacity_micromap,
        .VK_BUFFER_USAGE_MICROMAP_STORAGE_BIT_EXT = extensions.device.VK_EXT_opacity_micromap,
        .VK_BUFFER_USAGE_EXECUTION_GRAPH_SCRATCH_BIT_AMDX = extensions.device.VK_AMDX_shader_enqueue,
        .VK_BUFFER_USAGE_PUSH_DESCRIPTORS_DESCRIPTOR_BUFFER_BIT_EXT = extensions.device.VK_EXT_descriptor_buffer,
        .VK_BUFFER_USAGE_TILE_MEMORY_BIT_QCOM = extensions.device.VK_QCOM_tile_memory_heap,
    };
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkBufferCreateFlags(extensions: *const Extensions, item: *const vk.VkBufferCreateFlags) bool {
    const valid_value: vk.VkBufferCreateFlags = .{
        .VK_BUFFER_CREATE_SPARSE_BINDING_BIT = true,
        .VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT = true,
        .VK_BUFFER_CREATE_SPARSE_ALIASED_BIT = true,
        .VK_BUFFER_CREATE_PROTECTED_BIT = true,
        .VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT = true,
        .VK_BUFFER_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT = extensions.device.VK_EXT_descriptor_buffer,
        .VK_BUFFER_CREATE_VIDEO_PROFILE_INDEPENDENT_BIT_KHR = extensions.device.VK_KHR_video_maintenance1,
    };
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkShaderStageFlags(extensions: *const Extensions, item: *const vk.VkShaderStageFlags) bool {
    const valid_value: vk.VkShaderStageFlags = .{
        .VK_SHADER_STAGE_VERTEX_BIT = true,
        .VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT = true,
        .VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT = true,
        .VK_SHADER_STAGE_GEOMETRY_BIT = true,
        .VK_SHADER_STAGE_FRAGMENT_BIT = true,
        .VK_SHADER_STAGE_COMPUTE_BIT = true,
        .VK_SHADER_STAGE_TASK_BIT_EXT = extensions.device.VK_EXT_mesh_shader,
        .VK_SHADER_STAGE_MESH_BIT_EXT = extensions.device.VK_EXT_mesh_shader,
        .VK_SHADER_STAGE_RAYGEN_BIT_KHR = extensions.device.VK_KHR_ray_tracing_pipeline,
        .VK_SHADER_STAGE_ANY_HIT_BIT_KHR = extensions.device.VK_KHR_ray_tracing_pipeline,
        .VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR = extensions.device.VK_KHR_ray_tracing_pipeline,
        .VK_SHADER_STAGE_MISS_BIT_KHR = extensions.device.VK_KHR_ray_tracing_pipeline,
        .VK_SHADER_STAGE_INTERSECTION_BIT_KHR = extensions.device.VK_KHR_ray_tracing_pipeline,
        .VK_SHADER_STAGE_CALLABLE_BIT_KHR = extensions.device.VK_KHR_ray_tracing_pipeline,
        .VK_SHADER_STAGE_SUBPASS_SHADING_BIT_HUAWEI = extensions.device.VK_HUAWEI_subpass_shading,
        .VK_SHADER_STAGE_CLUSTER_CULLING_BIT_HUAWEI = extensions.device.VK_HUAWEI_cluster_culling_shader,
    };
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkImageUsageFlags(extensions: *const Extensions, item: *const vk.VkImageUsageFlags) bool {
    const valid_value: vk.VkImageUsageFlags = .{
        .VK_IMAGE_USAGE_TRANSFER_SRC_BIT = true,
        .VK_IMAGE_USAGE_TRANSFER_DST_BIT = true,
        .VK_IMAGE_USAGE_SAMPLED_BIT = true,
        .VK_IMAGE_USAGE_STORAGE_BIT = true,
        .VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT = true,
        .VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT = true,
        .VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT = true,
        .VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT = true,
        .VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = extensions.device.VK_KHR_fragment_shading_rate,
        .VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT = extensions.device.VK_EXT_fragment_density_map,
        .VK_IMAGE_USAGE_VIDEO_DECODE_DST_BIT_KHR = extensions.device.VK_KHR_video_decode_queue,
        .VK_IMAGE_USAGE_VIDEO_DECODE_SRC_BIT_KHR = extensions.device.VK_KHR_video_decode_queue,
        .VK_IMAGE_USAGE_VIDEO_DECODE_DPB_BIT_KHR = extensions.device.VK_KHR_video_decode_queue,
        .VK_IMAGE_USAGE_VIDEO_ENCODE_DST_BIT_KHR = extensions.device.VK_KHR_video_encode_queue,
        .VK_IMAGE_USAGE_VIDEO_ENCODE_SRC_BIT_KHR = extensions.device.VK_KHR_video_encode_queue,
        .VK_IMAGE_USAGE_VIDEO_ENCODE_DPB_BIT_KHR = extensions.device.VK_KHR_video_encode_queue,
        .VK_IMAGE_USAGE_INVOCATION_MASK_BIT_HUAWEI = extensions.device.VK_HUAWEI_invocation_mask,
        .VK_IMAGE_USAGE_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT = extensions.device.VK_EXT_attachment_feedback_loop_layout,
        .VK_IMAGE_USAGE_SAMPLE_WEIGHT_BIT_QCOM = extensions.device.VK_QCOM_image_processing,
        .VK_IMAGE_USAGE_SAMPLE_BLOCK_MATCH_BIT_QCOM = extensions.device.VK_QCOM_image_processing,
        .VK_IMAGE_USAGE_HOST_TRANSFER_BIT = true,
        .VK_IMAGE_USAGE_TENSOR_ALIASING_BIT_ARM = extensions.device.VK_ARM_tensors,
        .VK_IMAGE_USAGE_VIDEO_ENCODE_QUANTIZATION_DELTA_MAP_BIT_KHR = extensions.device.VK_KHR_video_encode_quantization_map,
        .VK_IMAGE_USAGE_VIDEO_ENCODE_EMPHASIS_MAP_BIT_KHR = extensions.device.VK_KHR_video_encode_quantization_map,
        .VK_IMAGE_USAGE_TILE_MEMORY_BIT_QCOM = extensions.device.VK_QCOM_tile_memory_heap,
    };
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkImageCreateFlags(extensions: *const Extensions, item: *const vk.VkImageCreateFlags) bool {
    const valid_value: vk.VkImageCreateFlags = .{
        .VK_IMAGE_CREATE_SPARSE_BINDING_BIT = true,
        .VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT = true,
        .VK_IMAGE_CREATE_SPARSE_ALIASED_BIT = true,
        .VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT = true,
        .VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT = true,
        .VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT = true,
        .VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT = true,
        .VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT = true,
        .VK_IMAGE_CREATE_EXTENDED_USAGE_BIT = true,
        .VK_IMAGE_CREATE_DISJOINT_BIT = true,
        .VK_IMAGE_CREATE_ALIAS_BIT = true,
        .VK_IMAGE_CREATE_PROTECTED_BIT = true,
        .VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT = extensions.device.VK_EXT_sample_locations,
        .VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV = extensions.device.VK_NV_corner_sampled_image,
        .VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT = extensions.device.VK_EXT_fragment_density_map,
        .VK_IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_EXT = extensions.device.VK_EXT_fragment_density_map_offset,
        .VK_IMAGE_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT = extensions.device.VK_EXT_descriptor_buffer,
        .VK_IMAGE_CREATE_2D_VIEW_COMPATIBLE_BIT_EXT = extensions.device.VK_EXT_image_2d_view_of_3d,
        .VK_IMAGE_CREATE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_BIT_EXT = extensions.device.VK_EXT_multisampled_render_to_single_sampled,
        .VK_IMAGE_CREATE_VIDEO_PROFILE_INDEPENDENT_BIT_KHR = extensions.device.VK_KHR_video_maintenance1,
    };
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkImageViewCreateFlags(extensions: *const Extensions, item: *const vk.VkImageViewCreateFlags) bool {
    const valid_value: vk.VkImageViewCreateFlags = .{
        .VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT = extensions.device.VK_EXT_fragment_density_map,
        .VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DEFERRED_BIT_EXT = extensions.device.VK_EXT_fragment_density_map2,
        .VK_IMAGE_VIEW_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT = extensions.device.VK_EXT_descriptor_buffer,
    };
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkPipelineCreateFlags(extensions: *const Extensions, item: *const vk.VkPipelineCreateFlags) bool {
    const valid_value: vk.VkPipelineCreateFlags = .{
        .VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT = true,
        .VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT = true,
        .VK_PIPELINE_CREATE_DERIVATIVE_BIT = true,
        .VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT = true,
        .VK_PIPELINE_CREATE_DISPATCH_BASE_BIT = true,
        .VK_PIPELINE_CREATE_DEFER_COMPILE_BIT_NV = extensions.device.VK_NV_ray_tracing,
        .VK_PIPELINE_CREATE_CAPTURE_STATISTICS_BIT_KHR = extensions.device.VK_KHR_pipeline_executable_properties,
        .VK_PIPELINE_CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR = extensions.device.VK_KHR_pipeline_executable_properties,
        .VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT = true,
        .VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT = true,
        .VK_PIPELINE_CREATE_LINK_TIME_OPTIMIZATION_BIT_EXT = extensions.device.VK_EXT_graphics_pipeline_library,
        .VK_PIPELINE_CREATE_LIBRARY_BIT_KHR = extensions.device.VK_KHR_pipeline_library,
        .VK_PIPELINE_CREATE_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR = extensions.device.VK_KHR_ray_tracing_pipeline,
        .VK_PIPELINE_CREATE_RAY_TRACING_SKIP_AABBS_BIT_KHR = extensions.device.VK_KHR_ray_tracing_pipeline,
        .VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR = extensions.device.VK_KHR_ray_tracing_pipeline,
        .VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR = extensions.device.VK_KHR_ray_tracing_pipeline,
        .VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR = extensions.device.VK_KHR_ray_tracing_pipeline,
        .VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR = extensions.device.VK_KHR_ray_tracing_pipeline,
        .VK_PIPELINE_CREATE_INDIRECT_BINDABLE_BIT_NV = extensions.device.VK_NV_device_generated_commands,
        .VK_PIPELINE_CREATE_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR = extensions.device.VK_KHR_ray_tracing_pipeline,
        .VK_PIPELINE_CREATE_RAY_TRACING_ALLOW_MOTION_BIT_NV = extensions.device.VK_NV_ray_tracing_motion_blur,
        .VK_PIPELINE_CREATE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = extensions.device.VK_KHR_fragment_shading_rate,
        .VK_PIPELINE_CREATE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT = extensions.device.VK_EXT_fragment_density_map,
        .VK_PIPELINE_CREATE_RETAIN_LINK_TIME_OPTIMIZATION_INFO_BIT_EXT = extensions.device.VK_EXT_graphics_pipeline_library,
        .VK_PIPELINE_CREATE_RAY_TRACING_OPACITY_MICROMAP_BIT_EXT = extensions.device.VK_EXT_opacity_micromap,
        .VK_PIPELINE_CREATE_COLOR_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT = extensions.device.VK_EXT_attachment_feedback_loop_layout,
        .VK_PIPELINE_CREATE_DEPTH_STENCIL_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT = extensions.device.VK_EXT_attachment_feedback_loop_layout,
        .VK_PIPELINE_CREATE_NO_PROTECTED_ACCESS_BIT = true,
        .VK_PIPELINE_CREATE_RAY_TRACING_DISPLACEMENT_MICROMAP_BIT_NV = extensions.device.VK_NV_displacement_micromap,
        .VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT = extensions.device.VK_EXT_descriptor_buffer,
        .VK_PIPELINE_CREATE_PROTECTED_ACCESS_ONLY_BIT = true,
    };
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkColorComponentFlags(extensions: *const Extensions, item: *const vk.VkColorComponentFlags) bool {
    const valid_value: vk.VkColorComponentFlags = .{
        .VK_COLOR_COMPONENT_R_BIT = true,
        .VK_COLOR_COMPONENT_G_BIT = true,
        .VK_COLOR_COMPONENT_B_BIT = true,
        .VK_COLOR_COMPONENT_A_BIT = true,
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkFenceCreateFlags(extensions: *const Extensions, item: *const vk.VkFenceCreateFlags) bool {
    const valid_value: vk.VkFenceCreateFlags = .{
        .VK_FENCE_CREATE_SIGNALED_BIT = true,
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkSemaphoreCreateFlags(extensions: *const Extensions, item: *const vk.VkSemaphoreCreateFlags) bool {
    const valid_value: vk.VkSemaphoreCreateFlags = .{
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkFormatFeatureFlags(extensions: *const Extensions, item: *const vk.VkFormatFeatureFlags) bool {
    const valid_value: vk.VkFormatFeatureFlags = .{
        .VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT = true,
        .VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT = true,
        .VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT = true,
        .VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT = true,
        .VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT = true,
        .VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT = true,
        .VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT = true,
        .VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT = true,
        .VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT = true,
        .VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT = true,
        .VK_FORMAT_FEATURE_BLIT_SRC_BIT = true,
        .VK_FORMAT_FEATURE_BLIT_DST_BIT = true,
        .VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT = true,
        .VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT = extensions.device.VK_EXT_filter_cubic,
        .VK_FORMAT_FEATURE_TRANSFER_SRC_BIT = true,
        .VK_FORMAT_FEATURE_TRANSFER_DST_BIT = true,
        .VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT = true,
        .VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT = true,
        .VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT = true,
        .VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT = true,
        .VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT = true,
        .VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT = true,
        .VK_FORMAT_FEATURE_DISJOINT_BIT = true,
        .VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT = true,
        .VK_FORMAT_FEATURE_FRAGMENT_DENSITY_MAP_BIT_EXT = extensions.device.VK_EXT_fragment_density_map,
        .VK_FORMAT_FEATURE_VIDEO_DECODE_OUTPUT_BIT_KHR = extensions.device.VK_KHR_video_decode_queue,
        .VK_FORMAT_FEATURE_VIDEO_DECODE_DPB_BIT_KHR = extensions.device.VK_KHR_video_decode_queue,
        .VK_FORMAT_FEATURE_VIDEO_ENCODE_INPUT_BIT_KHR = extensions.device.VK_KHR_video_encode_queue,
        .VK_FORMAT_FEATURE_VIDEO_ENCODE_DPB_BIT_KHR = extensions.device.VK_KHR_video_encode_queue,
        .VK_FORMAT_FEATURE_ACCELERATION_STRUCTURE_VERTEX_BUFFER_BIT_KHR = extensions.device.VK_KHR_acceleration_structure,
        .VK_FORMAT_FEATURE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = extensions.device.VK_KHR_fragment_shading_rate,
    };
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkQueryControlFlags(extensions: *const Extensions, item: *const vk.VkQueryControlFlags) bool {
    const valid_value: vk.VkQueryControlFlags = .{
        .VK_QUERY_CONTROL_PRECISE_BIT = true,
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkQueryResultFlags(extensions: *const Extensions, item: *const vk.VkQueryResultFlags) bool {
    const valid_value: vk.VkQueryResultFlags = .{
        .VK_QUERY_RESULT_64_BIT = true,
        .VK_QUERY_RESULT_WAIT_BIT = true,
        .VK_QUERY_RESULT_WITH_AVAILABILITY_BIT = true,
        .VK_QUERY_RESULT_PARTIAL_BIT = true,
        .VK_QUERY_RESULT_WITH_STATUS_BIT_KHR = extensions.device.VK_KHR_video_queue,
    };
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkShaderModuleCreateFlags(extensions: *const Extensions, item: *const vk.VkShaderModuleCreateFlags) bool {
    const valid_value: vk.VkShaderModuleCreateFlags = .{
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkEventCreateFlags(extensions: *const Extensions, item: *const vk.VkEventCreateFlags) bool {
    const valid_value: vk.VkEventCreateFlags = .{
        .VK_EVENT_CREATE_DEVICE_ONLY_BIT = true,
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkCommandPoolCreateFlags(extensions: *const Extensions, item: *const vk.VkCommandPoolCreateFlags) bool {
    const valid_value: vk.VkCommandPoolCreateFlags = .{
        .VK_COMMAND_POOL_CREATE_TRANSIENT_BIT = true,
        .VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT = true,
        .VK_COMMAND_POOL_CREATE_PROTECTED_BIT = true,
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkCommandPoolResetFlags(extensions: *const Extensions, item: *const vk.VkCommandPoolResetFlags) bool {
    const valid_value: vk.VkCommandPoolResetFlags = .{
        .VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT = true,
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkCommandBufferResetFlags(extensions: *const Extensions, item: *const vk.VkCommandBufferResetFlags) bool {
    const valid_value: vk.VkCommandBufferResetFlags = .{
        .VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT = true,
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkCommandBufferUsageFlags(extensions: *const Extensions, item: *const vk.VkCommandBufferUsageFlags) bool {
    const valid_value: vk.VkCommandBufferUsageFlags = .{
        .VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT = true,
        .VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT = true,
        .VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT = true,
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkQueryPipelineStatisticFlags(extensions: *const Extensions, item: *const vk.VkQueryPipelineStatisticFlags) bool {
    const valid_value: vk.VkQueryPipelineStatisticFlags = .{
        .VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT = true,
        .VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT = true,
        .VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT = true,
        .VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT = true,
        .VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT = true,
        .VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT = true,
        .VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT = true,
        .VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT = true,
        .VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT = true,
        .VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT = true,
        .VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT = true,
        .VK_QUERY_PIPELINE_STATISTIC_TASK_SHADER_INVOCATIONS_BIT_EXT = extensions.device.VK_EXT_mesh_shader,
        .VK_QUERY_PIPELINE_STATISTIC_MESH_SHADER_INVOCATIONS_BIT_EXT = extensions.device.VK_EXT_mesh_shader,
        .VK_QUERY_PIPELINE_STATISTIC_CLUSTER_CULLING_SHADER_INVOCATIONS_BIT_HUAWEI = extensions.device.VK_HUAWEI_cluster_culling_shader,
    };
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkMemoryMapFlags(extensions: *const Extensions, item: *const vk.VkMemoryMapFlags) bool {
    const valid_value: vk.VkMemoryMapFlags = .{
        .VK_MEMORY_MAP_PLACED_BIT_EXT = extensions.device.VK_EXT_map_memory_placed,
    };
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkMemoryUnmapFlags(extensions: *const Extensions, item: *const vk.VkMemoryUnmapFlags) bool {
    const valid_value: vk.VkMemoryUnmapFlags = .{
        .VK_MEMORY_UNMAP_RESERVE_BIT_EXT = extensions.device.VK_EXT_map_memory_placed,
    };
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkImageAspectFlags(extensions: *const Extensions, item: *const vk.VkImageAspectFlags) bool {
    const valid_value: vk.VkImageAspectFlags = .{
        .VK_IMAGE_ASPECT_COLOR_BIT = true,
        .VK_IMAGE_ASPECT_DEPTH_BIT = true,
        .VK_IMAGE_ASPECT_STENCIL_BIT = true,
        .VK_IMAGE_ASPECT_METADATA_BIT = true,
        .VK_IMAGE_ASPECT_PLANE_0_BIT = true,
        .VK_IMAGE_ASPECT_PLANE_1_BIT = true,
        .VK_IMAGE_ASPECT_PLANE_2_BIT = true,
        .VK_IMAGE_ASPECT_MEMORY_PLANE_0_BIT_EXT = extensions.device.VK_EXT_image_drm_format_modifier,
        .VK_IMAGE_ASPECT_MEMORY_PLANE_1_BIT_EXT = extensions.device.VK_EXT_image_drm_format_modifier,
        .VK_IMAGE_ASPECT_MEMORY_PLANE_2_BIT_EXT = extensions.device.VK_EXT_image_drm_format_modifier,
        .VK_IMAGE_ASPECT_MEMORY_PLANE_3_BIT_EXT = extensions.device.VK_EXT_image_drm_format_modifier,
    };
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkSparseMemoryBindFlags(extensions: *const Extensions, item: *const vk.VkSparseMemoryBindFlags) bool {
    const valid_value: vk.VkSparseMemoryBindFlags = .{
        .VK_SPARSE_MEMORY_BIND_METADATA_BIT = true,
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkSparseImageFormatFlags(extensions: *const Extensions, item: *const vk.VkSparseImageFormatFlags) bool {
    const valid_value: vk.VkSparseImageFormatFlags = .{
        .VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT = true,
        .VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT = true,
        .VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT = true,
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkSubpassDescriptionFlags(extensions: *const Extensions, item: *const vk.VkSubpassDescriptionFlags) bool {
    const valid_value: vk.VkSubpassDescriptionFlags = .{
        .VK_SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX = extensions.device.VK_NVX_multiview_per_view_attributes,
        .VK_SUBPASS_DESCRIPTION_PER_VIEW_POSITION_X_ONLY_BIT_NVX = extensions.device.VK_NVX_multiview_per_view_attributes,
        .VK_SUBPASS_DESCRIPTION_FRAGMENT_REGION_BIT_EXT = extensions.device.VK_EXT_custom_resolve,
        .VK_SUBPASS_DESCRIPTION_CUSTOM_RESOLVE_BIT_EXT = extensions.device.VK_EXT_custom_resolve,
        .VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_COLOR_ACCESS_BIT_EXT = extensions.device.VK_EXT_rasterization_order_attachment_access,
        .VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_EXT = extensions.device.VK_EXT_rasterization_order_attachment_access,
        .VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_EXT = extensions.device.VK_EXT_rasterization_order_attachment_access,
        .VK_SUBPASS_DESCRIPTION_ENABLE_LEGACY_DITHERING_BIT_EXT = extensions.device.VK_EXT_legacy_dithering,
        .VK_SUBPASS_DESCRIPTION_TILE_SHADING_APRON_BIT_QCOM = extensions.device.VK_QCOM_tile_shading,
    };
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkPipelineStageFlags(extensions: *const Extensions, item: *const vk.VkPipelineStageFlags) bool {
    const valid_value: vk.VkPipelineStageFlags = .{
        .VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT = true,
        .VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT = true,
        .VK_PIPELINE_STAGE_VERTEX_INPUT_BIT = true,
        .VK_PIPELINE_STAGE_VERTEX_SHADER_BIT = true,
        .VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT = true,
        .VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT = true,
        .VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT = true,
        .VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT = true,
        .VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT = true,
        .VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT = true,
        .VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT = true,
        .VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT = true,
        .VK_PIPELINE_STAGE_TRANSFER_BIT = true,
        .VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT = true,
        .VK_PIPELINE_STAGE_HOST_BIT = true,
        .VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT = true,
        .VK_PIPELINE_STAGE_ALL_COMMANDS_BIT = true,
        .VK_PIPELINE_STAGE_COMMAND_PREPROCESS_BIT_EXT = extensions.device.VK_EXT_device_generated_commands,
        .VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT = extensions.device.VK_EXT_conditional_rendering,
        .VK_PIPELINE_STAGE_TASK_SHADER_BIT_EXT = extensions.device.VK_EXT_mesh_shader,
        .VK_PIPELINE_STAGE_MESH_SHADER_BIT_EXT = extensions.device.VK_EXT_mesh_shader,
        .VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_KHR = extensions.device.VK_KHR_ray_tracing_pipeline,
        .VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = extensions.device.VK_KHR_fragment_shading_rate,
        .VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT = extensions.device.VK_EXT_fragment_density_map,
        .VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT = extensions.device.VK_EXT_transform_feedback,
        .VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR = extensions.device.VK_KHR_acceleration_structure,
    };
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkSampleCountFlags(extensions: *const Extensions, item: *const vk.VkSampleCountFlags) bool {
    const valid_value: vk.VkSampleCountFlags = .{
        .VK_SAMPLE_COUNT_1_BIT = true,
        .VK_SAMPLE_COUNT_2_BIT = true,
        .VK_SAMPLE_COUNT_4_BIT = true,
        .VK_SAMPLE_COUNT_8_BIT = true,
        .VK_SAMPLE_COUNT_16_BIT = true,
        .VK_SAMPLE_COUNT_32_BIT = true,
        .VK_SAMPLE_COUNT_64_BIT = true,
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkAttachmentDescriptionFlags(extensions: *const Extensions, item: *const vk.VkAttachmentDescriptionFlags) bool {
    const valid_value: vk.VkAttachmentDescriptionFlags = .{
        .VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT = true,
        .VK_ATTACHMENT_DESCRIPTION_RESOLVE_SKIP_TRANSFER_FUNCTION_BIT_KHR = extensions.device.VK_KHR_maintenance10,
        .VK_ATTACHMENT_DESCRIPTION_RESOLVE_ENABLE_TRANSFER_FUNCTION_BIT_KHR = extensions.device.VK_KHR_maintenance10,
    };
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkStencilFaceFlags(extensions: *const Extensions, item: *const vk.VkStencilFaceFlags) bool {
    const valid_value: vk.VkStencilFaceFlags = .{
        .VK_STENCIL_FACE_FRONT_BIT = true,
        .VK_STENCIL_FACE_BACK_BIT = true,
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkCullModeFlags(extensions: *const Extensions, item: *const vk.VkCullModeFlags) bool {
    const valid_value: vk.VkCullModeFlags = .{
        .VK_CULL_MODE_FRONT_BIT = true,
        .VK_CULL_MODE_BACK_BIT = true,
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkDescriptorPoolCreateFlags(extensions: *const Extensions, item: *const vk.VkDescriptorPoolCreateFlags) bool {
    const valid_value: vk.VkDescriptorPoolCreateFlags = .{
        .VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT = true,
        .VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT = true,
        .VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_EXT = extensions.device.VK_EXT_mutable_descriptor_type,
        .VK_DESCRIPTOR_POOL_CREATE_ALLOW_OVERALLOCATION_SETS_BIT_NV = extensions.device.VK_NV_descriptor_pool_overallocation,
        .VK_DESCRIPTOR_POOL_CREATE_ALLOW_OVERALLOCATION_POOLS_BIT_NV = extensions.device.VK_NV_descriptor_pool_overallocation,
    };
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkDescriptorPoolResetFlags(extensions: *const Extensions, item: *const vk.VkDescriptorPoolResetFlags) bool {
    const valid_value: vk.VkDescriptorPoolResetFlags = .{
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkDependencyFlags(extensions: *const Extensions, item: *const vk.VkDependencyFlags) bool {
    const valid_value: vk.VkDependencyFlags = .{
        .VK_DEPENDENCY_BY_REGION_BIT = true,
        .VK_DEPENDENCY_VIEW_LOCAL_BIT = true,
        .VK_DEPENDENCY_DEVICE_GROUP_BIT = true,
        .VK_DEPENDENCY_FEEDBACK_LOOP_BIT_EXT = extensions.device.VK_EXT_attachment_feedback_loop_layout,
        .VK_DEPENDENCY_QUEUE_FAMILY_OWNERSHIP_TRANSFER_USE_ALL_STAGES_BIT_KHR = extensions.device.VK_KHR_maintenance8,
        .VK_DEPENDENCY_ASYMMETRIC_EVENT_BIT_KHR = extensions.device.VK_KHR_maintenance9,
    };
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkSubgroupFeatureFlags(extensions: *const Extensions, item: *const vk.VkSubgroupFeatureFlags) bool {
    const valid_value: vk.VkSubgroupFeatureFlags = .{
        .VK_SUBGROUP_FEATURE_BASIC_BIT = true,
        .VK_SUBGROUP_FEATURE_VOTE_BIT = true,
        .VK_SUBGROUP_FEATURE_ARITHMETIC_BIT = true,
        .VK_SUBGROUP_FEATURE_BALLOT_BIT = true,
        .VK_SUBGROUP_FEATURE_SHUFFLE_BIT = true,
        .VK_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT = true,
        .VK_SUBGROUP_FEATURE_CLUSTERED_BIT = true,
        .VK_SUBGROUP_FEATURE_QUAD_BIT = true,
        .VK_SUBGROUP_FEATURE_PARTITIONED_BIT_NV = extensions.device.VK_NV_shader_subgroup_partitioned,
        .VK_SUBGROUP_FEATURE_ROTATE_BIT = true,
        .VK_SUBGROUP_FEATURE_ROTATE_CLUSTERED_BIT = true,
    };
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkIndirectCommandsLayoutUsageFlagsNV(extensions: *const Extensions, item: *const vk.VkIndirectCommandsLayoutUsageFlagsNV) bool {
    const valid_value: vk.VkIndirectCommandsLayoutUsageFlagsNV = .{
        .VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EXPLICIT_PREPROCESS_BIT_NV = true,
        .VK_INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT_NV = true,
        .VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_NV = true,
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkIndirectStateFlagsNV(extensions: *const Extensions, item: *const vk.VkIndirectStateFlagsNV) bool {
    const valid_value: vk.VkIndirectStateFlagsNV = .{
        .VK_INDIRECT_STATE_FLAG_FRONTFACE_BIT_NV = true,
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkGeometryFlagsKHR(extensions: *const Extensions, item: *const vk.VkGeometryFlagsKHR) bool {
    const valid_value: vk.VkGeometryFlagsKHR = .{
        .VK_GEOMETRY_OPAQUE_BIT_KHR = true,
        .VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_KHR = true,
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkGeometryInstanceFlagsKHR(extensions: *const Extensions, item: *const vk.VkGeometryInstanceFlagsKHR) bool {
    const valid_value: vk.VkGeometryInstanceFlagsKHR = .{
        .VK_GEOMETRY_INSTANCE_TRIANGLE_FACING_CULL_DISABLE_BIT_KHR = true,
        .VK_GEOMETRY_INSTANCE_TRIANGLE_FLIP_FACING_BIT_KHR = true,
        .VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_KHR = true,
        .VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_KHR = true,
        .VK_GEOMETRY_INSTANCE_FORCE_OPACITY_MICROMAP_2_STATE_BIT_EXT = extensions.device.VK_EXT_opacity_micromap,
        .VK_GEOMETRY_INSTANCE_DISABLE_OPACITY_MICROMAPS_BIT_EXT = extensions.device.VK_EXT_opacity_micromap,
    };
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkClusterAccelerationStructureGeometryFlagsNV(extensions: *const Extensions, item: *const vk.VkClusterAccelerationStructureGeometryFlagsNV) bool {
    const valid_value: vk.VkClusterAccelerationStructureGeometryFlagsNV = .{
        .VK_CLUSTER_ACCELERATION_STRUCTURE_GEOMETRY_CULL_DISABLE_BIT_NV = true,
        .VK_CLUSTER_ACCELERATION_STRUCTURE_GEOMETRY_NO_DUPLICATE_ANYHIT_INVOCATION_BIT_NV = true,
        .VK_CLUSTER_ACCELERATION_STRUCTURE_GEOMETRY_OPAQUE_BIT_NV = true,
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkClusterAccelerationStructureClusterFlagsNV(extensions: *const Extensions, item: *const vk.VkClusterAccelerationStructureClusterFlagsNV) bool {
    const valid_value: vk.VkClusterAccelerationStructureClusterFlagsNV = .{
        .VK_CLUSTER_ACCELERATION_STRUCTURE_CLUSTER_ALLOW_DISABLE_OPACITY_MICROMAPS_NV = true,
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkClusterAccelerationStructureAddressResolutionFlagsNV(extensions: *const Extensions, item: *const vk.VkClusterAccelerationStructureAddressResolutionFlagsNV) bool {
    const valid_value: vk.VkClusterAccelerationStructureAddressResolutionFlagsNV = .{
        .VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_DST_IMPLICIT_DATA_BIT_NV = true,
        .VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_SCRATCH_DATA_BIT_NV = true,
        .VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_DST_ADDRESS_ARRAY_BIT_NV = true,
        .VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_DST_SIZES_ARRAY_BIT_NV = true,
        .VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_SRC_INFOS_ARRAY_BIT_NV = true,
        .VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_SRC_INFOS_COUNT_BIT_NV = true,
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkBuildAccelerationStructureFlagsKHR(extensions: *const Extensions, item: *const vk.VkBuildAccelerationStructureFlagsKHR) bool {
    const valid_value: vk.VkBuildAccelerationStructureFlagsKHR = .{
        .VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_KHR = true,
        .VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_KHR = true,
        .VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_KHR = true,
        .VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_KHR = true,
        .VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_KHR = true,
        .VK_BUILD_ACCELERATION_STRUCTURE_MOTION_BIT_NV = extensions.device.VK_NV_ray_tracing_motion_blur,
        .VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_UPDATE_BIT_EXT = extensions.device.VK_EXT_opacity_micromap,
        .VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DISABLE_OPACITY_MICROMAPS_BIT_EXT = extensions.device.VK_EXT_opacity_micromap,
        .VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_DATA_UPDATE_BIT_EXT = extensions.device.VK_EXT_opacity_micromap,
        .VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DISPLACEMENT_MICROMAP_UPDATE_BIT_NV = extensions.device.VK_NV_displacement_micromap,
        .VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DATA_ACCESS_BIT_KHR = extensions.device.VK_KHR_ray_tracing_position_fetch,
        .VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_CLUSTER_OPACITY_MICROMAPS_BIT_NV = extensions.device.VK_NV_cluster_acceleration_structure,
    };
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkPrivateDataSlotCreateFlags(extensions: *const Extensions, item: *const vk.VkPrivateDataSlotCreateFlags) bool {
    const valid_value: vk.VkPrivateDataSlotCreateFlags = .{
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkAccelerationStructureCreateFlagsKHR(extensions: *const Extensions, item: *const vk.VkAccelerationStructureCreateFlagsKHR) bool {
    const valid_value: vk.VkAccelerationStructureCreateFlagsKHR = .{
        .VK_ACCELERATION_STRUCTURE_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR = true,
        .VK_ACCELERATION_STRUCTURE_CREATE_MOTION_BIT_NV = extensions.device.VK_NV_ray_tracing_motion_blur,
        .VK_ACCELERATION_STRUCTURE_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT = extensions.device.VK_EXT_descriptor_buffer,
    };
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkDescriptorUpdateTemplateCreateFlags(extensions: *const Extensions, item: *const vk.VkDescriptorUpdateTemplateCreateFlags) bool {
    const valid_value: vk.VkDescriptorUpdateTemplateCreateFlags = .{
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkPipelineCreationFeedbackFlags(extensions: *const Extensions, item: *const vk.VkPipelineCreationFeedbackFlags) bool {
    const valid_value: vk.VkPipelineCreationFeedbackFlags = .{
        .VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT = true,
        .VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT = true,
        .VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT = true,
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkPerformanceCounterDescriptionFlagsKHR(extensions: *const Extensions, item: *const vk.VkPerformanceCounterDescriptionFlagsKHR) bool {
    const valid_value: vk.VkPerformanceCounterDescriptionFlagsKHR = .{
        .VK_PERFORMANCE_COUNTER_DESCRIPTION_PERFORMANCE_IMPACTING_BIT_KHR = true,
        .VK_PERFORMANCE_COUNTER_DESCRIPTION_CONCURRENTLY_IMPACTED_BIT_KHR = true,
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkAcquireProfilingLockFlagsKHR(extensions: *const Extensions, item: *const vk.VkAcquireProfilingLockFlagsKHR) bool {
    const valid_value: vk.VkAcquireProfilingLockFlagsKHR = .{
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkSemaphoreWaitFlags(extensions: *const Extensions, item: *const vk.VkSemaphoreWaitFlags) bool {
    const valid_value: vk.VkSemaphoreWaitFlags = .{
        .VK_SEMAPHORE_WAIT_ANY_BIT = true,
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkPipelineCompilerControlFlagsAMD(extensions: *const Extensions, item: *const vk.VkPipelineCompilerControlFlagsAMD) bool {
    const valid_value: vk.VkPipelineCompilerControlFlagsAMD = .{
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkShaderCorePropertiesFlagsAMD(extensions: *const Extensions, item: *const vk.VkShaderCorePropertiesFlagsAMD) bool {
    const valid_value: vk.VkShaderCorePropertiesFlagsAMD = .{
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkDeviceDiagnosticsConfigFlagsNV(extensions: *const Extensions, item: *const vk.VkDeviceDiagnosticsConfigFlagsNV) bool {
    const valid_value: vk.VkDeviceDiagnosticsConfigFlagsNV = .{
        .VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_SHADER_DEBUG_INFO_BIT_NV = true,
        .VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_RESOURCE_TRACKING_BIT_NV = true,
        .VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_AUTOMATIC_CHECKPOINTS_BIT_NV = true,
        .VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_SHADER_ERROR_REPORTING_BIT_NV = true,
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkRefreshObjectFlagsKHR(extensions: *const Extensions, item: *const vk.VkRefreshObjectFlagsKHR) bool {
    const valid_value: vk.VkRefreshObjectFlagsKHR = .{
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkAccessFlags2(extensions: *const Extensions, item: *const vk.VkAccessFlags2) bool {
    const valid_value: vk.VkAccessFlags2 = .{
        .VK_ACCESS_2_INDIRECT_COMMAND_READ_BIT = true,
        .VK_ACCESS_2_INDEX_READ_BIT = true,
        .VK_ACCESS_2_VERTEX_ATTRIBUTE_READ_BIT = true,
        .VK_ACCESS_2_UNIFORM_READ_BIT = true,
        .VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT = true,
        .VK_ACCESS_2_SHADER_READ_BIT = true,
        .VK_ACCESS_2_SHADER_WRITE_BIT = true,
        .VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT = true,
        .VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT = true,
        .VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT = true,
        .VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT = true,
        .VK_ACCESS_2_TRANSFER_READ_BIT = true,
        .VK_ACCESS_2_TRANSFER_WRITE_BIT = true,
        .VK_ACCESS_2_HOST_READ_BIT = true,
        .VK_ACCESS_2_HOST_WRITE_BIT = true,
        .VK_ACCESS_2_MEMORY_READ_BIT = true,
        .VK_ACCESS_2_MEMORY_WRITE_BIT = true,
        .VK_ACCESS_2_COMMAND_PREPROCESS_READ_BIT_EXT = extensions.device.VK_KHR_synchronization2,
        .VK_ACCESS_2_COMMAND_PREPROCESS_WRITE_BIT_EXT = extensions.device.VK_KHR_synchronization2,
        .VK_ACCESS_2_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT = extensions.device.VK_KHR_synchronization2,
        .VK_ACCESS_2_CONDITIONAL_RENDERING_READ_BIT_EXT = extensions.device.VK_KHR_synchronization2,
        .VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_KHR = extensions.device.VK_KHR_synchronization2,
        .VK_ACCESS_2_ACCELERATION_STRUCTURE_WRITE_BIT_KHR = extensions.device.VK_KHR_synchronization2,
        .VK_ACCESS_2_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR = extensions.device.VK_KHR_synchronization2,
        .VK_ACCESS_2_FRAGMENT_DENSITY_MAP_READ_BIT_EXT = extensions.device.VK_KHR_synchronization2,
        .VK_ACCESS_2_TRANSFORM_FEEDBACK_WRITE_BIT_EXT = extensions.device.VK_KHR_synchronization2,
        .VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT = extensions.device.VK_KHR_synchronization2,
        .VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT = extensions.device.VK_KHR_synchronization2,
        .VK_ACCESS_2_SHADER_SAMPLED_READ_BIT = true,
        .VK_ACCESS_2_SHADER_STORAGE_READ_BIT = true,
        .VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT = true,
        .VK_ACCESS_2_VIDEO_DECODE_READ_BIT_KHR = extensions.device.VK_KHR_video_decode_queue,
        .VK_ACCESS_2_VIDEO_DECODE_WRITE_BIT_KHR = extensions.device.VK_KHR_video_decode_queue,
        .VK_ACCESS_2_VIDEO_ENCODE_READ_BIT_KHR = extensions.device.VK_KHR_video_encode_queue,
        .VK_ACCESS_2_VIDEO_ENCODE_WRITE_BIT_KHR = extensions.device.VK_KHR_video_encode_queue,
        .VK_ACCESS_2_INVOCATION_MASK_READ_BIT_HUAWEI = extensions.device.VK_HUAWEI_invocation_mask,
        .VK_ACCESS_2_SHADER_BINDING_TABLE_READ_BIT_KHR = extensions.device.VK_KHR_ray_tracing_maintenance1,
        .VK_ACCESS_2_DESCRIPTOR_BUFFER_READ_BIT_EXT = extensions.device.VK_EXT_descriptor_buffer,
        .VK_ACCESS_2_OPTICAL_FLOW_READ_BIT_NV = extensions.device.VK_NV_optical_flow,
        .VK_ACCESS_2_OPTICAL_FLOW_WRITE_BIT_NV = extensions.device.VK_NV_optical_flow,
        .VK_ACCESS_2_MICROMAP_READ_BIT_EXT = extensions.device.VK_EXT_opacity_micromap,
        .VK_ACCESS_2_MICROMAP_WRITE_BIT_EXT = extensions.device.VK_EXT_opacity_micromap,
        .VK_ACCESS_2_DATA_GRAPH_READ_BIT_ARM = extensions.device.VK_ARM_data_graph,
        .VK_ACCESS_2_DATA_GRAPH_WRITE_BIT_ARM = extensions.device.VK_ARM_data_graph,
        .VK_ACCESS_2_SHADER_TILE_ATTACHMENT_READ_BIT_QCOM = extensions.device.VK_QCOM_tile_shading,
        .VK_ACCESS_2_SHADER_TILE_ATTACHMENT_WRITE_BIT_QCOM = extensions.device.VK_QCOM_tile_shading,
        .VK_ACCESS_2_MEMORY_DECOMPRESSION_READ_BIT_EXT = extensions.device.VK_EXT_memory_decompression,
        .VK_ACCESS_2_MEMORY_DECOMPRESSION_WRITE_BIT_EXT = extensions.device.VK_EXT_memory_decompression,
    };
    const valid_bits: u64 = @bitCast(valid_value);
    const current_bits: u64 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkPipelineStageFlags2(extensions: *const Extensions, item: *const vk.VkPipelineStageFlags2) bool {
    const valid_value: vk.VkPipelineStageFlags2 = .{
        .VK_PIPELINE_STAGE_2_TOP_OF_PIPE_BIT = true,
        .VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT = true,
        .VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT = true,
        .VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT = true,
        .VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT = true,
        .VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT = true,
        .VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT = true,
        .VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT = true,
        .VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT = true,
        .VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT = true,
        .VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT = true,
        .VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT = true,
        .VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT = true,
        .VK_PIPELINE_STAGE_2_BOTTOM_OF_PIPE_BIT = true,
        .VK_PIPELINE_STAGE_2_HOST_BIT = true,
        .VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT = true,
        .VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT = true,
        .VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_EXT = extensions.device.VK_KHR_synchronization2,
        .VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT = extensions.device.VK_KHR_synchronization2,
        .VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_EXT = extensions.device.VK_KHR_synchronization2,
        .VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_EXT = extensions.device.VK_KHR_synchronization2,
        .VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR = extensions.device.VK_KHR_synchronization2,
        .VK_PIPELINE_STAGE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = extensions.device.VK_KHR_synchronization2,
        .VK_PIPELINE_STAGE_2_FRAGMENT_DENSITY_PROCESS_BIT_EXT = extensions.device.VK_KHR_synchronization2,
        .VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT = extensions.device.VK_KHR_synchronization2,
        .VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR = extensions.device.VK_KHR_synchronization2,
        .VK_PIPELINE_STAGE_2_VIDEO_DECODE_BIT_KHR = extensions.device.VK_KHR_video_decode_queue,
        .VK_PIPELINE_STAGE_2_VIDEO_ENCODE_BIT_KHR = extensions.device.VK_KHR_video_encode_queue,
        .VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_COPY_BIT_KHR = extensions.device.VK_KHR_ray_tracing_maintenance1,
        .VK_PIPELINE_STAGE_2_OPTICAL_FLOW_BIT_NV = extensions.device.VK_NV_optical_flow,
        .VK_PIPELINE_STAGE_2_MICROMAP_BUILD_BIT_EXT = extensions.device.VK_EXT_opacity_micromap,
        .VK_PIPELINE_STAGE_2_COPY_BIT = true,
        .VK_PIPELINE_STAGE_2_RESOLVE_BIT = true,
        .VK_PIPELINE_STAGE_2_BLIT_BIT = true,
        .VK_PIPELINE_STAGE_2_CLEAR_BIT = true,
        .VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT = true,
        .VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT = true,
        .VK_PIPELINE_STAGE_2_PRE_RASTERIZATION_SHADERS_BIT = true,
        .VK_PIPELINE_STAGE_2_SUBPASS_SHADER_BIT_HUAWEI = extensions.device.VK_HUAWEI_subpass_shading,
        .VK_PIPELINE_STAGE_2_INVOCATION_MASK_BIT_HUAWEI = extensions.device.VK_HUAWEI_invocation_mask,
        .VK_PIPELINE_STAGE_2_CLUSTER_CULLING_SHADER_BIT_HUAWEI = extensions.device.VK_HUAWEI_cluster_culling_shader,
        .VK_PIPELINE_STAGE_2_DATA_GRAPH_BIT_ARM = extensions.device.VK_ARM_data_graph,
        .VK_PIPELINE_STAGE_2_CONVERT_COOPERATIVE_VECTOR_MATRIX_BIT_NV = extensions.device.VK_NV_cooperative_vector,
        .VK_PIPELINE_STAGE_2_MEMORY_DECOMPRESSION_BIT_EXT = extensions.device.VK_EXT_memory_decompression,
        .VK_PIPELINE_STAGE_2_COPY_INDIRECT_BIT_KHR = extensions.device.VK_KHR_copy_memory_indirect,
    };
    const valid_bits: u64 = @bitCast(valid_value);
    const current_bits: u64 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkAccelerationStructureMotionInfoFlagsNV(extensions: *const Extensions, item: *const vk.VkAccelerationStructureMotionInfoFlagsNV) bool {
    const valid_value: vk.VkAccelerationStructureMotionInfoFlagsNV = .{
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkAccelerationStructureMotionInstanceFlagsNV(extensions: *const Extensions, item: *const vk.VkAccelerationStructureMotionInstanceFlagsNV) bool {
    const valid_value: vk.VkAccelerationStructureMotionInstanceFlagsNV = .{
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkFormatFeatureFlags2(extensions: *const Extensions, item: *const vk.VkFormatFeatureFlags2) bool {
    const valid_value: vk.VkFormatFeatureFlags2 = .{
        .VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_BIT = true,
        .VK_FORMAT_FEATURE_2_STORAGE_IMAGE_BIT = true,
        .VK_FORMAT_FEATURE_2_STORAGE_IMAGE_ATOMIC_BIT = true,
        .VK_FORMAT_FEATURE_2_UNIFORM_TEXEL_BUFFER_BIT = true,
        .VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_BIT = true,
        .VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_ATOMIC_BIT = true,
        .VK_FORMAT_FEATURE_2_VERTEX_BUFFER_BIT = true,
        .VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BIT = true,
        .VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BLEND_BIT = true,
        .VK_FORMAT_FEATURE_2_DEPTH_STENCIL_ATTACHMENT_BIT = true,
        .VK_FORMAT_FEATURE_2_BLIT_SRC_BIT = true,
        .VK_FORMAT_FEATURE_2_BLIT_DST_BIT = true,
        .VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_LINEAR_BIT = true,
        .VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_CUBIC_BIT = true,
        .VK_FORMAT_FEATURE_2_TRANSFER_SRC_BIT = true,
        .VK_FORMAT_FEATURE_2_TRANSFER_DST_BIT = true,
        .VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_MINMAX_BIT = true,
        .VK_FORMAT_FEATURE_2_MIDPOINT_CHROMA_SAMPLES_BIT = true,
        .VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT = true,
        .VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT = true,
        .VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT = true,
        .VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT = true,
        .VK_FORMAT_FEATURE_2_DISJOINT_BIT = true,
        .VK_FORMAT_FEATURE_2_COSITED_CHROMA_SAMPLES_BIT = true,
        .VK_FORMAT_FEATURE_2_FRAGMENT_DENSITY_MAP_BIT_EXT = extensions.device.VK_EXT_fragment_density_map,
        .VK_FORMAT_FEATURE_2_VIDEO_DECODE_OUTPUT_BIT_KHR = extensions.device.VK_KHR_video_decode_queue,
        .VK_FORMAT_FEATURE_2_VIDEO_DECODE_DPB_BIT_KHR = extensions.device.VK_KHR_video_decode_queue,
        .VK_FORMAT_FEATURE_2_VIDEO_ENCODE_INPUT_BIT_KHR = extensions.device.VK_KHR_video_encode_queue,
        .VK_FORMAT_FEATURE_2_VIDEO_ENCODE_DPB_BIT_KHR = extensions.device.VK_KHR_video_encode_queue,
        .VK_FORMAT_FEATURE_2_ACCELERATION_STRUCTURE_VERTEX_BUFFER_BIT_KHR = extensions.device.VK_KHR_acceleration_structure,
        .VK_FORMAT_FEATURE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = extensions.device.VK_KHR_fragment_shading_rate,
        .VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT = true,
        .VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT = true,
        .VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT = true,
        .VK_FORMAT_FEATURE_2_WEIGHT_IMAGE_BIT_QCOM = extensions.device.VK_QCOM_image_processing,
        .VK_FORMAT_FEATURE_2_WEIGHT_SAMPLED_IMAGE_BIT_QCOM = extensions.device.VK_QCOM_image_processing,
        .VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM = extensions.device.VK_QCOM_image_processing,
        .VK_FORMAT_FEATURE_2_BOX_FILTER_SAMPLED_BIT_QCOM = extensions.device.VK_QCOM_image_processing,
        .VK_FORMAT_FEATURE_2_LINEAR_COLOR_ATTACHMENT_BIT_NV = extensions.device.VK_NV_linear_color_attachment,
        .VK_FORMAT_FEATURE_2_TENSOR_SHADER_BIT_ARM = extensions.device.VK_ARM_tensors,
        .VK_FORMAT_FEATURE_2_OPTICAL_FLOW_IMAGE_BIT_NV = extensions.device.VK_NV_optical_flow,
        .VK_FORMAT_FEATURE_2_OPTICAL_FLOW_VECTOR_BIT_NV = extensions.device.VK_NV_optical_flow,
        .VK_FORMAT_FEATURE_2_OPTICAL_FLOW_COST_BIT_NV = extensions.device.VK_NV_optical_flow,
        .VK_FORMAT_FEATURE_2_TENSOR_IMAGE_ALIASING_BIT_ARM = extensions.device.VK_ARM_tensors,
        .VK_FORMAT_FEATURE_2_HOST_IMAGE_TRANSFER_BIT = true,
        .VK_FORMAT_FEATURE_2_TENSOR_DATA_GRAPH_BIT_ARM = extensions.device.VK_ARM_data_graph,
        .VK_FORMAT_FEATURE_2_VIDEO_ENCODE_QUANTIZATION_DELTA_MAP_BIT_KHR = extensions.device.VK_KHR_video_encode_quantization_map,
        .VK_FORMAT_FEATURE_2_VIDEO_ENCODE_EMPHASIS_MAP_BIT_KHR = extensions.device.VK_KHR_video_encode_quantization_map,
        .VK_FORMAT_FEATURE_2_ACCELERATION_STRUCTURE_RADIUS_BUFFER_BIT_NV = extensions.device.VK_NV_ray_tracing_linear_swept_spheres,
        .VK_FORMAT_FEATURE_2_DEPTH_COPY_ON_COMPUTE_QUEUE_BIT_KHR = extensions.device.VK_KHR_maintenance10,
        .VK_FORMAT_FEATURE_2_DEPTH_COPY_ON_TRANSFER_QUEUE_BIT_KHR = extensions.device.VK_KHR_maintenance10,
        .VK_FORMAT_FEATURE_2_STENCIL_COPY_ON_COMPUTE_QUEUE_BIT_KHR = extensions.device.VK_KHR_maintenance10,
        .VK_FORMAT_FEATURE_2_STENCIL_COPY_ON_TRANSFER_QUEUE_BIT_KHR = extensions.device.VK_KHR_maintenance10,
        .VK_FORMAT_FEATURE_2_COPY_IMAGE_INDIRECT_DST_BIT_KHR = extensions.device.VK_KHR_copy_memory_indirect,
    };
    const valid_bits: u64 = @bitCast(valid_value);
    const current_bits: u64 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkRenderingFlags(extensions: *const Extensions, item: *const vk.VkRenderingFlags) bool {
    const valid_value: vk.VkRenderingFlags = .{
        .VK_RENDERING_CONTENTS_SECONDARY_COMMAND_BUFFERS_BIT = true,
        .VK_RENDERING_SUSPENDING_BIT = true,
        .VK_RENDERING_RESUMING_BIT = true,
        .VK_RENDERING_ENABLE_LEGACY_DITHERING_BIT_EXT = extensions.device.VK_EXT_legacy_dithering,
        .VK_RENDERING_CONTENTS_INLINE_BIT_KHR = extensions.device.VK_KHR_maintenance7,
        .VK_RENDERING_PER_LAYER_FRAGMENT_DENSITY_BIT_VALVE = extensions.device.VK_VALVE_fragment_density_map_layered,
        .VK_RENDERING_FRAGMENT_REGION_BIT_EXT = extensions.device.VK_EXT_custom_resolve,
        .VK_RENDERING_CUSTOM_RESOLVE_BIT_EXT = extensions.device.VK_EXT_custom_resolve,
        .VK_RENDERING_LOCAL_READ_CONCURRENT_ACCESS_CONTROL_BIT_KHR = extensions.device.VK_KHR_maintenance10,
    };
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkMemoryDecompressionMethodFlagsEXT(extensions: *const Extensions, item: *const vk.VkMemoryDecompressionMethodFlagsEXT) bool {
    const valid_value: vk.VkMemoryDecompressionMethodFlagsEXT = .{
        .VK_MEMORY_DECOMPRESSION_METHOD_GDEFLATE_1_0_BIT_EXT = true,
    };
    _ = extensions;
    const valid_bits: u64 = @bitCast(valid_value);
    const current_bits: u64 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkBuildMicromapFlagsEXT(extensions: *const Extensions, item: *const vk.VkBuildMicromapFlagsEXT) bool {
    const valid_value: vk.VkBuildMicromapFlagsEXT = .{
        .VK_BUILD_MICROMAP_PREFER_FAST_TRACE_BIT_EXT = true,
        .VK_BUILD_MICROMAP_PREFER_FAST_BUILD_BIT_EXT = true,
        .VK_BUILD_MICROMAP_ALLOW_COMPACTION_BIT_EXT = true,
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkMicromapCreateFlagsEXT(extensions: *const Extensions, item: *const vk.VkMicromapCreateFlagsEXT) bool {
    const valid_value: vk.VkMicromapCreateFlagsEXT = .{
        .VK_MICROMAP_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT = true,
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkIndirectCommandsLayoutUsageFlagsEXT(extensions: *const Extensions, item: *const vk.VkIndirectCommandsLayoutUsageFlagsEXT) bool {
    const valid_value: vk.VkIndirectCommandsLayoutUsageFlagsEXT = .{
        .VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EXPLICIT_PREPROCESS_BIT_EXT = true,
        .VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_EXT = true,
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkIndirectCommandsInputModeFlagsEXT(extensions: *const Extensions, item: *const vk.VkIndirectCommandsInputModeFlagsEXT) bool {
    const valid_value: vk.VkIndirectCommandsInputModeFlagsEXT = .{
        .VK_INDIRECT_COMMANDS_INPUT_MODE_VULKAN_INDEX_BUFFER_EXT = true,
        .VK_INDIRECT_COMMANDS_INPUT_MODE_DXGI_INDEX_BUFFER_EXT = true,
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkDirectDriverLoadingFlagsLUNARG(extensions: *const Extensions, item: *const vk.VkDirectDriverLoadingFlagsLUNARG) bool {
    const valid_value: vk.VkDirectDriverLoadingFlagsLUNARG = .{
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkPipelineCreateFlags2(extensions: *const Extensions, item: *const vk.VkPipelineCreateFlags2) bool {
    const valid_value: vk.VkPipelineCreateFlags2 = .{
        .VK_PIPELINE_CREATE_2_DISABLE_OPTIMIZATION_BIT = true,
        .VK_PIPELINE_CREATE_2_ALLOW_DERIVATIVES_BIT = true,
        .VK_PIPELINE_CREATE_2_DERIVATIVE_BIT = true,
        .VK_PIPELINE_CREATE_2_VIEW_INDEX_FROM_DEVICE_INDEX_BIT = true,
        .VK_PIPELINE_CREATE_2_DISPATCH_BASE_BIT = true,
        .VK_PIPELINE_CREATE_2_DEFER_COMPILE_BIT_NV = extensions.device.VK_KHR_maintenance5,
        .VK_PIPELINE_CREATE_2_CAPTURE_STATISTICS_BIT_KHR = extensions.device.VK_KHR_maintenance5,
        .VK_PIPELINE_CREATE_2_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR = extensions.device.VK_KHR_maintenance5,
        .VK_PIPELINE_CREATE_2_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT = true,
        .VK_PIPELINE_CREATE_2_EARLY_RETURN_ON_FAILURE_BIT = true,
        .VK_PIPELINE_CREATE_2_LINK_TIME_OPTIMIZATION_BIT_EXT = extensions.device.VK_KHR_maintenance5,
        .VK_PIPELINE_CREATE_2_LIBRARY_BIT_KHR = extensions.device.VK_KHR_maintenance5,
        .VK_PIPELINE_CREATE_2_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR = extensions.device.VK_KHR_maintenance5,
        .VK_PIPELINE_CREATE_2_RAY_TRACING_SKIP_AABBS_BIT_KHR = extensions.device.VK_KHR_maintenance5,
        .VK_PIPELINE_CREATE_2_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR = extensions.device.VK_KHR_maintenance5,
        .VK_PIPELINE_CREATE_2_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR = extensions.device.VK_KHR_maintenance5,
        .VK_PIPELINE_CREATE_2_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR = extensions.device.VK_KHR_maintenance5,
        .VK_PIPELINE_CREATE_2_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR = extensions.device.VK_KHR_maintenance5,
        .VK_PIPELINE_CREATE_2_INDIRECT_BINDABLE_BIT_NV = extensions.device.VK_KHR_maintenance5,
        .VK_PIPELINE_CREATE_2_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR = extensions.device.VK_KHR_maintenance5,
        .VK_PIPELINE_CREATE_2_RAY_TRACING_ALLOW_MOTION_BIT_NV = extensions.device.VK_KHR_maintenance5,
        .VK_PIPELINE_CREATE_2_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = extensions.device.VK_KHR_maintenance5,
        .VK_PIPELINE_CREATE_2_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT = extensions.device.VK_KHR_maintenance5,
        .VK_PIPELINE_CREATE_2_RETAIN_LINK_TIME_OPTIMIZATION_INFO_BIT_EXT = extensions.device.VK_KHR_maintenance5,
        .VK_PIPELINE_CREATE_2_RAY_TRACING_OPACITY_MICROMAP_BIT_EXT = extensions.device.VK_KHR_maintenance5,
        .VK_PIPELINE_CREATE_2_COLOR_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT = extensions.device.VK_KHR_maintenance5,
        .VK_PIPELINE_CREATE_2_DEPTH_STENCIL_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT = extensions.device.VK_KHR_maintenance5,
        .VK_PIPELINE_CREATE_2_NO_PROTECTED_ACCESS_BIT = true,
        .VK_PIPELINE_CREATE_2_RAY_TRACING_DISPLACEMENT_MICROMAP_BIT_NV = extensions.device.VK_KHR_maintenance5,
        .VK_PIPELINE_CREATE_2_DESCRIPTOR_BUFFER_BIT_EXT = extensions.device.VK_KHR_maintenance5,
        .VK_PIPELINE_CREATE_2_PROTECTED_ACCESS_ONLY_BIT = true,
        .VK_PIPELINE_CREATE_2_CAPTURE_DATA_BIT_KHR = extensions.device.VK_KHR_pipeline_binary,
        .VK_PIPELINE_CREATE_2_EXECUTION_GRAPH_BIT_AMDX = extensions.device.VK_AMDX_shader_enqueue,
        .VK_PIPELINE_CREATE_2_RAY_TRACING_ALLOW_SPHERES_AND_LINEAR_SWEPT_SPHERES_BIT_NV = extensions.device.VK_NV_ray_tracing_linear_swept_spheres,
        .VK_PIPELINE_CREATE_2_ENABLE_LEGACY_DITHERING_BIT_EXT = extensions.device.VK_EXT_legacy_dithering,
        .VK_PIPELINE_CREATE_2_DISALLOW_OPACITY_MICROMAP_BIT_ARM = extensions.device.VK_ARM_pipeline_opacity_micromap,
        .VK_PIPELINE_CREATE_2_INDIRECT_BINDABLE_BIT_EXT = extensions.device.VK_EXT_device_generated_commands,
        .VK_PIPELINE_CREATE_2_PER_LAYER_FRAGMENT_DENSITY_BIT_VALVE = extensions.device.VK_VALVE_fragment_density_map_layered,
        .VK_PIPELINE_CREATE_2_64_BIT_INDEXING_BIT_EXT = extensions.device.VK_EXT_shader_64bit_indexing,
    };
    const valid_bits: u64 = @bitCast(valid_value);
    const current_bits: u64 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkBufferUsageFlags2(extensions: *const Extensions, item: *const vk.VkBufferUsageFlags2) bool {
    const valid_value: vk.VkBufferUsageFlags2 = .{
        .VK_BUFFER_USAGE_2_TRANSFER_SRC_BIT = true,
        .VK_BUFFER_USAGE_2_TRANSFER_DST_BIT = true,
        .VK_BUFFER_USAGE_2_UNIFORM_TEXEL_BUFFER_BIT = true,
        .VK_BUFFER_USAGE_2_STORAGE_TEXEL_BUFFER_BIT = true,
        .VK_BUFFER_USAGE_2_UNIFORM_BUFFER_BIT = true,
        .VK_BUFFER_USAGE_2_STORAGE_BUFFER_BIT = true,
        .VK_BUFFER_USAGE_2_INDEX_BUFFER_BIT = true,
        .VK_BUFFER_USAGE_2_VERTEX_BUFFER_BIT = true,
        .VK_BUFFER_USAGE_2_INDIRECT_BUFFER_BIT = true,
        .VK_BUFFER_USAGE_2_CONDITIONAL_RENDERING_BIT_EXT = extensions.device.VK_KHR_maintenance5,
        .VK_BUFFER_USAGE_2_SHADER_BINDING_TABLE_BIT_KHR = extensions.device.VK_KHR_maintenance5,
        .VK_BUFFER_USAGE_2_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT = extensions.device.VK_KHR_maintenance5,
        .VK_BUFFER_USAGE_2_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT = extensions.device.VK_KHR_maintenance5,
        .VK_BUFFER_USAGE_2_VIDEO_DECODE_SRC_BIT_KHR = extensions.device.VK_KHR_maintenance5,
        .VK_BUFFER_USAGE_2_VIDEO_DECODE_DST_BIT_KHR = extensions.device.VK_KHR_maintenance5,
        .VK_BUFFER_USAGE_2_VIDEO_ENCODE_DST_BIT_KHR = extensions.device.VK_KHR_maintenance5,
        .VK_BUFFER_USAGE_2_VIDEO_ENCODE_SRC_BIT_KHR = extensions.device.VK_KHR_maintenance5,
        .VK_BUFFER_USAGE_2_SHADER_DEVICE_ADDRESS_BIT = true,
        .VK_BUFFER_USAGE_2_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR = extensions.device.VK_KHR_maintenance5,
        .VK_BUFFER_USAGE_2_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR = extensions.device.VK_KHR_maintenance5,
        .VK_BUFFER_USAGE_2_SAMPLER_DESCRIPTOR_BUFFER_BIT_EXT = extensions.device.VK_KHR_maintenance5,
        .VK_BUFFER_USAGE_2_RESOURCE_DESCRIPTOR_BUFFER_BIT_EXT = extensions.device.VK_KHR_maintenance5,
        .VK_BUFFER_USAGE_2_MICROMAP_BUILD_INPUT_READ_ONLY_BIT_EXT = extensions.device.VK_KHR_maintenance5,
        .VK_BUFFER_USAGE_2_MICROMAP_STORAGE_BIT_EXT = extensions.device.VK_KHR_maintenance5,
        .VK_BUFFER_USAGE_2_EXECUTION_GRAPH_SCRATCH_BIT_AMDX = extensions.device.VK_AMDX_shader_enqueue,
        .VK_BUFFER_USAGE_2_PUSH_DESCRIPTORS_DESCRIPTOR_BUFFER_BIT_EXT = extensions.device.VK_KHR_maintenance5,
        .VK_BUFFER_USAGE_2_TILE_MEMORY_BIT_QCOM = extensions.device.VK_QCOM_tile_memory_heap,
        .VK_BUFFER_USAGE_2_DATA_GRAPH_FOREIGN_DESCRIPTOR_BIT_ARM = extensions.device.VK_ARM_data_graph,
        .VK_BUFFER_USAGE_2_PREPROCESS_BUFFER_BIT_EXT = extensions.device.VK_EXT_device_generated_commands,
        .VK_BUFFER_USAGE_2_MEMORY_DECOMPRESSION_BIT_EXT = extensions.device.VK_EXT_memory_decompression,
        .VK_BUFFER_USAGE_2_COMPRESSED_DATA_DGF1_BIT_AMDX = extensions.device.VK_AMDX_dense_geometry_format,
    };
    const valid_bits: u64 = @bitCast(valid_value);
    const current_bits: u64 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkAddressCopyFlagsKHR(extensions: *const Extensions, item: *const vk.VkAddressCopyFlagsKHR) bool {
    const valid_value: vk.VkAddressCopyFlagsKHR = .{
        .VK_ADDRESS_COPY_DEVICE_LOCAL_BIT_KHR = true,
        .VK_ADDRESS_COPY_SPARSE_BIT_KHR = true,
        .VK_ADDRESS_COPY_PROTECTED_BIT_KHR = true,
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkTensorCreateFlagsARM(extensions: *const Extensions, item: *const vk.VkTensorCreateFlagsARM) bool {
    const valid_value: vk.VkTensorCreateFlagsARM = .{
        .VK_TENSOR_CREATE_MUTABLE_FORMAT_BIT_ARM = true,
        .VK_TENSOR_CREATE_PROTECTED_BIT_ARM = true,
        .VK_TENSOR_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_ARM = extensions.device.VK_ARM_tensors,
    };
    const valid_bits: u64 = @bitCast(valid_value);
    const current_bits: u64 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkTensorUsageFlagsARM(extensions: *const Extensions, item: *const vk.VkTensorUsageFlagsARM) bool {
    const valid_value: vk.VkTensorUsageFlagsARM = .{
        .VK_TENSOR_USAGE_SHADER_BIT_ARM = true,
        .VK_TENSOR_USAGE_TRANSFER_SRC_BIT_ARM = true,
        .VK_TENSOR_USAGE_TRANSFER_DST_BIT_ARM = true,
        .VK_TENSOR_USAGE_IMAGE_ALIASING_BIT_ARM = true,
        .VK_TENSOR_USAGE_DATA_GRAPH_BIT_ARM = extensions.device.VK_ARM_data_graph,
    };
    const valid_bits: u64 = @bitCast(valid_value);
    const current_bits: u64 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkTensorViewCreateFlagsARM(extensions: *const Extensions, item: *const vk.VkTensorViewCreateFlagsARM) bool {
    const valid_value: vk.VkTensorViewCreateFlagsARM = .{
        .VK_TENSOR_VIEW_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_ARM = extensions.device.VK_ARM_tensors,
    };
    const valid_bits: u64 = @bitCast(valid_value);
    const current_bits: u64 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkDataGraphPipelineSessionCreateFlagsARM(extensions: *const Extensions, item: *const vk.VkDataGraphPipelineSessionCreateFlagsARM) bool {
    const valid_value: vk.VkDataGraphPipelineSessionCreateFlagsARM = .{
        .VK_DATA_GRAPH_PIPELINE_SESSION_CREATE_PROTECTED_BIT_ARM = true,
    };
    _ = extensions;
    const valid_bits: u64 = @bitCast(valid_value);
    const current_bits: u64 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkDataGraphPipelineDispatchFlagsARM(extensions: *const Extensions, item: *const vk.VkDataGraphPipelineDispatchFlagsARM) bool {
    const valid_value: vk.VkDataGraphPipelineDispatchFlagsARM = .{
    };
    _ = extensions;
    const valid_bits: u64 = @bitCast(valid_value);
    const current_bits: u64 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkVideoEncodeRgbModelConversionFlagsVALVE(extensions: *const Extensions, item: *const vk.VkVideoEncodeRgbModelConversionFlagsVALVE) bool {
    const valid_value: vk.VkVideoEncodeRgbModelConversionFlagsVALVE = .{
        .VK_VIDEO_ENCODE_RGB_MODEL_CONVERSION_RGB_IDENTITY_BIT_VALVE = true,
        .VK_VIDEO_ENCODE_RGB_MODEL_CONVERSION_YCBCR_IDENTITY_BIT_VALVE = true,
        .VK_VIDEO_ENCODE_RGB_MODEL_CONVERSION_YCBCR_709_BIT_VALVE = true,
        .VK_VIDEO_ENCODE_RGB_MODEL_CONVERSION_YCBCR_601_BIT_VALVE = true,
        .VK_VIDEO_ENCODE_RGB_MODEL_CONVERSION_YCBCR_2020_BIT_VALVE = true,
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkVideoEncodeRgbRangeCompressionFlagsVALVE(extensions: *const Extensions, item: *const vk.VkVideoEncodeRgbRangeCompressionFlagsVALVE) bool {
    const valid_value: vk.VkVideoEncodeRgbRangeCompressionFlagsVALVE = .{
        .VK_VIDEO_ENCODE_RGB_RANGE_COMPRESSION_FULL_RANGE_BIT_VALVE = true,
        .VK_VIDEO_ENCODE_RGB_RANGE_COMPRESSION_NARROW_RANGE_BIT_VALVE = true,
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkVideoEncodeRgbChromaOffsetFlagsVALVE(extensions: *const Extensions, item: *const vk.VkVideoEncodeRgbChromaOffsetFlagsVALVE) bool {
    const valid_value: vk.VkVideoEncodeRgbChromaOffsetFlagsVALVE = .{
        .VK_VIDEO_ENCODE_RGB_CHROMA_OFFSET_COSITED_EVEN_BIT_VALVE = true,
        .VK_VIDEO_ENCODE_RGB_CHROMA_OFFSET_MIDPOINT_BIT_VALVE = true,
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkCompositeAlphaFlagsKHR(extensions: *const Extensions, item: *const vk.VkCompositeAlphaFlagsKHR) bool {
    const valid_value: vk.VkCompositeAlphaFlagsKHR = .{
        .VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR = true,
        .VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR = true,
        .VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR = true,
        .VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR = true,
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkDisplayPlaneAlphaFlagsKHR(extensions: *const Extensions, item: *const vk.VkDisplayPlaneAlphaFlagsKHR) bool {
    const valid_value: vk.VkDisplayPlaneAlphaFlagsKHR = .{
        .VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR = true,
        .VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR = true,
        .VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR = true,
        .VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR = true,
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkSurfaceTransformFlagsKHR(extensions: *const Extensions, item: *const vk.VkSurfaceTransformFlagsKHR) bool {
    const valid_value: vk.VkSurfaceTransformFlagsKHR = .{
        .VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR = true,
        .VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR = true,
        .VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR = true,
        .VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR = true,
        .VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR = true,
        .VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR = true,
        .VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR = true,
        .VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR = true,
        .VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR = true,
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkSwapchainCreateFlagsKHR(extensions: *const Extensions, item: *const vk.VkSwapchainCreateFlagsKHR) bool {
    const valid_value: vk.VkSwapchainCreateFlagsKHR = .{
        .VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR = extensions.device.VK_KHR_device_group,
        .VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR = extensions.device.VK_KHR_swapchain,
        .VK_SWAPCHAIN_CREATE_MUTABLE_FORMAT_BIT_KHR = extensions.device.VK_KHR_swapchain_mutable_format,
        .VK_SWAPCHAIN_CREATE_DEFERRED_MEMORY_ALLOCATION_BIT_KHR = extensions.device.VK_KHR_swapchain_maintenance1,
        .VK_SWAPCHAIN_CREATE_PRESENT_ID_2_BIT_KHR = extensions.device.VK_KHR_present_id2,
        .VK_SWAPCHAIN_CREATE_PRESENT_WAIT_2_BIT_KHR = extensions.device.VK_KHR_present_wait2,
        .VK_SWAPCHAIN_CREATE_PRESENT_TIMING_BIT_EXT = extensions.device.VK_EXT_present_timing,
    };
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkDisplayModeCreateFlagsKHR(extensions: *const Extensions, item: *const vk.VkDisplayModeCreateFlagsKHR) bool {
    const valid_value: vk.VkDisplayModeCreateFlagsKHR = .{
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkDisplaySurfaceCreateFlagsKHR(extensions: *const Extensions, item: *const vk.VkDisplaySurfaceCreateFlagsKHR) bool {
    const valid_value: vk.VkDisplaySurfaceCreateFlagsKHR = .{
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkAndroidSurfaceCreateFlagsKHR(extensions: *const Extensions, item: *const vk.VkAndroidSurfaceCreateFlagsKHR) bool {
    const valid_value: vk.VkAndroidSurfaceCreateFlagsKHR = .{
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkViSurfaceCreateFlagsNN(extensions: *const Extensions, item: *const vk.VkViSurfaceCreateFlagsNN) bool {
    const valid_value: vk.VkViSurfaceCreateFlagsNN = .{
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkWaylandSurfaceCreateFlagsKHR(extensions: *const Extensions, item: *const vk.VkWaylandSurfaceCreateFlagsKHR) bool {
    const valid_value: vk.VkWaylandSurfaceCreateFlagsKHR = .{
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkWin32SurfaceCreateFlagsKHR(extensions: *const Extensions, item: *const vk.VkWin32SurfaceCreateFlagsKHR) bool {
    const valid_value: vk.VkWin32SurfaceCreateFlagsKHR = .{
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkXlibSurfaceCreateFlagsKHR(extensions: *const Extensions, item: *const vk.VkXlibSurfaceCreateFlagsKHR) bool {
    const valid_value: vk.VkXlibSurfaceCreateFlagsKHR = .{
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkXcbSurfaceCreateFlagsKHR(extensions: *const Extensions, item: *const vk.VkXcbSurfaceCreateFlagsKHR) bool {
    const valid_value: vk.VkXcbSurfaceCreateFlagsKHR = .{
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkDirectFBSurfaceCreateFlagsEXT(extensions: *const Extensions, item: *const vk.VkDirectFBSurfaceCreateFlagsEXT) bool {
    const valid_value: vk.VkDirectFBSurfaceCreateFlagsEXT = .{
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkIOSSurfaceCreateFlagsMVK(extensions: *const Extensions, item: *const vk.VkIOSSurfaceCreateFlagsMVK) bool {
    const valid_value: vk.VkIOSSurfaceCreateFlagsMVK = .{
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkMacOSSurfaceCreateFlagsMVK(extensions: *const Extensions, item: *const vk.VkMacOSSurfaceCreateFlagsMVK) bool {
    const valid_value: vk.VkMacOSSurfaceCreateFlagsMVK = .{
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkMetalSurfaceCreateFlagsEXT(extensions: *const Extensions, item: *const vk.VkMetalSurfaceCreateFlagsEXT) bool {
    const valid_value: vk.VkMetalSurfaceCreateFlagsEXT = .{
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkImagePipeSurfaceCreateFlagsFUCHSIA(extensions: *const Extensions, item: *const vk.VkImagePipeSurfaceCreateFlagsFUCHSIA) bool {
    const valid_value: vk.VkImagePipeSurfaceCreateFlagsFUCHSIA = .{
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkStreamDescriptorSurfaceCreateFlagsGGP(extensions: *const Extensions, item: *const vk.VkStreamDescriptorSurfaceCreateFlagsGGP) bool {
    const valid_value: vk.VkStreamDescriptorSurfaceCreateFlagsGGP = .{
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkHeadlessSurfaceCreateFlagsEXT(extensions: *const Extensions, item: *const vk.VkHeadlessSurfaceCreateFlagsEXT) bool {
    const valid_value: vk.VkHeadlessSurfaceCreateFlagsEXT = .{
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkScreenSurfaceCreateFlagsQNX(extensions: *const Extensions, item: *const vk.VkScreenSurfaceCreateFlagsQNX) bool {
    const valid_value: vk.VkScreenSurfaceCreateFlagsQNX = .{
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkPeerMemoryFeatureFlags(extensions: *const Extensions, item: *const vk.VkPeerMemoryFeatureFlags) bool {
    const valid_value: vk.VkPeerMemoryFeatureFlags = .{
        .VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT = true,
        .VK_PEER_MEMORY_FEATURE_COPY_DST_BIT = true,
        .VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT = true,
        .VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT = true,
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkMemoryAllocateFlags(extensions: *const Extensions, item: *const vk.VkMemoryAllocateFlags) bool {
    const valid_value: vk.VkMemoryAllocateFlags = .{
        .VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT = true,
        .VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT = true,
        .VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT = true,
        .VK_MEMORY_ALLOCATE_ZERO_INITIALIZE_BIT_EXT = extensions.device.VK_EXT_zero_initialize_device_memory,
    };
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkDeviceGroupPresentModeFlagsKHR(extensions: *const Extensions, item: *const vk.VkDeviceGroupPresentModeFlagsKHR) bool {
    const valid_value: vk.VkDeviceGroupPresentModeFlagsKHR = .{
        .VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR = true,
        .VK_DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHR = true,
        .VK_DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHR = true,
        .VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHR = true,
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkDebugReportFlagsEXT(extensions: *const Extensions, item: *const vk.VkDebugReportFlagsEXT) bool {
    const valid_value: vk.VkDebugReportFlagsEXT = .{
        .VK_DEBUG_REPORT_INFORMATION_BIT_EXT = true,
        .VK_DEBUG_REPORT_WARNING_BIT_EXT = true,
        .VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT = true,
        .VK_DEBUG_REPORT_ERROR_BIT_EXT = true,
        .VK_DEBUG_REPORT_DEBUG_BIT_EXT = true,
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkCommandPoolTrimFlags(extensions: *const Extensions, item: *const vk.VkCommandPoolTrimFlags) bool {
    const valid_value: vk.VkCommandPoolTrimFlags = .{
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkExternalMemoryHandleTypeFlagsNV(extensions: *const Extensions, item: *const vk.VkExternalMemoryHandleTypeFlagsNV) bool {
    const valid_value: vk.VkExternalMemoryHandleTypeFlagsNV = .{
        .VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV = true,
        .VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_NV = true,
        .VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_BIT_NV = true,
        .VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_KMT_BIT_NV = true,
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkClusterAccelerationStructureIndexFormatFlagsNV(extensions: *const Extensions, item: *const vk.VkClusterAccelerationStructureIndexFormatFlagsNV) bool {
    const valid_value: vk.VkClusterAccelerationStructureIndexFormatFlagsNV = .{
        .VK_CLUSTER_ACCELERATION_STRUCTURE_INDEX_FORMAT_8BIT_NV = true,
        .VK_CLUSTER_ACCELERATION_STRUCTURE_INDEX_FORMAT_16BIT_NV = true,
        .VK_CLUSTER_ACCELERATION_STRUCTURE_INDEX_FORMAT_32BIT_NV = true,
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkExternalMemoryFeatureFlagsNV(extensions: *const Extensions, item: *const vk.VkExternalMemoryFeatureFlagsNV) bool {
    const valid_value: vk.VkExternalMemoryFeatureFlagsNV = .{
        .VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV = true,
        .VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_NV = true,
        .VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_NV = true,
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkExternalMemoryHandleTypeFlags(extensions: *const Extensions, item: *const vk.VkExternalMemoryHandleTypeFlags) bool {
    const valid_value: vk.VkExternalMemoryHandleTypeFlags = .{
        .VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT = true,
        .VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT = true,
        .VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT = true,
        .VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT = true,
        .VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT = true,
        .VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT = true,
        .VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT = true,
        .VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT = extensions.device.VK_EXT_external_memory_host,
        .VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT = extensions.device.VK_EXT_external_memory_host,
        .VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT = extensions.device.VK_EXT_external_memory_dma_buf,
        .VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID = extensions.device.VK_ANDROID_external_memory_android_hardware_buffer,
        .VK_EXTERNAL_MEMORY_HANDLE_TYPE_ZIRCON_VMO_BIT_FUCHSIA = extensions.device.VK_FUCHSIA_external_memory,
        .VK_EXTERNAL_MEMORY_HANDLE_TYPE_RDMA_ADDRESS_BIT_NV = extensions.device.VK_NV_external_memory_rdma,
        .VK_EXTERNAL_MEMORY_HANDLE_TYPE_SCI_BUF_BIT_NV = extensions.device.VK_NV_external_memory_sci_buf,
        .VK_EXTERNAL_MEMORY_HANDLE_TYPE_SCREEN_BUFFER_BIT_QNX = extensions.device.VK_QNX_external_memory_screen_buffer,
        .VK_EXTERNAL_MEMORY_HANDLE_TYPE_OH_NATIVE_BUFFER_BIT_OHOS = extensions.device.VK_OHOS_external_memory,
        .VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLBUFFER_BIT_EXT = extensions.device.VK_EXT_external_memory_metal,
        .VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLTEXTURE_BIT_EXT = extensions.device.VK_EXT_external_memory_metal,
        .VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLHEAP_BIT_EXT = extensions.device.VK_EXT_external_memory_metal,
    };
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkExternalMemoryFeatureFlags(extensions: *const Extensions, item: *const vk.VkExternalMemoryFeatureFlags) bool {
    const valid_value: vk.VkExternalMemoryFeatureFlags = .{
        .VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT = true,
        .VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT = true,
        .VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT = true,
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkExternalSemaphoreHandleTypeFlags(extensions: *const Extensions, item: *const vk.VkExternalSemaphoreHandleTypeFlags) bool {
    const valid_value: vk.VkExternalSemaphoreHandleTypeFlags = .{
        .VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT = true,
        .VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT = true,
        .VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT = true,
        .VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT = true,
        .VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT = true,
        .VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SCI_SYNC_OBJ_BIT_NV = extensions.device.VK_NV_external_sci_sync,
        .VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_ZIRCON_EVENT_BIT_FUCHSIA = extensions.device.VK_FUCHSIA_external_semaphore,
    };
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkExternalSemaphoreFeatureFlags(extensions: *const Extensions, item: *const vk.VkExternalSemaphoreFeatureFlags) bool {
    const valid_value: vk.VkExternalSemaphoreFeatureFlags = .{
        .VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT = true,
        .VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT = true,
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkSemaphoreImportFlags(extensions: *const Extensions, item: *const vk.VkSemaphoreImportFlags) bool {
    const valid_value: vk.VkSemaphoreImportFlags = .{
        .VK_SEMAPHORE_IMPORT_TEMPORARY_BIT = true,
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkExternalFenceHandleTypeFlags(extensions: *const Extensions, item: *const vk.VkExternalFenceHandleTypeFlags) bool {
    const valid_value: vk.VkExternalFenceHandleTypeFlags = .{
        .VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT = true,
        .VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT = true,
        .VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT = true,
        .VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT = true,
        .VK_EXTERNAL_FENCE_HANDLE_TYPE_SCI_SYNC_OBJ_BIT_NV = extensions.device.VK_NV_external_sci_sync2,
        .VK_EXTERNAL_FENCE_HANDLE_TYPE_SCI_SYNC_FENCE_BIT_NV = extensions.device.VK_NV_external_sci_sync2,
    };
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkExternalFenceFeatureFlags(extensions: *const Extensions, item: *const vk.VkExternalFenceFeatureFlags) bool {
    const valid_value: vk.VkExternalFenceFeatureFlags = .{
        .VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT = true,
        .VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT = true,
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkFenceImportFlags(extensions: *const Extensions, item: *const vk.VkFenceImportFlags) bool {
    const valid_value: vk.VkFenceImportFlags = .{
        .VK_FENCE_IMPORT_TEMPORARY_BIT = true,
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkSurfaceCounterFlagsEXT(extensions: *const Extensions, item: *const vk.VkSurfaceCounterFlagsEXT) bool {
    const valid_value: vk.VkSurfaceCounterFlagsEXT = .{
        .VK_SURFACE_COUNTER_VBLANK_BIT_EXT = true,
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkPipelineViewportSwizzleStateCreateFlagsNV(extensions: *const Extensions, item: *const vk.VkPipelineViewportSwizzleStateCreateFlagsNV) bool {
    const valid_value: vk.VkPipelineViewportSwizzleStateCreateFlagsNV = .{
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkPipelineDiscardRectangleStateCreateFlagsEXT(extensions: *const Extensions, item: *const vk.VkPipelineDiscardRectangleStateCreateFlagsEXT) bool {
    const valid_value: vk.VkPipelineDiscardRectangleStateCreateFlagsEXT = .{
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkPipelineCoverageToColorStateCreateFlagsNV(extensions: *const Extensions, item: *const vk.VkPipelineCoverageToColorStateCreateFlagsNV) bool {
    const valid_value: vk.VkPipelineCoverageToColorStateCreateFlagsNV = .{
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkPipelineCoverageModulationStateCreateFlagsNV(extensions: *const Extensions, item: *const vk.VkPipelineCoverageModulationStateCreateFlagsNV) bool {
    const valid_value: vk.VkPipelineCoverageModulationStateCreateFlagsNV = .{
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkPipelineCoverageReductionStateCreateFlagsNV(extensions: *const Extensions, item: *const vk.VkPipelineCoverageReductionStateCreateFlagsNV) bool {
    const valid_value: vk.VkPipelineCoverageReductionStateCreateFlagsNV = .{
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkValidationCacheCreateFlagsEXT(extensions: *const Extensions, item: *const vk.VkValidationCacheCreateFlagsEXT) bool {
    const valid_value: vk.VkValidationCacheCreateFlagsEXT = .{
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkDebugUtilsMessageSeverityFlagsEXT(extensions: *const Extensions, item: *const vk.VkDebugUtilsMessageSeverityFlagsEXT) bool {
    const valid_value: vk.VkDebugUtilsMessageSeverityFlagsEXT = .{
        .VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT = true,
        .VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT = true,
        .VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT = true,
        .VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT = true,
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkDebugUtilsMessageTypeFlagsEXT(extensions: *const Extensions, item: *const vk.VkDebugUtilsMessageTypeFlagsEXT) bool {
    const valid_value: vk.VkDebugUtilsMessageTypeFlagsEXT = .{
        .VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT = true,
        .VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT = true,
        .VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT = true,
        .VK_DEBUG_UTILS_MESSAGE_TYPE_DEVICE_ADDRESS_BINDING_BIT_EXT = extensions.device.VK_EXT_device_address_binding_report,
    };
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkDebugUtilsMessengerCreateFlagsEXT(extensions: *const Extensions, item: *const vk.VkDebugUtilsMessengerCreateFlagsEXT) bool {
    const valid_value: vk.VkDebugUtilsMessengerCreateFlagsEXT = .{
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkDebugUtilsMessengerCallbackDataFlagsEXT(extensions: *const Extensions, item: *const vk.VkDebugUtilsMessengerCallbackDataFlagsEXT) bool {
    const valid_value: vk.VkDebugUtilsMessengerCallbackDataFlagsEXT = .{
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkDeviceMemoryReportFlagsEXT(extensions: *const Extensions, item: *const vk.VkDeviceMemoryReportFlagsEXT) bool {
    const valid_value: vk.VkDeviceMemoryReportFlagsEXT = .{
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkPipelineRasterizationConservativeStateCreateFlagsEXT(extensions: *const Extensions, item: *const vk.VkPipelineRasterizationConservativeStateCreateFlagsEXT) bool {
    const valid_value: vk.VkPipelineRasterizationConservativeStateCreateFlagsEXT = .{
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkDescriptorBindingFlags(extensions: *const Extensions, item: *const vk.VkDescriptorBindingFlags) bool {
    const valid_value: vk.VkDescriptorBindingFlags = .{
        .VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT = true,
        .VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT = true,
        .VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT = true,
        .VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT = true,
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkConditionalRenderingFlagsEXT(extensions: *const Extensions, item: *const vk.VkConditionalRenderingFlagsEXT) bool {
    const valid_value: vk.VkConditionalRenderingFlagsEXT = .{
        .VK_CONDITIONAL_RENDERING_INVERTED_BIT_EXT = true,
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkResolveModeFlags(extensions: *const Extensions, item: *const vk.VkResolveModeFlags) bool {
    const valid_value: vk.VkResolveModeFlags = .{
        .VK_RESOLVE_MODE_SAMPLE_ZERO_BIT = true,
        .VK_RESOLVE_MODE_AVERAGE_BIT = true,
        .VK_RESOLVE_MODE_MIN_BIT = true,
        .VK_RESOLVE_MODE_MAX_BIT = true,
        .VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_BIT_ANDROID = extensions.device.VK_ANDROID_external_format_resolve,
        .VK_RESOLVE_MODE_CUSTOM_BIT_EXT = extensions.device.VK_EXT_custom_resolve,
    };
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkPipelineRasterizationStateStreamCreateFlagsEXT(extensions: *const Extensions, item: *const vk.VkPipelineRasterizationStateStreamCreateFlagsEXT) bool {
    const valid_value: vk.VkPipelineRasterizationStateStreamCreateFlagsEXT = .{
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkPipelineRasterizationDepthClipStateCreateFlagsEXT(extensions: *const Extensions, item: *const vk.VkPipelineRasterizationDepthClipStateCreateFlagsEXT) bool {
    const valid_value: vk.VkPipelineRasterizationDepthClipStateCreateFlagsEXT = .{
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkSwapchainImageUsageFlagsANDROID(extensions: *const Extensions, item: *const vk.VkSwapchainImageUsageFlagsANDROID) bool {
    const valid_value: vk.VkSwapchainImageUsageFlagsANDROID = .{
        .VK_SWAPCHAIN_IMAGE_USAGE_SHARED_BIT_ANDROID = true,
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkToolPurposeFlags(extensions: *const Extensions, item: *const vk.VkToolPurposeFlags) bool {
    const valid_value: vk.VkToolPurposeFlags = .{
        .VK_TOOL_PURPOSE_VALIDATION_BIT = true,
        .VK_TOOL_PURPOSE_PROFILING_BIT = true,
        .VK_TOOL_PURPOSE_TRACING_BIT = true,
        .VK_TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT = true,
        .VK_TOOL_PURPOSE_MODIFYING_FEATURES_BIT = true,
        .VK_TOOL_PURPOSE_DEBUG_REPORTING_BIT_EXT = extensions.device.VK_EXT_tooling_info,
        .VK_TOOL_PURPOSE_DEBUG_MARKERS_BIT_EXT = extensions.device.VK_EXT_tooling_info,
    };
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkSubmitFlags(extensions: *const Extensions, item: *const vk.VkSubmitFlags) bool {
    const valid_value: vk.VkSubmitFlags = .{
        .VK_SUBMIT_PROTECTED_BIT = true,
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkImageFormatConstraintsFlagsFUCHSIA(extensions: *const Extensions, item: *const vk.VkImageFormatConstraintsFlagsFUCHSIA) bool {
    const valid_value: vk.VkImageFormatConstraintsFlagsFUCHSIA = .{
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkHostImageCopyFlags(extensions: *const Extensions, item: *const vk.VkHostImageCopyFlags) bool {
    const valid_value: vk.VkHostImageCopyFlags = .{
        .VK_HOST_IMAGE_COPY_MEMCPY_BIT = true,
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkPartitionedAccelerationStructureInstanceFlagsNV(extensions: *const Extensions, item: *const vk.VkPartitionedAccelerationStructureInstanceFlagsNV) bool {
    const valid_value: vk.VkPartitionedAccelerationStructureInstanceFlagsNV = .{
        .VK_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCE_FLAG_TRIANGLE_FACING_CULL_DISABLE_BIT_NV = true,
        .VK_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCE_FLAG_TRIANGLE_FLIP_FACING_BIT_NV = true,
        .VK_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCE_FLAG_FORCE_OPAQUE_BIT_NV = true,
        .VK_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCE_FLAG_FORCE_NO_OPAQUE_BIT_NV = true,
        .VK_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCE_FLAG_ENABLE_EXPLICIT_BOUNDING_BOX_NV = true,
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkImageConstraintsInfoFlagsFUCHSIA(extensions: *const Extensions, item: *const vk.VkImageConstraintsInfoFlagsFUCHSIA) bool {
    const valid_value: vk.VkImageConstraintsInfoFlagsFUCHSIA = .{
        .VK_IMAGE_CONSTRAINTS_INFO_CPU_READ_RARELY_FUCHSIA = true,
        .VK_IMAGE_CONSTRAINTS_INFO_CPU_READ_OFTEN_FUCHSIA = true,
        .VK_IMAGE_CONSTRAINTS_INFO_CPU_WRITE_RARELY_FUCHSIA = true,
        .VK_IMAGE_CONSTRAINTS_INFO_CPU_WRITE_OFTEN_FUCHSIA = true,
        .VK_IMAGE_CONSTRAINTS_INFO_PROTECTED_OPTIONAL_FUCHSIA = true,
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkGraphicsPipelineLibraryFlagsEXT(extensions: *const Extensions, item: *const vk.VkGraphicsPipelineLibraryFlagsEXT) bool {
    const valid_value: vk.VkGraphicsPipelineLibraryFlagsEXT = .{
        .VK_GRAPHICS_PIPELINE_LIBRARY_VERTEX_INPUT_INTERFACE_BIT_EXT = true,
        .VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT = true,
        .VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT = true,
        .VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_OUTPUT_INTERFACE_BIT_EXT = true,
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkImageCompressionFlagsEXT(extensions: *const Extensions, item: *const vk.VkImageCompressionFlagsEXT) bool {
    const valid_value: vk.VkImageCompressionFlagsEXT = .{
        .VK_IMAGE_COMPRESSION_FIXED_RATE_DEFAULT_EXT = true,
        .VK_IMAGE_COMPRESSION_FIXED_RATE_EXPLICIT_EXT = true,
        .VK_IMAGE_COMPRESSION_DISABLED_EXT = true,
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkImageCompressionFixedRateFlagsEXT(extensions: *const Extensions, item: *const vk.VkImageCompressionFixedRateFlagsEXT) bool {
    const valid_value: vk.VkImageCompressionFixedRateFlagsEXT = .{
        .VK_IMAGE_COMPRESSION_FIXED_RATE_1BPC_BIT_EXT = true,
        .VK_IMAGE_COMPRESSION_FIXED_RATE_2BPC_BIT_EXT = true,
        .VK_IMAGE_COMPRESSION_FIXED_RATE_3BPC_BIT_EXT = true,
        .VK_IMAGE_COMPRESSION_FIXED_RATE_4BPC_BIT_EXT = true,
        .VK_IMAGE_COMPRESSION_FIXED_RATE_5BPC_BIT_EXT = true,
        .VK_IMAGE_COMPRESSION_FIXED_RATE_6BPC_BIT_EXT = true,
        .VK_IMAGE_COMPRESSION_FIXED_RATE_7BPC_BIT_EXT = true,
        .VK_IMAGE_COMPRESSION_FIXED_RATE_8BPC_BIT_EXT = true,
        .VK_IMAGE_COMPRESSION_FIXED_RATE_9BPC_BIT_EXT = true,
        .VK_IMAGE_COMPRESSION_FIXED_RATE_10BPC_BIT_EXT = true,
        .VK_IMAGE_COMPRESSION_FIXED_RATE_11BPC_BIT_EXT = true,
        .VK_IMAGE_COMPRESSION_FIXED_RATE_12BPC_BIT_EXT = true,
        .VK_IMAGE_COMPRESSION_FIXED_RATE_13BPC_BIT_EXT = true,
        .VK_IMAGE_COMPRESSION_FIXED_RATE_14BPC_BIT_EXT = true,
        .VK_IMAGE_COMPRESSION_FIXED_RATE_15BPC_BIT_EXT = true,
        .VK_IMAGE_COMPRESSION_FIXED_RATE_16BPC_BIT_EXT = true,
        .VK_IMAGE_COMPRESSION_FIXED_RATE_17BPC_BIT_EXT = true,
        .VK_IMAGE_COMPRESSION_FIXED_RATE_18BPC_BIT_EXT = true,
        .VK_IMAGE_COMPRESSION_FIXED_RATE_19BPC_BIT_EXT = true,
        .VK_IMAGE_COMPRESSION_FIXED_RATE_20BPC_BIT_EXT = true,
        .VK_IMAGE_COMPRESSION_FIXED_RATE_21BPC_BIT_EXT = true,
        .VK_IMAGE_COMPRESSION_FIXED_RATE_22BPC_BIT_EXT = true,
        .VK_IMAGE_COMPRESSION_FIXED_RATE_23BPC_BIT_EXT = true,
        .VK_IMAGE_COMPRESSION_FIXED_RATE_24BPC_BIT_EXT = true,
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkExportMetalObjectTypeFlagsEXT(extensions: *const Extensions, item: *const vk.VkExportMetalObjectTypeFlagsEXT) bool {
    const valid_value: vk.VkExportMetalObjectTypeFlagsEXT = .{
        .VK_EXPORT_METAL_OBJECT_TYPE_METAL_DEVICE_BIT_EXT = true,
        .VK_EXPORT_METAL_OBJECT_TYPE_METAL_COMMAND_QUEUE_BIT_EXT = true,
        .VK_EXPORT_METAL_OBJECT_TYPE_METAL_BUFFER_BIT_EXT = true,
        .VK_EXPORT_METAL_OBJECT_TYPE_METAL_TEXTURE_BIT_EXT = true,
        .VK_EXPORT_METAL_OBJECT_TYPE_METAL_IOSURFACE_BIT_EXT = true,
        .VK_EXPORT_METAL_OBJECT_TYPE_METAL_SHARED_EVENT_BIT_EXT = true,
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkRenderingAttachmentFlagsKHR(extensions: *const Extensions, item: *const vk.VkRenderingAttachmentFlagsKHR) bool {
    const valid_value: vk.VkRenderingAttachmentFlagsKHR = .{
        .VK_RENDERING_ATTACHMENT_INPUT_ATTACHMENT_FEEDBACK_BIT_KHR = extensions.device.VK_KHR_maintenance10,
        .VK_RENDERING_ATTACHMENT_RESOLVE_SKIP_TRANSFER_FUNCTION_BIT_KHR = extensions.device.VK_KHR_maintenance10,
        .VK_RENDERING_ATTACHMENT_RESOLVE_ENABLE_TRANSFER_FUNCTION_BIT_KHR = extensions.device.VK_KHR_maintenance10,
    };
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkResolveImageFlagsKHR(extensions: *const Extensions, item: *const vk.VkResolveImageFlagsKHR) bool {
    const valid_value: vk.VkResolveImageFlagsKHR = .{
        .VK_RESOLVE_IMAGE_SKIP_TRANSFER_FUNCTION_BIT_KHR = extensions.device.VK_KHR_maintenance10,
        .VK_RESOLVE_IMAGE_ENABLE_TRANSFER_FUNCTION_BIT_KHR = extensions.device.VK_KHR_maintenance10,
    };
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkDeviceAddressBindingFlagsEXT(extensions: *const Extensions, item: *const vk.VkDeviceAddressBindingFlagsEXT) bool {
    const valid_value: vk.VkDeviceAddressBindingFlagsEXT = .{
        .VK_DEVICE_ADDRESS_BINDING_INTERNAL_OBJECT_BIT_EXT = true,
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkOpticalFlowGridSizeFlagsNV(extensions: *const Extensions, item: *const vk.VkOpticalFlowGridSizeFlagsNV) bool {
    const valid_value: vk.VkOpticalFlowGridSizeFlagsNV = .{
        .VK_OPTICAL_FLOW_GRID_SIZE_1X1_BIT_NV = true,
        .VK_OPTICAL_FLOW_GRID_SIZE_2X2_BIT_NV = true,
        .VK_OPTICAL_FLOW_GRID_SIZE_4X4_BIT_NV = true,
        .VK_OPTICAL_FLOW_GRID_SIZE_8X8_BIT_NV = true,
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkOpticalFlowUsageFlagsNV(extensions: *const Extensions, item: *const vk.VkOpticalFlowUsageFlagsNV) bool {
    const valid_value: vk.VkOpticalFlowUsageFlagsNV = .{
        .VK_OPTICAL_FLOW_USAGE_INPUT_BIT_NV = true,
        .VK_OPTICAL_FLOW_USAGE_OUTPUT_BIT_NV = true,
        .VK_OPTICAL_FLOW_USAGE_HINT_BIT_NV = true,
        .VK_OPTICAL_FLOW_USAGE_COST_BIT_NV = true,
        .VK_OPTICAL_FLOW_USAGE_GLOBAL_FLOW_BIT_NV = true,
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkOpticalFlowSessionCreateFlagsNV(extensions: *const Extensions, item: *const vk.VkOpticalFlowSessionCreateFlagsNV) bool {
    const valid_value: vk.VkOpticalFlowSessionCreateFlagsNV = .{
        .VK_OPTICAL_FLOW_SESSION_CREATE_ENABLE_HINT_BIT_NV = true,
        .VK_OPTICAL_FLOW_SESSION_CREATE_ENABLE_COST_BIT_NV = true,
        .VK_OPTICAL_FLOW_SESSION_CREATE_ENABLE_GLOBAL_FLOW_BIT_NV = true,
        .VK_OPTICAL_FLOW_SESSION_CREATE_ALLOW_REGIONS_BIT_NV = true,
        .VK_OPTICAL_FLOW_SESSION_CREATE_BOTH_DIRECTIONS_BIT_NV = true,
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkOpticalFlowExecuteFlagsNV(extensions: *const Extensions, item: *const vk.VkOpticalFlowExecuteFlagsNV) bool {
    const valid_value: vk.VkOpticalFlowExecuteFlagsNV = .{
        .VK_OPTICAL_FLOW_EXECUTE_DISABLE_TEMPORAL_HINTS_BIT_NV = true,
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkFrameBoundaryFlagsEXT(extensions: *const Extensions, item: *const vk.VkFrameBoundaryFlagsEXT) bool {
    const valid_value: vk.VkFrameBoundaryFlagsEXT = .{
        .VK_FRAME_BOUNDARY_FRAME_END_BIT_EXT = true,
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkPresentScalingFlagsKHR(extensions: *const Extensions, item: *const vk.VkPresentScalingFlagsKHR) bool {
    const valid_value: vk.VkPresentScalingFlagsKHR = .{
        .VK_PRESENT_SCALING_ONE_TO_ONE_BIT_KHR = true,
        .VK_PRESENT_SCALING_ASPECT_RATIO_STRETCH_BIT_KHR = true,
        .VK_PRESENT_SCALING_STRETCH_BIT_KHR = true,
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkPresentGravityFlagsKHR(extensions: *const Extensions, item: *const vk.VkPresentGravityFlagsKHR) bool {
    const valid_value: vk.VkPresentGravityFlagsKHR = .{
        .VK_PRESENT_GRAVITY_MIN_BIT_KHR = true,
        .VK_PRESENT_GRAVITY_MAX_BIT_KHR = true,
        .VK_PRESENT_GRAVITY_CENTERED_BIT_KHR = true,
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkShaderCreateFlagsEXT(extensions: *const Extensions, item: *const vk.VkShaderCreateFlagsEXT) bool {
    const valid_value: vk.VkShaderCreateFlagsEXT = .{
        .VK_SHADER_CREATE_LINK_STAGE_BIT_EXT = true,
        .VK_SHADER_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT = extensions.device.VK_EXT_shader_object,
        .VK_SHADER_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT = extensions.device.VK_EXT_shader_object,
        .VK_SHADER_CREATE_NO_TASK_SHADER_BIT_EXT = extensions.device.VK_EXT_shader_object,
        .VK_SHADER_CREATE_DISPATCH_BASE_BIT_EXT = extensions.device.VK_EXT_shader_object,
        .VK_SHADER_CREATE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_EXT = extensions.device.VK_EXT_shader_object,
        .VK_SHADER_CREATE_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT = extensions.device.VK_EXT_shader_object,
        .VK_SHADER_CREATE_INDIRECT_BINDABLE_BIT_EXT = extensions.device.VK_EXT_device_generated_commands,
        .VK_SHADER_CREATE_64_BIT_INDEXING_BIT_EXT = extensions.device.VK_EXT_shader_64bit_indexing,
    };
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkTileShadingRenderPassFlagsQCOM(extensions: *const Extensions, item: *const vk.VkTileShadingRenderPassFlagsQCOM) bool {
    const valid_value: vk.VkTileShadingRenderPassFlagsQCOM = .{
        .VK_TILE_SHADING_RENDER_PASS_ENABLE_BIT_QCOM = true,
        .VK_TILE_SHADING_RENDER_PASS_PER_TILE_EXECUTION_BIT_QCOM = true,
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkPhysicalDeviceSchedulingControlsFlagsARM(extensions: *const Extensions, item: *const vk.VkPhysicalDeviceSchedulingControlsFlagsARM) bool {
    const valid_value: vk.VkPhysicalDeviceSchedulingControlsFlagsARM = .{
        .VK_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_SHADER_CORE_COUNT_ARM = true,
    };
    _ = extensions;
    const valid_bits: u64 = @bitCast(valid_value);
    const current_bits: u64 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkSurfaceCreateFlagsOHOS(extensions: *const Extensions, item: *const vk.VkSurfaceCreateFlagsOHOS) bool {
    const valid_value: vk.VkSurfaceCreateFlagsOHOS = .{
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkPresentStageFlagsEXT(extensions: *const Extensions, item: *const vk.VkPresentStageFlagsEXT) bool {
    const valid_value: vk.VkPresentStageFlagsEXT = .{
        .VK_PRESENT_STAGE_QUEUE_OPERATIONS_END_BIT_EXT = true,
        .VK_PRESENT_STAGE_REQUEST_DEQUEUED_BIT_EXT = true,
        .VK_PRESENT_STAGE_IMAGE_FIRST_PIXEL_OUT_BIT_EXT = true,
        .VK_PRESENT_STAGE_IMAGE_FIRST_PIXEL_VISIBLE_BIT_EXT = true,
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkPastPresentationTimingFlagsEXT(extensions: *const Extensions, item: *const vk.VkPastPresentationTimingFlagsEXT) bool {
    const valid_value: vk.VkPastPresentationTimingFlagsEXT = .{
        .VK_PAST_PRESENTATION_TIMING_ALLOW_PARTIAL_RESULTS_BIT_EXT = true,
        .VK_PAST_PRESENTATION_TIMING_ALLOW_OUT_OF_ORDER_RESULTS_BIT_EXT = true,
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkPresentTimingInfoFlagsEXT(extensions: *const Extensions, item: *const vk.VkPresentTimingInfoFlagsEXT) bool {
    const valid_value: vk.VkPresentTimingInfoFlagsEXT = .{
        .VK_PRESENT_TIMING_INFO_PRESENT_AT_RELATIVE_TIME_BIT_EXT = true,
        .VK_PRESENT_TIMING_INFO_PRESENT_AT_NEAREST_REFRESH_CYCLE_BIT_EXT = true,
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkSwapchainImageUsageFlagsOHOS(extensions: *const Extensions, item: *const vk.VkSwapchainImageUsageFlagsOHOS) bool {
    const valid_value: vk.VkSwapchainImageUsageFlagsOHOS = .{
        .VK_SWAPCHAIN_IMAGE_USAGE_SHARED_BIT_OHOS = true,
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkPerformanceCounterDescriptionFlagsARM(extensions: *const Extensions, item: *const vk.VkPerformanceCounterDescriptionFlagsARM) bool {
    const valid_value: vk.VkPerformanceCounterDescriptionFlagsARM = .{
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkVideoCodecOperationFlagsKHR(extensions: *const Extensions, item: *const vk.VkVideoCodecOperationFlagsKHR) bool {
    const valid_value: vk.VkVideoCodecOperationFlagsKHR = .{
        .VK_VIDEO_CODEC_OPERATION_DECODE_H264_BIT_KHR = extensions.device.VK_KHR_video_decode_h264,
        .VK_VIDEO_CODEC_OPERATION_DECODE_H265_BIT_KHR = extensions.device.VK_KHR_video_decode_h265,
        .VK_VIDEO_CODEC_OPERATION_DECODE_AV1_BIT_KHR = extensions.device.VK_KHR_video_decode_av1,
        .VK_VIDEO_CODEC_OPERATION_DECODE_VP9_BIT_KHR = extensions.device.VK_KHR_video_decode_vp9,
        .VK_VIDEO_CODEC_OPERATION_ENCODE_H264_BIT_KHR = extensions.device.VK_KHR_video_encode_h264,
        .VK_VIDEO_CODEC_OPERATION_ENCODE_H265_BIT_KHR = extensions.device.VK_KHR_video_encode_h265,
        .VK_VIDEO_CODEC_OPERATION_ENCODE_AV1_BIT_KHR = extensions.device.VK_KHR_video_encode_av1,
    };
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkVideoCapabilityFlagsKHR(extensions: *const Extensions, item: *const vk.VkVideoCapabilityFlagsKHR) bool {
    const valid_value: vk.VkVideoCapabilityFlagsKHR = .{
        .VK_VIDEO_CAPABILITY_PROTECTED_CONTENT_BIT_KHR = true,
        .VK_VIDEO_CAPABILITY_SEPARATE_REFERENCE_IMAGES_BIT_KHR = true,
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkVideoSessionCreateFlagsKHR(extensions: *const Extensions, item: *const vk.VkVideoSessionCreateFlagsKHR) bool {
    const valid_value: vk.VkVideoSessionCreateFlagsKHR = .{
        .VK_VIDEO_SESSION_CREATE_PROTECTED_CONTENT_BIT_KHR = true,
        .VK_VIDEO_SESSION_CREATE_ALLOW_ENCODE_PARAMETER_OPTIMIZATIONS_BIT_KHR = extensions.device.VK_KHR_video_encode_queue,
        .VK_VIDEO_SESSION_CREATE_INLINE_QUERIES_BIT_KHR = extensions.device.VK_KHR_video_maintenance1,
        .VK_VIDEO_SESSION_CREATE_ALLOW_ENCODE_QUANTIZATION_DELTA_MAP_BIT_KHR = extensions.device.VK_KHR_video_encode_quantization_map,
        .VK_VIDEO_SESSION_CREATE_ALLOW_ENCODE_EMPHASIS_MAP_BIT_KHR = extensions.device.VK_KHR_video_encode_quantization_map,
        .VK_VIDEO_SESSION_CREATE_INLINE_SESSION_PARAMETERS_BIT_KHR = extensions.device.VK_KHR_video_maintenance2,
    };
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkVideoSessionParametersCreateFlagsKHR(extensions: *const Extensions, item: *const vk.VkVideoSessionParametersCreateFlagsKHR) bool {
    const valid_value: vk.VkVideoSessionParametersCreateFlagsKHR = .{
        .VK_VIDEO_SESSION_PARAMETERS_CREATE_QUANTIZATION_MAP_COMPATIBLE_BIT_KHR = extensions.device.VK_KHR_video_encode_quantization_map,
    };
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkVideoBeginCodingFlagsKHR(extensions: *const Extensions, item: *const vk.VkVideoBeginCodingFlagsKHR) bool {
    const valid_value: vk.VkVideoBeginCodingFlagsKHR = .{
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkVideoEndCodingFlagsKHR(extensions: *const Extensions, item: *const vk.VkVideoEndCodingFlagsKHR) bool {
    const valid_value: vk.VkVideoEndCodingFlagsKHR = .{
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkVideoCodingControlFlagsKHR(extensions: *const Extensions, item: *const vk.VkVideoCodingControlFlagsKHR) bool {
    const valid_value: vk.VkVideoCodingControlFlagsKHR = .{
        .VK_VIDEO_CODING_CONTROL_RESET_BIT_KHR = true,
        .VK_VIDEO_CODING_CONTROL_ENCODE_RATE_CONTROL_BIT_KHR = extensions.device.VK_KHR_video_encode_queue,
        .VK_VIDEO_CODING_CONTROL_ENCODE_QUALITY_LEVEL_BIT_KHR = extensions.device.VK_KHR_video_encode_queue,
    };
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkVideoDecodeUsageFlagsKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeUsageFlagsKHR) bool {
    const valid_value: vk.VkVideoDecodeUsageFlagsKHR = .{
        .VK_VIDEO_DECODE_USAGE_TRANSCODING_BIT_KHR = true,
        .VK_VIDEO_DECODE_USAGE_OFFLINE_BIT_KHR = true,
        .VK_VIDEO_DECODE_USAGE_STREAMING_BIT_KHR = true,
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkVideoDecodeCapabilityFlagsKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeCapabilityFlagsKHR) bool {
    const valid_value: vk.VkVideoDecodeCapabilityFlagsKHR = .{
        .VK_VIDEO_DECODE_CAPABILITY_DPB_AND_OUTPUT_COINCIDE_BIT_KHR = true,
        .VK_VIDEO_DECODE_CAPABILITY_DPB_AND_OUTPUT_DISTINCT_BIT_KHR = true,
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkVideoDecodeFlagsKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeFlagsKHR) bool {
    const valid_value: vk.VkVideoDecodeFlagsKHR = .{
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkVideoDecodeH264PictureLayoutFlagsKHR(extensions: *const Extensions, item: *const vk.VkVideoDecodeH264PictureLayoutFlagsKHR) bool {
    const valid_value: vk.VkVideoDecodeH264PictureLayoutFlagsKHR = .{
        .VK_VIDEO_DECODE_H264_PICTURE_LAYOUT_INTERLACED_INTERLEAVED_LINES_BIT_KHR = true,
        .VK_VIDEO_DECODE_H264_PICTURE_LAYOUT_INTERLACED_SEPARATE_PLANES_BIT_KHR = true,
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkVideoEncodeFlagsKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeFlagsKHR) bool {
    const valid_value: vk.VkVideoEncodeFlagsKHR = .{
        .VK_VIDEO_ENCODE_WITH_QUANTIZATION_DELTA_MAP_BIT_KHR = extensions.device.VK_KHR_video_encode_quantization_map,
        .VK_VIDEO_ENCODE_WITH_EMPHASIS_MAP_BIT_KHR = extensions.device.VK_KHR_video_encode_quantization_map,
        .VK_VIDEO_ENCODE_INTRA_REFRESH_BIT_KHR = extensions.device.VK_KHR_video_encode_intra_refresh,
    };
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkVideoEncodeUsageFlagsKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeUsageFlagsKHR) bool {
    const valid_value: vk.VkVideoEncodeUsageFlagsKHR = .{
        .VK_VIDEO_ENCODE_USAGE_TRANSCODING_BIT_KHR = true,
        .VK_VIDEO_ENCODE_USAGE_STREAMING_BIT_KHR = true,
        .VK_VIDEO_ENCODE_USAGE_RECORDING_BIT_KHR = true,
        .VK_VIDEO_ENCODE_USAGE_CONFERENCING_BIT_KHR = true,
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkVideoEncodeContentFlagsKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeContentFlagsKHR) bool {
    const valid_value: vk.VkVideoEncodeContentFlagsKHR = .{
        .VK_VIDEO_ENCODE_CONTENT_CAMERA_BIT_KHR = true,
        .VK_VIDEO_ENCODE_CONTENT_DESKTOP_BIT_KHR = true,
        .VK_VIDEO_ENCODE_CONTENT_RENDERED_BIT_KHR = true,
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkVideoEncodeCapabilityFlagsKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeCapabilityFlagsKHR) bool {
    const valid_value: vk.VkVideoEncodeCapabilityFlagsKHR = .{
        .VK_VIDEO_ENCODE_CAPABILITY_PRECEDING_EXTERNALLY_ENCODED_BYTES_BIT_KHR = true,
        .VK_VIDEO_ENCODE_CAPABILITY_INSUFFICIENT_BITSTREAM_BUFFER_RANGE_DETECTION_BIT_KHR = true,
        .VK_VIDEO_ENCODE_CAPABILITY_QUANTIZATION_DELTA_MAP_BIT_KHR = extensions.device.VK_KHR_video_encode_quantization_map,
        .VK_VIDEO_ENCODE_CAPABILITY_EMPHASIS_MAP_BIT_KHR = extensions.device.VK_KHR_video_encode_quantization_map,
    };
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkVideoEncodeFeedbackFlagsKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeFeedbackFlagsKHR) bool {
    const valid_value: vk.VkVideoEncodeFeedbackFlagsKHR = .{
        .VK_VIDEO_ENCODE_FEEDBACK_BITSTREAM_BUFFER_OFFSET_BIT_KHR = true,
        .VK_VIDEO_ENCODE_FEEDBACK_BITSTREAM_BYTES_WRITTEN_BIT_KHR = true,
        .VK_VIDEO_ENCODE_FEEDBACK_BITSTREAM_HAS_OVERRIDES_BIT_KHR = true,
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkVideoEncodeRateControlFlagsKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeRateControlFlagsKHR) bool {
    const valid_value: vk.VkVideoEncodeRateControlFlagsKHR = .{
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkVideoEncodeRateControlModeFlagsKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeRateControlModeFlagsKHR) bool {
    const valid_value: vk.VkVideoEncodeRateControlModeFlagsKHR = .{
        .VK_VIDEO_ENCODE_RATE_CONTROL_MODE_DISABLED_BIT_KHR = true,
        .VK_VIDEO_ENCODE_RATE_CONTROL_MODE_CBR_BIT_KHR = true,
        .VK_VIDEO_ENCODE_RATE_CONTROL_MODE_VBR_BIT_KHR = true,
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkVideoEncodeIntraRefreshModeFlagsKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeIntraRefreshModeFlagsKHR) bool {
    const valid_value: vk.VkVideoEncodeIntraRefreshModeFlagsKHR = .{
        .VK_VIDEO_ENCODE_INTRA_REFRESH_MODE_PER_PICTURE_PARTITION_BIT_KHR = true,
        .VK_VIDEO_ENCODE_INTRA_REFRESH_MODE_BLOCK_BASED_BIT_KHR = true,
        .VK_VIDEO_ENCODE_INTRA_REFRESH_MODE_BLOCK_ROW_BASED_BIT_KHR = true,
        .VK_VIDEO_ENCODE_INTRA_REFRESH_MODE_BLOCK_COLUMN_BASED_BIT_KHR = true,
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkVideoChromaSubsamplingFlagsKHR(extensions: *const Extensions, item: *const vk.VkVideoChromaSubsamplingFlagsKHR) bool {
    const valid_value: vk.VkVideoChromaSubsamplingFlagsKHR = .{
        .VK_VIDEO_CHROMA_SUBSAMPLING_MONOCHROME_BIT_KHR = true,
        .VK_VIDEO_CHROMA_SUBSAMPLING_420_BIT_KHR = true,
        .VK_VIDEO_CHROMA_SUBSAMPLING_422_BIT_KHR = true,
        .VK_VIDEO_CHROMA_SUBSAMPLING_444_BIT_KHR = true,
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkVideoComponentBitDepthFlagsKHR(extensions: *const Extensions, item: *const vk.VkVideoComponentBitDepthFlagsKHR) bool {
    const valid_value: vk.VkVideoComponentBitDepthFlagsKHR = .{
        .VK_VIDEO_COMPONENT_BIT_DEPTH_8_BIT_KHR = true,
        .VK_VIDEO_COMPONENT_BIT_DEPTH_10_BIT_KHR = true,
        .VK_VIDEO_COMPONENT_BIT_DEPTH_12_BIT_KHR = true,
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkVideoEncodeH264CapabilityFlagsKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH264CapabilityFlagsKHR) bool {
    const valid_value: vk.VkVideoEncodeH264CapabilityFlagsKHR = .{
        .VK_VIDEO_ENCODE_H264_CAPABILITY_HRD_COMPLIANCE_BIT_KHR = true,
        .VK_VIDEO_ENCODE_H264_CAPABILITY_PREDICTION_WEIGHT_TABLE_GENERATED_BIT_KHR = true,
        .VK_VIDEO_ENCODE_H264_CAPABILITY_ROW_UNALIGNED_SLICE_BIT_KHR = true,
        .VK_VIDEO_ENCODE_H264_CAPABILITY_DIFFERENT_SLICE_TYPE_BIT_KHR = true,
        .VK_VIDEO_ENCODE_H264_CAPABILITY_B_FRAME_IN_L0_LIST_BIT_KHR = true,
        .VK_VIDEO_ENCODE_H264_CAPABILITY_B_FRAME_IN_L1_LIST_BIT_KHR = true,
        .VK_VIDEO_ENCODE_H264_CAPABILITY_PER_PICTURE_TYPE_MIN_MAX_QP_BIT_KHR = true,
        .VK_VIDEO_ENCODE_H264_CAPABILITY_PER_SLICE_CONSTANT_QP_BIT_KHR = true,
        .VK_VIDEO_ENCODE_H264_CAPABILITY_GENERATE_PREFIX_NALU_BIT_KHR = true,
        .VK_VIDEO_ENCODE_H264_CAPABILITY_MB_QP_DIFF_WRAPAROUND_BIT_KHR = extensions.device.VK_KHR_video_encode_quantization_map,
        .VK_VIDEO_ENCODE_H264_CAPABILITY_B_PICTURE_INTRA_REFRESH_BIT_KHR = extensions.device.VK_KHR_video_encode_intra_refresh,
    };
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkVideoEncodeH264StdFlagsKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH264StdFlagsKHR) bool {
    const valid_value: vk.VkVideoEncodeH264StdFlagsKHR = .{
        .VK_VIDEO_ENCODE_H264_STD_SEPARATE_COLOR_PLANE_FLAG_SET_BIT_KHR = true,
        .VK_VIDEO_ENCODE_H264_STD_QPPRIME_Y_ZERO_TRANSFORM_BYPASS_FLAG_SET_BIT_KHR = true,
        .VK_VIDEO_ENCODE_H264_STD_SCALING_MATRIX_PRESENT_FLAG_SET_BIT_KHR = true,
        .VK_VIDEO_ENCODE_H264_STD_CHROMA_QP_INDEX_OFFSET_BIT_KHR = true,
        .VK_VIDEO_ENCODE_H264_STD_SECOND_CHROMA_QP_INDEX_OFFSET_BIT_KHR = true,
        .VK_VIDEO_ENCODE_H264_STD_PIC_INIT_QP_MINUS26_BIT_KHR = true,
        .VK_VIDEO_ENCODE_H264_STD_WEIGHTED_PRED_FLAG_SET_BIT_KHR = true,
        .VK_VIDEO_ENCODE_H264_STD_WEIGHTED_BIPRED_IDC_EXPLICIT_BIT_KHR = true,
        .VK_VIDEO_ENCODE_H264_STD_WEIGHTED_BIPRED_IDC_IMPLICIT_BIT_KHR = true,
        .VK_VIDEO_ENCODE_H264_STD_TRANSFORM_8X8_MODE_FLAG_SET_BIT_KHR = true,
        .VK_VIDEO_ENCODE_H264_STD_DIRECT_SPATIAL_MV_PRED_FLAG_UNSET_BIT_KHR = true,
        .VK_VIDEO_ENCODE_H264_STD_ENTROPY_CODING_MODE_FLAG_UNSET_BIT_KHR = true,
        .VK_VIDEO_ENCODE_H264_STD_ENTROPY_CODING_MODE_FLAG_SET_BIT_KHR = true,
        .VK_VIDEO_ENCODE_H264_STD_DIRECT_8X8_INFERENCE_FLAG_UNSET_BIT_KHR = true,
        .VK_VIDEO_ENCODE_H264_STD_CONSTRAINED_INTRA_PRED_FLAG_SET_BIT_KHR = true,
        .VK_VIDEO_ENCODE_H264_STD_DEBLOCKING_FILTER_DISABLED_BIT_KHR = true,
        .VK_VIDEO_ENCODE_H264_STD_DEBLOCKING_FILTER_ENABLED_BIT_KHR = true,
        .VK_VIDEO_ENCODE_H264_STD_DEBLOCKING_FILTER_PARTIAL_BIT_KHR = true,
        .VK_VIDEO_ENCODE_H264_STD_SLICE_QP_DELTA_BIT_KHR = true,
        .VK_VIDEO_ENCODE_H264_STD_DIFFERENT_SLICE_QP_DELTA_BIT_KHR = true,
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkVideoEncodeH264RateControlFlagsKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH264RateControlFlagsKHR) bool {
    const valid_value: vk.VkVideoEncodeH264RateControlFlagsKHR = .{
        .VK_VIDEO_ENCODE_H264_RATE_CONTROL_ATTEMPT_HRD_COMPLIANCE_BIT_KHR = true,
        .VK_VIDEO_ENCODE_H264_RATE_CONTROL_REGULAR_GOP_BIT_KHR = true,
        .VK_VIDEO_ENCODE_H264_RATE_CONTROL_REFERENCE_PATTERN_FLAT_BIT_KHR = true,
        .VK_VIDEO_ENCODE_H264_RATE_CONTROL_REFERENCE_PATTERN_DYADIC_BIT_KHR = true,
        .VK_VIDEO_ENCODE_H264_RATE_CONTROL_TEMPORAL_LAYER_PATTERN_DYADIC_BIT_KHR = true,
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkVideoEncodeH265CapabilityFlagsKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH265CapabilityFlagsKHR) bool {
    const valid_value: vk.VkVideoEncodeH265CapabilityFlagsKHR = .{
        .VK_VIDEO_ENCODE_H265_CAPABILITY_HRD_COMPLIANCE_BIT_KHR = true,
        .VK_VIDEO_ENCODE_H265_CAPABILITY_PREDICTION_WEIGHT_TABLE_GENERATED_BIT_KHR = true,
        .VK_VIDEO_ENCODE_H265_CAPABILITY_ROW_UNALIGNED_SLICE_SEGMENT_BIT_KHR = true,
        .VK_VIDEO_ENCODE_H265_CAPABILITY_DIFFERENT_SLICE_SEGMENT_TYPE_BIT_KHR = true,
        .VK_VIDEO_ENCODE_H265_CAPABILITY_B_FRAME_IN_L0_LIST_BIT_KHR = true,
        .VK_VIDEO_ENCODE_H265_CAPABILITY_B_FRAME_IN_L1_LIST_BIT_KHR = true,
        .VK_VIDEO_ENCODE_H265_CAPABILITY_PER_PICTURE_TYPE_MIN_MAX_QP_BIT_KHR = true,
        .VK_VIDEO_ENCODE_H265_CAPABILITY_PER_SLICE_SEGMENT_CONSTANT_QP_BIT_KHR = true,
        .VK_VIDEO_ENCODE_H265_CAPABILITY_MULTIPLE_TILES_PER_SLICE_SEGMENT_BIT_KHR = true,
        .VK_VIDEO_ENCODE_H265_CAPABILITY_MULTIPLE_SLICE_SEGMENTS_PER_TILE_BIT_KHR = true,
        .VK_VIDEO_ENCODE_H265_CAPABILITY_CU_QP_DIFF_WRAPAROUND_BIT_KHR = extensions.device.VK_KHR_video_encode_quantization_map,
        .VK_VIDEO_ENCODE_H265_CAPABILITY_B_PICTURE_INTRA_REFRESH_BIT_KHR = extensions.device.VK_KHR_video_encode_intra_refresh,
    };
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkVideoEncodeH265StdFlagsKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH265StdFlagsKHR) bool {
    const valid_value: vk.VkVideoEncodeH265StdFlagsKHR = .{
        .VK_VIDEO_ENCODE_H265_STD_SEPARATE_COLOR_PLANE_FLAG_SET_BIT_KHR = true,
        .VK_VIDEO_ENCODE_H265_STD_SAMPLE_ADAPTIVE_OFFSET_ENABLED_FLAG_SET_BIT_KHR = true,
        .VK_VIDEO_ENCODE_H265_STD_SCALING_LIST_DATA_PRESENT_FLAG_SET_BIT_KHR = true,
        .VK_VIDEO_ENCODE_H265_STD_PCM_ENABLED_FLAG_SET_BIT_KHR = true,
        .VK_VIDEO_ENCODE_H265_STD_SPS_TEMPORAL_MVP_ENABLED_FLAG_SET_BIT_KHR = true,
        .VK_VIDEO_ENCODE_H265_STD_INIT_QP_MINUS26_BIT_KHR = true,
        .VK_VIDEO_ENCODE_H265_STD_WEIGHTED_PRED_FLAG_SET_BIT_KHR = true,
        .VK_VIDEO_ENCODE_H265_STD_WEIGHTED_BIPRED_FLAG_SET_BIT_KHR = true,
        .VK_VIDEO_ENCODE_H265_STD_LOG2_PARALLEL_MERGE_LEVEL_MINUS2_BIT_KHR = true,
        .VK_VIDEO_ENCODE_H265_STD_SIGN_DATA_HIDING_ENABLED_FLAG_SET_BIT_KHR = true,
        .VK_VIDEO_ENCODE_H265_STD_TRANSFORM_SKIP_ENABLED_FLAG_SET_BIT_KHR = true,
        .VK_VIDEO_ENCODE_H265_STD_TRANSFORM_SKIP_ENABLED_FLAG_UNSET_BIT_KHR = true,
        .VK_VIDEO_ENCODE_H265_STD_PPS_SLICE_CHROMA_QP_OFFSETS_PRESENT_FLAG_SET_BIT_KHR = true,
        .VK_VIDEO_ENCODE_H265_STD_TRANSQUANT_BYPASS_ENABLED_FLAG_SET_BIT_KHR = true,
        .VK_VIDEO_ENCODE_H265_STD_CONSTRAINED_INTRA_PRED_FLAG_SET_BIT_KHR = true,
        .VK_VIDEO_ENCODE_H265_STD_ENTROPY_CODING_SYNC_ENABLED_FLAG_SET_BIT_KHR = true,
        .VK_VIDEO_ENCODE_H265_STD_DEBLOCKING_FILTER_OVERRIDE_ENABLED_FLAG_SET_BIT_KHR = true,
        .VK_VIDEO_ENCODE_H265_STD_DEPENDENT_SLICE_SEGMENTS_ENABLED_FLAG_SET_BIT_KHR = true,
        .VK_VIDEO_ENCODE_H265_STD_DEPENDENT_SLICE_SEGMENT_FLAG_SET_BIT_KHR = true,
        .VK_VIDEO_ENCODE_H265_STD_SLICE_QP_DELTA_BIT_KHR = true,
        .VK_VIDEO_ENCODE_H265_STD_DIFFERENT_SLICE_QP_DELTA_BIT_KHR = true,
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkVideoEncodeH265RateControlFlagsKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH265RateControlFlagsKHR) bool {
    const valid_value: vk.VkVideoEncodeH265RateControlFlagsKHR = .{
        .VK_VIDEO_ENCODE_H265_RATE_CONTROL_ATTEMPT_HRD_COMPLIANCE_BIT_KHR = true,
        .VK_VIDEO_ENCODE_H265_RATE_CONTROL_REGULAR_GOP_BIT_KHR = true,
        .VK_VIDEO_ENCODE_H265_RATE_CONTROL_REFERENCE_PATTERN_FLAT_BIT_KHR = true,
        .VK_VIDEO_ENCODE_H265_RATE_CONTROL_REFERENCE_PATTERN_DYADIC_BIT_KHR = true,
        .VK_VIDEO_ENCODE_H265_RATE_CONTROL_TEMPORAL_SUB_LAYER_PATTERN_DYADIC_BIT_KHR = true,
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkVideoEncodeH265CtbSizeFlagsKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH265CtbSizeFlagsKHR) bool {
    const valid_value: vk.VkVideoEncodeH265CtbSizeFlagsKHR = .{
        .VK_VIDEO_ENCODE_H265_CTB_SIZE_16_BIT_KHR = true,
        .VK_VIDEO_ENCODE_H265_CTB_SIZE_32_BIT_KHR = true,
        .VK_VIDEO_ENCODE_H265_CTB_SIZE_64_BIT_KHR = true,
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkVideoEncodeH265TransformBlockSizeFlagsKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeH265TransformBlockSizeFlagsKHR) bool {
    const valid_value: vk.VkVideoEncodeH265TransformBlockSizeFlagsKHR = .{
        .VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_4_BIT_KHR = true,
        .VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_8_BIT_KHR = true,
        .VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_16_BIT_KHR = true,
        .VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_32_BIT_KHR = true,
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkVideoEncodeAV1CapabilityFlagsKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeAV1CapabilityFlagsKHR) bool {
    const valid_value: vk.VkVideoEncodeAV1CapabilityFlagsKHR = .{
        .VK_VIDEO_ENCODE_AV1_CAPABILITY_PER_RATE_CONTROL_GROUP_MIN_MAX_Q_INDEX_BIT_KHR = true,
        .VK_VIDEO_ENCODE_AV1_CAPABILITY_GENERATE_OBU_EXTENSION_HEADER_BIT_KHR = true,
        .VK_VIDEO_ENCODE_AV1_CAPABILITY_PRIMARY_REFERENCE_CDF_ONLY_BIT_KHR = true,
        .VK_VIDEO_ENCODE_AV1_CAPABILITY_FRAME_SIZE_OVERRIDE_BIT_KHR = true,
        .VK_VIDEO_ENCODE_AV1_CAPABILITY_MOTION_VECTOR_SCALING_BIT_KHR = true,
        .VK_VIDEO_ENCODE_AV1_CAPABILITY_COMPOUND_PREDICTION_INTRA_REFRESH_BIT_KHR = extensions.device.VK_KHR_video_encode_intra_refresh,
    };
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkVideoEncodeAV1StdFlagsKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeAV1StdFlagsKHR) bool {
    const valid_value: vk.VkVideoEncodeAV1StdFlagsKHR = .{
        .VK_VIDEO_ENCODE_AV1_STD_UNIFORM_TILE_SPACING_FLAG_SET_BIT_KHR = true,
        .VK_VIDEO_ENCODE_AV1_STD_SKIP_MODE_PRESENT_UNSET_BIT_KHR = true,
        .VK_VIDEO_ENCODE_AV1_STD_PRIMARY_REF_FRAME_BIT_KHR = true,
        .VK_VIDEO_ENCODE_AV1_STD_DELTA_Q_BIT_KHR = true,
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkVideoEncodeAV1RateControlFlagsKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeAV1RateControlFlagsKHR) bool {
    const valid_value: vk.VkVideoEncodeAV1RateControlFlagsKHR = .{
        .VK_VIDEO_ENCODE_AV1_RATE_CONTROL_REGULAR_GOP_BIT_KHR = true,
        .VK_VIDEO_ENCODE_AV1_RATE_CONTROL_TEMPORAL_LAYER_PATTERN_DYADIC_BIT_KHR = true,
        .VK_VIDEO_ENCODE_AV1_RATE_CONTROL_REFERENCE_PATTERN_FLAT_BIT_KHR = true,
        .VK_VIDEO_ENCODE_AV1_RATE_CONTROL_REFERENCE_PATTERN_DYADIC_BIT_KHR = true,
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkVideoEncodeAV1SuperblockSizeFlagsKHR(extensions: *const Extensions, item: *const vk.VkVideoEncodeAV1SuperblockSizeFlagsKHR) bool {
    const valid_value: vk.VkVideoEncodeAV1SuperblockSizeFlagsKHR = .{
        .VK_VIDEO_ENCODE_AV1_SUPERBLOCK_SIZE_64_BIT_KHR = true,
        .VK_VIDEO_ENCODE_AV1_SUPERBLOCK_SIZE_128_BIT_KHR = true,
    };
    _ = extensions;
    const valid_bits: u32 = @bitCast(valid_value);
    const current_bits: u32 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}

pub fn validate_VkAccessFlags3KHR(extensions: *const Extensions, item: *const vk.VkAccessFlags3KHR) bool {
    const valid_value: vk.VkAccessFlags3KHR = .{
    };
    _ = extensions;
    const valid_bits: u64 = @bitCast(valid_value);
    const current_bits: u64 = @bitCast(item.*);
    return (current_bits & ~valid_bits) == 0;
}
pub const AdditionalPDF = struct {
    VkPhysicalDeviceRobustness2FeaturesKHR: vk.VkPhysicalDeviceRobustness2FeaturesKHR = .{},
    VkPhysicalDeviceImageRobustnessFeatures: vk.VkPhysicalDeviceImageRobustnessFeatures = .{},
    VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV: vk.VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV = .{},
    VkPhysicalDeviceMeshShaderFeaturesEXT: vk.VkPhysicalDeviceMeshShaderFeaturesEXT = .{},
    VkPhysicalDeviceMeshShaderFeaturesNV: vk.VkPhysicalDeviceMeshShaderFeaturesNV = .{},
    VkPhysicalDeviceDescriptorBufferFeaturesEXT: vk.VkPhysicalDeviceDescriptorBufferFeaturesEXT = .{},
    VkPhysicalDeviceShaderObjectFeaturesEXT: vk.VkPhysicalDeviceShaderObjectFeaturesEXT = .{},
    VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT: vk.VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT = .{},
    VkPhysicalDeviceImage2DViewOf3DFeaturesEXT: vk.VkPhysicalDeviceImage2DViewOf3DFeaturesEXT = .{},
    VkPhysicalDeviceVulkan12Features: vk.VkPhysicalDeviceVulkan12Features = .{},
    VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT: vk.VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT = .{},
    VkPhysicalDeviceTransformFeedbackFeaturesEXT: vk.VkPhysicalDeviceTransformFeedbackFeaturesEXT = .{},
    VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM: vk.VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM = .{},
    VkPhysicalDeviceShaderTileImageFeaturesEXT: vk.VkPhysicalDeviceShaderTileImageFeaturesEXT = .{},
    VkPhysicalDeviceTensorFeaturesARM: vk.VkPhysicalDeviceTensorFeaturesARM = .{},
    VkPhysicalDeviceDataGraphFeaturesARM: vk.VkPhysicalDeviceDataGraphFeaturesARM = .{},
    VkPhysicalDeviceShaderFloat8FeaturesEXT: vk.VkPhysicalDeviceShaderFloat8FeaturesEXT = .{},
    VkPhysicalDeviceFragmentShadingRateFeaturesKHR: vk.VkPhysicalDeviceFragmentShadingRateFeaturesKHR = .{},
    VkPhysicalDeviceVulkan11Features: vk.VkPhysicalDeviceVulkan11Features = .{},
    VkPhysicalDeviceShaderDrawParametersFeatures: vk.VkPhysicalDeviceShaderDrawParametersFeatures = .{},
    VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR: vk.VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR = .{},
    VkPhysicalDevice16BitStorageFeatures: vk.VkPhysicalDevice16BitStorageFeatures = .{},
    VkPhysicalDeviceMultiviewFeatures: vk.VkPhysicalDeviceMultiviewFeatures = .{},
    VkPhysicalDeviceVariablePointersFeatures: vk.VkPhysicalDeviceVariablePointersFeatures = .{},
    VkPhysicalDeviceRayQueryFeaturesKHR: vk.VkPhysicalDeviceRayQueryFeaturesKHR = .{},
    VkPhysicalDeviceShaderUntypedPointersFeaturesKHR: vk.VkPhysicalDeviceShaderUntypedPointersFeaturesKHR = .{},
    VkPhysicalDeviceRayTracingPipelineFeaturesKHR: vk.VkPhysicalDeviceRayTracingPipelineFeaturesKHR = .{},
    VkPhysicalDeviceImageProcessingFeaturesQCOM: vk.VkPhysicalDeviceImageProcessingFeaturesQCOM = .{},
    VkPhysicalDeviceTileShadingFeaturesQCOM: vk.VkPhysicalDeviceTileShadingFeaturesQCOM = .{},
    VkPhysicalDeviceImageProcessing2FeaturesQCOM: vk.VkPhysicalDeviceImageProcessing2FeaturesQCOM = .{},
    VkPhysicalDeviceShaderEnqueueFeaturesAMDX: vk.VkPhysicalDeviceShaderEnqueueFeaturesAMDX = .{},
    VkPhysicalDeviceShaderQuadControlFeaturesKHR: vk.VkPhysicalDeviceShaderQuadControlFeaturesKHR = .{},
    VkPhysicalDeviceShaderBfloat16FeaturesKHR: vk.VkPhysicalDeviceShaderBfloat16FeaturesKHR = .{},
    VkPhysicalDeviceShaderImageFootprintFeaturesNV: vk.VkPhysicalDeviceShaderImageFootprintFeaturesNV = .{},
    VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR: vk.VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR = .{},
    VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR: vk.VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR = .{},
    VkPhysicalDeviceFragmentDensityMapFeaturesEXT: vk.VkPhysicalDeviceFragmentDensityMapFeaturesEXT = .{},
    VkPhysicalDeviceShadingRateImageFeaturesNV: vk.VkPhysicalDeviceShadingRateImageFeaturesNV = .{},
    VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR: vk.VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR = .{},
    VkPhysicalDeviceRayTracingMotionBlurFeaturesNV: vk.VkPhysicalDeviceRayTracingMotionBlurFeaturesNV = .{},
    VkPhysicalDeviceBufferDeviceAddressFeaturesEXT: vk.VkPhysicalDeviceBufferDeviceAddressFeaturesEXT = .{},
    VkPhysicalDeviceCooperativeMatrixFeaturesNV: vk.VkPhysicalDeviceCooperativeMatrixFeaturesNV = .{},
    VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT: vk.VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT = .{},
    VkPhysicalDeviceShaderSMBuiltinsFeaturesNV: vk.VkPhysicalDeviceShaderSMBuiltinsFeaturesNV = .{},
    VkPhysicalDeviceVulkan13Features: vk.VkPhysicalDeviceVulkan13Features = .{},
    VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures: vk.VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures = .{},
    VkPhysicalDeviceCooperativeVectorFeaturesNV: vk.VkPhysicalDeviceCooperativeVectorFeaturesNV = .{},
    VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV: vk.VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV = .{},
    VkPhysicalDeviceRawAccessChainsFeaturesNV: vk.VkPhysicalDeviceRawAccessChainsFeaturesNV = .{},
    VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV: vk.VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV = .{},
    VkPhysicalDeviceCooperativeMatrix2FeaturesNV: vk.VkPhysicalDeviceCooperativeMatrix2FeaturesNV = .{},
    VkPhysicalDeviceClusterAccelerationStructureFeaturesNV: vk.VkPhysicalDeviceClusterAccelerationStructureFeaturesNV = .{},
    VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL: vk.VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL = .{},
    VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT: vk.VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT = .{},
    VkPhysicalDeviceVulkan14Features: vk.VkPhysicalDeviceVulkan14Features = .{},
    VkPhysicalDeviceShaderExpectAssumeFeatures: vk.VkPhysicalDeviceShaderExpectAssumeFeatures = .{},
    VkPhysicalDeviceShaderIntegerDotProductFeatures: vk.VkPhysicalDeviceShaderIntegerDotProductFeatures = .{},
    VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR: vk.VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR = .{},
    VkPhysicalDeviceCooperativeMatrixFeaturesKHR: vk.VkPhysicalDeviceCooperativeMatrixFeaturesKHR = .{},
    VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT: vk.VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT = .{},
    VkPhysicalDeviceShaderSubgroupRotateFeatures: vk.VkPhysicalDeviceShaderSubgroupRotateFeatures = .{},
    VkPhysicalDeviceShaderFloatControls2Features: vk.VkPhysicalDeviceShaderFloatControls2Features = .{},
    VkPhysicalDeviceShaderFmaFeaturesKHR: vk.VkPhysicalDeviceShaderFmaFeaturesKHR = .{},
    VkPhysicalDeviceShaderAtomicFloatFeaturesEXT: vk.VkPhysicalDeviceShaderAtomicFloatFeaturesEXT = .{},

    pub fn chain_supported(pdf: *AdditionalPDF, extensions: [][*c]const u8) ?*anyopaque {
        var pnext: ?*anyopaque = null;
        for (extensions) |ext| {
            const e = std.mem.span(ext);
            if ((std.mem.eql(u8, e, "VK_EXT_robustness2") or
                std.mem.eql(u8, e, "VK_KHR_robustness2")) and pdf.VkPhysicalDeviceRobustness2FeaturesKHR.pNext == null)
            {
                pdf.VkPhysicalDeviceRobustness2FeaturesKHR.pNext = pnext;
                pnext = &pdf.VkPhysicalDeviceRobustness2FeaturesKHR;
                continue;
            }
            if ((std.mem.eql(u8, e, "VK_EXT_image_robustness")) and pdf.VkPhysicalDeviceImageRobustnessFeatures.pNext == null)
            {
                pdf.VkPhysicalDeviceImageRobustnessFeatures.pNext = pnext;
                pnext = &pdf.VkPhysicalDeviceImageRobustnessFeatures;
                continue;
            }
            if ((std.mem.eql(u8, e, "VK_NV_fragment_shading_rate_enums")) and pdf.VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV.pNext == null)
            {
                pdf.VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV.pNext = pnext;
                pnext = &pdf.VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV;
                continue;
            }
            if ((std.mem.eql(u8, e, "VK_EXT_mesh_shader")) and pdf.VkPhysicalDeviceMeshShaderFeaturesEXT.pNext == null)
            {
                pdf.VkPhysicalDeviceMeshShaderFeaturesEXT.pNext = pnext;
                pnext = &pdf.VkPhysicalDeviceMeshShaderFeaturesEXT;
                continue;
            }
            if ((std.mem.eql(u8, e, "VK_NV_mesh_shader")) and pdf.VkPhysicalDeviceMeshShaderFeaturesNV.pNext == null)
            {
                pdf.VkPhysicalDeviceMeshShaderFeaturesNV.pNext = pnext;
                pnext = &pdf.VkPhysicalDeviceMeshShaderFeaturesNV;
                continue;
            }
            if ((std.mem.eql(u8, e, "VK_EXT_descriptor_buffer")) and pdf.VkPhysicalDeviceDescriptorBufferFeaturesEXT.pNext == null)
            {
                pdf.VkPhysicalDeviceDescriptorBufferFeaturesEXT.pNext = pnext;
                pnext = &pdf.VkPhysicalDeviceDescriptorBufferFeaturesEXT;
                continue;
            }
            if ((std.mem.eql(u8, e, "VK_EXT_shader_object")) and pdf.VkPhysicalDeviceShaderObjectFeaturesEXT.pNext == null)
            {
                pdf.VkPhysicalDeviceShaderObjectFeaturesEXT.pNext = pnext;
                pnext = &pdf.VkPhysicalDeviceShaderObjectFeaturesEXT;
                continue;
            }
            if ((std.mem.eql(u8, e, "VK_EXT_primitives_generated_query")) and pdf.VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT.pNext == null)
            {
                pdf.VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT.pNext = pnext;
                pnext = &pdf.VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT;
                continue;
            }
            if ((std.mem.eql(u8, e, "VK_EXT_image_2d_view_of_3d")) and pdf.VkPhysicalDeviceImage2DViewOf3DFeaturesEXT.pNext == null)
            {
                pdf.VkPhysicalDeviceImage2DViewOf3DFeaturesEXT.pNext = pnext;
                pnext = &pdf.VkPhysicalDeviceImage2DViewOf3DFeaturesEXT;
                continue;
            }
            if ((std.mem.eql(u8, e, "VK_EXT_shader_image_atomic_int64")) and pdf.VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT.pNext == null)
            {
                pdf.VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT.pNext = pnext;
                pnext = &pdf.VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT;
                continue;
            }
            if ((std.mem.eql(u8, e, "VK_EXT_transform_feedback")) and pdf.VkPhysicalDeviceTransformFeedbackFeaturesEXT.pNext == null)
            {
                pdf.VkPhysicalDeviceTransformFeedbackFeaturesEXT.pNext = pnext;
                pnext = &pdf.VkPhysicalDeviceTransformFeedbackFeaturesEXT;
                continue;
            }
            if ((std.mem.eql(u8, e, "VK_ARM_shader_core_builtins")) and pdf.VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM.pNext == null)
            {
                pdf.VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM.pNext = pnext;
                pnext = &pdf.VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM;
                continue;
            }
            if ((std.mem.eql(u8, e, "VK_EXT_shader_tile_image")) and pdf.VkPhysicalDeviceShaderTileImageFeaturesEXT.pNext == null)
            {
                pdf.VkPhysicalDeviceShaderTileImageFeaturesEXT.pNext = pnext;
                pnext = &pdf.VkPhysicalDeviceShaderTileImageFeaturesEXT;
                continue;
            }
            if ((std.mem.eql(u8, e, "VK_ARM_tensors")) and pdf.VkPhysicalDeviceTensorFeaturesARM.pNext == null)
            {
                pdf.VkPhysicalDeviceTensorFeaturesARM.pNext = pnext;
                pnext = &pdf.VkPhysicalDeviceTensorFeaturesARM;
                continue;
            }
            if ((std.mem.eql(u8, e, "VK_ARM_data_graph")) and pdf.VkPhysicalDeviceDataGraphFeaturesARM.pNext == null)
            {
                pdf.VkPhysicalDeviceDataGraphFeaturesARM.pNext = pnext;
                pnext = &pdf.VkPhysicalDeviceDataGraphFeaturesARM;
                continue;
            }
            if ((std.mem.eql(u8, e, "VK_EXT_shader_float8")) and pdf.VkPhysicalDeviceShaderFloat8FeaturesEXT.pNext == null)
            {
                pdf.VkPhysicalDeviceShaderFloat8FeaturesEXT.pNext = pnext;
                pnext = &pdf.VkPhysicalDeviceShaderFloat8FeaturesEXT;
                continue;
            }
            if ((std.mem.eql(u8, e, "VK_KHR_fragment_shading_rate")) and pdf.VkPhysicalDeviceFragmentShadingRateFeaturesKHR.pNext == null)
            {
                pdf.VkPhysicalDeviceFragmentShadingRateFeaturesKHR.pNext = pnext;
                pnext = &pdf.VkPhysicalDeviceFragmentShadingRateFeaturesKHR;
                continue;
            }
            if ((std.mem.eql(u8, e, "VK_KHR_workgroup_memory_explicit_layout")) and pdf.VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR.pNext == null)
            {
                pdf.VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR.pNext = pnext;
                pnext = &pdf.VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR;
                continue;
            }
            if ((std.mem.eql(u8, e, "VK_KHR_16bit_storage")) and pdf.VkPhysicalDevice16BitStorageFeatures.pNext == null)
            {
                pdf.VkPhysicalDevice16BitStorageFeatures.pNext = pnext;
                pnext = &pdf.VkPhysicalDevice16BitStorageFeatures;
                continue;
            }
            if ((std.mem.eql(u8, e, "VK_KHR_multiview")) and pdf.VkPhysicalDeviceMultiviewFeatures.pNext == null)
            {
                pdf.VkPhysicalDeviceMultiviewFeatures.pNext = pnext;
                pnext = &pdf.VkPhysicalDeviceMultiviewFeatures;
                continue;
            }
            if ((std.mem.eql(u8, e, "VK_KHR_variable_pointers") or
                std.mem.eql(u8, e, "VK_KHR_variable_pointers")) and pdf.VkPhysicalDeviceVariablePointersFeatures.pNext == null)
            {
                pdf.VkPhysicalDeviceVariablePointersFeatures.pNext = pnext;
                pnext = &pdf.VkPhysicalDeviceVariablePointersFeatures;
                continue;
            }
            if ((std.mem.eql(u8, e, "VK_KHR_ray_query")) and pdf.VkPhysicalDeviceRayQueryFeaturesKHR.pNext == null)
            {
                pdf.VkPhysicalDeviceRayQueryFeaturesKHR.pNext = pnext;
                pnext = &pdf.VkPhysicalDeviceRayQueryFeaturesKHR;
                continue;
            }
            if ((std.mem.eql(u8, e, "VK_KHR_shader_untyped_pointers")) and pdf.VkPhysicalDeviceShaderUntypedPointersFeaturesKHR.pNext == null)
            {
                pdf.VkPhysicalDeviceShaderUntypedPointersFeaturesKHR.pNext = pnext;
                pnext = &pdf.VkPhysicalDeviceShaderUntypedPointersFeaturesKHR;
                continue;
            }
            if ((std.mem.eql(u8, e, "VK_KHR_ray_tracing_pipeline")) and pdf.VkPhysicalDeviceRayTracingPipelineFeaturesKHR.pNext == null)
            {
                pdf.VkPhysicalDeviceRayTracingPipelineFeaturesKHR.pNext = pnext;
                pnext = &pdf.VkPhysicalDeviceRayTracingPipelineFeaturesKHR;
                continue;
            }
            if ((std.mem.eql(u8, e, "VK_QCOM_image_processing")) and pdf.VkPhysicalDeviceImageProcessingFeaturesQCOM.pNext == null)
            {
                pdf.VkPhysicalDeviceImageProcessingFeaturesQCOM.pNext = pnext;
                pnext = &pdf.VkPhysicalDeviceImageProcessingFeaturesQCOM;
                continue;
            }
            if ((std.mem.eql(u8, e, "VK_QCOM_tile_shading")) and pdf.VkPhysicalDeviceTileShadingFeaturesQCOM.pNext == null)
            {
                pdf.VkPhysicalDeviceTileShadingFeaturesQCOM.pNext = pnext;
                pnext = &pdf.VkPhysicalDeviceTileShadingFeaturesQCOM;
                continue;
            }
            if ((std.mem.eql(u8, e, "VK_QCOM_image_processing2")) and pdf.VkPhysicalDeviceImageProcessing2FeaturesQCOM.pNext == null)
            {
                pdf.VkPhysicalDeviceImageProcessing2FeaturesQCOM.pNext = pnext;
                pnext = &pdf.VkPhysicalDeviceImageProcessing2FeaturesQCOM;
                continue;
            }
            if ((std.mem.eql(u8, e, "VK_AMDX_shader_enqueue")) and pdf.VkPhysicalDeviceShaderEnqueueFeaturesAMDX.pNext == null)
            {
                pdf.VkPhysicalDeviceShaderEnqueueFeaturesAMDX.pNext = pnext;
                pnext = &pdf.VkPhysicalDeviceShaderEnqueueFeaturesAMDX;
                continue;
            }
            if ((std.mem.eql(u8, e, "VK_KHR_shader_quad_control")) and pdf.VkPhysicalDeviceShaderQuadControlFeaturesKHR.pNext == null)
            {
                pdf.VkPhysicalDeviceShaderQuadControlFeaturesKHR.pNext = pnext;
                pnext = &pdf.VkPhysicalDeviceShaderQuadControlFeaturesKHR;
                continue;
            }
            if ((std.mem.eql(u8, e, "VK_KHR_shader_bfloat16")) and pdf.VkPhysicalDeviceShaderBfloat16FeaturesKHR.pNext == null)
            {
                pdf.VkPhysicalDeviceShaderBfloat16FeaturesKHR.pNext = pnext;
                pnext = &pdf.VkPhysicalDeviceShaderBfloat16FeaturesKHR;
                continue;
            }
            if ((std.mem.eql(u8, e, "VK_NV_shader_image_footprint")) and pdf.VkPhysicalDeviceShaderImageFootprintFeaturesNV.pNext == null)
            {
                pdf.VkPhysicalDeviceShaderImageFootprintFeaturesNV.pNext = pnext;
                pnext = &pdf.VkPhysicalDeviceShaderImageFootprintFeaturesNV;
                continue;
            }
            if ((std.mem.eql(u8, e, "VK_NV_fragment_shader_barycentric") or
                std.mem.eql(u8, e, "VK_KHR_fragment_shader_barycentric")) and pdf.VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR.pNext == null)
            {
                pdf.VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR.pNext = pnext;
                pnext = &pdf.VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR;
                continue;
            }
            if ((std.mem.eql(u8, e, "VK_NV_compute_shader_derivatives") or
                std.mem.eql(u8, e, "VK_KHR_compute_shader_derivatives")) and pdf.VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR.pNext == null)
            {
                pdf.VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR.pNext = pnext;
                pnext = &pdf.VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR;
                continue;
            }
            if ((std.mem.eql(u8, e, "VK_EXT_fragment_density_map")) and pdf.VkPhysicalDeviceFragmentDensityMapFeaturesEXT.pNext == null)
            {
                pdf.VkPhysicalDeviceFragmentDensityMapFeaturesEXT.pNext = pnext;
                pnext = &pdf.VkPhysicalDeviceFragmentDensityMapFeaturesEXT;
                continue;
            }
            if ((std.mem.eql(u8, e, "VK_NV_shading_rate_image")) and pdf.VkPhysicalDeviceShadingRateImageFeaturesNV.pNext == null)
            {
                pdf.VkPhysicalDeviceShadingRateImageFeaturesNV.pNext = pnext;
                pnext = &pdf.VkPhysicalDeviceShadingRateImageFeaturesNV;
                continue;
            }
            if ((std.mem.eql(u8, e, "VK_KHR_ray_tracing_position_fetch")) and pdf.VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR.pNext == null)
            {
                pdf.VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR.pNext = pnext;
                pnext = &pdf.VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR;
                continue;
            }
            if ((std.mem.eql(u8, e, "VK_NV_ray_tracing_motion_blur")) and pdf.VkPhysicalDeviceRayTracingMotionBlurFeaturesNV.pNext == null)
            {
                pdf.VkPhysicalDeviceRayTracingMotionBlurFeaturesNV.pNext = pnext;
                pnext = &pdf.VkPhysicalDeviceRayTracingMotionBlurFeaturesNV;
                continue;
            }
            if ((std.mem.eql(u8, e, "VK_EXT_buffer_device_address") or
                std.mem.eql(u8, e, "VK_EXT_buffer_device_address")) and pdf.VkPhysicalDeviceBufferDeviceAddressFeaturesEXT.pNext == null)
            {
                pdf.VkPhysicalDeviceBufferDeviceAddressFeaturesEXT.pNext = pnext;
                pnext = &pdf.VkPhysicalDeviceBufferDeviceAddressFeaturesEXT;
                continue;
            }
            if ((std.mem.eql(u8, e, "VK_NV_cooperative_matrix")) and pdf.VkPhysicalDeviceCooperativeMatrixFeaturesNV.pNext == null)
            {
                pdf.VkPhysicalDeviceCooperativeMatrixFeaturesNV.pNext = pnext;
                pnext = &pdf.VkPhysicalDeviceCooperativeMatrixFeaturesNV;
                continue;
            }
            if ((std.mem.eql(u8, e, "VK_EXT_fragment_shader_interlock")) and pdf.VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT.pNext == null)
            {
                pdf.VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT.pNext = pnext;
                pnext = &pdf.VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT;
                continue;
            }
            if ((std.mem.eql(u8, e, "VK_NV_shader_sm_builtins")) and pdf.VkPhysicalDeviceShaderSMBuiltinsFeaturesNV.pNext == null)
            {
                pdf.VkPhysicalDeviceShaderSMBuiltinsFeaturesNV.pNext = pnext;
                pnext = &pdf.VkPhysicalDeviceShaderSMBuiltinsFeaturesNV;
                continue;
            }
            if ((std.mem.eql(u8, e, "VK_EXT_shader_demote_to_helper_invocation")) and pdf.VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures.pNext == null)
            {
                pdf.VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures.pNext = pnext;
                pnext = &pdf.VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures;
                continue;
            }
            if ((std.mem.eql(u8, e, "VK_NV_cooperative_vector")) and pdf.VkPhysicalDeviceCooperativeVectorFeaturesNV.pNext == null)
            {
                pdf.VkPhysicalDeviceCooperativeVectorFeaturesNV.pNext = pnext;
                pnext = &pdf.VkPhysicalDeviceCooperativeVectorFeaturesNV;
                continue;
            }
            if ((std.mem.eql(u8, e, "VK_NV_shader_atomic_float16_vector")) and pdf.VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV.pNext == null)
            {
                pdf.VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV.pNext = pnext;
                pnext = &pdf.VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV;
                continue;
            }
            if ((std.mem.eql(u8, e, "VK_NV_raw_access_chains")) and pdf.VkPhysicalDeviceRawAccessChainsFeaturesNV.pNext == null)
            {
                pdf.VkPhysicalDeviceRawAccessChainsFeaturesNV.pNext = pnext;
                pnext = &pdf.VkPhysicalDeviceRawAccessChainsFeaturesNV;
                continue;
            }
            if ((std.mem.eql(u8, e, "VK_NV_ray_tracing_linear_swept_spheres")) and pdf.VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV.pNext == null)
            {
                pdf.VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV.pNext = pnext;
                pnext = &pdf.VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV;
                continue;
            }
            if ((std.mem.eql(u8, e, "VK_NV_cooperative_matrix2")) and pdf.VkPhysicalDeviceCooperativeMatrix2FeaturesNV.pNext == null)
            {
                pdf.VkPhysicalDeviceCooperativeMatrix2FeaturesNV.pNext = pnext;
                pnext = &pdf.VkPhysicalDeviceCooperativeMatrix2FeaturesNV;
                continue;
            }
            if ((std.mem.eql(u8, e, "VK_NV_cluster_acceleration_structure")) and pdf.VkPhysicalDeviceClusterAccelerationStructureFeaturesNV.pNext == null)
            {
                pdf.VkPhysicalDeviceClusterAccelerationStructureFeaturesNV.pNext = pnext;
                pnext = &pdf.VkPhysicalDeviceClusterAccelerationStructureFeaturesNV;
                continue;
            }
            if ((std.mem.eql(u8, e, "VK_INTEL_shader_integer_functions2")) and pdf.VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL.pNext == null)
            {
                pdf.VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL.pNext = pnext;
                pnext = &pdf.VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL;
                continue;
            }
            if ((std.mem.eql(u8, e, "VK_EXT_shader_atomic_float2")) and pdf.VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT.pNext == null)
            {
                pdf.VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT.pNext = pnext;
                pnext = &pdf.VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT;
                continue;
            }
            if ((std.mem.eql(u8, e, "VK_KHR_shader_expect_assume")) and pdf.VkPhysicalDeviceShaderExpectAssumeFeatures.pNext == null)
            {
                pdf.VkPhysicalDeviceShaderExpectAssumeFeatures.pNext = pnext;
                pnext = &pdf.VkPhysicalDeviceShaderExpectAssumeFeatures;
                continue;
            }
            if ((std.mem.eql(u8, e, "VK_KHR_shader_integer_dot_product")) and pdf.VkPhysicalDeviceShaderIntegerDotProductFeatures.pNext == null)
            {
                pdf.VkPhysicalDeviceShaderIntegerDotProductFeatures.pNext = pnext;
                pnext = &pdf.VkPhysicalDeviceShaderIntegerDotProductFeatures;
                continue;
            }
            if ((std.mem.eql(u8, e, "VK_KHR_ray_tracing_maintenance1")) and pdf.VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR.pNext == null)
            {
                pdf.VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR.pNext = pnext;
                pnext = &pdf.VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR;
                continue;
            }
            if ((std.mem.eql(u8, e, "VK_KHR_cooperative_matrix")) and pdf.VkPhysicalDeviceCooperativeMatrixFeaturesKHR.pNext == null)
            {
                pdf.VkPhysicalDeviceCooperativeMatrixFeaturesKHR.pNext = pnext;
                pnext = &pdf.VkPhysicalDeviceCooperativeMatrixFeaturesKHR;
                continue;
            }
            if ((std.mem.eql(u8, e, "VK_EXT_shader_replicated_composites")) and pdf.VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT.pNext == null)
            {
                pdf.VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT.pNext = pnext;
                pnext = &pdf.VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT;
                continue;
            }
            if ((std.mem.eql(u8, e, "VK_KHR_shader_subgroup_rotate")) and pdf.VkPhysicalDeviceShaderSubgroupRotateFeatures.pNext == null)
            {
                pdf.VkPhysicalDeviceShaderSubgroupRotateFeatures.pNext = pnext;
                pnext = &pdf.VkPhysicalDeviceShaderSubgroupRotateFeatures;
                continue;
            }
            if ((std.mem.eql(u8, e, "VK_KHR_shader_float_controls2")) and pdf.VkPhysicalDeviceShaderFloatControls2Features.pNext == null)
            {
                pdf.VkPhysicalDeviceShaderFloatControls2Features.pNext = pnext;
                pnext = &pdf.VkPhysicalDeviceShaderFloatControls2Features;
                continue;
            }
            if ((std.mem.eql(u8, e, "VK_KHR_shader_fma")) and pdf.VkPhysicalDeviceShaderFmaFeaturesKHR.pNext == null)
            {
                pdf.VkPhysicalDeviceShaderFmaFeaturesKHR.pNext = pnext;
                pnext = &pdf.VkPhysicalDeviceShaderFmaFeaturesKHR;
                continue;
            }
            if ((std.mem.eql(u8, e, "VK_EXT_shader_atomic_float")) and pdf.VkPhysicalDeviceShaderAtomicFloatFeaturesEXT.pNext == null)
            {
                pdf.VkPhysicalDeviceShaderAtomicFloatFeaturesEXT.pNext = pnext;
                pnext = &pdf.VkPhysicalDeviceShaderAtomicFloatFeaturesEXT;
                continue;
            }
        }
        pdf.VkPhysicalDeviceVulkan12Features.pNext = pnext;
        pnext = &pdf.VkPhysicalDeviceVulkan12Features;
        pdf.VkPhysicalDeviceVulkan11Features.pNext = pnext;
        pnext = &pdf.VkPhysicalDeviceVulkan11Features;
        pdf.VkPhysicalDeviceShaderDrawParametersFeatures.pNext = pnext;
        pnext = &pdf.VkPhysicalDeviceShaderDrawParametersFeatures;
        pdf.VkPhysicalDeviceVulkan13Features.pNext = pnext;
        pnext = &pdf.VkPhysicalDeviceVulkan13Features;
        pdf.VkPhysicalDeviceVulkan14Features.pNext = pnext;
        pnext = &pdf.VkPhysicalDeviceVulkan14Features;
        return pnext;
    }
};
pub const AdditionalProperties = struct {
    VkPhysicalDeviceVulkan11Properties: vk.VkPhysicalDeviceVulkan11Properties = .{},
    VkPhysicalDeviceVulkan12Properties: vk.VkPhysicalDeviceVulkan12Properties = .{},

    pub fn chain_supported(pdf: *AdditionalProperties, extensions: [][*c]const u8) ?*anyopaque {
        var pnext: ?*anyopaque = null;
        for (extensions) |ext| {
            const e = std.mem.span(ext);
            _ = e;
        }
        pdf.VkPhysicalDeviceVulkan11Properties.pNext = pnext;
        pnext = &pdf.VkPhysicalDeviceVulkan11Properties;
        pdf.VkPhysicalDeviceVulkan12Properties.pNext = pnext;
        pnext = &pdf.VkPhysicalDeviceVulkan12Properties;
        return pnext;
    }
};

pub fn validate_spirv_extension(validation: *const Validation, extension_name: []const u8) bool {
    if (std.mem.eql(u8, extension_name, "SPV_KHR_variable_pointers"))
        return validation.extensions.device.VK_KHR_variable_pointers or !validation.api_version.less(vk.VK_API_VERSION_1_1);
    if (std.mem.eql(u8, extension_name, "SPV_AMD_shader_explicit_vertex_parameter"))
        return validation.extensions.device.VK_AMD_shader_explicit_vertex_parameter;
    if (std.mem.eql(u8, extension_name, "SPV_AMD_gcn_shader"))
        return validation.extensions.device.VK_AMD_gcn_shader;
    if (std.mem.eql(u8, extension_name, "SPV_AMD_gpu_shader_half_float"))
        return validation.extensions.device.VK_AMD_gpu_shader_half_float;
    if (std.mem.eql(u8, extension_name, "SPV_AMD_gpu_shader_int16"))
        return validation.extensions.device.VK_AMD_gpu_shader_int16;
    if (std.mem.eql(u8, extension_name, "SPV_AMD_shader_ballot"))
        return validation.extensions.device.VK_AMD_shader_ballot;
    if (std.mem.eql(u8, extension_name, "SPV_AMD_shader_fragment_mask"))
        return validation.extensions.device.VK_AMD_shader_fragment_mask;
    if (std.mem.eql(u8, extension_name, "SPV_AMD_shader_image_load_store_lod"))
        return validation.extensions.device.VK_AMD_shader_image_load_store_lod;
    if (std.mem.eql(u8, extension_name, "SPV_AMD_shader_trinary_minmax"))
        return validation.extensions.device.VK_AMD_shader_trinary_minmax;
    if (std.mem.eql(u8, extension_name, "SPV_AMD_texture_gather_bias_lod"))
        return validation.extensions.device.VK_AMD_texture_gather_bias_lod;
    if (std.mem.eql(u8, extension_name, "SPV_AMD_shader_early_and_late_fragment_tests"))
        return validation.extensions.device.VK_AMD_shader_early_and_late_fragment_tests;
    if (std.mem.eql(u8, extension_name, "SPV_KHR_shader_draw_parameters"))
        return validation.extensions.device.VK_KHR_shader_draw_parameters or !validation.api_version.less(vk.VK_API_VERSION_1_1);
    if (std.mem.eql(u8, extension_name, "SPV_KHR_8bit_storage"))
        return validation.extensions.device.VK_KHR_8bit_storage or !validation.api_version.less(vk.VK_API_VERSION_1_2);
    if (std.mem.eql(u8, extension_name, "SPV_KHR_16bit_storage"))
        return validation.extensions.device.VK_KHR_16bit_storage or !validation.api_version.less(vk.VK_API_VERSION_1_1);
    if (std.mem.eql(u8, extension_name, "SPV_KHR_shader_clock"))
        return validation.extensions.device.VK_KHR_shader_clock;
    if (std.mem.eql(u8, extension_name, "SPV_KHR_float_controls"))
        return validation.extensions.device.VK_KHR_shader_float_controls or !validation.api_version.less(vk.VK_API_VERSION_1_2);
    if (std.mem.eql(u8, extension_name, "SPV_KHR_storage_buffer_storage_class"))
        return validation.extensions.device.VK_KHR_storage_buffer_storage_class or !validation.api_version.less(vk.VK_API_VERSION_1_1);
    if (std.mem.eql(u8, extension_name, "SPV_KHR_post_depth_coverage"))
        return validation.extensions.device.VK_EXT_post_depth_coverage;
    if (std.mem.eql(u8, extension_name, "SPV_EXT_shader_stencil_export"))
        return validation.extensions.device.VK_EXT_shader_stencil_export;
    if (std.mem.eql(u8, extension_name, "SPV_KHR_shader_ballot"))
        return validation.extensions.device.VK_EXT_shader_subgroup_ballot;
    if (std.mem.eql(u8, extension_name, "SPV_KHR_subgroup_vote"))
        return validation.extensions.device.VK_EXT_shader_subgroup_vote;
    if (std.mem.eql(u8, extension_name, "SPV_NV_sample_mask_override_coverage"))
        return validation.extensions.device.VK_NV_sample_mask_override_coverage;
    if (std.mem.eql(u8, extension_name, "SPV_NV_geometry_shader_passthrough"))
        return validation.extensions.device.VK_NV_geometry_shader_passthrough;
    if (std.mem.eql(u8, extension_name, "SPV_NV_mesh_shader"))
        return validation.extensions.device.VK_NV_mesh_shader;
    if (std.mem.eql(u8, extension_name, "SPV_NV_viewport_array2"))
        return validation.extensions.device.VK_NV_viewport_array2;
    if (std.mem.eql(u8, extension_name, "SPV_NV_shader_subgroup_partitioned"))
        return validation.extensions.device.VK_NV_shader_subgroup_partitioned;
    if (std.mem.eql(u8, extension_name, "SPV_NV_shader_invocation_reorder"))
        return validation.extensions.device.VK_NV_ray_tracing_invocation_reorder;
    if (std.mem.eql(u8, extension_name, "SPV_EXT_shader_viewport_index_layer"))
        return validation.extensions.device.VK_EXT_shader_viewport_index_layer or !validation.api_version.less(vk.VK_API_VERSION_1_2);
    if (std.mem.eql(u8, extension_name, "SPV_NVX_multiview_per_view_attributes"))
        return validation.extensions.device.VK_NVX_multiview_per_view_attributes;
    if (std.mem.eql(u8, extension_name, "SPV_EXT_descriptor_indexing"))
        return validation.extensions.device.VK_EXT_descriptor_indexing or !validation.api_version.less(vk.VK_API_VERSION_1_2);
    if (std.mem.eql(u8, extension_name, "SPV_KHR_vulkan_memory_model"))
        return validation.extensions.device.VK_KHR_vulkan_memory_model or !validation.api_version.less(vk.VK_API_VERSION_1_2);
    if (std.mem.eql(u8, extension_name, "SPV_NV_compute_shader_derivatives"))
        return validation.extensions.device.VK_NV_compute_shader_derivatives;
    if (std.mem.eql(u8, extension_name, "SPV_NV_fragment_shader_barycentric"))
        return validation.extensions.device.VK_NV_fragment_shader_barycentric;
    if (std.mem.eql(u8, extension_name, "SPV_NV_shader_image_footprint"))
        return validation.extensions.device.VK_NV_shader_image_footprint;
    if (std.mem.eql(u8, extension_name, "SPV_NV_shading_rate"))
        return validation.extensions.device.VK_NV_shading_rate_image;
    if (std.mem.eql(u8, extension_name, "SPV_NV_ray_tracing"))
        return validation.extensions.device.VK_NV_ray_tracing;
    if (std.mem.eql(u8, extension_name, "SPV_KHR_ray_tracing"))
        return validation.extensions.device.VK_KHR_ray_tracing_pipeline;
    if (std.mem.eql(u8, extension_name, "SPV_KHR_ray_query"))
        return validation.extensions.device.VK_KHR_ray_query;
    if (std.mem.eql(u8, extension_name, "SPV_KHR_ray_cull_mask"))
        return validation.extensions.device.VK_KHR_ray_tracing_maintenance1;
    if (std.mem.eql(u8, extension_name, "SPV_GOOGLE_hlsl_functionality1"))
        return validation.extensions.device.VK_GOOGLE_hlsl_functionality1;
    if (std.mem.eql(u8, extension_name, "SPV_GOOGLE_user_type"))
        return validation.extensions.device.VK_GOOGLE_user_type;
    if (std.mem.eql(u8, extension_name, "SPV_GOOGLE_decorate_string"))
        return validation.extensions.device.VK_GOOGLE_decorate_string;
    if (std.mem.eql(u8, extension_name, "SPV_EXT_fragment_invocation_density"))
        return validation.extensions.device.VK_EXT_fragment_density_map;
    if (std.mem.eql(u8, extension_name, "SPV_KHR_physical_storage_buffer"))
        return validation.extensions.device.VK_KHR_buffer_device_address or !validation.api_version.less(vk.VK_API_VERSION_1_2);
    if (std.mem.eql(u8, extension_name, "SPV_EXT_physical_storage_buffer"))
        return validation.extensions.device.VK_EXT_buffer_device_address;
    if (std.mem.eql(u8, extension_name, "SPV_NV_cooperative_matrix"))
        return validation.extensions.device.VK_NV_cooperative_matrix;
    if (std.mem.eql(u8, extension_name, "SPV_NV_shader_sm_builtins"))
        return validation.extensions.device.VK_NV_shader_sm_builtins;
    if (std.mem.eql(u8, extension_name, "SPV_EXT_fragment_shader_interlock"))
        return validation.extensions.device.VK_EXT_fragment_shader_interlock;
    if (std.mem.eql(u8, extension_name, "SPV_EXT_demote_to_helper_invocation"))
        return validation.extensions.device.VK_EXT_shader_demote_to_helper_invocation or !validation.api_version.less(vk.VK_API_VERSION_1_3);
    if (std.mem.eql(u8, extension_name, "SPV_KHR_fragment_shading_rate"))
        return validation.extensions.device.VK_KHR_fragment_shading_rate;
    if (std.mem.eql(u8, extension_name, "SPV_KHR_non_semantic_info"))
        return validation.extensions.device.VK_KHR_shader_non_semantic_info or !validation.api_version.less(vk.VK_API_VERSION_1_3);
    if (std.mem.eql(u8, extension_name, "SPV_EXT_shader_image_int64"))
        return validation.extensions.device.VK_EXT_shader_image_atomic_int64;
    if (std.mem.eql(u8, extension_name, "SPV_KHR_terminate_invocation"))
        return validation.extensions.device.VK_KHR_shader_terminate_invocation or !validation.api_version.less(vk.VK_API_VERSION_1_3);
    if (std.mem.eql(u8, extension_name, "SPV_KHR_multiview"))
        return validation.extensions.device.VK_KHR_multiview or !validation.api_version.less(vk.VK_API_VERSION_1_1);
    if (std.mem.eql(u8, extension_name, "SPV_KHR_workgroup_memory_explicit_layout"))
        return validation.extensions.device.VK_KHR_workgroup_memory_explicit_layout;
    if (std.mem.eql(u8, extension_name, "SPV_EXT_shader_atomic_float_add"))
        return validation.extensions.device.VK_EXT_shader_atomic_float;
    if (std.mem.eql(u8, extension_name, "SPV_KHR_fragment_shader_barycentric"))
        return validation.extensions.device.VK_KHR_fragment_shader_barycentric;
    if (std.mem.eql(u8, extension_name, "SPV_KHR_subgroup_uniform_control_flow"))
        return validation.extensions.device.VK_KHR_shader_subgroup_uniform_control_flow;
    if (std.mem.eql(u8, extension_name, "SPV_EXT_shader_atomic_float_min_max"))
        return validation.extensions.device.VK_EXT_shader_atomic_float2;
    if (std.mem.eql(u8, extension_name, "SPV_EXT_shader_atomic_float16_add"))
        return validation.extensions.device.VK_EXT_shader_atomic_float2;
    if (std.mem.eql(u8, extension_name, "SPV_NV_shader_atomic_fp16_vector"))
        return validation.extensions.device.VK_NV_shader_atomic_float16_vector;
    if (std.mem.eql(u8, extension_name, "SPV_EXT_fragment_fully_covered"))
        return validation.extensions.device.VK_EXT_conservative_rasterization;
    if (std.mem.eql(u8, extension_name, "SPV_KHR_integer_dot_product"))
        return validation.extensions.device.VK_KHR_shader_integer_dot_product or !validation.api_version.less(vk.VK_API_VERSION_1_3);
    if (std.mem.eql(u8, extension_name, "SPV_INTEL_shader_integer_functions2"))
        return validation.extensions.device.VK_INTEL_shader_integer_functions2;
    if (std.mem.eql(u8, extension_name, "SPV_KHR_device_group"))
        return validation.extensions.device.VK_KHR_device_group or !validation.api_version.less(vk.VK_API_VERSION_1_1);
    if (std.mem.eql(u8, extension_name, "SPV_QCOM_image_processing"))
        return validation.extensions.device.VK_QCOM_image_processing;
    if (std.mem.eql(u8, extension_name, "SPV_QCOM_image_processing2"))
        return validation.extensions.device.VK_QCOM_image_processing2;
    if (std.mem.eql(u8, extension_name, "SPV_EXT_mesh_shader"))
        return validation.extensions.device.VK_EXT_mesh_shader;
    if (std.mem.eql(u8, extension_name, "SPV_KHR_ray_tracing_position_fetch"))
        return validation.extensions.device.VK_KHR_ray_tracing_position_fetch;
    if (std.mem.eql(u8, extension_name, "SPV_EXT_shader_tile_image"))
        return validation.extensions.device.VK_EXT_shader_tile_image;
    if (std.mem.eql(u8, extension_name, "SPV_EXT_opacity_micromap"))
        return validation.extensions.device.VK_EXT_opacity_micromap;
    if (std.mem.eql(u8, extension_name, "SPV_KHR_cooperative_matrix"))
        return validation.extensions.device.VK_KHR_cooperative_matrix;
    if (std.mem.eql(u8, extension_name, "SPV_ARM_core_builtins"))
        return validation.extensions.device.VK_ARM_shader_core_builtins;
    if (std.mem.eql(u8, extension_name, "SPV_HUAWEI_cluster_culling_shader"))
        return validation.extensions.device.VK_HUAWEI_cluster_culling_shader;
    if (std.mem.eql(u8, extension_name, "SPV_HUAWEI_subpass_shading"))
        return validation.extensions.device.VK_HUAWEI_subpass_shading;
    if (std.mem.eql(u8, extension_name, "SPV_NV_ray_tracing_motion_blur"))
        return validation.extensions.device.VK_NV_ray_tracing_motion_blur;
    if (std.mem.eql(u8, extension_name, "SPV_KHR_maximal_reconvergence"))
        return validation.extensions.device.VK_KHR_shader_maximal_reconvergence;
    if (std.mem.eql(u8, extension_name, "SPV_KHR_subgroup_rotate"))
        return validation.extensions.device.VK_KHR_shader_subgroup_rotate or !validation.api_version.less(vk.VK_API_VERSION_1_4);
    if (std.mem.eql(u8, extension_name, "SPV_KHR_expect_assume"))
        return validation.extensions.device.VK_KHR_shader_expect_assume or !validation.api_version.less(vk.VK_API_VERSION_1_4);
    if (std.mem.eql(u8, extension_name, "SPV_KHR_float_controls2"))
        return validation.extensions.device.VK_KHR_shader_float_controls2 or !validation.api_version.less(vk.VK_API_VERSION_1_4);
    if (std.mem.eql(u8, extension_name, "SPV_KHR_fma"))
        return validation.extensions.device.VK_KHR_shader_fma;
    if (std.mem.eql(u8, extension_name, "SPV_KHR_quad_control"))
        return validation.extensions.device.VK_KHR_shader_quad_control;
    if (std.mem.eql(u8, extension_name, "SPV_KHR_bfloat16"))
        return validation.extensions.device.VK_KHR_shader_bfloat16;
    if (std.mem.eql(u8, extension_name, "SPV_NV_raw_access_chains"))
        return validation.extensions.device.VK_NV_raw_access_chains;
    if (std.mem.eql(u8, extension_name, "SPV_KHR_compute_shader_derivatives"))
        return validation.extensions.device.VK_KHR_compute_shader_derivatives;
    if (std.mem.eql(u8, extension_name, "SPV_EXT_replicated_composites"))
        return validation.extensions.device.VK_EXT_shader_replicated_composites;
    if (std.mem.eql(u8, extension_name, "SPV_KHR_relaxed_extended_instruction"))
        return validation.extensions.device.VK_KHR_shader_relaxed_extended_instruction;
    if (std.mem.eql(u8, extension_name, "SPV_NV_cooperative_matrix2"))
        return validation.extensions.device.VK_NV_cooperative_matrix2;
    if (std.mem.eql(u8, extension_name, "SPV_NV_tensor_addressing"))
        return validation.extensions.device.VK_NV_cooperative_matrix2;
    if (std.mem.eql(u8, extension_name, "SPV_NV_linear_swept_spheres"))
        return validation.extensions.device.VK_NV_ray_tracing_linear_swept_spheres;
    if (std.mem.eql(u8, extension_name, "SPV_NV_cluster_acceleration_structure"))
        return validation.extensions.device.VK_NV_cluster_acceleration_structure;
    if (std.mem.eql(u8, extension_name, "SPV_NV_cooperative_vector"))
        return validation.extensions.device.VK_NV_cooperative_vector;
    if (std.mem.eql(u8, extension_name, "SPV_EXT_shader_invocation_reorder"))
        return validation.extensions.device.VK_EXT_ray_tracing_invocation_reorder;
    if (std.mem.eql(u8, extension_name, "SPV_QCOM_tile_shading"))
        return validation.extensions.device.VK_QCOM_tile_shading;
    if (std.mem.eql(u8, extension_name, "SPV_ARM_tensors"))
        return validation.extensions.device.VK_ARM_tensors;
    if (std.mem.eql(u8, extension_name, "SPV_EXT_float8"))
        return validation.extensions.device.VK_EXT_shader_float8;
    if (std.mem.eql(u8, extension_name, "SPV_ARM_graph"))
        return validation.extensions.device.VK_ARM_data_graph;
    if (std.mem.eql(u8, extension_name, "SPV_KHR_untyped_pointers"))
        return validation.extensions.device.VK_KHR_shader_untyped_pointers;
    if (std.mem.eql(u8, extension_name, "SPV_EXT_shader_64bit_indexing"))
        return validation.extensions.device.VK_EXT_shader_64bit_indexing;
    return false;
}

pub fn validate_spirv_capability(validation: *const Validation, capability: u32) bool {
    switch (capability) {
        // Matrix
        0 => {
            if (!validation.api_version.less(vk.VK_API_VERSION_1_0)) return true;
        },
        // Shader
        1 => {
            if (!validation.api_version.less(vk.VK_API_VERSION_1_0)) return true;
        },
        // Geometry
        2 => {
            if (validation.pdf.features.geometryShader == vk.VK_TRUE) return true;
        },
        // Tessellation
        3 => {
            if (validation.pdf.features.tessellationShader == vk.VK_TRUE) return true;
        },
        // Float16
        9 => {
            if (validation.additional_pdf.VkPhysicalDeviceVulkan12Features.shaderFloat16 == vk.VK_TRUE) return true;
            if (validation.extensions.device.VK_AMD_gpu_shader_half_float) return true;
        },
        // Float64
        10 => {
            if (validation.pdf.features.shaderFloat64 == vk.VK_TRUE) return true;
        },
        // Int64
        11 => {
            if (validation.pdf.features.shaderInt64 == vk.VK_TRUE) return true;
        },
        // Int64Atomics
        12 => {
            if (validation.additional_pdf.VkPhysicalDeviceVulkan12Features.shaderBufferInt64Atomics == vk.VK_TRUE) return true;
            if (validation.additional_pdf.VkPhysicalDeviceVulkan12Features.shaderSharedInt64Atomics == vk.VK_TRUE) return true;
            if (validation.additional_pdf.VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT.shaderImageInt64Atomics == vk.VK_TRUE) return true;
        },
        // Int16
        22 => {
            if (validation.pdf.features.shaderInt16 == vk.VK_TRUE) return true;
        },
        // TessellationPointSize
        23 => {
            if (validation.pdf.features.shaderTessellationAndGeometryPointSize == vk.VK_TRUE) return true;
        },
        // GeometryPointSize
        24 => {
            if (validation.pdf.features.shaderTessellationAndGeometryPointSize == vk.VK_TRUE) return true;
        },
        // ImageGatherExtended
        25 => {
            if (validation.pdf.features.shaderImageGatherExtended == vk.VK_TRUE) return true;
        },
        // StorageImageMultisample
        27 => {
            if (validation.pdf.features.shaderStorageImageMultisample == vk.VK_TRUE) return true;
        },
        // UniformBufferArrayDynamicIndexing
        28 => {
            if (validation.pdf.features.shaderUniformBufferArrayDynamicIndexing == vk.VK_TRUE) return true;
        },
        // SampledImageArrayDynamicIndexing
        29 => {
            if (validation.pdf.features.shaderSampledImageArrayDynamicIndexing == vk.VK_TRUE) return true;
        },
        // StorageBufferArrayDynamicIndexing
        30 => {
            if (validation.pdf.features.shaderStorageBufferArrayDynamicIndexing == vk.VK_TRUE) return true;
        },
        // StorageImageArrayDynamicIndexing
        31 => {
            if (validation.pdf.features.shaderStorageImageArrayDynamicIndexing == vk.VK_TRUE) return true;
        },
        // ClipDistance
        32 => {
            if (validation.pdf.features.shaderClipDistance == vk.VK_TRUE) return true;
        },
        // CullDistance
        33 => {
            if (validation.pdf.features.shaderCullDistance == vk.VK_TRUE) return true;
        },
        // ImageCubeArray
        34 => {
            if (validation.pdf.features.imageCubeArray == vk.VK_TRUE) return true;
        },
        // SampleRateShading
        35 => {
            if (validation.pdf.features.sampleRateShading == vk.VK_TRUE) return true;
        },
        // Int8
        39 => {
            if (validation.additional_pdf.VkPhysicalDeviceVulkan12Features.shaderInt8 == vk.VK_TRUE) return true;
        },
        // InputAttachment
        40 => {
            if (!validation.api_version.less(vk.VK_API_VERSION_1_0)) return true;
        },
        // SparseResidency
        41 => {
            if (validation.pdf.features.shaderResourceResidency == vk.VK_TRUE) return true;
        },
        // MinLod
        42 => {
            if (validation.pdf.features.shaderResourceMinLod == vk.VK_TRUE) return true;
        },
        // Sampled1D
        43 => {
            if (!validation.api_version.less(vk.VK_API_VERSION_1_0)) return true;
        },
        // Image1D
        44 => {
            if (!validation.api_version.less(vk.VK_API_VERSION_1_0)) return true;
        },
        // SampledCubeArray
        45 => {
            if (validation.pdf.features.imageCubeArray == vk.VK_TRUE) return true;
        },
        // SampledBuffer
        46 => {
            if (!validation.api_version.less(vk.VK_API_VERSION_1_0)) return true;
        },
        // ImageBuffer
        47 => {
            if (!validation.api_version.less(vk.VK_API_VERSION_1_0)) return true;
        },
        // ImageMSArray
        48 => {
            if (validation.pdf.features.shaderStorageImageMultisample == vk.VK_TRUE) return true;
        },
        // StorageImageExtendedFormats
        49 => {
            if (!validation.api_version.less(vk.VK_API_VERSION_1_0)) return true;
        },
        // ImageQuery
        50 => {
            if (!validation.api_version.less(vk.VK_API_VERSION_1_0)) return true;
        },
        // DerivativeControl
        51 => {
            if (!validation.api_version.less(vk.VK_API_VERSION_1_0)) return true;
        },
        // InterpolationFunction
        52 => {
            if (validation.pdf.features.sampleRateShading == vk.VK_TRUE) return true;
        },
        // TransformFeedback
        53 => {
            if (validation.additional_pdf.VkPhysicalDeviceTransformFeedbackFeaturesEXT.transformFeedback == vk.VK_TRUE) return true;
        },
        // GeometryStreams
        54 => {
            if (validation.additional_pdf.VkPhysicalDeviceTransformFeedbackFeaturesEXT.geometryStreams == vk.VK_TRUE) return true;
        },
        // StorageImageReadWithoutFormat
        55 => {
            if (validation.pdf.features.shaderStorageImageReadWithoutFormat == vk.VK_TRUE) return true;
            if (!validation.api_version.less(vk.VK_API_VERSION_1_3)) return true;
            if (validation.extensions.device.VK_KHR_format_feature_flags2) return true;
        },
        // StorageImageWriteWithoutFormat
        56 => {
            if (validation.pdf.features.shaderStorageImageWriteWithoutFormat == vk.VK_TRUE) return true;
            if (!validation.api_version.less(vk.VK_API_VERSION_1_3)) return true;
            if (validation.extensions.device.VK_KHR_format_feature_flags2) return true;
        },
        // MultiViewport
        57 => {
            if (validation.pdf.features.multiViewport == vk.VK_TRUE) return true;
        },
        // GroupNonUniform
        61 => {
            if (validation.additional_properties.VkPhysicalDeviceVulkan11Properties.subgroupSupportedOperations.VK_SUBGROUP_FEATURE_BASIC_BIT) return true;
        },
        // GroupNonUniformVote
        62 => {
            if (validation.additional_properties.VkPhysicalDeviceVulkan11Properties.subgroupSupportedOperations.VK_SUBGROUP_FEATURE_VOTE_BIT) return true;
        },
        // GroupNonUniformArithmetic
        63 => {
            if (validation.additional_properties.VkPhysicalDeviceVulkan11Properties.subgroupSupportedOperations.VK_SUBGROUP_FEATURE_ARITHMETIC_BIT) return true;
        },
        // GroupNonUniformBallot
        64 => {
            if (validation.additional_properties.VkPhysicalDeviceVulkan11Properties.subgroupSupportedOperations.VK_SUBGROUP_FEATURE_BALLOT_BIT) return true;
        },
        // GroupNonUniformShuffle
        65 => {
            if (validation.additional_properties.VkPhysicalDeviceVulkan11Properties.subgroupSupportedOperations.VK_SUBGROUP_FEATURE_SHUFFLE_BIT) return true;
        },
        // GroupNonUniformShuffleRelative
        66 => {
            if (validation.additional_properties.VkPhysicalDeviceVulkan11Properties.subgroupSupportedOperations.VK_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT) return true;
        },
        // GroupNonUniformClustered
        67 => {
            if (validation.additional_properties.VkPhysicalDeviceVulkan11Properties.subgroupSupportedOperations.VK_SUBGROUP_FEATURE_CLUSTERED_BIT) return true;
        },
        // GroupNonUniformQuad
        68 => {
            if (validation.additional_properties.VkPhysicalDeviceVulkan11Properties.subgroupSupportedOperations.VK_SUBGROUP_FEATURE_QUAD_BIT) return true;
        },
        // ShaderLayer
        69 => {
            if (validation.additional_pdf.VkPhysicalDeviceVulkan12Features.shaderOutputLayer == vk.VK_TRUE) return true;
        },
        // ShaderViewportIndex
        70 => {
            if (validation.additional_pdf.VkPhysicalDeviceVulkan12Features.shaderOutputViewportIndex == vk.VK_TRUE) return true;
        },
        // CoreBuiltinsARM
        4165 => {
            if (validation.additional_pdf.VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM.shaderCoreBuiltins == vk.VK_TRUE) return true;
        },
        // TileImageColorReadAccessEXT
        4166 => {
            if (validation.additional_pdf.VkPhysicalDeviceShaderTileImageFeaturesEXT.shaderTileImageColorReadAccess == vk.VK_TRUE) return true;
        },
        // TileImageDepthReadAccessEXT
        4167 => {
            if (validation.additional_pdf.VkPhysicalDeviceShaderTileImageFeaturesEXT.shaderTileImageDepthReadAccess == vk.VK_TRUE) return true;
        },
        // TileImageStencilReadAccessEXT
        4168 => {
            if (validation.additional_pdf.VkPhysicalDeviceShaderTileImageFeaturesEXT.shaderTileImageStencilReadAccess == vk.VK_TRUE) return true;
        },
        // TensorsARM
        4174 => {
            if (validation.additional_pdf.VkPhysicalDeviceTensorFeaturesARM.shaderTensorAccess == vk.VK_TRUE) return true;
        },
        // StorageTensorArrayDynamicIndexingARM
        4175 => {
            if (validation.additional_pdf.VkPhysicalDeviceTensorFeaturesARM.shaderStorageTensorArrayDynamicIndexing == vk.VK_TRUE) return true;
        },
        // StorageTensorArrayNonUniformIndexingARM
        4176 => {
            if (validation.additional_pdf.VkPhysicalDeviceTensorFeaturesARM.shaderStorageTensorArrayNonUniformIndexing == vk.VK_TRUE) return true;
        },
        // GraphARM
        4191 => {
            if (validation.additional_pdf.VkPhysicalDeviceDataGraphFeaturesARM.dataGraph == vk.VK_TRUE) return true;
        },
        // Float8EXT
        4212 => {
            if (validation.additional_pdf.VkPhysicalDeviceShaderFloat8FeaturesEXT.shaderFloat8 == vk.VK_TRUE) return true;
        },
        // Float8CooperativeMatrixEXT
        4213 => {
            if (validation.additional_pdf.VkPhysicalDeviceShaderFloat8FeaturesEXT.shaderFloat8CooperativeMatrix == vk.VK_TRUE) return true;
        },
        // FragmentShadingRateKHR
        4422 => {
            if (validation.additional_pdf.VkPhysicalDeviceFragmentShadingRateFeaturesKHR.pipelineFragmentShadingRate == vk.VK_TRUE) return true;
            if (validation.additional_pdf.VkPhysicalDeviceFragmentShadingRateFeaturesKHR.primitiveFragmentShadingRate == vk.VK_TRUE) return true;
            if (validation.additional_pdf.VkPhysicalDeviceFragmentShadingRateFeaturesKHR.attachmentFragmentShadingRate == vk.VK_TRUE) return true;
        },
        // SubgroupBallotKHR
        4423 => {
            if (validation.extensions.device.VK_EXT_shader_subgroup_ballot) return true;
        },
        // DrawParameters
        4427 => {
            if (validation.additional_pdf.VkPhysicalDeviceVulkan11Features.shaderDrawParameters == vk.VK_TRUE) return true;
            if (validation.additional_pdf.VkPhysicalDeviceShaderDrawParametersFeatures.shaderDrawParameters == vk.VK_TRUE) return true;
            if (validation.extensions.device.VK_KHR_shader_draw_parameters) return true;
        },
        // WorkgroupMemoryExplicitLayoutKHR
        4428 => {
            if (validation.additional_pdf.VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR.workgroupMemoryExplicitLayout == vk.VK_TRUE) return true;
        },
        // WorkgroupMemoryExplicitLayout8BitAccessKHR
        4429 => {
            if (validation.additional_pdf.VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR.workgroupMemoryExplicitLayout8BitAccess == vk.VK_TRUE) return true;
        },
        // WorkgroupMemoryExplicitLayout16BitAccessKHR
        4430 => {
            if (validation.additional_pdf.VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR.workgroupMemoryExplicitLayout16BitAccess == vk.VK_TRUE) return true;
        },
        // SubgroupVoteKHR
        4431 => {
            if (validation.extensions.device.VK_EXT_shader_subgroup_vote) return true;
        },
        // StorageBuffer16BitAccess
        4433 => {
            if (validation.additional_pdf.VkPhysicalDeviceVulkan11Features.storageBuffer16BitAccess == vk.VK_TRUE) return true;
            if (validation.additional_pdf.VkPhysicalDevice16BitStorageFeatures.storageBuffer16BitAccess == vk.VK_TRUE) return true;
        },
        // UniformAndStorageBuffer16BitAccess
        4434 => {
            if (validation.additional_pdf.VkPhysicalDeviceVulkan11Features.uniformAndStorageBuffer16BitAccess == vk.VK_TRUE) return true;
            if (validation.additional_pdf.VkPhysicalDevice16BitStorageFeatures.uniformAndStorageBuffer16BitAccess == vk.VK_TRUE) return true;
        },
        // StoragePushConstant16
        4435 => {
            if (validation.additional_pdf.VkPhysicalDeviceVulkan11Features.storagePushConstant16 == vk.VK_TRUE) return true;
            if (validation.additional_pdf.VkPhysicalDevice16BitStorageFeatures.storagePushConstant16 == vk.VK_TRUE) return true;
        },
        // StorageInputOutput16
        4436 => {
            if (validation.additional_pdf.VkPhysicalDeviceVulkan11Features.storageInputOutput16 == vk.VK_TRUE) return true;
            if (validation.additional_pdf.VkPhysicalDevice16BitStorageFeatures.storageInputOutput16 == vk.VK_TRUE) return true;
        },
        // DeviceGroup
        4437 => {
            if (!validation.api_version.less(vk.VK_API_VERSION_1_1)) return true;
            if (validation.extensions.device.VK_KHR_device_group) return true;
        },
        // MultiView
        4439 => {
            if (validation.additional_pdf.VkPhysicalDeviceVulkan11Features.multiview == vk.VK_TRUE) return true;
            if (validation.additional_pdf.VkPhysicalDeviceMultiviewFeatures.multiview == vk.VK_TRUE) return true;
        },
        // VariablePointersStorageBuffer
        4441 => {
            if (validation.additional_pdf.VkPhysicalDeviceVulkan11Features.variablePointersStorageBuffer == vk.VK_TRUE) return true;
            if (validation.additional_pdf.VkPhysicalDeviceVariablePointersFeatures.variablePointersStorageBuffer == vk.VK_TRUE) return true;
        },
        // VariablePointers
        4442 => {
            if (validation.additional_pdf.VkPhysicalDeviceVulkan11Features.variablePointers == vk.VK_TRUE) return true;
            if (validation.additional_pdf.VkPhysicalDeviceVariablePointersFeatures.variablePointers == vk.VK_TRUE) return true;
        },
        // SampleMaskPostDepthCoverage
        4447 => {
            if (validation.extensions.device.VK_EXT_post_depth_coverage) return true;
        },
        // StorageBuffer8BitAccess
        4448 => {
            if (validation.additional_pdf.VkPhysicalDeviceVulkan12Features.storageBuffer8BitAccess == vk.VK_TRUE) return true;
        },
        // UniformAndStorageBuffer8BitAccess
        4449 => {
            if (validation.additional_pdf.VkPhysicalDeviceVulkan12Features.uniformAndStorageBuffer8BitAccess == vk.VK_TRUE) return true;
        },
        // StoragePushConstant8
        4450 => {
            if (validation.additional_pdf.VkPhysicalDeviceVulkan12Features.storagePushConstant8 == vk.VK_TRUE) return true;
        },
        // DenormPreserve
        4464 => {
            if (validation.additional_properties.VkPhysicalDeviceVulkan12Properties.shaderDenormPreserveFloat16 == vk.VK_TRUE) return true;
            if (validation.additional_properties.VkPhysicalDeviceVulkan12Properties.shaderDenormPreserveFloat32 == vk.VK_TRUE) return true;
            if (validation.additional_properties.VkPhysicalDeviceVulkan12Properties.shaderDenormPreserveFloat64 == vk.VK_TRUE) return true;
        },
        // DenormFlushToZero
        4465 => {
            if (validation.additional_properties.VkPhysicalDeviceVulkan12Properties.shaderDenormFlushToZeroFloat16 == vk.VK_TRUE) return true;
            if (validation.additional_properties.VkPhysicalDeviceVulkan12Properties.shaderDenormFlushToZeroFloat32 == vk.VK_TRUE) return true;
            if (validation.additional_properties.VkPhysicalDeviceVulkan12Properties.shaderDenormFlushToZeroFloat64 == vk.VK_TRUE) return true;
        },
        // SignedZeroInfNanPreserve
        4466 => {
            if (validation.additional_properties.VkPhysicalDeviceVulkan12Properties.shaderSignedZeroInfNanPreserveFloat16 == vk.VK_TRUE) return true;
            if (validation.additional_properties.VkPhysicalDeviceVulkan12Properties.shaderSignedZeroInfNanPreserveFloat32 == vk.VK_TRUE) return true;
            if (validation.additional_properties.VkPhysicalDeviceVulkan12Properties.shaderSignedZeroInfNanPreserveFloat64 == vk.VK_TRUE) return true;
        },
        // RoundingModeRTE
        4467 => {
            if (validation.additional_properties.VkPhysicalDeviceVulkan12Properties.shaderRoundingModeRTEFloat16 == vk.VK_TRUE) return true;
            if (validation.additional_properties.VkPhysicalDeviceVulkan12Properties.shaderRoundingModeRTEFloat32 == vk.VK_TRUE) return true;
            if (validation.additional_properties.VkPhysicalDeviceVulkan12Properties.shaderRoundingModeRTEFloat64 == vk.VK_TRUE) return true;
        },
        // RoundingModeRTZ
        4468 => {
            if (validation.additional_properties.VkPhysicalDeviceVulkan12Properties.shaderRoundingModeRTZFloat16 == vk.VK_TRUE) return true;
            if (validation.additional_properties.VkPhysicalDeviceVulkan12Properties.shaderRoundingModeRTZFloat32 == vk.VK_TRUE) return true;
            if (validation.additional_properties.VkPhysicalDeviceVulkan12Properties.shaderRoundingModeRTZFloat64 == vk.VK_TRUE) return true;
        },
        // RayQueryKHR
        4472 => {
            if (validation.additional_pdf.VkPhysicalDeviceRayQueryFeaturesKHR.rayQuery == vk.VK_TRUE) return true;
        },
        // UntypedPointersKHR
        4473 => {
            if (validation.additional_pdf.VkPhysicalDeviceShaderUntypedPointersFeaturesKHR.shaderUntypedPointers == vk.VK_TRUE) return true;
        },
        // RayTraversalPrimitiveCullingKHR
        4478 => {
            if (validation.additional_pdf.VkPhysicalDeviceRayTracingPipelineFeaturesKHR.rayTraversalPrimitiveCulling == vk.VK_TRUE) return true;
            if (validation.additional_pdf.VkPhysicalDeviceRayQueryFeaturesKHR.rayQuery == vk.VK_TRUE) return true;
        },
        // RayTracingKHR
        4479 => {
            if (validation.additional_pdf.VkPhysicalDeviceRayTracingPipelineFeaturesKHR.rayTracingPipeline == vk.VK_TRUE) return true;
        },
        // TextureSampleWeightedQCOM
        4484 => {
            if (validation.additional_pdf.VkPhysicalDeviceImageProcessingFeaturesQCOM.textureSampleWeighted == vk.VK_TRUE) return true;
        },
        // TextureBoxFilterQCOM
        4485 => {
            if (validation.additional_pdf.VkPhysicalDeviceImageProcessingFeaturesQCOM.textureBoxFilter == vk.VK_TRUE) return true;
        },
        // TextureBlockMatchQCOM
        4486 => {
            if (validation.additional_pdf.VkPhysicalDeviceImageProcessingFeaturesQCOM.textureBlockMatch == vk.VK_TRUE) return true;
        },
        // TileShadingQCOM
        4495 => {
            if (validation.additional_pdf.VkPhysicalDeviceTileShadingFeaturesQCOM.tileShading == vk.VK_TRUE) return true;
        },
        // TextureBlockMatch2QCOM
        4498 => {
            if (validation.additional_pdf.VkPhysicalDeviceImageProcessing2FeaturesQCOM.textureBlockMatch2 == vk.VK_TRUE) return true;
        },
        // ImageGatherBiasLodAMD
        5009 => {
            if (validation.extensions.device.VK_AMD_texture_gather_bias_lod) return true;
        },
        // FragmentMaskAMD
        5010 => {
            if (validation.extensions.device.VK_AMD_shader_fragment_mask) return true;
        },
        // StencilExportEXT
        5013 => {
            if (validation.extensions.device.VK_EXT_shader_stencil_export) return true;
        },
        // ImageReadWriteLodAMD
        5015 => {
            if (validation.extensions.device.VK_AMD_shader_image_load_store_lod) return true;
        },
        // Int64ImageEXT
        5016 => {
            if (validation.additional_pdf.VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT.shaderImageInt64Atomics == vk.VK_TRUE) return true;
        },
        // ShaderClockKHR
        5055 => {
            if (validation.extensions.device.VK_KHR_shader_clock) return true;
        },
        // ShaderEnqueueAMDX
        5067 => {
            if (validation.additional_pdf.VkPhysicalDeviceShaderEnqueueFeaturesAMDX.shaderEnqueue == vk.VK_TRUE) return true;
        },
        // QuadControlKHR
        5087 => {
            if (validation.additional_pdf.VkPhysicalDeviceShaderQuadControlFeaturesKHR.shaderQuadControl == vk.VK_TRUE) return true;
        },
        // BFloat16TypeKHR
        5116 => {
            if (validation.additional_pdf.VkPhysicalDeviceShaderBfloat16FeaturesKHR.shaderBFloat16Type == vk.VK_TRUE) return true;
        },
        // BFloat16DotProductKHR
        5117 => {
            if (validation.additional_pdf.VkPhysicalDeviceShaderBfloat16FeaturesKHR.shaderBFloat16DotProduct == vk.VK_TRUE) return true;
        },
        // BFloat16CooperativeMatrixKHR
        5118 => {
            if (validation.additional_pdf.VkPhysicalDeviceShaderBfloat16FeaturesKHR.shaderBFloat16CooperativeMatrix == vk.VK_TRUE) return true;
        },
        // SampleMaskOverrideCoverageNV
        5249 => {
            if (validation.extensions.device.VK_NV_sample_mask_override_coverage) return true;
        },
        // GeometryShaderPassthroughNV
        5251 => {
            if (validation.extensions.device.VK_NV_geometry_shader_passthrough) return true;
        },
        // ShaderViewportIndexLayerEXT
        5254 => {
            if (validation.extensions.device.VK_EXT_shader_viewport_index_layer) return true;
            if (validation.extensions.device.VK_NV_viewport_array2) return true;
        },
        // ShaderViewportMaskNV
        5255 => {
            if (validation.extensions.device.VK_NV_viewport_array2) return true;
        },
        // PerViewAttributesNV
        5260 => {
            if (validation.extensions.device.VK_NVX_multiview_per_view_attributes) return true;
        },
        // FragmentFullyCoveredEXT
        5265 => {
            if (validation.extensions.device.VK_EXT_conservative_rasterization) return true;
        },
        // MeshShadingNV
        5266 => {
            if (validation.extensions.device.VK_NV_mesh_shader) return true;
        },
        // ImageFootprintNV
        5282 => {
            if (validation.additional_pdf.VkPhysicalDeviceShaderImageFootprintFeaturesNV.imageFootprint == vk.VK_TRUE) return true;
        },
        // MeshShadingEXT
        5283 => {
            if (validation.extensions.device.VK_EXT_mesh_shader) return true;
        },
        // FragmentBarycentricKHR
        5284 => {
            if (validation.additional_pdf.VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR.fragmentShaderBarycentric == vk.VK_TRUE) return true;
            if (validation.additional_pdf.VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR.fragmentShaderBarycentric == vk.VK_TRUE) return true;
        },
        // ComputeDerivativeGroupQuadsKHR
        5288 => {
            if (validation.additional_pdf.VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR.computeDerivativeGroupQuads == vk.VK_TRUE) return true;
            if (validation.additional_pdf.VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR.computeDerivativeGroupQuads == vk.VK_TRUE) return true;
        },
        // FragmentDensityEXT
        5291 => {
            if (validation.additional_pdf.VkPhysicalDeviceFragmentDensityMapFeaturesEXT.fragmentDensityMap == vk.VK_TRUE) return true;
            if (validation.additional_pdf.VkPhysicalDeviceShadingRateImageFeaturesNV.shadingRateImage == vk.VK_TRUE) return true;
        },
        // GroupNonUniformPartitionedNV
        5297 => {
            if (validation.additional_properties.VkPhysicalDeviceVulkan11Properties.subgroupSupportedOperations.VK_SUBGROUP_FEATURE_PARTITIONED_BIT_NV) return true;
        },
        // ShaderNonUniform
        5301 => {
            if (!validation.api_version.less(vk.VK_API_VERSION_1_2)) return true;
            if (validation.extensions.device.VK_EXT_descriptor_indexing) return true;
        },
        // RuntimeDescriptorArray
        5302 => {
            if (validation.additional_pdf.VkPhysicalDeviceVulkan12Features.runtimeDescriptorArray == vk.VK_TRUE) return true;
        },
        // InputAttachmentArrayDynamicIndexing
        5303 => {
            if (validation.additional_pdf.VkPhysicalDeviceVulkan12Features.shaderInputAttachmentArrayDynamicIndexing == vk.VK_TRUE) return true;
        },
        // UniformTexelBufferArrayDynamicIndexing
        5304 => {
            if (validation.additional_pdf.VkPhysicalDeviceVulkan12Features.shaderUniformTexelBufferArrayDynamicIndexing == vk.VK_TRUE) return true;
        },
        // StorageTexelBufferArrayDynamicIndexing
        5305 => {
            if (validation.additional_pdf.VkPhysicalDeviceVulkan12Features.shaderStorageTexelBufferArrayDynamicIndexing == vk.VK_TRUE) return true;
        },
        // UniformBufferArrayNonUniformIndexing
        5306 => {
            if (validation.additional_pdf.VkPhysicalDeviceVulkan12Features.shaderUniformBufferArrayNonUniformIndexing == vk.VK_TRUE) return true;
        },
        // SampledImageArrayNonUniformIndexing
        5307 => {
            if (validation.additional_pdf.VkPhysicalDeviceVulkan12Features.shaderSampledImageArrayNonUniformIndexing == vk.VK_TRUE) return true;
        },
        // StorageBufferArrayNonUniformIndexing
        5308 => {
            if (validation.additional_pdf.VkPhysicalDeviceVulkan12Features.shaderStorageBufferArrayNonUniformIndexing == vk.VK_TRUE) return true;
        },
        // StorageImageArrayNonUniformIndexing
        5309 => {
            if (validation.additional_pdf.VkPhysicalDeviceVulkan12Features.shaderStorageImageArrayNonUniformIndexing == vk.VK_TRUE) return true;
        },
        // InputAttachmentArrayNonUniformIndexing
        5310 => {
            if (validation.additional_pdf.VkPhysicalDeviceVulkan12Features.shaderInputAttachmentArrayNonUniformIndexing == vk.VK_TRUE) return true;
        },
        // UniformTexelBufferArrayNonUniformIndexing
        5311 => {
            if (validation.additional_pdf.VkPhysicalDeviceVulkan12Features.shaderUniformTexelBufferArrayNonUniformIndexing == vk.VK_TRUE) return true;
        },
        // StorageTexelBufferArrayNonUniformIndexing
        5312 => {
            if (validation.additional_pdf.VkPhysicalDeviceVulkan12Features.shaderStorageTexelBufferArrayNonUniformIndexing == vk.VK_TRUE) return true;
        },
        // RayTracingPositionFetchKHR
        5336 => {
            if (validation.additional_pdf.VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR.rayTracingPositionFetch == vk.VK_TRUE) return true;
        },
        // RayTracingNV
        5340 => {
            if (validation.extensions.device.VK_NV_ray_tracing) return true;
        },
        // RayTracingMotionBlurNV
        5341 => {
            if (validation.additional_pdf.VkPhysicalDeviceRayTracingMotionBlurFeaturesNV.rayTracingMotionBlur == vk.VK_TRUE) return true;
        },
        // VulkanMemoryModel
        5345 => {
            if (validation.additional_pdf.VkPhysicalDeviceVulkan12Features.vulkanMemoryModel == vk.VK_TRUE) return true;
        },
        // VulkanMemoryModelDeviceScope
        5346 => {
            if (validation.additional_pdf.VkPhysicalDeviceVulkan12Features.vulkanMemoryModelDeviceScope == vk.VK_TRUE) return true;
        },
        // PhysicalStorageBufferAddresses
        5347 => {
            if (validation.additional_pdf.VkPhysicalDeviceVulkan12Features.bufferDeviceAddress == vk.VK_TRUE) return true;
            if (validation.additional_pdf.VkPhysicalDeviceBufferDeviceAddressFeaturesEXT.bufferDeviceAddress == vk.VK_TRUE) return true;
        },
        // ComputeDerivativeGroupLinearKHR
        5350 => {
            if (validation.additional_pdf.VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR.computeDerivativeGroupLinear == vk.VK_TRUE) return true;
            if (validation.additional_pdf.VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR.computeDerivativeGroupLinear == vk.VK_TRUE) return true;
        },
        // CooperativeMatrixNV
        5357 => {
            if (validation.additional_pdf.VkPhysicalDeviceCooperativeMatrixFeaturesNV.cooperativeMatrix == vk.VK_TRUE) return true;
        },
        // FragmentShaderSampleInterlockEXT
        5363 => {
            if (validation.additional_pdf.VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT.fragmentShaderSampleInterlock == vk.VK_TRUE) return true;
        },
        // FragmentShaderShadingRateInterlockEXT
        5372 => {
            if (validation.additional_pdf.VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT.fragmentShaderShadingRateInterlock == vk.VK_TRUE) return true;
            if (validation.additional_pdf.VkPhysicalDeviceShadingRateImageFeaturesNV.shadingRateImage == vk.VK_TRUE) return true;
        },
        // ShaderSMBuiltinsNV
        5373 => {
            if (validation.additional_pdf.VkPhysicalDeviceShaderSMBuiltinsFeaturesNV.shaderSMBuiltins == vk.VK_TRUE) return true;
        },
        // FragmentShaderPixelInterlockEXT
        5378 => {
            if (validation.additional_pdf.VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT.fragmentShaderPixelInterlock == vk.VK_TRUE) return true;
        },
        // DemoteToHelperInvocation
        5379 => {
            if (validation.additional_pdf.VkPhysicalDeviceVulkan13Features.shaderDemoteToHelperInvocation == vk.VK_TRUE) return true;
            if (validation.additional_pdf.VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures.shaderDemoteToHelperInvocation == vk.VK_TRUE) return true;
        },
        // RayTracingOpacityMicromapEXT
        5381 => {
            if (validation.extensions.device.VK_EXT_opacity_micromap) return true;
        },
        // ShaderInvocationReorderNV
        5383 => {
            if (validation.extensions.device.VK_NV_ray_tracing_invocation_reorder) return true;
        },
        // RayQueryPositionFetchKHR
        5391 => {
            if (validation.additional_pdf.VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR.rayTracingPositionFetch == vk.VK_TRUE) return true;
        },
        // CooperativeVectorNV
        5394 => {
            if (validation.additional_pdf.VkPhysicalDeviceCooperativeVectorFeaturesNV.cooperativeVector == vk.VK_TRUE) return true;
        },
        // AtomicFloat16VectorNV
        5404 => {
            if (validation.additional_pdf.VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV.shaderFloat16VectorAtomics == vk.VK_TRUE) return true;
        },
        // RawAccessChainsNV
        5414 => {
            if (validation.additional_pdf.VkPhysicalDeviceRawAccessChainsFeaturesNV.shaderRawAccessChains == vk.VK_TRUE) return true;
        },
        // RayTracingSpheresGeometryNV
        5418 => {
            if (validation.additional_pdf.VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV.spheres == vk.VK_TRUE) return true;
        },
        // RayTracingLinearSweptSpheresGeometryNV
        5419 => {
            if (validation.additional_pdf.VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV.linearSweptSpheres == vk.VK_TRUE) return true;
        },
        // CooperativeMatrixReductionsNV
        5430 => {
            if (validation.additional_pdf.VkPhysicalDeviceCooperativeMatrix2FeaturesNV.cooperativeMatrixReductions == vk.VK_TRUE) return true;
        },
        // CooperativeMatrixConversionsNV
        5431 => {
            if (validation.additional_pdf.VkPhysicalDeviceCooperativeMatrix2FeaturesNV.cooperativeMatrixConversions == vk.VK_TRUE) return true;
        },
        // CooperativeMatrixPerElementOperationsNV
        5432 => {
            if (validation.additional_pdf.VkPhysicalDeviceCooperativeMatrix2FeaturesNV.cooperativeMatrixPerElementOperations == vk.VK_TRUE) return true;
        },
        // CooperativeMatrixTensorAddressingNV
        5433 => {
            if (validation.additional_pdf.VkPhysicalDeviceCooperativeMatrix2FeaturesNV.cooperativeMatrixTensorAddressing == vk.VK_TRUE) return true;
        },
        // CooperativeMatrixBlockLoadsNV
        5434 => {
            if (validation.additional_pdf.VkPhysicalDeviceCooperativeMatrix2FeaturesNV.cooperativeMatrixBlockLoads == vk.VK_TRUE) return true;
        },
        // CooperativeVectorTrainingNV
        5435 => {
            if (validation.additional_pdf.VkPhysicalDeviceCooperativeVectorFeaturesNV.cooperativeVectorTraining == vk.VK_TRUE) return true;
        },
        // RayTracingClusterAccelerationStructureNV
        5437 => {
            if (validation.additional_pdf.VkPhysicalDeviceClusterAccelerationStructureFeaturesNV.clusterAccelerationStructure == vk.VK_TRUE) return true;
        },
        // TensorAddressingNV
        5439 => {
            if (validation.additional_pdf.VkPhysicalDeviceCooperativeMatrix2FeaturesNV.cooperativeMatrixTensorAddressing == vk.VK_TRUE) return true;
        },
        // IntegerFunctions2INTEL
        5584 => {
            if (validation.additional_pdf.VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL.shaderIntegerFunctions2 == vk.VK_TRUE) return true;
        },
        // AtomicFloat32MinMaxEXT
        5612 => {
            if (validation.additional_pdf.VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT.shaderBufferFloat32AtomicMinMax == vk.VK_TRUE) return true;
            if (validation.additional_pdf.VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT.shaderSharedFloat32AtomicMinMax == vk.VK_TRUE) return true;
            if (validation.additional_pdf.VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT.shaderImageFloat32AtomicMinMax == vk.VK_TRUE) return true;
        },
        // AtomicFloat64MinMaxEXT
        5613 => {
            if (validation.additional_pdf.VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT.shaderBufferFloat64AtomicMinMax == vk.VK_TRUE) return true;
            if (validation.additional_pdf.VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT.shaderSharedFloat64AtomicMinMax == vk.VK_TRUE) return true;
        },
        // AtomicFloat16MinMaxEXT
        5616 => {
            if (validation.additional_pdf.VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT.shaderBufferFloat16AtomicMinMax == vk.VK_TRUE) return true;
            if (validation.additional_pdf.VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT.shaderSharedFloat16AtomicMinMax == vk.VK_TRUE) return true;
        },
        // ExpectAssumeKHR
        5629 => {
            if (validation.additional_pdf.VkPhysicalDeviceVulkan14Features.shaderExpectAssume == vk.VK_TRUE) return true;
            if (validation.additional_pdf.VkPhysicalDeviceShaderExpectAssumeFeatures.shaderExpectAssume == vk.VK_TRUE) return true;
        },
        // DotProductInputAll
        6016 => {
            if (validation.additional_pdf.VkPhysicalDeviceVulkan13Features.shaderIntegerDotProduct == vk.VK_TRUE) return true;
            if (validation.additional_pdf.VkPhysicalDeviceShaderIntegerDotProductFeatures.shaderIntegerDotProduct == vk.VK_TRUE) return true;
        },
        // DotProductInput4x8Bit
        6017 => {
            if (validation.additional_pdf.VkPhysicalDeviceVulkan13Features.shaderIntegerDotProduct == vk.VK_TRUE) return true;
            if (validation.additional_pdf.VkPhysicalDeviceShaderIntegerDotProductFeatures.shaderIntegerDotProduct == vk.VK_TRUE) return true;
        },
        // DotProductInput4x8BitPacked
        6018 => {
            if (validation.additional_pdf.VkPhysicalDeviceVulkan13Features.shaderIntegerDotProduct == vk.VK_TRUE) return true;
            if (validation.additional_pdf.VkPhysicalDeviceShaderIntegerDotProductFeatures.shaderIntegerDotProduct == vk.VK_TRUE) return true;
        },
        // DotProduct
        6019 => {
            if (validation.additional_pdf.VkPhysicalDeviceVulkan13Features.shaderIntegerDotProduct == vk.VK_TRUE) return true;
            if (validation.additional_pdf.VkPhysicalDeviceShaderIntegerDotProductFeatures.shaderIntegerDotProduct == vk.VK_TRUE) return true;
        },
        // RayCullMaskKHR
        6020 => {
            if (validation.additional_pdf.VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR.rayTracingMaintenance1 == vk.VK_TRUE) return true;
        },
        // CooperativeMatrixKHR
        6022 => {
            if (validation.additional_pdf.VkPhysicalDeviceCooperativeMatrixFeaturesKHR.cooperativeMatrix == vk.VK_TRUE) return true;
        },
        // ReplicatedCompositesEXT
        6024 => {
            if (validation.additional_pdf.VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT.shaderReplicatedComposites == vk.VK_TRUE) return true;
        },
        // GroupNonUniformRotateKHR
        6026 => {
            if (validation.additional_pdf.VkPhysicalDeviceVulkan14Features.shaderSubgroupRotate == vk.VK_TRUE) return true;
            if (validation.additional_pdf.VkPhysicalDeviceShaderSubgroupRotateFeatures.shaderSubgroupRotate == vk.VK_TRUE) return true;
        },
        // FloatControls2
        6029 => {
            if (validation.additional_pdf.VkPhysicalDeviceVulkan14Features.shaderFloatControls2 == vk.VK_TRUE) return true;
            if (validation.additional_pdf.VkPhysicalDeviceShaderFloatControls2Features.shaderFloatControls2 == vk.VK_TRUE) return true;
        },
        // FMAKHR
        6030 => {
            if (validation.additional_pdf.VkPhysicalDeviceShaderFmaFeaturesKHR.shaderFmaFloat16 == vk.VK_TRUE) return true;
            if (validation.additional_pdf.VkPhysicalDeviceShaderFmaFeaturesKHR.shaderFmaFloat32 == vk.VK_TRUE) return true;
            if (validation.additional_pdf.VkPhysicalDeviceShaderFmaFeaturesKHR.shaderFmaFloat64 == vk.VK_TRUE) return true;
        },
        // AtomicFloat32AddEXT
        6033 => {
            if (validation.additional_pdf.VkPhysicalDeviceShaderAtomicFloatFeaturesEXT.shaderBufferFloat32AtomicAdd == vk.VK_TRUE) return true;
            if (validation.additional_pdf.VkPhysicalDeviceShaderAtomicFloatFeaturesEXT.shaderSharedFloat32AtomicAdd == vk.VK_TRUE) return true;
            if (validation.additional_pdf.VkPhysicalDeviceShaderAtomicFloatFeaturesEXT.shaderImageFloat32AtomicAdd == vk.VK_TRUE) return true;
        },
        // AtomicFloat64AddEXT
        6034 => {
            if (validation.additional_pdf.VkPhysicalDeviceShaderAtomicFloatFeaturesEXT.shaderBufferFloat64AtomicAdd == vk.VK_TRUE) return true;
            if (validation.additional_pdf.VkPhysicalDeviceShaderAtomicFloatFeaturesEXT.shaderSharedFloat64AtomicAdd == vk.VK_TRUE) return true;
        },
        // AtomicFloat16AddEXT
        6095 => {
            if (validation.additional_pdf.VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT.shaderBufferFloat16AtomicAdd == vk.VK_TRUE) return true;
            if (validation.additional_pdf.VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT.shaderSharedFloat16AtomicAdd == vk.VK_TRUE) return true;
        },
        else => |other| {
            log.debug(@src(), "Uknown SPRIV capability: {d}", .{other});
            return false;
        },
    }
    return false;
}
// From SPIRV-Headers/include/spirv/unified1/spirv.h
const SPIRV_MAX_VERSION = 0x10600;
const SPIRV_MAGIC_NUMBER = 0x07230203;
const SPIRV_OP_EXTENSION = 10;
const SPIRV_OP_CAPABILITY = 17;
const SPIRV_OP_FUNCTION = 54;

pub fn validate_shader_code(
    validation: *const Validation,
    create_info: *const vk.VkShaderModuleCreateInfo,
) bool {
    var code: []const u32 = undefined;
    code.ptr = create_info.pCode.?;
    code.len = create_info.codeSize / @sizeOf(u32);

    // Impossibly small shader
    if (code.len < 5) return false;
    if (code[0] != SPIRV_MAGIC_NUMBER) return false;

    const version = code[1];
    if (SPIRV_MAX_VERSION < version) return false;
    if (version == 0x10600 and validation.api_version.less(vk.VK_API_VERSION_1_3)) return false;
    if (version == 0x10500 and validation.api_version.less(vk.VK_API_VERSION_1_2)) return false;
    if (0x10400 <= version and
        (validation.api_version.less(vk.VK_API_VERSION_1_2) and
            !validation.extensions.device.VK_KHR_spirv_1_4)) return false;
    if (0x10300 <= version and validation.api_version.less(vk.VK_API_VERSION_1_1)) return false;
    if (0x10000 < version and validation.api_version.less(vk.VK_API_VERSION_1_1)) return false;

    var offset: usize = 5;
    while (offset < code.len) {
        const op: u32 = code[offset] & 0xffff;
        const count = (code[offset] >> 16) & 0xffff;

        if (count == 0) return false;
        if (code.len < offset + count) return false;

        if (op == SPIRV_OP_CAPABILITY) {
            if (count != 2) return false;

            const capability = code[offset + 1];
            if (!validate_spirv_capability(validation, capability)) {
                log.debug(@src(), "Invalid SPIR-V capability: {d}", .{capability});
                return false;
            }
        } else if (op == SPIRV_OP_EXTENSION ) {
            if (count < 2) return false;
            const byte_slice: [*c]const u8 = @ptrCast(code[offset + 1 ..].ptr);
            const name = std.mem.span(byte_slice);
            if (!validate_spirv_extension(validation, name)) {
                log.debug(@src(), "Invalid SPIR-V extension: {s}", .{name});
                return false;
            }
        } else if (op == SPIRV_OP_FUNCTION) {
            // Code starts here, stop validation
            break;
        }
        offset += count;
    }

    return true;
}
pub const Validation = struct {
    api_version: vk.ApiVersion = .{},
    extensions: Extensions = .{},
    pdf: vk.VkPhysicalDeviceFeatures2 = .{},
    additional_pdf: AdditionalPDF = .{},
    additional_properties: AdditionalProperties = .{},
};
