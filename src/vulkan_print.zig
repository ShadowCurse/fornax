// Copyright (c) 2025 Egor Lazarchuk
// SPDX-License-Identifier: MIT
//
// This file is auto generated by gen/vulkan_print_gen.zig

const std = @import("std");
const log = @import("log.zig");
const vk = @import("volk");

pub fn print_chain(chain: anytype) void {
    var current: ?*const anyopaque = chain;
    while (current) |c| {
        const base_struct: *const vk.VkBaseInStructure = @alignCast(@ptrCast(c));
        switch (base_struct.sType) {
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_DEVICE_MEMORY_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceVulkanMemoryModelFeatures = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceVertexAttributeDivisorFeaturesKHR = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceVariablePointersFeatures = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceUniformBufferStandardLayoutFeatures = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceTransformFeedbackFeaturesEXT = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_SHADING_FEATURES_QCOM => {
                const nn: *const vk.VkPhysicalDeviceTileShadingFeaturesQCOM = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TENSOR_FEATURES_ARM => {
                const nn: *const vk.VkPhysicalDeviceTensorFeaturesARM = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceSynchronization2FeaturesKHR = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceSubgroupSizeControlFeaturesEXT = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceShadingRateImageFeaturesNV = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceShaderTileImageFeaturesEXT = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_ROTATE_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceShaderSubgroupRotateFeaturesKHR = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceShaderSMBuiltinsFeaturesNV = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_REPLICATED_COMPOSITES_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_QUAD_CONTROL_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceShaderQuadControlFeaturesKHR = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceShaderObjectFeaturesEXT = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL => {
                const nn: *const vk.VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceShaderIntegerDotProductFeaturesKHR = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceShaderImageFootprintFeaturesNV = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT_CONTROLS_2_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceShaderFloatControls2FeaturesKHR = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT8_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceShaderFloat8FeaturesEXT = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceShaderFloat16Int8Features = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EXPECT_ASSUME_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceShaderExpectAssumeFeaturesKHR = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceShaderDrawParametersFeatures = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_FEATURES_ARM => {
                const nn: *const vk.VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceShaderClockFeaturesKHR = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_BFLOAT16_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceShaderBfloat16FeaturesKHR = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceShaderAtomicInt64Features = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceShaderAtomicFloatFeaturesEXT = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceScalarBlockLayoutFeaturesEXT = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceSamplerYcbcrConversionFeatures = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceRobustness2FeaturesEXT = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_POSITION_FETCH_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceRayTracingPipelineFeaturesKHR = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceRayTracingMotionBlurFeaturesNV = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_LINEAR_SWEPT_SPHERES_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceRayQueryFeaturesKHR = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAW_ACCESS_CHAINS_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceRawAccessChainsFeaturesNV = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceProvokingVertexFeaturesEXT = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDevicePipelineRobustnessFeaturesEXT = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDevicePipelineProtectedAccessFeaturesEXT = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_OPACITY_MICROMAP_FEATURES_ARM => {
                const nn: *const vk.VkPhysicalDevicePipelineOpacityMicromapFeaturesARM = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PER_STAGE_DESCRIPTOR_SET_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDevicePerStageDescriptorSetFeaturesNV = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PARTITIONED_ACCELERATION_STRUCTURE_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDevicePartitionedAccelerationStructureFeaturesNV = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceOpticalFlowFeaturesNV = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceOpacityMicromapFeaturesEXT = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceMultiviewFeatures = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceMeshShaderFeaturesNV = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceMeshShaderFeaturesEXT = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_7_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceMaintenance7FeaturesKHR = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceMaintenance5FeaturesKHR = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceMaintenance4FeaturesKHR = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceLineRasterizationFeaturesKHR = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceLegacyDitheringFeaturesEXT = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceInlineUniformBlockFeaturesEXT = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceImageRobustnessFeaturesEXT = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_FEATURES_QCOM => {
                const nn: *const vk.VkPhysicalDeviceImageProcessingFeaturesQCOM = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_FEATURES_QCOM => {
                const nn: *const vk.VkPhysicalDeviceImageProcessing2FeaturesQCOM = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceImage2DViewOf3DFeaturesEXT = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceFragmentShadingRateFeaturesKHR = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_LAYERED_FEATURES_VALVE => {
                const nn: *const vk.VkPhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceFragmentDensityMapFeaturesEXT = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2 => {
                const nn: *const vk.VkPhysicalDeviceFeatures2 = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceExtendedDynamicStateFeaturesEXT = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceExtendedDynamicState3FeaturesEXT = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceExtendedDynamicState2FeaturesEXT = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_LOCAL_READ_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceDynamicRenderingLocalReadFeaturesKHR = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceDynamicRenderingFeaturesKHR = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_COMPUTE_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceDescriptorIndexingFeatures = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceDescriptorBufferFeaturesEXT = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceDepthClipEnableFeaturesEXT = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceDepthClipControlFeaturesEXT = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_CONTROL_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceDepthClampControlFeaturesEXT = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_BIAS_CONTROL_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceDepthBiasControlFeaturesEXT = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceCustomBorderColorFeaturesEXT = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_VECTOR_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceCooperativeVectorFeaturesNV = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceCooperativeMatrixFeaturesNV = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceCooperativeMatrixFeaturesKHR = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_2_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceCooperativeMatrix2FeaturesNV = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceConditionalRenderingFeaturesEXT = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceColorWriteEnableFeaturesEXT = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_ACCELERATION_STRUCTURE_FEATURES_NV => {
                const nn: *const vk.VkPhysicalDeviceClusterAccelerationStructureFeaturesNV = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceBufferDeviceAddressFeaturesEXT = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES => {
                const nn: *const vk.VkPhysicalDeviceBufferDeviceAddressFeatures = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceBorderColorSwizzleFeaturesEXT = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_FEATURES_EXT => {
                const nn: *const vk.VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR => {
                const nn: *const vk.VkPhysicalDeviceAccelerationStructureFeaturesKHR = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES => {
                const nn: *const vk.VkPhysicalDevice8BitStorageFeatures = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            vk.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES => {
                const nn: *const vk.VkPhysicalDevice16BitStorageFeatures = @alignCast(@ptrCast(c));
                print_struct(nn);
                current = nn.pNext;
            },
            else => {
                log.warn(@src(), "Unknown struct sType: {d}", .{base_struct.sType});
                current = base_struct.pNext;
            },
        }
    }
}
pub fn print_struct(@"struct": anytype) void {
    print_struct_offset("", @"struct", 0);
}

fn print_struct_offset(name: []const u8, @"struct": anytype, base_offset: u32) void {
    const t = @typeInfo(@TypeOf(@"struct")).pointer.child;
    const type_name = @typeName(t)["cimport.struct_".len..];
    log.output("{s}: {s} = .{{\n", .{ name, type_name });
    const fields = @typeInfo(t).@"struct".fields;
    const fields_base_offset = base_offset + 1;
    inline for (fields) |field| {
        for (0..fields_base_offset) |_|
            log.output("    ", .{});
        switch (field.type) {
            i16, i32, u32, u64, usize, vk.VkStructureType => {
                log.output("{s}: {s} = {d},\n", .{
                    field.name,
                    @typeName(field.type),
                    @field(@"struct", field.name),
                });
            },
            f32, f64 => {
                log.output("{s}: {d},\n", .{ field.name, @field(@"struct", field.name) });
            },
            vk.VkOffset2D,
            vk.VkExtent2D,
            vk.VkOffset3D,
            vk.VkExtent3D,
            vk.VkPhysicalDeviceFeatures,
            => print_struct_offset(
                field.name,
                &@field(@"struct", field.name),
                fields_base_offset,
            ),
            ?*anyopaque,
            ?*const anyopaque,
            vk.VkPipelineLayout,
            vk.VkRenderPass,
            vk.VkPipeline,
            => {
                log.output("{s}: {?},\n", .{ field.name, @field(@"struct", field.name) });
            },
            [*c]const u8 => {
                log.output("{s}: {s},\n", .{ field.name, @field(@"struct", field.name) });
            },
            [*c]const u32 => {
                if (@hasField(t, "codeSize")) {
                    const len = @field(@"struct", "codeSize") / @sizeOf(u32);
                    log.output("{s}: {d} instructions,\n", .{ field.name, len });
                }
            },
            [*c]const vk.VkDescriptorSetLayoutBinding => {
                const len = @field(@"struct", "bindingCount");
                var elements: []const vk.VkDescriptorSetLayoutBinding = undefined;
                elements.ptr = @field(@"struct", field.name);
                elements.len = len;
                for (elements) |*binding|
                    print_struct_offset(field.name, binding, fields_base_offset);
            },
            [*c]const vk.VkDescriptorSetLayout => {
                const len = @field(@"struct", "setLayoutCount");
                var elements: []const *anyopaque = undefined;
                elements.ptr = @ptrCast(@field(@"struct", field.name));
                elements.len = len;
                log.output("{s}: {any},\n", .{ field.name, elements });
            },
            [*c]const vk.VkPushConstantRange => {
                const len = @field(@"struct", "pushConstantRangeCount");
                var elements: []const vk.VkPushConstantRange = undefined;
                elements.ptr = @field(@"struct", field.name);
                elements.len = len;
                for (elements) |*binding|
                    print_struct_offset(field.name, binding, fields_base_offset);
            },
            [*c]const vk.VkAttachmentDescription => {
                const len = @field(@"struct", "attachmentCount");
                var elements: []const vk.VkAttachmentDescription = undefined;
                elements.ptr = @field(@"struct", field.name);
                elements.len = len;
                for (elements) |*binding|
                    print_struct_offset(field.name, binding, fields_base_offset);
            },
            [*c]const vk.VkSubpassDescription => {
                const len = @field(@"struct", "subpassCount");
                var elements: []const vk.VkSubpassDescription = undefined;
                elements.ptr = @field(@"struct", field.name);
                elements.len = len;
                for (elements) |*binding|
                    print_struct_offset(field.name, binding, fields_base_offset);
            },
            [*c]const vk.VkAttachmentReference => {
                const len = if (std.mem.eql(u8, field.name, "pInputAttachments"))
                    @field(@"struct", "inputAttachmentCount")
                else if (std.mem.eql(u8, field.name, "pColorAttachments"))
                    @field(@"struct", "colorAttachmentCount")
                else if (std.mem.eql(u8, field.name, "pResolveAttachments")) blk: {
                    if (@field(@"struct", field.name) != null)
                        break :blk @field(@"struct", "colorAttachmentCount")
                    else
                        break :blk 0;
                } else if (std.mem.eql(u8, field.name, "pDepthStencilAttachment"))
                    @intFromBool(@field(@"struct", field.name) != null)
                else if (std.mem.eql(u8, field.name, "pPreserveAttachments"))
                    @field(@"struct", "preserveAttachmentCount")
                else
                    @panic("Cannot find length for the VkAttachmentReference array");

                if (len != 0) {
                    var elements: []const vk.VkAttachmentReference = undefined;
                    elements.ptr = @field(@"struct", field.name);
                    elements.len = len;
                    for (elements) |*binding|
                        print_struct_offset(field.name, binding, fields_base_offset);
                }
            },
            [*c]const vk.VkSubpassDependency => {
                const len = @field(@"struct", "dependencyCount");
                var elements: []const vk.VkSubpassDependency = undefined;
                elements.ptr = @field(@"struct", field.name);
                elements.len = len;
                for (elements) |*binding|
                    print_struct_offset(field.name, binding, fields_base_offset);
            },
            [*c]const vk.VkPipelineShaderStageCreateInfo => {
                const len = @field(@"struct", "stageCount");
                var elements: []const vk.VkPipelineShaderStageCreateInfo = undefined;
                elements.ptr = @field(@"struct", field.name);
                elements.len = len;
                for (elements) |*binding|
                    print_struct_offset(field.name, binding, fields_base_offset);
            },
            [*c]const vk.VkSpecializationMapEntry => {
                const len = @field(@"struct", "mapEntryCount");
                var elements: []const vk.VkSpecializationMapEntry = undefined;
                elements.ptr = @field(@"struct", field.name);
                elements.len = len;
                for (elements) |*binding|
                    print_struct_offset(field.name, binding, fields_base_offset);
            },

            [*c]const vk.VkPipelineVertexInputStateCreateInfo,
            [*c]const vk.VkPipelineInputAssemblyStateCreateInfo,
            [*c]const vk.VkPipelineTessellationStateCreateInfo,
            [*c]const vk.VkPipelineViewportStateCreateInfo,
            [*c]const vk.VkPipelineRasterizationStateCreateInfo,
            [*c]const vk.VkPipelineMultisampleStateCreateInfo,
            [*c]const vk.VkPipelineDepthStencilStateCreateInfo,
            [*c]const vk.VkPipelineColorBlendStateCreateInfo,
            [*c]const vk.VkPipelineDynamicStateCreateInfo,
            [*c]const vk.VkSpecializationInfo,
            [*c]const vk.VkViewport,
            [*c]const vk.VkRect2D,
            => {
                const element_type = @typeInfo(field.type).pointer.child;
                const element: ?*const element_type = @field(@"struct", field.name);
                if (element) |e|
                    print_struct_offset(field.name, e, fields_base_offset)
                else
                    log.output("{s}: {?},\n", .{ field.name, element });
            },
            else => log.warn(
                @src(),
                "Cannot format field {s} of type {s}",
                .{ field.name, @typeName(field.type) },
            ),
        }
    }
    for (0..base_offset) |_|
        log.output("    ", .{});
    log.output("}},\n", .{});
}
